!function(n,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.VPlayer=t():n.VPlayer=t()}("undefined"!=typeof self?self:this,function(){return function(n){function t(g){if(e[g])return e[g].exports;var I=e[g]={i:g,l:!1,exports:{}};return n[g].call(I.exports,I,I.exports,t),I.l=!0,I.exports}var e={};return t.m=n,t.c=e,t.d=function(n,e,g){t.o(n,e)||Object.defineProperty(n,e,{configurable:!1,enumerable:!0,get:g})},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},t.p="",t(t.s=5)}([function(module,exports,__webpack_require__){eval("/**\n * @license\n * Video.js 6.6.3 <http://videojs.com/>\n * Copyright Brightcove, Inc. <https://www.brightcove.com/>\n * Available under Apache License Version 2.0\n * <https://github.com/videojs/video.js/blob/master/LICENSE>\n *\n * Includes vtt.js <https://github.com/mozilla/vtt.js>\n * Available under Apache License Version 2.0\n * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>\n */\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar window = _interopDefault(__webpack_require__(1));\nvar document = _interopDefault(__webpack_require__(7));\nvar tsml = _interopDefault(__webpack_require__(9));\nvar safeParseTuple = _interopDefault(__webpack_require__(10));\nvar xhr = _interopDefault(__webpack_require__(11));\nvar vtt = _interopDefault(__webpack_require__(16));\n\nvar version = \"6.6.3\";\n\n/**\n * @file browser.js\n * @module browser\n */\nvar USER_AGENT = window.navigator && window.navigator.userAgent || '';\nvar webkitVersionMap = /AppleWebKit\\/([\\d.]+)/i.exec(USER_AGENT);\nvar appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;\n\n/*\n * Device is an iPhone\n *\n * @type {Boolean}\n * @constant\n * @private\n */\nvar IS_IPAD = /iPad/i.test(USER_AGENT);\n\n// The Facebook app's UIWebView identifies as both an iPhone and iPad, so\n// to identify iPhones, we need to exclude iPads.\n// http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/\nvar IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;\nvar IS_IPOD = /iPod/i.test(USER_AGENT);\nvar IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;\n\nvar IOS_VERSION = function () {\n  var match = USER_AGENT.match(/OS (\\d+)_/i);\n\n  if (match && match[1]) {\n    return match[1];\n  }\n  return null;\n}();\n\nvar IS_ANDROID = /Android/i.test(USER_AGENT);\nvar ANDROID_VERSION = function () {\n  // This matches Android Major.Minor.Patch versions\n  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned\n  var match = USER_AGENT.match(/Android (\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))*/i);\n\n  if (!match) {\n    return null;\n  }\n\n  var major = match[1] && parseFloat(match[1]);\n  var minor = match[2] && parseFloat(match[2]);\n\n  if (major && minor) {\n    return parseFloat(match[1] + '.' + match[2]);\n  } else if (major) {\n    return major;\n  }\n  return null;\n}();\n\n// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser\nvar IS_OLD_ANDROID = IS_ANDROID && /webkit/i.test(USER_AGENT) && ANDROID_VERSION < 2.3;\nvar IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;\n\nvar IS_FIREFOX = /Firefox/i.test(USER_AGENT);\nvar IS_EDGE = /Edge/i.test(USER_AGENT);\nvar IS_CHROME = !IS_EDGE && /Chrome/i.test(USER_AGENT);\nvar CHROME_VERSION = function () {\n  var match = USER_AGENT.match(/Chrome\\/(\\d+)/);\n\n  if (match && match[1]) {\n    return parseFloat(match[1]);\n  }\n  return null;\n}();\nvar IS_IE8 = /MSIE\\s8\\.0/.test(USER_AGENT);\nvar IE_VERSION = function () {\n  var result = /MSIE\\s(\\d+)\\.\\d/.exec(USER_AGENT);\n  var version = result && parseFloat(result[1]);\n\n  if (!version && /Trident\\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {\n    // IE 11 has a different user agent string than other IE versions\n    version = 11.0;\n  }\n\n  return version;\n}();\n\nvar IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;\nvar IS_ANY_SAFARI = IS_SAFARI || IS_IOS;\n\nvar TOUCH_ENABLED = isReal() && ('ontouchstart' in window || window.DocumentTouch && window.document instanceof window.DocumentTouch);\n\nvar BACKGROUND_SIZE_SUPPORTED = isReal() && 'backgroundSize' in window.document.createElement('video').style;\n\nvar browser = (Object.freeze || Object)({\n\tIS_IPAD: IS_IPAD,\n\tIS_IPHONE: IS_IPHONE,\n\tIS_IPOD: IS_IPOD,\n\tIS_IOS: IS_IOS,\n\tIOS_VERSION: IOS_VERSION,\n\tIS_ANDROID: IS_ANDROID,\n\tANDROID_VERSION: ANDROID_VERSION,\n\tIS_OLD_ANDROID: IS_OLD_ANDROID,\n\tIS_NATIVE_ANDROID: IS_NATIVE_ANDROID,\n\tIS_FIREFOX: IS_FIREFOX,\n\tIS_EDGE: IS_EDGE,\n\tIS_CHROME: IS_CHROME,\n\tCHROME_VERSION: CHROME_VERSION,\n\tIS_IE8: IS_IE8,\n\tIE_VERSION: IE_VERSION,\n\tIS_SAFARI: IS_SAFARI,\n\tIS_ANY_SAFARI: IS_ANY_SAFARI,\n\tTOUCH_ENABLED: TOUCH_ENABLED,\n\tBACKGROUND_SIZE_SUPPORTED: BACKGROUND_SIZE_SUPPORTED\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n\n\n\n\n\n\n\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar taggedTemplateLiteralLoose = function (strings, raw) {\n  strings.raw = raw;\n  return strings;\n};\n\n/**\n * @file obj.js\n * @module obj\n */\n\n/**\n * @callback obj:EachCallback\n *\n * @param {Mixed} value\n *        The current key for the object that is being iterated over.\n *\n * @param {string} key\n *        The current key-value for object that is being iterated over\n */\n\n/**\n * @callback obj:ReduceCallback\n *\n * @param {Mixed} accum\n *        The value that is accumulating over the reduce loop.\n *\n * @param {Mixed} value\n *        The current key for the object that is being iterated over.\n *\n * @param {string} key\n *        The current key-value for object that is being iterated over\n *\n * @return {Mixed}\n *         The new accumulated value.\n */\nvar toString = Object.prototype.toString;\n\n/**\n * Get the keys of an Object\n *\n * @param {Object}\n *        The Object to get the keys from\n *\n * @return {string[]}\n *         An array of the keys from the object. Returns an empty array if the\n *         object passed in was invalid or had no keys.\n *\n * @private\n */\nvar keys = function keys(object) {\n  return isObject(object) ? Object.keys(object) : [];\n};\n\n/**\n * Array-like iteration for objects.\n *\n * @param {Object} object\n *        The object to iterate over\n *\n * @param {obj:EachCallback} fn\n *        The callback function which is called for each key in the object.\n */\nfunction each(object, fn) {\n  keys(object).forEach(function (key) {\n    return fn(object[key], key);\n  });\n}\n\n/**\n * Array-like reduce for objects.\n *\n * @param {Object} object\n *        The Object that you want to reduce.\n *\n * @param {Function} fn\n *         A callback function which is called for each key in the object. It\n *         receives the accumulated value and the per-iteration value and key\n *         as arguments.\n *\n * @param {Mixed} [initial = 0]\n *        Starting value\n *\n * @return {Mixed}\n *         The final accumulated value.\n */\nfunction reduce(object, fn) {\n  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  return keys(object).reduce(function (accum, key) {\n    return fn(accum, object[key], key);\n  }, initial);\n}\n\n/**\n * Object.assign-style object shallow merge/extend.\n *\n * @param  {Object} target\n * @param  {Object} ...sources\n * @return {Object}\n */\nfunction assign(target) {\n  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  if (Object.assign) {\n    return Object.assign.apply(Object, [target].concat(sources));\n  }\n\n  sources.forEach(function (source) {\n    if (!source) {\n      return;\n    }\n\n    each(source, function (value, key) {\n      target[key] = value;\n    });\n  });\n\n  return target;\n}\n\n/**\n * Returns whether a value is an object of any kind - including DOM nodes,\n * arrays, regular expressions, etc. Not functions, though.\n *\n * This avoids the gotcha where using `typeof` on a `null` value\n * results in `'object'`.\n *\n * @param  {Object} value\n * @return {Boolean}\n */\nfunction isObject(value) {\n  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';\n}\n\n/**\n * Returns whether an object appears to be a \"plain\" object - that is, a\n * direct instance of `Object`.\n *\n * @param  {Object} value\n * @return {Boolean}\n */\nfunction isPlain(value) {\n  return isObject(value) && toString.call(value) === '[object Object]' && value.constructor === Object;\n}\n\n/**\n * @file log.js\n * @module log\n */\nvar log = void 0;\n\n// This is the private tracking variable for logging level.\nvar level = 'info';\n\n// This is the private tracking variable for the logging history.\nvar history = [];\n\n/**\n * Log messages to the console and history based on the type of message\n *\n * @private\n * @param  {string} type\n *         The name of the console method to use.\n *\n * @param  {Array} args\n *         The arguments to be passed to the matching console method.\n *\n * @param  {boolean} [stringify]\n *         By default, only old IEs should get console argument stringification,\n *         but this is exposed as a parameter to facilitate testing.\n */\nvar logByType = function logByType(type, args) {\n  var stringify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !!IE_VERSION && IE_VERSION < 11;\n\n  var lvl = log.levels[level];\n  var lvlRegExp = new RegExp('^(' + lvl + ')$');\n\n  if (type !== 'log') {\n\n    // Add the type to the front of the message when it's not \"log\".\n    args.unshift(type.toUpperCase() + ':');\n  }\n\n  // Add a clone of the args at this point to history.\n  if (history) {\n    history.push([].concat(args));\n  }\n\n  // Add console prefix after adding to history.\n  args.unshift('VIDEOJS:');\n\n  // If there's no console then don't try to output messages, but they will\n  // still be stored in history.\n  if (!window.console) {\n    return;\n  }\n\n  // Was setting these once outside of this function, but containing them\n  // in the function makes it easier to test cases where console doesn't exist\n  // when the module is executed.\n  var fn = window.console[type];\n\n  if (!fn && type === 'debug') {\n    // Certain browsers don't have support for console.debug. For those, we\n    // should default to the closest comparable log.\n    fn = window.console.info || window.console.log;\n  }\n\n  // Bail out if there's no console or if this type is not allowed by the\n  // current logging level.\n  if (!fn || !lvl || !lvlRegExp.test(type)) {\n    return;\n  }\n\n  // IEs previous to 11 log objects uselessly as \"[object Object]\"; so, JSONify\n  // objects and arrays for those less-capable browsers.\n  if (stringify) {\n    args = args.map(function (a) {\n      if (isObject(a) || Array.isArray(a)) {\n        try {\n          return JSON.stringify(a);\n        } catch (x) {\n          return String(a);\n        }\n      }\n\n      // Cast to string before joining, so we get null and undefined explicitly\n      // included in output (as we would in a modern console).\n      return String(a);\n    }).join(' ');\n  }\n\n  // Old IE versions do not allow .apply() for console methods (they are\n  // reported as objects rather than functions).\n  if (!fn.apply) {\n    fn(args);\n  } else {\n    fn[Array.isArray(args) ? 'apply' : 'call'](window.console, args);\n  }\n};\n\n/**\n * Logs plain debug messages. Similar to `console.log`.\n *\n * @class\n * @param    {Mixed[]} args\n *           One or more messages or objects that should be logged.\n */\nlog = function log() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  logByType('log', args);\n};\n\n/**\n * Enumeration of available logging levels, where the keys are the level names\n * and the values are `|`-separated strings containing logging methods allowed\n * in that logging level. These strings are used to create a regular expression\n * matching the function name being called.\n *\n * Levels provided by video.js are:\n *\n * - `off`: Matches no calls. Any value that can be cast to `false` will have\n *   this effect. The most restrictive.\n * - `all`: Matches only Video.js-provided functions (`debug`, `log`,\n *   `log.warn`, and `log.error`).\n * - `debug`: Matches `log.debug`, `log`, `log.warn`, and `log.error` calls.\n * - `info` (default): Matches `log`, `log.warn`, and `log.error` calls.\n * - `warn`: Matches `log.warn` and `log.error` calls.\n * - `error`: Matches only `log.error` calls.\n *\n * @type {Object}\n */\nlog.levels = {\n  all: 'debug|log|warn|error',\n  off: '',\n  debug: 'debug|log|warn|error',\n  info: 'log|warn|error',\n  warn: 'warn|error',\n  error: 'error',\n  DEFAULT: level\n};\n\n/**\n * Get or set the current logging level. If a string matching a key from\n * {@link log.levels} is provided, acts as a setter. Regardless of argument,\n * returns the current logging level.\n *\n * @param  {string} [lvl]\n *         Pass to set a new logging level.\n *\n * @return {string}\n *         The current logging level.\n */\nlog.level = function (lvl) {\n  if (typeof lvl === 'string') {\n    if (!log.levels.hasOwnProperty(lvl)) {\n      throw new Error('\"' + lvl + '\" in not a valid log level');\n    }\n    level = lvl;\n  }\n  return level;\n};\n\n/**\n * Returns an array containing everything that has been logged to the history.\n *\n * This array is a shallow clone of the internal history record. However, its\n * contents are _not_ cloned; so, mutating objects inside this array will\n * mutate them in history.\n *\n * @return {Array}\n */\nlog.history = function () {\n  return history ? [].concat(history) : [];\n};\n\n/**\n * Clears the internal history tracking, but does not prevent further history\n * tracking.\n */\nlog.history.clear = function () {\n  if (history) {\n    history.length = 0;\n  }\n};\n\n/**\n * Disable history tracking if it is currently enabled.\n */\nlog.history.disable = function () {\n  if (history !== null) {\n    history.length = 0;\n    history = null;\n  }\n};\n\n/**\n * Enable history tracking if it is currently disabled.\n */\nlog.history.enable = function () {\n  if (history === null) {\n    history = [];\n  }\n};\n\n/**\n * Logs error messages. Similar to `console.error`.\n *\n * @param {Mixed[]} args\n *        One or more messages or objects that should be logged as an error\n */\nlog.error = function () {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return logByType('error', args);\n};\n\n/**\n * Logs warning messages. Similar to `console.warn`.\n *\n * @param {Mixed[]} args\n *        One or more messages or objects that should be logged as a warning.\n */\nlog.warn = function () {\n  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  return logByType('warn', args);\n};\n\n/**\n * Logs debug messages. Similar to `console.debug`, but may also act as a comparable\n * log if `console.debug` is not available\n *\n * @param {Mixed[]} args\n *        One or more messages or objects that should be logged as debug.\n */\nlog.debug = function () {\n  for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    args[_key4] = arguments[_key4];\n  }\n\n  return logByType('debug', args);\n};\n\nvar log$1 = log;\n\n/**\n * @file computed-style.js\n * @module computed-style\n */\n/**\n * A safe getComputedStyle with an IE8 fallback.\n *\n * This is needed because in Firefox, if the player is loaded in an iframe with\n * `display:none`, then `getComputedStyle` returns `null`, so, we do a null-check to\n * make sure  that the player doesn't break in these cases.\n *\n * @param {Element} el\n *        The element you want the computed style of\n *\n * @param {string} prop\n *        The property name you want\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n *\n * @static\n * @const\n */\nfunction computedStyle(el, prop) {\n  if (!el || !prop) {\n    return '';\n  }\n\n  if (typeof window.getComputedStyle === 'function') {\n    var cs = window.getComputedStyle(el);\n\n    return cs ? cs[prop] : '';\n  }\n\n  return el.currentStyle[prop] || '';\n}\n\nvar _templateObject = taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.'], ['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.']);\n\n/**\n * @file dom.js\n * @module dom\n */\n/**\n * Detect if a value is a string with any non-whitespace characters.\n *\n * @param {string} str\n *        The string to check\n *\n * @return {boolean}\n *         - True if the string is non-blank\n *         - False otherwise\n *\n */\nfunction isNonBlankString(str) {\n  return typeof str === 'string' && /\\S/.test(str);\n}\n\n/**\n * Throws an error if the passed string has whitespace. This is used by\n * class methods to be relatively consistent with the classList API.\n *\n * @param {string} str\n *         The string to check for whitespace.\n *\n * @throws {Error}\n *         Throws an error if there is whitespace in the string.\n *\n */\nfunction throwIfWhitespace(str) {\n  if (/\\s/.test(str)) {\n    throw new Error('class has illegal whitespace characters');\n  }\n}\n\n/**\n * Produce a regular expression for matching a className within an elements className.\n *\n * @param {string} className\n *         The className to generate the RegExp for.\n *\n * @return {RegExp}\n *         The RegExp that will check for a specific `className` in an elements\n *         className.\n */\nfunction classRegExp(className) {\n  return new RegExp('(^|\\\\s)' + className + '($|\\\\s)');\n}\n\n/**\n * Whether the current DOM interface appears to be real.\n *\n * @return {Boolean}\n */\nfunction isReal() {\n  return (\n\n    // Both document and window will never be undefined thanks to `global`.\n    document === window.document &&\n\n    // In IE < 9, DOM methods return \"object\" as their type, so all we can\n    // confidently check is that it exists.\n    typeof document.createElement !== 'undefined'\n  );\n}\n\n/**\n * Determines, via duck typing, whether or not a value is a DOM element.\n *\n * @param {Mixed} value\n *        The thing to check\n *\n * @return {boolean}\n *         - True if it is a DOM element\n *         - False otherwise\n */\nfunction isEl(value) {\n  return isObject(value) && value.nodeType === 1;\n}\n\n/**\n * Determines if the current DOM is embedded in an iframe.\n *\n * @return {boolean}\n *\n */\nfunction isInFrame() {\n\n  // We need a try/catch here because Safari will throw errors when attempting\n  // to get either `parent` or `self`\n  try {\n    return window.parent !== window.self;\n  } catch (x) {\n    return true;\n  }\n}\n\n/**\n * Creates functions to query the DOM using a given method.\n *\n * @param {string} method\n *         The method to create the query with.\n *\n * @return {Function}\n *         The query method\n */\nfunction createQuerier(method) {\n  return function (selector, context) {\n    if (!isNonBlankString(selector)) {\n      return document[method](null);\n    }\n    if (isNonBlankString(context)) {\n      context = document.querySelector(context);\n    }\n\n    var ctx = isEl(context) ? context : document;\n\n    return ctx[method] && ctx[method](selector);\n  };\n}\n\n/**\n * Creates an element and applies properties.\n *\n * @param {string} [tagName='div']\n *         Name of tag to be created.\n *\n * @param {Object} [properties={}]\n *         Element properties to be applied.\n *\n * @param {Object} [attributes={}]\n *         Element attributes to be applied.\n *\n * @param {String|Element|TextNode|Array|Function} [content]\n *         Contents for the element (see: {@link dom:normalizeContent})\n *\n * @return {Element}\n *         The element that was created.\n */\nfunction createEl() {\n  var tagName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';\n  var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var content = arguments[3];\n\n  var el = document.createElement(tagName);\n\n  Object.getOwnPropertyNames(properties).forEach(function (propName) {\n    var val = properties[propName];\n\n    // See #2176\n    // We originally were accepting both properties and attributes in the\n    // same object, but that doesn't work so well.\n    if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {\n      log$1.warn(tsml(_templateObject, propName, val));\n      el.setAttribute(propName, val);\n\n      // Handle textContent since it's not supported everywhere and we have a\n      // method for it.\n    } else if (propName === 'textContent') {\n      textContent(el, val);\n    } else {\n      el[propName] = val;\n    }\n  });\n\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n    el.setAttribute(attrName, attributes[attrName]);\n  });\n\n  if (content) {\n    appendContent(el, content);\n  }\n\n  return el;\n}\n\n/**\n * Injects text into an element, replacing any existing contents entirely.\n *\n * @param {Element} el\n *        The element to add text content into\n *\n * @param {string} text\n *        The text content to add.\n *\n * @return {Element}\n *         The element with added text content.\n */\nfunction textContent(el, text) {\n  if (typeof el.textContent === 'undefined') {\n    el.innerText = text;\n  } else {\n    el.textContent = text;\n  }\n  return el;\n}\n\n/**\n * Insert an element as the first child node of another\n *\n * @param {Element} child\n *        Element to insert\n *\n * @param {Element} parent\n *        Element to insert child into\n */\nfunction prependTo(child, parent) {\n  if (parent.firstChild) {\n    parent.insertBefore(child, parent.firstChild);\n  } else {\n    parent.appendChild(child);\n  }\n}\n\n/**\n * Check if an element has a CSS class\n *\n * @param {Element} element\n *        Element to check\n *\n * @param {string} classToCheck\n *        Class name to check for\n *\n * @return {boolean}\n *         - True if the element had the class\n *         - False otherwise.\n *\n * @throws {Error}\n *         Throws an error if `classToCheck` has white space.\n */\nfunction hasClass(element, classToCheck) {\n  throwIfWhitespace(classToCheck);\n  if (element.classList) {\n    return element.classList.contains(classToCheck);\n  }\n  return classRegExp(classToCheck).test(element.className);\n}\n\n/**\n * Add a CSS class name to an element\n *\n * @param {Element} element\n *        Element to add class name to.\n *\n * @param {string} classToAdd\n *        Class name to add.\n *\n * @return {Element}\n *         The dom element with the added class name.\n */\nfunction addClass(element, classToAdd) {\n  if (element.classList) {\n    element.classList.add(classToAdd);\n\n    // Don't need to `throwIfWhitespace` here because `hasElClass` will do it\n    // in the case of classList not being supported.\n  } else if (!hasClass(element, classToAdd)) {\n    element.className = (element.className + ' ' + classToAdd).trim();\n  }\n\n  return element;\n}\n\n/**\n * Remove a CSS class name from an element\n *\n * @param {Element} element\n *        Element to remove a class name from.\n *\n * @param {string} classToRemove\n *        Class name to remove\n *\n * @return {Element}\n *         The dom element with class name removed.\n */\nfunction removeClass(element, classToRemove) {\n  if (element.classList) {\n    element.classList.remove(classToRemove);\n  } else {\n    throwIfWhitespace(classToRemove);\n    element.className = element.className.split(/\\s+/).filter(function (c) {\n      return c !== classToRemove;\n    }).join(' ');\n  }\n\n  return element;\n}\n\n/**\n * The callback definition for toggleElClass.\n *\n * @callback Dom~PredicateCallback\n * @param {Element} element\n *        The DOM element of the Component.\n *\n * @param {string} classToToggle\n *        The `className` that wants to be toggled\n *\n * @return {boolean|undefined}\n *         - If true the `classToToggle` will get added to `element`.\n *         - If false the `classToToggle` will get removed from `element`.\n *         - If undefined this callback will be ignored\n */\n\n/**\n * Adds or removes a CSS class name on an element depending on an optional\n * condition or the presence/absence of the class name.\n *\n * @param {Element} element\n *        The element to toggle a class name on.\n *\n * @param {string} classToToggle\n *        The class that should be toggled\n *\n * @param {boolean|PredicateCallback} [predicate]\n *        See the return value for {@link Dom~PredicateCallback}\n *\n * @return {Element}\n *         The element with a class that has been toggled.\n */\nfunction toggleClass(element, classToToggle, predicate) {\n\n  // This CANNOT use `classList` internally because IE does not support the\n  // second parameter to the `classList.toggle()` method! Which is fine because\n  // `classList` will be used by the add/remove functions.\n  var has = hasClass(element, classToToggle);\n\n  if (typeof predicate === 'function') {\n    predicate = predicate(element, classToToggle);\n  }\n\n  if (typeof predicate !== 'boolean') {\n    predicate = !has;\n  }\n\n  // If the necessary class operation matches the current state of the\n  // element, no action is required.\n  if (predicate === has) {\n    return;\n  }\n\n  if (predicate) {\n    addClass(element, classToToggle);\n  } else {\n    removeClass(element, classToToggle);\n  }\n\n  return element;\n}\n\n/**\n * Apply attributes to an HTML element.\n *\n * @param {Element} el\n *        Element to add attributes to.\n *\n * @param {Object} [attributes]\n *        Attributes to be applied.\n */\nfunction setAttributes(el, attributes) {\n  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n    var attrValue = attributes[attrName];\n\n    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {\n      el.removeAttribute(attrName);\n    } else {\n      el.setAttribute(attrName, attrValue === true ? '' : attrValue);\n    }\n  });\n}\n\n/**\n * Get an element's attribute values, as defined on the HTML tag\n * Attributes are not the same as properties. They're defined on the tag\n * or with setAttribute (which shouldn't be used with HTML)\n * This will return true or false for boolean attributes.\n *\n * @param {Element} tag\n *        Element from which to get tag attributes.\n *\n * @return {Object}\n *         All attributes of the element.\n */\nfunction getAttributes(tag) {\n  var obj = {};\n\n  // known boolean attributes\n  // we can check for matching boolean properties, but older browsers\n  // won't know about HTML5 boolean attributes that we still read from\n  var knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';\n\n  if (tag && tag.attributes && tag.attributes.length > 0) {\n    var attrs = tag.attributes;\n\n    for (var i = attrs.length - 1; i >= 0; i--) {\n      var attrName = attrs[i].name;\n      var attrVal = attrs[i].value;\n\n      // check for known booleans\n      // the matching element property will return a value for typeof\n      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {\n        // the value of an included boolean attribute is typically an empty\n        // string ('') which would equal false if we just check for a false value.\n        // we also don't want support bad code like autoplay='false'\n        attrVal = attrVal !== null ? true : false;\n      }\n\n      obj[attrName] = attrVal;\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Get the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to get the value of\n *\n * @return {string}\n *         value of the attribute\n */\nfunction getAttribute(el, attribute) {\n  return el.getAttribute(attribute);\n}\n\n/**\n * Set the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to set\n *\n * @param {string} value\n *        Value to set the attribute to\n */\nfunction setAttribute(el, attribute, value) {\n  el.setAttribute(attribute, value);\n}\n\n/**\n * Remove an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to remove\n */\nfunction removeAttribute(el, attribute) {\n  el.removeAttribute(attribute);\n}\n\n/**\n * Attempt to block the ability to select text while dragging controls\n */\nfunction blockTextSelection() {\n  document.body.focus();\n  document.onselectstart = function () {\n    return false;\n  };\n}\n\n/**\n * Turn off text selection blocking\n */\nfunction unblockTextSelection() {\n  document.onselectstart = function () {\n    return true;\n  };\n}\n\n/**\n * Identical to the native `getBoundingClientRect` function, but ensures that\n * the method is supported at all (it is in all browsers we claim to support)\n * and that the element is in the DOM before continuing.\n *\n * This wrapper function also shims properties which are not provided by some\n * older browsers (namely, IE8).\n *\n * Additionally, some browsers do not support adding properties to a\n * `ClientRect`/`DOMRect` object; so, we shallow-copy it with the standard\n * properties (except `x` and `y` which are not widely supported). This helps\n * avoid implementations where keys are non-enumerable.\n *\n * @param  {Element} el\n *         Element whose `ClientRect` we want to calculate.\n *\n * @return {Object|undefined}\n *         Always returns a plain\n */\nfunction getBoundingClientRect(el) {\n  if (el && el.getBoundingClientRect && el.parentNode) {\n    var rect = el.getBoundingClientRect();\n    var result = {};\n\n    ['bottom', 'height', 'left', 'right', 'top', 'width'].forEach(function (k) {\n      if (rect[k] !== undefined) {\n        result[k] = rect[k];\n      }\n    });\n\n    if (!result.height) {\n      result.height = parseFloat(computedStyle(el, 'height'));\n    }\n\n    if (!result.width) {\n      result.width = parseFloat(computedStyle(el, 'width'));\n    }\n\n    return result;\n  }\n}\n\n/**\n * The postion of a DOM element on the page.\n *\n * @typedef {Object} module:dom~Position\n *\n * @property {number} left\n *           Pixels to the left\n *\n * @property {number} top\n *           Pixels on top\n */\n\n/**\n * Offset Left.\n * getBoundingClientRect technique from\n * John Resig\n *\n * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/\n *\n * @param {Element} el\n *        Element from which to get offset\n *\n * @return {module:dom~Position}\n *         The position of the element that was passed in.\n */\nfunction findPosition(el) {\n  var box = void 0;\n\n  if (el.getBoundingClientRect && el.parentNode) {\n    box = el.getBoundingClientRect();\n  }\n\n  if (!box) {\n    return {\n      left: 0,\n      top: 0\n    };\n  }\n\n  var docEl = document.documentElement;\n  var body = document.body;\n\n  var clientLeft = docEl.clientLeft || body.clientLeft || 0;\n  var scrollLeft = window.pageXOffset || body.scrollLeft;\n  var left = box.left + scrollLeft - clientLeft;\n\n  var clientTop = docEl.clientTop || body.clientTop || 0;\n  var scrollTop = window.pageYOffset || body.scrollTop;\n  var top = box.top + scrollTop - clientTop;\n\n  // Android sometimes returns slightly off decimal values, so need to round\n  return {\n    left: Math.round(left),\n    top: Math.round(top)\n  };\n}\n\n/**\n * x and y coordinates for a dom element or mouse pointer\n *\n * @typedef {Object} Dom~Coordinates\n *\n * @property {number} x\n *           x coordinate in pixels\n *\n * @property {number} y\n *           y coordinate in pixels\n */\n\n/**\n * Get pointer position in element\n * Returns an object with x and y coordinates.\n * The base on the coordinates are the bottom left of the element.\n *\n * @param {Element} el\n *        Element on which to get the pointer position on\n *\n * @param {EventTarget~Event} event\n *        Event object\n *\n * @return {Dom~Coordinates}\n *         A Coordinates object corresponding to the mouse position.\n *\n */\nfunction getPointerPosition(el, event) {\n  var position = {};\n  var box = findPosition(el);\n  var boxW = el.offsetWidth;\n  var boxH = el.offsetHeight;\n\n  var boxY = box.top;\n  var boxX = box.left;\n  var pageY = event.pageY;\n  var pageX = event.pageX;\n\n  if (event.changedTouches) {\n    pageX = event.changedTouches[0].pageX;\n    pageY = event.changedTouches[0].pageY;\n  }\n\n  position.y = Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));\n  position.x = Math.max(0, Math.min(1, (pageX - boxX) / boxW));\n\n  return position;\n}\n\n/**\n * Determines, via duck typing, whether or not a value is a text node.\n *\n * @param {Mixed} value\n *        Check if this value is a text node.\n *\n * @return {boolean}\n *         - True if it is a text node\n *         - False otherwise\n */\nfunction isTextNode(value) {\n  return isObject(value) && value.nodeType === 3;\n}\n\n/**\n * Empties the contents of an element.\n *\n * @param {Element} el\n *        The element to empty children from\n *\n * @return {Element}\n *         The element with no children\n */\nfunction emptyEl(el) {\n  while (el.firstChild) {\n    el.removeChild(el.firstChild);\n  }\n  return el;\n}\n\n/**\n * Normalizes content for eventual insertion into the DOM.\n *\n * This allows a wide range of content definition methods, but protects\n * from falling into the trap of simply writing to `innerHTML`, which is\n * an XSS concern.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        - String: Normalized into a text node.\n *        - Element/TextNode: Passed through.\n *        - Array: A one-dimensional array of strings, elements, nodes, or functions\n *          (which return single strings, elements, or nodes).\n *        - Function: If the sole argument, is expected to produce a string, element,\n *          node, or array as defined above.\n *\n * @return {Array}\n *         All of the content that was passed in normalized.\n */\nfunction normalizeContent(content) {\n\n  // First, invoke content if it is a function. If it produces an array,\n  // that needs to happen before normalization.\n  if (typeof content === 'function') {\n    content = content();\n  }\n\n  // Next up, normalize to an array, so one or many items can be normalized,\n  // filtered, and returned.\n  return (Array.isArray(content) ? content : [content]).map(function (value) {\n\n    // First, invoke value if it is a function to produce a new value,\n    // which will be subsequently normalized to a Node of some kind.\n    if (typeof value === 'function') {\n      value = value();\n    }\n\n    if (isEl(value) || isTextNode(value)) {\n      return value;\n    }\n\n    if (typeof value === 'string' && /\\S/.test(value)) {\n      return document.createTextNode(value);\n    }\n  }).filter(function (value) {\n    return value;\n  });\n}\n\n/**\n * Normalizes and appends content to an element.\n *\n * @param {Element} el\n *        Element to append normalized content to.\n *\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with appended normalized content.\n */\nfunction appendContent(el, content) {\n  normalizeContent(content).forEach(function (node) {\n    return el.appendChild(node);\n  });\n  return el;\n}\n\n/**\n * Normalizes and inserts content into an element; this is identical to\n * `appendContent()`, except it empties the element first.\n *\n * @param {Element} el\n *        Element to insert normalized content into.\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with inserted normalized content.\n *\n */\nfunction insertContent(el, content) {\n  return appendContent(emptyEl(el), content);\n}\n\n/**\n * Check if event was a single left click\n *\n * @param {EventTarget~Event} event\n *        Event object\n *\n * @return {boolean}\n *         - True if a left click\n *         - False if not a left click\n */\nfunction isSingleLeftClick(event) {\n  // Note: if you create something draggable, be sure to\n  // call it on both `mousedown` and `mousemove` event,\n  // otherwise `mousedown` should be enough for a button\n\n  if (event.button === undefined && event.buttons === undefined) {\n    // Why do we need `butttons` ?\n    // Because, middle mouse sometimes have this:\n    // e.button === 0 and e.buttons === 4\n    // Furthermore, we want to prevent combination click, something like\n    // HOLD middlemouse then left click, that would be\n    // e.button === 0, e.buttons === 5\n    // just `button` is not gonna work\n\n    // Alright, then what this block does ?\n    // this is for chrome `simulate mobile devices`\n    // I want to support this as well\n\n    return true;\n  }\n\n  if (event.button === 0 && event.buttons === undefined) {\n    // Touch screen, sometimes on some specific device, `buttons`\n    // doesn't have anything (safari on ios, blackberry...)\n\n    return true;\n  }\n\n  if (IE_VERSION === 9) {\n    // Ignore IE9\n\n    return true;\n  }\n\n  if (event.button !== 0 || event.buttons !== 1) {\n    // This is the reason we have those if else block above\n    // if any special case we can catch and let it slide\n    // we do it above, when get to here, this definitely\n    // is-not-left-click\n\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Finds a single DOM element matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *        A valid CSS selector, which will be passed to `querySelector`.\n *\n * @param {Element|String} [context=document]\n *        A DOM element within which to query. Can also be a selector\n *        string in which case the first matching element will be used\n *        as context. If missing (or no element matches selector), falls\n *        back to `document`.\n *\n * @return {Element|null}\n *         The element that was found or null.\n */\nvar $ = createQuerier('querySelector');\n\n/**\n * Finds a all DOM elements matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *           A valid CSS selector, which will be passed to `querySelectorAll`.\n *\n * @param {Element|String} [context=document]\n *           A DOM element within which to query. Can also be a selector\n *           string in which case the first matching element will be used\n *           as context. If missing (or no element matches selector), falls\n *           back to `document`.\n *\n * @return {NodeList}\n *         A element list of elements that were found. Will be empty if none were found.\n *\n */\nvar $$ = createQuerier('querySelectorAll');\n\n\n\nvar Dom = (Object.freeze || Object)({\n\tisReal: isReal,\n\tisEl: isEl,\n\tisInFrame: isInFrame,\n\tcreateEl: createEl,\n\ttextContent: textContent,\n\tprependTo: prependTo,\n\thasClass: hasClass,\n\taddClass: addClass,\n\tremoveClass: removeClass,\n\ttoggleClass: toggleClass,\n\tsetAttributes: setAttributes,\n\tgetAttributes: getAttributes,\n\tgetAttribute: getAttribute,\n\tsetAttribute: setAttribute,\n\tremoveAttribute: removeAttribute,\n\tblockTextSelection: blockTextSelection,\n\tunblockTextSelection: unblockTextSelection,\n\tgetBoundingClientRect: getBoundingClientRect,\n\tfindPosition: findPosition,\n\tgetPointerPosition: getPointerPosition,\n\tisTextNode: isTextNode,\n\temptyEl: emptyEl,\n\tnormalizeContent: normalizeContent,\n\tappendContent: appendContent,\n\tinsertContent: insertContent,\n\tisSingleLeftClick: isSingleLeftClick,\n\t$: $,\n\t$$: $$\n});\n\n/**\n * @file guid.js\n * @module guid\n */\n\n/**\n * Unique ID for an element or function\n * @type {Number}\n */\nvar _guid = 1;\n\n/**\n * Get a unique auto-incrementing ID by number that has not been returned before.\n *\n * @return {number}\n *         A new unique ID.\n */\nfunction newGUID() {\n  return _guid++;\n}\n\n/**\n * @file dom-data.js\n * @module dom-data\n */\n/**\n * Element Data Store.\n *\n * Allows for binding data to an element without putting it directly on the\n * element. Ex. Event listeners are stored here.\n * (also from jsninja.com, slightly modified and updated for closure compiler)\n *\n * @type {Object}\n * @private\n */\nvar elData = {};\n\n/*\n * Unique attribute name to store an element's guid in\n *\n * @type {String}\n * @constant\n * @private\n */\nvar elIdAttr = 'vdata' + new Date().getTime();\n\n/**\n * Returns the cache object where data for an element is stored\n *\n * @param {Element} el\n *        Element to store data for.\n *\n * @return {Object}\n *         The cache object for that el that was passed in.\n */\nfunction getData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    id = el[elIdAttr] = newGUID();\n  }\n\n  if (!elData[id]) {\n    elData[id] = {};\n  }\n\n  return elData[id];\n}\n\n/**\n * Returns whether or not an element has cached data\n *\n * @param {Element} el\n *        Check if this element has cached data.\n *\n * @return {boolean}\n *         - True if the DOM element has cached data.\n *         - False otherwise.\n */\nfunction hasData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    return false;\n  }\n\n  return !!Object.getOwnPropertyNames(elData[id]).length;\n}\n\n/**\n * Delete data for the element from the cache and the guid attr from getElementById\n *\n * @param {Element} el\n *        Remove cached data for this element.\n */\nfunction removeData(el) {\n  var id = el[elIdAttr];\n\n  if (!id) {\n    return;\n  }\n\n  // Remove all stored data\n  delete elData[id];\n\n  // Remove the elIdAttr property from the DOM node\n  try {\n    delete el[elIdAttr];\n  } catch (e) {\n    if (el.removeAttribute) {\n      el.removeAttribute(elIdAttr);\n    } else {\n      // IE doesn't appear to support removeAttribute on the document element\n      el[elIdAttr] = null;\n    }\n  }\n}\n\n/**\n * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\n * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\n * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\n * robust as jquery's, so there's probably some differences.\n *\n * @module events\n */\n\n/**\n * Clean up the listener cache and dispatchers\n *\n * @param {Element|Object} elem\n *        Element to clean up\n *\n * @param {string} type\n *        Type of event to clean up\n */\nfunction _cleanUpEvents(elem, type) {\n  var data = getData(elem);\n\n  // Remove the events of a particular type if there are none left\n  if (data.handlers[type].length === 0) {\n    delete data.handlers[type];\n    // data.handlers[type] = null;\n    // Setting to null was causing an error with data.handlers\n\n    // Remove the meta-handler from the element\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, data.dispatcher, false);\n    } else if (elem.detachEvent) {\n      elem.detachEvent('on' + type, data.dispatcher);\n    }\n  }\n\n  // Remove the events object if there are no types left\n  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {\n    delete data.handlers;\n    delete data.dispatcher;\n    delete data.disabled;\n  }\n\n  // Finally remove the element data if there is no data left\n  if (Object.getOwnPropertyNames(data).length === 0) {\n    removeData(elem);\n  }\n}\n\n/**\n * Loops through an array of event types and calls the requested method for each type.\n *\n * @param {Function} fn\n *        The event method we want to use.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} callback\n *        Event listener.\n */\nfunction _handleMultipleEvents(fn, elem, types, callback) {\n  types.forEach(function (type) {\n    // Call the event method for each one of the types\n    fn(elem, type, callback);\n  });\n}\n\n/**\n * Fix a native event to have standard property values\n *\n * @param {Object} event\n *        Event object to fix.\n *\n * @return {Object}\n *         Fixed event object.\n */\nfunction fixEvent(event) {\n\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  }\n\n  // Test if fixing up is needed\n  // Used to check if !event.stopPropagation instead of isPropagationStopped\n  // But native events return true for stopPropagation, but don't have\n  // other expected methods like isPropagationStopped. Seems to be a problem\n  // with the Javascript Ninja code. So we're just overriding all events now.\n  if (!event || !event.isPropagationStopped) {\n    var old = event || window.event;\n\n    event = {};\n    // Clone the old object so that we can modify the values event = {};\n    // IE8 Doesn't like when you mess with native event properties\n    // Firefox returns false for event.hasOwnProperty('type') and other props\n    //  which makes copying more difficult.\n    // TODO: Probably best to create a whitelist of event props\n    for (var key in old) {\n      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\n      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation\n      // and webkitMovementX/Y\n      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {\n        // Chrome 32+ warns if you try to copy deprecated returnValue, but\n        // we still want to if preventDefault isn't supported (IE8).\n        if (!(key === 'returnValue' && old.preventDefault)) {\n          event[key] = old[key];\n        }\n      }\n    }\n\n    // The event occurred on this element\n    if (!event.target) {\n      event.target = event.srcElement || document;\n    }\n\n    // Handle which other element the event is related to\n    if (!event.relatedTarget) {\n      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\n    }\n\n    // Stop the default browser action\n    event.preventDefault = function () {\n      if (old.preventDefault) {\n        old.preventDefault();\n      }\n      event.returnValue = false;\n      old.returnValue = false;\n      event.defaultPrevented = true;\n    };\n\n    event.defaultPrevented = false;\n\n    // Stop the event from bubbling\n    event.stopPropagation = function () {\n      if (old.stopPropagation) {\n        old.stopPropagation();\n      }\n      event.cancelBubble = true;\n      old.cancelBubble = true;\n      event.isPropagationStopped = returnTrue;\n    };\n\n    event.isPropagationStopped = returnFalse;\n\n    // Stop the event from bubbling and executing other handlers\n    event.stopImmediatePropagation = function () {\n      if (old.stopImmediatePropagation) {\n        old.stopImmediatePropagation();\n      }\n      event.isImmediatePropagationStopped = returnTrue;\n      event.stopPropagation();\n    };\n\n    event.isImmediatePropagationStopped = returnFalse;\n\n    // Handle mouse position\n    if (event.clientX !== null && event.clientX !== undefined) {\n      var doc = document.documentElement;\n      var body = document.body;\n\n      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n    }\n\n    // Handle key presses\n    event.which = event.charCode || event.keyCode;\n\n    // Fix button for mouse clicks:\n    // 0 == left; 1 == middle; 2 == right\n    if (event.button !== null && event.button !== undefined) {\n\n      // The following is disabled because it does not pass videojs-standard\n      // and... yikes.\n      /* eslint-disable */\n      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;\n      /* eslint-enable */\n    }\n  }\n\n  // Returns fixed-up instance\n  return event;\n}\n\n/**\n * Whether passive event listeners are supported\n */\nvar _supportsPassive = false;\n\n(function () {\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        _supportsPassive = true;\n      }\n    });\n\n    window.addEventListener('test', null, opts);\n    window.removeEventListener('test', null, opts);\n  } catch (e) {\n    // disregard\n  }\n})();\n\n/**\n * Touch events Chrome expects to be passive\n */\nvar passiveEvents = ['touchstart', 'touchmove'];\n\n/**\n * Add an event listener to element\n * It stores the handler function in a separate cache object\n * and adds a generic handler to the element's event,\n * along with a unique id (guid) to the element.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string|string[]} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} fn\n *        Event listener.\n */\nfunction on(elem, type, fn) {\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(on, elem, type, fn);\n  }\n\n  var data = getData(elem);\n\n  // We need a place to store all our handler data\n  if (!data.handlers) {\n    data.handlers = {};\n  }\n\n  if (!data.handlers[type]) {\n    data.handlers[type] = [];\n  }\n\n  if (!fn.guid) {\n    fn.guid = newGUID();\n  }\n\n  data.handlers[type].push(fn);\n\n  if (!data.dispatcher) {\n    data.disabled = false;\n\n    data.dispatcher = function (event, hash) {\n\n      if (data.disabled) {\n        return;\n      }\n\n      event = fixEvent(event);\n\n      var handlers = data.handlers[event.type];\n\n      if (handlers) {\n        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\n        var handlersCopy = handlers.slice(0);\n\n        for (var m = 0, n = handlersCopy.length; m < n; m++) {\n          if (event.isImmediatePropagationStopped()) {\n            break;\n          } else {\n            try {\n              handlersCopy[m].call(elem, event, hash);\n            } catch (e) {\n              log$1.error(e);\n            }\n          }\n        }\n      }\n    };\n  }\n\n  if (data.handlers[type].length === 1) {\n    if (elem.addEventListener) {\n      var options = false;\n\n      if (_supportsPassive && passiveEvents.indexOf(type) > -1) {\n        options = { passive: true };\n      }\n      elem.addEventListener(type, data.dispatcher, options);\n    } else if (elem.attachEvent) {\n      elem.attachEvent('on' + type, data.dispatcher);\n    }\n  }\n}\n\n/**\n * Removes event listeners from an element\n *\n * @param {Element|Object} elem\n *        Object to remove listeners from.\n *\n * @param {string|string[]} [type]\n *        Type of listener to remove. Don't include to remove all events from element.\n *\n * @param {EventTarget~EventListener} [fn]\n *        Specific listener to remove. Don't include to remove listeners for an event\n *        type.\n */\nfunction off(elem, type, fn) {\n  // Don't want to add a cache object through getElData if not needed\n  if (!hasData(elem)) {\n    return;\n  }\n\n  var data = getData(elem);\n\n  // If no events exist, nothing to unbind\n  if (!data.handlers) {\n    return;\n  }\n\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(off, elem, type, fn);\n  }\n\n  // Utility function\n  var removeType = function removeType(el, t) {\n    data.handlers[t] = [];\n    _cleanUpEvents(el, t);\n  };\n\n  // Are we removing all bound events?\n  if (type === undefined) {\n    for (var t in data.handlers) {\n      if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {\n        removeType(elem, t);\n      }\n    }\n    return;\n  }\n\n  var handlers = data.handlers[type];\n\n  // If no handlers exist, nothing to unbind\n  if (!handlers) {\n    return;\n  }\n\n  // If no listener was provided, remove all listeners for type\n  if (!fn) {\n    removeType(elem, type);\n    return;\n  }\n\n  // We're only removing a single handler\n  if (fn.guid) {\n    for (var n = 0; n < handlers.length; n++) {\n      if (handlers[n].guid === fn.guid) {\n        handlers.splice(n--, 1);\n      }\n    }\n  }\n\n  _cleanUpEvents(elem, type);\n}\n\n/**\n * Trigger an event for an element\n *\n * @param {Element|Object} elem\n *        Element to trigger an event on\n *\n * @param {EventTarget~Event|string} event\n *        A string (the type) or an event object with a type attribute\n *\n * @param {Object} [hash]\n *        data hash to pass along with the event\n *\n * @return {boolean|undefined}\n *         - Returns the opposite of `defaultPrevented` if default was prevented\n *         - Otherwise returns undefined\n */\nfunction trigger(elem, event, hash) {\n  // Fetches element data and a reference to the parent (for bubbling).\n  // Don't want to add a data object to cache for every parent,\n  // so checking hasElData first.\n  var elemData = hasData(elem) ? getData(elem) : {};\n  var parent = elem.parentNode || elem.ownerDocument;\n  // type = event.type || event,\n  // handler;\n\n  // If an event name was passed as a string, creates an event out of it\n  if (typeof event === 'string') {\n    event = { type: event, target: elem };\n  }\n  // Normalizes the event properties.\n  event = fixEvent(event);\n\n  // If the passed element has a dispatcher, executes the established handlers.\n  if (elemData.dispatcher) {\n    elemData.dispatcher.call(elem, event, hash);\n  }\n\n  // Unless explicitly stopped or the event does not bubble (e.g. media events)\n  // recursively calls this function to bubble the event up the DOM.\n  if (parent && !event.isPropagationStopped() && event.bubbles === true) {\n    trigger.call(null, parent, event, hash);\n\n    // If at the top of the DOM, triggers the default action unless disabled.\n  } else if (!parent && !event.defaultPrevented) {\n    var targetData = getData(event.target);\n\n    // Checks if the target has a default action for this event.\n    if (event.target[event.type]) {\n      // Temporarily disables event dispatching on the target as we have already executed the handler.\n      targetData.disabled = true;\n      // Executes the default action.\n      if (typeof event.target[event.type] === 'function') {\n        event.target[event.type]();\n      }\n      // Re-enables event dispatching.\n      targetData.disabled = false;\n    }\n  }\n\n  // Inform the triggerer if the default was prevented by returning false\n  return !event.defaultPrevented;\n}\n\n/**\n * Trigger a listener only once for an event\n *\n * @param {Element|Object} elem\n *        Element or object to bind to.\n *\n * @param {string|string[]} type\n *        Name/type of event\n *\n * @param {Event~EventListener} fn\n *        Event Listener function\n */\nfunction one(elem, type, fn) {\n  if (Array.isArray(type)) {\n    return _handleMultipleEvents(one, elem, type, fn);\n  }\n  var func = function func() {\n    off(elem, type, func);\n    fn.apply(this, arguments);\n  };\n\n  // copy the guid to the new function so it can removed using the original function's ID\n  func.guid = fn.guid = fn.guid || newGUID();\n  on(elem, type, func);\n}\n\nvar Events = (Object.freeze || Object)({\n\tfixEvent: fixEvent,\n\ton: on,\n\toff: off,\n\ttrigger: trigger,\n\tone: one\n});\n\n/**\n * @file setup.js - Functions for setting up a player without\n * user interaction based on the data-setup `attribute` of the video tag.\n *\n * @module setup\n */\nvar _windowLoaded = false;\nvar videojs$2 = void 0;\n\n/**\n * Set up any tags that have a data-setup `attribute` when the player is started.\n */\nvar autoSetup = function autoSetup() {\n\n  // Protect against breakage in non-browser environments.\n  if (!isReal()) {\n    return;\n  }\n\n  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*\n  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));\n  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));\n  // var mediaEls = vids.concat(audios);\n\n  // Because IE8 doesn't support calling slice on a node list, we need to loop\n  // through each list of elements to build up a new, combined list of elements.\n  var vids = document.getElementsByTagName('video');\n  var audios = document.getElementsByTagName('audio');\n  var divs = document.getElementsByTagName('video-js');\n  var mediaEls = [];\n\n  if (vids && vids.length > 0) {\n    for (var i = 0, e = vids.length; i < e; i++) {\n      mediaEls.push(vids[i]);\n    }\n  }\n\n  if (audios && audios.length > 0) {\n    for (var _i = 0, _e = audios.length; _i < _e; _i++) {\n      mediaEls.push(audios[_i]);\n    }\n  }\n\n  if (divs && divs.length > 0) {\n    for (var _i2 = 0, _e2 = divs.length; _i2 < _e2; _i2++) {\n      mediaEls.push(divs[_i2]);\n    }\n  }\n\n  // Check if any media elements exist\n  if (mediaEls && mediaEls.length > 0) {\n\n    for (var _i3 = 0, _e3 = mediaEls.length; _i3 < _e3; _i3++) {\n      var mediaEl = mediaEls[_i3];\n\n      // Check if element exists, has getAttribute func.\n      // IE seems to consider typeof el.getAttribute == 'object' instead of\n      // 'function' like expected, at least when loading the player immediately.\n      if (mediaEl && mediaEl.getAttribute) {\n\n        // Make sure this player hasn't already been set up.\n        if (mediaEl.player === undefined) {\n          var options = mediaEl.getAttribute('data-setup');\n\n          // Check if data-setup attr exists.\n          // We only auto-setup if they've added the data-setup attr.\n          if (options !== null) {\n            // Create new video.js instance.\n            videojs$2(mediaEl);\n          }\n        }\n\n        // If getAttribute isn't defined, we need to wait for the DOM.\n      } else {\n        autoSetupTimeout(1);\n        break;\n      }\n    }\n\n    // No videos were found, so keep looping unless page is finished loading.\n  } else if (!_windowLoaded) {\n    autoSetupTimeout(1);\n  }\n};\n\n/**\n * Wait until the page is loaded before running autoSetup. This will be called in\n * autoSetup if `hasLoaded` returns false.\n *\n * @param {number} wait\n *        How long to wait in ms\n *\n * @param {module:videojs} [vjs]\n *        The videojs library function\n */\nfunction autoSetupTimeout(wait, vjs) {\n  if (vjs) {\n    videojs$2 = vjs;\n  }\n\n  window.setTimeout(autoSetup, wait);\n}\n\nif (isReal() && document.readyState === 'complete') {\n  _windowLoaded = true;\n} else {\n  /**\n   * Listen for the load event on window, and set _windowLoaded to true.\n   *\n   * @listens load\n   */\n  one(window, 'load', function () {\n    _windowLoaded = true;\n  });\n}\n\n/**\n * @file stylesheet.js\n * @module stylesheet\n */\n/**\n * Create a DOM syle element given a className for it.\n *\n * @param {string} className\n *        The className to add to the created style element.\n *\n * @return {Element}\n *         The element that was created.\n */\nvar createStyleElement = function createStyleElement(className) {\n  var style = document.createElement('style');\n\n  style.className = className;\n\n  return style;\n};\n\n/**\n * Add text to a DOM element.\n *\n * @param {Element} el\n *        The Element to add text content to.\n *\n * @param {string} content\n *        The text to add to the element.\n */\nvar setTextContent = function setTextContent(el, content) {\n  if (el.styleSheet) {\n    el.styleSheet.cssText = content;\n  } else {\n    el.textContent = content;\n  }\n};\n\n/**\n * @file fn.js\n * @module fn\n */\n/**\n * Bind (a.k.a proxy or Context). A simple method for changing the context of a function\n * It also stores a unique id on the function so it can be easily removed from events.\n *\n * @param {Mixed} context\n *        The object to bind as scope.\n *\n * @param {Function} fn\n *        The function to be bound to a scope.\n *\n * @param {number} [uid]\n *        An optional unique ID for the function to be set\n *\n * @return {Function}\n *         The new function that will be bound into the context given\n */\nvar bind = function bind(context, fn, uid) {\n  // Make sure the function has a unique ID\n  if (!fn.guid) {\n    fn.guid = newGUID();\n  }\n\n  // Create the new function that changes the context\n  var bound = function bound() {\n    return fn.apply(context, arguments);\n  };\n\n  // Allow for the ability to individualize this function\n  // Needed in the case where multiple objects might share the same prototype\n  // IF both items add an event listener with the same function, then you try to remove just one\n  // it will remove both because they both have the same guid.\n  // when using this, you need to use the bind method when you remove the listener as well.\n  // currently used in text tracks\n  bound.guid = uid ? uid + '_' + fn.guid : fn.guid;\n\n  return bound;\n};\n\n/**\n * Wraps the given function, `fn`, with a new function that only invokes `fn`\n * at most once per every `wait` milliseconds.\n *\n * @param  {Function} fn\n *         The function to be throttled.\n *\n * @param  {Number}   wait\n *         The number of milliseconds by which to throttle.\n *\n * @return {Function}\n */\nvar throttle = function throttle(fn, wait) {\n  var last = Date.now();\n\n  var throttled = function throttled() {\n    var now = Date.now();\n\n    if (now - last >= wait) {\n      fn.apply(undefined, arguments);\n      last = now;\n    }\n  };\n\n  return throttled;\n};\n\n/**\n * @file src/js/event-target.js\n */\n/**\n * `EventTarget` is a class that can have the same API as the DOM `EventTarget`. It\n * adds shorthand functions that wrap around lengthy functions. For example:\n * the `on` function is a wrapper around `addEventListener`.\n *\n * @see [EventTarget Spec]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}\n * @class EventTarget\n */\nvar EventTarget = function EventTarget() {};\n\n/**\n * A Custom DOM event.\n *\n * @typedef {Object} EventTarget~Event\n * @see [Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}\n */\n\n/**\n * All event listeners should follow the following format.\n *\n * @callback EventTarget~EventListener\n * @this {EventTarget}\n *\n * @param {EventTarget~Event} event\n *        the event that triggered this function\n *\n * @param {Object} [hash]\n *        hash of data sent during the event\n */\n\n/**\n * An object containing event names as keys and booleans as values.\n *\n * > NOTE: If an event name is set to a true value here {@link EventTarget#trigger}\n *         will have extra functionality. See that function for more information.\n *\n * @property EventTarget.prototype.allowedEvents_\n * @private\n */\nEventTarget.prototype.allowedEvents_ = {};\n\n/**\n * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a\n * function that will get called when an event with a certain name gets triggered.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to call with `EventTarget`s\n */\nEventTarget.prototype.on = function (type, fn) {\n  // Remove the addEventListener alias before calling Events.on\n  // so we don't get into an infinite type loop\n  var ael = this.addEventListener;\n\n  this.addEventListener = function () {};\n  on(this, type, fn);\n  this.addEventListener = ael;\n};\n\n/**\n * An alias of {@link EventTarget#on}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#on}\n */\nEventTarget.prototype.addEventListener = EventTarget.prototype.on;\n\n/**\n * Removes an `event listener` for a specific event from an instance of `EventTarget`.\n * This makes it so that the `event listener` will no longer get called when the\n * named event happens.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to remove.\n */\nEventTarget.prototype.off = function (type, fn) {\n  off(this, type, fn);\n};\n\n/**\n * An alias of {@link EventTarget#off}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#off}\n */\nEventTarget.prototype.removeEventListener = EventTarget.prototype.off;\n\n/**\n * This function will add an `event listener` that gets triggered only once. After the\n * first trigger it will get removed. This is like adding an `event listener`\n * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to be called once for each event name.\n */\nEventTarget.prototype.one = function (type, fn) {\n  // Remove the addEventListener alialing Events.on\n  // so we don't get into an infinite type loop\n  var ael = this.addEventListener;\n\n  this.addEventListener = function () {};\n  one(this, type, fn);\n  this.addEventListener = ael;\n};\n\n/**\n * This function causes an event to happen. This will then cause any `event listeners`\n * that are waiting for that event, to get called. If there are no `event listeners`\n * for an event then nothing will happen.\n *\n * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.\n * Trigger will also call the `on` + `uppercaseEventName` function.\n *\n * Example:\n * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call\n * `onClick` if it exists.\n *\n * @param {string|EventTarget~Event|Object} event\n *        The name of the event, an `Event`, or an object with a key of type set to\n *        an event name.\n */\nEventTarget.prototype.trigger = function (event) {\n  var type = event.type || event;\n\n  if (typeof event === 'string') {\n    event = { type: type };\n  }\n  event = fixEvent(event);\n\n  if (this.allowedEvents_[type] && this['on' + type]) {\n    this['on' + type](event);\n  }\n\n  trigger(this, event);\n};\n\n/**\n * An alias of {@link EventTarget#trigger}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#trigger}\n */\nEventTarget.prototype.dispatchEvent = EventTarget.prototype.trigger;\n\n/**\n * @file mixins/evented.js\n * @module evented\n */\n/**\n * Returns whether or not an object has had the evented mixin applied.\n *\n * @param  {Object} object\n *         An object to test.\n *\n * @return {boolean}\n *         Whether or not the object appears to be evented.\n */\nvar isEvented = function isEvented(object) {\n  return object instanceof EventTarget || !!object.eventBusEl_ && ['on', 'one', 'off', 'trigger'].every(function (k) {\n    return typeof object[k] === 'function';\n  });\n};\n\n/**\n * Whether a value is a valid event type - non-empty string or array.\n *\n * @private\n * @param  {string|Array} type\n *         The type value to test.\n *\n * @return {boolean}\n *         Whether or not the type is a valid event type.\n */\nvar isValidEventType = function isValidEventType(type) {\n  return (\n    // The regex here verifies that the `type` contains at least one non-\n    // whitespace character.\n    typeof type === 'string' && /\\S/.test(type) || Array.isArray(type) && !!type.length\n  );\n};\n\n/**\n * Validates a value to determine if it is a valid event target. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the target does not appear to be a valid event target.\n *\n * @param  {Object} target\n *         The object to test.\n */\nvar validateTarget = function validateTarget(target) {\n  if (!target.nodeName && !isEvented(target)) {\n    throw new Error('Invalid target; must be a DOM node or evented object.');\n  }\n};\n\n/**\n * Validates a value to determine if it is a valid event target. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the type does not appear to be a valid event type.\n *\n * @param  {string|Array} type\n *         The type to test.\n */\nvar validateEventType = function validateEventType(type) {\n  if (!isValidEventType(type)) {\n    throw new Error('Invalid event type; must be a non-empty string or array.');\n  }\n};\n\n/**\n * Validates a value to determine if it is a valid listener. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the listener is not a function.\n *\n * @param  {Function} listener\n *         The listener to test.\n */\nvar validateListener = function validateListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new Error('Invalid listener; must be a function.');\n  }\n};\n\n/**\n * Takes an array of arguments given to `on()` or `one()`, validates them, and\n * normalizes them into an object.\n *\n * @private\n * @param  {Object} self\n *         The evented object on which `on()` or `one()` was called. This\n *         object will be bound as the `this` value for the listener.\n *\n * @param  {Array} args\n *         An array of arguments passed to `on()` or `one()`.\n *\n * @return {Object}\n *         An object containing useful values for `on()` or `one()` calls.\n */\nvar normalizeListenArgs = function normalizeListenArgs(self, args) {\n\n  // If the number of arguments is less than 3, the target is always the\n  // evented object itself.\n  var isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;\n  var target = void 0;\n  var type = void 0;\n  var listener = void 0;\n\n  if (isTargetingSelf) {\n    target = self.eventBusEl_;\n\n    // Deal with cases where we got 3 arguments, but we are still listening to\n    // the evented object itself.\n    if (args.length >= 3) {\n      args.shift();\n    }\n\n    type = args[0];\n    listener = args[1];\n  } else {\n    target = args[0];\n    type = args[1];\n    listener = args[2];\n  }\n\n  validateTarget(target);\n  validateEventType(type);\n  validateListener(listener);\n\n  listener = bind(self, listener);\n\n  return { isTargetingSelf: isTargetingSelf, target: target, type: type, listener: listener };\n};\n\n/**\n * Adds the listener to the event type(s) on the target, normalizing for\n * the type of target.\n *\n * @private\n * @param  {Element|Object} target\n *         A DOM node or evented object.\n *\n * @param  {string} method\n *         The event binding method to use (\"on\" or \"one\").\n *\n * @param  {string|Array} type\n *         One or more event type(s).\n *\n * @param  {Function} listener\n *         A listener function.\n */\nvar listen = function listen(target, method, type, listener) {\n  validateTarget(target);\n\n  if (target.nodeName) {\n    Events[method](target, type, listener);\n  } else {\n    target[method](type, listener);\n  }\n};\n\n/**\n * Contains methods that provide event capabilites to an object which is passed\n * to {@link module:evented|evented}.\n *\n * @mixin EventedMixin\n */\nvar EventedMixin = {\n\n  /**\n   * Add a listener to an event (or events) on this object or another evented\n   * object.\n   *\n   * @param  {string|Array|Element|Object} targetOrType\n   *         If this is a string or array, it represents the event type(s)\n   *         that will trigger the listener.\n   *\n   *         Another evented object can be passed here instead, which will\n   *         cause the listener to listen for events on _that_ object.\n   *\n   *         In either case, the listener's `this` value will be bound to\n   *         this object.\n   *\n   * @param  {string|Array|Function} typeOrListener\n   *         If the first argument was a string or array, this should be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function.\n   */\n  on: function on$$1() {\n    var _this = this;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _normalizeListenArgs = normalizeListenArgs(this, args),\n        isTargetingSelf = _normalizeListenArgs.isTargetingSelf,\n        target = _normalizeListenArgs.target,\n        type = _normalizeListenArgs.type,\n        listener = _normalizeListenArgs.listener;\n\n    listen(target, 'on', type, listener);\n\n    // If this object is listening to another evented object.\n    if (!isTargetingSelf) {\n\n      // If this object is disposed, remove the listener.\n      var removeListenerOnDispose = function removeListenerOnDispose() {\n        return _this.off(target, type, listener);\n      };\n\n      // Use the same function ID as the listener so we can remove it later it\n      // using the ID of the original listener.\n      removeListenerOnDispose.guid = listener.guid;\n\n      // Add a listener to the target's dispose event as well. This ensures\n      // that if the target is disposed BEFORE this object, we remove the\n      // removal listener that was just added. Otherwise, we create a memory leak.\n      var removeRemoverOnTargetDispose = function removeRemoverOnTargetDispose() {\n        return _this.off('dispose', removeListenerOnDispose);\n      };\n\n      // Use the same function ID as the listener so we can remove it later\n      // it using the ID of the original listener.\n      removeRemoverOnTargetDispose.guid = listener.guid;\n\n      listen(this, 'on', 'dispose', removeListenerOnDispose);\n      listen(target, 'on', 'dispose', removeRemoverOnTargetDispose);\n    }\n  },\n\n\n  /**\n   * Add a listener to an event (or events) on this object or another evented\n   * object. The listener will only be called once and then removed.\n   *\n   * @param  {string|Array|Element|Object} targetOrType\n   *         If this is a string or array, it represents the event type(s)\n   *         that will trigger the listener.\n   *\n   *         Another evented object can be passed here instead, which will\n   *         cause the listener to listen for events on _that_ object.\n   *\n   *         In either case, the listener's `this` value will be bound to\n   *         this object.\n   *\n   * @param  {string|Array|Function} typeOrListener\n   *         If the first argument was a string or array, this should be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function.\n   */\n  one: function one$$1() {\n    var _this2 = this;\n\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    var _normalizeListenArgs2 = normalizeListenArgs(this, args),\n        isTargetingSelf = _normalizeListenArgs2.isTargetingSelf,\n        target = _normalizeListenArgs2.target,\n        type = _normalizeListenArgs2.type,\n        listener = _normalizeListenArgs2.listener;\n\n    // Targeting this evented object.\n\n\n    if (isTargetingSelf) {\n      listen(target, 'one', type, listener);\n\n      // Targeting another evented object.\n    } else {\n      var wrapper = function wrapper() {\n        for (var _len3 = arguments.length, largs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          largs[_key3] = arguments[_key3];\n        }\n\n        _this2.off(target, type, wrapper);\n        listener.apply(null, largs);\n      };\n\n      // Use the same function ID as the listener so we can remove it later\n      // it using the ID of the original listener.\n      wrapper.guid = listener.guid;\n      listen(target, 'one', type, wrapper);\n    }\n  },\n\n\n  /**\n   * Removes listener(s) from event(s) on an evented object.\n   *\n   * @param  {string|Array|Element|Object} [targetOrType]\n   *         If this is a string or array, it represents the event type(s).\n   *\n   *         Another evented object can be passed here instead, in which case\n   *         ALL 3 arguments are _required_.\n   *\n   * @param  {string|Array|Function} [typeOrListener]\n   *         If the first argument was a string or array, this may be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function; otherwise, _all_ listeners bound to the\n   *         event type(s) will be removed.\n   */\n  off: function off$$1(targetOrType, typeOrListener, listener) {\n\n    // Targeting this evented object.\n    if (!targetOrType || isValidEventType(targetOrType)) {\n      off(this.eventBusEl_, targetOrType, typeOrListener);\n\n      // Targeting another evented object.\n    } else {\n      var target = targetOrType;\n      var type = typeOrListener;\n\n      // Fail fast and in a meaningful way!\n      validateTarget(target);\n      validateEventType(type);\n      validateListener(listener);\n\n      // Ensure there's at least a guid, even if the function hasn't been used\n      listener = bind(this, listener);\n\n      // Remove the dispose listener on this evented object, which was given\n      // the same guid as the event listener in on().\n      this.off('dispose', listener);\n\n      if (target.nodeName) {\n        off(target, type, listener);\n        off(target, 'dispose', listener);\n      } else if (isEvented(target)) {\n        target.off(type, listener);\n        target.off('dispose', listener);\n      }\n    }\n  },\n\n\n  /**\n   * Fire an event on this evented object, causing its listeners to be called.\n   *\n   * @param   {string|Object} event\n   *          An event type or an object with a type property.\n   *\n   * @param   {Object} [hash]\n   *          An additional object to pass along to listeners.\n   *\n   * @returns {boolean}\n   *          Whether or not the default behavior was prevented.\n   */\n  trigger: function trigger$$1(event, hash) {\n    return trigger(this.eventBusEl_, event, hash);\n  }\n};\n\n/**\n * Applies {@link module:evented~EventedMixin|EventedMixin} to a target object.\n *\n * @param  {Object} target\n *         The object to which to add event methods.\n *\n * @param  {Object} [options={}]\n *         Options for customizing the mixin behavior.\n *\n * @param  {String} [options.eventBusKey]\n *         By default, adds a `eventBusEl_` DOM element to the target object,\n *         which is used as an event bus. If the target object already has a\n *         DOM element that should be used, pass its key here.\n *\n * @return {Object}\n *         The target object.\n */\nfunction evented(target) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var eventBusKey = options.eventBusKey;\n\n  // Set or create the eventBusEl_.\n\n  if (eventBusKey) {\n    if (!target[eventBusKey].nodeName) {\n      throw new Error('The eventBusKey \"' + eventBusKey + '\" does not refer to an element.');\n    }\n    target.eventBusEl_ = target[eventBusKey];\n  } else {\n    target.eventBusEl_ = createEl('span', { className: 'vjs-event-bus' });\n  }\n\n  assign(target, EventedMixin);\n\n  // When any evented object is disposed, it removes all its listeners.\n  target.on('dispose', function () {\n    target.off();\n    window.setTimeout(function () {\n      target.eventBusEl_ = null;\n    }, 0);\n  });\n\n  return target;\n}\n\n/**\n * @file mixins/stateful.js\n * @module stateful\n */\n/**\n * Contains methods that provide statefulness to an object which is passed\n * to {@link module:stateful}.\n *\n * @mixin StatefulMixin\n */\nvar StatefulMixin = {\n\n  /**\n   * A hash containing arbitrary keys and values representing the state of\n   * the object.\n   *\n   * @type {Object}\n   */\n  state: {},\n\n  /**\n   * Set the state of an object by mutating its\n   * {@link module:stateful~StatefulMixin.state|state} object in place.\n   *\n   * @fires   module:stateful~StatefulMixin#statechanged\n   * @param   {Object|Function} stateUpdates\n   *          A new set of properties to shallow-merge into the plugin state.\n   *          Can be a plain object or a function returning a plain object.\n   *\n   * @returns {Object|undefined}\n   *          An object containing changes that occurred. If no changes\n   *          occurred, returns `undefined`.\n   */\n  setState: function setState(stateUpdates) {\n    var _this = this;\n\n    // Support providing the `stateUpdates` state as a function.\n    if (typeof stateUpdates === 'function') {\n      stateUpdates = stateUpdates();\n    }\n\n    var changes = void 0;\n\n    each(stateUpdates, function (value, key) {\n\n      // Record the change if the value is different from what's in the\n      // current state.\n      if (_this.state[key] !== value) {\n        changes = changes || {};\n        changes[key] = {\n          from: _this.state[key],\n          to: value\n        };\n      }\n\n      _this.state[key] = value;\n    });\n\n    // Only trigger \"statechange\" if there were changes AND we have a trigger\n    // function. This allows us to not require that the target object be an\n    // evented object.\n    if (changes && isEvented(this)) {\n\n      /**\n       * An event triggered on an object that is both\n       * {@link module:stateful|stateful} and {@link module:evented|evented}\n       * indicating that its state has changed.\n       *\n       * @event    module:stateful~StatefulMixin#statechanged\n       * @type     {Object}\n       * @property {Object} changes\n       *           A hash containing the properties that were changed and\n       *           the values they were changed `from` and `to`.\n       */\n      this.trigger({\n        changes: changes,\n        type: 'statechanged'\n      });\n    }\n\n    return changes;\n  }\n};\n\n/**\n * Applies {@link module:stateful~StatefulMixin|StatefulMixin} to a target\n * object.\n *\n * If the target object is {@link module:evented|evented} and has a\n * `handleStateChanged` method, that method will be automatically bound to the\n * `statechanged` event on itself.\n *\n * @param   {Object} target\n *          The object to be made stateful.\n *\n * @param   {Object} [defaultState]\n *          A default set of properties to populate the newly-stateful object's\n *          `state` property.\n *\n * @returns {Object}\n *          Returns the `target`.\n */\nfunction stateful(target, defaultState) {\n  assign(target, StatefulMixin);\n\n  // This happens after the mixing-in because we need to replace the `state`\n  // added in that step.\n  target.state = assign({}, target.state, defaultState);\n\n  // Auto-bind the `handleStateChanged` method of the target object if it exists.\n  if (typeof target.handleStateChanged === 'function' && isEvented(target)) {\n    target.on('statechanged', target.handleStateChanged);\n  }\n\n  return target;\n}\n\n/**\n * @file to-title-case.js\n * @module to-title-case\n */\n\n/**\n * Uppercase the first letter of a string.\n *\n * @param {string} string\n *        String to be uppercased\n *\n * @return {string}\n *         The string with an uppercased first letter\n */\nfunction toTitleCase(string) {\n  if (typeof string !== 'string') {\n    return string;\n  }\n\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\n/**\n * Compares the TitleCase versions of the two strings for equality.\n *\n * @param {string} str1\n *        The first string to compare\n *\n * @param {string} str2\n *        The second string to compare\n *\n * @return {boolean}\n *         Whether the TitleCase versions of the strings are equal\n */\nfunction titleCaseEquals(str1, str2) {\n  return toTitleCase(str1) === toTitleCase(str2);\n}\n\n/**\n * @file merge-options.js\n * @module merge-options\n */\n/**\n * Deep-merge one or more options objects, recursively merging **only** plain\n * object properties.\n *\n * @param   {Object[]} sources\n *          One or more objects to merge into a new object.\n *\n * @returns {Object}\n *          A new object that is the merged result of all sources.\n */\nfunction mergeOptions() {\n  var result = {};\n\n  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n\n  sources.forEach(function (source) {\n    if (!source) {\n      return;\n    }\n\n    each(source, function (value, key) {\n      if (!isPlain(value)) {\n        result[key] = value;\n        return;\n      }\n\n      if (!isPlain(result[key])) {\n        result[key] = {};\n      }\n\n      result[key] = mergeOptions(result[key], value);\n    });\n  });\n\n  return result;\n}\n\n/**\n * Player Component - Base class for all UI objects\n *\n * @file component.js\n */\n/**\n * Base class for all UI Components.\n * Components are UI objects which represent both a javascript object and an element\n * in the DOM. They can be children of other components, and can have\n * children themselves.\n *\n * Components can also use methods from {@link EventTarget}\n */\n\nvar Component = function () {\n\n  /**\n   * A callback that is called when a component is ready. Does not have any\n   * paramters and any callback value will be ignored.\n   *\n   * @callback Component~ReadyCallback\n   * @this Component\n   */\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Object[]} [options.children]\n   *        An array of children objects to intialize this component with. Children objects have\n   *        a name property that will be used if more than one component of the same type needs to be\n   *        added.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        Function that gets called when the `Component` is ready.\n   */\n  function Component(player, options, ready) {\n    classCallCheck(this, Component);\n\n\n    // The component might be the player itself and we can't pass `this` to super\n    if (!player && this.play) {\n      this.player_ = player = this; // eslint-disable-line\n    } else {\n      this.player_ = player;\n    }\n\n    // Make a copy of prototype.options_ to protect against overriding defaults\n    this.options_ = mergeOptions({}, this.options_);\n\n    // Updated options with supplied options\n    options = this.options_ = mergeOptions(this.options_, options);\n\n    // Get ID from options or options element if one is supplied\n    this.id_ = options.id || options.el && options.el.id;\n\n    // If there was no ID from the options, generate one\n    if (!this.id_) {\n      // Don't require the player ID function in the case of mock players\n      var id = player && player.id && player.id() || 'no_player';\n\n      this.id_ = id + '_component_' + newGUID();\n    }\n\n    this.name_ = options.name || null;\n\n    // Create element if one wasn't provided in options\n    if (options.el) {\n      this.el_ = options.el;\n    } else if (options.createEl !== false) {\n      this.el_ = this.createEl();\n    }\n\n    // if evented is anything except false, we want to mixin in evented\n    if (options.evented !== false) {\n      // Make this an evented object and use `el_`, if available, as its event bus\n      evented(this, { eventBusKey: this.el_ ? 'el_' : null });\n    }\n    stateful(this, this.constructor.defaultState);\n\n    this.children_ = [];\n    this.childIndex_ = {};\n    this.childNameIndex_ = {};\n\n    // Add any child components in options\n    if (options.initChildren !== false) {\n      this.initChildren();\n    }\n\n    this.ready(ready);\n    // Don't want to trigger ready here or it will before init is actually\n    // finished for all children that run this constructor\n\n    if (options.reportTouchActivity !== false) {\n      this.enableTouchActivity();\n    }\n  }\n\n  /**\n   * Dispose of the `Component` and all child components.\n   *\n   * @fires Component#dispose\n   */\n\n\n  Component.prototype.dispose = function dispose() {\n\n    /**\n     * Triggered when a `Component` is disposed.\n     *\n     * @event Component#dispose\n     * @type {EventTarget~Event}\n     *\n     * @property {boolean} [bubbles=false]\n     *           set to false so that the close event does not\n     *           bubble up\n     */\n    this.trigger({ type: 'dispose', bubbles: false });\n\n    // Dispose all children.\n    if (this.children_) {\n      for (var i = this.children_.length - 1; i >= 0; i--) {\n        if (this.children_[i].dispose) {\n          this.children_[i].dispose();\n        }\n      }\n    }\n\n    // Delete child references\n    this.children_ = null;\n    this.childIndex_ = null;\n    this.childNameIndex_ = null;\n\n    if (this.el_) {\n      // Remove element from DOM\n      if (this.el_.parentNode) {\n        this.el_.parentNode.removeChild(this.el_);\n      }\n\n      removeData(this.el_);\n      this.el_ = null;\n    }\n\n    // remove reference to the player after disposing of the element\n    this.player_ = null;\n  };\n\n  /**\n   * Return the {@link Player} that the `Component` has attached to.\n   *\n   * @return {Player}\n   *         The player that this `Component` has attached to.\n   */\n\n\n  Component.prototype.player = function player() {\n    return this.player_;\n  };\n\n  /**\n   * Deep merge of options objects with new options.\n   * > Note: When both `obj` and `options` contain properties whose values are objects.\n   *         The two properties get merged using {@link module:mergeOptions}\n   *\n   * @param {Object} obj\n   *        The object that contains new options.\n   *\n   * @return {Object}\n   *         A new object of `this.options_` and `obj` merged together.\n   *\n   * @deprecated since version 5\n   */\n\n\n  Component.prototype.options = function options(obj) {\n    log$1.warn('this.options() has been deprecated and will be moved to the constructor in 6.0');\n\n    if (!obj) {\n      return this.options_;\n    }\n\n    this.options_ = mergeOptions(this.options_, obj);\n    return this.options_;\n  };\n\n  /**\n   * Get the `Component`s DOM element\n   *\n   * @return {Element}\n   *         The DOM element for this `Component`.\n   */\n\n\n  Component.prototype.el = function el() {\n    return this.el_;\n  };\n\n  /**\n   * Create the `Component`s DOM element.\n   *\n   * @param {string} [tagName]\n   *        Element's DOM node type. e.g. 'div'\n   *\n   * @param {Object} [properties]\n   *        An object of properties that should be set.\n   *\n   * @param {Object} [attributes]\n   *        An object of attributes that should be set.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  Component.prototype.createEl = function createEl$$1(tagName, properties, attributes) {\n    return createEl(tagName, properties, attributes);\n  };\n\n  /**\n   * Localize a string given the string in english.\n   *\n   * If tokens are provided, it'll try and run a simple token replacement on the provided string.\n   * The tokens it loooks for look like `{1}` with the index being 1-indexed into the tokens array.\n   *\n   * If a `defaultValue` is provided, it'll use that over `string`,\n   * if a value isn't found in provided language files.\n   * This is useful if you want to have a descriptive key for token replacement\n   * but have a succinct localized string and not require `en.json` to be included.\n   *\n   * Currently, it is used for the progress bar timing.\n   * ```js\n   * {\n   *   \"progress bar timing: currentTime={1} duration={2}\": \"{1} of {2}\"\n   * }\n   * ```\n   * It is then used like so:\n   * ```js\n   * this.localize('progress bar timing: currentTime={1} duration{2}',\n   *               [this.player_.currentTime(), this.player_.duration()],\n   *               '{1} of {2}');\n   * ```\n   *\n   * Which outputs something like: `01:23 of 24:56`.\n   *\n   *\n   * @param {string} string\n   *        The string to localize and the key to lookup in the language files.\n   * @param {string[]} [tokens]\n   *        If the current item has token replacements, provide the tokens here.\n   * @param {string} [defaultValue]\n   *        Defaults to `string`. Can be a default value to use for token replacement\n   *        if the lookup key is needed to be separate.\n   *\n   * @return {string}\n   *         The localized string or if no localization exists the english string.\n   */\n\n\n  Component.prototype.localize = function localize(string, tokens) {\n    var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : string;\n\n    var code = this.player_.language && this.player_.language();\n    var languages = this.player_.languages && this.player_.languages();\n    var language = languages && languages[code];\n    var primaryCode = code && code.split('-')[0];\n    var primaryLang = languages && languages[primaryCode];\n\n    var localizedString = defaultValue;\n\n    if (language && language[string]) {\n      localizedString = language[string];\n    } else if (primaryLang && primaryLang[string]) {\n      localizedString = primaryLang[string];\n    }\n\n    if (tokens) {\n      localizedString = localizedString.replace(/\\{(\\d+)\\}/g, function (match, index) {\n        var value = tokens[index - 1];\n        var ret = value;\n\n        if (typeof value === 'undefined') {\n          ret = match;\n        }\n\n        return ret;\n      });\n    }\n\n    return localizedString;\n  };\n\n  /**\n   * Return the `Component`s DOM element. This is where children get inserted.\n   * This will usually be the the same as the element returned in {@link Component#el}.\n   *\n   * @return {Element}\n   *         The content element for this `Component`.\n   */\n\n\n  Component.prototype.contentEl = function contentEl() {\n    return this.contentEl_ || this.el_;\n  };\n\n  /**\n   * Get this `Component`s ID\n   *\n   * @return {string}\n   *         The id of this `Component`\n   */\n\n\n  Component.prototype.id = function id() {\n    return this.id_;\n  };\n\n  /**\n   * Get the `Component`s name. The name gets used to reference the `Component`\n   * and is set during registration.\n   *\n   * @return {string}\n   *         The name of this `Component`.\n   */\n\n\n  Component.prototype.name = function name() {\n    return this.name_;\n  };\n\n  /**\n   * Get an array of all child components\n   *\n   * @return {Array}\n   *         The children\n   */\n\n\n  Component.prototype.children = function children() {\n    return this.children_;\n  };\n\n  /**\n   * Returns the child `Component` with the given `id`.\n   *\n   * @param {string} id\n   *        The id of the child `Component` to get.\n   *\n   * @return {Component|undefined}\n   *         The child `Component` with the given `id` or undefined.\n   */\n\n\n  Component.prototype.getChildById = function getChildById(id) {\n    return this.childIndex_[id];\n  };\n\n  /**\n   * Returns the child `Component` with the given `name`.\n   *\n   * @param {string} name\n   *        The name of the child `Component` to get.\n   *\n   * @return {Component|undefined}\n   *         The child `Component` with the given `name` or undefined.\n   */\n\n\n  Component.prototype.getChild = function getChild(name) {\n    if (!name) {\n      return;\n    }\n\n    name = toTitleCase(name);\n\n    return this.childNameIndex_[name];\n  };\n\n  /**\n   * Add a child `Component` inside the current `Component`.\n   *\n   *\n   * @param {string|Component} child\n   *        The name or instance of a child to add.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of options that will get passed to children of\n   *        the child.\n   *\n   * @param {number} [index=this.children_.length]\n   *        The index to attempt to add a child into.\n   *\n   * @return {Component}\n   *         The `Component` that gets added as a child. When using a string the\n   *         `Component` will get created by this process.\n   */\n\n\n  Component.prototype.addChild = function addChild(child) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.children_.length;\n\n    var component = void 0;\n    var componentName = void 0;\n\n    // If child is a string, create component with options\n    if (typeof child === 'string') {\n      componentName = toTitleCase(child);\n\n      var componentClassName = options.componentClass || componentName;\n\n      // Set name through options\n      options.name = componentName;\n\n      // Create a new object & element for this controls set\n      // If there's no .player_, this is a player\n      var ComponentClass = Component.getComponent(componentClassName);\n\n      if (!ComponentClass) {\n        throw new Error('Component ' + componentClassName + ' does not exist');\n      }\n\n      // data stored directly on the videojs object may be\n      // misidentified as a component to retain\n      // backwards-compatibility with 4.x. check to make sure the\n      // component class can be instantiated.\n      if (typeof ComponentClass !== 'function') {\n        return null;\n      }\n\n      component = new ComponentClass(this.player_ || this, options);\n\n      // child is a component instance\n    } else {\n      component = child;\n    }\n\n    this.children_.splice(index, 0, component);\n\n    if (typeof component.id === 'function') {\n      this.childIndex_[component.id()] = component;\n    }\n\n    // If a name wasn't used to create the component, check if we can use the\n    // name function of the component\n    componentName = componentName || component.name && toTitleCase(component.name());\n\n    if (componentName) {\n      this.childNameIndex_[componentName] = component;\n    }\n\n    // Add the UI object's element to the container div (box)\n    // Having an element is not required\n    if (typeof component.el === 'function' && component.el()) {\n      var childNodes = this.contentEl().children;\n      var refNode = childNodes[index] || null;\n\n      this.contentEl().insertBefore(component.el(), refNode);\n    }\n\n    // Return so it can stored on parent object if desired.\n    return component;\n  };\n\n  /**\n   * Remove a child `Component` from this `Component`s list of children. Also removes\n   * the child `Component`s element from this `Component`s element.\n   *\n   * @param {Component} component\n   *        The child `Component` to remove.\n   */\n\n\n  Component.prototype.removeChild = function removeChild(component) {\n    if (typeof component === 'string') {\n      component = this.getChild(component);\n    }\n\n    if (!component || !this.children_) {\n      return;\n    }\n\n    var childFound = false;\n\n    for (var i = this.children_.length - 1; i >= 0; i--) {\n      if (this.children_[i] === component) {\n        childFound = true;\n        this.children_.splice(i, 1);\n        break;\n      }\n    }\n\n    if (!childFound) {\n      return;\n    }\n\n    this.childIndex_[component.id()] = null;\n    this.childNameIndex_[component.name()] = null;\n\n    var compEl = component.el();\n\n    if (compEl && compEl.parentNode === this.contentEl()) {\n      this.contentEl().removeChild(component.el());\n    }\n  };\n\n  /**\n   * Add and initialize default child `Component`s based upon options.\n   */\n\n\n  Component.prototype.initChildren = function initChildren() {\n    var _this = this;\n\n    var children = this.options_.children;\n\n    if (children) {\n      // `this` is `parent`\n      var parentOptions = this.options_;\n\n      var handleAdd = function handleAdd(child) {\n        var name = child.name;\n        var opts = child.opts;\n\n        // Allow options for children to be set at the parent options\n        // e.g. videojs(id, { controlBar: false });\n        // instead of videojs(id, { children: { controlBar: false });\n        if (parentOptions[name] !== undefined) {\n          opts = parentOptions[name];\n        }\n\n        // Allow for disabling default components\n        // e.g. options['children']['posterImage'] = false\n        if (opts === false) {\n          return;\n        }\n\n        // Allow options to be passed as a simple boolean if no configuration\n        // is necessary.\n        if (opts === true) {\n          opts = {};\n        }\n\n        // We also want to pass the original player options\n        // to each component as well so they don't need to\n        // reach back into the player for options later.\n        opts.playerOptions = _this.options_.playerOptions;\n\n        // Create and add the child component.\n        // Add a direct reference to the child by name on the parent instance.\n        // If two of the same component are used, different names should be supplied\n        // for each\n        var newChild = _this.addChild(name, opts);\n\n        if (newChild) {\n          _this[name] = newChild;\n        }\n      };\n\n      // Allow for an array of children details to passed in the options\n      var workingChildren = void 0;\n      var Tech = Component.getComponent('Tech');\n\n      if (Array.isArray(children)) {\n        workingChildren = children;\n      } else {\n        workingChildren = Object.keys(children);\n      }\n\n      workingChildren\n      // children that are in this.options_ but also in workingChildren  would\n      // give us extra children we do not want. So, we want to filter them out.\n      .concat(Object.keys(this.options_).filter(function (child) {\n        return !workingChildren.some(function (wchild) {\n          if (typeof wchild === 'string') {\n            return child === wchild;\n          }\n          return child === wchild.name;\n        });\n      })).map(function (child) {\n        var name = void 0;\n        var opts = void 0;\n\n        if (typeof child === 'string') {\n          name = child;\n          opts = children[name] || _this.options_[name] || {};\n        } else {\n          name = child.name;\n          opts = child;\n        }\n\n        return { name: name, opts: opts };\n      }).filter(function (child) {\n        // we have to make sure that child.name isn't in the techOrder since\n        // techs are registerd as Components but can't aren't compatible\n        // See https://github.com/videojs/video.js/issues/2772\n        var c = Component.getComponent(child.opts.componentClass || toTitleCase(child.name));\n\n        return c && !Tech.isTech(c);\n      }).forEach(handleAdd);\n    }\n  };\n\n  /**\n   * Builds the default DOM class name. Should be overriden by sub-components.\n   *\n   * @return {string}\n   *         The DOM class name for this object.\n   *\n   * @abstract\n   */\n\n\n  Component.prototype.buildCSSClass = function buildCSSClass() {\n    // Child classes can include a function that does:\n    // return 'CLASS NAME' + this._super();\n    return '';\n  };\n\n  /**\n   * Bind a listener to the component's ready state.\n   * Different from event listeners in that if the ready event has already happened\n   * it will trigger the function immediately.\n   *\n   * @return {Component}\n   *         Returns itself; method can be chained.\n   */\n\n\n  Component.prototype.ready = function ready(fn) {\n    var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (!fn) {\n      return;\n    }\n\n    if (!this.isReady_) {\n      this.readyQueue_ = this.readyQueue_ || [];\n      this.readyQueue_.push(fn);\n      return;\n    }\n\n    if (sync) {\n      fn.call(this);\n    } else {\n      // Call the function asynchronously by default for consistency\n      this.setTimeout(fn, 1);\n    }\n  };\n\n  /**\n   * Trigger all the ready listeners for this `Component`.\n   *\n   * @fires Component#ready\n   */\n\n\n  Component.prototype.triggerReady = function triggerReady() {\n    this.isReady_ = true;\n\n    // Ensure ready is triggerd asynchronously\n    this.setTimeout(function () {\n      var readyQueue = this.readyQueue_;\n\n      // Reset Ready Queue\n      this.readyQueue_ = [];\n\n      if (readyQueue && readyQueue.length > 0) {\n        readyQueue.forEach(function (fn) {\n          fn.call(this);\n        }, this);\n      }\n\n      // Allow for using event listeners also\n      /**\n       * Triggered when a `Component` is ready.\n       *\n       * @event Component#ready\n       * @type {EventTarget~Event}\n       */\n      this.trigger('ready');\n    }, 1);\n  };\n\n  /**\n   * Find a single DOM element matching a `selector`. This can be within the `Component`s\n   * `contentEl()` or another custom context.\n   *\n   * @param {string} selector\n   *        A valid CSS selector, which will be passed to `querySelector`.\n   *\n   * @param {Element|string} [context=this.contentEl()]\n   *        A DOM element within which to query. Can also be a selector string in\n   *        which case the first matching element will get used as context. If\n   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n   *        nothing it falls back to `document`.\n   *\n   * @return {Element|null}\n   *         the dom element that was found, or null\n   *\n   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n   */\n\n\n  Component.prototype.$ = function $$$1(selector, context) {\n    return $(selector, context || this.contentEl());\n  };\n\n  /**\n   * Finds all DOM element matching a `selector`. This can be within the `Component`s\n   * `contentEl()` or another custom context.\n   *\n   * @param {string} selector\n   *        A valid CSS selector, which will be passed to `querySelectorAll`.\n   *\n   * @param {Element|string} [context=this.contentEl()]\n   *        A DOM element within which to query. Can also be a selector string in\n   *        which case the first matching element will get used as context. If\n   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n   *        nothing it falls back to `document`.\n   *\n   * @return {NodeList}\n   *         a list of dom elements that were found\n   *\n   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n   */\n\n\n  Component.prototype.$$ = function $$$$1(selector, context) {\n    return $$(selector, context || this.contentEl());\n  };\n\n  /**\n   * Check if a component's element has a CSS class name.\n   *\n   * @param {string} classToCheck\n   *        CSS class name to check.\n   *\n   * @return {boolean}\n   *         - True if the `Component` has the class.\n   *         - False if the `Component` does not have the class`\n   */\n\n\n  Component.prototype.hasClass = function hasClass$$1(classToCheck) {\n    return hasClass(this.el_, classToCheck);\n  };\n\n  /**\n   * Add a CSS class name to the `Component`s element.\n   *\n   * @param {string} classToAdd\n   *        CSS class name to add\n   */\n\n\n  Component.prototype.addClass = function addClass$$1(classToAdd) {\n    addClass(this.el_, classToAdd);\n  };\n\n  /**\n   * Remove a CSS class name from the `Component`s element.\n   *\n   * @param {string} classToRemove\n   *        CSS class name to remove\n   */\n\n\n  Component.prototype.removeClass = function removeClass$$1(classToRemove) {\n    removeClass(this.el_, classToRemove);\n  };\n\n  /**\n   * Add or remove a CSS class name from the component's element.\n   * - `classToToggle` gets added when {@link Component#hasClass} would return false.\n   * - `classToToggle` gets removed when {@link Component#hasClass} would return true.\n   *\n   * @param  {string} classToToggle\n   *         The class to add or remove based on (@link Component#hasClass}\n   *\n   * @param  {boolean|Dom~predicate} [predicate]\n   *         An {@link Dom~predicate} function or a boolean\n   */\n\n\n  Component.prototype.toggleClass = function toggleClass$$1(classToToggle, predicate) {\n    toggleClass(this.el_, classToToggle, predicate);\n  };\n\n  /**\n   * Show the `Component`s element if it is hidden by removing the\n   * 'vjs-hidden' class name from it.\n   */\n\n\n  Component.prototype.show = function show() {\n    this.removeClass('vjs-hidden');\n  };\n\n  /**\n   * Hide the `Component`s element if it is currently showing by adding the\n   * 'vjs-hidden` class name to it.\n   */\n\n\n  Component.prototype.hide = function hide() {\n    this.addClass('vjs-hidden');\n  };\n\n  /**\n   * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'\n   * class name to it. Used during fadeIn/fadeOut.\n   *\n   * @private\n   */\n\n\n  Component.prototype.lockShowing = function lockShowing() {\n    this.addClass('vjs-lock-showing');\n  };\n\n  /**\n   * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'\n   * class name from it. Used during fadeIn/fadeOut.\n   *\n   * @private\n   */\n\n\n  Component.prototype.unlockShowing = function unlockShowing() {\n    this.removeClass('vjs-lock-showing');\n  };\n\n  /**\n   * Get the value of an attribute on the `Component`s element.\n   *\n   * @param {string} attribute\n   *        Name of the attribute to get the value from.\n   *\n   * @return {string|null}\n   *         - The value of the attribute that was asked for.\n   *         - Can be an empty string on some browsers if the attribute does not exist\n   *           or has no value\n   *         - Most browsers will return null if the attibute does not exist or has\n   *           no value.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}\n   */\n\n\n  Component.prototype.getAttribute = function getAttribute$$1(attribute) {\n    return getAttribute(this.el_, attribute);\n  };\n\n  /**\n   * Set the value of an attribute on the `Component`'s element\n   *\n   * @param {string} attribute\n   *        Name of the attribute to set.\n   *\n   * @param {string} value\n   *        Value to set the attribute to.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}\n   */\n\n\n  Component.prototype.setAttribute = function setAttribute$$1(attribute, value) {\n    setAttribute(this.el_, attribute, value);\n  };\n\n  /**\n   * Remove an attribute from the `Component`s element.\n   *\n   * @param {string} attribute\n   *        Name of the attribute to remove.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}\n   */\n\n\n  Component.prototype.removeAttribute = function removeAttribute$$1(attribute) {\n    removeAttribute(this.el_, attribute);\n  };\n\n  /**\n   * Get or set the width of the component based upon the CSS styles.\n   * See {@link Component#dimension} for more detailed information.\n   *\n   * @param {number|string} [num]\n   *        The width that you want to set postfixed with '%', 'px' or nothing.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the componentresize event trigger\n   *\n   * @return {number|string}\n   *         The width when getting, zero if there is no width. Can be a string\n   *           postpixed with '%' or 'px'.\n   */\n\n\n  Component.prototype.width = function width(num, skipListeners) {\n    return this.dimension('width', num, skipListeners);\n  };\n\n  /**\n   * Get or set the height of the component based upon the CSS styles.\n   * See {@link Component#dimension} for more detailed information.\n   *\n   * @param {number|string} [num]\n   *        The height that you want to set postfixed with '%', 'px' or nothing.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the componentresize event trigger\n   *\n   * @return {number|string}\n   *         The width when getting, zero if there is no width. Can be a string\n   *         postpixed with '%' or 'px'.\n   */\n\n\n  Component.prototype.height = function height(num, skipListeners) {\n    return this.dimension('height', num, skipListeners);\n  };\n\n  /**\n   * Set both the width and height of the `Component` element at the same time.\n   *\n   * @param  {number|string} width\n   *         Width to set the `Component`s element to.\n   *\n   * @param  {number|string} height\n   *         Height to set the `Component`s element to.\n   */\n\n\n  Component.prototype.dimensions = function dimensions(width, height) {\n    // Skip componentresize listeners on width for optimization\n    this.width(width, true);\n    this.height(height);\n  };\n\n  /**\n   * Get or set width or height of the `Component` element. This is the shared code\n   * for the {@link Component#width} and {@link Component#height}.\n   *\n   * Things to know:\n   * - If the width or height in an number this will return the number postfixed with 'px'.\n   * - If the width/height is a percent this will return the percent postfixed with '%'\n   * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function\n   *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.\n   *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}\n   *   for more information\n   * - If you want the computed style of the component, use {@link Component#currentWidth}\n   *   and {@link {Component#currentHeight}\n   *\n   * @fires Component#componentresize\n   *\n   * @param {string} widthOrHeight\n   8        'width' or 'height'\n   *\n   * @param  {number|string} [num]\n   8         New dimension\n   *\n   * @param  {boolean} [skipListeners]\n   *         Skip componentresize event trigger\n   *\n   * @return {number}\n   *         The dimension when getting or 0 if unset\n   */\n\n\n  Component.prototype.dimension = function dimension(widthOrHeight, num, skipListeners) {\n    if (num !== undefined) {\n      // Set to zero if null or literally NaN (NaN !== NaN)\n      if (num === null || num !== num) {\n        num = 0;\n      }\n\n      // Check if using css width/height (% or px) and adjust\n      if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {\n        this.el_.style[widthOrHeight] = num;\n      } else if (num === 'auto') {\n        this.el_.style[widthOrHeight] = '';\n      } else {\n        this.el_.style[widthOrHeight] = num + 'px';\n      }\n\n      // skipListeners allows us to avoid triggering the resize event when setting both width and height\n      if (!skipListeners) {\n        /**\n         * Triggered when a component is resized.\n         *\n         * @event Component#componentresize\n         * @type {EventTarget~Event}\n         */\n        this.trigger('componentresize');\n      }\n\n      return;\n    }\n\n    // Not setting a value, so getting it\n    // Make sure element exists\n    if (!this.el_) {\n      return 0;\n    }\n\n    // Get dimension value from style\n    var val = this.el_.style[widthOrHeight];\n    var pxIndex = val.indexOf('px');\n\n    if (pxIndex !== -1) {\n      // Return the pixel value with no 'px'\n      return parseInt(val.slice(0, pxIndex), 10);\n    }\n\n    // No px so using % or no style was set, so falling back to offsetWidth/height\n    // If component has display:none, offset will return 0\n    // TODO: handle display:none and no dimension style using px\n    return parseInt(this.el_['offset' + toTitleCase(widthOrHeight)], 10);\n  };\n\n  /**\n   * Get the width or the height of the `Component` elements computed style. Uses\n   * `window.getComputedStyle`.\n   *\n   * @param {string} widthOrHeight\n   *        A string containing 'width' or 'height'. Whichever one you want to get.\n   *\n   * @return {number}\n   *         The dimension that gets asked for or 0 if nothing was set\n   *         for that dimension.\n   */\n\n\n  Component.prototype.currentDimension = function currentDimension(widthOrHeight) {\n    var computedWidthOrHeight = 0;\n\n    if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {\n      throw new Error('currentDimension only accepts width or height value');\n    }\n\n    if (typeof window.getComputedStyle === 'function') {\n      var computedStyle = window.getComputedStyle(this.el_);\n\n      computedWidthOrHeight = computedStyle.getPropertyValue(widthOrHeight) || computedStyle[widthOrHeight];\n    }\n\n    // remove 'px' from variable and parse as integer\n    computedWidthOrHeight = parseFloat(computedWidthOrHeight);\n\n    // if the computed value is still 0, it's possible that the browser is lying\n    // and we want to check the offset values.\n    // This code also runs on IE8 and wherever getComputedStyle doesn't exist.\n    if (computedWidthOrHeight === 0) {\n      var rule = 'offset' + toTitleCase(widthOrHeight);\n\n      computedWidthOrHeight = this.el_[rule];\n    }\n\n    return computedWidthOrHeight;\n  };\n\n  /**\n   * An object that contains width and height values of the `Component`s\n   * computed style. Uses `window.getComputedStyle`.\n   *\n   * @typedef {Object} Component~DimensionObject\n   *\n   * @property {number} width\n   *           The width of the `Component`s computed style.\n   *\n   * @property {number} height\n   *           The height of the `Component`s computed style.\n   */\n\n  /**\n   * Get an object that contains width and height values of the `Component`s\n   * computed style.\n   *\n   * @return {Component~DimensionObject}\n   *         The dimensions of the components element\n   */\n\n\n  Component.prototype.currentDimensions = function currentDimensions() {\n    return {\n      width: this.currentDimension('width'),\n      height: this.currentDimension('height')\n    };\n  };\n\n  /**\n   * Get the width of the `Component`s computed style. Uses `window.getComputedStyle`.\n   *\n   * @return {number} width\n   *           The width of the `Component`s computed style.\n   */\n\n\n  Component.prototype.currentWidth = function currentWidth() {\n    return this.currentDimension('width');\n  };\n\n  /**\n   * Get the height of the `Component`s computed style. Uses `window.getComputedStyle`.\n   *\n   * @return {number} height\n   *           The height of the `Component`s computed style.\n   */\n\n\n  Component.prototype.currentHeight = function currentHeight() {\n    return this.currentDimension('height');\n  };\n\n  /**\n   * Set the focus to this component\n   */\n\n\n  Component.prototype.focus = function focus() {\n    this.el_.focus();\n  };\n\n  /**\n   * Remove the focus from this component\n   */\n\n\n  Component.prototype.blur = function blur() {\n    this.el_.blur();\n  };\n\n  /**\n   * Emit a 'tap' events when touch event support gets detected. This gets used to\n   * support toggling the controls through a tap on the video. They get enabled\n   * because every sub-component would have extra overhead otherwise.\n   *\n   * @private\n   * @fires Component#tap\n   * @listens Component#touchstart\n   * @listens Component#touchmove\n   * @listens Component#touchleave\n   * @listens Component#touchcancel\n   * @listens Component#touchend\n    */\n\n\n  Component.prototype.emitTapEvents = function emitTapEvents() {\n    // Track the start time so we can determine how long the touch lasted\n    var touchStart = 0;\n    var firstTouch = null;\n\n    // Maximum movement allowed during a touch event to still be considered a tap\n    // Other popular libs use anywhere from 2 (hammer.js) to 15,\n    // so 10 seems like a nice, round number.\n    var tapMovementThreshold = 10;\n\n    // The maximum length a touch can be while still being considered a tap\n    var touchTimeThreshold = 200;\n\n    var couldBeTap = void 0;\n\n    this.on('touchstart', function (event) {\n      // If more than one finger, don't consider treating this as a click\n      if (event.touches.length === 1) {\n        // Copy pageX/pageY from the object\n        firstTouch = {\n          pageX: event.touches[0].pageX,\n          pageY: event.touches[0].pageY\n        };\n        // Record start time so we can detect a tap vs. \"touch and hold\"\n        touchStart = new Date().getTime();\n        // Reset couldBeTap tracking\n        couldBeTap = true;\n      }\n    });\n\n    this.on('touchmove', function (event) {\n      // If more than one finger, don't consider treating this as a click\n      if (event.touches.length > 1) {\n        couldBeTap = false;\n      } else if (firstTouch) {\n        // Some devices will throw touchmoves for all but the slightest of taps.\n        // So, if we moved only a small distance, this could still be a tap\n        var xdiff = event.touches[0].pageX - firstTouch.pageX;\n        var ydiff = event.touches[0].pageY - firstTouch.pageY;\n        var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n\n        if (touchDistance > tapMovementThreshold) {\n          couldBeTap = false;\n        }\n      }\n    });\n\n    var noTap = function noTap() {\n      couldBeTap = false;\n    };\n\n    // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s\n    this.on('touchleave', noTap);\n    this.on('touchcancel', noTap);\n\n    // When the touch ends, measure how long it took and trigger the appropriate\n    // event\n    this.on('touchend', function (event) {\n      firstTouch = null;\n      // Proceed only if the touchmove/leave/cancel event didn't happen\n      if (couldBeTap === true) {\n        // Measure how long the touch lasted\n        var touchTime = new Date().getTime() - touchStart;\n\n        // Make sure the touch was less than the threshold to be considered a tap\n        if (touchTime < touchTimeThreshold) {\n          // Don't let browser turn this into a click\n          event.preventDefault();\n          /**\n           * Triggered when a `Component` is tapped.\n           *\n           * @event Component#tap\n           * @type {EventTarget~Event}\n           */\n          this.trigger('tap');\n          // It may be good to copy the touchend event object and change the\n          // type to tap, if the other event properties aren't exact after\n          // Events.fixEvent runs (e.g. event.target)\n        }\n      }\n    });\n  };\n\n  /**\n   * This function reports user activity whenever touch events happen. This can get\n   * turned off by any sub-components that wants touch events to act another way.\n   *\n   * Report user touch activity when touch events occur. User activity gets used to\n   * determine when controls should show/hide. It is simple when it comes to mouse\n   * events, because any mouse event should show the controls. So we capture mouse\n   * events that bubble up to the player and report activity when that happens.\n   * With touch events it isn't as easy as `touchstart` and `touchend` toggle player\n   * controls. So touch events can't help us at the player level either.\n   *\n   * User activity gets checked asynchronously. So what could happen is a tap event\n   * on the video turns the controls off. Then the `touchend` event bubbles up to\n   * the player. Which, if it reported user activity, would turn the controls right\n   * back on. We also don't want to completely block touch events from bubbling up.\n   * Furthermore a `touchmove` event and anything other than a tap, should not turn\n   * controls back on.\n   *\n   * @listens Component#touchstart\n   * @listens Component#touchmove\n   * @listens Component#touchend\n   * @listens Component#touchcancel\n   */\n\n\n  Component.prototype.enableTouchActivity = function enableTouchActivity() {\n    // Don't continue if the root player doesn't support reporting user activity\n    if (!this.player() || !this.player().reportUserActivity) {\n      return;\n    }\n\n    // listener for reporting that the user is active\n    var report = bind(this.player(), this.player().reportUserActivity);\n\n    var touchHolding = void 0;\n\n    this.on('touchstart', function () {\n      report();\n      // For as long as the they are touching the device or have their mouse down,\n      // we consider them active even if they're not moving their finger or mouse.\n      // So we want to continue to update that they are active\n      this.clearInterval(touchHolding);\n      // report at the same interval as activityCheck\n      touchHolding = this.setInterval(report, 250);\n    });\n\n    var touchEnd = function touchEnd(event) {\n      report();\n      // stop the interval that maintains activity if the touch is holding\n      this.clearInterval(touchHolding);\n    };\n\n    this.on('touchmove', report);\n    this.on('touchend', touchEnd);\n    this.on('touchcancel', touchEnd);\n  };\n\n  /**\n   * A callback that has no parameters and is bound into `Component`s context.\n   *\n   * @callback Component~GenericCallback\n   * @this Component\n   */\n\n  /**\n   * Creates a function that runs after an `x` millisecond timeout. This function is a\n   * wrapper around `window.setTimeout`. There are a few reasons to use this one\n   * instead though:\n   * 1. It gets cleared via  {@link Component#clearTimeout} when\n   *    {@link Component#dispose} gets called.\n   * 2. The function callback will gets turned into a {@link Component~GenericCallback}\n   *\n   * > Note: You can use `window.clearTimeout` on the id returned by this function. This\n   *         will cause its dispose listener not to get cleaned up! Please use\n   *         {@link Component#clearTimeout} or {@link Component#dispose}.\n   *\n   * @param {Component~GenericCallback} fn\n   *        The function that will be run after `timeout`.\n   *\n   * @param {number} timeout\n   *        Timeout in milliseconds to delay before executing the specified function.\n   *\n   * @return {number}\n   *         Returns a timeout ID that gets used to identify the timeout. It can also\n   *         get used in {@link Component#clearTimeout} to clear the timeout that\n   *         was set.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}\n   */\n\n\n  Component.prototype.setTimeout = function setTimeout(fn, timeout) {\n    var _this2 = this;\n\n    fn = bind(this, fn);\n\n    var timeoutId = window.setTimeout(fn, timeout);\n    var disposeFn = function disposeFn() {\n      return _this2.clearTimeout(timeoutId);\n    };\n\n    disposeFn.guid = 'vjs-timeout-' + timeoutId;\n\n    this.on('dispose', disposeFn);\n\n    return timeoutId;\n  };\n\n  /**\n   * Clears a timeout that gets created via `window.setTimeout` or\n   * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}\n   * use this function instead of `window.clearTimout`. If you don't your dispose\n   * listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} timeoutId\n   *        The id of the timeout to clear. The return value of\n   *        {@link Component#setTimeout} or `window.setTimeout`.\n   *\n   * @return {number}\n   *         Returns the timeout id that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}\n   */\n\n\n  Component.prototype.clearTimeout = function clearTimeout(timeoutId) {\n    window.clearTimeout(timeoutId);\n\n    var disposeFn = function disposeFn() {};\n\n    disposeFn.guid = 'vjs-timeout-' + timeoutId;\n\n    this.off('dispose', disposeFn);\n\n    return timeoutId;\n  };\n\n  /**\n   * Creates a function that gets run every `x` milliseconds. This function is a wrapper\n   * around `window.setInterval`. There are a few reasons to use this one instead though.\n   * 1. It gets cleared via  {@link Component#clearInterval} when\n   *    {@link Component#dispose} gets called.\n   * 2. The function callback will be a {@link Component~GenericCallback}\n   *\n   * @param {Component~GenericCallback} fn\n   *        The function to run every `x` seconds.\n   *\n   * @param {number} interval\n   *        Execute the specified function every `x` milliseconds.\n   *\n   * @return {number}\n   *         Returns an id that can be used to identify the interval. It can also be be used in\n   *         {@link Component#clearInterval} to clear the interval.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}\n   */\n\n\n  Component.prototype.setInterval = function setInterval(fn, interval) {\n    var _this3 = this;\n\n    fn = bind(this, fn);\n\n    var intervalId = window.setInterval(fn, interval);\n\n    var disposeFn = function disposeFn() {\n      return _this3.clearInterval(intervalId);\n    };\n\n    disposeFn.guid = 'vjs-interval-' + intervalId;\n\n    this.on('dispose', disposeFn);\n\n    return intervalId;\n  };\n\n  /**\n   * Clears an interval that gets created via `window.setInterval` or\n   * {@link Component#setInterval}. If you set an inteval via {@link Component#setInterval}\n   * use this function instead of `window.clearInterval`. If you don't your dispose\n   * listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} intervalId\n   *        The id of the interval to clear. The return value of\n   *        {@link Component#setInterval} or `window.setInterval`.\n   *\n   * @return {number}\n   *         Returns the interval id that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}\n   */\n\n\n  Component.prototype.clearInterval = function clearInterval(intervalId) {\n    window.clearInterval(intervalId);\n\n    var disposeFn = function disposeFn() {};\n\n    disposeFn.guid = 'vjs-interval-' + intervalId;\n\n    this.off('dispose', disposeFn);\n\n    return intervalId;\n  };\n\n  /**\n   * Queues up a callback to be passed to requestAnimationFrame (rAF), but\n   * with a few extra bonuses:\n   *\n   * - Supports browsers that do not support rAF by falling back to\n   *   {@link Component#setTimeout}.\n   *\n   * - The callback is turned into a {@link Component~GenericCallback} (i.e.\n   *   bound to the component).\n   *\n   * - Automatic cancellation of the rAF callback is handled if the component\n   *   is disposed before it is called.\n   *\n   * @param  {Component~GenericCallback} fn\n   *         A function that will be bound to this component and executed just\n   *         before the browser's next repaint.\n   *\n   * @return {number}\n   *         Returns an rAF ID that gets used to identify the timeout. It can\n   *         also be used in {@link Component#cancelAnimationFrame} to cancel\n   *         the animation frame callback.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}\n   */\n\n\n  Component.prototype.requestAnimationFrame = function requestAnimationFrame(fn) {\n    var _this4 = this;\n\n    if (this.supportsRaf_) {\n      fn = bind(this, fn);\n\n      var id = window.requestAnimationFrame(fn);\n      var disposeFn = function disposeFn() {\n        return _this4.cancelAnimationFrame(id);\n      };\n\n      disposeFn.guid = 'vjs-raf-' + id;\n      this.on('dispose', disposeFn);\n\n      return id;\n    }\n\n    // Fall back to using a timer.\n    return this.setTimeout(fn, 1000 / 60);\n  };\n\n  /**\n   * Cancels a queued callback passed to {@link Component#requestAnimationFrame}\n   * (rAF).\n   *\n   * If you queue an rAF callback via {@link Component#requestAnimationFrame},\n   * use this function instead of `window.cancelAnimationFrame`. If you don't,\n   * your dispose listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} id\n   *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.\n   *\n   * @return {number}\n   *         Returns the rAF ID that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}\n   */\n\n\n  Component.prototype.cancelAnimationFrame = function cancelAnimationFrame(id) {\n    if (this.supportsRaf_) {\n      window.cancelAnimationFrame(id);\n\n      var disposeFn = function disposeFn() {};\n\n      disposeFn.guid = 'vjs-raf-' + id;\n\n      this.off('dispose', disposeFn);\n\n      return id;\n    }\n\n    // Fall back to using a timer.\n    return this.clearTimeout(id);\n  };\n\n  /**\n   * Register a `Component` with `videojs` given the name and the component.\n   *\n   * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s\n   *         should be registered using {@link Tech.registerTech} or\n   *         {@link videojs:videojs.registerTech}.\n   *\n   * > NOTE: This function can also be seen on videojs as\n   *         {@link videojs:videojs.registerComponent}.\n   *\n   * @param {string} name\n   *        The name of the `Component` to register.\n   *\n   * @param {Component} ComponentToRegister\n   *        The `Component` class to register.\n   *\n   * @return {Component}\n   *         The `Component` that was registered.\n   */\n\n\n  Component.registerComponent = function registerComponent(name, ComponentToRegister) {\n    if (typeof name !== 'string' || !name) {\n      throw new Error('Illegal component name, \"' + name + '\"; must be a non-empty string.');\n    }\n\n    var Tech = Component.getComponent('Tech');\n\n    // We need to make sure this check is only done if Tech has been registered.\n    var isTech = Tech && Tech.isTech(ComponentToRegister);\n    var isComp = Component === ComponentToRegister || Component.prototype.isPrototypeOf(ComponentToRegister.prototype);\n\n    if (isTech || !isComp) {\n      var reason = void 0;\n\n      if (isTech) {\n        reason = 'techs must be registered using Tech.registerTech()';\n      } else {\n        reason = 'must be a Component subclass';\n      }\n\n      throw new Error('Illegal component, \"' + name + '\"; ' + reason + '.');\n    }\n\n    name = toTitleCase(name);\n\n    if (!Component.components_) {\n      Component.components_ = {};\n    }\n\n    var Player = Component.getComponent('Player');\n\n    if (name === 'Player' && Player && Player.players) {\n      var players = Player.players;\n      var playerNames = Object.keys(players);\n\n      // If we have players that were disposed, then their name will still be\n      // in Players.players. So, we must loop through and verify that the value\n      // for each item is not null. This allows registration of the Player component\n      // after all players have been disposed or before any were created.\n      if (players && playerNames.length > 0 && playerNames.map(function (pname) {\n        return players[pname];\n      }).every(Boolean)) {\n        throw new Error('Can not register Player component after player has been created.');\n      }\n    }\n\n    Component.components_[name] = ComponentToRegister;\n\n    return ComponentToRegister;\n  };\n\n  /**\n   * Get a `Component` based on the name it was registered with.\n   *\n   * @param {string} name\n   *        The Name of the component to get.\n   *\n   * @return {Component}\n   *         The `Component` that got registered under the given name.\n   *\n   * @deprecated In `videojs` 6 this will not return `Component`s that were not\n   *             registered using {@link Component.registerComponent}. Currently we\n   *             check the global `videojs` object for a `Component` name and\n   *             return that if it exists.\n   */\n\n\n  Component.getComponent = function getComponent(name) {\n    if (!name) {\n      return;\n    }\n\n    name = toTitleCase(name);\n\n    if (Component.components_ && Component.components_[name]) {\n      return Component.components_[name];\n    }\n  };\n\n  return Component;\n}();\n\n/**\n * Whether or not this component supports `requestAnimationFrame`.\n *\n * This is exposed primarily for testing purposes.\n *\n * @private\n * @type {Boolean}\n */\n\n\nComponent.prototype.supportsRaf_ = typeof window.requestAnimationFrame === 'function' && typeof window.cancelAnimationFrame === 'function';\n\nComponent.registerComponent('Component', Component);\n\n/**\n * @file time-ranges.js\n * @module time-ranges\n */\n\n/**\n * Returns the time for the specified index at the start or end\n * of a TimeRange object.\n *\n * @function time-ranges:indexFunction\n *\n * @param {number} [index=0]\n *        The range number to return the time for.\n *\n * @return {number}\n *         The time that offset at the specified index.\n *\n * @depricated index must be set to a value, in the future this will throw an error.\n */\n\n/**\n * An object that contains ranges of time for various reasons.\n *\n * @typedef {Object} TimeRange\n *\n * @property {number} length\n *           The number of time ranges represented by this Object\n *\n * @property {time-ranges:indexFunction} start\n *           Returns the time offset at which a specified time range begins.\n *\n * @property {time-ranges:indexFunction} end\n *           Returns the time offset at which a specified time range begins.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges\n */\n\n/**\n * Check if any of the time ranges are over the maximum index.\n *\n * @param {string} fnName\n *        The function name to use for logging\n *\n * @param {number} index\n *        The index to check\n *\n * @param {number} maxIndex\n *        The maximum possible index\n *\n * @throws {Error} if the timeRanges provided are over the maxIndex\n */\nfunction rangeCheck(fnName, index, maxIndex) {\n  if (typeof index !== 'number' || index < 0 || index > maxIndex) {\n    throw new Error('Failed to execute \\'' + fnName + '\\' on \\'TimeRanges\\': The index provided (' + index + ') is non-numeric or out of bounds (0-' + maxIndex + ').');\n  }\n}\n\n/**\n * Check if any of the time ranges are over the maximum index.\n *\n * @param {string} fnName\n *        The function name to use for logging\n *\n * @param {string} valueIndex\n *        The proprety that should be used to get the time. should be 'start' or 'end'\n *\n * @param {Array} ranges\n *        An array of time ranges\n *\n * @param {Array} [rangeIndex=0]\n *        The index to start the search at\n *\n * @return {number}\n *         The time that offset at the specified index.\n *\n *\n * @depricated rangeIndex must be set to a value, in the future this will throw an error.\n * @throws {Error} if rangeIndex is more than the length of ranges\n */\nfunction getRange(fnName, valueIndex, ranges, rangeIndex) {\n  rangeCheck(fnName, rangeIndex, ranges.length - 1);\n  return ranges[rangeIndex][valueIndex];\n}\n\n/**\n * Create a time range object givent ranges of time.\n *\n * @param {Array} [ranges]\n *        An array of time ranges.\n */\nfunction createTimeRangesObj(ranges) {\n  if (ranges === undefined || ranges.length === 0) {\n    return {\n      length: 0,\n      start: function start() {\n        throw new Error('This TimeRanges object is empty');\n      },\n      end: function end() {\n        throw new Error('This TimeRanges object is empty');\n      }\n    };\n  }\n  return {\n    length: ranges.length,\n    start: getRange.bind(null, 'start', 0, ranges),\n    end: getRange.bind(null, 'end', 1, ranges)\n  };\n}\n\n/**\n * Should create a fake `TimeRange` object which mimics an HTML5 time range instance.\n *\n * @param {number|Array} start\n *        The start of a single range or an array of ranges\n *\n * @param {number} end\n *        The end of a single range.\n *\n * @private\n */\nfunction createTimeRanges(start, end) {\n  if (Array.isArray(start)) {\n    return createTimeRangesObj(start);\n  } else if (start === undefined || end === undefined) {\n    return createTimeRangesObj();\n  }\n  return createTimeRangesObj([[start, end]]);\n}\n\n/**\n * @file buffer.js\n * @module buffer\n */\n/**\n * Compute the percentage of the media that has been buffered.\n *\n * @param {TimeRange} buffered\n *        The current `TimeRange` object representing buffered time ranges\n *\n * @param {number} duration\n *        Total duration of the media\n *\n * @return {number}\n *         Percent buffered of the total duration in decimal form.\n */\nfunction bufferedPercent(buffered, duration) {\n  var bufferedDuration = 0;\n  var start = void 0;\n  var end = void 0;\n\n  if (!duration) {\n    return 0;\n  }\n\n  if (!buffered || !buffered.length) {\n    buffered = createTimeRanges(0, 0);\n  }\n\n  for (var i = 0; i < buffered.length; i++) {\n    start = buffered.start(i);\n    end = buffered.end(i);\n\n    // buffered end can be bigger than duration by a very small fraction\n    if (end > duration) {\n      end = duration;\n    }\n\n    bufferedDuration += end - start;\n  }\n\n  return bufferedDuration / duration;\n}\n\n/**\n * @file fullscreen-api.js\n * @module fullscreen-api\n * @private\n */\n/**\n * Store the browser-specific methods for the fullscreen API.\n *\n * @type {Object}\n * @see [Specification]{@link https://fullscreen.spec.whatwg.org}\n * @see [Map Approach From Screenfull.js]{@link https://github.com/sindresorhus/screenfull.js}\n */\nvar FullscreenApi = {};\n\n// browser API methods\nvar apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'],\n// WebKit\n['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'],\n// Old WebKit (Safari 5.1)\n['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'],\n// Mozilla\n['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'],\n// Microsoft\n['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];\n\nvar specApi = apiMap[0];\nvar browserApi = void 0;\n\n// determine the supported set of functions\nfor (var i = 0; i < apiMap.length; i++) {\n  // check for exitFullscreen function\n  if (apiMap[i][1] in document) {\n    browserApi = apiMap[i];\n    break;\n  }\n}\n\n// map the browser API names to the spec API names\nif (browserApi) {\n  for (var _i = 0; _i < browserApi.length; _i++) {\n    FullscreenApi[specApi[_i]] = browserApi[_i];\n  }\n}\n\n/**\n * @file media-error.js\n */\n/**\n * A Custom `MediaError` class which mimics the standard HTML5 `MediaError` class.\n *\n * @param {number|string|Object|MediaError} value\n *        This can be of multiple types:\n *        - number: should be a standard error code\n *        - string: an error message (the code will be 0)\n *        - Object: arbitrary properties\n *        - `MediaError` (native): used to populate a video.js `MediaError` object\n *        - `MediaError` (video.js): will return itself if it's already a\n *          video.js `MediaError` object.\n *\n * @see [MediaError Spec]{@link https://dev.w3.org/html5/spec-author-view/video.html#mediaerror}\n * @see [Encrypted MediaError Spec]{@link https://www.w3.org/TR/2013/WD-encrypted-media-20130510/#error-codes}\n *\n * @class MediaError\n */\nfunction MediaError(value) {\n\n  // Allow redundant calls to this constructor to avoid having `instanceof`\n  // checks peppered around the code.\n  if (value instanceof MediaError) {\n    return value;\n  }\n\n  if (typeof value === 'number') {\n    this.code = value;\n  } else if (typeof value === 'string') {\n    // default code is zero, so this is a custom error\n    this.message = value;\n  } else if (isObject(value)) {\n\n    // We assign the `code` property manually because native `MediaError` objects\n    // do not expose it as an own/enumerable property of the object.\n    if (typeof value.code === 'number') {\n      this.code = value.code;\n    }\n\n    assign(this, value);\n  }\n\n  if (!this.message) {\n    this.message = MediaError.defaultMessages[this.code] || '';\n  }\n}\n\n/**\n * The error code that refers two one of the defined `MediaError` types\n *\n * @type {Number}\n */\nMediaError.prototype.code = 0;\n\n/**\n * An optional message that to show with the error. Message is not part of the HTML5\n * video spec but allows for more informative custom errors.\n *\n * @type {String}\n */\nMediaError.prototype.message = '';\n\n/**\n * An optional status code that can be set by plugins to allow even more detail about\n * the error. For example a plugin might provide a specific HTTP status code and an\n * error message for that code. Then when the plugin gets that error this class will\n * know how to display an error message for it. This allows a custom message to show\n * up on the `Player` error overlay.\n *\n * @type {Array}\n */\nMediaError.prototype.status = null;\n\n/**\n * Errors indexed by the W3C standard. The order **CANNOT CHANGE**! See the\n * specification listed under {@link MediaError} for more information.\n *\n * @enum {array}\n * @readonly\n * @property {string} 0 - MEDIA_ERR_CUSTOM\n * @property {string} 1 - MEDIA_ERR_CUSTOM\n * @property {string} 2 - MEDIA_ERR_ABORTED\n * @property {string} 3 - MEDIA_ERR_NETWORK\n * @property {string} 4 - MEDIA_ERR_SRC_NOT_SUPPORTED\n * @property {string} 5 - MEDIA_ERR_ENCRYPTED\n */\nMediaError.errorTypes = ['MEDIA_ERR_CUSTOM', 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED', 'MEDIA_ERR_ENCRYPTED'];\n\n/**\n * The default `MediaError` messages based on the {@link MediaError.errorTypes}.\n *\n * @type {Array}\n * @constant\n */\nMediaError.defaultMessages = {\n  1: 'You aborted the media playback',\n  2: 'A network error caused the media download to fail part-way.',\n  3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',\n  4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',\n  5: 'The media is encrypted and we do not have the keys to decrypt it.'\n};\n\n// Add types as properties on MediaError\n// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;\nfor (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {\n  MediaError[MediaError.errorTypes[errNum]] = errNum;\n  // values should be accessible on both the class and instance\n  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;\n}\n\n/**\n * Returns whether an object is `Promise`-like (i.e. has a `then` method).\n *\n * @param  {Object}  value\n *         An object that may or may not be `Promise`-like.\n *\n * @return {Boolean}\n *         Whether or not the object is `Promise`-like.\n */\nfunction isPromise(value) {\n  return value !== undefined && typeof value.then === 'function';\n}\n\n/**\n * Silence a Promise-like object.\n *\n * This is useful for avoiding non-harmful, but potentially confusing \"uncaught\n * play promise\" rejection error messages.\n *\n * @param  {Object} value\n *         An object that may or may not be `Promise`-like.\n */\nfunction silencePromise(value) {\n  if (isPromise(value)) {\n    value.then(null, function (e) {});\n  }\n}\n\n/**\n * @file text-track-list-converter.js Utilities for capturing text track state and\n * re-creating tracks based on a capture.\n *\n * @module text-track-list-converter\n */\n\n/**\n * Examine a single {@link TextTrack} and return a JSON-compatible javascript object that\n * represents the {@link TextTrack}'s state.\n *\n * @param {TextTrack} track\n *        The text track to query.\n *\n * @return {Object}\n *         A serializable javascript representation of the TextTrack.\n * @private\n */\nvar trackToJson_ = function trackToJson_(track) {\n  var ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce(function (acc, prop, i) {\n\n    if (track[prop]) {\n      acc[prop] = track[prop];\n    }\n\n    return acc;\n  }, {\n    cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {\n      return {\n        startTime: cue.startTime,\n        endTime: cue.endTime,\n        text: cue.text,\n        id: cue.id\n      };\n    })\n  });\n\n  return ret;\n};\n\n/**\n * Examine a {@link Tech} and return a JSON-compatible javascript array that represents the\n * state of all {@link TextTrack}s currently configured. The return array is compatible with\n * {@link text-track-list-converter:jsonToTextTracks}.\n *\n * @param {Tech} tech\n *        The tech object to query\n *\n * @return {Array}\n *         A serializable javascript representation of the {@link Tech}s\n *         {@link TextTrackList}.\n */\nvar textTracksToJson = function textTracksToJson(tech) {\n\n  var trackEls = tech.$$('track');\n\n  var trackObjs = Array.prototype.map.call(trackEls, function (t) {\n    return t.track;\n  });\n  var tracks = Array.prototype.map.call(trackEls, function (trackEl) {\n    var json = trackToJson_(trackEl.track);\n\n    if (trackEl.src) {\n      json.src = trackEl.src;\n    }\n    return json;\n  });\n\n  return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {\n    return trackObjs.indexOf(track) === -1;\n  }).map(trackToJson_));\n};\n\n/**\n * Create a set of remote {@link TextTrack}s on a {@link Tech} based on an array of javascript\n * object {@link TextTrack} representations.\n *\n * @param {Array} json\n *        An array of `TextTrack` representation objects, like those that would be\n *        produced by `textTracksToJson`.\n *\n * @param {Tech} tech\n *        The `Tech` to create the `TextTrack`s on.\n */\nvar jsonToTextTracks = function jsonToTextTracks(json, tech) {\n  json.forEach(function (track) {\n    var addedTrack = tech.addRemoteTextTrack(track).track;\n\n    if (!track.src && track.cues) {\n      track.cues.forEach(function (cue) {\n        return addedTrack.addCue(cue);\n      });\n    }\n  });\n\n  return tech.textTracks();\n};\n\nvar textTrackConverter = { textTracksToJson: textTracksToJson, jsonToTextTracks: jsonToTextTracks, trackToJson_: trackToJson_ };\n\n/**\n * @file modal-dialog.js\n */\nvar MODAL_CLASS_NAME = 'vjs-modal-dialog';\nvar ESC = 27;\n\n/**\n * The `ModalDialog` displays over the video and its controls, which blocks\n * interaction with the player until it is closed.\n *\n * Modal dialogs include a \"Close\" button and will close when that button\n * is activated - or when ESC is pressed anywhere.\n *\n * @extends Component\n */\n\nvar ModalDialog = function (_Component) {\n  inherits(ModalDialog, _Component);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Mixed} [options.content=undefined]\n   *        Provide customized content for this modal.\n   *\n   * @param {string} [options.description]\n   *        A text description for the modal, primarily for accessibility.\n   *\n   * @param {boolean} [options.fillAlways=false]\n   *        Normally, modals are automatically filled only the first time\n   *        they open. This tells the modal to refresh its content\n   *        every time it opens.\n   *\n   * @param {string} [options.label]\n   *        A text label for the modal, primarily for accessibility.\n   *\n   * @param {boolean} [options.temporary=true]\n   *        If `true`, the modal can only be opened once; it will be\n   *        disposed as soon as it's closed.\n   *\n   * @param {boolean} [options.uncloseable=false]\n   *        If `true`, the user will not be able to close the modal\n   *        through the UI in the normal ways. Programmatic closing is\n   *        still possible.\n   */\n  function ModalDialog(player, options) {\n    classCallCheck(this, ModalDialog);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = false;\n\n    _this.closeable(!_this.options_.uncloseable);\n    _this.content(_this.options_.content);\n\n    // Make sure the contentEl is defined AFTER any children are initialized\n    // because we only want the contents of the modal in the contentEl\n    // (not the UI elements like the close button).\n    _this.contentEl_ = createEl('div', {\n      className: MODAL_CLASS_NAME + '-content'\n    }, {\n      role: 'document'\n    });\n\n    _this.descEl_ = createEl('p', {\n      className: MODAL_CLASS_NAME + '-description vjs-control-text',\n      id: _this.el().getAttribute('aria-describedby')\n    });\n\n    textContent(_this.descEl_, _this.description());\n    _this.el_.appendChild(_this.descEl_);\n    _this.el_.appendChild(_this.contentEl_);\n    return _this;\n  }\n\n  /**\n   * Create the `ModalDialog`'s DOM element\n   *\n   * @return {Element}\n   *         The DOM element that gets created.\n   */\n\n\n  ModalDialog.prototype.createEl = function createEl$$1() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: this.buildCSSClass(),\n      tabIndex: -1\n    }, {\n      'aria-describedby': this.id() + '_description',\n      'aria-hidden': 'true',\n      'aria-label': this.label(),\n      'role': 'dialog'\n    });\n  };\n\n  ModalDialog.prototype.dispose = function dispose() {\n    this.contentEl_ = null;\n    this.descEl_ = null;\n    this.previouslyActiveEl_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  ModalDialog.prototype.buildCSSClass = function buildCSSClass() {\n    return MODAL_CLASS_NAME + ' vjs-hidden ' + _Component.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Handles `keydown` events on the document, looking for ESC, which closes\n   * the modal.\n   *\n   * @param {EventTarget~Event} e\n   *        The keypress that triggered this event.\n   *\n   * @listens keydown\n   */\n\n\n  ModalDialog.prototype.handleKeyPress = function handleKeyPress(e) {\n    if (e.which === ESC && this.closeable()) {\n      this.close();\n    }\n  };\n\n  /**\n   * Returns the label string for this modal. Primarily used for accessibility.\n   *\n   * @return {string}\n   *         the localized or raw label of this modal.\n   */\n\n\n  ModalDialog.prototype.label = function label() {\n    return this.localize(this.options_.label || 'Modal Window');\n  };\n\n  /**\n   * Returns the description string for this modal. Primarily used for\n   * accessibility.\n   *\n   * @return {string}\n   *         The localized or raw description of this modal.\n   */\n\n\n  ModalDialog.prototype.description = function description() {\n    var desc = this.options_.description || this.localize('This is a modal window.');\n\n    // Append a universal closeability message if the modal is closeable.\n    if (this.closeable()) {\n      desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');\n    }\n\n    return desc;\n  };\n\n  /**\n   * Opens the modal.\n   *\n   * @fires ModalDialog#beforemodalopen\n   * @fires ModalDialog#modalopen\n   */\n\n\n  ModalDialog.prototype.open = function open() {\n    if (!this.opened_) {\n      var player = this.player();\n\n      /**\n        * Fired just before a `ModalDialog` is opened.\n        *\n        * @event ModalDialog#beforemodalopen\n        * @type {EventTarget~Event}\n        */\n      this.trigger('beforemodalopen');\n      this.opened_ = true;\n\n      // Fill content if the modal has never opened before and\n      // never been filled.\n      if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {\n        this.fill();\n      }\n\n      // If the player was playing, pause it and take note of its previously\n      // playing state.\n      this.wasPlaying_ = !player.paused();\n\n      if (this.options_.pauseOnOpen && this.wasPlaying_) {\n        player.pause();\n      }\n\n      if (this.closeable()) {\n        this.on(this.el_.ownerDocument, 'keydown', bind(this, this.handleKeyPress));\n      }\n\n      // Hide controls and note if they were enabled.\n      this.hadControls_ = player.controls();\n      player.controls(false);\n\n      this.show();\n      this.conditionalFocus_();\n      this.el().setAttribute('aria-hidden', 'false');\n\n      /**\n        * Fired just after a `ModalDialog` is opened.\n        *\n        * @event ModalDialog#modalopen\n        * @type {EventTarget~Event}\n        */\n      this.trigger('modalopen');\n      this.hasBeenOpened_ = true;\n    }\n  };\n\n  /**\n   * If the `ModalDialog` is currently open or closed.\n   *\n   * @param  {boolean} [value]\n   *         If given, it will open (`true`) or close (`false`) the modal.\n   *\n   * @return {boolean}\n   *         the current open state of the modaldialog\n   */\n\n\n  ModalDialog.prototype.opened = function opened(value) {\n    if (typeof value === 'boolean') {\n      this[value ? 'open' : 'close']();\n    }\n    return this.opened_;\n  };\n\n  /**\n   * Closes the modal, does nothing if the `ModalDialog` is\n   * not open.\n   *\n   * @fires ModalDialog#beforemodalclose\n   * @fires ModalDialog#modalclose\n   */\n\n\n  ModalDialog.prototype.close = function close() {\n    if (!this.opened_) {\n      return;\n    }\n    var player = this.player();\n\n    /**\n      * Fired just before a `ModalDialog` is closed.\n      *\n      * @event ModalDialog#beforemodalclose\n      * @type {EventTarget~Event}\n      */\n    this.trigger('beforemodalclose');\n    this.opened_ = false;\n\n    if (this.wasPlaying_ && this.options_.pauseOnOpen) {\n      player.play();\n    }\n\n    if (this.closeable()) {\n      this.off(this.el_.ownerDocument, 'keydown', bind(this, this.handleKeyPress));\n    }\n\n    if (this.hadControls_) {\n      player.controls(true);\n    }\n\n    this.hide();\n    this.el().setAttribute('aria-hidden', 'true');\n\n    /**\n      * Fired just after a `ModalDialog` is closed.\n      *\n      * @event ModalDialog#modalclose\n      * @type {EventTarget~Event}\n      */\n    this.trigger('modalclose');\n    this.conditionalBlur_();\n\n    if (this.options_.temporary) {\n      this.dispose();\n    }\n  };\n\n  /**\n   * Check to see if the `ModalDialog` is closeable via the UI.\n   *\n   * @param  {boolean} [value]\n   *         If given as a boolean, it will set the `closeable` option.\n   *\n   * @return {boolean}\n   *         Returns the final value of the closable option.\n   */\n\n\n  ModalDialog.prototype.closeable = function closeable(value) {\n    if (typeof value === 'boolean') {\n      var closeable = this.closeable_ = !!value;\n      var close = this.getChild('closeButton');\n\n      // If this is being made closeable and has no close button, add one.\n      if (closeable && !close) {\n\n        // The close button should be a child of the modal - not its\n        // content element, so temporarily change the content element.\n        var temp = this.contentEl_;\n\n        this.contentEl_ = this.el_;\n        close = this.addChild('closeButton', { controlText: 'Close Modal Dialog' });\n        this.contentEl_ = temp;\n        this.on(close, 'close', this.close);\n      }\n\n      // If this is being made uncloseable and has a close button, remove it.\n      if (!closeable && close) {\n        this.off(close, 'close', this.close);\n        this.removeChild(close);\n        close.dispose();\n      }\n    }\n    return this.closeable_;\n  };\n\n  /**\n   * Fill the modal's content element with the modal's \"content\" option.\n   * The content element will be emptied before this change takes place.\n   */\n\n\n  ModalDialog.prototype.fill = function fill() {\n    this.fillWith(this.content());\n  };\n\n  /**\n   * Fill the modal's content element with arbitrary content.\n   * The content element will be emptied before this change takes place.\n   *\n   * @fires ModalDialog#beforemodalfill\n   * @fires ModalDialog#modalfill\n   *\n   * @param {Mixed} [content]\n   *        The same rules apply to this as apply to the `content` option.\n   */\n\n\n  ModalDialog.prototype.fillWith = function fillWith(content) {\n    var contentEl = this.contentEl();\n    var parentEl = contentEl.parentNode;\n    var nextSiblingEl = contentEl.nextSibling;\n\n    /**\n     * Fired just before a `ModalDialog` is filled with content.\n     *\n     * @event ModalDialog#beforemodalfill\n     * @type {EventTarget~Event}\n     */\n    this.trigger('beforemodalfill');\n    this.hasBeenFilled_ = true;\n\n    // Detach the content element from the DOM before performing\n    // manipulation to avoid modifying the live DOM multiple times.\n    parentEl.removeChild(contentEl);\n    this.empty();\n    insertContent(contentEl, content);\n    /**\n     * Fired just after a `ModalDialog` is filled with content.\n     *\n     * @event ModalDialog#modalfill\n     * @type {EventTarget~Event}\n     */\n    this.trigger('modalfill');\n\n    // Re-inject the re-filled content element.\n    if (nextSiblingEl) {\n      parentEl.insertBefore(contentEl, nextSiblingEl);\n    } else {\n      parentEl.appendChild(contentEl);\n    }\n\n    // make sure that the close button is last in the dialog DOM\n    var closeButton = this.getChild('closeButton');\n\n    if (closeButton) {\n      parentEl.appendChild(closeButton.el_);\n    }\n  };\n\n  /**\n   * Empties the content element. This happens anytime the modal is filled.\n   *\n   * @fires ModalDialog#beforemodalempty\n   * @fires ModalDialog#modalempty\n   */\n\n\n  ModalDialog.prototype.empty = function empty() {\n    /**\n     * Fired just before a `ModalDialog` is emptied.\n     *\n     * @event ModalDialog#beforemodalempty\n     * @type {EventTarget~Event}\n     */\n    this.trigger('beforemodalempty');\n    emptyEl(this.contentEl());\n\n    /**\n     * Fired just after a `ModalDialog` is emptied.\n     *\n     * @event ModalDialog#modalempty\n     * @type {EventTarget~Event}\n     */\n    this.trigger('modalempty');\n  };\n\n  /**\n   * Gets or sets the modal content, which gets normalized before being\n   * rendered into the DOM.\n   *\n   * This does not update the DOM or fill the modal, but it is called during\n   * that process.\n   *\n   * @param  {Mixed} [value]\n   *         If defined, sets the internal content value to be used on the\n   *         next call(s) to `fill`. This value is normalized before being\n   *         inserted. To \"clear\" the internal content value, pass `null`.\n   *\n   * @return {Mixed}\n   *         The current content of the modal dialog\n   */\n\n\n  ModalDialog.prototype.content = function content(value) {\n    if (typeof value !== 'undefined') {\n      this.content_ = value;\n    }\n    return this.content_;\n  };\n\n  /**\n   * conditionally focus the modal dialog if focus was previously on the player.\n   *\n   * @private\n   */\n\n\n  ModalDialog.prototype.conditionalFocus_ = function conditionalFocus_() {\n    var activeEl = document.activeElement;\n    var playerEl = this.player_.el_;\n\n    this.previouslyActiveEl_ = null;\n\n    if (playerEl.contains(activeEl) || playerEl === activeEl) {\n      this.previouslyActiveEl_ = activeEl;\n\n      this.focus();\n\n      this.on(document, 'keydown', this.handleKeyDown);\n    }\n  };\n\n  /**\n   * conditionally blur the element and refocus the last focused element\n   *\n   * @private\n   */\n\n\n  ModalDialog.prototype.conditionalBlur_ = function conditionalBlur_() {\n    if (this.previouslyActiveEl_) {\n      this.previouslyActiveEl_.focus();\n      this.previouslyActiveEl_ = null;\n    }\n\n    this.off(document, 'keydown', this.handleKeyDown);\n  };\n\n  /**\n   * Keydown handler. Attached when modal is focused.\n   *\n   * @listens keydown\n   */\n\n\n  ModalDialog.prototype.handleKeyDown = function handleKeyDown(event) {\n    // exit early if it isn't a tab key\n    if (event.which !== 9) {\n      return;\n    }\n\n    var focusableEls = this.focusableEls_();\n    var activeEl = this.el_.querySelector(':focus');\n    var focusIndex = void 0;\n\n    for (var i = 0; i < focusableEls.length; i++) {\n      if (activeEl === focusableEls[i]) {\n        focusIndex = i;\n        break;\n      }\n    }\n\n    if (document.activeElement === this.el_) {\n      focusIndex = 0;\n    }\n\n    if (event.shiftKey && focusIndex === 0) {\n      focusableEls[focusableEls.length - 1].focus();\n      event.preventDefault();\n    } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {\n      focusableEls[0].focus();\n      event.preventDefault();\n    }\n  };\n\n  /**\n   * get all focusable elements\n   *\n   * @private\n   */\n\n\n  ModalDialog.prototype.focusableEls_ = function focusableEls_() {\n    var allChildren = this.el_.querySelectorAll('*');\n\n    return Array.prototype.filter.call(allChildren, function (child) {\n      return (child instanceof window.HTMLAnchorElement || child instanceof window.HTMLAreaElement) && child.hasAttribute('href') || (child instanceof window.HTMLInputElement || child instanceof window.HTMLSelectElement || child instanceof window.HTMLTextAreaElement || child instanceof window.HTMLButtonElement) && !child.hasAttribute('disabled') || child instanceof window.HTMLIFrameElement || child instanceof window.HTMLObjectElement || child instanceof window.HTMLEmbedElement || child.hasAttribute('tabindex') && child.getAttribute('tabindex') !== -1 || child.hasAttribute('contenteditable');\n    });\n  };\n\n  return ModalDialog;\n}(Component);\n\n/**\n * Default options for `ModalDialog` default options.\n *\n * @type {Object}\n * @private\n */\n\n\nModalDialog.prototype.options_ = {\n  pauseOnOpen: true,\n  temporary: true\n};\n\nComponent.registerComponent('ModalDialog', ModalDialog);\n\n/**\n * @file track-list.js\n */\n/**\n * Common functionaliy between {@link TextTrackList}, {@link AudioTrackList}, and\n * {@link VideoTrackList}\n *\n * @extends EventTarget\n */\n\nvar TrackList = function (_EventTarget) {\n  inherits(TrackList, _EventTarget);\n\n  /**\n   * Create an instance of this class\n   *\n   * @param {Track[]} tracks\n   *        A list of tracks to initialize the list with.\n   *\n   * @param {Object} [list]\n   *        The child object with inheritance done manually for ie8.\n   *\n   * @abstract\n   */\n  function TrackList() {\n    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    var _ret;\n\n    var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    classCallCheck(this, TrackList);\n\n    var _this = possibleConstructorReturn(this, _EventTarget.call(this));\n\n    if (!list) {\n      list = _this; // eslint-disable-line\n      if (IS_IE8) {\n        list = document.createElement('custom');\n        for (var prop in TrackList.prototype) {\n          if (prop !== 'constructor') {\n            list[prop] = TrackList.prototype[prop];\n          }\n        }\n      }\n    }\n\n    list.tracks_ = [];\n\n    /**\n     * @memberof TrackList\n     * @member {number} length\n     *         The current number of `Track`s in the this Trackist.\n     * @instance\n     */\n    Object.defineProperty(list, 'length', {\n      get: function get$$1() {\n        return this.tracks_.length;\n      }\n    });\n\n    for (var i = 0; i < tracks.length; i++) {\n      list.addTrack(tracks[i]);\n    }\n\n    // must return the object, as for ie8 it will not be this\n    // but a reference to a document object\n    return _ret = list, possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\n   * Add a {@link Track} to the `TrackList`\n   *\n   * @param {Track} track\n   *        The audio, video, or text track to add to the list.\n   *\n   * @fires TrackList#addtrack\n   */\n\n\n  TrackList.prototype.addTrack = function addTrack(track) {\n    var index = this.tracks_.length;\n\n    if (!('' + index in this)) {\n      Object.defineProperty(this, index, {\n        get: function get$$1() {\n          return this.tracks_[index];\n        }\n      });\n    }\n\n    // Do not add duplicate tracks\n    if (this.tracks_.indexOf(track) === -1) {\n      this.tracks_.push(track);\n      /**\n       * Triggered when a track is added to a track list.\n       *\n       * @event TrackList#addtrack\n       * @type {EventTarget~Event}\n       * @property {Track} track\n       *           A reference to track that was added.\n       */\n      this.trigger({\n        track: track,\n        type: 'addtrack'\n      });\n    }\n  };\n\n  /**\n   * Remove a {@link Track} from the `TrackList`\n   *\n   * @param {Track} rtrack\n   *        The audio, video, or text track to remove from the list.\n   *\n   * @fires TrackList#removetrack\n   */\n\n\n  TrackList.prototype.removeTrack = function removeTrack(rtrack) {\n    var track = void 0;\n\n    for (var i = 0, l = this.length; i < l; i++) {\n      if (this[i] === rtrack) {\n        track = this[i];\n        if (track.off) {\n          track.off();\n        }\n\n        this.tracks_.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (!track) {\n      return;\n    }\n\n    /**\n     * Triggered when a track is removed from track list.\n     *\n     * @event TrackList#removetrack\n     * @type {EventTarget~Event}\n     * @property {Track} track\n     *           A reference to track that was removed.\n     */\n    this.trigger({\n      track: track,\n      type: 'removetrack'\n    });\n  };\n\n  /**\n   * Get a Track from the TrackList by a tracks id\n   *\n   * @param {String} id - the id of the track to get\n   * @method getTrackById\n   * @return {Track}\n   * @private\n   */\n\n\n  TrackList.prototype.getTrackById = function getTrackById(id) {\n    var result = null;\n\n    for (var i = 0, l = this.length; i < l; i++) {\n      var track = this[i];\n\n      if (track.id === id) {\n        result = track;\n        break;\n      }\n    }\n\n    return result;\n  };\n\n  return TrackList;\n}(EventTarget);\n\n/**\n * Triggered when a different track is selected/enabled.\n *\n * @event TrackList#change\n * @type {EventTarget~Event}\n */\n\n/**\n * Events that can be called with on + eventName. See {@link EventHandler}.\n *\n * @property {Object} TrackList#allowedEvents_\n * @private\n */\n\n\nTrackList.prototype.allowedEvents_ = {\n  change: 'change',\n  addtrack: 'addtrack',\n  removetrack: 'removetrack'\n};\n\n// emulate attribute EventHandler support to allow for feature detection\nfor (var event in TrackList.prototype.allowedEvents_) {\n  TrackList.prototype['on' + event] = null;\n}\n\n/**\n * @file audio-track-list.js\n */\n/**\n * Anywhere we call this function we diverge from the spec\n * as we only support one enabled audiotrack at a time\n *\n * @param {AudioTrackList} list\n *        list to work on\n *\n * @param {AudioTrack} track\n *        The track to skip\n *\n * @private\n */\nvar disableOthers = function disableOthers(list, track) {\n  for (var i = 0; i < list.length; i++) {\n    if (!Object.keys(list[i]).length || track.id === list[i].id) {\n      continue;\n    }\n    // another audio track is enabled, disable it\n    list[i].enabled = false;\n  }\n};\n\n/**\n * The current list of {@link AudioTrack} for a media file.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist}\n * @extends TrackList\n */\n\nvar AudioTrackList = function (_TrackList) {\n  inherits(AudioTrackList, _TrackList);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {AudioTrack[]} [tracks=[]]\n   *        A list of `AudioTrack` to instantiate the list with.\n   */\n  function AudioTrackList() {\n    var _this, _ret;\n\n    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    classCallCheck(this, AudioTrackList);\n\n    var list = void 0;\n\n    // make sure only 1 track is enabled\n    // sorted from last index to first index\n    for (var i = tracks.length - 1; i >= 0; i--) {\n      if (tracks[i].enabled) {\n        disableOthers(tracks, tracks[i]);\n        break;\n      }\n    }\n\n    // IE8 forces us to implement inheritance ourselves\n    // as it does not support Object.defineProperty properly\n    if (IS_IE8) {\n      list = document.createElement('custom');\n      for (var prop in TrackList.prototype) {\n        if (prop !== 'constructor') {\n          list[prop] = TrackList.prototype[prop];\n        }\n      }\n      for (var _prop in AudioTrackList.prototype) {\n        if (_prop !== 'constructor') {\n          list[_prop] = AudioTrackList.prototype[_prop];\n        }\n      }\n    }\n\n    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);\n    list.changing_ = false;\n\n    return _ret = list, possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\n   * Add an {@link AudioTrack} to the `AudioTrackList`.\n   *\n   * @param {AudioTrack} track\n   *        The AudioTrack to add to the list\n   *\n   * @fires TrackList#addtrack\n   */\n\n\n  AudioTrackList.prototype.addTrack = function addTrack(track) {\n    var _this2 = this;\n\n    if (track.enabled) {\n      disableOthers(this, track);\n    }\n\n    _TrackList.prototype.addTrack.call(this, track);\n    // native tracks don't have this\n    if (!track.addEventListener) {\n      return;\n    }\n\n    /**\n     * @listens AudioTrack#enabledchange\n     * @fires TrackList#change\n     */\n    track.addEventListener('enabledchange', function () {\n      // when we are disabling other tracks (since we don't support\n      // more than one track at a time) we will set changing_\n      // to true so that we don't trigger additional change events\n      if (_this2.changing_) {\n        return;\n      }\n      _this2.changing_ = true;\n      disableOthers(_this2, track);\n      _this2.changing_ = false;\n      _this2.trigger('change');\n    });\n  };\n\n  return AudioTrackList;\n}(TrackList);\n\n/**\n * @file video-track-list.js\n */\n/**\n * Un-select all other {@link VideoTrack}s that are selected.\n *\n * @param {VideoTrackList} list\n *        list to work on\n *\n * @param {VideoTrack} track\n *        The track to skip\n *\n * @private\n */\nvar disableOthers$1 = function disableOthers(list, track) {\n  for (var i = 0; i < list.length; i++) {\n    if (!Object.keys(list[i]).length || track.id === list[i].id) {\n      continue;\n    }\n    // another video track is enabled, disable it\n    list[i].selected = false;\n  }\n};\n\n/**\n * The current list of {@link VideoTrack} for a video.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist}\n * @extends TrackList\n */\n\nvar VideoTrackList = function (_TrackList) {\n  inherits(VideoTrackList, _TrackList);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {VideoTrack[]} [tracks=[]]\n   *        A list of `VideoTrack` to instantiate the list with.\n   */\n  function VideoTrackList() {\n    var _this, _ret;\n\n    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    classCallCheck(this, VideoTrackList);\n\n    var list = void 0;\n\n    // make sure only 1 track is enabled\n    // sorted from last index to first index\n    for (var i = tracks.length - 1; i >= 0; i--) {\n      if (tracks[i].selected) {\n        disableOthers$1(tracks, tracks[i]);\n        break;\n      }\n    }\n\n    // IE8 forces us to implement inheritance ourselves\n    // as it does not support Object.defineProperty properly\n    if (IS_IE8) {\n      list = document.createElement('custom');\n      for (var prop in TrackList.prototype) {\n        if (prop !== 'constructor') {\n          list[prop] = TrackList.prototype[prop];\n        }\n      }\n      for (var _prop in VideoTrackList.prototype) {\n        if (_prop !== 'constructor') {\n          list[_prop] = VideoTrackList.prototype[_prop];\n        }\n      }\n    }\n\n    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);\n    list.changing_ = false;\n\n    /**\n     * @member {number} VideoTrackList#selectedIndex\n     *         The current index of the selected {@link VideoTrack`}.\n     */\n    Object.defineProperty(list, 'selectedIndex', {\n      get: function get$$1() {\n        for (var _i = 0; _i < this.length; _i++) {\n          if (this[_i].selected) {\n            return _i;\n          }\n        }\n        return -1;\n      },\n      set: function set$$1() {}\n    });\n\n    return _ret = list, possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\n   * Add a {@link VideoTrack} to the `VideoTrackList`.\n   *\n   * @param {VideoTrack} track\n   *        The VideoTrack to add to the list\n   *\n   * @fires TrackList#addtrack\n   */\n\n\n  VideoTrackList.prototype.addTrack = function addTrack(track) {\n    var _this2 = this;\n\n    if (track.selected) {\n      disableOthers$1(this, track);\n    }\n\n    _TrackList.prototype.addTrack.call(this, track);\n    // native tracks don't have this\n    if (!track.addEventListener) {\n      return;\n    }\n\n    /**\n     * @listens VideoTrack#selectedchange\n     * @fires TrackList#change\n     */\n    track.addEventListener('selectedchange', function () {\n      if (_this2.changing_) {\n        return;\n      }\n      _this2.changing_ = true;\n      disableOthers$1(_this2, track);\n      _this2.changing_ = false;\n      _this2.trigger('change');\n    });\n  };\n\n  return VideoTrackList;\n}(TrackList);\n\n/**\n * @file text-track-list.js\n */\n/**\n * The current list of {@link TextTrack} for a media file.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist}\n * @extends TrackList\n */\n\nvar TextTrackList = function (_TrackList) {\n  inherits(TextTrackList, _TrackList);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {TextTrack[]} [tracks=[]]\n   *        A list of `TextTrack` to instantiate the list with.\n   */\n  function TextTrackList() {\n    var _this, _ret;\n\n    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    classCallCheck(this, TextTrackList);\n\n    var list = void 0;\n\n    // IE8 forces us to implement inheritance ourselves\n    // as it does not support Object.defineProperty properly\n    if (IS_IE8) {\n      list = document.createElement('custom');\n      for (var prop in TrackList.prototype) {\n        if (prop !== 'constructor') {\n          list[prop] = TrackList.prototype[prop];\n        }\n      }\n      for (var _prop in TextTrackList.prototype) {\n        if (_prop !== 'constructor') {\n          list[_prop] = TextTrackList.prototype[_prop];\n        }\n      }\n    }\n\n    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);\n    return _ret = list, possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\n   * Add a {@link TextTrack} to the `TextTrackList`\n   *\n   * @param {TextTrack} track\n   *        The text track to add to the list.\n   *\n   * @fires TrackList#addtrack\n   */\n\n\n  TextTrackList.prototype.addTrack = function addTrack(track) {\n    _TrackList.prototype.addTrack.call(this, track);\n\n    /**\n     * @listens TextTrack#modechange\n     * @fires TrackList#change\n     */\n    track.addEventListener('modechange', bind(this, function () {\n      this.trigger('change');\n    }));\n\n    var nonLanguageTextTrackKind = ['metadata', 'chapters'];\n\n    if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {\n      track.addEventListener('modechange', bind(this, function () {\n        this.trigger('selectedlanguagechange');\n      }));\n    }\n  };\n\n  return TextTrackList;\n}(TrackList);\n\n/**\n * @file html-track-element-list.js\n */\n\n/**\n * The current list of {@link HtmlTrackElement}s.\n */\n\nvar HtmlTrackElementList = function () {\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {HtmlTrackElement[]} [tracks=[]]\n   *        A list of `HtmlTrackElement` to instantiate the list with.\n   */\n  function HtmlTrackElementList() {\n    var trackElements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    classCallCheck(this, HtmlTrackElementList);\n\n    var list = this; // eslint-disable-line\n\n    if (IS_IE8) {\n      list = document.createElement('custom');\n\n      for (var prop in HtmlTrackElementList.prototype) {\n        if (prop !== 'constructor') {\n          list[prop] = HtmlTrackElementList.prototype[prop];\n        }\n      }\n    }\n\n    list.trackElements_ = [];\n\n    /**\n     * @memberof HtmlTrackElementList\n     * @member {number} length\n     *         The current number of `Track`s in the this Trackist.\n     * @instance\n     */\n    Object.defineProperty(list, 'length', {\n      get: function get$$1() {\n        return this.trackElements_.length;\n      }\n    });\n\n    for (var i = 0, length = trackElements.length; i < length; i++) {\n      list.addTrackElement_(trackElements[i]);\n    }\n\n    if (IS_IE8) {\n      return list;\n    }\n  }\n\n  /**\n   * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`\n   *\n   * @param {HtmlTrackElement} trackElement\n   *        The track element to add to the list.\n   *\n   * @private\n   */\n\n\n  HtmlTrackElementList.prototype.addTrackElement_ = function addTrackElement_(trackElement) {\n    var index = this.trackElements_.length;\n\n    if (!('' + index in this)) {\n      Object.defineProperty(this, index, {\n        get: function get$$1() {\n          return this.trackElements_[index];\n        }\n      });\n    }\n\n    // Do not add duplicate elements\n    if (this.trackElements_.indexOf(trackElement) === -1) {\n      this.trackElements_.push(trackElement);\n    }\n  };\n\n  /**\n   * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an\n   * {@link TextTrack}.\n   *\n   * @param {TextTrack} track\n   *        The track associated with a track element.\n   *\n   * @return {HtmlTrackElement|undefined}\n   *         The track element that was found or undefined.\n   *\n   * @private\n   */\n\n\n  HtmlTrackElementList.prototype.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {\n    var trackElement_ = void 0;\n\n    for (var i = 0, length = this.trackElements_.length; i < length; i++) {\n      if (track === this.trackElements_[i].track) {\n        trackElement_ = this.trackElements_[i];\n\n        break;\n      }\n    }\n\n    return trackElement_;\n  };\n\n  /**\n   * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`\n   *\n   * @param {HtmlTrackElement} trackElement\n   *        The track element to remove from the list.\n   *\n   * @private\n   */\n\n\n  HtmlTrackElementList.prototype.removeTrackElement_ = function removeTrackElement_(trackElement) {\n    for (var i = 0, length = this.trackElements_.length; i < length; i++) {\n      if (trackElement === this.trackElements_[i]) {\n        this.trackElements_.splice(i, 1);\n\n        break;\n      }\n    }\n  };\n\n  return HtmlTrackElementList;\n}();\n\n/**\n * @file text-track-cue-list.js\n */\n/**\n * @typedef {Object} TextTrackCueList~TextTrackCue\n *\n * @property {string} id\n *           The unique id for this text track cue\n *\n * @property {number} startTime\n *           The start time for this text track cue\n *\n * @property {number} endTime\n *           The end time for this text track cue\n *\n * @property {boolean} pauseOnExit\n *           Pause when the end time is reached if true.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcue}\n */\n\n/**\n * A List of TextTrackCues.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist}\n */\n\nvar TextTrackCueList = function () {\n\n  /**\n   * Create an instance of this class..\n   *\n   * @param {Array} cues\n   *        A list of cues to be initialized with\n   */\n  function TextTrackCueList(cues) {\n    classCallCheck(this, TextTrackCueList);\n\n    var list = this; // eslint-disable-line\n\n    if (IS_IE8) {\n      list = document.createElement('custom');\n\n      for (var prop in TextTrackCueList.prototype) {\n        if (prop !== 'constructor') {\n          list[prop] = TextTrackCueList.prototype[prop];\n        }\n      }\n    }\n\n    TextTrackCueList.prototype.setCues_.call(list, cues);\n\n    /**\n     * @memberof TextTrackCueList\n     * @member {number} length\n     *         The current number of `TextTrackCue`s in the TextTrackCueList.\n     * @instance\n     */\n    Object.defineProperty(list, 'length', {\n      get: function get$$1() {\n        return this.length_;\n      }\n    });\n\n    if (IS_IE8) {\n      return list;\n    }\n  }\n\n  /**\n   * A setter for cues in this list. Creates getters\n   * an an index for the cues.\n   *\n   * @param {Array} cues\n   *        An array of cues to set\n   *\n   * @private\n   */\n\n\n  TextTrackCueList.prototype.setCues_ = function setCues_(cues) {\n    var oldLength = this.length || 0;\n    var i = 0;\n    var l = cues.length;\n\n    this.cues_ = cues;\n    this.length_ = cues.length;\n\n    var defineProp = function defineProp(index) {\n      if (!('' + index in this)) {\n        Object.defineProperty(this, '' + index, {\n          get: function get$$1() {\n            return this.cues_[index];\n          }\n        });\n      }\n    };\n\n    if (oldLength < l) {\n      i = oldLength;\n\n      for (; i < l; i++) {\n        defineProp.call(this, i);\n      }\n    }\n  };\n\n  /**\n   * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.\n   *\n   * @param {string} id\n   *        The id of the cue that should be searched for.\n   *\n   * @return {TextTrackCueList~TextTrackCue|null}\n   *         A single cue or null if none was found.\n   */\n\n\n  TextTrackCueList.prototype.getCueById = function getCueById(id) {\n    var result = null;\n\n    for (var i = 0, l = this.length; i < l; i++) {\n      var cue = this[i];\n\n      if (cue.id === id) {\n        result = cue;\n        break;\n      }\n    }\n\n    return result;\n  };\n\n  return TextTrackCueList;\n}();\n\n/**\n * @file track-kinds.js\n */\n\n/**\n * All possible `VideoTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind\n * @typedef VideoTrack~Kind\n * @enum\n */\nvar VideoTrackKind = {\n  alternative: 'alternative',\n  captions: 'captions',\n  main: 'main',\n  sign: 'sign',\n  subtitles: 'subtitles',\n  commentary: 'commentary'\n};\n\n/**\n * All possible `AudioTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind\n * @typedef AudioTrack~Kind\n * @enum\n */\nvar AudioTrackKind = {\n  'alternative': 'alternative',\n  'descriptions': 'descriptions',\n  'main': 'main',\n  'main-desc': 'main-desc',\n  'translation': 'translation',\n  'commentary': 'commentary'\n};\n\n/**\n * All possible `TextTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-kind\n * @typedef TextTrack~Kind\n * @enum\n */\nvar TextTrackKind = {\n  subtitles: 'subtitles',\n  captions: 'captions',\n  descriptions: 'descriptions',\n  chapters: 'chapters',\n  metadata: 'metadata'\n};\n\n/**\n * All possible `TextTrackMode`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode\n * @typedef TextTrack~Mode\n * @enum\n */\nvar TextTrackMode = {\n  disabled: 'disabled',\n  hidden: 'hidden',\n  showing: 'showing'\n};\n\n/**\n * @file track.js\n */\n/**\n * A Track class that contains all of the common functionality for {@link AudioTrack},\n * {@link VideoTrack}, and {@link TextTrack}.\n *\n * > Note: This class should not be used directly\n *\n * @see {@link https://html.spec.whatwg.org/multipage/embedded-content.html}\n * @extends EventTarget\n * @abstract\n */\n\nvar Track = function (_EventTarget) {\n  inherits(Track, _EventTarget);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {string} [options.kind='']\n   *        A valid kind for the track type you are creating.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @abstract\n   */\n  function Track() {\n    var _ret;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, Track);\n\n    var _this = possibleConstructorReturn(this, _EventTarget.call(this));\n\n    var track = _this; // eslint-disable-line\n\n    if (IS_IE8) {\n      track = document.createElement('custom');\n      for (var prop in Track.prototype) {\n        if (prop !== 'constructor') {\n          track[prop] = Track.prototype[prop];\n        }\n      }\n    }\n\n    var trackProps = {\n      id: options.id || 'vjs_track_' + newGUID(),\n      kind: options.kind || '',\n      label: options.label || '',\n      language: options.language || ''\n    };\n\n    /**\n     * @memberof Track\n     * @member {string} id\n     *         The id of this track. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     */\n\n    /**\n     * @memberof Track\n     * @member {string} kind\n     *         The kind of track that this is. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     */\n\n    /**\n     * @memberof Track\n     * @member {string} label\n     *         The label of this track. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     */\n\n    /**\n     * @memberof Track\n     * @member {string} language\n     *         The two letter language code for this track. Cannot be changed after\n     *         creation.\n     * @instance\n     *\n     * @readonly\n     */\n\n    var _loop = function _loop(key) {\n      Object.defineProperty(track, key, {\n        get: function get$$1() {\n          return trackProps[key];\n        },\n        set: function set$$1() {}\n      });\n    };\n\n    for (var key in trackProps) {\n      _loop(key);\n    }\n\n    return _ret = track, possibleConstructorReturn(_this, _ret);\n  }\n\n  return Track;\n}(EventTarget);\n\n/**\n * @file url.js\n * @module url\n */\n/**\n * @typedef {Object} url:URLObject\n *\n * @property {string} protocol\n *           The protocol of the url that was parsed.\n *\n * @property {string} hostname\n *           The hostname of the url that was parsed.\n *\n * @property {string} port\n *           The port of the url that was parsed.\n *\n * @property {string} pathname\n *           The pathname of the url that was parsed.\n *\n * @property {string} search\n *           The search query of the url that was parsed.\n *\n * @property {string} hash\n *           The hash of the url that was parsed.\n *\n * @property {string} host\n *           The host of the url that was parsed.\n */\n\n/**\n * Resolve and parse the elements of a URL.\n *\n * @param  {String} url\n *         The url to parse\n *\n * @return {url:URLObject}\n *         An object of url details\n */\nvar parseUrl = function parseUrl(url) {\n  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];\n\n  // add the url to an anchor and let the browser parse the URL\n  var a = document.createElement('a');\n\n  a.href = url;\n\n  // IE8 (and 9?) Fix\n  // ie8 doesn't parse the URL correctly until the anchor is actually\n  // added to the body, and an innerHTML is needed to trigger the parsing\n  var addToBody = a.host === '' && a.protocol !== 'file:';\n  var div = void 0;\n\n  if (addToBody) {\n    div = document.createElement('div');\n    div.innerHTML = '<a href=\"' + url + '\"></a>';\n    a = div.firstChild;\n    // prevent the div from affecting layout\n    div.setAttribute('style', 'display:none; position:absolute;');\n    document.body.appendChild(div);\n  }\n\n  // Copy the specific URL properties to a new object\n  // This is also needed for IE8 because the anchor loses its\n  // properties when it's removed from the dom\n  var details = {};\n\n  for (var i = 0; i < props.length; i++) {\n    details[props[i]] = a[props[i]];\n  }\n\n  // IE9 adds the port to the host property unlike everyone else. If\n  // a port identifier is added for standard ports, strip it.\n  if (details.protocol === 'http:') {\n    details.host = details.host.replace(/:80$/, '');\n  }\n\n  if (details.protocol === 'https:') {\n    details.host = details.host.replace(/:443$/, '');\n  }\n\n  if (!details.protocol) {\n    details.protocol = window.location.protocol;\n  }\n\n  if (addToBody) {\n    document.body.removeChild(div);\n  }\n\n  return details;\n};\n\n/**\n * Get absolute version of relative URL. Used to tell flash correct URL.\n *\n *\n * @param  {string} url\n *         URL to make absolute\n *\n * @return {string}\n *         Absolute URL\n *\n * @see http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\n */\nvar getAbsoluteURL = function getAbsoluteURL(url) {\n  // Check if absolute URL\n  if (!url.match(/^https?:\\/\\//)) {\n    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.\n    var div = document.createElement('div');\n\n    div.innerHTML = '<a href=\"' + url + '\">x</a>';\n    url = div.firstChild.href;\n  }\n\n  return url;\n};\n\n/**\n * Returns the extension of the passed file name. It will return an empty string\n * if passed an invalid path.\n *\n * @param {string} path\n *        The fileName path like '/path/to/file.mp4'\n *\n * @returns {string}\n *          The extension in lower case or an empty string if no\n *          extension could be found.\n */\nvar getFileExtension = function getFileExtension(path) {\n  if (typeof path === 'string') {\n    var splitPathRe = /^(\\/?)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?)(\\.([^\\.\\/\\?]+)))(?:[\\/]*|[\\?].*)$/i;\n    var pathParts = splitPathRe.exec(path);\n\n    if (pathParts) {\n      return pathParts.pop().toLowerCase();\n    }\n  }\n\n  return '';\n};\n\n/**\n * Returns whether the url passed is a cross domain request or not.\n *\n * @param {string} url\n *        The url to check.\n *\n * @return {boolean}\n *         Whether it is a cross domain request or not.\n */\nvar isCrossOrigin = function isCrossOrigin(url) {\n  var winLoc = window.location;\n  var urlInfo = parseUrl(url);\n\n  // IE8 protocol relative urls will return ':' for protocol\n  var srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;\n\n  // Check if url is for another domain/origin\n  // IE8 doesn't know location.origin, so we won't rely on it here\n  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;\n\n  return crossOrigin;\n};\n\nvar Url = (Object.freeze || Object)({\n\tparseUrl: parseUrl,\n\tgetAbsoluteURL: getAbsoluteURL,\n\tgetFileExtension: getFileExtension,\n\tisCrossOrigin: isCrossOrigin\n});\n\n/**\n * @file text-track.js\n */\n/**\n * Takes a webvtt file contents and parses it into cues\n *\n * @param {string} srcContent\n *        webVTT file contents\n *\n * @param {TextTrack} track\n *        TextTrack to add cues to. Cues come from the srcContent.\n *\n * @private\n */\nvar parseCues = function parseCues(srcContent, track) {\n  var parser = new window.WebVTT.Parser(window, window.vttjs, window.WebVTT.StringDecoder());\n  var errors = [];\n\n  parser.oncue = function (cue) {\n    track.addCue(cue);\n  };\n\n  parser.onparsingerror = function (error) {\n    errors.push(error);\n  };\n\n  parser.onflush = function () {\n    track.trigger({\n      type: 'loadeddata',\n      target: track\n    });\n  };\n\n  parser.parse(srcContent);\n  if (errors.length > 0) {\n    if (window.console && window.console.groupCollapsed) {\n      window.console.groupCollapsed('Text Track parsing errors for ' + track.src);\n    }\n    errors.forEach(function (error) {\n      return log$1.error(error);\n    });\n    if (window.console && window.console.groupEnd) {\n      window.console.groupEnd();\n    }\n  }\n\n  parser.flush();\n};\n\n/**\n * Load a `TextTrack` from a specifed url.\n *\n * @param {string} src\n *        Url to load track from.\n *\n * @param {TextTrack} track\n *        Track to add cues to. Comes from the content at the end of `url`.\n *\n * @private\n */\nvar loadTrack = function loadTrack(src, track) {\n  var opts = {\n    uri: src\n  };\n  var crossOrigin = isCrossOrigin(src);\n\n  if (crossOrigin) {\n    opts.cors = crossOrigin;\n  }\n\n  xhr(opts, bind(this, function (err, response, responseBody) {\n    if (err) {\n      return log$1.error(err, response);\n    }\n\n    track.loaded_ = true;\n\n    // Make sure that vttjs has loaded, otherwise, wait till it finished loading\n    // NOTE: this is only used for the alt/video.novtt.js build\n    if (typeof window.WebVTT !== 'function') {\n      if (track.tech_) {\n        var loadHandler = function loadHandler() {\n          return parseCues(responseBody, track);\n        };\n\n        track.tech_.on('vttjsloaded', loadHandler);\n        track.tech_.on('vttjserror', function () {\n          log$1.error('vttjs failed to load, stopping trying to process ' + track.src);\n          track.tech_.off('vttjsloaded', loadHandler);\n        });\n      }\n    } else {\n      parseCues(responseBody, track);\n    }\n  }));\n};\n\n/**\n * A representation of a single `TextTrack`.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack}\n * @extends Track\n */\n\nvar TextTrack = function (_Track) {\n  inherits(TextTrack, _Track);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} options={}\n   *        Object of option names and values\n   *\n   * @param {Tech} options.tech\n   *        A reference to the tech that owns this TextTrack.\n   *\n   * @param {TextTrack~Kind} [options.kind='subtitles']\n   *        A valid text track kind.\n   *\n   * @param {TextTrack~Mode} [options.mode='disabled']\n   *        A valid text track mode.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this TextTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {string} [options.srclang='']\n   *        A valid two character language code. An alternative, but deprioritized\n   *        vesion of `options.language`\n   *\n   * @param {string} [options.src]\n   *        A url to TextTrack cues.\n   *\n   * @param {boolean} [options.default]\n   *        If this track should default to on or off.\n   */\n  function TextTrack() {\n    var _this, _ret;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, TextTrack);\n\n    if (!options.tech) {\n      throw new Error('A tech was not provided.');\n    }\n\n    var settings = mergeOptions(options, {\n      kind: TextTrackKind[options.kind] || 'subtitles',\n      language: options.language || options.srclang || ''\n    });\n    var mode = TextTrackMode[settings.mode] || 'disabled';\n    var default_ = settings['default'];\n\n    if (settings.kind === 'metadata' || settings.kind === 'chapters') {\n      mode = 'hidden';\n    }\n    // on IE8 this will be a document element\n    // for every other browser this will be a normal object\n    var tt = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);\n\n    tt.tech_ = settings.tech;\n\n    if (IS_IE8) {\n      for (var prop in TextTrack.prototype) {\n        if (prop !== 'constructor') {\n          tt[prop] = TextTrack.prototype[prop];\n        }\n      }\n    }\n\n    tt.cues_ = [];\n    tt.activeCues_ = [];\n\n    var cues = new TextTrackCueList(tt.cues_);\n    var activeCues = new TextTrackCueList(tt.activeCues_);\n    var changed = false;\n    var timeupdateHandler = bind(tt, function () {\n\n      // Accessing this.activeCues for the side-effects of updating itself\n      // due to it's nature as a getter function. Do not remove or cues will\n      // stop updating!\n      /* eslint-disable no-unused-expressions */\n      this.activeCues;\n      /* eslint-enable no-unused-expressions */\n      if (changed) {\n        this.trigger('cuechange');\n        changed = false;\n      }\n    });\n\n    if (mode !== 'disabled') {\n      tt.tech_.ready(function () {\n        tt.tech_.on('timeupdate', timeupdateHandler);\n      }, true);\n    }\n\n    /**\n     * @memberof TextTrack\n     * @member {boolean} default\n     *         If this track was set to be on or off by default. Cannot be changed after\n     *         creation.\n     * @instance\n     *\n     * @readonly\n     */\n    Object.defineProperty(tt, 'default', {\n      get: function get$$1() {\n        return default_;\n      },\n      set: function set$$1() {}\n    });\n\n    /**\n     * @memberof TextTrack\n     * @member {string} mode\n     *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will\n     *         not be set if setting to an invalid mode.\n     * @instance\n     *\n     * @fires TextTrack#modechange\n     */\n    Object.defineProperty(tt, 'mode', {\n      get: function get$$1() {\n        return mode;\n      },\n      set: function set$$1(newMode) {\n        var _this2 = this;\n\n        if (!TextTrackMode[newMode]) {\n          return;\n        }\n        mode = newMode;\n        if (mode === 'showing') {\n\n          this.tech_.ready(function () {\n            _this2.tech_.on('timeupdate', timeupdateHandler);\n          }, true);\n        }\n        /**\n         * An event that fires when mode changes on this track. This allows\n         * the TextTrackList that holds this track to act accordingly.\n         *\n         * > Note: This is not part of the spec!\n         *\n         * @event TextTrack#modechange\n         * @type {EventTarget~Event}\n         */\n        this.trigger('modechange');\n      }\n    });\n\n    /**\n     * @memberof TextTrack\n     * @member {TextTrackCueList} cues\n     *         The text track cue list for this TextTrack.\n     * @instance\n     */\n    Object.defineProperty(tt, 'cues', {\n      get: function get$$1() {\n        if (!this.loaded_) {\n          return null;\n        }\n\n        return cues;\n      },\n      set: function set$$1() {}\n    });\n\n    /**\n     * @memberof TextTrack\n     * @member {TextTrackCueList} activeCues\n     *         The list text track cues that are currently active for this TextTrack.\n     * @instance\n     */\n    Object.defineProperty(tt, 'activeCues', {\n      get: function get$$1() {\n        if (!this.loaded_) {\n          return null;\n        }\n\n        // nothing to do\n        if (this.cues.length === 0) {\n          return activeCues;\n        }\n\n        var ct = this.tech_.currentTime();\n        var active = [];\n\n        for (var i = 0, l = this.cues.length; i < l; i++) {\n          var cue = this.cues[i];\n\n          if (cue.startTime <= ct && cue.endTime >= ct) {\n            active.push(cue);\n          } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {\n            active.push(cue);\n          }\n        }\n\n        changed = false;\n\n        if (active.length !== this.activeCues_.length) {\n          changed = true;\n        } else {\n          for (var _i = 0; _i < active.length; _i++) {\n            if (this.activeCues_.indexOf(active[_i]) === -1) {\n              changed = true;\n            }\n          }\n        }\n\n        this.activeCues_ = active;\n        activeCues.setCues_(this.activeCues_);\n\n        return activeCues;\n      },\n      set: function set$$1() {}\n    });\n\n    if (settings.src) {\n      tt.src = settings.src;\n      loadTrack(settings.src, tt);\n    } else {\n      tt.loaded_ = true;\n    }\n\n    return _ret = tt, possibleConstructorReturn(_this, _ret);\n  }\n\n  /**\n   * Add a cue to the internal list of cues.\n   *\n   * @param {TextTrack~Cue} cue\n   *        The cue to add to our internal list\n   */\n\n\n  TextTrack.prototype.addCue = function addCue(originalCue) {\n    var cue = originalCue;\n\n    if (window.vttjs && !(originalCue instanceof window.vttjs.VTTCue)) {\n      cue = new window.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);\n\n      for (var prop in originalCue) {\n        if (!(prop in cue)) {\n          cue[prop] = originalCue[prop];\n        }\n      }\n\n      // make sure that `id` is copied over\n      cue.id = originalCue.id;\n      cue.originalCue_ = originalCue;\n    }\n\n    var tracks = this.tech_.textTracks();\n\n    for (var i = 0; i < tracks.length; i++) {\n      if (tracks[i] !== this) {\n        tracks[i].removeCue(cue);\n      }\n    }\n\n    this.cues_.push(cue);\n    this.cues.setCues_(this.cues_);\n  };\n\n  /**\n   * Remove a cue from our internal list\n   *\n   * @param {TextTrack~Cue} removeCue\n   *        The cue to remove from our internal list\n   */\n\n\n  TextTrack.prototype.removeCue = function removeCue(_removeCue) {\n    var i = this.cues_.length;\n\n    while (i--) {\n      var cue = this.cues_[i];\n\n      if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {\n        this.cues_.splice(i, 1);\n        this.cues.setCues_(this.cues_);\n        break;\n      }\n    }\n  };\n\n  return TextTrack;\n}(Track);\n\n/**\n * cuechange - One or more cues in the track have become active or stopped being active.\n */\n\n\nTextTrack.prototype.allowedEvents_ = {\n  cuechange: 'cuechange'\n};\n\n/**\n * A representation of a single `AudioTrack`. If it is part of an {@link AudioTrackList}\n * only one `AudioTrack` in the list will be enabled at a time.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack}\n * @extends Track\n */\n\nvar AudioTrack = function (_Track) {\n  inherits(AudioTrack, _Track);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {AudioTrack~Kind} [options.kind='']\n   *        A valid audio track kind\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {boolean} [options.enabled]\n   *        If this track is the one that is currently playing. If this track is part of\n   *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.\n   */\n  function AudioTrack() {\n    var _this, _ret;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, AudioTrack);\n\n    var settings = mergeOptions(options, {\n      kind: AudioTrackKind[options.kind] || ''\n    });\n    // on IE8 this will be a document element\n    // for every other browser this will be a normal object\n    var track = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);\n    var enabled = false;\n\n    if (IS_IE8) {\n      for (var prop in AudioTrack.prototype) {\n        if (prop !== 'constructor') {\n          track[prop] = AudioTrack.prototype[prop];\n        }\n      }\n    }\n    /**\n     * @memberof AudioTrack\n     * @member {boolean} enabled\n     *         If this `AudioTrack` is enabled or not. When setting this will\n     *         fire {@link AudioTrack#enabledchange} if the state of enabled is changed.\n     * @instance\n     *\n     * @fires VideoTrack#selectedchange\n     */\n    Object.defineProperty(track, 'enabled', {\n      get: function get$$1() {\n        return enabled;\n      },\n      set: function set$$1(newEnabled) {\n        // an invalid or unchanged value\n        if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {\n          return;\n        }\n        enabled = newEnabled;\n\n        /**\n         * An event that fires when enabled changes on this track. This allows\n         * the AudioTrackList that holds this track to act accordingly.\n         *\n         * > Note: This is not part of the spec! Native tracks will do\n         *         this internally without an event.\n         *\n         * @event AudioTrack#enabledchange\n         * @type {EventTarget~Event}\n         */\n        this.trigger('enabledchange');\n      }\n    });\n\n    // if the user sets this track to selected then\n    // set selected to that true value otherwise\n    // we keep it false\n    if (settings.enabled) {\n      track.enabled = settings.enabled;\n    }\n    track.loaded_ = true;\n\n    return _ret = track, possibleConstructorReturn(_this, _ret);\n  }\n\n  return AudioTrack;\n}(Track);\n\n/**\n * A representation of a single `VideoTrack`.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack}\n * @extends Track\n */\n\nvar VideoTrack = function (_Track) {\n  inherits(VideoTrack, _Track);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {string} [options.kind='']\n   *        A valid {@link VideoTrack~Kind}\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {boolean} [options.selected]\n   *        If this track is the one that is currently playing.\n   */\n  function VideoTrack() {\n    var _this, _ret;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, VideoTrack);\n\n    var settings = mergeOptions(options, {\n      kind: VideoTrackKind[options.kind] || ''\n    });\n\n    // on IE8 this will be a document element\n    // for every other browser this will be a normal object\n    var track = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);\n    var selected = false;\n\n    if (IS_IE8) {\n      for (var prop in VideoTrack.prototype) {\n        if (prop !== 'constructor') {\n          track[prop] = VideoTrack.prototype[prop];\n        }\n      }\n    }\n\n    /**\n     * @memberof VideoTrack\n     * @member {boolean} selected\n     *         If this `VideoTrack` is selected or not. When setting this will\n     *         fire {@link VideoTrack#selectedchange} if the state of selected changed.\n     * @instance\n     *\n     * @fires VideoTrack#selectedchange\n     */\n    Object.defineProperty(track, 'selected', {\n      get: function get$$1() {\n        return selected;\n      },\n      set: function set$$1(newSelected) {\n        // an invalid or unchanged value\n        if (typeof newSelected !== 'boolean' || newSelected === selected) {\n          return;\n        }\n        selected = newSelected;\n\n        /**\n         * An event that fires when selected changes on this track. This allows\n         * the VideoTrackList that holds this track to act accordingly.\n         *\n         * > Note: This is not part of the spec! Native tracks will do\n         *         this internally without an event.\n         *\n         * @event VideoTrack#selectedchange\n         * @type {EventTarget~Event}\n         */\n        this.trigger('selectedchange');\n      }\n    });\n\n    // if the user sets this track to selected then\n    // set selected to that true value otherwise\n    // we keep it false\n    if (settings.selected) {\n      track.selected = settings.selected;\n    }\n\n    return _ret = track, possibleConstructorReturn(_this, _ret);\n  }\n\n  return VideoTrack;\n}(Track);\n\n/**\n * @file html-track-element.js\n */\n\n/**\n * @memberof HTMLTrackElement\n * @typedef {HTMLTrackElement~ReadyState}\n * @enum {number}\n */\nvar NONE = 0;\nvar LOADING = 1;\nvar LOADED = 2;\nvar ERROR = 3;\n\n/**\n * A single track represented in the DOM.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement}\n * @extends EventTarget\n */\n\nvar HTMLTrackElement = function (_EventTarget) {\n  inherits(HTMLTrackElement, _EventTarget);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Object} options={}\n   *        Object of option names and values\n   *\n   * @param {Tech} options.tech\n   *        A reference to the tech that owns this HTMLTrackElement.\n   *\n   * @param {TextTrack~Kind} [options.kind='subtitles']\n   *        A valid text track kind.\n   *\n   * @param {TextTrack~Mode} [options.mode='disabled']\n   *        A valid text track mode.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this TextTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {string} [options.srclang='']\n   *        A valid two character language code. An alternative, but deprioritized\n   *        vesion of `options.language`\n   *\n   * @param {string} [options.src]\n   *        A url to TextTrack cues.\n   *\n   * @param {boolean} [options.default]\n   *        If this track should default to on or off.\n   */\n  function HTMLTrackElement() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, HTMLTrackElement);\n\n    var _this = possibleConstructorReturn(this, _EventTarget.call(this));\n\n    var readyState = void 0;\n    var trackElement = _this; // eslint-disable-line\n\n    if (IS_IE8) {\n      trackElement = document.createElement('custom');\n\n      for (var prop in HTMLTrackElement.prototype) {\n        if (prop !== 'constructor') {\n          trackElement[prop] = HTMLTrackElement.prototype[prop];\n        }\n      }\n    }\n\n    var track = new TextTrack(options);\n\n    trackElement.kind = track.kind;\n    trackElement.src = track.src;\n    trackElement.srclang = track.language;\n    trackElement.label = track.label;\n    trackElement['default'] = track['default'];\n\n    /**\n     * @memberof HTMLTrackElement\n     * @member {HTMLTrackElement~ReadyState} readyState\n     *         The current ready state of the track element.\n     * @instance\n     */\n    Object.defineProperty(trackElement, 'readyState', {\n      get: function get$$1() {\n        return readyState;\n      }\n    });\n\n    /**\n     * @memberof HTMLTrackElement\n     * @member {TextTrack} track\n     *         The underlying TextTrack object.\n     * @instance\n     *\n     */\n    Object.defineProperty(trackElement, 'track', {\n      get: function get$$1() {\n        return track;\n      }\n    });\n\n    readyState = NONE;\n\n    /**\n     * @listens TextTrack#loadeddata\n     * @fires HTMLTrackElement#load\n     */\n    track.addEventListener('loadeddata', function () {\n      readyState = LOADED;\n\n      trackElement.trigger({\n        type: 'load',\n        target: trackElement\n      });\n    });\n\n    if (IS_IE8) {\n      var _ret;\n\n      return _ret = trackElement, possibleConstructorReturn(_this, _ret);\n    }\n    return _this;\n  }\n\n  return HTMLTrackElement;\n}(EventTarget);\n\nHTMLTrackElement.prototype.allowedEvents_ = {\n  load: 'load'\n};\n\nHTMLTrackElement.NONE = NONE;\nHTMLTrackElement.LOADING = LOADING;\nHTMLTrackElement.LOADED = LOADED;\nHTMLTrackElement.ERROR = ERROR;\n\n/*\n * This file contains all track properties that are used in\n * player.js, tech.js, html5.js and possibly other techs in the future.\n */\n\nvar NORMAL = {\n  audio: {\n    ListClass: AudioTrackList,\n    TrackClass: AudioTrack,\n    capitalName: 'Audio'\n  },\n  video: {\n    ListClass: VideoTrackList,\n    TrackClass: VideoTrack,\n    capitalName: 'Video'\n  },\n  text: {\n    ListClass: TextTrackList,\n    TrackClass: TextTrack,\n    capitalName: 'Text'\n  }\n};\n\nObject.keys(NORMAL).forEach(function (type) {\n  NORMAL[type].getterName = type + 'Tracks';\n  NORMAL[type].privateName = type + 'Tracks_';\n});\n\nvar REMOTE = {\n  remoteText: {\n    ListClass: TextTrackList,\n    TrackClass: TextTrack,\n    capitalName: 'RemoteText',\n    getterName: 'remoteTextTracks',\n    privateName: 'remoteTextTracks_'\n  },\n  remoteTextEl: {\n    ListClass: HtmlTrackElementList,\n    TrackClass: HTMLTrackElement,\n    capitalName: 'RemoteTextTrackEls',\n    getterName: 'remoteTextTrackEls',\n    privateName: 'remoteTextTrackEls_'\n  }\n};\n\nvar ALL = mergeOptions(NORMAL, REMOTE);\n\nREMOTE.names = Object.keys(REMOTE);\nNORMAL.names = Object.keys(NORMAL);\nALL.names = [].concat(REMOTE.names).concat(NORMAL.names);\n\n/**\n * @file tech.js\n */\n\n/**\n * An Object containing a structure like: `{src: 'url', type: 'mimetype'}` or string\n * that just contains the src url alone.\n * * `var SourceObject = {src: 'http://ex.com/video.mp4', type: 'video/mp4'};`\n   * `var SourceString = 'http://example.com/some-video.mp4';`\n *\n * @typedef {Object|string} Tech~SourceObject\n *\n * @property {string} src\n *           The url to the source\n *\n * @property {string} type\n *           The mime type of the source\n */\n\n/**\n * A function used by {@link Tech} to create a new {@link TextTrack}.\n *\n * @private\n *\n * @param {Tech} self\n *        An instance of the Tech class.\n *\n * @param {string} kind\n *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n *\n * @param {string} [label]\n *        Label to identify the text track\n *\n * @param {string} [language]\n *        Two letter language abbreviation\n *\n * @param {Object} [options={}]\n *        An object with additional text track options\n *\n * @return {TextTrack}\n *          The text track that was created.\n */\nfunction createTrackHelper(self, kind, label, language) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  var tracks = self.textTracks();\n\n  options.kind = kind;\n\n  if (label) {\n    options.label = label;\n  }\n  if (language) {\n    options.language = language;\n  }\n  options.tech = self;\n\n  var track = new ALL.text.TrackClass(options);\n\n  tracks.addTrack(track);\n\n  return track;\n}\n\n/**\n * This is the base class for media playback technology controllers, such as\n * {@link Flash} and {@link HTML5}\n *\n * @extends Component\n */\n\nvar Tech = function (_Component) {\n  inherits(Tech, _Component);\n\n  /**\n   * Create an instance of this Tech.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} ready\n   *        Callback function to call when the `HTML5` Tech is ready.\n   */\n  function Tech() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var ready = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n    classCallCheck(this, Tech);\n\n    // we don't want the tech to report user activity automatically.\n    // This is done manually in addControlsListeners\n    options.reportTouchActivity = false;\n\n    // keep track of whether the current source has played at all to\n    // implement a very limited played()\n    var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));\n\n    _this.hasStarted_ = false;\n    _this.on('playing', function () {\n      this.hasStarted_ = true;\n    });\n    _this.on('loadstart', function () {\n      this.hasStarted_ = false;\n    });\n\n    ALL.names.forEach(function (name) {\n      var props = ALL[name];\n\n      if (options && options[props.getterName]) {\n        _this[props.privateName] = options[props.getterName];\n      }\n    });\n\n    // Manually track progress in cases where the browser/flash player doesn't report it.\n    if (!_this.featuresProgressEvents) {\n      _this.manualProgressOn();\n    }\n\n    // Manually track timeupdates in cases where the browser/flash player doesn't report it.\n    if (!_this.featuresTimeupdateEvents) {\n      _this.manualTimeUpdatesOn();\n    }\n\n    ['Text', 'Audio', 'Video'].forEach(function (track) {\n      if (options['native' + track + 'Tracks'] === false) {\n        _this['featuresNative' + track + 'Tracks'] = false;\n      }\n    });\n\n    if (options.nativeCaptions === false || options.nativeTextTracks === false) {\n      _this.featuresNativeTextTracks = false;\n    } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {\n      _this.featuresNativeTextTracks = true;\n    }\n\n    if (!_this.featuresNativeTextTracks) {\n      _this.emulateTextTracks();\n    }\n\n    _this.autoRemoteTextTracks_ = new ALL.text.ListClass();\n\n    _this.initTrackListeners();\n\n    // Turn on component tap events only if not using native controls\n    if (!options.nativeControlsForTouch) {\n      _this.emitTapEvents();\n    }\n\n    if (_this.constructor) {\n      _this.name_ = _this.constructor.name || 'Unknown Tech';\n    }\n    return _this;\n  }\n\n  /* Fallbacks for unsupported event types\n  ================================================================================ */\n\n  /**\n   * Polyfill the `progress` event for browsers that don't support it natively.\n   *\n   * @see {@link Tech#trackProgress}\n   */\n\n\n  Tech.prototype.manualProgressOn = function manualProgressOn() {\n    this.on('durationchange', this.onDurationChange);\n\n    this.manualProgress = true;\n\n    // Trigger progress watching when a source begins loading\n    this.one('ready', this.trackProgress);\n  };\n\n  /**\n   * Turn off the polyfill for `progress` events that was created in\n   * {@link Tech#manualProgressOn}\n   */\n\n\n  Tech.prototype.manualProgressOff = function manualProgressOff() {\n    this.manualProgress = false;\n    this.stopTrackingProgress();\n\n    this.off('durationchange', this.onDurationChange);\n  };\n\n  /**\n   * This is used to trigger a `progress` event when the buffered percent changes. It\n   * sets an interval function that will be called every 500 milliseconds to check if the\n   * buffer end percent has changed.\n   *\n   * > This function is called by {@link Tech#manualProgressOn}\n   *\n   * @param {EventTarget~Event} event\n   *        The `ready` event that caused this to run.\n   *\n   * @listens Tech#ready\n   * @fires Tech#progress\n   */\n\n\n  Tech.prototype.trackProgress = function trackProgress(event) {\n    this.stopTrackingProgress();\n    this.progressInterval = this.setInterval(bind(this, function () {\n      // Don't trigger unless buffered amount is greater than last time\n\n      var numBufferedPercent = this.bufferedPercent();\n\n      if (this.bufferedPercent_ !== numBufferedPercent) {\n        /**\n         * See {@link Player#progress}\n         *\n         * @event Tech#progress\n         * @type {EventTarget~Event}\n         */\n        this.trigger('progress');\n      }\n\n      this.bufferedPercent_ = numBufferedPercent;\n\n      if (numBufferedPercent === 1) {\n        this.stopTrackingProgress();\n      }\n    }), 500);\n  };\n\n  /**\n   * Update our internal duration on a `durationchange` event by calling\n   * {@link Tech#duration}.\n   *\n   * @param {EventTarget~Event} event\n   *        The `durationchange` event that caused this to run.\n   *\n   * @listens Tech#durationchange\n   */\n\n\n  Tech.prototype.onDurationChange = function onDurationChange(event) {\n    this.duration_ = this.duration();\n  };\n\n  /**\n   * Get and create a `TimeRange` object for buffering.\n   *\n   * @return {TimeRange}\n   *         The time range object that was created.\n   */\n\n\n  Tech.prototype.buffered = function buffered() {\n    return createTimeRanges(0, 0);\n  };\n\n  /**\n   * Get the percentage of the current video that is currently buffered.\n   *\n   * @return {number}\n   *         A number from 0 to 1 that represents the decimal percentage of the\n   *         video that is buffered.\n   *\n   */\n\n\n  Tech.prototype.bufferedPercent = function bufferedPercent$$1() {\n    return bufferedPercent(this.buffered(), this.duration_);\n  };\n\n  /**\n   * Turn off the polyfill for `progress` events that was created in\n   * {@link Tech#manualProgressOn}\n   * Stop manually tracking progress events by clearing the interval that was set in\n   * {@link Tech#trackProgress}.\n   */\n\n\n  Tech.prototype.stopTrackingProgress = function stopTrackingProgress() {\n    this.clearInterval(this.progressInterval);\n  };\n\n  /**\n   * Polyfill the `timeupdate` event for browsers that don't support it.\n   *\n   * @see {@link Tech#trackCurrentTime}\n   */\n\n\n  Tech.prototype.manualTimeUpdatesOn = function manualTimeUpdatesOn() {\n    this.manualTimeUpdates = true;\n\n    this.on('play', this.trackCurrentTime);\n    this.on('pause', this.stopTrackingCurrentTime);\n  };\n\n  /**\n   * Turn off the polyfill for `timeupdate` events that was created in\n   * {@link Tech#manualTimeUpdatesOn}\n   */\n\n\n  Tech.prototype.manualTimeUpdatesOff = function manualTimeUpdatesOff() {\n    this.manualTimeUpdates = false;\n    this.stopTrackingCurrentTime();\n    this.off('play', this.trackCurrentTime);\n    this.off('pause', this.stopTrackingCurrentTime);\n  };\n\n  /**\n   * Sets up an interval function to track current time and trigger `timeupdate` every\n   * 250 milliseconds.\n   *\n   * @listens Tech#play\n   * @triggers Tech#timeupdate\n   */\n\n\n  Tech.prototype.trackCurrentTime = function trackCurrentTime() {\n    if (this.currentTimeInterval) {\n      this.stopTrackingCurrentTime();\n    }\n    this.currentTimeInterval = this.setInterval(function () {\n      /**\n       * Triggered at an interval of 250ms to indicated that time is passing in the video.\n       *\n       * @event Tech#timeupdate\n       * @type {EventTarget~Event}\n       */\n      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\n\n      // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\n    }, 250);\n  };\n\n  /**\n   * Stop the interval function created in {@link Tech#trackCurrentTime} so that the\n   * `timeupdate` event is no longer triggered.\n   *\n   * @listens {Tech#pause}\n   */\n\n\n  Tech.prototype.stopTrackingCurrentTime = function stopTrackingCurrentTime() {\n    this.clearInterval(this.currentTimeInterval);\n\n    // #1002 - if the video ends right before the next timeupdate would happen,\n    // the progress bar won't make it all the way to the end\n    this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\n  };\n\n  /**\n   * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},\n   * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.\n   *\n   * @fires Component#dispose\n   */\n\n\n  Tech.prototype.dispose = function dispose() {\n\n    // clear out all tracks because we can't reuse them between techs\n    this.clearTracks(NORMAL.names);\n\n    // Turn off any manual progress or timeupdate tracking\n    if (this.manualProgress) {\n      this.manualProgressOff();\n    }\n\n    if (this.manualTimeUpdates) {\n      this.manualTimeUpdatesOff();\n    }\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Clear out a single `TrackList` or an array of `TrackLists` given their names.\n   *\n   * > Note: Techs without source handlers should call this between sources for `video`\n   *         & `audio` tracks. You don't want to use them between tracks!\n   *\n   * @param {string[]|string} types\n   *        TrackList names to clear, valid names are `video`, `audio`, and\n   *        `text`.\n   */\n\n\n  Tech.prototype.clearTracks = function clearTracks(types) {\n    var _this2 = this;\n\n    types = [].concat(types);\n    // clear out all tracks because we can't reuse them between techs\n    types.forEach(function (type) {\n      var list = _this2[type + 'Tracks']() || [];\n      var i = list.length;\n\n      while (i--) {\n        var track = list[i];\n\n        if (type === 'text') {\n          _this2.removeRemoteTextTrack(track);\n        }\n        list.removeTrack(track);\n      }\n    });\n  };\n\n  /**\n   * Remove any TextTracks added via addRemoteTextTrack that are\n   * flagged for automatic garbage collection\n   */\n\n\n  Tech.prototype.cleanupAutoTextTracks = function cleanupAutoTextTracks() {\n    var list = this.autoRemoteTextTracks_ || [];\n    var i = list.length;\n\n    while (i--) {\n      var track = list[i];\n\n      this.removeRemoteTextTrack(track);\n    }\n  };\n\n  /**\n   * Reset the tech, which will removes all sources and reset the internal readyState.\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.reset = function reset() {};\n\n  /**\n   * Get or set an error on the Tech.\n   *\n   * @param {MediaError} [err]\n   *        Error to set on the Tech\n   *\n   * @return {MediaError|null}\n   *         The current error object on the tech, or null if there isn't one.\n   */\n\n\n  Tech.prototype.error = function error(err) {\n    if (err !== undefined) {\n      this.error_ = new MediaError(err);\n      this.trigger('error');\n    }\n    return this.error_;\n  };\n\n  /**\n   * Returns the `TimeRange`s that have been played through for the current source.\n   *\n   * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.\n   *         It only checks wether the source has played at all or not.\n   *\n   * @return {TimeRange}\n   *         - A single time range if this video has played\n   *         - An empty set of ranges if not.\n   */\n\n\n  Tech.prototype.played = function played() {\n    if (this.hasStarted_) {\n      return createTimeRanges(0, 0);\n    }\n    return createTimeRanges();\n  };\n\n  /**\n   * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was\n   * previously called.\n   *\n   * @fires Tech#timeupdate\n   */\n\n\n  Tech.prototype.setCurrentTime = function setCurrentTime() {\n    // improve the accuracy of manual timeupdates\n    if (this.manualTimeUpdates) {\n      /**\n       * A manual `timeupdate` event.\n       *\n       * @event Tech#timeupdate\n       * @type {EventTarget~Event}\n       */\n      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\n    }\n  };\n\n  /**\n   * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and\n   * {@link TextTrackList} events.\n   *\n   * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.\n   *\n   * @fires Tech#audiotrackchange\n   * @fires Tech#videotrackchange\n   * @fires Tech#texttrackchange\n   */\n\n\n  Tech.prototype.initTrackListeners = function initTrackListeners() {\n    var _this3 = this;\n\n    /**\n     * Triggered when tracks are added or removed on the Tech {@link AudioTrackList}\n     *\n     * @event Tech#audiotrackchange\n     * @type {EventTarget~Event}\n     */\n\n    /**\n     * Triggered when tracks are added or removed on the Tech {@link VideoTrackList}\n     *\n     * @event Tech#videotrackchange\n     * @type {EventTarget~Event}\n     */\n\n    /**\n     * Triggered when tracks are added or removed on the Tech {@link TextTrackList}\n     *\n     * @event Tech#texttrackchange\n     * @type {EventTarget~Event}\n     */\n    NORMAL.names.forEach(function (name) {\n      var props = NORMAL[name];\n      var trackListChanges = function trackListChanges() {\n        _this3.trigger(name + 'trackchange');\n      };\n\n      var tracks = _this3[props.getterName]();\n\n      tracks.addEventListener('removetrack', trackListChanges);\n      tracks.addEventListener('addtrack', trackListChanges);\n\n      _this3.on('dispose', function () {\n        tracks.removeEventListener('removetrack', trackListChanges);\n        tracks.removeEventListener('addtrack', trackListChanges);\n      });\n    });\n  };\n\n  /**\n   * Emulate TextTracks using vtt.js if necessary\n   *\n   * @fires Tech#vttjsloaded\n   * @fires Tech#vttjserror\n   */\n\n\n  Tech.prototype.addWebVttScript_ = function addWebVttScript_() {\n    var _this4 = this;\n\n    if (window.WebVTT) {\n      return;\n    }\n\n    // Initially, Tech.el_ is a child of a dummy-div wait until the Component system\n    // signals that the Tech is ready at which point Tech.el_ is part of the DOM\n    // before inserting the WebVTT script\n    if (document.body.contains(this.el())) {\n\n      // load via require if available and vtt.js script location was not passed in\n      // as an option. novtt builds will turn the above require call into an empty object\n      // which will cause this if check to always fail.\n      if (!this.options_['vtt.js'] && isPlain(vtt) && Object.keys(vtt).length > 0) {\n        this.trigger('vttjsloaded');\n        return;\n      }\n\n      // load vtt.js via the script location option or the cdn of no location was\n      // passed in\n      var script = document.createElement('script');\n\n      script.src = this.options_['vtt.js'] || 'https://vjs.zencdn.net/vttjs/0.12.4/vtt.min.js';\n      script.onload = function () {\n        /**\n         * Fired when vtt.js is loaded.\n         *\n         * @event Tech#vttjsloaded\n         * @type {EventTarget~Event}\n         */\n        _this4.trigger('vttjsloaded');\n      };\n      script.onerror = function () {\n        /**\n         * Fired when vtt.js was not loaded due to an error\n         *\n         * @event Tech#vttjsloaded\n         * @type {EventTarget~Event}\n         */\n        _this4.trigger('vttjserror');\n      };\n      this.on('dispose', function () {\n        script.onload = null;\n        script.onerror = null;\n      });\n      // but have not loaded yet and we set it to true before the inject so that\n      // we don't overwrite the injected window.WebVTT if it loads right away\n      window.WebVTT = true;\n      this.el().parentNode.appendChild(script);\n    } else {\n      this.ready(this.addWebVttScript_);\n    }\n  };\n\n  /**\n   * Emulate texttracks\n   *\n   */\n\n\n  Tech.prototype.emulateTextTracks = function emulateTextTracks() {\n    var _this5 = this;\n\n    var tracks = this.textTracks();\n    var remoteTracks = this.remoteTextTracks();\n    var handleAddTrack = function handleAddTrack(e) {\n      return tracks.addTrack(e.track);\n    };\n    var handleRemoveTrack = function handleRemoveTrack(e) {\n      return tracks.removeTrack(e.track);\n    };\n\n    remoteTracks.on('addtrack', handleAddTrack);\n    remoteTracks.on('removetrack', handleRemoveTrack);\n\n    this.addWebVttScript_();\n\n    var updateDisplay = function updateDisplay() {\n      return _this5.trigger('texttrackchange');\n    };\n\n    var textTracksChanges = function textTracksChanges() {\n      updateDisplay();\n\n      for (var i = 0; i < tracks.length; i++) {\n        var track = tracks[i];\n\n        track.removeEventListener('cuechange', updateDisplay);\n        if (track.mode === 'showing') {\n          track.addEventListener('cuechange', updateDisplay);\n        }\n      }\n    };\n\n    textTracksChanges();\n    tracks.addEventListener('change', textTracksChanges);\n    tracks.addEventListener('addtrack', textTracksChanges);\n    tracks.addEventListener('removetrack', textTracksChanges);\n\n    this.on('dispose', function () {\n      remoteTracks.off('addtrack', handleAddTrack);\n      remoteTracks.off('removetrack', handleRemoveTrack);\n      tracks.removeEventListener('change', textTracksChanges);\n      tracks.removeEventListener('addtrack', textTracksChanges);\n      tracks.removeEventListener('removetrack', textTracksChanges);\n\n      for (var i = 0; i < tracks.length; i++) {\n        var track = tracks[i];\n\n        track.removeEventListener('cuechange', updateDisplay);\n      }\n    });\n  };\n\n  /**\n   * Create and returns a remote {@link TextTrack} object.\n   *\n   * @param {string} kind\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n   *\n   * @param {string} [label]\n   *        Label to identify the text track\n   *\n   * @param {string} [language]\n   *        Two letter language abbreviation\n   *\n   * @return {TextTrack}\n   *         The TextTrack that gets created.\n   */\n\n\n  Tech.prototype.addTextTrack = function addTextTrack(kind, label, language) {\n    if (!kind) {\n      throw new Error('TextTrack kind is required but was not provided');\n    }\n\n    return createTrackHelper(this, kind, label, language);\n  };\n\n  /**\n   * Create an emulated TextTrack for use by addRemoteTextTrack\n   *\n   * This is intended to be overridden by classes that inherit from\n   * Tech in order to create native or custom TextTracks.\n   *\n   * @param {Object} options\n   *        The object should contain the options to initialize the TextTrack with.\n   *\n   * @param {string} [options.kind]\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n   *\n   * @param {string} [options.label].\n   *        Label to identify the text track\n   *\n   * @param {string} [options.language]\n   *        Two letter language abbreviation.\n   *\n   * @return {HTMLTrackElement}\n   *         The track element that gets created.\n   */\n\n\n  Tech.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {\n    var track = mergeOptions(options, {\n      tech: this\n    });\n\n    return new REMOTE.remoteTextEl.TrackClass(track);\n  };\n\n  /**\n   * Creates a remote text track object and returns an html track element.\n   *\n   * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.\n   *\n   * @param {Object} options\n   *        See {@link Tech#createRemoteTextTrack} for more detailed properties.\n   *\n   * @param {boolean} [manualCleanup=true]\n   *        - When false: the TextTrack will be automatically removed from the video\n   *          element whenever the source changes\n   *        - When True: The TextTrack will have to be cleaned up manually\n   *\n   * @return {HTMLTrackElement}\n   *         An Html Track Element.\n   *\n   * @deprecated The default functionality for this function will be equivalent\n   *             to \"manualCleanup=false\" in the future. The manualCleanup parameter will\n   *             also be removed.\n   */\n\n\n  Tech.prototype.addRemoteTextTrack = function addRemoteTextTrack() {\n    var _this6 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var manualCleanup = arguments[1];\n\n    var htmlTrackElement = this.createRemoteTextTrack(options);\n\n    if (manualCleanup !== true && manualCleanup !== false) {\n      // deprecation warning\n      log$1.warn('Calling addRemoteTextTrack without explicitly setting the \"manualCleanup\" parameter to `true` is deprecated and default to `false` in future version of video.js');\n      manualCleanup = true;\n    }\n\n    // store HTMLTrackElement and TextTrack to remote list\n    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);\n    this.remoteTextTracks().addTrack(htmlTrackElement.track);\n\n    if (manualCleanup !== true) {\n      // create the TextTrackList if it doesn't exist\n      this.ready(function () {\n        return _this6.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);\n      });\n    }\n\n    return htmlTrackElement;\n  };\n\n  /**\n   * Remove a remote text track from the remote `TextTrackList`.\n   *\n   * @param {TextTrack} track\n   *        `TextTrack` to remove from the `TextTrackList`\n   */\n\n\n  Tech.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {\n    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);\n\n    // remove HTMLTrackElement and TextTrack from remote list\n    this.remoteTextTrackEls().removeTrackElement_(trackElement);\n    this.remoteTextTracks().removeTrack(track);\n    this.autoRemoteTextTracks_.removeTrack(track);\n  };\n\n  /**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object}\n   *         An object with supported media playback quality metrics\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\n    return {};\n  };\n\n  /**\n   * A method to set a poster from a `Tech`.\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.setPoster = function setPoster() {};\n\n  /**\n   * A method to check for the presence of the 'playsinine' <video> attribute.\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.playsinline = function playsinline() {};\n\n  /**\n   * A method to set or unset the 'playsinine' <video> attribute.\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.setPlaysinline = function setPlaysinline() {};\n\n  /*\n   * Check if the tech can support the given mime-type.\n   *\n   * The base tech does not support any type, but source handlers might\n   * overwrite this.\n   *\n   * @param  {string} type\n   *         The mimetype to check for support\n   *\n   * @return {string}\n   *         'probably', 'maybe', or empty string\n   *\n   * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}\n   *\n   * @abstract\n   */\n\n\n  Tech.prototype.canPlayType = function canPlayType() {\n    return '';\n  };\n\n  /**\n   * Check if the type is supported by this tech.\n   *\n   * The base tech does not support any type, but source handlers might\n   * overwrite this.\n   *\n   * @param {string} type\n   *        The media type to check\n   * @return {string} Returns the native video element's response\n   */\n\n\n  Tech.canPlayType = function canPlayType() {\n    return '';\n  };\n\n  /**\n   * Check if the tech can support the given source\n   * @param {Object} srcObj\n   *        The source object\n   * @param {Object} options\n   *        The options passed to the tech\n   * @return {string} 'probably', 'maybe', or '' (empty string)\n   */\n\n\n  Tech.canPlaySource = function canPlaySource(srcObj, options) {\n    return Tech.canPlayType(srcObj.type);\n  };\n\n  /*\n   * Return whether the argument is a Tech or not.\n   * Can be passed either a Class like `Html5` or a instance like `player.tech_`\n   *\n   * @param {Object} component\n   *        The item to check\n   *\n   * @return {boolean}\n   *         Whether it is a tech or not\n   *         - True if it is a tech\n   *         - False if it is not\n   */\n\n\n  Tech.isTech = function isTech(component) {\n    return component.prototype instanceof Tech || component instanceof Tech || component === Tech;\n  };\n\n  /**\n   * Registers a `Tech` into a shared list for videojs.\n   *\n   * @param {string} name\n   *        Name of the `Tech` to register.\n   *\n   * @param {Object} tech\n   *        The `Tech` class to register.\n   */\n\n\n  Tech.registerTech = function registerTech(name, tech) {\n    if (!Tech.techs_) {\n      Tech.techs_ = {};\n    }\n\n    if (!Tech.isTech(tech)) {\n      throw new Error('Tech ' + name + ' must be a Tech');\n    }\n\n    if (!Tech.canPlayType) {\n      throw new Error('Techs must have a static canPlayType method on them');\n    }\n    if (!Tech.canPlaySource) {\n      throw new Error('Techs must have a static canPlaySource method on them');\n    }\n\n    name = toTitleCase(name);\n\n    Tech.techs_[name] = tech;\n    if (name !== 'Tech') {\n      // camel case the techName for use in techOrder\n      Tech.defaultTechOrder_.push(name);\n    }\n    return tech;\n  };\n\n  /**\n   * Get a `Tech` from the shared list by name.\n   *\n   * @param {string} name\n   *        `camelCase` or `TitleCase` name of the Tech to get\n   *\n   * @return {Tech|undefined}\n   *         The `Tech` or undefined if there was no tech with the name requsted.\n   */\n\n\n  Tech.getTech = function getTech(name) {\n    if (!name) {\n      return;\n    }\n\n    name = toTitleCase(name);\n\n    if (Tech.techs_ && Tech.techs_[name]) {\n      return Tech.techs_[name];\n    }\n\n    if (window && window.videojs && window.videojs[name]) {\n      log$1.warn('The ' + name + ' tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)');\n      return window.videojs[name];\n    }\n  };\n\n  return Tech;\n}(Component);\n\n/**\n * Get the {@link VideoTrackList}\n *\n * @returns {VideoTrackList}\n * @method Tech.prototype.videoTracks\n */\n\n/**\n * Get the {@link AudioTrackList}\n *\n * @returns {AudioTrackList}\n * @method Tech.prototype.audioTracks\n */\n\n/**\n * Get the {@link TextTrackList}\n *\n * @returns {TextTrackList}\n * @method Tech.prototype.textTracks\n */\n\n/**\n * Get the remote element {@link TextTrackList}\n *\n * @returns {TextTrackList}\n * @method Tech.prototype.remoteTextTracks\n */\n\n/**\n * Get the remote element {@link HtmlTrackElementList}\n *\n * @returns {HtmlTrackElementList}\n * @method Tech.prototype.remoteTextTrackEls\n */\n\nALL.names.forEach(function (name) {\n  var props = ALL[name];\n\n  Tech.prototype[props.getterName] = function () {\n    this[props.privateName] = this[props.privateName] || new props.ListClass();\n    return this[props.privateName];\n  };\n});\n\n/**\n * List of associated text tracks\n *\n * @type {TextTrackList}\n * @private\n * @property Tech#textTracks_\n */\n\n/**\n * List of associated audio tracks.\n *\n * @type {AudioTrackList}\n * @private\n * @property Tech#audioTracks_\n */\n\n/**\n * List of associated video tracks.\n *\n * @type {VideoTrackList}\n * @private\n * @property Tech#videoTracks_\n */\n\n/**\n * Boolean indicating wether the `Tech` supports volume control.\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresVolumeControl = true;\n\n/**\n * Boolean indicating wether the `Tech` support fullscreen resize control.\n * Resizing plugins using request fullscreen reloads the plugin\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresFullscreenResize = false;\n\n/**\n * Boolean indicating wether the `Tech` supports changing the speed at which the video\n * plays. Examples:\n *   - Set player to play 2x (twice) as fast\n *   - Set player to play 0.5x (half) as fast\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresPlaybackRate = false;\n\n/**\n * Boolean indicating wether the `Tech` supports the `progress` event. This is currently\n * not triggered by video-js-swf. This will be used to determine if\n * {@link Tech#manualProgressOn} should be called.\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresProgressEvents = false;\n\n/**\n * Boolean indicating wether the `Tech` supports the `timeupdate` event. This is currently\n * not triggered by video-js-swf. This will be used to determine if\n * {@link Tech#manualTimeUpdates} should be called.\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresTimeupdateEvents = false;\n\n/**\n * Boolean indicating wether the `Tech` supports the native `TextTrack`s.\n * This will help us integrate with native `TextTrack`s if the browser supports them.\n *\n * @type {boolean}\n * @default\n */\nTech.prototype.featuresNativeTextTracks = false;\n\n/**\n * A functional mixin for techs that want to use the Source Handler pattern.\n * Source handlers are scripts for handling specific formats.\n * The source handler pattern is used for adaptive formats (HLS, DASH) that\n * manually load video data and feed it into a Source Buffer (Media Source Extensions)\n * Example: `Tech.withSourceHandlers.call(MyTech);`\n *\n * @param {Tech} _Tech\n *        The tech to add source handler functions to.\n *\n * @mixes Tech~SourceHandlerAdditions\n */\nTech.withSourceHandlers = function (_Tech) {\n\n  /**\n   * Register a source handler\n   *\n   * @param {Function} handler\n   *        The source handler class\n   *\n   * @param {number} [index]\n   *        Register it at the following index\n   */\n  _Tech.registerSourceHandler = function (handler, index) {\n    var handlers = _Tech.sourceHandlers;\n\n    if (!handlers) {\n      handlers = _Tech.sourceHandlers = [];\n    }\n\n    if (index === undefined) {\n      // add to the end of the list\n      index = handlers.length;\n    }\n\n    handlers.splice(index, 0, handler);\n  };\n\n  /**\n   * Check if the tech can support the given type. Also checks the\n   * Techs sourceHandlers.\n   *\n   * @param {string} type\n   *         The mimetype to check.\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */\n  _Tech.canPlayType = function (type) {\n    var handlers = _Tech.sourceHandlers || [];\n    var can = void 0;\n\n    for (var i = 0; i < handlers.length; i++) {\n      can = handlers[i].canPlayType(type);\n\n      if (can) {\n        return can;\n      }\n    }\n\n    return '';\n  };\n\n  /**\n   * Returns the first source handler that supports the source.\n   *\n   * TODO: Answer question: should 'probably' be prioritized over 'maybe'\n   *\n   * @param {Tech~SourceObject} source\n   *        The source object\n   *\n   * @param {Object} options\n   *        The options passed to the tech\n   *\n   * @return {SourceHandler|null}\n   *          The first source handler that supports the source or null if\n   *          no SourceHandler supports the source\n   */\n  _Tech.selectSourceHandler = function (source, options) {\n    var handlers = _Tech.sourceHandlers || [];\n    var can = void 0;\n\n    for (var i = 0; i < handlers.length; i++) {\n      can = handlers[i].canHandleSource(source, options);\n\n      if (can) {\n        return handlers[i];\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * Check if the tech can support the given source.\n   *\n   * @param {Tech~SourceObject} srcObj\n   *        The source object\n   *\n   * @param {Object} options\n   *        The options passed to the tech\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */\n  _Tech.canPlaySource = function (srcObj, options) {\n    var sh = _Tech.selectSourceHandler(srcObj, options);\n\n    if (sh) {\n      return sh.canHandleSource(srcObj, options);\n    }\n\n    return '';\n  };\n\n  /**\n   * When using a source handler, prefer its implementation of\n   * any function normally provided by the tech.\n   */\n  var deferrable = ['seekable', 'duration'];\n\n  /**\n   * A wrapper around {@link Tech#seekable} that will call a `SourceHandler`s seekable\n   * function if it exists, with a fallback to the Techs seekable function.\n   *\n   * @method _Tech.seekable\n   */\n\n  /**\n   * A wrapper around {@link Tech#duration} that will call a `SourceHandler`s duration\n   * function if it exists, otherwise it will fallback to the techs duration function.\n   *\n   * @method _Tech.duration\n   */\n\n  deferrable.forEach(function (fnName) {\n    var originalFn = this[fnName];\n\n    if (typeof originalFn !== 'function') {\n      return;\n    }\n\n    this[fnName] = function () {\n      if (this.sourceHandler_ && this.sourceHandler_[fnName]) {\n        return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);\n      }\n      return originalFn.apply(this, arguments);\n    };\n  }, _Tech.prototype);\n\n  /**\n   * Create a function for setting the source using a source object\n   * and source handlers.\n   * Should never be called unless a source handler was found.\n   *\n   * @param {Tech~SourceObject} source\n   *        A source object with src and type keys\n   */\n  _Tech.prototype.setSource = function (source) {\n    var sh = _Tech.selectSourceHandler(source, this.options_);\n\n    if (!sh) {\n      // Fall back to a native source hander when unsupported sources are\n      // deliberately set\n      if (_Tech.nativeSourceHandler) {\n        sh = _Tech.nativeSourceHandler;\n      } else {\n        log$1.error('No source hander found for the current source.');\n      }\n    }\n\n    // Dispose any existing source handler\n    this.disposeSourceHandler();\n    this.off('dispose', this.disposeSourceHandler);\n\n    if (sh !== _Tech.nativeSourceHandler) {\n      this.currentSource_ = source;\n    }\n\n    this.sourceHandler_ = sh.handleSource(source, this, this.options_);\n    this.on('dispose', this.disposeSourceHandler);\n  };\n\n  /**\n   * Clean up any existing SourceHandlers and listeners when the Tech is disposed.\n   *\n   * @listens Tech#dispose\n   */\n  _Tech.prototype.disposeSourceHandler = function () {\n    // if we have a source and get another one\n    // then we are loading something new\n    // than clear all of our current tracks\n    if (this.currentSource_) {\n      this.clearTracks(['audio', 'video']);\n      this.currentSource_ = null;\n    }\n\n    // always clean up auto-text tracks\n    this.cleanupAutoTextTracks();\n\n    if (this.sourceHandler_) {\n\n      if (this.sourceHandler_.dispose) {\n        this.sourceHandler_.dispose();\n      }\n\n      this.sourceHandler_ = null;\n    }\n  };\n};\n\n// The base Tech class needs to be registered as a Component. It is the only\n// Tech that can be registered as a Component.\nComponent.registerComponent('Tech', Tech);\nTech.registerTech('Tech', Tech);\n\n/**\n * A list of techs that should be added to techOrder on Players\n *\n * @private\n */\nTech.defaultTechOrder_ = [];\n\nvar middlewares = {};\n\nfunction use(type, middleware) {\n  middlewares[type] = middlewares[type] || [];\n  middlewares[type].push(middleware);\n}\n\n\n\nfunction setSource(player, src, next) {\n  player.setTimeout(function () {\n    return setSourceHelper(src, middlewares[src.type], next, player);\n  }, 1);\n}\n\nfunction setTech(middleware, tech) {\n  middleware.forEach(function (mw) {\n    return mw.setTech && mw.setTech(tech);\n  });\n}\n\nfunction get$1(middleware, tech, method) {\n  return middleware.reduceRight(middlewareIterator(method), tech[method]());\n}\n\nfunction set$1(middleware, tech, method, arg) {\n  return tech[method](middleware.reduce(middlewareIterator(method), arg));\n}\n\nvar allowedGetters = {\n  buffered: 1,\n  currentTime: 1,\n  duration: 1,\n  seekable: 1,\n  played: 1\n};\n\nvar allowedSetters = {\n  setCurrentTime: 1\n};\n\nfunction middlewareIterator(method) {\n  return function (value, mw) {\n    if (mw[method]) {\n      return mw[method](value);\n    }\n\n    return value;\n  };\n}\n\nfunction setSourceHelper() {\n  var src = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var middleware = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var next = arguments[2];\n  var player = arguments[3];\n  var acc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var lastRun = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var mwFactory = middleware[0],\n      mwrest = middleware.slice(1);\n\n  // if mwFactory is a string, then we're at a fork in the road\n\n  if (typeof mwFactory === 'string') {\n    setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);\n\n    // if we have an mwFactory, call it with the player to get the mw,\n    // then call the mw's setSource method\n  } else if (mwFactory) {\n    var mw = mwFactory(player);\n\n    mw.setSource(assign({}, src), function (err, _src) {\n\n      // something happened, try the next middleware on the current level\n      // make sure to use the old src\n      if (err) {\n        return setSourceHelper(src, mwrest, next, player, acc, lastRun);\n      }\n\n      // we've succeeded, now we need to go deeper\n      acc.push(mw);\n\n      // if it's the same type, continue down the current chain\n      // otherwise, we want to go down the new chain\n      setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);\n    });\n  } else if (mwrest.length) {\n    setSourceHelper(src, mwrest, next, player, acc, lastRun);\n  } else if (lastRun) {\n    next(src, acc);\n  } else {\n    setSourceHelper(src, middlewares['*'], next, player, acc, true);\n  }\n}\n\n/**\n * @module filter-source\n */\n/**\n * Filter out single bad source objects or multiple source objects in an\n * array. Also flattens nested source object arrays into a 1 dimensional\n * array of source objects.\n *\n * @param {Tech~SourceObject|Tech~SourceObject[]} src\n *        The src object to filter\n *\n * @return {Tech~SourceObject[]}\n *         An array of sourceobjects containing only valid sources\n *\n * @private\n */\nvar filterSource = function filterSource(src) {\n  // traverse array\n  if (Array.isArray(src)) {\n    var newsrc = [];\n\n    src.forEach(function (srcobj) {\n      srcobj = filterSource(srcobj);\n\n      if (Array.isArray(srcobj)) {\n        newsrc = newsrc.concat(srcobj);\n      } else if (isObject(srcobj)) {\n        newsrc.push(srcobj);\n      }\n    });\n\n    src = newsrc;\n  } else if (typeof src === 'string' && src.trim()) {\n    // convert string into object\n    src = [{ src: src }];\n  } else if (isObject(src) && typeof src.src === 'string' && src.src && src.src.trim()) {\n    // src is already valid\n    src = [src];\n  } else {\n    // invalid source, turn it into an empty array\n    src = [];\n  }\n\n  return src;\n};\n\n/**\n * @file loader.js\n */\n/**\n * The `MediaLoader` is the `Component` that decides which playback technology to load\n * when a player is initialized.\n *\n * @extends Component\n */\n\nvar MediaLoader = function (_Component) {\n  inherits(MediaLoader, _Component);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should attach to.\n   *\n   * @param {Object} [options]\n   *        The key/value stroe of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function that is run when this component is ready.\n   */\n  function MediaLoader(player, options, ready) {\n    classCallCheck(this, MediaLoader);\n\n    // MediaLoader has no element\n    var options_ = mergeOptions({ createEl: false }, options);\n\n    // If there are no sources when the player is initialized,\n    // load the first supported playback technology.\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options_, ready));\n\n    if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {\n      for (var i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {\n        var techName = toTitleCase(j[i]);\n        var tech = Tech.getTech(techName);\n\n        // Support old behavior of techs being registered as components.\n        // Remove once that deprecated behavior is removed.\n        if (!techName) {\n          tech = Component.getComponent(techName);\n        }\n\n        // Check if the browser supports this technology\n        if (tech && tech.isSupported()) {\n          player.loadTech_(techName);\n          break;\n        }\n      }\n    } else {\n      // Loop through playback technologies (HTML5, Flash) and check for support.\n      // Then load the best source.\n      // A few assumptions here:\n      //   All playback technologies respect preload false.\n      player.src(options.playerOptions.sources);\n    }\n    return _this;\n  }\n\n  return MediaLoader;\n}(Component);\n\nComponent.registerComponent('MediaLoader', MediaLoader);\n\n/**\n * @file button.js\n */\n/**\n * Clickable Component which is clickable or keyboard actionable,\n * but is not a native HTML button.\n *\n * @extends Component\n */\n\nvar ClickableComponent = function (_Component) {\n  inherits(ClickableComponent, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */\n  function ClickableComponent(player, options) {\n    classCallCheck(this, ClickableComponent);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.emitTapEvents();\n\n    _this.enable();\n    return _this;\n  }\n\n  /**\n   * Create the `Component`s DOM element.\n   *\n   * @param {string} [tag=div]\n   *        The element's node type.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element.\n   *\n   * @param {Object} [attributes={}]\n   *        An object of attributes that should be set on the element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  ClickableComponent.prototype.createEl = function createEl$$1() {\n    var tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    props = assign({\n      innerHTML: '<span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>',\n      className: this.buildCSSClass(),\n      tabIndex: 0\n    }, props);\n\n    if (tag === 'button') {\n      log$1.error('Creating a ClickableComponent with an HTML element of ' + tag + ' is not supported; use a Button instead.');\n    }\n\n    // Add ARIA attributes for clickable element which is not a native HTML button\n    attributes = assign({\n      'role': 'button',\n\n      // let the screen reader user know that the text of the element may change\n      'aria-live': 'polite'\n    }, attributes);\n\n    this.tabIndex_ = props.tabIndex;\n\n    var el = _Component.prototype.createEl.call(this, tag, props, attributes);\n\n    this.createControlTextEl(el);\n\n    return el;\n  };\n\n  ClickableComponent.prototype.dispose = function dispose() {\n    // remove controlTextEl_ on dipose\n    this.controlTextEl_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Create a control text element on this `Component`\n   *\n   * @param {Element} [el]\n   *        Parent element for the control text.\n   *\n   * @return {Element}\n   *         The control text element that gets created.\n   */\n\n\n  ClickableComponent.prototype.createControlTextEl = function createControlTextEl(el) {\n    this.controlTextEl_ = createEl('span', {\n      className: 'vjs-control-text'\n    });\n\n    if (el) {\n      el.appendChild(this.controlTextEl_);\n    }\n\n    this.controlText(this.controlText_, el);\n\n    return this.controlTextEl_;\n  };\n\n  /**\n   * Get or set the localize text to use for the controls on the `Component`.\n   *\n   * @param {string} [text]\n   *        Control text for element.\n   *\n   * @param {Element} [el=this.el()]\n   *        Element to set the title on.\n   *\n   * @return {string}\n   *         - The control text when getting\n   */\n\n\n  ClickableComponent.prototype.controlText = function controlText(text) {\n    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.el();\n\n    if (text === undefined) {\n      return this.controlText_ || 'Need Text';\n    }\n\n    var localizedText = this.localize(text);\n\n    this.controlText_ = text;\n    textContent(this.controlTextEl_, localizedText);\n    if (!this.nonIconControl) {\n      // Set title attribute if only an icon is shown\n      el.setAttribute('title', localizedText);\n    }\n  };\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  ClickableComponent.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-control vjs-button ' + _Component.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Enable this `Component`s element.\n   */\n\n\n  ClickableComponent.prototype.enable = function enable() {\n    if (!this.enabled_) {\n      this.enabled_ = true;\n      this.removeClass('vjs-disabled');\n      this.el_.setAttribute('aria-disabled', 'false');\n      if (typeof this.tabIndex_ !== 'undefined') {\n        this.el_.setAttribute('tabIndex', this.tabIndex_);\n      }\n      this.on(['tap', 'click'], this.handleClick);\n      this.on('focus', this.handleFocus);\n      this.on('blur', this.handleBlur);\n    }\n  };\n\n  /**\n   * Disable this `Component`s element.\n   */\n\n\n  ClickableComponent.prototype.disable = function disable() {\n    this.enabled_ = false;\n    this.addClass('vjs-disabled');\n    this.el_.setAttribute('aria-disabled', 'true');\n    if (typeof this.tabIndex_ !== 'undefined') {\n      this.el_.removeAttribute('tabIndex');\n    }\n    this.off(['tap', 'click'], this.handleClick);\n    this.off('focus', this.handleFocus);\n    this.off('blur', this.handleBlur);\n  };\n\n  /**\n   * This gets called when a `ClickableComponent` gets:\n   * - Clicked (via the `click` event, listening starts in the constructor)\n   * - Tapped (via the `tap` event, listening starts in the constructor)\n   * - The following things happen in order:\n   *   1. {@link ClickableComponent#handleFocus} is called via a `focus` event on the\n   *      `ClickableComponent`.\n   *   2. {@link ClickableComponent#handleFocus} adds a listener for `keydown` on using\n   *      {@link ClickableComponent#handleKeyPress}.\n   *   3. `ClickableComponent` has not had a `blur` event (`blur` means that focus was lost). The user presses\n   *      the space or enter key.\n   *   4. {@link ClickableComponent#handleKeyPress} calls this function with the `keydown`\n   *      event as a parameter.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   * @abstract\n   */\n\n\n  ClickableComponent.prototype.handleClick = function handleClick(event) {};\n\n  /**\n   * This gets called when a `ClickableComponent` gains focus via a `focus` event.\n   * Turns on listening for `keydown` events. When they happen it\n   * calls `this.handleKeyPress`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `focus` event that caused this function to be called.\n   *\n   * @listens focus\n   */\n\n\n  ClickableComponent.prototype.handleFocus = function handleFocus(event) {\n    on(document, 'keydown', bind(this, this.handleKeyPress));\n  };\n\n  /**\n   * Called when this ClickableComponent has focus and a key gets pressed down. By\n   * default it will call `this.handleClick` when the key is space or enter.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */\n\n\n  ClickableComponent.prototype.handleKeyPress = function handleKeyPress(event) {\n\n    // Support Space (32) or Enter (13) key operation to fire a click event\n    if (event.which === 32 || event.which === 13) {\n      event.preventDefault();\n      this.trigger('click');\n    } else if (_Component.prototype.handleKeyPress) {\n\n      // Pass keypress handling up for unsupported keys\n      _Component.prototype.handleKeyPress.call(this, event);\n    }\n  };\n\n  /**\n   * Called when a `ClickableComponent` loses focus. Turns off the listener for\n   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `blur` event that caused this function to be called.\n   *\n   * @listens blur\n   */\n\n\n  ClickableComponent.prototype.handleBlur = function handleBlur(event) {\n    off(document, 'keydown', bind(this, this.handleKeyPress));\n  };\n\n  return ClickableComponent;\n}(Component);\n\nComponent.registerComponent('ClickableComponent', ClickableComponent);\n\n/**\n * @file poster-image.js\n */\n/**\n * A `ClickableComponent` that handles showing the poster image for the player.\n *\n * @extends ClickableComponent\n */\n\nvar PosterImage = function (_ClickableComponent) {\n  inherits(PosterImage, _ClickableComponent);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should attach to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function PosterImage(player, options) {\n    classCallCheck(this, PosterImage);\n\n    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));\n\n    _this.update();\n    player.on('posterchange', bind(_this, _this.update));\n    return _this;\n  }\n\n  /**\n   * Clean up and dispose of the `PosterImage`.\n   */\n\n\n  PosterImage.prototype.dispose = function dispose() {\n    this.player().off('posterchange', this.update);\n    _ClickableComponent.prototype.dispose.call(this);\n  };\n\n  /**\n   * Create the `PosterImage`s DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  PosterImage.prototype.createEl = function createEl$$1() {\n    var el = createEl('div', {\n      className: 'vjs-poster',\n\n      // Don't want poster to be tabbable.\n      tabIndex: -1\n    });\n\n    // To ensure the poster image resizes while maintaining its original aspect\n    // ratio, use a div with `background-size` when available. For browsers that\n    // do not support `background-size` (e.g. IE8), fall back on using a regular\n    // img element.\n    if (!BACKGROUND_SIZE_SUPPORTED) {\n      this.fallbackImg_ = createEl('img');\n      el.appendChild(this.fallbackImg_);\n    }\n\n    return el;\n  };\n\n  /**\n   * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.\n   *\n   * @listens Player#posterchange\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `Player#posterchange` event that triggered this function.\n   */\n\n\n  PosterImage.prototype.update = function update(event) {\n    var url = this.player().poster();\n\n    this.setSrc(url);\n\n    // If there's no poster source we should display:none on this component\n    // so it's not still clickable or right-clickable\n    if (url) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  };\n\n  /**\n   * Set the source of the `PosterImage` depending on the display method.\n   *\n   * @param {string} url\n   *        The URL to the source for the `PosterImage`.\n   */\n\n\n  PosterImage.prototype.setSrc = function setSrc(url) {\n    if (this.fallbackImg_) {\n      this.fallbackImg_.src = url;\n    } else {\n      var backgroundImage = '';\n\n      // Any falsey values should stay as an empty string, otherwise\n      // this will throw an extra error\n      if (url) {\n        backgroundImage = 'url(\"' + url + '\")';\n      }\n\n      this.el_.style.backgroundImage = backgroundImage;\n    }\n  };\n\n  /**\n   * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See\n   * {@link ClickableComponent#handleClick} for instances where this will be triggered.\n   *\n   * @listens tap\n   * @listens click\n   * @listens keydown\n   *\n   * @param {EventTarget~Event} event\n   +        The `click`, `tap` or `keydown` event that caused this function to be called.\n   */\n\n\n  PosterImage.prototype.handleClick = function handleClick(event) {\n    // We don't want a click to trigger playback when controls are disabled\n    if (!this.player_.controls()) {\n      return;\n    }\n\n    if (this.player_.paused()) {\n      this.player_.play();\n    } else {\n      this.player_.pause();\n    }\n  };\n\n  return PosterImage;\n}(ClickableComponent);\n\nComponent.registerComponent('PosterImage', PosterImage);\n\n/**\n * @file text-track-display.js\n */\nvar darkGray = '#222';\nvar lightGray = '#ccc';\nvar fontMap = {\n  monospace: 'monospace',\n  sansSerif: 'sans-serif',\n  serif: 'serif',\n  monospaceSansSerif: '\"Andale Mono\", \"Lucida Console\", monospace',\n  monospaceSerif: '\"Courier New\", monospace',\n  proportionalSansSerif: 'sans-serif',\n  proportionalSerif: 'serif',\n  casual: '\"Comic Sans MS\", Impact, fantasy',\n  script: '\"Monotype Corsiva\", cursive',\n  smallcaps: '\"Andale Mono\", \"Lucida Console\", monospace, sans-serif'\n};\n\n/**\n * Construct an rgba color from a given hex color code.\n *\n * @param {number} color\n *        Hex number for color, like #f0e.\n *\n * @param {number} opacity\n *        Value for opacity, 0.0 - 1.0.\n *\n * @return {string}\n *         The rgba color that was created, like 'rgba(255, 0, 0, 0.3)'.\n *\n * @private\n */\nfunction constructColor(color, opacity) {\n  return 'rgba(' +\n  // color looks like \"#f0e\"\n  parseInt(color[1] + color[1], 16) + ',' + parseInt(color[2] + color[2], 16) + ',' + parseInt(color[3] + color[3], 16) + ',' + opacity + ')';\n}\n\n/**\n * Try to update the style of a DOM element. Some style changes will throw an error,\n * particularly in IE8. Those should be noops.\n *\n * @param {Element} el\n *        The DOM element to be styled.\n *\n * @param {string} style\n *        The CSS property on the element that should be styled.\n *\n * @param {string} rule\n *        The style rule that should be applied to the property.\n *\n * @private\n */\nfunction tryUpdateStyle(el, style, rule) {\n  try {\n    el.style[style] = rule;\n  } catch (e) {\n\n    // Satisfies linter.\n    return;\n  }\n}\n\n/**\n * The component for displaying text track cues.\n *\n * @extends Component\n */\n\nvar TextTrackDisplay = function (_Component) {\n  inherits(TextTrackDisplay, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when `TextTrackDisplay` is ready.\n   */\n  function TextTrackDisplay(player, options, ready) {\n    classCallCheck(this, TextTrackDisplay);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options, ready));\n\n    player.on('loadstart', bind(_this, _this.toggleDisplay));\n    player.on('texttrackchange', bind(_this, _this.updateDisplay));\n    player.on('loadstart', bind(_this, _this.preselectTrack));\n\n    // This used to be called during player init, but was causing an error\n    // if a track should show by default and the display hadn't loaded yet.\n    // Should probably be moved to an external track loader when we support\n    // tracks that don't need a display.\n    player.ready(bind(_this, function () {\n      if (player.tech_ && player.tech_.featuresNativeTextTracks) {\n        this.hide();\n        return;\n      }\n\n      player.on('fullscreenchange', bind(this, this.updateDisplay));\n\n      var tracks = this.options_.playerOptions.tracks || [];\n\n      for (var i = 0; i < tracks.length; i++) {\n        this.player_.addRemoteTextTrack(tracks[i], true);\n      }\n\n      this.preselectTrack();\n    }));\n    return _this;\n  }\n\n  /**\n  * Preselect a track following this precedence:\n  * - matches the previously selected {@link TextTrack}'s language and kind\n  * - matches the previously selected {@link TextTrack}'s language only\n  * - is the first default captions track\n  * - is the first default descriptions track\n  *\n  * @listens Player#loadstart\n  */\n\n\n  TextTrackDisplay.prototype.preselectTrack = function preselectTrack() {\n    var modes = { captions: 1, subtitles: 1 };\n    var trackList = this.player_.textTracks();\n    var userPref = this.player_.cache_.selectedLanguage;\n    var firstDesc = void 0;\n    var firstCaptions = void 0;\n    var preferredTrack = void 0;\n\n    for (var i = 0; i < trackList.length; i++) {\n      var track = trackList[i];\n\n      if (userPref && userPref.enabled && userPref.language === track.language) {\n        // Always choose the track that matches both language and kind\n        if (track.kind === userPref.kind) {\n          preferredTrack = track;\n          // or choose the first track that matches language\n        } else if (!preferredTrack) {\n          preferredTrack = track;\n        }\n\n        // clear everything if offTextTrackMenuItem was clicked\n      } else if (userPref && !userPref.enabled) {\n        preferredTrack = null;\n        firstDesc = null;\n        firstCaptions = null;\n      } else if (track['default']) {\n        if (track.kind === 'descriptions' && !firstDesc) {\n          firstDesc = track;\n        } else if (track.kind in modes && !firstCaptions) {\n          firstCaptions = track;\n        }\n      }\n    }\n\n    // The preferredTrack matches the user preference and takes\n    // precendence over all the other tracks.\n    // So, display the preferredTrack before the first default track\n    // and the subtitles/captions track before the descriptions track\n    if (preferredTrack) {\n      preferredTrack.mode = 'showing';\n    } else if (firstCaptions) {\n      firstCaptions.mode = 'showing';\n    } else if (firstDesc) {\n      firstDesc.mode = 'showing';\n    }\n  };\n\n  /**\n   * Turn display of {@link TextTrack}'s from the current state into the other state.\n   * There are only two states:\n   * - 'shown'\n   * - 'hidden'\n   *\n   * @listens Player#loadstart\n   */\n\n\n  TextTrackDisplay.prototype.toggleDisplay = function toggleDisplay() {\n    if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  };\n\n  /**\n   * Create the {@link Component}'s DOM element.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  TextTrackDisplay.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-text-track-display'\n    }, {\n      'aria-live': 'off',\n      'aria-atomic': 'true'\n    });\n  };\n\n  /**\n   * Clear all displayed {@link TextTrack}s.\n   */\n\n\n  TextTrackDisplay.prototype.clearDisplay = function clearDisplay() {\n    if (typeof window.WebVTT === 'function') {\n      window.WebVTT.processCues(window, [], this.el_);\n    }\n  };\n\n  /**\n   * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or\n   * a {@link Player#fullscreenchange} is fired.\n   *\n   * @listens Player#texttrackchange\n   * @listens Player#fullscreenchange\n   */\n\n\n  TextTrackDisplay.prototype.updateDisplay = function updateDisplay() {\n    var tracks = this.player_.textTracks();\n\n    this.clearDisplay();\n\n    // Track display prioritization model: if multiple tracks are 'showing',\n    //  display the first 'subtitles' or 'captions' track which is 'showing',\n    //  otherwise display the first 'descriptions' track which is 'showing'\n\n    var descriptionsTrack = null;\n    var captionsSubtitlesTrack = null;\n    var i = tracks.length;\n\n    while (i--) {\n      var track = tracks[i];\n\n      if (track.mode === 'showing') {\n        if (track.kind === 'descriptions') {\n          descriptionsTrack = track;\n        } else {\n          captionsSubtitlesTrack = track;\n        }\n      }\n    }\n\n    if (captionsSubtitlesTrack) {\n      if (this.getAttribute('aria-live') !== 'off') {\n        this.setAttribute('aria-live', 'off');\n      }\n      this.updateForTrack(captionsSubtitlesTrack);\n    } else if (descriptionsTrack) {\n      if (this.getAttribute('aria-live') !== 'assertive') {\n        this.setAttribute('aria-live', 'assertive');\n      }\n      this.updateForTrack(descriptionsTrack);\n    }\n  };\n\n  /**\n   * Add an {@link Texttrack} to to the {@link Tech}s {@link TextTrackList}.\n   *\n   * @param {TextTrack} track\n   *        Text track object to be added to the list.\n   */\n\n\n  TextTrackDisplay.prototype.updateForTrack = function updateForTrack(track) {\n    if (typeof window.WebVTT !== 'function' || !track.activeCues) {\n      return;\n    }\n\n    var overrides = this.player_.textTrackSettings.getValues();\n    var cues = [];\n\n    for (var _i = 0; _i < track.activeCues.length; _i++) {\n      cues.push(track.activeCues[_i]);\n    }\n\n    window.WebVTT.processCues(window, cues, this.el_);\n\n    var i = cues.length;\n\n    while (i--) {\n      var cue = cues[i];\n\n      if (!cue) {\n        continue;\n      }\n\n      var cueDiv = cue.displayState;\n\n      if (overrides.color) {\n        cueDiv.firstChild.style.color = overrides.color;\n      }\n      if (overrides.textOpacity) {\n        tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));\n      }\n      if (overrides.backgroundColor) {\n        cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;\n      }\n      if (overrides.backgroundOpacity) {\n        tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));\n      }\n      if (overrides.windowColor) {\n        if (overrides.windowOpacity) {\n          tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));\n        } else {\n          cueDiv.style.backgroundColor = overrides.windowColor;\n        }\n      }\n      if (overrides.edgeStyle) {\n        if (overrides.edgeStyle === 'dropshadow') {\n          cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;\n        } else if (overrides.edgeStyle === 'raised') {\n          cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;\n        } else if (overrides.edgeStyle === 'depressed') {\n          cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;\n        } else if (overrides.edgeStyle === 'uniform') {\n          cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;\n        }\n      }\n      if (overrides.fontPercent && overrides.fontPercent !== 1) {\n        var fontSize = window.parseFloat(cueDiv.style.fontSize);\n\n        cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';\n        cueDiv.style.height = 'auto';\n        cueDiv.style.top = 'auto';\n        cueDiv.style.bottom = '2px';\n      }\n      if (overrides.fontFamily && overrides.fontFamily !== 'default') {\n        if (overrides.fontFamily === 'small-caps') {\n          cueDiv.firstChild.style.fontVariant = 'small-caps';\n        } else {\n          cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];\n        }\n      }\n    }\n  };\n\n  return TextTrackDisplay;\n}(Component);\n\nComponent.registerComponent('TextTrackDisplay', TextTrackDisplay);\n\n/**\n * @file loading-spinner.js\n */\n/**\n * A loading spinner for use during waiting/loading events.\n *\n * @extends Component\n */\n\nvar LoadingSpinner = function (_Component) {\n  inherits(LoadingSpinner, _Component);\n\n  function LoadingSpinner() {\n    classCallCheck(this, LoadingSpinner);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the `LoadingSpinner`s DOM element.\n   *\n   * @return {Element}\n   *         The dom element that gets created.\n   */\n  LoadingSpinner.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-loading-spinner',\n      dir: 'ltr'\n    });\n  };\n\n  return LoadingSpinner;\n}(Component);\n\nComponent.registerComponent('LoadingSpinner', LoadingSpinner);\n\n/**\n * @file button.js\n */\n/**\n * Base class for all buttons.\n *\n * @extends ClickableComponent\n */\n\nvar Button = function (_ClickableComponent) {\n  inherits(Button, _ClickableComponent);\n\n  function Button() {\n    classCallCheck(this, Button);\n    return possibleConstructorReturn(this, _ClickableComponent.apply(this, arguments));\n  }\n\n  /**\n   * Create the `Button`s DOM element.\n   *\n   * @param {string} [tag=\"button\"]\n   *        The element's node type. This argument is IGNORED: no matter what\n   *        is passed, it will always create a `button` element.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element.\n   *\n   * @param {Object} [attributes={}]\n   *        An object of attributes that should be set on the element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n  Button.prototype.createEl = function createEl(tag) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    tag = 'button';\n\n    props = assign({\n      innerHTML: '<span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>',\n      className: this.buildCSSClass()\n    }, props);\n\n    // Add attributes for button element\n    attributes = assign({\n\n      // Necessary since the default button type is \"submit\"\n      'type': 'button',\n\n      // let the screen reader user know that the text of the button may change\n      'aria-live': 'polite'\n    }, attributes);\n\n    var el = Component.prototype.createEl.call(this, tag, props, attributes);\n\n    this.createControlTextEl(el);\n\n    return el;\n  };\n\n  /**\n   * Add a child `Component` inside of this `Button`.\n   *\n   * @param {string|Component} child\n   *        The name or instance of a child to add.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of options that will get passed to children of\n   *        the child.\n   *\n   * @return {Component}\n   *         The `Component` that gets added as a child. When using a string the\n   *         `Component` will get created by this process.\n   *\n   * @deprecated since version 5\n   */\n\n\n  Button.prototype.addChild = function addChild(child) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var className = this.constructor.name;\n\n    log$1.warn('Adding an actionable (user controllable) child to a Button (' + className + ') is not supported; use a ClickableComponent instead.');\n\n    // Avoid the error message generated by ClickableComponent's addChild method\n    return Component.prototype.addChild.call(this, child, options);\n  };\n\n  /**\n   * Enable the `Button` element so that it can be activated or clicked. Use this with\n   * {@link Button#disable}.\n   */\n\n\n  Button.prototype.enable = function enable() {\n    _ClickableComponent.prototype.enable.call(this);\n    this.el_.removeAttribute('disabled');\n  };\n\n  /**\n   * Disable the `Button` element so that it cannot be activated or clicked. Use this with\n   * {@link Button#enable}.\n   */\n\n\n  Button.prototype.disable = function disable() {\n    _ClickableComponent.prototype.disable.call(this);\n    this.el_.setAttribute('disabled', 'disabled');\n  };\n\n  /**\n   * This gets called when a `Button` has focus and `keydown` is triggered via a key\n   * press.\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to get called.\n   *\n   * @listens keydown\n   */\n\n\n  Button.prototype.handleKeyPress = function handleKeyPress(event) {\n\n    // Ignore Space (32) or Enter (13) key operation, which is handled by the browser for a button.\n    if (event.which === 32 || event.which === 13) {\n      return;\n    }\n\n    // Pass keypress handling up for unsupported keys\n    _ClickableComponent.prototype.handleKeyPress.call(this, event);\n  };\n\n  return Button;\n}(ClickableComponent);\n\nComponent.registerComponent('Button', Button);\n\n/**\n * @file big-play-button.js\n */\n/**\n * The initial play button that shows before the video has played. The hiding of the\n * `BigPlayButton` get done via CSS and `Player` states.\n *\n * @extends Button\n */\n\nvar BigPlayButton = function (_Button) {\n  inherits(BigPlayButton, _Button);\n\n  function BigPlayButton(player, options) {\n    classCallCheck(this, BigPlayButton);\n\n    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));\n\n    _this.mouseused_ = false;\n\n    _this.on('mousedown', _this.handleMouseDown);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.\n   */\n\n\n  BigPlayButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-big-play-button';\n  };\n\n  /**\n   * This gets called when a `BigPlayButton` \"clicked\". See {@link ClickableComponent}\n   * for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  BigPlayButton.prototype.handleClick = function handleClick(event) {\n    var playPromise = this.player_.play();\n\n    // exit early if clicked via the mouse\n    if (this.mouseused_ && event.clientX && event.clientY) {\n      return;\n    }\n\n    var cb = this.player_.getChild('controlBar');\n    var playToggle = cb && cb.getChild('playToggle');\n\n    if (!playToggle) {\n      this.player_.focus();\n      return;\n    }\n\n    var playFocus = function playFocus() {\n      return playToggle.focus();\n    };\n\n    if (isPromise(playPromise)) {\n      playPromise.then(playFocus, function () {});\n    } else {\n      this.setTimeout(playFocus, 1);\n    }\n  };\n\n  BigPlayButton.prototype.handleKeyPress = function handleKeyPress(event) {\n    this.mouseused_ = false;\n\n    _Button.prototype.handleKeyPress.call(this, event);\n  };\n\n  BigPlayButton.prototype.handleMouseDown = function handleMouseDown(event) {\n    this.mouseused_ = true;\n  };\n\n  return BigPlayButton;\n}(Button);\n\n/**\n * The text that should display over the `BigPlayButton`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */\n\n\nBigPlayButton.prototype.controlText_ = 'Play Video';\n\nComponent.registerComponent('BigPlayButton', BigPlayButton);\n\n/**\n * @file close-button.js\n */\n/**\n * The `CloseButton` is a `{@link Button}` that fires a `close` event when\n * it gets clicked.\n *\n * @extends Button\n */\n\nvar CloseButton = function (_Button) {\n  inherits(CloseButton, _Button);\n\n  /**\n   * Creates an instance of the this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */\n  function CloseButton(player, options) {\n    classCallCheck(this, CloseButton);\n\n    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));\n\n    _this.controlText(options && options.controlText || _this.localize('Close'));\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  CloseButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-close-button ' + _Button.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * This gets called when a `CloseButton` gets clicked. See\n   * {@link ClickableComponent#handleClick} for more information on when this will be\n   * triggered\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   * @fires CloseButton#close\n   */\n\n\n  CloseButton.prototype.handleClick = function handleClick(event) {\n\n    /**\n     * Triggered when the a `CloseButton` is clicked.\n     *\n     * @event CloseButton#close\n     * @type {EventTarget~Event}\n     *\n     * @property {boolean} [bubbles=false]\n     *           set to false so that the close event does not\n     *           bubble up to parents if there is no listener\n     */\n    this.trigger({ type: 'close', bubbles: false });\n  };\n\n  return CloseButton;\n}(Button);\n\nComponent.registerComponent('CloseButton', CloseButton);\n\n/**\n * @file play-toggle.js\n */\n/**\n * Button to toggle between play and pause.\n *\n * @extends Button\n */\n\nvar PlayToggle = function (_Button) {\n  inherits(PlayToggle, _Button);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function PlayToggle(player, options) {\n    classCallCheck(this, PlayToggle);\n\n    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));\n\n    _this.on(player, 'play', _this.handlePlay);\n    _this.on(player, 'pause', _this.handlePause);\n    _this.on(player, 'ended', _this.handleEnded);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  PlayToggle.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-play-control ' + _Button.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * This gets called when an `PlayToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  PlayToggle.prototype.handleClick = function handleClick(event) {\n    if (this.player_.paused()) {\n      this.player_.play();\n    } else {\n      this.player_.pause();\n    }\n  };\n\n  /**\n   * This gets called once after the video has ended and the user seeks so that\n   * we can change the replay button back to a play button.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#seeked\n   */\n\n\n  PlayToggle.prototype.handleSeeked = function handleSeeked(event) {\n    this.removeClass('vjs-ended');\n\n    if (this.player_.paused()) {\n      this.handlePause(event);\n    } else {\n      this.handlePlay(event);\n    }\n  };\n\n  /**\n   * Add the vjs-playing class to the element so it can change appearance.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#play\n   */\n\n\n  PlayToggle.prototype.handlePlay = function handlePlay(event) {\n    this.removeClass('vjs-ended');\n    this.removeClass('vjs-paused');\n    this.addClass('vjs-playing');\n    // change the button text to \"Pause\"\n    this.controlText('Pause');\n  };\n\n  /**\n   * Add the vjs-paused class to the element so it can change appearance.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#pause\n   */\n\n\n  PlayToggle.prototype.handlePause = function handlePause(event) {\n    this.removeClass('vjs-playing');\n    this.addClass('vjs-paused');\n    // change the button text to \"Play\"\n    this.controlText('Play');\n  };\n\n  /**\n   * Add the vjs-ended class to the element so it can change appearance\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#ended\n   */\n\n\n  PlayToggle.prototype.handleEnded = function handleEnded(event) {\n    this.removeClass('vjs-playing');\n    this.addClass('vjs-ended');\n    // change the button text to \"Replay\"\n    this.controlText('Replay');\n\n    // on the next seek remove the replay button\n    this.one(this.player_, 'seeked', this.handleSeeked);\n  };\n\n  return PlayToggle;\n}(Button);\n\n/**\n * The text that should display over the `PlayToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nPlayToggle.prototype.controlText_ = 'Play';\n\nComponent.registerComponent('PlayToggle', PlayToggle);\n\n/**\n * @file format-time.js\n * @module Format-time\n */\n\n/**\n * Format seconds as a time string, H:MM:SS or M:SS. Supplying a guide (in seconds)\n * will force a number of leading zeros to cover the length of the guide.\n *\n * @param {number} seconds\n *        Number of seconds to be turned into a string\n *\n * @param {number} guide\n *        Number (in seconds) to model the string after\n *\n * @return {string}\n *         Time formatted as H:MM:SS or M:SS\n */\nfunction formatTime(seconds) {\n  var guide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : seconds;\n\n  seconds = seconds < 0 ? 0 : seconds;\n  var s = Math.floor(seconds % 60);\n  var m = Math.floor(seconds / 60 % 60);\n  var h = Math.floor(seconds / 3600);\n  var gm = Math.floor(guide / 60 % 60);\n  var gh = Math.floor(guide / 3600);\n\n  // handle invalid times\n  if (isNaN(seconds) || seconds === Infinity) {\n    // '-' is false for all relational operators (e.g. <, >=) so this setting\n    // will add the minimum number of fields specified by the guide\n    h = m = s = '-';\n  }\n\n  // Check if we need to show hours\n  h = h > 0 || gh > 0 ? h + ':' : '';\n\n  // If hours are showing, we may need to add a leading zero.\n  // Always show at least one digit of minutes.\n  m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';\n\n  // Check if leading zero is need for seconds\n  s = s < 10 ? '0' + s : s;\n\n  return h + m + s;\n}\n\n/**\n * @file time-display.js\n */\n/**\n * Displays the time left in the video\n *\n * @extends Component\n */\n\nvar TimeDisplay = function (_Component) {\n  inherits(TimeDisplay, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function TimeDisplay(player, options) {\n    classCallCheck(this, TimeDisplay);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.throttledUpdateContent = throttle(bind(_this, _this.updateContent), 25);\n    _this.on(player, 'timeupdate', _this.throttledUpdateContent);\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  TimeDisplay.prototype.createEl = function createEl$$1(plainName) {\n    var className = this.buildCSSClass();\n    var el = _Component.prototype.createEl.call(this, 'div', {\n      className: className + ' vjs-time-control vjs-control'\n    });\n\n    this.contentEl_ = createEl('div', {\n      className: className + '-display'\n    }, {\n      // tell screen readers not to automatically read the time as it changes\n      'aria-live': 'off'\n    }, createEl('span', {\n      className: 'vjs-control-text',\n      textContent: this.localize(this.controlText_)\n    }));\n\n    this.updateTextNode_();\n    el.appendChild(this.contentEl_);\n    return el;\n  };\n\n  TimeDisplay.prototype.dispose = function dispose() {\n    this.contentEl_ = null;\n    this.textNode_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Updates the \"remaining time\" text node with new content using the\n   * contents of the `formattedTime_` property.\n   *\n   * @private\n   */\n\n\n  TimeDisplay.prototype.updateTextNode_ = function updateTextNode_() {\n    if (!this.contentEl_) {\n      return;\n    }\n\n    while (this.contentEl_.firstChild) {\n      this.contentEl_.removeChild(this.contentEl_.firstChild);\n    }\n\n    this.textNode_ = document.createTextNode(this.formattedTime_ || '0:00');\n    this.contentEl_.appendChild(this.textNode_);\n  };\n\n  /**\n   * Generates a formatted time for this component to use in display.\n   *\n   * @param  {number} time\n   *         A numeric time, in seconds.\n   *\n   * @return {string}\n   *         A formatted time\n   *\n   * @private\n   */\n\n\n  TimeDisplay.prototype.formatTime_ = function formatTime_(time) {\n    return formatTime(time);\n  };\n\n  /**\n   * Updates the time display text node if it has what was passed in changed\n   * the formatted time.\n   *\n   * @param {number} time\n   *        The time to update to\n   *\n   * @private\n   */\n\n\n  TimeDisplay.prototype.updateFormattedTime_ = function updateFormattedTime_(time) {\n    var formattedTime = this.formatTime_(time);\n\n    if (formattedTime === this.formattedTime_) {\n      return;\n    }\n\n    this.formattedTime_ = formattedTime;\n    this.requestAnimationFrame(this.updateTextNode_);\n  };\n\n  /**\n   * To be filled out in the child class, should update the displayed time\n   * in accordance with the fact that the current time has changed.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate`  event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   */\n\n\n  TimeDisplay.prototype.updateContent = function updateContent(event) {};\n\n  return TimeDisplay;\n}(Component);\n\n/**\n * The text that should display over the `TimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */\n\n\nTimeDisplay.prototype.controlText_ = 'Time';\n\nComponent.registerComponent('TimeDisplay', TimeDisplay);\n\n/**\n * @file current-time-display.js\n */\n/**\n * Displays the current time\n *\n * @extends Component\n */\n\nvar CurrentTimeDisplay = function (_TimeDisplay) {\n  inherits(CurrentTimeDisplay, _TimeDisplay);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function CurrentTimeDisplay(player, options) {\n    classCallCheck(this, CurrentTimeDisplay);\n\n    var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));\n\n    _this.on(player, 'ended', _this.handleEnded);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  CurrentTimeDisplay.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-current-time';\n  };\n\n  /**\n   * Update current time display\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` event that caused this function to run.\n   *\n   * @listens Player#timeupdate\n   */\n\n\n  CurrentTimeDisplay.prototype.updateContent = function updateContent(event) {\n    // Allows for smooth scrubbing, when player can't keep up.\n    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n\n    this.updateFormattedTime_(time);\n  };\n\n  /**\n   * When the player fires ended there should be no time left. Sadly\n   * this is not always the case, lets make it seem like that is the case\n   * for users.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `ended` event that caused this to run.\n   *\n   * @listens Player#ended\n   */\n\n\n  CurrentTimeDisplay.prototype.handleEnded = function handleEnded(event) {\n    if (!this.player_.duration()) {\n      return;\n    }\n    this.updateFormattedTime_(this.player_.duration());\n  };\n\n  return CurrentTimeDisplay;\n}(TimeDisplay);\n\n/**\n * The text that should display over the `CurrentTimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */\n\n\nCurrentTimeDisplay.prototype.controlText_ = 'Current Time';\n\nComponent.registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);\n\n/**\n * @file duration-display.js\n */\n/**\n * Displays the duration\n *\n * @extends Component\n */\n\nvar DurationDisplay = function (_TimeDisplay) {\n  inherits(DurationDisplay, _TimeDisplay);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function DurationDisplay(player, options) {\n    classCallCheck(this, DurationDisplay);\n\n    // we do not want to/need to throttle duration changes,\n    // as they should always display the changed duration as\n    // it has changed\n    var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));\n\n    _this.on(player, 'durationchange', _this.updateContent);\n\n    // Also listen for timeupdate (in the parent) and loadedmetadata because removing those\n    // listeners could have broken dependent applications/libraries. These\n    // can likely be removed for 7.0.\n    _this.on(player, 'loadedmetadata', _this.throttledUpdateContent);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  DurationDisplay.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-duration';\n  };\n\n  /**\n   * Update duration time display.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused\n   *        this function to be called.\n   *\n   * @listens Player#durationchange\n   * @listens Player#timeupdate\n   * @listens Player#loadedmetadata\n   */\n\n\n  DurationDisplay.prototype.updateContent = function updateContent(event) {\n    var duration = this.player_.duration();\n\n    if (duration && this.duration_ !== duration) {\n      this.duration_ = duration;\n      this.updateFormattedTime_(duration);\n    }\n  };\n\n  return DurationDisplay;\n}(TimeDisplay);\n\n/**\n * The text that should display over the `DurationDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */\n\n\nDurationDisplay.prototype.controlText_ = 'Duration Time';\n\nComponent.registerComponent('DurationDisplay', DurationDisplay);\n\n/**\n * @file time-divider.js\n */\n/**\n * The separator between the current time and duration.\n * Can be hidden if it's not needed in the design.\n *\n * @extends Component\n */\n\nvar TimeDivider = function (_Component) {\n  inherits(TimeDivider, _Component);\n\n  function TimeDivider() {\n    classCallCheck(this, TimeDivider);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the component's DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  TimeDivider.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-time-control vjs-time-divider',\n      innerHTML: '<div><span>/</span></div>'\n    });\n  };\n\n  return TimeDivider;\n}(Component);\n\nComponent.registerComponent('TimeDivider', TimeDivider);\n\n/**\n * @file remaining-time-display.js\n */\n/**\n * Displays the time left in the video\n *\n * @extends Component\n */\n\nvar RemainingTimeDisplay = function (_TimeDisplay) {\n  inherits(RemainingTimeDisplay, _TimeDisplay);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function RemainingTimeDisplay(player, options) {\n    classCallCheck(this, RemainingTimeDisplay);\n\n    var _this = possibleConstructorReturn(this, _TimeDisplay.call(this, player, options));\n\n    _this.on(player, 'durationchange', _this.throttledUpdateContent);\n    _this.on(player, 'ended', _this.handleEnded);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  RemainingTimeDisplay.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-remaining-time';\n  };\n\n  /**\n   * The remaining time display prefixes numbers with a \"minus\" character.\n   *\n   * @param  {number} time\n   *         A numeric time, in seconds.\n   *\n   * @return {string}\n   *         A formatted time\n   *\n   * @private\n   */\n\n\n  RemainingTimeDisplay.prototype.formatTime_ = function formatTime_(time) {\n    return '-' + _TimeDisplay.prototype.formatTime_.call(this, time);\n  };\n\n  /**\n   * Update remaining time display.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `durationchange` event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   * @listens Player#durationchange\n   */\n\n\n  RemainingTimeDisplay.prototype.updateContent = function updateContent(event) {\n    if (!this.player_.duration()) {\n      return;\n    }\n\n    // @deprecated We should only use remainingTimeDisplay\n    // as of video.js 7\n    if (this.player_.remainingTimeDisplay) {\n      this.updateFormattedTime_(this.player_.remainingTimeDisplay());\n    } else {\n      this.updateFormattedTime_(this.player_.remainingTime());\n    }\n  };\n\n  /**\n   * When the player fires ended there should be no time left. Sadly\n   * this is not always the case, lets make it seem like that is the case\n   * for users.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `ended` event that caused this to run.\n   *\n   * @listens Player#ended\n   */\n\n\n  RemainingTimeDisplay.prototype.handleEnded = function handleEnded(event) {\n    if (!this.player_.duration()) {\n      return;\n    }\n    this.updateFormattedTime_(0);\n  };\n\n  return RemainingTimeDisplay;\n}(TimeDisplay);\n\n/**\n * The text that should display over the `RemainingTimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */\n\n\nRemainingTimeDisplay.prototype.controlText_ = 'Remaining Time';\n\nComponent.registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);\n\n/**\n * @file live-display.js\n */\n// TODO - Future make it click to snap to live\n\n/**\n * Displays the live indicator when duration is Infinity.\n *\n * @extends Component\n */\n\nvar LiveDisplay = function (_Component) {\n  inherits(LiveDisplay, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function LiveDisplay(player, options) {\n    classCallCheck(this, LiveDisplay);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.updateShowing();\n    _this.on(_this.player(), 'durationchange', _this.updateShowing);\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  LiveDisplay.prototype.createEl = function createEl$$1() {\n    var el = _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-live-control vjs-control'\n    });\n\n    this.contentEl_ = createEl('div', {\n      className: 'vjs-live-display',\n      innerHTML: '<span class=\"vjs-control-text\">' + this.localize('Stream Type') + '</span>' + this.localize('LIVE')\n    }, {\n      'aria-live': 'off'\n    });\n\n    el.appendChild(this.contentEl_);\n    return el;\n  };\n\n  LiveDisplay.prototype.dispose = function dispose() {\n    this.contentEl_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide\n   * it accordingly\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#durationchange} event that caused this function to run.\n   *\n   * @listens Player#durationchange\n   */\n\n\n  LiveDisplay.prototype.updateShowing = function updateShowing(event) {\n    if (this.player().duration() === Infinity) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  };\n\n  return LiveDisplay;\n}(Component);\n\nComponent.registerComponent('LiveDisplay', LiveDisplay);\n\n/**\n * @file slider.js\n */\n/**\n * The base functionality for a slider. Can be vertical or horizontal.\n * For instance the volume bar or the seek bar on a video is a slider.\n *\n * @extends Component\n */\n\nvar Slider = function (_Component) {\n  inherits(Slider, _Component);\n\n  /**\n   * Create an instance of this class\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function Slider(player, options) {\n    classCallCheck(this, Slider);\n\n    // Set property names to bar to match with the child Slider class is looking for\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.bar = _this.getChild(_this.options_.barName);\n\n    // Set a horizontal or vertical class on the slider depending on the slider type\n    _this.vertical(!!_this.options_.vertical);\n\n    _this.enable();\n    return _this;\n  }\n\n  /**\n   * Are controls are currently enabled for this slider or not.\n   *\n   * @return {boolean}\n   *         true if controls are enabled, false otherwise\n   */\n\n\n  Slider.prototype.enabled = function enabled() {\n    return this.enabled_;\n  };\n\n  /**\n   * Enable controls for this slider if they are disabled\n   */\n\n\n  Slider.prototype.enable = function enable() {\n    if (this.enabled()) {\n      return;\n    }\n\n    this.on('mousedown', this.handleMouseDown);\n    this.on('touchstart', this.handleMouseDown);\n    this.on('focus', this.handleFocus);\n    this.on('blur', this.handleBlur);\n    this.on('click', this.handleClick);\n\n    this.on(this.player_, 'controlsvisible', this.update);\n\n    if (this.playerEvent) {\n      this.on(this.player_, this.playerEvent, this.update);\n    }\n\n    this.removeClass('disabled');\n    this.setAttribute('tabindex', 0);\n\n    this.enabled_ = true;\n  };\n\n  /**\n   * Disable controls for this slider if they are enabled\n   */\n\n\n  Slider.prototype.disable = function disable() {\n    if (!this.enabled()) {\n      return;\n    }\n    var doc = this.bar.el_.ownerDocument;\n\n    this.off('mousedown', this.handleMouseDown);\n    this.off('touchstart', this.handleMouseDown);\n    this.off('focus', this.handleFocus);\n    this.off('blur', this.handleBlur);\n    this.off('click', this.handleClick);\n    this.off(this.player_, 'controlsvisible', this.update);\n    this.off(doc, 'mousemove', this.handleMouseMove);\n    this.off(doc, 'mouseup', this.handleMouseUp);\n    this.off(doc, 'touchmove', this.handleMouseMove);\n    this.off(doc, 'touchend', this.handleMouseUp);\n    this.removeAttribute('tabindex');\n\n    this.addClass('disabled');\n\n    if (this.playerEvent) {\n      this.off(this.player_, this.playerEvent, this.update);\n    }\n    this.enabled_ = false;\n  };\n\n  /**\n   * Create the `Button`s DOM element.\n   *\n   * @param {string} type\n   *        Type of element to create.\n   *\n   * @param {Object} [props={}]\n   *        List of properties in Object form.\n   *\n   * @param {Object} [attributes={}]\n   *        list of attributes in Object form.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  Slider.prototype.createEl = function createEl$$1(type) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    // Add the slider element class to all sub classes\n    props.className = props.className + ' vjs-slider';\n    props = assign({\n      tabIndex: 0\n    }, props);\n\n    attributes = assign({\n      'role': 'slider',\n      'aria-valuenow': 0,\n      'aria-valuemin': 0,\n      'aria-valuemax': 100,\n      'tabIndex': 0\n    }, attributes);\n\n    return _Component.prototype.createEl.call(this, type, props, attributes);\n  };\n\n  /**\n   * Handle `mousedown` or `touchstart` events on the `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   * @fires Slider#slideractive\n   */\n\n\n  Slider.prototype.handleMouseDown = function handleMouseDown(event) {\n    var doc = this.bar.el_.ownerDocument;\n\n    event.preventDefault();\n    blockTextSelection();\n\n    this.addClass('vjs-sliding');\n    /**\n     * Triggered when the slider is in an active state\n     *\n     * @event Slider#slideractive\n     * @type {EventTarget~Event}\n     */\n    this.trigger('slideractive');\n\n    this.on(doc, 'mousemove', this.handleMouseMove);\n    this.on(doc, 'mouseup', this.handleMouseUp);\n    this.on(doc, 'touchmove', this.handleMouseMove);\n    this.on(doc, 'touchend', this.handleMouseUp);\n\n    this.handleMouseMove(event);\n  };\n\n  /**\n   * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.\n   * The `mousemove` and `touchmove` events will only only trigger this function during\n   * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and\n   * {@link Slider#handleMouseUp}.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered\n   *        this function\n   *\n   * @listens mousemove\n   * @listens touchmove\n   */\n\n\n  Slider.prototype.handleMouseMove = function handleMouseMove(event) {};\n\n  /**\n   * Handle `mouseup` or `touchend` events on the `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   * @fires Slider#sliderinactive\n   */\n\n\n  Slider.prototype.handleMouseUp = function handleMouseUp() {\n    var doc = this.bar.el_.ownerDocument;\n\n    unblockTextSelection();\n\n    this.removeClass('vjs-sliding');\n    /**\n     * Triggered when the slider is no longer in an active state.\n     *\n     * @event Slider#sliderinactive\n     * @type {EventTarget~Event}\n     */\n    this.trigger('sliderinactive');\n\n    this.off(doc, 'mousemove', this.handleMouseMove);\n    this.off(doc, 'mouseup', this.handleMouseUp);\n    this.off(doc, 'touchmove', this.handleMouseMove);\n    this.off(doc, 'touchend', this.handleMouseUp);\n\n    this.update();\n  };\n\n  /**\n   * Update the progress bar of the `Slider`.\n   *\n   * @returns {number}\n   *          The percentage of progress the progress bar represents as a\n   *          number from 0 to 1.\n   */\n\n\n  Slider.prototype.update = function update() {\n\n    // In VolumeBar init we have a setTimeout for update that pops and update\n    // to the end of the execution stack. The player is destroyed before then\n    // update will cause an error\n    if (!this.el_) {\n      return;\n    }\n\n    // If scrubbing, we could use a cached value to make the handle keep up\n    // with the user's mouse. On HTML5 browsers scrubbing is really smooth, but\n    // some flash players are slow, so we might want to utilize this later.\n    // var progress =  (this.player_.scrubbing()) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();\n    var progress = this.getPercent();\n    var bar = this.bar;\n\n    // If there's no bar...\n    if (!bar) {\n      return;\n    }\n\n    // Protect against no duration and other division issues\n    if (typeof progress !== 'number' || progress !== progress || progress < 0 || progress === Infinity) {\n      progress = 0;\n    }\n\n    // Convert to a percentage for setting\n    var percentage = (progress * 100).toFixed(2) + '%';\n    var style = bar.el().style;\n\n    // Set the new bar width or height\n    if (this.vertical()) {\n      style.height = percentage;\n    } else {\n      style.width = percentage;\n    }\n\n    return progress;\n  };\n\n  /**\n   * Calculate distance for slider\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run.\n   *\n   * @return {number}\n   *         The current position of the Slider.\n   *         - postition.x for vertical `Slider`s\n   *         - postition.y for horizontal `Slider`s\n   */\n\n\n  Slider.prototype.calculateDistance = function calculateDistance(event) {\n    var position = getPointerPosition(this.el_, event);\n\n    if (this.vertical()) {\n      return position.y;\n    }\n    return position.x;\n  };\n\n  /**\n   * Handle a `focus` event on this `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `focus` event that caused this function to run.\n   *\n   * @listens focus\n   */\n\n\n  Slider.prototype.handleFocus = function handleFocus() {\n    this.on(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);\n  };\n\n  /**\n   * Handle a `keydown` event on the `Slider`. Watches for left, rigth, up, and down\n   * arrow keys. This function will only be called when the slider has focus. See\n   * {@link Slider#handleFocus} and {@link Slider#handleBlur}.\n   *\n   * @param {EventTarget~Event} event\n   *        the `keydown` event that caused this function to run.\n   *\n   * @listens keydown\n   */\n\n\n  Slider.prototype.handleKeyPress = function handleKeyPress(event) {\n    // Left and Down Arrows\n    if (event.which === 37 || event.which === 40) {\n      event.preventDefault();\n      this.stepBack();\n\n      // Up and Right Arrows\n    } else if (event.which === 38 || event.which === 39) {\n      event.preventDefault();\n      this.stepForward();\n    }\n  };\n\n  /**\n   * Handle a `blur` event on this `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `blur` event that caused this function to run.\n   *\n   * @listens blur\n   */\n\n  Slider.prototype.handleBlur = function handleBlur() {\n    this.off(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);\n  };\n\n  /**\n   * Listener for click events on slider, used to prevent clicks\n   *   from bubbling up to parent elements like button menus.\n   *\n   * @param {Object} event\n   *        Event that caused this object to run\n   */\n\n\n  Slider.prototype.handleClick = function handleClick(event) {\n    event.stopImmediatePropagation();\n    event.preventDefault();\n  };\n\n  /**\n   * Get/set if slider is horizontal for vertical\n   *\n   * @param {boolean} [bool]\n   *        - true if slider is vertical,\n   *        - false is horizontal\n   *\n   * @return {boolean}\n   *         - true if slider is vertical, and getting\n   *         - false if the slider is horizontal, and getting\n   */\n\n\n  Slider.prototype.vertical = function vertical(bool) {\n    if (bool === undefined) {\n      return this.vertical_ || false;\n    }\n\n    this.vertical_ = !!bool;\n\n    if (this.vertical_) {\n      this.addClass('vjs-slider-vertical');\n    } else {\n      this.addClass('vjs-slider-horizontal');\n    }\n  };\n\n  return Slider;\n}(Component);\n\nComponent.registerComponent('Slider', Slider);\n\n/**\n * @file load-progress-bar.js\n */\n/**\n * Shows loading progress\n *\n * @extends Component\n */\n\nvar LoadProgressBar = function (_Component) {\n  inherits(LoadProgressBar, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function LoadProgressBar(player, options) {\n    classCallCheck(this, LoadProgressBar);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.partEls_ = [];\n    _this.on(player, 'progress', _this.update);\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  LoadProgressBar.prototype.createEl = function createEl$$1() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-load-progress',\n      innerHTML: '<span class=\"vjs-control-text\"><span>' + this.localize('Loaded') + '</span>: 0%</span>'\n    });\n  };\n\n  LoadProgressBar.prototype.dispose = function dispose() {\n    this.partEls_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Update progress bar\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `progress` event that caused this function to run.\n   *\n   * @listens Player#progress\n   */\n\n\n  LoadProgressBar.prototype.update = function update(event) {\n    var buffered = this.player_.buffered();\n    var duration = this.player_.duration();\n    var bufferedEnd = this.player_.bufferedEnd();\n    var children = this.partEls_;\n\n    // get the percent width of a time compared to the total end\n    var percentify = function percentify(time, end) {\n      // no NaN\n      var percent = time / end || 0;\n\n      return (percent >= 1 ? 1 : percent) * 100 + '%';\n    };\n\n    // update the width of the progress bar\n    this.el_.style.width = percentify(bufferedEnd, duration);\n\n    // add child elements to represent the individual buffered time ranges\n    for (var i = 0; i < buffered.length; i++) {\n      var start = buffered.start(i);\n      var end = buffered.end(i);\n      var part = children[i];\n\n      if (!part) {\n        part = this.el_.appendChild(createEl());\n        children[i] = part;\n      }\n\n      // set the percent based on the width of the progress bar (bufferedEnd)\n      part.style.left = percentify(start, bufferedEnd);\n      part.style.width = percentify(end - start, bufferedEnd);\n    }\n\n    // remove unused buffered range elements\n    for (var _i = children.length; _i > buffered.length; _i--) {\n      this.el_.removeChild(children[_i - 1]);\n    }\n    children.length = buffered.length;\n  };\n\n  return LoadProgressBar;\n}(Component);\n\nComponent.registerComponent('LoadProgressBar', LoadProgressBar);\n\n/**\n * @file time-tooltip.js\n */\n/**\n * Time tooltips display a time above the progress bar.\n *\n * @extends Component\n */\n\nvar TimeTooltip = function (_Component) {\n  inherits(TimeTooltip, _Component);\n\n  function TimeTooltip() {\n    classCallCheck(this, TimeTooltip);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the time tooltip DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  TimeTooltip.prototype.createEl = function createEl$$1() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-time-tooltip'\n    });\n  };\n\n  /**\n   * Updates the position of the time tooltip relative to the `SeekBar`.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */\n\n\n  TimeTooltip.prototype.update = function update(seekBarRect, seekBarPoint, content) {\n    var tooltipRect = getBoundingClientRect(this.el_);\n    var playerRect = getBoundingClientRect(this.player_.el());\n    var seekBarPointPx = seekBarRect.width * seekBarPoint;\n\n    // do nothing if either rect isn't available\n    // for example, if the player isn't in the DOM for testing\n    if (!playerRect || !tooltipRect) {\n      return;\n    }\n\n    // This is the space left of the `seekBarPoint` available within the bounds\n    // of the player. We calculate any gap between the left edge of the player\n    // and the left edge of the `SeekBar` and add the number of pixels in the\n    // `SeekBar` before hitting the `seekBarPoint`\n    var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;\n\n    // This is the space right of the `seekBarPoint` available within the bounds\n    // of the player. We calculate the number of pixels from the `seekBarPoint`\n    // to the right edge of the `SeekBar` and add to that any gap between the\n    // right edge of the `SeekBar` and the player.\n    var spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);\n\n    // This is the number of pixels by which the tooltip will need to be pulled\n    // further to the right to center it over the `seekBarPoint`.\n    var pullTooltipBy = tooltipRect.width / 2;\n\n    // Adjust the `pullTooltipBy` distance to the left or right depending on\n    // the results of the space calculations above.\n    if (spaceLeftOfPoint < pullTooltipBy) {\n      pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;\n    } else if (spaceRightOfPoint < pullTooltipBy) {\n      pullTooltipBy = spaceRightOfPoint;\n    }\n\n    // Due to the imprecision of decimal/ratio based calculations and varying\n    // rounding behaviors, there are cases where the spacing adjustment is off\n    // by a pixel or two. This adds insurance to these calculations.\n    if (pullTooltipBy < 0) {\n      pullTooltipBy = 0;\n    } else if (pullTooltipBy > tooltipRect.width) {\n      pullTooltipBy = tooltipRect.width;\n    }\n\n    this.el_.style.right = '-' + pullTooltipBy + 'px';\n    textContent(this.el_, content);\n  };\n\n  return TimeTooltip;\n}(Component);\n\nComponent.registerComponent('TimeTooltip', TimeTooltip);\n\n/**\n * @file play-progress-bar.js\n */\n/**\n * Used by {@link SeekBar} to display media playback progress as part of the\n * {@link ProgressControl}.\n *\n * @extends Component\n */\n\nvar PlayProgressBar = function (_Component) {\n  inherits(PlayProgressBar, _Component);\n\n  function PlayProgressBar() {\n    classCallCheck(this, PlayProgressBar);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the the DOM element for this class.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  PlayProgressBar.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-play-progress vjs-slider-bar',\n      innerHTML: '<span class=\"vjs-control-text\"><span>' + this.localize('Progress') + '</span>: 0%</span>'\n    });\n  };\n\n  /**\n   * Enqueues updates to its own DOM as well as the DOM of its\n   * {@link TimeTooltip} child.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */\n\n\n  PlayProgressBar.prototype.update = function update(seekBarRect, seekBarPoint) {\n    var _this2 = this;\n\n    // If there is an existing rAF ID, cancel it so we don't over-queue.\n    if (this.rafId_) {\n      this.cancelAnimationFrame(this.rafId_);\n    }\n\n    this.rafId_ = this.requestAnimationFrame(function () {\n      var time = _this2.player_.scrubbing() ? _this2.player_.getCache().currentTime : _this2.player_.currentTime();\n\n      var content = formatTime(time, _this2.player_.duration());\n      var timeTooltip = _this2.getChild('timeTooltip');\n\n      if (timeTooltip) {\n        timeTooltip.update(seekBarRect, seekBarPoint, content);\n      }\n    });\n  };\n\n  return PlayProgressBar;\n}(Component);\n\n/**\n * Default options for {@link PlayProgressBar}.\n *\n * @type {Object}\n * @private\n */\n\n\nPlayProgressBar.prototype.options_ = {\n  children: []\n};\n\n// Time tooltips should not be added to a player on mobile devices or IE8\nif ((!IE_VERSION || IE_VERSION > 8) && !IS_IOS && !IS_ANDROID) {\n  PlayProgressBar.prototype.options_.children.push('timeTooltip');\n}\n\nComponent.registerComponent('PlayProgressBar', PlayProgressBar);\n\n/**\n * @file mouse-time-display.js\n */\n/**\n * The {@link MouseTimeDisplay} component tracks mouse movement over the\n * {@link ProgressControl}. It displays an indicator and a {@link TimeTooltip}\n * indicating the time which is represented by a given point in the\n * {@link ProgressControl}.\n *\n * @extends Component\n */\n\nvar MouseTimeDisplay = function (_Component) {\n  inherits(MouseTimeDisplay, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The {@link Player} that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function MouseTimeDisplay(player, options) {\n    classCallCheck(this, MouseTimeDisplay);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.update = throttle(bind(_this, _this.update), 25);\n    return _this;\n  }\n\n  /**\n   * Create the DOM element for this class.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  MouseTimeDisplay.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-mouse-display'\n    });\n  };\n\n  /**\n   * Enqueues updates to its own DOM as well as the DOM of its\n   * {@link TimeTooltip} child.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */\n\n\n  MouseTimeDisplay.prototype.update = function update(seekBarRect, seekBarPoint) {\n    var _this2 = this;\n\n    // If there is an existing rAF ID, cancel it so we don't over-queue.\n    if (this.rafId_) {\n      this.cancelAnimationFrame(this.rafId_);\n    }\n\n    this.rafId_ = this.requestAnimationFrame(function () {\n      var duration = _this2.player_.duration();\n      var content = formatTime(seekBarPoint * duration, duration);\n\n      _this2.el_.style.left = seekBarRect.width * seekBarPoint + 'px';\n      _this2.getChild('timeTooltip').update(seekBarRect, seekBarPoint, content);\n    });\n  };\n\n  return MouseTimeDisplay;\n}(Component);\n\n/**\n * Default options for `MouseTimeDisplay`\n *\n * @type {Object}\n * @private\n */\n\n\nMouseTimeDisplay.prototype.options_ = {\n  children: ['timeTooltip']\n};\n\nComponent.registerComponent('MouseTimeDisplay', MouseTimeDisplay);\n\n/**\n * @file seek-bar.js\n */\n// The number of seconds the `step*` functions move the timeline.\nvar STEP_SECONDS = 5;\n\n// The interval at which the bar should update as it progresses.\nvar UPDATE_REFRESH_INTERVAL = 30;\n\n/**\n * Seek bar and container for the progress bars. Uses {@link PlayProgressBar}\n * as its `bar`.\n *\n * @extends Slider\n */\n\nvar SeekBar = function (_Slider) {\n  inherits(SeekBar, _Slider);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function SeekBar(player, options) {\n    classCallCheck(this, SeekBar);\n\n    var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));\n\n    _this.update = throttle(bind(_this, _this.update), UPDATE_REFRESH_INTERVAL);\n\n    _this.on(player, 'timeupdate', _this.update);\n    _this.on(player, 'ended', _this.handleEnded);\n\n    // when playing, let's ensure we smoothly update the play progress bar\n    // via an interval\n    _this.updateInterval = null;\n\n    _this.on(player, ['playing'], function () {\n      _this.clearInterval(_this.updateInterval);\n\n      _this.updateInterval = _this.setInterval(function () {\n        _this.requestAnimationFrame(function () {\n          _this.update();\n        });\n      }, UPDATE_REFRESH_INTERVAL);\n    });\n\n    _this.on(player, ['ended', 'pause', 'waiting'], function () {\n      _this.clearInterval(_this.updateInterval);\n    });\n\n    _this.on(player, ['timeupdate', 'ended'], _this.update);\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  SeekBar.prototype.createEl = function createEl$$1() {\n    return _Slider.prototype.createEl.call(this, 'div', {\n      className: 'vjs-progress-holder'\n    }, {\n      'aria-label': this.localize('Progress Bar')\n    });\n  };\n\n  /**\n   * This function updates the play progress bar and accessiblity\n   * attributes to whatever is passed in.\n   *\n   * @param {number} currentTime\n   *        The currentTime value that should be used for accessiblity\n   *\n   * @param {number} percent\n   *        The percentage as a decimal that the bar should be filled from 0-1.\n   *\n   * @private\n   */\n\n\n  SeekBar.prototype.update_ = function update_(currentTime, percent) {\n    var duration = this.player_.duration();\n\n    // machine readable value of progress bar (percentage complete)\n    this.el_.setAttribute('aria-valuenow', (percent * 100).toFixed(2));\n\n    // human readable value of progress bar (time complete)\n    this.el_.setAttribute('aria-valuetext', this.localize('progress bar timing: currentTime={1} duration={2}', [formatTime(currentTime, duration), formatTime(duration, duration)], '{1} of {2}'));\n\n    // Update the `PlayProgressBar`.\n    this.bar.update(getBoundingClientRect(this.el_), percent);\n  };\n\n  /**\n   * Update the seek bar's UI.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `ended` event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   *\n   * @returns {number}\n   *          The current percent at a number from 0-1\n   */\n\n\n  SeekBar.prototype.update = function update(event) {\n    var percent = _Slider.prototype.update.call(this);\n\n    this.update_(this.getCurrentTime_(), percent);\n    return percent;\n  };\n\n  /**\n   * Get the value of current time but allows for smooth scrubbing,\n   * when player can't keep up.\n   *\n   * @return {number}\n   *         The current time value to display\n   *\n   * @private\n   */\n\n\n  SeekBar.prototype.getCurrentTime_ = function getCurrentTime_() {\n    return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n  };\n\n  /**\n   * We want the seek bar to be full on ended\n   * no matter what the actual internal values are. so we force it.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `ended` event that caused this to run.\n   *\n   * @listens Player#ended\n   */\n\n\n  SeekBar.prototype.handleEnded = function handleEnded(event) {\n    this.update_(this.player_.duration(), 1);\n  };\n\n  /**\n   * Get the percentage of media played so far.\n   *\n   * @return {number}\n   *         The percentage of media played so far (0 to 1).\n   */\n\n\n  SeekBar.prototype.getPercent = function getPercent() {\n    var percent = this.getCurrentTime_() / this.player_.duration();\n\n    return percent >= 1 ? 1 : percent;\n  };\n\n  /**\n   * Handle mouse down on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousedown` event that caused this to run.\n   *\n   * @listens mousedown\n   */\n\n\n  SeekBar.prototype.handleMouseDown = function handleMouseDown(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    this.player_.scrubbing(true);\n\n    this.videoWasPlaying = !this.player_.paused();\n    this.player_.pause();\n\n    _Slider.prototype.handleMouseDown.call(this, event);\n  };\n\n  /**\n   * Handle mouse move on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this to run.\n   *\n   * @listens mousemove\n   */\n\n\n  SeekBar.prototype.handleMouseMove = function handleMouseMove(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    var newTime = this.calculateDistance(event) * this.player_.duration();\n\n    // Don't let video end while scrubbing.\n    if (newTime === this.player_.duration()) {\n      newTime = newTime - 0.1;\n    }\n\n    // Set new time (tell player to seek to new time)\n    this.player_.currentTime(newTime);\n  };\n\n  SeekBar.prototype.enable = function enable() {\n    _Slider.prototype.enable.call(this);\n    var mouseTimeDisplay = this.getChild('mouseTimeDisplay');\n\n    if (!mouseTimeDisplay) {\n      return;\n    }\n\n    mouseTimeDisplay.show();\n  };\n\n  SeekBar.prototype.disable = function disable() {\n    _Slider.prototype.disable.call(this);\n    var mouseTimeDisplay = this.getChild('mouseTimeDisplay');\n\n    if (!mouseTimeDisplay) {\n      return;\n    }\n\n    mouseTimeDisplay.hide();\n  };\n\n  /**\n   * Handle mouse up on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mouseup` event that caused this to run.\n   *\n   * @listens mouseup\n   */\n\n\n  SeekBar.prototype.handleMouseUp = function handleMouseUp(event) {\n    _Slider.prototype.handleMouseUp.call(this, event);\n\n    this.player_.scrubbing(false);\n\n    /**\n     * Trigger timeupdate because we're done seeking and the time has changed.\n     * This is particularly useful for if the player is paused to time the time displays.\n     *\n     * @event Tech#timeupdate\n     * @type {EventTarget~Event}\n     */\n    this.player_.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });\n    if (this.videoWasPlaying) {\n      silencePromise(this.player_.play());\n    }\n  };\n\n  /**\n   * Move more quickly fast forward for keyboard-only users\n   */\n\n\n  SeekBar.prototype.stepForward = function stepForward() {\n    this.player_.currentTime(this.player_.currentTime() + STEP_SECONDS);\n  };\n\n  /**\n   * Move more quickly rewind for keyboard-only users\n   */\n\n\n  SeekBar.prototype.stepBack = function stepBack() {\n    this.player_.currentTime(this.player_.currentTime() - STEP_SECONDS);\n  };\n\n  /**\n   * Toggles the playback state of the player\n   * This gets called when enter or space is used on the seekbar\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called\n   *\n   */\n\n\n  SeekBar.prototype.handleAction = function handleAction(event) {\n    if (this.player_.paused()) {\n      this.player_.play();\n    } else {\n      this.player_.pause();\n    }\n  };\n\n  /**\n   * Called when this SeekBar has focus and a key gets pressed down. By\n   * default it will call `this.handleAction` when the key is space or enter.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */\n\n\n  SeekBar.prototype.handleKeyPress = function handleKeyPress(event) {\n\n    // Support Space (32) or Enter (13) key operation to fire a click event\n    if (event.which === 32 || event.which === 13) {\n      event.preventDefault();\n      this.handleAction(event);\n    } else if (_Slider.prototype.handleKeyPress) {\n\n      // Pass keypress handling up for unsupported keys\n      _Slider.prototype.handleKeyPress.call(this, event);\n    }\n  };\n\n  return SeekBar;\n}(Slider);\n\n/**\n * Default options for the `SeekBar`\n *\n * @type {Object}\n * @private\n */\n\n\nSeekBar.prototype.options_ = {\n  children: ['loadProgressBar', 'playProgressBar'],\n  barName: 'playProgressBar'\n};\n\n// MouseTimeDisplay tooltips should not be added to a player on mobile devices or IE8\nif ((!IE_VERSION || IE_VERSION > 8) && !IS_IOS && !IS_ANDROID) {\n  SeekBar.prototype.options_.children.splice(1, 0, 'mouseTimeDisplay');\n}\n\n/**\n * Call the update event for this Slider when this event happens on the player.\n *\n * @type {string}\n */\nSeekBar.prototype.playerEvent = 'timeupdate';\n\nComponent.registerComponent('SeekBar', SeekBar);\n\n/**\n * @file progress-control.js\n */\n/**\n * The Progress Control component contains the seek bar, load progress,\n * and play progress.\n *\n * @extends Component\n */\n\nvar ProgressControl = function (_Component) {\n  inherits(ProgressControl, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function ProgressControl(player, options) {\n    classCallCheck(this, ProgressControl);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.handleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);\n    _this.throttledHandleMouseSeek = throttle(bind(_this, _this.handleMouseSeek), 25);\n\n    _this.enable();\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  ProgressControl.prototype.createEl = function createEl$$1() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-progress-control vjs-control'\n    });\n  };\n\n  /**\n   * When the mouse moves over the `ProgressControl`, the pointer position\n   * gets passed down to the `MouseTimeDisplay` component.\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this function to run.\n   *\n   * @listen mousemove\n   */\n\n\n  ProgressControl.prototype.handleMouseMove = function handleMouseMove(event) {\n    var seekBar = this.getChild('seekBar');\n    var mouseTimeDisplay = seekBar.getChild('mouseTimeDisplay');\n    var seekBarEl = seekBar.el();\n    var seekBarRect = getBoundingClientRect(seekBarEl);\n    var seekBarPoint = getPointerPosition(seekBarEl, event).x;\n\n    // The default skin has a gap on either side of the `SeekBar`. This means\n    // that it's possible to trigger this behavior outside the boundaries of\n    // the `SeekBar`. This ensures we stay within it at all times.\n    if (seekBarPoint > 1) {\n      seekBarPoint = 1;\n    } else if (seekBarPoint < 0) {\n      seekBarPoint = 0;\n    }\n\n    if (mouseTimeDisplay) {\n      mouseTimeDisplay.update(seekBarRect, seekBarPoint);\n    }\n  };\n\n  /**\n   * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.\n   *\n   * @method ProgressControl#throttledHandleMouseSeek\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this function to run.\n   *\n   * @listen mousemove\n   * @listen touchmove\n   */\n\n  /**\n   * Handle `mousemove` or `touchmove` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousemove\n   * @listens touchmove\n   */\n\n\n  ProgressControl.prototype.handleMouseSeek = function handleMouseSeek(event) {\n    var seekBar = this.getChild('seekBar');\n\n    seekBar.handleMouseMove(event);\n  };\n\n  /**\n   * Are controls are currently enabled for this progress control.\n   *\n   * @return {boolean}\n   *         true if controls are enabled, false otherwise\n   */\n\n\n  ProgressControl.prototype.enabled = function enabled() {\n    return this.enabled_;\n  };\n\n  /**\n   * Disable all controls on the progress control and its children\n   */\n\n\n  ProgressControl.prototype.disable = function disable() {\n    this.children().forEach(function (child) {\n      return child.disable && child.disable();\n    });\n\n    if (!this.enabled()) {\n      return;\n    }\n\n    this.off(['mousedown', 'touchstart'], this.handleMouseDown);\n    this.off(this.el_, 'mousemove', this.handleMouseMove);\n    this.handleMouseUp();\n\n    this.addClass('disabled');\n\n    this.enabled_ = false;\n  };\n\n  /**\n   * Enable all controls on the progress control and its children\n   */\n\n\n  ProgressControl.prototype.enable = function enable() {\n    this.children().forEach(function (child) {\n      return child.enable && child.enable();\n    });\n\n    if (this.enabled()) {\n      return;\n    }\n\n    this.on(['mousedown', 'touchstart'], this.handleMouseDown);\n    this.on(this.el_, 'mousemove', this.handleMouseMove);\n    this.removeClass('disabled');\n\n    this.enabled_ = true;\n  };\n\n  /**\n   * Handle `mousedown` or `touchstart` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */\n\n\n  ProgressControl.prototype.handleMouseDown = function handleMouseDown(event) {\n    var doc = this.el_.ownerDocument;\n\n    this.on(doc, 'mousemove', this.throttledHandleMouseSeek);\n    this.on(doc, 'touchmove', this.throttledHandleMouseSeek);\n    this.on(doc, 'mouseup', this.handleMouseUp);\n    this.on(doc, 'touchend', this.handleMouseUp);\n  };\n\n  /**\n   * Handle `mouseup` or `touchend` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   */\n\n\n  ProgressControl.prototype.handleMouseUp = function handleMouseUp(event) {\n    var doc = this.el_.ownerDocument;\n\n    this.off(doc, 'mousemove', this.throttledHandleMouseSeek);\n    this.off(doc, 'touchmove', this.throttledHandleMouseSeek);\n    this.off(doc, 'mouseup', this.handleMouseUp);\n    this.off(doc, 'touchend', this.handleMouseUp);\n  };\n\n  return ProgressControl;\n}(Component);\n\n/**\n * Default options for `ProgressControl`\n *\n * @type {Object}\n * @private\n */\n\n\nProgressControl.prototype.options_ = {\n  children: ['seekBar']\n};\n\nComponent.registerComponent('ProgressControl', ProgressControl);\n\n/**\n * @file fullscreen-toggle.js\n */\n/**\n * Toggle fullscreen video\n *\n * @extends Button\n */\n\nvar FullscreenToggle = function (_Button) {\n  inherits(FullscreenToggle, _Button);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function FullscreenToggle(player, options) {\n    classCallCheck(this, FullscreenToggle);\n\n    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));\n\n    _this.on(player, 'fullscreenchange', _this.handleFullscreenChange);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  FullscreenToggle.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-fullscreen-control ' + _Button.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Handles fullscreenchange on the player and change control text accordingly.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#fullscreenchange} event that caused this function to be\n   *        called.\n   *\n   * @listens Player#fullscreenchange\n   */\n\n\n  FullscreenToggle.prototype.handleFullscreenChange = function handleFullscreenChange(event) {\n    if (this.player_.isFullscreen()) {\n      this.controlText('Non-Fullscreen');\n    } else {\n      this.controlText('Fullscreen');\n    }\n  };\n\n  /**\n   * This gets called when an `FullscreenToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  FullscreenToggle.prototype.handleClick = function handleClick(event) {\n    if (!this.player_.isFullscreen()) {\n      this.player_.requestFullscreen();\n    } else {\n      this.player_.exitFullscreen();\n    }\n  };\n\n  return FullscreenToggle;\n}(Button);\n\n/**\n * The text that should display over the `FullscreenToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nFullscreenToggle.prototype.controlText_ = 'Fullscreen';\n\nComponent.registerComponent('FullscreenToggle', FullscreenToggle);\n\n/**\n * Check if volume control is supported and if it isn't hide the\n * `Component` that was passed  using the `vjs-hidden` class.\n *\n * @param {Component} self\n *        The component that should be hidden if volume is unsupported\n *\n * @param {Player} player\n *        A reference to the player\n *\n * @private\n */\nvar checkVolumeSupport = function checkVolumeSupport(self, player) {\n  // hide volume controls when they're not supported by the current tech\n  if (player.tech_ && !player.tech_.featuresVolumeControl) {\n    self.addClass('vjs-hidden');\n  }\n\n  self.on(player, 'loadstart', function () {\n    if (!player.tech_.featuresVolumeControl) {\n      self.addClass('vjs-hidden');\n    } else {\n      self.removeClass('vjs-hidden');\n    }\n  });\n};\n\n/**\n * @file volume-level.js\n */\n/**\n * Shows volume level\n *\n * @extends Component\n */\n\nvar VolumeLevel = function (_Component) {\n  inherits(VolumeLevel, _Component);\n\n  function VolumeLevel() {\n    classCallCheck(this, VolumeLevel);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  VolumeLevel.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-volume-level',\n      innerHTML: '<span class=\"vjs-control-text\"></span>'\n    });\n  };\n\n  return VolumeLevel;\n}(Component);\n\nComponent.registerComponent('VolumeLevel', VolumeLevel);\n\n/**\n * @file volume-bar.js\n */\n// Required children\n/**\n * The bar that contains the volume level and can be clicked on to adjust the level\n *\n * @extends Slider\n */\n\nvar VolumeBar = function (_Slider) {\n  inherits(VolumeBar, _Slider);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function VolumeBar(player, options) {\n    classCallCheck(this, VolumeBar);\n\n    var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));\n\n    _this.on('slideractive', _this.updateLastVolume_);\n    _this.on(player, 'volumechange', _this.updateARIAAttributes);\n    player.ready(function () {\n      return _this.updateARIAAttributes();\n    });\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  VolumeBar.prototype.createEl = function createEl$$1() {\n    return _Slider.prototype.createEl.call(this, 'div', {\n      className: 'vjs-volume-bar vjs-slider-bar'\n    }, {\n      'aria-label': this.localize('Volume Level'),\n      'aria-live': 'polite'\n    });\n  };\n\n  /**\n   * Handle mouse down on volume bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousedown` event that caused this to run.\n   *\n   * @listens mousedown\n   */\n\n\n  VolumeBar.prototype.handleMouseDown = function handleMouseDown(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    _Slider.prototype.handleMouseDown.call(this, event);\n  };\n\n  /**\n   * Handle movement events on the {@link VolumeMenuButton}.\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run.\n   *\n   * @listens mousemove\n   */\n\n\n  VolumeBar.prototype.handleMouseMove = function handleMouseMove(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    this.checkMuted();\n    this.player_.volume(this.calculateDistance(event));\n  };\n\n  /**\n   * If the player is muted unmute it.\n   */\n\n\n  VolumeBar.prototype.checkMuted = function checkMuted() {\n    if (this.player_.muted()) {\n      this.player_.muted(false);\n    }\n  };\n\n  /**\n   * Get percent of volume level\n   *\n   * @return {number}\n   *         Volume level percent as a decimal number.\n   */\n\n\n  VolumeBar.prototype.getPercent = function getPercent() {\n    if (this.player_.muted()) {\n      return 0;\n    }\n    return this.player_.volume();\n  };\n\n  /**\n   * Increase volume level for keyboard users\n   */\n\n\n  VolumeBar.prototype.stepForward = function stepForward() {\n    this.checkMuted();\n    this.player_.volume(this.player_.volume() + 0.1);\n  };\n\n  /**\n   * Decrease volume level for keyboard users\n   */\n\n\n  VolumeBar.prototype.stepBack = function stepBack() {\n    this.checkMuted();\n    this.player_.volume(this.player_.volume() - 0.1);\n  };\n\n  /**\n   * Update ARIA accessibility attributes\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `volumechange` event that caused this function to run.\n   *\n   * @listens Player#volumechange\n   */\n\n\n  VolumeBar.prototype.updateARIAAttributes = function updateARIAAttributes(event) {\n    var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();\n\n    this.el_.setAttribute('aria-valuenow', ariaValue);\n    this.el_.setAttribute('aria-valuetext', ariaValue + '%');\n  };\n\n  /**\n   * Returns the current value of the player volume as a percentage\n   *\n   * @private\n   */\n\n\n  VolumeBar.prototype.volumeAsPercentage_ = function volumeAsPercentage_() {\n    return Math.round(this.player_.volume() * 100);\n  };\n\n  /**\n   * When user starts dragging the VolumeBar, store the volume and listen for\n   * the end of the drag. When the drag ends, if the volume was set to zero,\n   * set lastVolume to the stored volume.\n   *\n   * @listens slideractive\n   * @private\n   */\n\n\n  VolumeBar.prototype.updateLastVolume_ = function updateLastVolume_() {\n    var _this2 = this;\n\n    var volumeBeforeDrag = this.player_.volume();\n\n    this.one('sliderinactive', function () {\n      if (_this2.player_.volume() === 0) {\n        _this2.player_.lastVolume_(volumeBeforeDrag);\n      }\n    });\n  };\n\n  return VolumeBar;\n}(Slider);\n\n/**\n * Default options for the `VolumeBar`\n *\n * @type {Object}\n * @private\n */\n\n\nVolumeBar.prototype.options_ = {\n  children: ['volumeLevel'],\n  barName: 'volumeLevel'\n};\n\n/**\n * Call the update event for this Slider when this event happens on the player.\n *\n * @type {string}\n */\nVolumeBar.prototype.playerEvent = 'volumechange';\n\nComponent.registerComponent('VolumeBar', VolumeBar);\n\n/**\n * @file volume-control.js\n */\n// Required children\n/**\n * The component for controlling the volume level\n *\n * @extends Component\n */\n\nvar VolumeControl = function (_Component) {\n  inherits(VolumeControl, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n  function VolumeControl(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, VolumeControl);\n\n    options.vertical = options.vertical || false;\n\n    // Pass the vertical option down to the VolumeBar if\n    // the VolumeBar is turned on.\n    if (typeof options.volumeBar === 'undefined' || isPlain(options.volumeBar)) {\n      options.volumeBar = options.volumeBar || {};\n      options.volumeBar.vertical = options.vertical;\n    }\n\n    // hide this control if volume support is missing\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    checkVolumeSupport(_this, player);\n\n    _this.throttledHandleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);\n\n    _this.on('mousedown', _this.handleMouseDown);\n    _this.on('touchstart', _this.handleMouseDown);\n\n    // while the slider is active (the mouse has been pressed down and\n    // is dragging) or in focus we do not want to hide the VolumeBar\n    _this.on(_this.volumeBar, ['focus', 'slideractive'], function () {\n      _this.volumeBar.addClass('vjs-slider-active');\n      _this.addClass('vjs-slider-active');\n      _this.trigger('slideractive');\n    });\n\n    _this.on(_this.volumeBar, ['blur', 'sliderinactive'], function () {\n      _this.volumeBar.removeClass('vjs-slider-active');\n      _this.removeClass('vjs-slider-active');\n      _this.trigger('sliderinactive');\n    });\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  VolumeControl.prototype.createEl = function createEl() {\n    var orientationClass = 'vjs-volume-horizontal';\n\n    if (this.options_.vertical) {\n      orientationClass = 'vjs-volume-vertical';\n    }\n\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-volume-control vjs-control ' + orientationClass\n    });\n  };\n\n  /**\n   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */\n\n\n  VolumeControl.prototype.handleMouseDown = function handleMouseDown(event) {\n    var doc = this.el_.ownerDocument;\n\n    this.on(doc, 'mousemove', this.throttledHandleMouseMove);\n    this.on(doc, 'touchmove', this.throttledHandleMouseMove);\n    this.on(doc, 'mouseup', this.handleMouseUp);\n    this.on(doc, 'touchend', this.handleMouseUp);\n  };\n\n  /**\n   * Handle `mouseup` or `touchend` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   */\n\n\n  VolumeControl.prototype.handleMouseUp = function handleMouseUp(event) {\n    var doc = this.el_.ownerDocument;\n\n    this.off(doc, 'mousemove', this.throttledHandleMouseMove);\n    this.off(doc, 'touchmove', this.throttledHandleMouseMove);\n    this.off(doc, 'mouseup', this.handleMouseUp);\n    this.off(doc, 'touchend', this.handleMouseUp);\n  };\n\n  /**\n   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */\n\n\n  VolumeControl.prototype.handleMouseMove = function handleMouseMove(event) {\n    this.volumeBar.handleMouseMove(event);\n  };\n\n  return VolumeControl;\n}(Component);\n\n/**\n * Default options for the `VolumeControl`\n *\n * @type {Object}\n * @private\n */\n\n\nVolumeControl.prototype.options_ = {\n  children: ['volumeBar']\n};\n\nComponent.registerComponent('VolumeControl', VolumeControl);\n\n/**\n * @file mute-toggle.js\n */\n/**\n * A button component for muting the audio.\n *\n * @extends Button\n */\n\nvar MuteToggle = function (_Button) {\n  inherits(MuteToggle, _Button);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function MuteToggle(player, options) {\n    classCallCheck(this, MuteToggle);\n\n    // hide this control if volume support is missing\n    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));\n\n    checkVolumeSupport(_this, player);\n\n    _this.on(player, ['loadstart', 'volumechange'], _this.update);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  MuteToggle.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-mute-control ' + _Button.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * This gets called when an `MuteToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  MuteToggle.prototype.handleClick = function handleClick(event) {\n    var vol = this.player_.volume();\n    var lastVolume = this.player_.lastVolume_();\n\n    if (vol === 0) {\n      var volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;\n\n      this.player_.volume(volumeToSet);\n      this.player_.muted(false);\n    } else {\n      this.player_.muted(this.player_.muted() ? false : true);\n    }\n  };\n\n  /**\n   * Update the `MuteToggle` button based on the state of `volume` and `muted`\n   * on the player.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#loadstart} event if this function was called\n   *        through an event.\n   *\n   * @listens Player#loadstart\n   * @listens Player#volumechange\n   */\n\n\n  MuteToggle.prototype.update = function update(event) {\n    this.updateIcon_();\n    this.updateControlText_();\n  };\n\n  /**\n   * Update the appearance of the `MuteToggle` icon.\n   *\n   * Possible states (given `level` variable below):\n   * - 0: crossed out\n   * - 1: zero bars of volume\n   * - 2: one bar of volume\n   * - 3: two bars of volume\n   *\n   * @private\n   */\n\n\n  MuteToggle.prototype.updateIcon_ = function updateIcon_() {\n    var vol = this.player_.volume();\n    var level = 3;\n\n    if (vol === 0 || this.player_.muted()) {\n      level = 0;\n    } else if (vol < 0.33) {\n      level = 1;\n    } else if (vol < 0.67) {\n      level = 2;\n    }\n\n    // TODO improve muted icon classes\n    for (var i = 0; i < 4; i++) {\n      removeClass(this.el_, 'vjs-vol-' + i);\n    }\n    addClass(this.el_, 'vjs-vol-' + level);\n  };\n\n  /**\n   * If `muted` has changed on the player, update the control text\n   * (`title` attribute on `vjs-mute-control` element and content of\n   * `vjs-control-text` element).\n   *\n   * @private\n   */\n\n\n  MuteToggle.prototype.updateControlText_ = function updateControlText_() {\n    var soundOff = this.player_.muted() || this.player_.volume() === 0;\n    var text = soundOff ? 'Unmute' : 'Mute';\n\n    if (this.controlText() !== text) {\n      this.controlText(text);\n    }\n  };\n\n  return MuteToggle;\n}(Button);\n\n/**\n * The text that should display over the `MuteToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nMuteToggle.prototype.controlText_ = 'Mute';\n\nComponent.registerComponent('MuteToggle', MuteToggle);\n\n/**\n * @file volume-control.js\n */\n// Required children\n/**\n * A Component to contain the MuteToggle and VolumeControl so that\n * they can work together.\n *\n * @extends Component\n */\n\nvar VolumePanel = function (_Component) {\n  inherits(VolumePanel, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n  function VolumePanel(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, VolumePanel);\n\n    if (typeof options.inline !== 'undefined') {\n      options.inline = options.inline;\n    } else {\n      options.inline = true;\n    }\n\n    // pass the inline option down to the VolumeControl as vertical if\n    // the VolumeControl is on.\n    if (typeof options.volumeControl === 'undefined' || isPlain(options.volumeControl)) {\n      options.volumeControl = options.volumeControl || {};\n      options.volumeControl.vertical = !options.inline;\n    }\n\n    // hide this control if volume support is missing\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    checkVolumeSupport(_this, player);\n\n    // while the slider is active (the mouse has been pressed down and\n    // is dragging) we do not want to hide the VolumeBar\n    _this.on(_this.volumeControl, ['slideractive'], _this.sliderActive_);\n\n    _this.on(_this.volumeControl, ['sliderinactive'], _this.sliderInactive_);\n    return _this;\n  }\n\n  /**\n   * Add vjs-slider-active class to the VolumePanel\n   *\n   * @listens VolumeControl#slideractive\n   * @private\n   */\n\n\n  VolumePanel.prototype.sliderActive_ = function sliderActive_() {\n    this.addClass('vjs-slider-active');\n  };\n\n  /**\n   * Removes vjs-slider-active class to the VolumePanel\n   *\n   * @listens VolumeControl#sliderinactive\n   * @private\n   */\n\n\n  VolumePanel.prototype.sliderInactive_ = function sliderInactive_() {\n    this.removeClass('vjs-slider-active');\n  };\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  VolumePanel.prototype.createEl = function createEl() {\n    var orientationClass = 'vjs-volume-panel-horizontal';\n\n    if (!this.options_.inline) {\n      orientationClass = 'vjs-volume-panel-vertical';\n    }\n\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-volume-panel vjs-control ' + orientationClass\n    });\n  };\n\n  return VolumePanel;\n}(Component);\n\n/**\n * Default options for the `VolumeControl`\n *\n * @type {Object}\n * @private\n */\n\n\nVolumePanel.prototype.options_ = {\n  children: ['muteToggle', 'volumeControl']\n};\n\nComponent.registerComponent('VolumePanel', VolumePanel);\n\n/**\n * @file menu.js\n */\n/**\n * The Menu component is used to build popup menus, including subtitle and\n * captions selection menus.\n *\n * @extends Component\n */\n\nvar Menu = function (_Component) {\n  inherits(Menu, _Component);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        the player that this component should attach to\n   *\n   * @param {Object} [options]\n   *        Object of option names and values\n   *\n   */\n  function Menu(player, options) {\n    classCallCheck(this, Menu);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    if (options) {\n      _this.menuButton_ = options.menuButton;\n    }\n\n    _this.focusedChild_ = -1;\n\n    _this.on('keydown', _this.handleKeyPress);\n    return _this;\n  }\n\n  /**\n   * Add a {@link MenuItem} to the menu.\n   *\n   * @param {Object|string} component\n   *        The name or instance of the `MenuItem` to add.\n   *\n   */\n\n\n  Menu.prototype.addItem = function addItem(component) {\n    this.addChild(component);\n    component.on('click', bind(this, function (event) {\n      // Unpress the associated MenuButton, and move focus back to it\n      if (this.menuButton_) {\n        this.menuButton_.unpressButton();\n\n        // don't focus menu button if item is a caption settings item\n        // because focus will move elsewhere and it logs an error on IE8\n        if (component.name() !== 'CaptionSettingsMenuItem') {\n          this.menuButton_.focus();\n        }\n      }\n    }));\n  };\n\n  /**\n   * Create the `Menu`s DOM element.\n   *\n   * @return {Element}\n   *         the element that was created\n   */\n\n\n  Menu.prototype.createEl = function createEl$$1() {\n    var contentElType = this.options_.contentElType || 'ul';\n\n    this.contentEl_ = createEl(contentElType, {\n      className: 'vjs-menu-content'\n    });\n\n    this.contentEl_.setAttribute('role', 'menu');\n\n    var el = _Component.prototype.createEl.call(this, 'div', {\n      append: this.contentEl_,\n      className: 'vjs-menu'\n    });\n\n    el.appendChild(this.contentEl_);\n\n    // Prevent clicks from bubbling up. Needed for Menu Buttons,\n    // where a click on the parent is significant\n    on(el, 'click', function (event) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    });\n\n    return el;\n  };\n\n  Menu.prototype.dispose = function dispose() {\n    this.contentEl_ = null;\n\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Handle a `keydown` event on this menu. This listener is added in the constructor.\n   *\n   * @param {EventTarget~Event} event\n   *        A `keydown` event that happened on the menu.\n   *\n   * @listens keydown\n   */\n\n\n  Menu.prototype.handleKeyPress = function handleKeyPress(event) {\n    // Left and Down Arrows\n    if (event.which === 37 || event.which === 40) {\n      event.preventDefault();\n      this.stepForward();\n\n      // Up and Right Arrows\n    } else if (event.which === 38 || event.which === 39) {\n      event.preventDefault();\n      this.stepBack();\n    }\n  };\n\n  /**\n   * Move to next (lower) menu item for keyboard users.\n   */\n\n\n  Menu.prototype.stepForward = function stepForward() {\n    var stepChild = 0;\n\n    if (this.focusedChild_ !== undefined) {\n      stepChild = this.focusedChild_ + 1;\n    }\n    this.focus(stepChild);\n  };\n\n  /**\n   * Move to previous (higher) menu item for keyboard users.\n   */\n\n\n  Menu.prototype.stepBack = function stepBack() {\n    var stepChild = 0;\n\n    if (this.focusedChild_ !== undefined) {\n      stepChild = this.focusedChild_ - 1;\n    }\n    this.focus(stepChild);\n  };\n\n  /**\n   * Set focus on a {@link MenuItem} in the `Menu`.\n   *\n   * @param {Object|string} [item=0]\n   *        Index of child item set focus on.\n   */\n\n\n  Menu.prototype.focus = function focus() {\n    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    var children = this.children().slice();\n    var haveTitle = children.length && children[0].className && /vjs-menu-title/.test(children[0].className);\n\n    if (haveTitle) {\n      children.shift();\n    }\n\n    if (children.length > 0) {\n      if (item < 0) {\n        item = 0;\n      } else if (item >= children.length) {\n        item = children.length - 1;\n      }\n\n      this.focusedChild_ = item;\n\n      children[item].el_.focus();\n    }\n  };\n\n  return Menu;\n}(Component);\n\nComponent.registerComponent('Menu', Menu);\n\n/**\n * @file menu-button.js\n */\n/**\n * A `MenuButton` class for any popup {@link Menu}.\n *\n * @extends Component\n */\n\nvar MenuButton = function (_Component) {\n  inherits(MenuButton, _Component);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n  function MenuButton(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, MenuButton);\n\n    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));\n\n    _this.menuButton_ = new Button(player, options);\n\n    _this.menuButton_.controlText(_this.controlText_);\n    _this.menuButton_.el_.setAttribute('aria-haspopup', 'true');\n\n    // Add buildCSSClass values to the button, not the wrapper\n    var buttonClass = Button.prototype.buildCSSClass();\n\n    _this.menuButton_.el_.className = _this.buildCSSClass() + ' ' + buttonClass;\n    _this.menuButton_.removeClass('vjs-control');\n\n    _this.addChild(_this.menuButton_);\n\n    _this.update();\n\n    _this.enabled_ = true;\n\n    _this.on(_this.menuButton_, 'tap', _this.handleClick);\n    _this.on(_this.menuButton_, 'click', _this.handleClick);\n    _this.on(_this.menuButton_, 'focus', _this.handleFocus);\n    _this.on(_this.menuButton_, 'blur', _this.handleBlur);\n\n    _this.on('keydown', _this.handleSubmenuKeyPress);\n    return _this;\n  }\n\n  /**\n   * Update the menu based on the current state of its items.\n   */\n\n\n  MenuButton.prototype.update = function update() {\n    var menu = this.createMenu();\n\n    if (this.menu) {\n      this.menu.dispose();\n      this.removeChild(this.menu);\n    }\n\n    this.menu = menu;\n    this.addChild(menu);\n\n    /**\n     * Track the state of the menu button\n     *\n     * @type {Boolean}\n     * @private\n     */\n    this.buttonPressed_ = false;\n    this.menuButton_.el_.setAttribute('aria-expanded', 'false');\n\n    if (this.items && this.items.length <= this.hideThreshold_) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  };\n\n  /**\n   * Create the menu and add all items to it.\n   *\n   * @return {Menu}\n   *         The constructed menu\n   */\n\n\n  MenuButton.prototype.createMenu = function createMenu() {\n    var menu = new Menu(this.player_, { menuButton: this });\n\n    /**\n     * Hide the menu if the number of items is less than or equal to this threshold. This defaults\n     * to 0 and whenever we add items which can be hidden to the menu we'll increment it. We list\n     * it here because every time we run `createMenu` we need to reset the value.\n     *\n     * @protected\n     * @type {Number}\n     */\n    this.hideThreshold_ = 0;\n\n    // Add a title list item to the top\n    if (this.options_.title) {\n      var title = createEl('li', {\n        className: 'vjs-menu-title',\n        innerHTML: toTitleCase(this.options_.title),\n        tabIndex: -1\n      });\n\n      this.hideThreshold_ += 1;\n\n      menu.children_.unshift(title);\n      prependTo(title, menu.contentEl());\n    }\n\n    this.items = this.createItems();\n\n    if (this.items) {\n      // Add menu items to the menu\n      for (var i = 0; i < this.items.length; i++) {\n        menu.addItem(this.items[i]);\n      }\n    }\n\n    return menu;\n  };\n\n  /**\n   * Create the list of menu items. Specific to each subclass.\n   *\n   * @abstract\n   */\n\n\n  MenuButton.prototype.createItems = function createItems() {};\n\n  /**\n   * Create the `MenuButtons`s DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  MenuButton.prototype.createEl = function createEl$$1() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: this.buildWrapperCSSClass()\n    }, {});\n  };\n\n  /**\n   * Allow sub components to stack CSS class names for the wrapper element\n   *\n   * @return {string}\n   *         The constructed wrapper DOM `className`\n   */\n\n\n  MenuButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    var menuButtonClass = 'vjs-menu-button';\n\n    // If the inline option is passed, we want to use different styles altogether.\n    if (this.options_.inline === true) {\n      menuButtonClass += '-inline';\n    } else {\n      menuButtonClass += '-popup';\n    }\n\n    // TODO: Fix the CSS so that this isn't necessary\n    var buttonClass = Button.prototype.buildCSSClass();\n\n    return 'vjs-menu-button ' + menuButtonClass + ' ' + buttonClass + ' ' + _Component.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  MenuButton.prototype.buildCSSClass = function buildCSSClass() {\n    var menuButtonClass = 'vjs-menu-button';\n\n    // If the inline option is passed, we want to use different styles altogether.\n    if (this.options_.inline === true) {\n      menuButtonClass += '-inline';\n    } else {\n      menuButtonClass += '-popup';\n    }\n\n    return 'vjs-menu-button ' + menuButtonClass + ' ' + _Component.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Get or set the localized control text that will be used for accessibility.\n   *\n   * > NOTE: This will come from the internal `menuButton_` element.\n   *\n   * @param {string} [text]\n   *        Control text for element.\n   *\n   * @param {Element} [el=this.menuButton_.el()]\n   *        Element to set the title on.\n   *\n   * @return {string}\n   *         - The control text when getting\n   */\n\n\n  MenuButton.prototype.controlText = function controlText(text) {\n    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.menuButton_.el();\n\n    return this.menuButton_.controlText(text, el);\n  };\n\n  /**\n   * Handle a click on a `MenuButton`.\n   * See {@link ClickableComponent#handleClick} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  MenuButton.prototype.handleClick = function handleClick(event) {\n    // When you click the button it adds focus, which will show the menu.\n    // So we'll remove focus when the mouse leaves the button. Focus is needed\n    // for tab navigation.\n\n    this.one(this.menu.contentEl(), 'mouseleave', bind(this, function (e) {\n      this.unpressButton();\n      this.el_.blur();\n    }));\n    if (this.buttonPressed_) {\n      this.unpressButton();\n    } else {\n      this.pressButton();\n    }\n  };\n\n  /**\n   * Set the focus to the actual button, not to this element\n   */\n\n\n  MenuButton.prototype.focus = function focus() {\n    this.menuButton_.focus();\n  };\n\n  /**\n   * Remove the focus from the actual button, not this element\n   */\n\n\n  MenuButton.prototype.blur = function blur() {\n    this.menuButton_.blur();\n  };\n\n  /**\n   * This gets called when a `MenuButton` gains focus via a `focus` event.\n   * Turns on listening for `keydown` events. When they happen it\n   * calls `this.handleKeyPress`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `focus` event that caused this function to be called.\n   *\n   * @listens focus\n   */\n\n\n  MenuButton.prototype.handleFocus = function handleFocus() {\n    on(document, 'keydown', bind(this, this.handleKeyPress));\n  };\n\n  /**\n   * Called when a `MenuButton` loses focus. Turns off the listener for\n   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `blur` event that caused this function to be called.\n   *\n   * @listens blur\n   */\n\n\n  MenuButton.prototype.handleBlur = function handleBlur() {\n    off(document, 'keydown', bind(this, this.handleKeyPress));\n  };\n\n  /**\n   * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See\n   * {@link ClickableComponent#handleKeyPress} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */\n\n\n  MenuButton.prototype.handleKeyPress = function handleKeyPress(event) {\n\n    // Escape (27) key or Tab (9) key unpress the 'button'\n    if (event.which === 27 || event.which === 9) {\n      if (this.buttonPressed_) {\n        this.unpressButton();\n      }\n      // Don't preventDefault for Tab key - we still want to lose focus\n      if (event.which !== 9) {\n        event.preventDefault();\n        // Set focus back to the menu button's button\n        this.menuButton_.el_.focus();\n      }\n      // Up (38) key or Down (40) key press the 'button'\n    } else if (event.which === 38 || event.which === 40) {\n      if (!this.buttonPressed_) {\n        this.pressButton();\n        event.preventDefault();\n      }\n    }\n  };\n\n  /**\n   * Handle a `keydown` event on a sub-menu. The listener for this is added in\n   * the constructor.\n   *\n   * @param {EventTarget~Event} event\n   *        Key press event\n   *\n   * @listens keydown\n   */\n\n\n  MenuButton.prototype.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {\n\n    // Escape (27) key or Tab (9) key unpress the 'button'\n    if (event.which === 27 || event.which === 9) {\n      if (this.buttonPressed_) {\n        this.unpressButton();\n      }\n      // Don't preventDefault for Tab key - we still want to lose focus\n      if (event.which !== 9) {\n        event.preventDefault();\n        // Set focus back to the menu button's button\n        this.menuButton_.el_.focus();\n      }\n    }\n  };\n\n  /**\n   * Put the current `MenuButton` into a pressed state.\n   */\n\n\n  MenuButton.prototype.pressButton = function pressButton() {\n    if (this.enabled_) {\n      this.buttonPressed_ = true;\n      this.menu.lockShowing();\n      this.menuButton_.el_.setAttribute('aria-expanded', 'true');\n\n      // set the focus into the submenu, except on iOS where it is resulting in\n      // undesired scrolling behavior when the player is in an iframe\n      if (IS_IOS && isInFrame()) {\n        // Return early so that the menu isn't focused\n        return;\n      }\n\n      this.menu.focus();\n    }\n  };\n\n  /**\n   * Take the current `MenuButton` out of a pressed state.\n   */\n\n\n  MenuButton.prototype.unpressButton = function unpressButton() {\n    if (this.enabled_) {\n      this.buttonPressed_ = false;\n      this.menu.unlockShowing();\n      this.menuButton_.el_.setAttribute('aria-expanded', 'false');\n    }\n  };\n\n  /**\n   * Disable the `MenuButton`. Don't allow it to be clicked.\n   */\n\n\n  MenuButton.prototype.disable = function disable() {\n    this.unpressButton();\n\n    this.enabled_ = false;\n    this.addClass('vjs-disabled');\n\n    this.menuButton_.disable();\n  };\n\n  /**\n   * Enable the `MenuButton`. Allow it to be clicked.\n   */\n\n\n  MenuButton.prototype.enable = function enable() {\n    this.enabled_ = true;\n    this.removeClass('vjs-disabled');\n\n    this.menuButton_.enable();\n  };\n\n  return MenuButton;\n}(Component);\n\nComponent.registerComponent('MenuButton', MenuButton);\n\n/**\n * @file track-button.js\n */\n/**\n * The base class for buttons that toggle specific  track types (e.g. subtitles).\n *\n * @extends MenuButton\n */\n\nvar TrackButton = function (_MenuButton) {\n  inherits(TrackButton, _MenuButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function TrackButton(player, options) {\n    classCallCheck(this, TrackButton);\n\n    var tracks = options.tracks;\n\n    var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));\n\n    if (_this.items.length <= 1) {\n      _this.hide();\n    }\n\n    if (!tracks) {\n      return possibleConstructorReturn(_this);\n    }\n\n    var updateHandler = bind(_this, _this.update);\n\n    tracks.addEventListener('removetrack', updateHandler);\n    tracks.addEventListener('addtrack', updateHandler);\n    _this.player_.on('ready', updateHandler);\n\n    _this.player_.on('dispose', function () {\n      tracks.removeEventListener('removetrack', updateHandler);\n      tracks.removeEventListener('addtrack', updateHandler);\n    });\n    return _this;\n  }\n\n  return TrackButton;\n}(MenuButton);\n\nComponent.registerComponent('TrackButton', TrackButton);\n\n/**\n * @file menu-item.js\n */\n/**\n * The component for a menu item. `<li>`\n *\n * @extends ClickableComponent\n */\n\nvar MenuItem = function (_ClickableComponent) {\n  inherits(MenuItem, _ClickableComponent);\n\n  /**\n   * Creates an instance of the this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   *\n   */\n  function MenuItem(player, options) {\n    classCallCheck(this, MenuItem);\n\n    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));\n\n    _this.selectable = options.selectable;\n\n    _this.selected(options.selected);\n\n    if (_this.selectable) {\n      // TODO: May need to be either menuitemcheckbox or menuitemradio,\n      //       and may need logical grouping of menu items.\n      _this.el_.setAttribute('role', 'menuitemcheckbox');\n    } else {\n      _this.el_.setAttribute('role', 'menuitem');\n    }\n    return _this;\n  }\n\n  /**\n   * Create the `MenuItem's DOM element\n   *\n   * @param {string} [type=li]\n   *        Element's node type, not actually used, always set to `li`.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element\n   *\n   * @param {Object} [attrs={}]\n   *        An object of attributes that should be set on the element\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  MenuItem.prototype.createEl = function createEl(type, props, attrs) {\n    // The control is textual, not just an icon\n    this.nonIconControl = true;\n\n    return _ClickableComponent.prototype.createEl.call(this, 'li', assign({\n      className: 'vjs-menu-item',\n      innerHTML: '<span class=\"vjs-menu-item-text\">' + this.localize(this.options_.label) + '</span>',\n      tabIndex: -1\n    }, props), attrs);\n  };\n\n  /**\n   * Any click on a `MenuItem` puts int into the selected state.\n   * See {@link ClickableComponent#handleClick} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  MenuItem.prototype.handleClick = function handleClick(event) {\n    this.selected(true);\n  };\n\n  /**\n   * Set the state for this menu item as selected or not.\n   *\n   * @param {boolean} selected\n   *        if the menu item is selected or not\n   */\n\n\n  MenuItem.prototype.selected = function selected(_selected) {\n    if (this.selectable) {\n      if (_selected) {\n        this.addClass('vjs-selected');\n        this.el_.setAttribute('aria-checked', 'true');\n        // aria-checked isn't fully supported by browsers/screen readers,\n        // so indicate selected state to screen reader in the control text.\n        this.controlText(', selected');\n      } else {\n        this.removeClass('vjs-selected');\n        this.el_.setAttribute('aria-checked', 'false');\n        // Indicate un-selected state to screen reader\n        this.controlText('');\n      }\n    }\n  };\n\n  return MenuItem;\n}(ClickableComponent);\n\nComponent.registerComponent('MenuItem', MenuItem);\n\n/**\n * @file text-track-menu-item.js\n */\n/**\n * The specific menu item type for selecting a language within a text track kind\n *\n * @extends MenuItem\n */\n\nvar TextTrackMenuItem = function (_MenuItem) {\n  inherits(TextTrackMenuItem, _MenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function TextTrackMenuItem(player, options) {\n    classCallCheck(this, TextTrackMenuItem);\n\n    var track = options.track;\n    var tracks = player.textTracks();\n\n    // Modify options for parent MenuItem class's init.\n    options.label = track.label || track.language || 'Unknown';\n    options.selected = track.mode === 'showing';\n\n    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));\n\n    _this.track = track;\n    var changeHandler = function changeHandler() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this.handleTracksChange.apply(_this, args);\n    };\n    var selectedLanguageChangeHandler = function selectedLanguageChangeHandler() {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this.handleSelectedLanguageChange.apply(_this, args);\n    };\n\n    player.on(['loadstart', 'texttrackchange'], changeHandler);\n    tracks.addEventListener('change', changeHandler);\n    tracks.addEventListener('selectedlanguagechange', selectedLanguageChangeHandler);\n    _this.on('dispose', function () {\n      player.off(['loadstart', 'texttrackchange'], changeHandler);\n      tracks.removeEventListener('change', changeHandler);\n      tracks.removeEventListener('selectedlanguagechange', selectedLanguageChangeHandler);\n    });\n\n    // iOS7 doesn't dispatch change events to TextTrackLists when an\n    // associated track's mode changes. Without something like\n    // Object.observe() (also not present on iOS7), it's not\n    // possible to detect changes to the mode attribute and polyfill\n    // the change event. As a poor substitute, we manually dispatch\n    // change events whenever the controls modify the mode.\n    if (tracks.onchange === undefined) {\n      var event = void 0;\n\n      _this.on(['tap', 'click'], function () {\n        if (_typeof(window.Event) !== 'object') {\n          // Android 2.3 throws an Illegal Constructor error for window.Event\n          try {\n            event = new window.Event('change');\n          } catch (err) {\n            // continue regardless of error\n          }\n        }\n\n        if (!event) {\n          event = document.createEvent('Event');\n          event.initEvent('change', true, true);\n        }\n\n        tracks.dispatchEvent(event);\n      });\n    }\n\n    // set the default state based on current tracks\n    _this.handleTracksChange();\n    return _this;\n  }\n\n  /**\n   * This gets called when an `TextTrackMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  TextTrackMenuItem.prototype.handleClick = function handleClick(event) {\n    var kind = this.track.kind;\n    var kinds = this.track.kinds;\n    var tracks = this.player_.textTracks();\n\n    if (!kinds) {\n      kinds = [kind];\n    }\n\n    _MenuItem.prototype.handleClick.call(this, event);\n\n    if (!tracks) {\n      return;\n    }\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n\n      if (track === this.track && kinds.indexOf(track.kind) > -1) {\n        if (track.mode !== 'showing') {\n          track.mode = 'showing';\n        }\n      } else if (track.mode !== 'disabled') {\n        track.mode = 'disabled';\n      }\n    }\n  };\n\n  /**\n   * Handle text track list change\n   *\n   * @param {EventTarget~Event} event\n   *        The `change` event that caused this function to be called.\n   *\n   * @listens TextTrackList#change\n   */\n\n\n  TextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {\n    this.selected(this.track.mode === 'showing');\n  };\n\n  TextTrackMenuItem.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {\n    if (this.track.mode === 'showing') {\n      var selectedLanguage = this.player_.cache_.selectedLanguage;\n\n      // Don't replace the kind of track across the same language\n      if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {\n        return;\n      }\n\n      this.player_.cache_.selectedLanguage = {\n        enabled: true,\n        language: this.track.language,\n        kind: this.track.kind\n      };\n    }\n  };\n\n  TextTrackMenuItem.prototype.dispose = function dispose() {\n    // remove reference to track object on dispose\n    this.track = null;\n\n    _MenuItem.prototype.dispose.call(this);\n  };\n\n  return TextTrackMenuItem;\n}(MenuItem);\n\nComponent.registerComponent('TextTrackMenuItem', TextTrackMenuItem);\n\n/**\n * @file off-text-track-menu-item.js\n */\n/**\n * A special menu item for turning of a specific type of text track\n *\n * @extends TextTrackMenuItem\n */\n\nvar OffTextTrackMenuItem = function (_TextTrackMenuItem) {\n  inherits(OffTextTrackMenuItem, _TextTrackMenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function OffTextTrackMenuItem(player, options) {\n    classCallCheck(this, OffTextTrackMenuItem);\n\n    // Create pseudo track info\n    // Requires options['kind']\n    options.track = {\n      player: player,\n      kind: options.kind,\n      kinds: options.kinds,\n      'default': false,\n      mode: 'disabled'\n    };\n\n    if (!options.kinds) {\n      options.kinds = [options.kind];\n    }\n\n    if (options.label) {\n      options.track.label = options.label;\n    } else {\n      options.track.label = options.kinds.join(' and ') + ' off';\n    }\n\n    // MenuItem is selectable\n    options.selectable = true;\n\n    return possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));\n  }\n\n  /**\n   * Handle text track change\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run\n   */\n\n\n  OffTextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {\n    var tracks = this.player().textTracks();\n    var selected = true;\n\n    for (var i = 0, l = tracks.length; i < l; i++) {\n      var track = tracks[i];\n\n      if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === 'showing') {\n        selected = false;\n        break;\n      }\n    }\n\n    this.selected(selected);\n  };\n\n  OffTextTrackMenuItem.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {\n    var tracks = this.player().textTracks();\n    var allHidden = true;\n\n    for (var i = 0, l = tracks.length; i < l; i++) {\n      var track = tracks[i];\n\n      if (['captions', 'descriptions', 'subtitles'].indexOf(track.kind) > -1 && track.mode === 'showing') {\n        allHidden = false;\n        break;\n      }\n    }\n\n    if (allHidden) {\n      this.player_.cache_.selectedLanguage = {\n        enabled: false\n      };\n    }\n  };\n\n  return OffTextTrackMenuItem;\n}(TextTrackMenuItem);\n\nComponent.registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);\n\n/**\n * @file text-track-button.js\n */\n/**\n * The base class for buttons that toggle specific text track types (e.g. subtitles)\n *\n * @extends MenuButton\n */\n\nvar TextTrackButton = function (_TrackButton) {\n  inherits(TextTrackButton, _TrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n  function TextTrackButton(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, TextTrackButton);\n\n    options.tracks = player.textTracks();\n\n    return possibleConstructorReturn(this, _TrackButton.call(this, player, options));\n  }\n\n  /**\n   * Create a menu item for each text track\n   *\n   * @param {TextTrackMenuItem[]} [items=[]]\n   *        Existing array of items to use during creation\n   *\n   * @return {TextTrackMenuItem[]}\n   *         Array of menu items that were created\n   */\n\n\n  TextTrackButton.prototype.createItems = function createItems() {\n    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var TrackMenuItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TextTrackMenuItem;\n\n\n    // Label is an overide for the [track] off label\n    // USed to localise captions/subtitles\n    var label = void 0;\n\n    if (this.label_) {\n      label = this.label_ + ' off';\n    }\n    // Add an OFF menu item to turn all tracks off\n    items.push(new OffTextTrackMenuItem(this.player_, {\n      kinds: this.kinds_,\n      kind: this.kind_,\n      label: label\n    }));\n\n    this.hideThreshold_ += 1;\n\n    var tracks = this.player_.textTracks();\n\n    if (!Array.isArray(this.kinds_)) {\n      this.kinds_ = [this.kind_];\n    }\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n\n      // only add tracks that are of an appropriate kind and have a label\n      if (this.kinds_.indexOf(track.kind) > -1) {\n\n        var item = new TrackMenuItem(this.player_, {\n          track: track,\n          // MenuItem is selectable\n          selectable: true\n        });\n\n        item.addClass('vjs-' + track.kind + '-menu-item');\n        items.push(item);\n      }\n    }\n\n    return items;\n  };\n\n  return TextTrackButton;\n}(TrackButton);\n\nComponent.registerComponent('TextTrackButton', TextTrackButton);\n\n/**\n * @file chapters-track-menu-item.js\n */\n/**\n * The chapter track menu item\n *\n * @extends MenuItem\n */\n\nvar ChaptersTrackMenuItem = function (_MenuItem) {\n  inherits(ChaptersTrackMenuItem, _MenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function ChaptersTrackMenuItem(player, options) {\n    classCallCheck(this, ChaptersTrackMenuItem);\n\n    var track = options.track;\n    var cue = options.cue;\n    var currentTime = player.currentTime();\n\n    // Modify options for parent MenuItem class's init.\n    options.selectable = true;\n    options.label = cue.text;\n    options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;\n\n    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));\n\n    _this.track = track;\n    _this.cue = cue;\n    track.addEventListener('cuechange', bind(_this, _this.update));\n    return _this;\n  }\n\n  /**\n   * This gets called when an `ChaptersTrackMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  ChaptersTrackMenuItem.prototype.handleClick = function handleClick(event) {\n    _MenuItem.prototype.handleClick.call(this);\n    this.player_.currentTime(this.cue.startTime);\n    this.update(this.cue.startTime);\n  };\n\n  /**\n   * Update chapter menu item\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `cuechange` event that caused this function to run.\n   *\n   * @listens TextTrack#cuechange\n   */\n\n\n  ChaptersTrackMenuItem.prototype.update = function update(event) {\n    var cue = this.cue;\n    var currentTime = this.player_.currentTime();\n\n    // vjs.log(currentTime, cue.startTime);\n    this.selected(cue.startTime <= currentTime && currentTime < cue.endTime);\n  };\n\n  return ChaptersTrackMenuItem;\n}(MenuItem);\n\nComponent.registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);\n\n/**\n * @file chapters-button.js\n */\n/**\n * The button component for toggling and selecting chapters\n * Chapters act much differently than other text tracks\n * Cues are navigation vs. other tracks of alternative languages\n *\n * @extends TextTrackButton\n */\n\nvar ChaptersButton = function (_TextTrackButton) {\n  inherits(ChaptersButton, _TextTrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this function is ready.\n   */\n  function ChaptersButton(player, options, ready) {\n    classCallCheck(this, ChaptersButton);\n    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  ChaptersButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  ChaptersButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  /**\n   * Update the menu based on the current state of its items.\n   *\n   * @param {EventTarget~Event} [event]\n   *        An event that triggered this function to run.\n   *\n   * @listens TextTrackList#addtrack\n   * @listens TextTrackList#removetrack\n   * @listens TextTrackList#change\n   */\n\n\n  ChaptersButton.prototype.update = function update(event) {\n    if (!this.track_ || event && (event.type === 'addtrack' || event.type === 'removetrack')) {\n      this.setTrack(this.findChaptersTrack());\n    }\n    _TextTrackButton.prototype.update.call(this);\n  };\n\n  /**\n   * Set the currently selected track for the chapters button.\n   *\n   * @param {TextTrack} track\n   *        The new track to select. Nothing will change if this is the currently selected\n   *        track.\n   */\n\n\n  ChaptersButton.prototype.setTrack = function setTrack(track) {\n    if (this.track_ === track) {\n      return;\n    }\n\n    if (!this.updateHandler_) {\n      this.updateHandler_ = this.update.bind(this);\n    }\n\n    // here this.track_ refers to the old track instance\n    if (this.track_) {\n      var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);\n\n      if (remoteTextTrackEl) {\n        remoteTextTrackEl.removeEventListener('load', this.updateHandler_);\n      }\n\n      this.track_ = null;\n    }\n\n    this.track_ = track;\n\n    // here this.track_ refers to the new track instance\n    if (this.track_) {\n      this.track_.mode = 'hidden';\n\n      var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);\n\n      if (_remoteTextTrackEl) {\n        _remoteTextTrackEl.addEventListener('load', this.updateHandler_);\n      }\n    }\n  };\n\n  /**\n   * Find the track object that is currently in use by this ChaptersButton\n   *\n   * @return {TextTrack|undefined}\n   *         The current track or undefined if none was found.\n   */\n\n\n  ChaptersButton.prototype.findChaptersTrack = function findChaptersTrack() {\n    var tracks = this.player_.textTracks() || [];\n\n    for (var i = tracks.length - 1; i >= 0; i--) {\n      // We will always choose the last track as our chaptersTrack\n      var track = tracks[i];\n\n      if (track.kind === this.kind_) {\n        return track;\n      }\n    }\n  };\n\n  /**\n   * Get the caption for the ChaptersButton based on the track label. This will also\n   * use the current tracks localized kind as a fallback if a label does not exist.\n   *\n   * @return {string}\n   *         The tracks current label or the localized track kind.\n   */\n\n\n  ChaptersButton.prototype.getMenuCaption = function getMenuCaption() {\n    if (this.track_ && this.track_.label) {\n      return this.track_.label;\n    }\n    return this.localize(toTitleCase(this.kind_));\n  };\n\n  /**\n   * Create menu from chapter track\n   *\n   * @return {Menu}\n   *         New menu for the chapter buttons\n   */\n\n\n  ChaptersButton.prototype.createMenu = function createMenu() {\n    this.options_.title = this.getMenuCaption();\n    return _TextTrackButton.prototype.createMenu.call(this);\n  };\n\n  /**\n   * Create a menu item for each text track\n   *\n   * @return {TextTrackMenuItem[]}\n   *         Array of menu items\n   */\n\n\n  ChaptersButton.prototype.createItems = function createItems() {\n    var items = [];\n\n    if (!this.track_) {\n      return items;\n    }\n\n    var cues = this.track_.cues;\n\n    if (!cues) {\n      return items;\n    }\n\n    for (var i = 0, l = cues.length; i < l; i++) {\n      var cue = cues[i];\n      var mi = new ChaptersTrackMenuItem(this.player_, { track: this.track_, cue: cue });\n\n      items.push(mi);\n    }\n\n    return items;\n  };\n\n  return ChaptersButton;\n}(TextTrackButton);\n\n/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */\n\n\nChaptersButton.prototype.kind_ = 'chapters';\n\n/**\n * The text that should display over the `ChaptersButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\nChaptersButton.prototype.controlText_ = 'Chapters';\n\nComponent.registerComponent('ChaptersButton', ChaptersButton);\n\n/**\n * @file descriptions-button.js\n */\n/**\n * The button component for toggling and selecting descriptions\n *\n * @extends TextTrackButton\n */\n\nvar DescriptionsButton = function (_TextTrackButton) {\n  inherits(DescriptionsButton, _TextTrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */\n  function DescriptionsButton(player, options, ready) {\n    classCallCheck(this, DescriptionsButton);\n\n    var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));\n\n    var tracks = player.textTracks();\n    var changeHandler = bind(_this, _this.handleTracksChange);\n\n    tracks.addEventListener('change', changeHandler);\n    _this.on('dispose', function () {\n      tracks.removeEventListener('change', changeHandler);\n    });\n    return _this;\n  }\n\n  /**\n   * Handle text track change\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run\n   *\n   * @listens TextTrackList#change\n   */\n\n\n  DescriptionsButton.prototype.handleTracksChange = function handleTracksChange(event) {\n    var tracks = this.player().textTracks();\n    var disabled = false;\n\n    // Check whether a track of a different kind is showing\n    for (var i = 0, l = tracks.length; i < l; i++) {\n      var track = tracks[i];\n\n      if (track.kind !== this.kind_ && track.mode === 'showing') {\n        disabled = true;\n        break;\n      }\n    }\n\n    // If another track is showing, disable this menu button\n    if (disabled) {\n      this.disable();\n    } else {\n      this.enable();\n    }\n  };\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  DescriptionsButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  DescriptionsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  return DescriptionsButton;\n}(TextTrackButton);\n\n/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */\n\n\nDescriptionsButton.prototype.kind_ = 'descriptions';\n\n/**\n * The text that should display over the `DescriptionsButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\nDescriptionsButton.prototype.controlText_ = 'Descriptions';\n\nComponent.registerComponent('DescriptionsButton', DescriptionsButton);\n\n/**\n * @file subtitles-button.js\n */\n/**\n * The button component for toggling and selecting subtitles\n *\n * @extends TextTrackButton\n */\n\nvar SubtitlesButton = function (_TextTrackButton) {\n  inherits(SubtitlesButton, _TextTrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */\n  function SubtitlesButton(player, options, ready) {\n    classCallCheck(this, SubtitlesButton);\n    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  SubtitlesButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  SubtitlesButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  return SubtitlesButton;\n}(TextTrackButton);\n\n/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */\n\n\nSubtitlesButton.prototype.kind_ = 'subtitles';\n\n/**\n * The text that should display over the `SubtitlesButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\nSubtitlesButton.prototype.controlText_ = 'Subtitles';\n\nComponent.registerComponent('SubtitlesButton', SubtitlesButton);\n\n/**\n * @file caption-settings-menu-item.js\n */\n/**\n * The menu item for caption track settings menu\n *\n * @extends TextTrackMenuItem\n */\n\nvar CaptionSettingsMenuItem = function (_TextTrackMenuItem) {\n  inherits(CaptionSettingsMenuItem, _TextTrackMenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function CaptionSettingsMenuItem(player, options) {\n    classCallCheck(this, CaptionSettingsMenuItem);\n\n    options.track = {\n      player: player,\n      kind: options.kind,\n      label: options.kind + ' settings',\n      selectable: false,\n      'default': false,\n      mode: 'disabled'\n    };\n\n    // CaptionSettingsMenuItem has no concept of 'selected'\n    options.selectable = false;\n\n    options.name = 'CaptionSettingsMenuItem';\n\n    var _this = possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));\n\n    _this.addClass('vjs-texttrack-settings');\n    _this.controlText(', opens ' + options.kind + ' settings dialog');\n    return _this;\n  }\n\n  /**\n   * This gets called when an `CaptionSettingsMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  CaptionSettingsMenuItem.prototype.handleClick = function handleClick(event) {\n    this.player().getChild('textTrackSettings').open();\n  };\n\n  return CaptionSettingsMenuItem;\n}(TextTrackMenuItem);\n\nComponent.registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);\n\n/**\n * @file captions-button.js\n */\n/**\n * The button component for toggling and selecting captions\n *\n * @extends TextTrackButton\n */\n\nvar CaptionsButton = function (_TextTrackButton) {\n  inherits(CaptionsButton, _TextTrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */\n  function CaptionsButton(player, options, ready) {\n    classCallCheck(this, CaptionsButton);\n    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  CaptionsButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  CaptionsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  /**\n   * Create caption menu items\n   *\n   * @return {CaptionSettingsMenuItem[]}\n   *         The array of current menu items.\n   */\n\n\n  CaptionsButton.prototype.createItems = function createItems() {\n    var items = [];\n\n    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks)) {\n      items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.kind_ }));\n\n      this.hideThreshold_ += 1;\n    }\n\n    return _TextTrackButton.prototype.createItems.call(this, items);\n  };\n\n  return CaptionsButton;\n}(TextTrackButton);\n\n/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */\n\n\nCaptionsButton.prototype.kind_ = 'captions';\n\n/**\n * The text that should display over the `CaptionsButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\nCaptionsButton.prototype.controlText_ = 'Captions';\n\nComponent.registerComponent('CaptionsButton', CaptionsButton);\n\n/**\n * @file subs-caps-menu-item.js\n */\n/**\n * SubsCapsMenuItem has an [cc] icon to distinguish captions from subtitles\n * in the SubsCapsMenu.\n *\n * @extends TextTrackMenuItem\n */\n\nvar SubsCapsMenuItem = function (_TextTrackMenuItem) {\n  inherits(SubsCapsMenuItem, _TextTrackMenuItem);\n\n  function SubsCapsMenuItem() {\n    classCallCheck(this, SubsCapsMenuItem);\n    return possibleConstructorReturn(this, _TextTrackMenuItem.apply(this, arguments));\n  }\n\n  SubsCapsMenuItem.prototype.createEl = function createEl(type, props, attrs) {\n    var innerHTML = '<span class=\"vjs-menu-item-text\">' + this.localize(this.options_.label);\n\n    if (this.options_.track.kind === 'captions') {\n      innerHTML += '\\n        <span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>\\n        <span class=\"vjs-control-text\"> ' + this.localize('Captions') + '</span>\\n      ';\n    }\n\n    innerHTML += '</span>';\n\n    var el = _TextTrackMenuItem.prototype.createEl.call(this, type, assign({\n      innerHTML: innerHTML\n    }, props), attrs);\n\n    return el;\n  };\n\n  return SubsCapsMenuItem;\n}(TextTrackMenuItem);\n\nComponent.registerComponent('SubsCapsMenuItem', SubsCapsMenuItem);\n\n/**\n * @file sub-caps-button.js\n */\n/**\n * The button component for toggling and selecting captions and/or subtitles\n *\n * @extends TextTrackButton\n */\n\nvar SubsCapsButton = function (_TextTrackButton) {\n  inherits(SubsCapsButton, _TextTrackButton);\n\n  function SubsCapsButton(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, SubsCapsButton);\n\n    // Although North America uses \"captions\" in most cases for\n    // \"captions and subtitles\" other locales use \"subtitles\"\n    var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options));\n\n    _this.label_ = 'subtitles';\n    if (['en', 'en-us', 'en-ca', 'fr-ca'].indexOf(_this.player_.language_) > -1) {\n      _this.label_ = 'captions';\n    }\n    _this.menuButton_.controlText(toTitleCase(_this.label_));\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  SubsCapsButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-subs-caps-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  SubsCapsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-subs-caps-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  /**\n   * Create caption/subtitles menu items\n   *\n   * @return {CaptionSettingsMenuItem[]}\n   *         The array of current menu items.\n   */\n\n\n  SubsCapsButton.prototype.createItems = function createItems() {\n    var items = [];\n\n    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks)) {\n      items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.label_ }));\n\n      this.hideThreshold_ += 1;\n    }\n\n    items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);\n    return items;\n  };\n\n  return SubsCapsButton;\n}(TextTrackButton);\n\n/**\n * `kind`s of TextTrack to look for to associate it with this menu.\n *\n * @type {array}\n * @private\n */\n\n\nSubsCapsButton.prototype.kinds_ = ['captions', 'subtitles'];\n\n/**\n * The text that should display over the `SubsCapsButton`s controls.\n *\n *\n * @type {string}\n * @private\n */\nSubsCapsButton.prototype.controlText_ = 'Subtitles';\n\nComponent.registerComponent('SubsCapsButton', SubsCapsButton);\n\n/**\n * @file audio-track-menu-item.js\n */\n/**\n * An {@link AudioTrack} {@link MenuItem}\n *\n * @extends MenuItem\n */\n\nvar AudioTrackMenuItem = function (_MenuItem) {\n  inherits(AudioTrackMenuItem, _MenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function AudioTrackMenuItem(player, options) {\n    classCallCheck(this, AudioTrackMenuItem);\n\n    var track = options.track;\n    var tracks = player.audioTracks();\n\n    // Modify options for parent MenuItem class's init.\n    options.label = track.label || track.language || 'Unknown';\n    options.selected = track.enabled;\n\n    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));\n\n    _this.track = track;\n\n    var changeHandler = function changeHandler() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this.handleTracksChange.apply(_this, args);\n    };\n\n    tracks.addEventListener('change', changeHandler);\n    _this.on('dispose', function () {\n      tracks.removeEventListener('change', changeHandler);\n    });\n    return _this;\n  }\n\n  /**\n   * This gets called when an `AudioTrackMenuItem is \"clicked\". See {@link ClickableComponent}\n   * for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  AudioTrackMenuItem.prototype.handleClick = function handleClick(event) {\n    var tracks = this.player_.audioTracks();\n\n    _MenuItem.prototype.handleClick.call(this, event);\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n\n      track.enabled = track === this.track;\n    }\n  };\n\n  /**\n   * Handle any {@link AudioTrack} change.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link AudioTrackList#change} event that caused this to run.\n   *\n   * @listens AudioTrackList#change\n   */\n\n\n  AudioTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {\n    this.selected(this.track.enabled);\n  };\n\n  return AudioTrackMenuItem;\n}(MenuItem);\n\nComponent.registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);\n\n/**\n * @file audio-track-button.js\n */\n/**\n * The base class for buttons that toggle specific {@link AudioTrack} types.\n *\n * @extends TrackButton\n */\n\nvar AudioTrackButton = function (_TrackButton) {\n  inherits(AudioTrackButton, _TrackButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */\n  function AudioTrackButton(player) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, AudioTrackButton);\n\n    options.tracks = player.audioTracks();\n\n    return possibleConstructorReturn(this, _TrackButton.call(this, player, options));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  AudioTrackButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-audio-button ' + _TrackButton.prototype.buildCSSClass.call(this);\n  };\n\n  AudioTrackButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-audio-button ' + _TrackButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  /**\n   * Create a menu item for each audio track\n   *\n   * @param {AudioTrackMenuItem[]} [items=[]]\n   *        An array of existing menu items to use.\n   *\n   * @return {AudioTrackMenuItem[]}\n   *         An array of menu items\n   */\n\n\n  AudioTrackButton.prototype.createItems = function createItems() {\n    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    // if there's only one audio track, there no point in showing it\n    this.hideThreshold_ = 1;\n\n    var tracks = this.player_.audioTracks();\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n\n      items.push(new AudioTrackMenuItem(this.player_, {\n        track: track,\n        // MenuItem is selectable\n        selectable: true\n      }));\n    }\n\n    return items;\n  };\n\n  return AudioTrackButton;\n}(TrackButton);\n\n/**\n * The text that should display over the `AudioTrackButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nAudioTrackButton.prototype.controlText_ = 'Audio Track';\nComponent.registerComponent('AudioTrackButton', AudioTrackButton);\n\n/**\n * @file playback-rate-menu-item.js\n */\n/**\n * The specific menu item type for selecting a playback rate.\n *\n * @extends MenuItem\n */\n\nvar PlaybackRateMenuItem = function (_MenuItem) {\n  inherits(PlaybackRateMenuItem, _MenuItem);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function PlaybackRateMenuItem(player, options) {\n    classCallCheck(this, PlaybackRateMenuItem);\n\n    var label = options.rate;\n    var rate = parseFloat(label, 10);\n\n    // Modify options for parent MenuItem class's init.\n    options.label = label;\n    options.selected = rate === 1;\n    options.selectable = true;\n\n    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));\n\n    _this.label = label;\n    _this.rate = rate;\n\n    _this.on(player, 'ratechange', _this.update);\n    return _this;\n  }\n\n  /**\n   * This gets called when an `PlaybackRateMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  PlaybackRateMenuItem.prototype.handleClick = function handleClick(event) {\n    _MenuItem.prototype.handleClick.call(this);\n    this.player().playbackRate(this.rate);\n  };\n\n  /**\n   * Update the PlaybackRateMenuItem when the playbackrate changes.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `ratechange` event that caused this function to run.\n   *\n   * @listens Player#ratechange\n   */\n\n\n  PlaybackRateMenuItem.prototype.update = function update(event) {\n    this.selected(this.player().playbackRate() === this.rate);\n  };\n\n  return PlaybackRateMenuItem;\n}(MenuItem);\n\n/**\n * The text that should display over the `PlaybackRateMenuItem`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nPlaybackRateMenuItem.prototype.contentElType = 'button';\n\nComponent.registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);\n\n/**\n * @file playback-rate-menu-button.js\n */\n/**\n * The component for controlling the playback rate.\n *\n * @extends MenuButton\n */\n\nvar PlaybackRateMenuButton = function (_MenuButton) {\n  inherits(PlaybackRateMenuButton, _MenuButton);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */\n  function PlaybackRateMenuButton(player, options) {\n    classCallCheck(this, PlaybackRateMenuButton);\n\n    var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));\n\n    _this.updateVisibility();\n    _this.updateLabel();\n\n    _this.on(player, 'loadstart', _this.updateVisibility);\n    _this.on(player, 'ratechange', _this.updateLabel);\n    return _this;\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  PlaybackRateMenuButton.prototype.createEl = function createEl$$1() {\n    var el = _MenuButton.prototype.createEl.call(this);\n\n    this.labelEl_ = createEl('div', {\n      className: 'vjs-playback-rate-value',\n      innerHTML: '1x'\n    });\n\n    el.appendChild(this.labelEl_);\n\n    return el;\n  };\n\n  PlaybackRateMenuButton.prototype.dispose = function dispose() {\n    this.labelEl_ = null;\n\n    _MenuButton.prototype.dispose.call(this);\n  };\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n\n\n  PlaybackRateMenuButton.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-playback-rate ' + _MenuButton.prototype.buildCSSClass.call(this);\n  };\n\n  PlaybackRateMenuButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {\n    return 'vjs-playback-rate ' + _MenuButton.prototype.buildWrapperCSSClass.call(this);\n  };\n\n  /**\n   * Create the playback rate menu\n   *\n   * @return {Menu}\n   *         Menu object populated with {@link PlaybackRateMenuItem}s\n   */\n\n\n  PlaybackRateMenuButton.prototype.createMenu = function createMenu() {\n    var menu = new Menu(this.player());\n    var rates = this.playbackRates();\n\n    if (rates) {\n      for (var i = rates.length - 1; i >= 0; i--) {\n        menu.addChild(new PlaybackRateMenuItem(this.player(), { rate: rates[i] + 'x' }));\n      }\n    }\n\n    return menu;\n  };\n\n  /**\n   * Updates ARIA accessibility attributes\n   */\n\n\n  PlaybackRateMenuButton.prototype.updateARIAAttributes = function updateARIAAttributes() {\n    // Current playback rate\n    this.el().setAttribute('aria-valuenow', this.player().playbackRate());\n  };\n\n  /**\n   * This gets called when an `PlaybackRateMenuButton` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */\n\n\n  PlaybackRateMenuButton.prototype.handleClick = function handleClick(event) {\n    // select next rate option\n    var currentRate = this.player().playbackRate();\n    var rates = this.playbackRates();\n\n    // this will select first one if the last one currently selected\n    var newRate = rates[0];\n\n    for (var i = 0; i < rates.length; i++) {\n      if (rates[i] > currentRate) {\n        newRate = rates[i];\n        break;\n      }\n    }\n    this.player().playbackRate(newRate);\n  };\n\n  /**\n   * Get possible playback rates\n   *\n   * @return {Array}\n   *         All possible playback rates\n   */\n\n\n  PlaybackRateMenuButton.prototype.playbackRates = function playbackRates() {\n    return this.options_.playbackRates || this.options_.playerOptions && this.options_.playerOptions.playbackRates;\n  };\n\n  /**\n   * Get whether playback rates is supported by the tech\n   * and an array of playback rates exists\n   *\n   * @return {boolean}\n   *         Whether changing playback rate is supported\n   */\n\n\n  PlaybackRateMenuButton.prototype.playbackRateSupported = function playbackRateSupported() {\n    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;\n  };\n\n  /**\n   * Hide playback rate controls when they're no playback rate options to select\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#loadstart\n   */\n\n\n  PlaybackRateMenuButton.prototype.updateVisibility = function updateVisibility(event) {\n    if (this.playbackRateSupported()) {\n      this.removeClass('vjs-hidden');\n    } else {\n      this.addClass('vjs-hidden');\n    }\n  };\n\n  /**\n   * Update button label when rate changed\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#ratechange\n   */\n\n\n  PlaybackRateMenuButton.prototype.updateLabel = function updateLabel(event) {\n    if (this.playbackRateSupported()) {\n      this.labelEl_.innerHTML = this.player().playbackRate() + 'x';\n    }\n  };\n\n  return PlaybackRateMenuButton;\n}(MenuButton);\n\n/**\n * The text that should display over the `FullscreenToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */\n\n\nPlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';\n\nComponent.registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);\n\n/**\n * @file spacer.js\n */\n/**\n * Just an empty spacer element that can be used as an append point for plugins, etc.\n * Also can be used to create space between elements when necessary.\n *\n * @extends Component\n */\n\nvar Spacer = function (_Component) {\n  inherits(Spacer, _Component);\n\n  function Spacer() {\n    classCallCheck(this, Spacer);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n  Spacer.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-spacer ' + _Component.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  Spacer.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: this.buildCSSClass()\n    });\n  };\n\n  return Spacer;\n}(Component);\n\nComponent.registerComponent('Spacer', Spacer);\n\n/**\n * @file custom-control-spacer.js\n */\n/**\n * Spacer specifically meant to be used as an insertion point for new plugins, etc.\n *\n * @extends Spacer\n */\n\nvar CustomControlSpacer = function (_Spacer) {\n  inherits(CustomControlSpacer, _Spacer);\n\n  function CustomControlSpacer() {\n    classCallCheck(this, CustomControlSpacer);\n    return possibleConstructorReturn(this, _Spacer.apply(this, arguments));\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */\n  CustomControlSpacer.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-custom-control-spacer ' + _Spacer.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n\n\n  CustomControlSpacer.prototype.createEl = function createEl() {\n    var el = _Spacer.prototype.createEl.call(this, {\n      className: this.buildCSSClass()\n    });\n\n    // No-flex/table-cell mode requires there be some content\n    // in the cell to fill the remaining space of the table.\n    el.innerHTML = '\\xA0';\n    return el;\n  };\n\n  return CustomControlSpacer;\n}(Spacer);\n\nComponent.registerComponent('CustomControlSpacer', CustomControlSpacer);\n\n/**\n * @file control-bar.js\n */\n// Required children\n/**\n * Container of main controls.\n *\n * @extends Component\n */\n\nvar ControlBar = function (_Component) {\n  inherits(ControlBar, _Component);\n\n  function ControlBar() {\n    classCallCheck(this, ControlBar);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  /**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */\n  ControlBar.prototype.createEl = function createEl() {\n    return _Component.prototype.createEl.call(this, 'div', {\n      className: 'vjs-control-bar',\n      dir: 'ltr'\n    }, {\n      // The control bar is a group, but we don't aria-label it to avoid\n      //  over-announcing by JAWS\n      role: 'group'\n    });\n  };\n\n  return ControlBar;\n}(Component);\n\n/**\n * Default options for `ControlBar`\n *\n * @type {Object}\n * @private\n */\n\n\nControlBar.prototype.options_ = {\n  children: ['playToggle', 'volumePanel', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subsCapsButton', 'audioTrackButton', 'fullscreenToggle']\n};\n\nComponent.registerComponent('ControlBar', ControlBar);\n\n/**\n * @file error-display.js\n */\n/**\n * A display that indicates an error has occurred. This means that the video\n * is unplayable.\n *\n * @extends ModalDialog\n */\n\nvar ErrorDisplay = function (_ModalDialog) {\n  inherits(ErrorDisplay, _ModalDialog);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */\n  function ErrorDisplay(player, options) {\n    classCallCheck(this, ErrorDisplay);\n\n    var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));\n\n    _this.on(player, 'error', _this.open);\n    return _this;\n  }\n\n  /**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   *\n   * @deprecated Since version 5.\n   */\n\n\n  ErrorDisplay.prototype.buildCSSClass = function buildCSSClass() {\n    return 'vjs-error-display ' + _ModalDialog.prototype.buildCSSClass.call(this);\n  };\n\n  /**\n   * Gets the localized error message based on the `Player`s error.\n   *\n   * @return {string}\n   *         The `Player`s error message localized or an empty string.\n   */\n\n\n  ErrorDisplay.prototype.content = function content() {\n    var error = this.player().error();\n\n    return error ? this.localize(error.message) : '';\n  };\n\n  return ErrorDisplay;\n}(ModalDialog);\n\n/**\n * The default options for an `ErrorDisplay`.\n *\n * @private\n */\n\n\nErrorDisplay.prototype.options_ = mergeOptions(ModalDialog.prototype.options_, {\n  pauseOnOpen: false,\n  fillAlways: true,\n  temporary: false,\n  uncloseable: true\n});\n\nComponent.registerComponent('ErrorDisplay', ErrorDisplay);\n\n/**\n * @file text-track-settings.js\n */\nvar LOCAL_STORAGE_KEY = 'vjs-text-track-settings';\n\nvar COLOR_BLACK = ['#000', 'Black'];\nvar COLOR_BLUE = ['#00F', 'Blue'];\nvar COLOR_CYAN = ['#0FF', 'Cyan'];\nvar COLOR_GREEN = ['#0F0', 'Green'];\nvar COLOR_MAGENTA = ['#F0F', 'Magenta'];\nvar COLOR_RED = ['#F00', 'Red'];\nvar COLOR_WHITE = ['#FFF', 'White'];\nvar COLOR_YELLOW = ['#FF0', 'Yellow'];\n\nvar OPACITY_OPAQUE = ['1', 'Opaque'];\nvar OPACITY_SEMI = ['0.5', 'Semi-Transparent'];\nvar OPACITY_TRANS = ['0', 'Transparent'];\n\n// Configuration for the various <select> elements in the DOM of this component.\n//\n// Possible keys include:\n//\n// `default`:\n//   The default option index. Only needs to be provided if not zero.\n// `parser`:\n//   A function which is used to parse the value from the selected option in\n//   a customized way.\n// `selector`:\n//   The selector used to find the associated <select> element.\nvar selectConfigs = {\n  backgroundColor: {\n    selector: '.vjs-bg-color > select',\n    id: 'captions-background-color-%s',\n    label: 'Color',\n    options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]\n  },\n\n  backgroundOpacity: {\n    selector: '.vjs-bg-opacity > select',\n    id: 'captions-background-opacity-%s',\n    label: 'Transparency',\n    options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]\n  },\n\n  color: {\n    selector: '.vjs-fg-color > select',\n    id: 'captions-foreground-color-%s',\n    label: 'Color',\n    options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]\n  },\n\n  edgeStyle: {\n    selector: '.vjs-edge-style > select',\n    id: '%s',\n    label: 'Text Edge Style',\n    options: [['none', 'None'], ['raised', 'Raised'], ['depressed', 'Depressed'], ['uniform', 'Uniform'], ['dropshadow', 'Dropshadow']]\n  },\n\n  fontFamily: {\n    selector: '.vjs-font-family > select',\n    id: 'captions-font-family-%s',\n    label: 'Font Family',\n    options: [['proportionalSansSerif', 'Proportional Sans-Serif'], ['monospaceSansSerif', 'Monospace Sans-Serif'], ['proportionalSerif', 'Proportional Serif'], ['monospaceSerif', 'Monospace Serif'], ['casual', 'Casual'], ['script', 'Script'], ['small-caps', 'Small Caps']]\n  },\n\n  fontPercent: {\n    selector: '.vjs-font-percent > select',\n    id: 'captions-font-size-%s',\n    label: 'Font Size',\n    options: [['0.50', '50%'], ['0.75', '75%'], ['1.00', '100%'], ['1.25', '125%'], ['1.50', '150%'], ['1.75', '175%'], ['2.00', '200%'], ['3.00', '300%'], ['4.00', '400%']],\n    'default': 2,\n    parser: function parser(v) {\n      return v === '1.00' ? null : Number(v);\n    }\n  },\n\n  textOpacity: {\n    selector: '.vjs-text-opacity > select',\n    id: 'captions-foreground-opacity-%s',\n    label: 'Transparency',\n    options: [OPACITY_OPAQUE, OPACITY_SEMI]\n  },\n\n  // Options for this object are defined below.\n  windowColor: {\n    selector: '.vjs-window-color > select',\n    id: 'captions-window-color-%s',\n    label: 'Color'\n  },\n\n  // Options for this object are defined below.\n  windowOpacity: {\n    selector: '.vjs-window-opacity > select',\n    id: 'captions-window-opacity-%s',\n    label: 'Transparency',\n    options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]\n  }\n};\n\nselectConfigs.windowColor.options = selectConfigs.backgroundColor.options;\n\n/**\n * Get the actual value of an option.\n *\n * @param  {string} value\n *         The value to get\n *\n * @param  {Function} [parser]\n *         Optional function to adjust the value.\n *\n * @return {Mixed}\n *         - Will be `undefined` if no value exists\n *         - Will be `undefined` if the given value is \"none\".\n *         - Will be the actual value otherwise.\n *\n * @private\n */\nfunction parseOptionValue(value, parser) {\n  if (parser) {\n    value = parser(value);\n  }\n\n  if (value && value !== 'none') {\n    return value;\n  }\n}\n\n/**\n * Gets the value of the selected <option> element within a <select> element.\n *\n * @param  {Element} el\n *         the element to look in\n *\n * @param  {Function} [parser]\n *         Optional function to adjust the value.\n *\n * @return {Mixed}\n *         - Will be `undefined` if no value exists\n *         - Will be `undefined` if the given value is \"none\".\n *         - Will be the actual value otherwise.\n *\n * @private\n */\nfunction getSelectedOptionValue(el, parser) {\n  var value = el.options[el.options.selectedIndex].value;\n\n  return parseOptionValue(value, parser);\n}\n\n/**\n * Sets the selected <option> element within a <select> element based on a\n * given value.\n *\n * @param {Element} el\n *        The element to look in.\n *\n * @param {string} value\n *        the property to look on.\n *\n * @param {Function} [parser]\n *        Optional function to adjust the value before comparing.\n *\n * @private\n */\nfunction setSelectedOption(el, value, parser) {\n  if (!value) {\n    return;\n  }\n\n  for (var i = 0; i < el.options.length; i++) {\n    if (parseOptionValue(el.options[i].value, parser) === value) {\n      el.selectedIndex = i;\n      break;\n    }\n  }\n}\n\n/**\n * Manipulate Text Tracks settings.\n *\n * @extends ModalDialog\n */\n\nvar TextTrackSettings = function (_ModalDialog) {\n  inherits(TextTrackSettings, _ModalDialog);\n\n  /**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *         The key/value store of player options.\n   */\n  function TextTrackSettings(player, options) {\n    classCallCheck(this, TextTrackSettings);\n\n    options.temporary = false;\n\n    var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));\n\n    _this.updateDisplay = bind(_this, _this.updateDisplay);\n\n    // fill the modal and pretend we have opened it\n    _this.fill();\n    _this.hasBeenOpened_ = _this.hasBeenFilled_ = true;\n\n    _this.endDialog = createEl('p', {\n      className: 'vjs-control-text',\n      textContent: _this.localize('End of dialog window.')\n    });\n    _this.el().appendChild(_this.endDialog);\n\n    _this.setDefaults();\n\n    // Grab `persistTextTrackSettings` from the player options if not passed in child options\n    if (options.persistTextTrackSettings === undefined) {\n      _this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings;\n    }\n\n    _this.on(_this.$('.vjs-done-button'), 'click', function () {\n      _this.saveSettings();\n      _this.close();\n    });\n\n    _this.on(_this.$('.vjs-default-button'), 'click', function () {\n      _this.setDefaults();\n      _this.updateDisplay();\n    });\n\n    each(selectConfigs, function (config) {\n      _this.on(_this.$(config.selector), 'change', _this.updateDisplay);\n    });\n\n    if (_this.options_.persistTextTrackSettings) {\n      _this.restoreSettings();\n    }\n    return _this;\n  }\n\n  TextTrackSettings.prototype.dispose = function dispose() {\n    this.endDialog = null;\n\n    _ModalDialog.prototype.dispose.call(this);\n  };\n\n  /**\n   * Create a <select> element with configured options.\n   *\n   * @param {string} key\n   *        Configuration key to use during creation.\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElSelect_ = function createElSelect_(key) {\n    var _this2 = this;\n\n    var legendId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'label';\n\n    var config = selectConfigs[key];\n    var id = config.id.replace('%s', this.id_);\n\n    return ['<' + type + ' id=\"' + id + '\" class=\"' + (type === 'label' ? 'vjs-label' : '') + '\">', this.localize(config.label), '</' + type + '>', '<select aria-labelledby=\"' + (legendId !== '' ? legendId + ' ' : '') + id + '\">'].concat(config.options.map(function (o) {\n      var optionId = id + '-' + o[1];\n\n      return ['<option id=\"' + optionId + '\" value=\"' + o[0] + '\" ', 'aria-labelledby=\"' + (legendId !== '' ? legendId + ' ' : '') + id + ' ' + optionId + '\">', _this2.localize(o[1]), '</option>'].join('');\n    })).concat('</select>').join('');\n  };\n\n  /**\n   * Create foreground color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElFgColor_ = function createElFgColor_() {\n    var legendId = 'captions-text-legend-' + this.id_;\n\n    return ['<fieldset class=\"vjs-fg-color vjs-track-setting\">', '<legend id=\"' + legendId + '\">', this.localize('Text'), '</legend>', this.createElSelect_('color', legendId), '<span class=\"vjs-text-opacity vjs-opacity\">', this.createElSelect_('textOpacity', legendId), '</span>', '</fieldset>'].join('');\n  };\n\n  /**\n   * Create background color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElBgColor_ = function createElBgColor_() {\n    var legendId = 'captions-background-' + this.id_;\n\n    return ['<fieldset class=\"vjs-bg-color vjs-track-setting\">', '<legend id=\"' + legendId + '\">', this.localize('Background'), '</legend>', this.createElSelect_('backgroundColor', legendId), '<span class=\"vjs-bg-opacity vjs-opacity\">', this.createElSelect_('backgroundOpacity', legendId), '</span>', '</fieldset>'].join('');\n  };\n\n  /**\n   * Create window color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElWinColor_ = function createElWinColor_() {\n    var legendId = 'captions-window-' + this.id_;\n\n    return ['<fieldset class=\"vjs-window-color vjs-track-setting\">', '<legend id=\"' + legendId + '\">', this.localize('Window'), '</legend>', this.createElSelect_('windowColor', legendId), '<span class=\"vjs-window-opacity vjs-opacity\">', this.createElSelect_('windowOpacity', legendId), '</span>', '</fieldset>'].join('');\n  };\n\n  /**\n   * Create color elements for the component\n   *\n   * @return {Element}\n   *         The element that was created\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElColors_ = function createElColors_() {\n    return createEl('div', {\n      className: 'vjs-track-settings-colors',\n      innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join('')\n    });\n  };\n\n  /**\n   * Create font elements for the component\n   *\n   * @return {Element}\n   *         The element that was created.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElFont_ = function createElFont_() {\n    return createEl('div', {\n      className: 'vjs-track-settings-font\">',\n      innerHTML: ['<fieldset class=\"vjs-font-percent vjs-track-setting\">', this.createElSelect_('fontPercent', '', 'legend'), '</fieldset>', '<fieldset class=\"vjs-edge-style vjs-track-setting\">', this.createElSelect_('edgeStyle', '', 'legend'), '</fieldset>', '<fieldset class=\"vjs-font-family vjs-track-setting\">', this.createElSelect_('fontFamily', '', 'legend'), '</fieldset>'].join('')\n    });\n  };\n\n  /**\n   * Create controls for the component\n   *\n   * @return {Element}\n   *         The element that was created.\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.createElControls_ = function createElControls_() {\n    var defaultsDescription = this.localize('restore all settings to the default values');\n\n    return createEl('div', {\n      className: 'vjs-track-settings-controls',\n      innerHTML: ['<button class=\"vjs-default-button\" title=\"' + defaultsDescription + '\">', this.localize('Reset'), '<span class=\"vjs-control-text\"> ' + defaultsDescription + '</span>', '</button>', '<button class=\"vjs-done-button\">' + this.localize('Done') + '</button>'].join('')\n    });\n  };\n\n  TextTrackSettings.prototype.content = function content() {\n    return [this.createElColors_(), this.createElFont_(), this.createElControls_()];\n  };\n\n  TextTrackSettings.prototype.label = function label() {\n    return this.localize('Caption Settings Dialog');\n  };\n\n  TextTrackSettings.prototype.description = function description() {\n    return this.localize('Beginning of dialog window. Escape will cancel and close the window.');\n  };\n\n  TextTrackSettings.prototype.buildCSSClass = function buildCSSClass() {\n    return _ModalDialog.prototype.buildCSSClass.call(this) + ' vjs-text-track-settings';\n  };\n\n  /**\n   * Gets an object of text track settings (or null).\n   *\n   * @return {Object}\n   *         An object with config values parsed from the DOM or localStorage.\n   */\n\n\n  TextTrackSettings.prototype.getValues = function getValues() {\n    var _this3 = this;\n\n    return reduce(selectConfigs, function (accum, config, key) {\n      var value = getSelectedOptionValue(_this3.$(config.selector), config.parser);\n\n      if (value !== undefined) {\n        accum[key] = value;\n      }\n\n      return accum;\n    }, {});\n  };\n\n  /**\n   * Sets text track settings from an object of values.\n   *\n   * @param {Object} values\n   *        An object with config values parsed from the DOM or localStorage.\n   */\n\n\n  TextTrackSettings.prototype.setValues = function setValues(values) {\n    var _this4 = this;\n\n    each(selectConfigs, function (config, key) {\n      setSelectedOption(_this4.$(config.selector), values[key], config.parser);\n    });\n  };\n\n  /**\n   * Sets all `<select>` elements to their default values.\n   */\n\n\n  TextTrackSettings.prototype.setDefaults = function setDefaults() {\n    var _this5 = this;\n\n    each(selectConfigs, function (config) {\n      var index = config.hasOwnProperty('default') ? config['default'] : 0;\n\n      _this5.$(config.selector).selectedIndex = index;\n    });\n  };\n\n  /**\n   * Restore texttrack settings from localStorage\n   */\n\n\n  TextTrackSettings.prototype.restoreSettings = function restoreSettings() {\n    var values = void 0;\n\n    try {\n      values = JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY));\n    } catch (err) {\n      log$1.warn(err);\n    }\n\n    if (values) {\n      this.setValues(values);\n    }\n  };\n\n  /**\n   * Save text track settings to localStorage\n   */\n\n\n  TextTrackSettings.prototype.saveSettings = function saveSettings() {\n    if (!this.options_.persistTextTrackSettings) {\n      return;\n    }\n\n    var values = this.getValues();\n\n    try {\n      if (Object.keys(values).length) {\n        window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(values));\n      } else {\n        window.localStorage.removeItem(LOCAL_STORAGE_KEY);\n      }\n    } catch (err) {\n      log$1.warn(err);\n    }\n  };\n\n  /**\n   * Update display of text track settings\n   */\n\n\n  TextTrackSettings.prototype.updateDisplay = function updateDisplay() {\n    var ttDisplay = this.player_.getChild('textTrackDisplay');\n\n    if (ttDisplay) {\n      ttDisplay.updateDisplay();\n    }\n  };\n\n  /**\n   * conditionally blur the element and refocus the captions button\n   *\n   * @private\n   */\n\n\n  TextTrackSettings.prototype.conditionalBlur_ = function conditionalBlur_() {\n    this.previouslyActiveEl_ = null;\n    this.off(document, 'keydown', this.handleKeyDown);\n\n    var cb = this.player_.controlBar;\n    var subsCapsBtn = cb && cb.subsCapsButton;\n    var ccBtn = cb && cb.captionsButton;\n\n    if (subsCapsBtn) {\n      subsCapsBtn.focus();\n    } else if (ccBtn) {\n      ccBtn.focus();\n    }\n  };\n\n  return TextTrackSettings;\n}(ModalDialog);\n\nComponent.registerComponent('TextTrackSettings', TextTrackSettings);\n\nvar _templateObject$2 = taggedTemplateLiteralLoose(['Text Tracks are being loaded from another origin but the crossorigin attribute isn\\'t used.\\n            This may prevent text tracks from loading.'], ['Text Tracks are being loaded from another origin but the crossorigin attribute isn\\'t used.\\n            This may prevent text tracks from loading.']);\n\n/**\n * @file html5.js\n */\n/**\n * HTML5 Media Controller - Wrapper for HTML5 Media API\n *\n * @mixes Tech~SouceHandlerAdditions\n * @extends Tech\n */\n\nvar Html5 = function (_Tech) {\n  inherits(Html5, _Tech);\n\n  /**\n   * Create an instance of this Tech.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} ready\n   *        Callback function to call when the `HTML5` Tech is ready.\n   */\n  function Html5(options, ready) {\n    classCallCheck(this, Html5);\n\n    var _this = possibleConstructorReturn(this, _Tech.call(this, options, ready));\n\n    var source = options.source;\n    var crossoriginTracks = false;\n\n    // Set the source if one is provided\n    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)\n    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source\n    // anyway so the error gets fired.\n    if (source && (_this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {\n      _this.setSource(source);\n    } else {\n      _this.handleLateInit_(_this.el_);\n    }\n\n    if (_this.el_.hasChildNodes()) {\n\n      var nodes = _this.el_.childNodes;\n      var nodesLength = nodes.length;\n      var removeNodes = [];\n\n      while (nodesLength--) {\n        var node = nodes[nodesLength];\n        var nodeName = node.nodeName.toLowerCase();\n\n        if (nodeName === 'track') {\n          if (!_this.featuresNativeTextTracks) {\n            // Empty video tag tracks so the built-in player doesn't use them also.\n            // This may not be fast enough to stop HTML5 browsers from reading the tags\n            // so we'll need to turn off any default tracks if we're manually doing\n            // captions and subtitles. videoElement.textTracks\n            removeNodes.push(node);\n          } else {\n            // store HTMLTrackElement and TextTrack to remote list\n            _this.remoteTextTrackEls().addTrackElement_(node);\n            _this.remoteTextTracks().addTrack(node.track);\n            _this.textTracks().addTrack(node.track);\n            if (!crossoriginTracks && !_this.el_.hasAttribute('crossorigin') && isCrossOrigin(node.src)) {\n              crossoriginTracks = true;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < removeNodes.length; i++) {\n        _this.el_.removeChild(removeNodes[i]);\n      }\n    }\n\n    _this.proxyNativeTracks_();\n    if (_this.featuresNativeTextTracks && crossoriginTracks) {\n      log$1.warn(tsml(_templateObject$2));\n    }\n\n    // prevent iOS Safari from disabling metadata text tracks during native playback\n    _this.restoreMetadataTracksInIOSNativePlayer_();\n\n    // Determine if native controls should be used\n    // Our goal should be to get the custom controls on mobile solid everywhere\n    // so we can remove this all together. Right now this will block custom\n    // controls on touch enabled laptops like the Chrome Pixel\n    if ((TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {\n      _this.setControls(true);\n    }\n\n    // on iOS, we want to proxy `webkitbeginfullscreen` and `webkitendfullscreen`\n    // into a `fullscreenchange` event\n    _this.proxyWebkitFullscreen_();\n\n    _this.triggerReady();\n    return _this;\n  }\n\n  /**\n   * Dispose of `HTML5` media element and remove all tracks.\n   */\n\n\n  Html5.prototype.dispose = function dispose() {\n    Html5.disposeMediaElement(this.el_);\n    this.options_ = null;\n\n    // tech will handle clearing of the emulated track list\n    _Tech.prototype.dispose.call(this);\n  };\n\n  /**\n   * When a captions track is enabled in the iOS Safari native player, all other\n   * tracks are disabled (including metadata tracks), which nulls all of their\n   * associated cue points. This will restore metadata tracks to their pre-fullscreen\n   * state in those cases so that cue points are not needlessly lost.\n   *\n   * @private\n   */\n\n\n  Html5.prototype.restoreMetadataTracksInIOSNativePlayer_ = function restoreMetadataTracksInIOSNativePlayer_() {\n    var textTracks = this.textTracks();\n    var metadataTracksPreFullscreenState = void 0;\n\n    // captures a snapshot of every metadata track's current state\n    var takeMetadataTrackSnapshot = function takeMetadataTrackSnapshot() {\n      metadataTracksPreFullscreenState = [];\n\n      for (var i = 0; i < textTracks.length; i++) {\n        var track = textTracks[i];\n\n        if (track.kind === 'metadata') {\n          metadataTracksPreFullscreenState.push({\n            track: track,\n            storedMode: track.mode\n          });\n        }\n      }\n    };\n\n    // snapshot each metadata track's initial state, and update the snapshot\n    // each time there is a track 'change' event\n    takeMetadataTrackSnapshot();\n    textTracks.addEventListener('change', takeMetadataTrackSnapshot);\n\n    this.on('dispose', function () {\n      return textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n    });\n\n    var restoreTrackMode = function restoreTrackMode() {\n      for (var i = 0; i < metadataTracksPreFullscreenState.length; i++) {\n        var storedTrack = metadataTracksPreFullscreenState[i];\n\n        if (storedTrack.track.mode === 'disabled' && storedTrack.track.mode !== storedTrack.storedMode) {\n          storedTrack.track.mode = storedTrack.storedMode;\n        }\n      }\n      // we only want this handler to be executed on the first 'change' event\n      textTracks.removeEventListener('change', restoreTrackMode);\n    };\n\n    // when we enter fullscreen playback, stop updating the snapshot and\n    // restore all track modes to their pre-fullscreen state\n    this.on('webkitbeginfullscreen', function () {\n      textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n\n      // remove the listener before adding it just in case it wasn't previously removed\n      textTracks.removeEventListener('change', restoreTrackMode);\n      textTracks.addEventListener('change', restoreTrackMode);\n    });\n\n    // start updating the snapshot again after leaving fullscreen\n    this.on('webkitendfullscreen', function () {\n      // remove the listener before adding it just in case it wasn't previously removed\n      textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n      textTracks.addEventListener('change', takeMetadataTrackSnapshot);\n\n      // remove the restoreTrackMode handler in case it wasn't triggered during fullscreen playback\n      textTracks.removeEventListener('change', restoreTrackMode);\n    });\n  };\n\n  /**\n   * Proxy all native track list events to our track lists if the browser we are playing\n   * in supports that type of track list.\n   *\n   * @private\n   */\n\n\n  Html5.prototype.proxyNativeTracks_ = function proxyNativeTracks_() {\n    var _this2 = this;\n\n    NORMAL.names.forEach(function (name) {\n      var props = NORMAL[name];\n      var elTracks = _this2.el()[props.getterName];\n      var techTracks = _this2[props.getterName]();\n\n      if (!_this2['featuresNative' + props.capitalName + 'Tracks'] || !elTracks || !elTracks.addEventListener) {\n        return;\n      }\n      var listeners = {\n        change: function change(e) {\n          techTracks.trigger({\n            type: 'change',\n            target: techTracks,\n            currentTarget: techTracks,\n            srcElement: techTracks\n          });\n        },\n        addtrack: function addtrack(e) {\n          techTracks.addTrack(e.track);\n        },\n        removetrack: function removetrack(e) {\n          techTracks.removeTrack(e.track);\n        }\n      };\n      var removeOldTracks = function removeOldTracks() {\n        var removeTracks = [];\n\n        for (var i = 0; i < techTracks.length; i++) {\n          var found = false;\n\n          for (var j = 0; j < elTracks.length; j++) {\n            if (elTracks[j] === techTracks[i]) {\n              found = true;\n              break;\n            }\n          }\n\n          if (!found) {\n            removeTracks.push(techTracks[i]);\n          }\n        }\n\n        while (removeTracks.length) {\n          techTracks.removeTrack(removeTracks.shift());\n        }\n      };\n\n      Object.keys(listeners).forEach(function (eventName) {\n        var listener = listeners[eventName];\n\n        elTracks.addEventListener(eventName, listener);\n        _this2.on('dispose', function (e) {\n          return elTracks.removeEventListener(eventName, listener);\n        });\n      });\n\n      // Remove (native) tracks that are not used anymore\n      _this2.on('loadstart', removeOldTracks);\n      _this2.on('dispose', function (e) {\n        return _this2.off('loadstart', removeOldTracks);\n      });\n    });\n  };\n\n  /**\n   * Create the `Html5` Tech's DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  Html5.prototype.createEl = function createEl$$1() {\n    var el = this.options_.tag;\n\n    // Check if this browser supports moving the element into the box.\n    // On the iPhone video will break if you move the element,\n    // So we have to create a brand new element.\n    // If we ingested the player div, we do not need to move the media element.\n    if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {\n\n      // If the original tag is still there, clone and remove it.\n      if (el) {\n        var clone = el.cloneNode(true);\n\n        if (el.parentNode) {\n          el.parentNode.insertBefore(clone, el);\n        }\n        Html5.disposeMediaElement(el);\n        el = clone;\n      } else {\n        el = document.createElement('video');\n\n        // determine if native controls should be used\n        var tagAttributes = this.options_.tag && getAttributes(this.options_.tag);\n        var attributes = mergeOptions({}, tagAttributes);\n\n        if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {\n          delete attributes.controls;\n        }\n\n        setAttributes(el, assign(attributes, {\n          id: this.options_.techId,\n          'class': 'vjs-tech'\n        }));\n      }\n\n      el.playerId = this.options_.playerId;\n    }\n\n    if (typeof this.options_.preload !== 'undefined') {\n      setAttribute(el, 'preload', this.options_.preload);\n    }\n\n    // Update specific tag settings, in case they were overridden\n    // `autoplay` has to be *last* so that `muted` and `playsinline` are present\n    // when iOS/Safari or other browsers attempt to autoplay.\n    var settingsAttrs = ['loop', 'muted', 'playsinline', 'autoplay'];\n\n    for (var i = 0; i < settingsAttrs.length; i++) {\n      var attr = settingsAttrs[i];\n      var value = this.options_[attr];\n\n      if (typeof value !== 'undefined') {\n        if (value) {\n          setAttribute(el, attr, attr);\n        } else {\n          removeAttribute(el, attr);\n        }\n        el[attr] = value;\n      }\n    }\n\n    return el;\n  };\n\n  /**\n   * This will be triggered if the loadstart event has already fired, before videojs was\n   * ready. Two known examples of when this can happen are:\n   * 1. If we're loading the playback object after it has started loading\n   * 2. The media is already playing the (often with autoplay on) then\n   *\n   * This function will fire another loadstart so that videojs can catchup.\n   *\n   * @fires Tech#loadstart\n   *\n   * @return {undefined}\n   *         returns nothing.\n   */\n\n\n  Html5.prototype.handleLateInit_ = function handleLateInit_(el) {\n    if (el.networkState === 0 || el.networkState === 3) {\n      // The video element hasn't started loading the source yet\n      // or didn't find a source\n      return;\n    }\n\n    if (el.readyState === 0) {\n      // NetworkState is set synchronously BUT loadstart is fired at the\n      // end of the current stack, usually before setInterval(fn, 0).\n      // So at this point we know loadstart may have already fired or is\n      // about to fire, and either way the player hasn't seen it yet.\n      // We don't want to fire loadstart prematurely here and cause a\n      // double loadstart so we'll wait and see if it happens between now\n      // and the next loop, and fire it if not.\n      // HOWEVER, we also want to make sure it fires before loadedmetadata\n      // which could also happen between now and the next loop, so we'll\n      // watch for that also.\n      var loadstartFired = false;\n      var setLoadstartFired = function setLoadstartFired() {\n        loadstartFired = true;\n      };\n\n      this.on('loadstart', setLoadstartFired);\n\n      var triggerLoadstart = function triggerLoadstart() {\n        // We did miss the original loadstart. Make sure the player\n        // sees loadstart before loadedmetadata\n        if (!loadstartFired) {\n          this.trigger('loadstart');\n        }\n      };\n\n      this.on('loadedmetadata', triggerLoadstart);\n\n      this.ready(function () {\n        this.off('loadstart', setLoadstartFired);\n        this.off('loadedmetadata', triggerLoadstart);\n\n        if (!loadstartFired) {\n          // We did miss the original native loadstart. Fire it now.\n          this.trigger('loadstart');\n        }\n      });\n\n      return;\n    }\n\n    // From here on we know that loadstart already fired and we missed it.\n    // The other readyState events aren't as much of a problem if we double\n    // them, so not going to go to as much trouble as loadstart to prevent\n    // that unless we find reason to.\n    var eventsToTrigger = ['loadstart'];\n\n    // loadedmetadata: newly equal to HAVE_METADATA (1) or greater\n    eventsToTrigger.push('loadedmetadata');\n\n    // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater\n    if (el.readyState >= 2) {\n      eventsToTrigger.push('loadeddata');\n    }\n\n    // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater\n    if (el.readyState >= 3) {\n      eventsToTrigger.push('canplay');\n    }\n\n    // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)\n    if (el.readyState >= 4) {\n      eventsToTrigger.push('canplaythrough');\n    }\n\n    // We still need to give the player time to add event listeners\n    this.ready(function () {\n      eventsToTrigger.forEach(function (type) {\n        this.trigger(type);\n      }, this);\n    });\n  };\n\n  /**\n   * Set current time for the `HTML5` tech.\n   *\n   * @param {number} seconds\n   *        Set the current time of the media to this.\n   */\n\n\n  Html5.prototype.setCurrentTime = function setCurrentTime(seconds) {\n    try {\n      this.el_.currentTime = seconds;\n    } catch (e) {\n      log$1(e, 'Video is not ready. (Video.js)');\n      // this.warning(VideoJS.warnings.videoNotReady);\n    }\n  };\n\n  /**\n   * Get the current duration of the HTML5 media element.\n   *\n   * @return {number}\n   *         The duration of the media or 0 if there is no duration.\n   */\n\n\n  Html5.prototype.duration = function duration() {\n    var _this3 = this;\n\n    // Android Chrome will report duration as Infinity for VOD HLS until after\n    // playback has started, which triggers the live display erroneously.\n    // Return NaN if playback has not started and trigger a durationupdate once\n    // the duration can be reliably known.\n    if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {\n      // Wait for the first `timeupdate` with currentTime > 0 - there may be\n      // several with 0\n      var checkProgress = function checkProgress() {\n        if (_this3.el_.currentTime > 0) {\n          // Trigger durationchange for genuinely live video\n          if (_this3.el_.duration === Infinity) {\n            _this3.trigger('durationchange');\n          }\n          _this3.off('timeupdate', checkProgress);\n        }\n      };\n\n      this.on('timeupdate', checkProgress);\n      return NaN;\n    }\n    return this.el_.duration || NaN;\n  };\n\n  /**\n   * Get the current width of the HTML5 media element.\n   *\n   * @return {number}\n   *         The width of the HTML5 media element.\n   */\n\n\n  Html5.prototype.width = function width() {\n    return this.el_.offsetWidth;\n  };\n\n  /**\n   * Get the current height of the HTML5 media element.\n   *\n   * @return {number}\n   *         The heigth of the HTML5 media element.\n   */\n\n\n  Html5.prototype.height = function height() {\n    return this.el_.offsetHeight;\n  };\n\n  /**\n   * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into\n   * `fullscreenchange` event.\n   *\n   * @private\n   * @fires fullscreenchange\n   * @listens webkitendfullscreen\n   * @listens webkitbeginfullscreen\n   * @listens webkitbeginfullscreen\n   */\n\n\n  Html5.prototype.proxyWebkitFullscreen_ = function proxyWebkitFullscreen_() {\n    var _this4 = this;\n\n    if (!('webkitDisplayingFullscreen' in this.el_)) {\n      return;\n    }\n\n    var endFn = function endFn() {\n      this.trigger('fullscreenchange', { isFullscreen: false });\n    };\n\n    var beginFn = function beginFn() {\n      if ('webkitPresentationMode' in this.el_ && this.el_.webkitPresentationMode !== 'picture-in-picture') {\n        this.one('webkitendfullscreen', endFn);\n\n        this.trigger('fullscreenchange', { isFullscreen: true });\n      }\n    };\n\n    this.on('webkitbeginfullscreen', beginFn);\n    this.on('dispose', function () {\n      _this4.off('webkitbeginfullscreen', beginFn);\n      _this4.off('webkitendfullscreen', endFn);\n    });\n  };\n\n  /**\n   * Check if fullscreen is supported on the current playback device.\n   *\n   * @return {boolean}\n   *         - True if fullscreen is supported.\n   *         - False if fullscreen is not supported.\n   */\n\n\n  Html5.prototype.supportsFullScreen = function supportsFullScreen() {\n    if (typeof this.el_.webkitEnterFullScreen === 'function') {\n      var userAgent = window.navigator && window.navigator.userAgent || '';\n\n      // Seems to be broken in Chromium/Chrome && Safari in Leopard\n      if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Request that the `HTML5` Tech enter fullscreen.\n   */\n\n\n  Html5.prototype.enterFullScreen = function enterFullScreen() {\n    var video = this.el_;\n\n    if (video.paused && video.networkState <= video.HAVE_METADATA) {\n      // attempt to prime the video element for programmatic access\n      // this isn't necessary on the desktop but shouldn't hurt\n      this.el_.play();\n\n      // playing and pausing synchronously during the transition to fullscreen\n      // can get iOS ~6.1 devices into a play/pause loop\n      this.setTimeout(function () {\n        video.pause();\n        video.webkitEnterFullScreen();\n      }, 0);\n    } else {\n      video.webkitEnterFullScreen();\n    }\n  };\n\n  /**\n   * Request that the `HTML5` Tech exit fullscreen.\n   */\n\n\n  Html5.prototype.exitFullScreen = function exitFullScreen() {\n    this.el_.webkitExitFullScreen();\n  };\n\n  /**\n   * A getter/setter for the `Html5` Tech's source object.\n   * > Note: Please use {@link Html5#setSource}\n   *\n   * @param {Tech~SourceObject} [src]\n   *        The source object you want to set on the `HTML5` techs element.\n   *\n   * @return {Tech~SourceObject|undefined}\n   *         - The current source object when a source is not passed in.\n   *         - undefined when setting\n   *\n   * @deprecated Since version 5.\n   */\n\n\n  Html5.prototype.src = function src(_src) {\n    if (_src === undefined) {\n      return this.el_.src;\n    }\n\n    // Setting src through `src` instead of `setSrc` will be deprecated\n    this.setSrc(_src);\n  };\n\n  /**\n   * Reset the tech by removing all sources and then calling\n   * {@link Html5.resetMediaElement}.\n   */\n\n\n  Html5.prototype.reset = function reset() {\n    Html5.resetMediaElement(this.el_);\n  };\n\n  /**\n   * Get the current source on the `HTML5` Tech. Falls back to returning the source from\n   * the HTML5 media element.\n   *\n   * @return {Tech~SourceObject}\n   *         The current source object from the HTML5 tech. With a fallback to the\n   *         elements source.\n   */\n\n\n  Html5.prototype.currentSrc = function currentSrc() {\n    if (this.currentSource_) {\n      return this.currentSource_.src;\n    }\n    return this.el_.currentSrc;\n  };\n\n  /**\n   * Set controls attribute for the HTML5 media Element.\n   *\n   * @param {string} val\n   *        Value to set the controls attribute to\n   */\n\n\n  Html5.prototype.setControls = function setControls(val) {\n    this.el_.controls = !!val;\n  };\n\n  /**\n   * Create and returns a remote {@link TextTrack} object.\n   *\n   * @param {string} kind\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n   *\n   * @param {string} [label]\n   *        Label to identify the text track\n   *\n   * @param {string} [language]\n   *        Two letter language abbreviation\n   *\n   * @return {TextTrack}\n   *         The TextTrack that gets created.\n   */\n\n\n  Html5.prototype.addTextTrack = function addTextTrack(kind, label, language) {\n    if (!this.featuresNativeTextTracks) {\n      return _Tech.prototype.addTextTrack.call(this, kind, label, language);\n    }\n\n    return this.el_.addTextTrack(kind, label, language);\n  };\n\n  /**\n   * Creates either native TextTrack or an emulated TextTrack depending\n   * on the value of `featuresNativeTextTracks`\n   *\n   * @param {Object} options\n   *        The object should contain the options to intialize the TextTrack with.\n   *\n   * @param {string} [options.kind]\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n   *\n   * @param {string} [options.label].\n   *        Label to identify the text track\n   *\n   * @param {string} [options.language]\n   *        Two letter language abbreviation.\n   *\n   * @param {boolean} [options.default]\n   *        Default this track to on.\n   *\n   * @param {string} [options.id]\n   *        The internal id to assign this track.\n   *\n   * @param {string} [options.src]\n   *        A source url for the track.\n   *\n   * @return {HTMLTrackElement}\n   *         The track element that gets created.\n   */\n\n\n  Html5.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {\n    if (!this.featuresNativeTextTracks) {\n      return _Tech.prototype.createRemoteTextTrack.call(this, options);\n    }\n    var htmlTrackElement = document.createElement('track');\n\n    if (options.kind) {\n      htmlTrackElement.kind = options.kind;\n    }\n    if (options.label) {\n      htmlTrackElement.label = options.label;\n    }\n    if (options.language || options.srclang) {\n      htmlTrackElement.srclang = options.language || options.srclang;\n    }\n    if (options['default']) {\n      htmlTrackElement['default'] = options['default'];\n    }\n    if (options.id) {\n      htmlTrackElement.id = options.id;\n    }\n    if (options.src) {\n      htmlTrackElement.src = options.src;\n    }\n\n    return htmlTrackElement;\n  };\n\n  /**\n   * Creates a remote text track object and returns an html track element.\n   *\n   * @param {Object} options The object should contain values for\n   * kind, language, label, and src (location of the WebVTT file)\n   * @param {Boolean} [manualCleanup=true] if set to false, the TextTrack will be\n   * automatically removed from the video element whenever the source changes\n   * @return {HTMLTrackElement} An Html Track Element.\n   * This can be an emulated {@link HTMLTrackElement} or a native one.\n   * @deprecated The default value of the \"manualCleanup\" parameter will default\n   * to \"false\" in upcoming versions of Video.js\n   */\n\n\n  Html5.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {\n    var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);\n\n    if (this.featuresNativeTextTracks) {\n      this.el().appendChild(htmlTrackElement);\n    }\n\n    return htmlTrackElement;\n  };\n\n  /**\n   * Remove remote `TextTrack` from `TextTrackList` object\n   *\n   * @param {TextTrack} track\n   *        `TextTrack` object to remove\n   */\n\n\n  Html5.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {\n    _Tech.prototype.removeRemoteTextTrack.call(this, track);\n\n    if (this.featuresNativeTextTracks) {\n      var tracks = this.$$('track');\n\n      var i = tracks.length;\n\n      while (i--) {\n        if (track === tracks[i] || track === tracks[i].track) {\n          this.el().removeChild(tracks[i]);\n        }\n      }\n    }\n  };\n\n  /**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object}\n   *         An object with supported media playback quality metrics\n   */\n\n\n  Html5.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\n    if (typeof this.el().getVideoPlaybackQuality === 'function') {\n      return this.el().getVideoPlaybackQuality();\n    }\n\n    var videoPlaybackQuality = {};\n\n    if (typeof this.el().webkitDroppedFrameCount !== 'undefined' && typeof this.el().webkitDecodedFrameCount !== 'undefined') {\n      videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;\n      videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;\n    }\n\n    if (window.performance && typeof window.performance.now === 'function') {\n      videoPlaybackQuality.creationTime = window.performance.now();\n    } else if (window.performance && window.performance.timing && typeof window.performance.timing.navigationStart === 'number') {\n      videoPlaybackQuality.creationTime = window.Date.now() - window.performance.timing.navigationStart;\n    }\n\n    return videoPlaybackQuality;\n  };\n\n  return Html5;\n}(Tech);\n\n/* HTML5 Support Testing ---------------------------------------------------- */\n\nif (isReal()) {\n\n  /**\n   * Element for testing browser HTML5 media capabilities\n   *\n   * @type {Element}\n   * @constant\n   * @private\n   */\n  Html5.TEST_VID = document.createElement('video');\n  var track = document.createElement('track');\n\n  track.kind = 'captions';\n  track.srclang = 'en';\n  track.label = 'English';\n  Html5.TEST_VID.appendChild(track);\n}\n\n/**\n * Check if HTML5 media is supported by this browser/device.\n *\n * @return {boolean}\n *         - True if HTML5 media is supported.\n *         - False if HTML5 media is not supported.\n */\nHtml5.isSupported = function () {\n  // IE9 with no Media Player is a LIAR! (#984)\n  try {\n    Html5.TEST_VID.volume = 0.5;\n  } catch (e) {\n    return false;\n  }\n\n  return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);\n};\n\n/**\n * Check if the tech can support the given type\n *\n * @param {string} type\n *        The mimetype to check\n * @return {string} 'probably', 'maybe', or '' (empty string)\n */\nHtml5.canPlayType = function (type) {\n  return Html5.TEST_VID.canPlayType(type);\n};\n\n/**\n * Check if the tech can support the given source\n * @param {Object} srcObj\n *        The source object\n * @param {Object} options\n *        The options passed to the tech\n * @return {string} 'probably', 'maybe', or '' (empty string)\n */\nHtml5.canPlaySource = function (srcObj, options) {\n  return Html5.canPlayType(srcObj.type);\n};\n\n/**\n * Check if the volume can be changed in this browser/device.\n * Volume cannot be changed in a lot of mobile devices.\n * Specifically, it can't be changed from 1 on iOS.\n *\n * @return {boolean}\n *         - True if volume can be controlled\n *         - False otherwise\n */\nHtml5.canControlVolume = function () {\n  // IE will error if Windows Media Player not installed #3315\n  try {\n    var volume = Html5.TEST_VID.volume;\n\n    Html5.TEST_VID.volume = volume / 2 + 0.1;\n    return volume !== Html5.TEST_VID.volume;\n  } catch (e) {\n    return false;\n  }\n};\n\n/**\n * Check if the playback rate can be changed in this browser/device.\n *\n * @return {boolean}\n *         - True if playback rate can be controlled\n *         - False otherwise\n */\nHtml5.canControlPlaybackRate = function () {\n  // Playback rate API is implemented in Android Chrome, but doesn't do anything\n  // https://github.com/videojs/video.js/issues/3180\n  if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {\n    return false;\n  }\n  // IE will error if Windows Media Player not installed #3315\n  try {\n    var playbackRate = Html5.TEST_VID.playbackRate;\n\n    Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;\n    return playbackRate !== Html5.TEST_VID.playbackRate;\n  } catch (e) {\n    return false;\n  }\n};\n\n/**\n * Check to see if native `TextTrack`s are supported by this browser/device.\n *\n * @return {boolean}\n *         - True if native `TextTrack`s are supported.\n *         - False otherwise\n */\nHtml5.supportsNativeTextTracks = function () {\n  return IS_ANY_SAFARI;\n};\n\n/**\n * Check to see if native `VideoTrack`s are supported by this browser/device\n *\n * @return {boolean}\n *        - True if native `VideoTrack`s are supported.\n *        - False otherwise\n */\nHtml5.supportsNativeVideoTracks = function () {\n  return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);\n};\n\n/**\n * Check to see if native `AudioTrack`s are supported by this browser/device\n *\n * @return {boolean}\n *        - True if native `AudioTrack`s are supported.\n *        - False otherwise\n */\nHtml5.supportsNativeAudioTracks = function () {\n  return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);\n};\n\n/**\n * An array of events available on the Html5 tech.\n *\n * @private\n * @type {Array}\n */\nHtml5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'resize', 'volumechange'];\n\n/**\n * Boolean indicating whether the `Tech` supports volume control.\n *\n * @type {boolean}\n * @default {@link Html5.canControlVolume}\n */\nHtml5.prototype.featuresVolumeControl = Html5.canControlVolume();\n\n/**\n * Boolean indicating whether the `Tech` supports changing the speed at which the media\n * plays. Examples:\n *   - Set player to play 2x (twice) as fast\n *   - Set player to play 0.5x (half) as fast\n *\n * @type {boolean}\n * @default {@link Html5.canControlPlaybackRate}\n */\nHtml5.prototype.featuresPlaybackRate = Html5.canControlPlaybackRate();\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports the media element\n * moving in the DOM. iOS breaks if you move the media element, so this is set this to\n * false there. Everywhere else this should be true.\n *\n * @type {boolean}\n * @default\n */\nHtml5.prototype.movingMediaElementInDOM = !IS_IOS;\n\n// TODO: Previous comment: No longer appears to be used. Can probably be removed.\n//       Is this true?\n/**\n * Boolean indicating whether the `HTML5` tech currently supports automatic media resize\n * when going into fullscreen.\n *\n * @type {boolean}\n * @default\n */\nHtml5.prototype.featuresFullscreenResize = true;\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports the progress event.\n * If this is false, manual `progress` events will be triggred instead.\n *\n * @type {boolean}\n * @default\n */\nHtml5.prototype.featuresProgressEvents = true;\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports the timeupdate event.\n * If this is false, manual `timeupdate` events will be triggred instead.\n *\n * @default\n */\nHtml5.prototype.featuresTimeupdateEvents = true;\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports native `TextTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeTextTracks}\n */\nHtml5.prototype.featuresNativeTextTracks = Html5.supportsNativeTextTracks();\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports native `VideoTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeVideoTracks}\n */\nHtml5.prototype.featuresNativeVideoTracks = Html5.supportsNativeVideoTracks();\n\n/**\n * Boolean indicating whether the `HTML5` tech currently supports native `AudioTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeAudioTracks}\n */\nHtml5.prototype.featuresNativeAudioTracks = Html5.supportsNativeAudioTracks();\n\n// HTML5 Feature detection and Device Fixes --------------------------------- //\nvar canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;\nvar mpegurlRE = /^application\\/(?:x-|vnd\\.apple\\.)mpegurl/i;\nvar mp4RE = /^video\\/mp4/i;\n\nHtml5.patchCanPlayType = function () {\n\n  // Android 4.0 and above can play HLS to some extent but it reports being unable to do so\n  if (ANDROID_VERSION >= 4.0 && !IS_FIREFOX) {\n    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {\n      if (type && mpegurlRE.test(type)) {\n        return 'maybe';\n      }\n      return canPlayType.call(this, type);\n    };\n\n    // Override Android 2.2 and less canPlayType method which is broken\n  } else if (IS_OLD_ANDROID) {\n    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {\n      if (type && mp4RE.test(type)) {\n        return 'maybe';\n      }\n      return canPlayType.call(this, type);\n    };\n  }\n};\n\nHtml5.unpatchCanPlayType = function () {\n  var r = Html5.TEST_VID.constructor.prototype.canPlayType;\n\n  Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;\n  return r;\n};\n\n// by default, patch the media element\nHtml5.patchCanPlayType();\n\nHtml5.disposeMediaElement = function (el) {\n  if (!el) {\n    return;\n  }\n\n  if (el.parentNode) {\n    el.parentNode.removeChild(el);\n  }\n\n  // remove any child track or source nodes to prevent their loading\n  while (el.hasChildNodes()) {\n    el.removeChild(el.firstChild);\n  }\n\n  // remove any src reference. not setting `src=''` because that causes a warning\n  // in firefox\n  el.removeAttribute('src');\n\n  // force the media element to update its loading state by calling load()\n  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)\n  if (typeof el.load === 'function') {\n    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n    (function () {\n      try {\n        el.load();\n      } catch (e) {\n        // not supported\n      }\n    })();\n  }\n};\n\nHtml5.resetMediaElement = function (el) {\n  if (!el) {\n    return;\n  }\n\n  var sources = el.querySelectorAll('source');\n  var i = sources.length;\n\n  while (i--) {\n    el.removeChild(sources[i]);\n  }\n\n  // remove any src reference.\n  // not setting `src=''` because that throws an error\n  el.removeAttribute('src');\n\n  if (typeof el.load === 'function') {\n    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n    (function () {\n      try {\n        el.load();\n      } catch (e) {\n        // satisfy linter\n      }\n    })();\n  }\n};\n\n/* Native HTML5 element property wrapping ----------------------------------- */\n// Wrap native boolean attributes with getters that check both property and attribute\n// The list is as followed:\n// muted, defaultMuted, autoplay, controls, loop, playsinline\n[\n/**\n * Get the value of `muted` from the media element. `muted` indicates\n * that the volume for the media should be set to silent. This does not actually change\n * the `volume` attribute.\n *\n * @method Html5#muted\n * @return {boolean}\n *         - True if the value of `volume` should be ignored and the audio set to silent.\n *         - False if the value of `volume` should be used.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n */\n'muted',\n\n/**\n * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates\n * whether the media should start muted or not. Only changes the default state of the\n * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the\n * current state.\n *\n * @method Html5#defaultMuted\n * @return {boolean}\n *         - The value of `defaultMuted` from the media element.\n *         - True indicates that the media should start muted.\n *         - False indicates that the media should not start muted\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n */\n'defaultMuted',\n\n/**\n * Get the value of `autoplay` from the media element. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Html5#autoplay\n * @return {boolean}\n *         - The value of `autoplay` from the media element.\n *         - True indicates that the media should start as soon as the page loads.\n *         - False indicates that the media should not start as soon as the page loads.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n */\n'autoplay',\n\n/**\n * Get the value of `controls` from the media element. `controls` indicates\n * whether the native media controls should be shown or hidden.\n *\n * @method Html5#controls\n * @return {boolean}\n *         - The value of `controls` from the media element.\n *         - True indicates that native controls should be showing.\n *         - False indicates that native controls should be hidden.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}\n */\n'controls',\n\n/**\n * Get the value of `loop` from the media element. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Html5#loop\n * @return {boolean}\n *         - The value of `loop` from the media element.\n *         - True indicates that playback should seek back to start once\n *           the end of a media is reached.\n *         - False indicates that playback should not loop back to the start when the\n *           end of the media is reached.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n */\n'loop',\n\n/**\n * Get the value of `playsinline` from the media element. `playsinline` indicates\n * to the browser that non-fullscreen playback is preferred when fullscreen\n * playback is the native default, such as in iOS Safari.\n *\n * @method Html5#playsinline\n * @return {boolean}\n *         - The value of `playsinline` from the media element.\n *         - True indicates that the media should play inline.\n *         - False indicates that the media should not play inline.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n */\n'playsinline'].forEach(function (prop) {\n  Html5.prototype[prop] = function () {\n    return this.el_[prop] || this.el_.hasAttribute(prop);\n  };\n});\n\n// Wrap native boolean attributes with setters that set both property and attribute\n// The list is as followed:\n// setMuted, setDefaultMuted, setAutoplay, setLoop, setPlaysinline\n// setControls is special-cased above\n[\n/**\n * Set the value of `muted` on the media element. `muted` indicates that the current\n * audio level should be silent.\n *\n * @method Html5#setMuted\n * @param {boolean} muted\n *        - True if the audio should be set to silent\n *        - False otherwise\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n */\n'muted',\n\n/**\n * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current\n * audio level should be silent, but will only effect the muted level on intial playback..\n *\n * @method Html5.prototype.setDefaultMuted\n * @param {boolean} defaultMuted\n *        - True if the audio should be set to silent\n *        - False otherwise\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n */\n'defaultMuted',\n\n/**\n * Set the value of `autoplay` on the media element. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Html5#setAutoplay\n * @param {boolean} autoplay\n *         - True indicates that the media should start as soon as the page loads.\n *         - False indicates that the media should not start as soon as the page loads.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n */\n'autoplay',\n\n/**\n * Set the value of `loop` on the media element. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Html5#setLoop\n * @param {boolean} loop\n *         - True indicates that playback should seek back to start once\n *           the end of a media is reached.\n *         - False indicates that playback should not loop back to the start when the\n *           end of the media is reached.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n */\n'loop',\n\n/**\n * Set the value of `playsinline` from the media element. `playsinline` indicates\n * to the browser that non-fullscreen playback is preferred when fullscreen\n * playback is the native default, such as in iOS Safari.\n *\n * @method Html5#setPlaysinline\n * @param {boolean} playsinline\n *         - True indicates that the media should play inline.\n *         - False indicates that the media should not play inline.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n */\n'playsinline'].forEach(function (prop) {\n  Html5.prototype['set' + toTitleCase(prop)] = function (v) {\n    this.el_[prop] = v;\n\n    if (v) {\n      this.el_.setAttribute(prop, prop);\n    } else {\n      this.el_.removeAttribute(prop);\n    }\n  };\n});\n\n// Wrap native properties with a getter\n// The list is as followed\n// paused, currentTime, buffered, volume, poster, preload, error, seeking\n// seekable, ended, playbackRate, defaultPlaybackRate, played, networkState\n// readyState, videoWidth, videoHeight\n[\n/**\n * Get the value of `paused` from the media element. `paused` indicates whether the media element\n * is currently paused or not.\n *\n * @method Html5#paused\n * @return {boolean}\n *         The value of `paused` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}\n */\n'paused',\n\n/**\n * Get the value of `currentTime` from the media element. `currentTime` indicates\n * the current second that the media is at in playback.\n *\n * @method Html5#currentTime\n * @return {number}\n *         The value of `currentTime` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}\n */\n'currentTime',\n\n/**\n * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`\n * object that represents the parts of the media that are already downloaded and\n * available for playback.\n *\n * @method Html5#buffered\n * @return {TimeRange}\n *         The value of `buffered` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}\n */\n'buffered',\n\n/**\n * Get the value of `volume` from the media element. `volume` indicates\n * the current playback volume of audio for a media. `volume` will be a value from 0\n * (silent) to 1 (loudest and default).\n *\n * @method Html5#volume\n * @return {number}\n *         The value of `volume` from the media element. Value will be between 0-1.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n */\n'volume',\n\n/**\n * Get the value of `poster` from the media element. `poster` indicates\n * that the url of an image file that can/will be shown when no media data is available.\n *\n * @method Html5#poster\n * @return {string}\n *         The value of `poster` from the media element. Value will be a url to an\n *         image.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}\n */\n'poster',\n\n/**\n * Get the value of `preload` from the media element. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Html5#preload\n * @return {string}\n *         The value of `preload` from the media element. Will be 'none', 'metadata',\n *         or 'auto'.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n */\n'preload',\n\n/**\n * Get the value of the `error` from the media element. `error` indicates any\n * MediaError that may have occured during playback. If error returns null there is no\n * current error.\n *\n * @method Html5#error\n * @return {MediaError|null}\n *         The value of `error` from the media element. Will be `MediaError` if there\n *         is a current error and null otherwise.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}\n */\n'error',\n\n/**\n * Get the value of `seeking` from the media element. `seeking` indicates whether the\n * media is currently seeking to a new position or not.\n *\n * @method Html5#seeking\n * @return {boolean}\n *         - The value of `seeking` from the media element.\n *         - True indicates that the media is currently seeking to a new position.\n *         - Flase indicates that the media is not seeking to a new position at this time.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}\n */\n'seeking',\n\n/**\n * Get the value of `seekable` from the media element. `seekable` returns a\n * `TimeRange` object indicating ranges of time that can currently be `seeked` to.\n *\n * @method Html5#seekable\n * @return {TimeRange}\n *         The value of `seekable` from the media element. A `TimeRange` object\n *         indicating the current ranges of time that can be seeked to.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}\n */\n'seekable',\n\n/**\n * Get the value of `ended` from the media element. `ended` indicates whether\n * the media has reached the end or not.\n *\n * @method Html5#ended\n * @return {boolean}\n *         - The value of `ended` from the media element.\n *         - True indicates that the media has ended.\n *         - False indicates that the media has not ended.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}\n */\n'ended',\n\n/**\n * Get the value of `playbackRate` from the media element. `playbackRate` indicates\n * the rate at which the media is currently playing back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5#playbackRate\n * @return {number}\n *         The value of `playbackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */\n'playbackRate',\n\n/**\n * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates\n * the rate at which the media is currently playing back. This value will not indicate the current\n * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.\n *\n * Examples:\n *   - if defaultPlaybackRate is set to 2, media will play twice as fast.\n *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5.prototype.defaultPlaybackRate\n * @return {number}\n *         The value of `defaultPlaybackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */\n'defaultPlaybackRate',\n\n/**\n * Get the value of `played` from the media element. `played` returns a `TimeRange`\n * object representing points in the media timeline that have been played.\n *\n * @method Html5#played\n * @return {TimeRange}\n *         The value of `played` from the media element. A `TimeRange` object indicating\n *         the ranges of time that have been played.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}\n */\n'played',\n\n/**\n * Get the value of `networkState` from the media element. `networkState` indicates\n * the current network state. It returns an enumeration from the following list:\n * - 0: NETWORK_EMPTY\n * - 1: NEWORK_IDLE\n * - 2: NETWORK_LOADING\n * - 3: NETWORK_NO_SOURCE\n *\n * @method Html5#networkState\n * @return {number}\n *         The value of `networkState` from the media element. This will be a number\n *         from the list in the description.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}\n */\n'networkState',\n\n/**\n * Get the value of `readyState` from the media element. `readyState` indicates\n * the current state of the media element. It returns an enumeration from the\n * following list:\n * - 0: HAVE_NOTHING\n * - 1: HAVE_METADATA\n * - 2: HAVE_CURRENT_DATA\n * - 3: HAVE_FUTURE_DATA\n * - 4: HAVE_ENOUGH_DATA\n *\n * @method Html5#readyState\n * @return {number}\n *         The value of `readyState` from the media element. This will be a number\n *         from the list in the description.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}\n */\n'readyState',\n\n/**\n * Get the value of `videoWidth` from the video element. `videoWidth` indicates\n * the current width of the video in css pixels.\n *\n * @method Html5#videoWidth\n * @return {number}\n *         The value of `videoWidth` from the video element. This will be a number\n *         in css pixels.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n */\n'videoWidth',\n\n/**\n * Get the value of `videoHeight` from the video element. `videoHeigth` indicates\n * the current height of the video in css pixels.\n *\n * @method Html5#videoHeight\n * @return {number}\n *         The value of `videoHeight` from the video element. This will be a number\n *         in css pixels.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n */\n'videoHeight'].forEach(function (prop) {\n  Html5.prototype[prop] = function () {\n    return this.el_[prop];\n  };\n});\n\n// Wrap native properties with a setter in this format:\n// set + toTitleCase(name)\n// The list is as follows:\n// setVolume, setSrc, setPoster, setPreload, setPlaybackRate, setDefaultPlaybackRate\n[\n/**\n * Set the value of `volume` on the media element. `volume` indicates the current\n * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and\n * so on.\n *\n * @method Html5#setVolume\n * @param {number} percentAsDecimal\n *        The volume percent as a decimal. Valid range is from 0-1.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n */\n'volume',\n\n/**\n * Set the value of `src` on the media element. `src` indicates the current\n * {@link Tech~SourceObject} for the media.\n *\n * @method Html5#setSrc\n * @param {Tech~SourceObject} src\n *        The source object to set as the current source.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}\n */\n'src',\n\n/**\n * Set the value of `poster` on the media element. `poster` is the url to\n * an image file that can/will be shown when no media data is available.\n *\n * @method Html5#setPoster\n * @param {string} poster\n *        The url to an image that should be used as the `poster` for the media\n *        element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}\n */\n'poster',\n\n/**\n * Set the value of `preload` on the media element. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Html5#setPreload\n * @param {string} preload\n *         The value of `preload` to set on the media element. Must be 'none', 'metadata',\n *         or 'auto'.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n */\n'preload',\n\n/**\n * Set the value of `playbackRate` on the media element. `playbackRate` indicates\n * the rate at which the media should play back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5#setPlaybackRate\n * @return {number}\n *         The value of `playbackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */\n'playbackRate',\n\n/**\n * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates\n * the rate at which the media should play back upon initial startup. Changing this value\n * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.\n *\n * Example Values:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5.prototype.setDefaultPlaybackRate\n * @return {number}\n *         The value of `defaultPlaybackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}\n */\n'defaultPlaybackRate'].forEach(function (prop) {\n  Html5.prototype['set' + toTitleCase(prop)] = function (v) {\n    this.el_[prop] = v;\n  };\n});\n\n// wrap native functions with a function\n// The list is as follows:\n// pause, load play\n[\n/**\n * A wrapper around the media elements `pause` function. This will call the `HTML5`\n * media elements `pause` function.\n *\n * @method Html5#pause\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}\n */\n'pause',\n\n/**\n * A wrapper around the media elements `load` function. This will call the `HTML5`s\n * media element `load` function.\n *\n * @method Html5#load\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}\n */\n'load',\n\n/**\n * A wrapper around the media elements `play` function. This will call the `HTML5`s\n * media element `play` function.\n *\n * @method Html5#play\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}\n */\n'play'].forEach(function (prop) {\n  Html5.prototype[prop] = function () {\n    return this.el_[prop]();\n  };\n});\n\nTech.withSourceHandlers(Html5);\n\n/**\n * Native source handler for Html5, simply passes the source to the media element.\n *\n * @proprety {Tech~SourceObject} source\n *        The source object\n *\n * @proprety {Html5} tech\n *        The instance of the HTML5 tech.\n */\nHtml5.nativeSourceHandler = {};\n\n/**\n * Check if the media element can play the given mime type.\n *\n * @param {string} type\n *        The mimetype to check\n *\n * @return {string}\n *         'probably', 'maybe', or '' (empty string)\n */\nHtml5.nativeSourceHandler.canPlayType = function (type) {\n  // IE9 on Windows 7 without MediaPlayer throws an error here\n  // https://github.com/videojs/video.js/issues/519\n  try {\n    return Html5.TEST_VID.canPlayType(type);\n  } catch (e) {\n    return '';\n  }\n};\n\n/**\n * Check if the media element can handle a source natively.\n *\n * @param {Tech~SourceObject} source\n *         The source object\n *\n * @param {Object} [options]\n *         Options to be passed to the tech.\n *\n * @return {string}\n *         'probably', 'maybe', or '' (empty string).\n */\nHtml5.nativeSourceHandler.canHandleSource = function (source, options) {\n\n  // If a type was provided we should rely on that\n  if (source.type) {\n    return Html5.nativeSourceHandler.canPlayType(source.type);\n\n    // If no type, fall back to checking 'video/[EXTENSION]'\n  } else if (source.src) {\n    var ext = getFileExtension(source.src);\n\n    return Html5.nativeSourceHandler.canPlayType('video/' + ext);\n  }\n\n  return '';\n};\n\n/**\n * Pass the source to the native media element.\n *\n * @param {Tech~SourceObject} source\n *        The source object\n *\n * @param {Html5} tech\n *        The instance of the Html5 tech\n *\n * @param {Object} [options]\n *        The options to pass to the source\n */\nHtml5.nativeSourceHandler.handleSource = function (source, tech, options) {\n  tech.setSrc(source.src);\n};\n\n/**\n * A noop for the native dispose function, as cleanup is not needed.\n */\nHtml5.nativeSourceHandler.dispose = function () {};\n\n// Register the native source handler\nHtml5.registerSourceHandler(Html5.nativeSourceHandler);\n\nTech.registerTech('Html5', Html5);\n\nvar _templateObject$1 = taggedTemplateLiteralLoose(['\\n        Using the tech directly can be dangerous. I hope you know what you\\'re doing.\\n        See https://github.com/videojs/video.js/issues/2617 for more info.\\n      '], ['\\n        Using the tech directly can be dangerous. I hope you know what you\\'re doing.\\n        See https://github.com/videojs/video.js/issues/2617 for more info.\\n      ']);\n\n/**\n * @file player.js\n */\n// Subclasses Component\n// The following imports are used only to ensure that the corresponding modules\n// are always included in the video.js package. Importing the modules will\n// execute them and they will register themselves with video.js.\n// Import Html5 tech, at least for disposing the original video tag.\n// The following tech events are simply re-triggered\n// on the player when they happen\nvar TECH_EVENTS_RETRIGGER = [\n/**\n * Fired while the user agent is downloading media data.\n *\n * @event Player#progress\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `progress` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechProgress_\n * @fires Player#progress\n * @listens Tech#progress\n */\n'progress',\n\n/**\n * Fires when the loading of an audio/video is aborted.\n *\n * @event Player#abort\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `abort` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechAbort_\n * @fires Player#abort\n * @listens Tech#abort\n */\n'abort',\n\n/**\n * Fires when the browser is intentionally not getting media data.\n *\n * @event Player#suspend\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `suspend` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechSuspend_\n * @fires Player#suspend\n * @listens Tech#suspend\n */\n'suspend',\n\n/**\n * Fires when the current playlist is empty.\n *\n * @event Player#emptied\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `emptied` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechEmptied_\n * @fires Player#emptied\n * @listens Tech#emptied\n */\n'emptied',\n/**\n * Fires when the browser is trying to get media data, but data is not available.\n *\n * @event Player#stalled\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `stalled` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechStalled_\n * @fires Player#stalled\n * @listens Tech#stalled\n */\n'stalled',\n\n/**\n * Fires when the browser has loaded meta data for the audio/video.\n *\n * @event Player#loadedmetadata\n * @type {EventTarget~Event}\n */\n/**\n * Retrigger the `stalled` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechLoadedmetadata_\n * @fires Player#loadedmetadata\n * @listens Tech#loadedmetadata\n */\n'loadedmetadata',\n\n/**\n * Fires when the browser has loaded the current frame of the audio/video.\n *\n * @event Player#loadeddata\n * @type {event}\n */\n/**\n * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechLoaddeddata_\n * @fires Player#loadeddata\n * @listens Tech#loadeddata\n */\n'loadeddata',\n\n/**\n * Fires when the current playback position has changed.\n *\n * @event Player#timeupdate\n * @type {event}\n */\n/**\n * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechTimeUpdate_\n * @fires Player#timeupdate\n * @listens Tech#timeupdate\n */\n'timeupdate',\n\n/**\n * Fires when the playing speed of the audio/video is changed\n *\n * @event Player#ratechange\n * @type {event}\n */\n/**\n * Retrigger the `ratechange` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechRatechange_\n * @fires Player#ratechange\n * @listens Tech#ratechange\n */\n'ratechange',\n\n/**\n * Fires when the video's intrinsic dimensions change\n *\n * @event Player#resize\n * @type {event}\n */\n/**\n * Retrigger the `resize` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechResize_\n * @fires Player#resize\n * @listens Tech#resize\n */\n'resize',\n\n/**\n * Fires when the volume has been changed\n *\n * @event Player#volumechange\n * @type {event}\n */\n/**\n * Retrigger the `volumechange` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechVolumechange_\n * @fires Player#volumechange\n * @listens Tech#volumechange\n */\n'volumechange',\n\n/**\n * Fires when the text track has been changed\n *\n * @event Player#texttrackchange\n * @type {event}\n */\n/**\n * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechTexttrackchange_\n * @fires Player#texttrackchange\n * @listens Tech#texttrackchange\n */\n'texttrackchange'];\n\n/**\n * An instance of the `Player` class is created when any of the Video.js setup methods\n * are used to initialize a video.\n *\n * After an instance has been created it can be accessed globally in two ways:\n * 1. By calling `videojs('example_video_1');`\n * 2. By using it directly via  `videojs.players.example_video_1;`\n *\n * @extends Component\n */\n\nvar Player = function (_Component) {\n  inherits(Player, _Component);\n\n  /**\n   * Create an instance of this class.\n   *\n   * @param {Element} tag\n   *        The original video DOM element used for configuring options.\n   *\n   * @param {Object} [options]\n   *        Object of option names and values.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        Ready callback function.\n   */\n  function Player(tag, options, ready) {\n    classCallCheck(this, Player);\n\n    // Make sure tag ID exists\n    tag.id = tag.id || 'vjs_video_' + newGUID();\n\n    // Set Options\n    // The options argument overrides options set in the video tag\n    // which overrides globally set options.\n    // This latter part coincides with the load order\n    // (tag must exist before Player)\n    options = assign(Player.getTagSettings(tag), options);\n\n    // Delay the initialization of children because we need to set up\n    // player properties first, and can't use `this` before `super()`\n    options.initChildren = false;\n\n    // Same with creating the element\n    options.createEl = false;\n\n    // don't auto mixin the evented mixin\n    options.evented = false;\n\n    // we don't want the player to report touch activity on itself\n    // see enableTouchActivity in Component\n    options.reportTouchActivity = false;\n\n    // If language is not set, get the closest lang attribute\n    if (!options.language) {\n      if (typeof tag.closest === 'function') {\n        var closest = tag.closest('[lang]');\n\n        if (closest && closest.getAttribute) {\n          options.language = closest.getAttribute('lang');\n        }\n      } else {\n        var element = tag;\n\n        while (element && element.nodeType === 1) {\n          if (getAttributes(element).hasOwnProperty('lang')) {\n            options.language = element.getAttribute('lang');\n            break;\n          }\n          element = element.parentNode;\n        }\n      }\n    }\n\n    // Run base component initializing with new options\n\n    // Turn off API access because we're loading a new tech that might load asynchronously\n    var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));\n\n    _this.isReady_ = false;\n\n    // Init state hasStarted_\n    _this.hasStarted_ = false;\n\n    // Init state userActive_\n    _this.userActive_ = false;\n\n    // if the global option object was accidentally blown away by\n    // someone, bail early with an informative error\n    if (!_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) {\n      throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');\n    }\n\n    // Store the original tag used to set options\n    _this.tag = tag;\n\n    // Store the tag attributes used to restore html5 element\n    _this.tagAttributes = tag && getAttributes(tag);\n\n    // Update current language\n    _this.language(_this.options_.language);\n\n    // Update Supported Languages\n    if (options.languages) {\n      // Normalise player option languages to lowercase\n      var languagesToLower = {};\n\n      Object.getOwnPropertyNames(options.languages).forEach(function (name$$1) {\n        languagesToLower[name$$1.toLowerCase()] = options.languages[name$$1];\n      });\n      _this.languages_ = languagesToLower;\n    } else {\n      _this.languages_ = Player.prototype.options_.languages;\n    }\n\n    // Cache for video property values.\n    _this.cache_ = {};\n\n    // Set poster\n    _this.poster_ = options.poster || '';\n\n    // Set controls\n    _this.controls_ = !!options.controls;\n\n    // Set default values for lastVolume\n    _this.cache_.lastVolume = 1;\n\n    // Original tag settings stored in options\n    // now remove immediately so native controls don't flash.\n    // May be turned back on by HTML5 tech if nativeControlsForTouch is true\n    tag.controls = false;\n    tag.removeAttribute('controls');\n\n    /*\n     * Store the internal state of scrubbing\n     *\n     * @private\n     * @return {Boolean} True if the user is scrubbing\n     */\n    _this.scrubbing_ = false;\n\n    _this.el_ = _this.createEl();\n\n    // Make this an evented object and use `el_` as its event bus.\n    evented(_this, { eventBusKey: 'el_' });\n\n    // We also want to pass the original player options to each component and plugin\n    // as well so they don't need to reach back into the player for options later.\n    // We also need to do another copy of this.options_ so we don't end up with\n    // an infinite loop.\n    var playerOptionsCopy = mergeOptions(_this.options_);\n\n    // Load plugins\n    if (options.plugins) {\n      var plugins = options.plugins;\n\n      Object.keys(plugins).forEach(function (name$$1) {\n        if (typeof this[name$$1] === 'function') {\n          this[name$$1](plugins[name$$1]);\n        } else {\n          throw new Error('plugin \"' + name$$1 + '\" does not exist');\n        }\n      }, _this);\n    }\n\n    _this.options_.playerOptions = playerOptionsCopy;\n\n    _this.middleware_ = [];\n\n    _this.initChildren();\n\n    // Set isAudio based on whether or not an audio tag was used\n    _this.isAudio(tag.nodeName.toLowerCase() === 'audio');\n\n    // Update controls className. Can't do this when the controls are initially\n    // set because the element doesn't exist yet.\n    if (_this.controls()) {\n      _this.addClass('vjs-controls-enabled');\n    } else {\n      _this.addClass('vjs-controls-disabled');\n    }\n\n    // Set ARIA label and region role depending on player type\n    _this.el_.setAttribute('role', 'region');\n    if (_this.isAudio()) {\n      _this.el_.setAttribute('aria-label', _this.localize('Audio Player'));\n    } else {\n      _this.el_.setAttribute('aria-label', _this.localize('Video Player'));\n    }\n\n    if (_this.isAudio()) {\n      _this.addClass('vjs-audio');\n    }\n\n    if (_this.flexNotSupported_()) {\n      _this.addClass('vjs-no-flex');\n    }\n\n    // TODO: Make this smarter. Toggle user state between touching/mousing\n    // using events, since devices can have both touch and mouse events.\n    // if (browser.TOUCH_ENABLED) {\n    //   this.addClass('vjs-touch-enabled');\n    // }\n\n    // iOS Safari has broken hover handling\n    if (!IS_IOS) {\n      _this.addClass('vjs-workinghover');\n    }\n\n    // Make player easily findable by ID\n    Player.players[_this.id_] = _this;\n\n    // Add a major version class to aid css in plugins\n    var majorVersion = version.split('.')[0];\n\n    _this.addClass('vjs-v' + majorVersion);\n\n    // When the player is first initialized, trigger activity so components\n    // like the control bar show themselves if needed\n    _this.userActive(true);\n    _this.reportUserActivity();\n    _this.listenForUserActivity_();\n\n    _this.on('fullscreenchange', _this.handleFullscreenChange_);\n    _this.on('stageclick', _this.handleStageClick_);\n\n    _this.changingSrc_ = false;\n    _this.playWaitingForReady_ = false;\n    _this.playOnLoadstart_ = null;\n\n    _this.forceAutoplayInChrome_();\n    return _this;\n  }\n\n  /**\n   * Destroys the video player and does any necessary cleanup.\n   *\n   * This is especially helpful if you are dynamically adding and removing videos\n   * to/from the DOM.\n   *\n   * @fires Player#dispose\n   */\n\n\n  Player.prototype.dispose = function dispose() {\n    /**\n     * Called when the player is being disposed of.\n     *\n     * @event Player#dispose\n     * @type {EventTarget~Event}\n     */\n    this.trigger('dispose');\n    // prevent dispose from being called twice\n    this.off('dispose');\n\n    if (this.styleEl_ && this.styleEl_.parentNode) {\n      this.styleEl_.parentNode.removeChild(this.styleEl_);\n      this.styleEl_ = null;\n    }\n\n    // Kill reference to this player\n    Player.players[this.id_] = null;\n\n    if (this.tag && this.tag.player) {\n      this.tag.player = null;\n    }\n\n    if (this.el_ && this.el_.player) {\n      this.el_.player = null;\n    }\n\n    if (this.tech_) {\n      this.tech_.dispose();\n    }\n\n    if (this.playerElIngest_) {\n      this.playerElIngest_ = null;\n    }\n\n    if (this.tag) {\n      this.tag = null;\n    }\n\n    // the actual .el_ is removed here\n    _Component.prototype.dispose.call(this);\n  };\n\n  /**\n   * Create the `Player`'s DOM element.\n   *\n   * @return {Element}\n   *         The DOM element that gets created.\n   */\n\n\n  Player.prototype.createEl = function createEl$$1() {\n    var tag = this.tag;\n    var el = void 0;\n    var playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute('data-vjs-player');\n    var divEmbed = this.tag.tagName.toLowerCase() === 'video-js';\n\n    if (playerElIngest) {\n      el = this.el_ = tag.parentNode;\n    } else if (!divEmbed) {\n      el = this.el_ = _Component.prototype.createEl.call(this, 'div');\n    }\n\n    // Copy over all the attributes from the tag, including ID and class\n    // ID will now reference player box, not the video tag\n    var attrs = getAttributes(tag);\n\n    if (divEmbed) {\n      el = this.el_ = tag;\n      tag = this.tag = document.createElement('video');\n      while (el.children.length) {\n        tag.appendChild(el.firstChild);\n      }\n\n      if (!hasClass(el, 'video-js')) {\n        addClass(el, 'video-js');\n      }\n\n      el.appendChild(tag);\n\n      playerElIngest = this.playerElIngest_ = el;\n    }\n\n    // set tabindex to -1 so we could focus on the player element\n    tag.setAttribute('tabindex', '-1');\n\n    // Remove width/height attrs from tag so CSS can make it 100% width/height\n    tag.removeAttribute('width');\n    tag.removeAttribute('height');\n\n    Object.getOwnPropertyNames(attrs).forEach(function (attr) {\n      // workaround so we don't totally break IE7\n      // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7\n      if (attr === 'class') {\n        el.className += ' ' + attrs[attr];\n\n        if (divEmbed) {\n          tag.className += ' ' + attrs[attr];\n        }\n      } else {\n        el.setAttribute(attr, attrs[attr]);\n\n        if (divEmbed) {\n          tag.setAttribute(attr, attrs[attr]);\n        }\n      }\n    });\n\n    // Update tag id/class for use as HTML5 playback tech\n    // Might think we should do this after embedding in container so .vjs-tech class\n    // doesn't flash 100% width/height, but class only applies with .video-js parent\n    tag.playerId = tag.id;\n    tag.id += '_html5_api';\n    tag.className = 'vjs-tech';\n\n    // Make player findable on elements\n    tag.player = el.player = this;\n    // Default state of video is paused\n    this.addClass('vjs-paused');\n\n    // Add a style element in the player that we'll use to set the width/height\n    // of the player in a way that's still overrideable by CSS, just like the\n    // video element\n    if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true) {\n      this.styleEl_ = createStyleElement('vjs-styles-dimensions');\n      var defaultsStyleEl = $('.vjs-styles-defaults');\n      var head = $('head');\n\n      head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);\n    }\n\n    // Pass in the width/height/aspectRatio options which will update the style el\n    this.width(this.options_.width);\n    this.height(this.options_.height);\n    this.fluid(this.options_.fluid);\n    this.aspectRatio(this.options_.aspectRatio);\n\n    // Hide any links within the video/audio tag, because IE doesn't hide them completely.\n    var links = tag.getElementsByTagName('a');\n\n    for (var i = 0; i < links.length; i++) {\n      var linkEl = links.item(i);\n\n      addClass(linkEl, 'vjs-hidden');\n      linkEl.setAttribute('hidden', 'hidden');\n    }\n\n    // insertElFirst seems to cause the networkState to flicker from 3 to 2, so\n    // keep track of the original for later so we can know if the source originally failed\n    tag.initNetworkState_ = tag.networkState;\n\n    // Wrap video tag in div (el/box) container\n    if (tag.parentNode && !playerElIngest) {\n      tag.parentNode.insertBefore(el, tag);\n    }\n\n    // insert the tag as the first child of the player element\n    // then manually add it to the children array so that this.addChild\n    // will work properly for other components\n    //\n    // Breaks iPhone, fixed in HTML5 setup.\n    prependTo(tag, el);\n    this.children_.unshift(tag);\n\n    // Set lang attr on player to ensure CSS :lang() in consistent with player\n    // if it's been set to something different to the doc\n    this.el_.setAttribute('lang', this.language_);\n\n    this.el_ = el;\n\n    return el;\n  };\n\n  /**\n   * A getter/setter for the `Player`'s width. Returns the player's configured value.\n   * To get the current width use `currentWidth()`.\n   *\n   * @param {number} [value]\n   *        The value to set the `Player`'s width to.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the playerresize event trigger\n   *\n   * @return {number}\n   *         The current width of the `Player` when getting.\n   */\n\n\n  Player.prototype.width = function width(value, skipListeners) {\n    return this.dimension('width', value, skipListeners);\n  };\n\n  /**\n   * A getter/setter for the `Player`'s height. Returns the player's configured value.\n   * To get the current height use `currentheight()`.\n   *\n   * @param {number} [value]\n   *        The value to set the `Player`'s heigth to.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the playerresize event trigger\n   *\n   * @return {number}\n   *         The current height of the `Player` when getting.\n   */\n\n\n  Player.prototype.height = function height(value, skipListeners) {\n    return this.dimension('height', value, skipListeners);\n  };\n\n  /**\n   * A getter/setter for the `Player`'s width & height.\n   *\n   * @fires Player#playerresize\n   *\n   * @param {string} dimension\n   *        This string can be:\n   *        - 'width'\n   *        - 'height'\n   *\n   * @param {number} [value]\n   *        Value for dimension specified in the first argument.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the playerresize event trigger\n   *\n   * @return {number}\n   *         The dimension arguments value when getting (width/height).\n   */\n\n\n  Player.prototype.dimension = function dimension(_dimension, value, skipListeners) {\n    var privDimension = _dimension + '_';\n\n    if (value === undefined) {\n      return this[privDimension] || 0;\n    }\n\n    if (value === '') {\n      // If an empty string is given, reset the dimension to be automatic\n      this[privDimension] = undefined;\n      this.updateStyleEl_();\n      return;\n    }\n\n    var parsedVal = parseFloat(value);\n\n    if (isNaN(parsedVal)) {\n      log$1.error('Improper value \"' + value + '\" supplied for for ' + _dimension);\n      return;\n    }\n\n    this[privDimension] = parsedVal;\n    this.updateStyleEl_();\n\n    // skipListeners allows us to avoid triggering the resize event when setting both width and height\n    if (this.isReady_ && !skipListeners) {\n      /**\n       * Triggered when the player is resized.\n       *\n       * @event Player#playerresize\n       * @type {EventTarget~Event}\n       */\n      this.trigger('playerresize');\n    }\n  };\n\n  /**\n   * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.\n   *\n   * @param {boolean} [bool]\n   *        - A value of true adds the class.\n   *        - A value of false removes the class.\n   *        - No value will toggle the fluid class.\n   *\n   * @return {boolean|undefined}\n   *         - The value of fluid when getting.\n   *         - `undefined` when setting.\n   */\n\n\n  Player.prototype.fluid = function fluid(bool) {\n    if (bool === undefined) {\n      return !!this.fluid_;\n    }\n\n    this.fluid_ = !!bool;\n\n    if (bool) {\n      this.addClass('vjs-fluid');\n    } else {\n      this.removeClass('vjs-fluid');\n    }\n\n    this.updateStyleEl_();\n  };\n\n  /**\n   * Get/Set the aspect ratio\n   *\n   * @param {string} [ratio]\n   *        Aspect ratio for player\n   *\n   * @return {string|undefined}\n   *         returns the current aspect ratio when getting\n   */\n\n  /**\n   * A getter/setter for the `Player`'s aspect ratio.\n   *\n   * @param {string} [ratio]\n   *        The value to set the `Player's aspect ratio to.\n   *\n   * @return {string|undefined}\n   *         - The current aspect ratio of the `Player` when getting.\n   *         - undefined when setting\n   */\n\n\n  Player.prototype.aspectRatio = function aspectRatio(ratio) {\n    if (ratio === undefined) {\n      return this.aspectRatio_;\n    }\n\n    // Check for width:height format\n    if (!/^\\d+\\:\\d+$/.test(ratio)) {\n      throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');\n    }\n    this.aspectRatio_ = ratio;\n\n    // We're assuming if you set an aspect ratio you want fluid mode,\n    // because in fixed mode you could calculate width and height yourself.\n    this.fluid(true);\n\n    this.updateStyleEl_();\n  };\n\n  /**\n   * Update styles of the `Player` element (height, width and aspect ratio).\n   *\n   * @private\n   * @listens Tech#loadedmetadata\n   */\n\n\n  Player.prototype.updateStyleEl_ = function updateStyleEl_() {\n    if (window.VIDEOJS_NO_DYNAMIC_STYLE === true) {\n      var _width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;\n      var _height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;\n      var techEl = this.tech_ && this.tech_.el();\n\n      if (techEl) {\n        if (_width >= 0) {\n          techEl.width = _width;\n        }\n        if (_height >= 0) {\n          techEl.height = _height;\n        }\n      }\n\n      return;\n    }\n\n    var width = void 0;\n    var height = void 0;\n    var aspectRatio = void 0;\n    var idClass = void 0;\n\n    // The aspect ratio is either used directly or to calculate width and height.\n    if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {\n      // Use any aspectRatio that's been specifically set\n      aspectRatio = this.aspectRatio_;\n    } else if (this.videoWidth() > 0) {\n      // Otherwise try to get the aspect ratio from the video metadata\n      aspectRatio = this.videoWidth() + ':' + this.videoHeight();\n    } else {\n      // Or use a default. The video element's is 2:1, but 16:9 is more common.\n      aspectRatio = '16:9';\n    }\n\n    // Get the ratio as a decimal we can use to calculate dimensions\n    var ratioParts = aspectRatio.split(':');\n    var ratioMultiplier = ratioParts[1] / ratioParts[0];\n\n    if (this.width_ !== undefined) {\n      // Use any width that's been specifically set\n      width = this.width_;\n    } else if (this.height_ !== undefined) {\n      // Or calulate the width from the aspect ratio if a height has been set\n      width = this.height_ / ratioMultiplier;\n    } else {\n      // Or use the video's metadata, or use the video el's default of 300\n      width = this.videoWidth() || 300;\n    }\n\n    if (this.height_ !== undefined) {\n      // Use any height that's been specifically set\n      height = this.height_;\n    } else {\n      // Otherwise calculate the height from the ratio and the width\n      height = width * ratioMultiplier;\n    }\n\n    // Ensure the CSS class is valid by starting with an alpha character\n    if (/^[^a-zA-Z]/.test(this.id())) {\n      idClass = 'dimensions-' + this.id();\n    } else {\n      idClass = this.id() + '-dimensions';\n    }\n\n    // Ensure the right class is still on the player for the style element\n    this.addClass(idClass);\n\n    setTextContent(this.styleEl_, '\\n      .' + idClass + ' {\\n        width: ' + width + 'px;\\n        height: ' + height + 'px;\\n      }\\n\\n      .' + idClass + '.vjs-fluid {\\n        padding-top: ' + ratioMultiplier * 100 + '%;\\n      }\\n    ');\n  };\n\n  /**\n   * Load/Create an instance of playback {@link Tech} including element\n   * and API methods. Then append the `Tech` element in `Player` as a child.\n   *\n   * @param {string} techName\n   *        name of the playback technology\n   *\n   * @param {string} source\n   *        video source\n   *\n   * @private\n   */\n\n\n  Player.prototype.loadTech_ = function loadTech_(techName, source) {\n    var _this2 = this;\n\n    // Pause and remove current playback technology\n    if (this.tech_) {\n      this.unloadTech_();\n    }\n\n    var titleTechName = toTitleCase(techName);\n    var camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);\n\n    // get rid of the HTML5 video tag as soon as we are using another tech\n    if (titleTechName !== 'Html5' && this.tag) {\n      Tech.getTech('Html5').disposeMediaElement(this.tag);\n      this.tag.player = null;\n      this.tag = null;\n    }\n\n    this.techName_ = titleTechName;\n\n    // Turn off API access because we're loading a new tech that might load asynchronously\n    this.isReady_ = false;\n\n    // Grab tech-specific options from player options and add source and parent element to use.\n    var techOptions = {\n      source: source,\n      'nativeControlsForTouch': this.options_.nativeControlsForTouch,\n      'playerId': this.id(),\n      'techId': this.id() + '_' + titleTechName + '_api',\n      'autoplay': this.options_.autoplay,\n      'playsinline': this.options_.playsinline,\n      'preload': this.options_.preload,\n      'loop': this.options_.loop,\n      'muted': this.options_.muted,\n      'poster': this.poster(),\n      'language': this.language(),\n      'playerElIngest': this.playerElIngest_ || false,\n      'vtt.js': this.options_['vtt.js']\n    };\n\n    ALL.names.forEach(function (name$$1) {\n      var props = ALL[name$$1];\n\n      techOptions[props.getterName] = _this2[props.privateName];\n    });\n\n    assign(techOptions, this.options_[titleTechName]);\n    assign(techOptions, this.options_[camelTechName]);\n    assign(techOptions, this.options_[techName.toLowerCase()]);\n\n    if (this.tag) {\n      techOptions.tag = this.tag;\n    }\n\n    if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {\n      techOptions.startTime = this.cache_.currentTime;\n    }\n\n    // Initialize tech instance\n    var TechClass = Tech.getTech(techName);\n\n    if (!TechClass) {\n      throw new Error('No Tech named \\'' + titleTechName + '\\' exists! \\'' + titleTechName + '\\' should be registered using videojs.registerTech()\\'');\n    }\n\n    this.tech_ = new TechClass(techOptions);\n\n    // player.triggerReady is always async, so don't need this to be async\n    this.tech_.ready(bind(this, this.handleTechReady_), true);\n\n    textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);\n\n    // Listen to all HTML5-defined events and trigger them on the player\n    TECH_EVENTS_RETRIGGER.forEach(function (event) {\n      _this2.on(_this2.tech_, event, _this2['handleTech' + toTitleCase(event) + '_']);\n    });\n    this.on(this.tech_, 'loadstart', this.handleTechLoadStart_);\n    this.on(this.tech_, 'waiting', this.handleTechWaiting_);\n    this.on(this.tech_, 'canplay', this.handleTechCanPlay_);\n    this.on(this.tech_, 'canplaythrough', this.handleTechCanPlayThrough_);\n    this.on(this.tech_, 'playing', this.handleTechPlaying_);\n    this.on(this.tech_, 'ended', this.handleTechEnded_);\n    this.on(this.tech_, 'seeking', this.handleTechSeeking_);\n    this.on(this.tech_, 'seeked', this.handleTechSeeked_);\n    this.on(this.tech_, 'play', this.handleTechPlay_);\n    this.on(this.tech_, 'firstplay', this.handleTechFirstPlay_);\n    this.on(this.tech_, 'pause', this.handleTechPause_);\n    this.on(this.tech_, 'durationchange', this.handleTechDurationChange_);\n    this.on(this.tech_, 'fullscreenchange', this.handleTechFullscreenChange_);\n    this.on(this.tech_, 'error', this.handleTechError_);\n    this.on(this.tech_, 'loadedmetadata', this.updateStyleEl_);\n    this.on(this.tech_, 'posterchange', this.handleTechPosterChange_);\n    this.on(this.tech_, 'textdata', this.handleTechTextData_);\n\n    this.usingNativeControls(this.techGet_('controls'));\n\n    if (this.controls() && !this.usingNativeControls()) {\n      this.addTechControlsListeners_();\n    }\n\n    // Add the tech element in the DOM if it was not already there\n    // Make sure to not insert the original video element if using Html5\n    if (this.tech_.el().parentNode !== this.el() && (titleTechName !== 'Html5' || !this.tag)) {\n      prependTo(this.tech_.el(), this.el());\n    }\n\n    // Get rid of the original video tag reference after the first tech is loaded\n    if (this.tag) {\n      this.tag.player = null;\n      this.tag = null;\n    }\n  };\n\n  /**\n   * Unload and dispose of the current playback {@link Tech}.\n   *\n   * @private\n   */\n\n\n  Player.prototype.unloadTech_ = function unloadTech_() {\n    var _this3 = this;\n\n    // Save the current text tracks so that we can reuse the same text tracks with the next tech\n    ALL.names.forEach(function (name$$1) {\n      var props = ALL[name$$1];\n\n      _this3[props.privateName] = _this3[props.getterName]();\n    });\n    this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);\n\n    this.isReady_ = false;\n\n    this.tech_.dispose();\n\n    this.tech_ = false;\n  };\n\n  /**\n   * Return a reference to the current {@link Tech}.\n   * It will print a warning by default about the danger of using the tech directly\n   * but any argument that is passed in will silence the warning.\n   *\n   * @param {*} [safety]\n   *        Anything passed in to silence the warning\n   *\n   * @return {Tech}\n   *         The Tech\n   */\n\n\n  Player.prototype.tech = function tech(safety) {\n    if (safety === undefined) {\n      log$1.warn(tsml(_templateObject$1));\n    }\n\n    return this.tech_;\n  };\n\n  /**\n   * Set up click and touch listeners for the playback element\n   *\n   * - On desktops: a click on the video itself will toggle playback\n   * - On mobile devices: a click on the video toggles controls\n   *   which is done by toggling the user state between active and\n   *   inactive\n   * - A tap can signal that a user has become active or has become inactive\n   *   e.g. a quick tap on an iPhone movie should reveal the controls. Another\n   *   quick tap should hide them again (signaling the user is in an inactive\n   *   viewing state)\n   * - In addition to this, we still want the user to be considered inactive after\n   *   a few seconds of inactivity.\n   *\n   * > Note: the only part of iOS interaction we can't mimic with this setup\n   * is a touch and hold on the video element counting as activity in order to\n   * keep the controls showing, but that shouldn't be an issue. A touch and hold\n   * on any controls will still keep the user active\n   *\n   * @private\n   */\n\n\n  Player.prototype.addTechControlsListeners_ = function addTechControlsListeners_() {\n    // Make sure to remove all the previous listeners in case we are called multiple times.\n    this.removeTechControlsListeners_();\n\n    // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do\n    // trigger mousedown/up.\n    // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object\n    // Any touch events are set to block the mousedown event from happening\n    this.on(this.tech_, 'mousedown', this.handleTechClick_);\n\n    // If the controls were hidden we don't want that to change without a tap event\n    // so we'll check if the controls were already showing before reporting user\n    // activity\n    this.on(this.tech_, 'touchstart', this.handleTechTouchStart_);\n    this.on(this.tech_, 'touchmove', this.handleTechTouchMove_);\n    this.on(this.tech_, 'touchend', this.handleTechTouchEnd_);\n\n    // The tap listener needs to come after the touchend listener because the tap\n    // listener cancels out any reportedUserActivity when setting userActive(false)\n    this.on(this.tech_, 'tap', this.handleTechTap_);\n  };\n\n  /**\n   * Remove the listeners used for click and tap controls. This is needed for\n   * toggling to controls disabled, where a tap/touch should do nothing.\n   *\n   * @private\n   */\n\n\n  Player.prototype.removeTechControlsListeners_ = function removeTechControlsListeners_() {\n    // We don't want to just use `this.off()` because there might be other needed\n    // listeners added by techs that extend this.\n    this.off(this.tech_, 'tap', this.handleTechTap_);\n    this.off(this.tech_, 'touchstart', this.handleTechTouchStart_);\n    this.off(this.tech_, 'touchmove', this.handleTechTouchMove_);\n    this.off(this.tech_, 'touchend', this.handleTechTouchEnd_);\n    this.off(this.tech_, 'mousedown', this.handleTechClick_);\n  };\n\n  /**\n   * Player waits for the tech to be ready\n   *\n   * @private\n   */\n\n\n  Player.prototype.handleTechReady_ = function handleTechReady_() {\n    this.triggerReady();\n\n    // Keep the same volume as before\n    if (this.cache_.volume) {\n      this.techCall_('setVolume', this.cache_.volume);\n    }\n\n    // Look if the tech found a higher resolution poster while loading\n    this.handleTechPosterChange_();\n\n    // Update the duration if available\n    this.handleTechDurationChange_();\n\n    // Chrome and Safari both have issues with autoplay.\n    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.\n    // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)\n    // This fixes both issues. Need to wait for API, so it updates displays correctly\n    if ((this.src() || this.currentSrc()) && this.tag && this.options_.autoplay && this.paused()) {\n      try {\n        // Chrome Fix. Fixed in Chrome v16.\n        delete this.tag.poster;\n      } catch (e) {\n        log$1('deleting tag.poster throws in some browsers', e);\n      }\n    }\n  };\n\n  /**\n   * Retrigger the `loadstart` event that was triggered by the {@link Tech}. This\n   * function will also trigger {@link Player#firstplay} if it is the first loadstart\n   * for a video.\n   *\n   * @fires Player#loadstart\n   * @fires Player#firstplay\n   * @listens Tech#loadstart\n   * @private\n   */\n\n\n  Player.prototype.handleTechLoadStart_ = function handleTechLoadStart_() {\n    // TODO: Update to use `emptied` event instead. See #1277.\n\n    this.removeClass('vjs-ended');\n    this.removeClass('vjs-seeking');\n\n    // reset the error state\n    this.error(null);\n\n    // If it's already playing we want to trigger a firstplay event now.\n    // The firstplay event relies on both the play and loadstart events\n    // which can happen in any order for a new source\n    if (!this.paused()) {\n      /**\n       * Fired when the user agent begins looking for media data\n       *\n       * @event Player#loadstart\n       * @type {EventTarget~Event}\n       */\n      this.trigger('loadstart');\n      this.trigger('firstplay');\n    } else {\n      // reset the hasStarted state\n      this.hasStarted(false);\n      this.trigger('loadstart');\n    }\n  };\n\n  /**\n   * Add/remove the vjs-has-started class\n   *\n   * @fires Player#firstplay\n   *\n   * @param {boolean} request\n   *        - true: adds the class\n   *        - false: remove the class\n   *\n   * @return {boolean}\n   *         the boolean value of hasStarted_\n   */\n\n\n  Player.prototype.hasStarted = function hasStarted(request) {\n    if (request === undefined) {\n      // act as getter, if we have no request to change\n      return this.hasStarted_;\n    }\n\n    if (request === this.hasStarted_) {\n      return;\n    }\n\n    this.hasStarted_ = request;\n\n    if (this.hasStarted_) {\n      this.addClass('vjs-has-started');\n      this.trigger('firstplay');\n    } else {\n      this.removeClass('vjs-has-started');\n    }\n  };\n\n  /**\n   * Fired whenever the media begins or resumes playback\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}\n   * @fires Player#play\n   * @listens Tech#play\n   * @private\n   */\n\n\n  Player.prototype.handleTechPlay_ = function handleTechPlay_() {\n    this.removeClass('vjs-ended');\n    this.removeClass('vjs-paused');\n    this.addClass('vjs-playing');\n\n    // hide the poster when the user hits play\n    this.hasStarted(true);\n    /**\n     * Triggered whenever an {@link Tech#play} event happens. Indicates that\n     * playback has started or resumed.\n     *\n     * @event Player#play\n     * @type {EventTarget~Event}\n     */\n    this.trigger('play');\n  };\n\n  /**\n   * Retrigger the `waiting` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#waiting\n   * @listens Tech#waiting\n   * @private\n   */\n\n\n  Player.prototype.handleTechWaiting_ = function handleTechWaiting_() {\n    var _this4 = this;\n\n    this.addClass('vjs-waiting');\n    /**\n     * A readyState change on the DOM element has caused playback to stop.\n     *\n     * @event Player#waiting\n     * @type {EventTarget~Event}\n     */\n    this.trigger('waiting');\n    this.one('timeupdate', function () {\n      return _this4.removeClass('vjs-waiting');\n    });\n  };\n\n  /**\n   * Retrigger the `canplay` event that was triggered by the {@link Tech}.\n   * > Note: This is not consistent between browsers. See #1351\n   *\n   * @fires Player#canplay\n   * @listens Tech#canplay\n   * @private\n   */\n\n\n  Player.prototype.handleTechCanPlay_ = function handleTechCanPlay_() {\n    this.removeClass('vjs-waiting');\n    /**\n     * The media has a readyState of HAVE_FUTURE_DATA or greater.\n     *\n     * @event Player#canplay\n     * @type {EventTarget~Event}\n     */\n    this.trigger('canplay');\n  };\n\n  /**\n   * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#canplaythrough\n   * @listens Tech#canplaythrough\n   * @private\n   */\n\n\n  Player.prototype.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {\n    this.removeClass('vjs-waiting');\n    /**\n     * The media has a readyState of HAVE_ENOUGH_DATA or greater. This means that the\n     * entire media file can be played without buffering.\n     *\n     * @event Player#canplaythrough\n     * @type {EventTarget~Event}\n     */\n    this.trigger('canplaythrough');\n  };\n\n  /**\n   * Retrigger the `playing` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#playing\n   * @listens Tech#playing\n   * @private\n   */\n\n\n  Player.prototype.handleTechPlaying_ = function handleTechPlaying_() {\n    this.removeClass('vjs-waiting');\n    /**\n     * The media is no longer blocked from playback, and has started playing.\n     *\n     * @event Player#playing\n     * @type {EventTarget~Event}\n     */\n    this.trigger('playing');\n  };\n\n  /**\n   * Retrigger the `seeking` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#seeking\n   * @listens Tech#seeking\n   * @private\n   */\n\n\n  Player.prototype.handleTechSeeking_ = function handleTechSeeking_() {\n    this.addClass('vjs-seeking');\n    /**\n     * Fired whenever the player is jumping to a new time\n     *\n     * @event Player#seeking\n     * @type {EventTarget~Event}\n     */\n    this.trigger('seeking');\n  };\n\n  /**\n   * Retrigger the `seeked` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#seeked\n   * @listens Tech#seeked\n   * @private\n   */\n\n\n  Player.prototype.handleTechSeeked_ = function handleTechSeeked_() {\n    this.removeClass('vjs-seeking');\n    /**\n     * Fired when the player has finished jumping to a new time\n     *\n     * @event Player#seeked\n     * @type {EventTarget~Event}\n     */\n    this.trigger('seeked');\n  };\n\n  /**\n   * Retrigger the `firstplay` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#firstplay\n   * @listens Tech#firstplay\n   * @deprecated As of 6.0 firstplay event is deprecated.\n   * @deprecated As of 6.0 passing the `starttime` option to the player and the firstplay event are deprecated.\n   * @private\n   */\n\n\n  Player.prototype.handleTechFirstPlay_ = function handleTechFirstPlay_() {\n    // If the first starttime attribute is specified\n    // then we will start at the given offset in seconds\n    if (this.options_.starttime) {\n      log$1.warn('Passing the `starttime` option to the player will be deprecated in 6.0');\n      this.currentTime(this.options_.starttime);\n    }\n\n    this.addClass('vjs-has-started');\n    /**\n     * Fired the first time a video is played. Not part of the HLS spec, and this is\n     * probably not the best implementation yet, so use sparingly. If you don't have a\n     * reason to prevent playback, use `myPlayer.one('play');` instead.\n     *\n     * @event Player#firstplay\n     * @deprecated As of 6.0 firstplay event is deprecated.\n     * @type {EventTarget~Event}\n     */\n    this.trigger('firstplay');\n  };\n\n  /**\n   * Retrigger the `pause` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#pause\n   * @listens Tech#pause\n   * @private\n   */\n\n\n  Player.prototype.handleTechPause_ = function handleTechPause_() {\n    this.removeClass('vjs-playing');\n    this.addClass('vjs-paused');\n    /**\n     * Fired whenever the media has been paused\n     *\n     * @event Player#pause\n     * @type {EventTarget~Event}\n     */\n    this.trigger('pause');\n  };\n\n  /**\n   * Retrigger the `ended` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#ended\n   * @listens Tech#ended\n   * @private\n   */\n\n\n  Player.prototype.handleTechEnded_ = function handleTechEnded_() {\n    this.addClass('vjs-ended');\n    if (this.options_.loop) {\n      this.currentTime(0);\n      this.play();\n    } else if (!this.paused()) {\n      this.pause();\n    }\n\n    /**\n     * Fired when the end of the media resource is reached (currentTime == duration)\n     *\n     * @event Player#ended\n     * @type {EventTarget~Event}\n     */\n    this.trigger('ended');\n  };\n\n  /**\n   * Fired when the duration of the media resource is first known or changed\n   *\n   * @listens Tech#durationchange\n   * @private\n   */\n\n\n  Player.prototype.handleTechDurationChange_ = function handleTechDurationChange_() {\n    this.duration(this.techGet_('duration'));\n  };\n\n  /**\n   * Handle a click on the media element to play/pause\n   *\n   * @param {EventTarget~Event} event\n   *        the event that caused this function to trigger\n   *\n   * @listens Tech#mousedown\n   * @private\n   */\n\n\n  Player.prototype.handleTechClick_ = function handleTechClick_(event) {\n    if (!isSingleLeftClick(event)) {\n      return;\n    }\n\n    // When controls are disabled a click should not toggle playback because\n    // the click is considered a control\n    if (!this.controls_) {\n      return;\n    }\n\n    if (this.paused()) {\n      this.play();\n    } else {\n      this.pause();\n    }\n  };\n\n  /**\n   * Handle a tap on the media element. It will toggle the user\n   * activity state, which hides and shows the controls.\n   *\n   * @listens Tech#tap\n   * @private\n   */\n\n\n  Player.prototype.handleTechTap_ = function handleTechTap_() {\n    this.userActive(!this.userActive());\n  };\n\n  /**\n   * Handle touch to start\n   *\n   * @listens Tech#touchstart\n   * @private\n   */\n\n\n  Player.prototype.handleTechTouchStart_ = function handleTechTouchStart_() {\n    this.userWasActive = this.userActive();\n  };\n\n  /**\n   * Handle touch to move\n   *\n   * @listens Tech#touchmove\n   * @private\n   */\n\n\n  Player.prototype.handleTechTouchMove_ = function handleTechTouchMove_() {\n    if (this.userWasActive) {\n      this.reportUserActivity();\n    }\n  };\n\n  /**\n   * Handle touch to end\n   *\n   * @param {EventTarget~Event} event\n   *        the touchend event that triggered\n   *        this function\n   *\n   * @listens Tech#touchend\n   * @private\n   */\n\n\n  Player.prototype.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {\n    // Stop the mouse events from also happening\n    event.preventDefault();\n  };\n\n  /**\n   * Fired when the player switches in or out of fullscreen mode\n   *\n   * @private\n   * @listens Player#fullscreenchange\n   */\n\n\n  Player.prototype.handleFullscreenChange_ = function handleFullscreenChange_() {\n    if (this.isFullscreen()) {\n      this.addClass('vjs-fullscreen');\n    } else {\n      this.removeClass('vjs-fullscreen');\n    }\n  };\n\n  /**\n   * native click events on the SWF aren't triggered on IE11, Win8.1RT\n   * use stageclick events triggered from inside the SWF instead\n   *\n   * @private\n   * @listens stageclick\n   */\n\n\n  Player.prototype.handleStageClick_ = function handleStageClick_() {\n    this.reportUserActivity();\n  };\n\n  /**\n   * Handle Tech Fullscreen Change\n   *\n   * @param {EventTarget~Event} event\n   *        the fullscreenchange event that triggered this function\n   *\n   * @param {Object} data\n   *        the data that was sent with the event\n   *\n   * @private\n   * @listens Tech#fullscreenchange\n   * @fires Player#fullscreenchange\n   */\n\n\n  Player.prototype.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {\n    if (data) {\n      this.isFullscreen(data.isFullscreen);\n    }\n    /**\n     * Fired when going in and out of fullscreen.\n     *\n     * @event Player#fullscreenchange\n     * @type {EventTarget~Event}\n     */\n    this.trigger('fullscreenchange');\n  };\n\n  /**\n   * Fires when an error occurred during the loading of an audio/video.\n   *\n   * @private\n   * @listens Tech#error\n   */\n\n\n  Player.prototype.handleTechError_ = function handleTechError_() {\n    var error = this.tech_.error();\n\n    this.error(error);\n  };\n\n  /**\n   * Retrigger the `textdata` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#textdata\n   * @listens Tech#textdata\n   * @private\n   */\n\n\n  Player.prototype.handleTechTextData_ = function handleTechTextData_() {\n    var data = null;\n\n    if (arguments.length > 1) {\n      data = arguments[1];\n    }\n\n    /**\n     * Fires when we get a textdata event from tech\n     *\n     * @event Player#textdata\n     * @type {EventTarget~Event}\n     */\n    this.trigger('textdata', data);\n  };\n\n  /**\n   * Get object for cached values.\n   *\n   * @return {Object}\n   *         get the current object cache\n   */\n\n\n  Player.prototype.getCache = function getCache() {\n    return this.cache_;\n  };\n\n  /**\n   * Pass values to the playback tech\n   *\n   * @param {string} [method]\n   *        the method to call\n   *\n   * @param {Object} arg\n   *        the argument to pass\n   *\n   * @private\n   */\n\n\n  Player.prototype.techCall_ = function techCall_(method, arg) {\n    // If it's not ready yet, call method when it is\n\n    this.ready(function () {\n      if (method in allowedSetters) {\n        return set$1(this.middleware_, this.tech_, method, arg);\n      }\n\n      try {\n        if (this.tech_) {\n          this.tech_[method](arg);\n        }\n      } catch (e) {\n        log$1(e);\n        throw e;\n      }\n    }, true);\n  };\n\n  /**\n   * Get calls can't wait for the tech, and sometimes don't need to.\n   *\n   * @param {string} method\n   *        Tech method\n   *\n   * @return {Function|undefined}\n   *         the method or undefined\n   *\n   * @private\n   */\n\n\n  Player.prototype.techGet_ = function techGet_(method) {\n    if (!this.tech_ || !this.tech_.isReady_) {\n      return;\n    }\n\n    if (method in allowedGetters) {\n      return get$1(this.middleware_, this.tech_, method);\n    }\n\n    // Flash likes to die and reload when you hide or reposition it.\n    // In these cases the object methods go away and we get errors.\n    // When that happens we'll catch the errors and inform tech that it's not ready any more.\n    try {\n      return this.tech_[method]();\n    } catch (e) {\n\n      // When building additional tech libs, an expected method may not be defined yet\n      if (this.tech_[method] === undefined) {\n        log$1('Video.js: ' + method + ' method not defined for ' + this.techName_ + ' playback technology.', e);\n        throw e;\n      }\n\n      // When a method isn't available on the object it throws a TypeError\n      if (e.name === 'TypeError') {\n        log$1('Video.js: ' + method + ' unavailable on ' + this.techName_ + ' playback technology element.', e);\n        this.tech_.isReady_ = false;\n        throw e;\n      }\n\n      // If error unknown, just log and throw\n      log$1(e);\n      throw e;\n    }\n  };\n\n  /**\n   * Attempt to begin playback at the first opportunity.\n   *\n   * @return {Promise|undefined}\n   *         Returns a `Promise` only if the browser returns one and the player\n   *         is ready to begin playback. For some browsers and all non-ready\n   *         situations, this will return `undefined`.\n   */\n\n\n  Player.prototype.play = function play() {\n    var _this5 = this;\n\n    // If this is called while we have a play queued up on a loadstart, remove\n    // that listener to avoid getting in a potentially bad state.\n    if (this.playOnLoadstart_) {\n      this.off('loadstart', this.playOnLoadstart_);\n    }\n\n    // If the player/tech is not ready, queue up another call to `play()` for\n    // when it is. This will loop back into this method for another attempt at\n    // playback when the tech is ready.\n    if (!this.isReady_) {\n\n      // Bail out if we're already waiting for `ready`!\n      if (this.playWaitingForReady_) {\n        return;\n      }\n\n      this.playWaitingForReady_ = true;\n      this.ready(function () {\n        _this5.playWaitingForReady_ = false;\n        silencePromise(_this5.play());\n      });\n\n      // If the player/tech is ready and we have a source, we can attempt playback.\n    } else if (!this.changingSrc_ && (this.src() || this.currentSrc())) {\n      return this.techGet_('play');\n\n      // If the tech is ready, but we do not have a source, we'll need to wait\n      // for both the `ready` and a `loadstart` when the source is finally\n      // resolved by middleware and set on the player.\n      //\n      // This can happen if `play()` is called while changing sources or before\n      // one has been set on the player.\n    } else {\n\n      this.playOnLoadstart_ = function () {\n        _this5.playOnLoadstart_ = null;\n        silencePromise(_this5.play());\n      };\n\n      this.one('loadstart', this.playOnLoadstart_);\n    }\n  };\n\n  /**\n   * Pause the video playback\n   *\n   * @return {Player}\n   *         A reference to the player object this function was called on\n   */\n\n\n  Player.prototype.pause = function pause() {\n    this.techCall_('pause');\n  };\n\n  /**\n   * Check if the player is paused or has yet to play\n   *\n   * @return {boolean}\n   *         - false: if the media is currently playing\n   *         - true: if media is not currently playing\n   */\n\n\n  Player.prototype.paused = function paused() {\n    // The initial state of paused should be true (in Safari it's actually false)\n    return this.techGet_('paused') === false ? false : true;\n  };\n\n  /**\n   * Get a TimeRange object representing the current ranges of time that the user\n   * has played.\n   *\n   * @return {TimeRange}\n   *         A time range object that represents all the increments of time that have\n   *         been played.\n   */\n\n\n  Player.prototype.played = function played() {\n    return this.techGet_('played') || createTimeRanges(0, 0);\n  };\n\n  /**\n   * Returns whether or not the user is \"scrubbing\". Scrubbing is\n   * when the user has clicked the progress bar handle and is\n   * dragging it along the progress bar.\n   *\n   * @param {boolean} [isScrubbing]\n   *        wether the user is or is not scrubbing\n   *\n   * @return {boolean}\n   *         The value of scrubbing when getting\n   */\n\n\n  Player.prototype.scrubbing = function scrubbing(isScrubbing) {\n    if (typeof isScrubbing === 'undefined') {\n      return this.scrubbing_;\n    }\n    this.scrubbing_ = !!isScrubbing;\n\n    if (isScrubbing) {\n      this.addClass('vjs-scrubbing');\n    } else {\n      this.removeClass('vjs-scrubbing');\n    }\n  };\n\n  /**\n   * Get or set the current time (in seconds)\n   *\n   * @param {number|string} [seconds]\n   *        The time to seek to in seconds\n   *\n   * @return {number}\n   *         - the current time in seconds when getting\n   */\n\n\n  Player.prototype.currentTime = function currentTime(seconds) {\n    if (typeof seconds !== 'undefined') {\n      if (seconds < 0) {\n        seconds = 0;\n      }\n      this.techCall_('setCurrentTime', seconds);\n      return;\n    }\n\n    // cache last currentTime and return. default to 0 seconds\n    //\n    // Caching the currentTime is meant to prevent a massive amount of reads on the tech's\n    // currentTime when scrubbing, but may not provide much performance benefit afterall.\n    // Should be tested. Also something has to read the actual current time or the cache will\n    // never get updated.\n    this.cache_.currentTime = this.techGet_('currentTime') || 0;\n    return this.cache_.currentTime;\n  };\n\n  /**\n   * Normally gets the length in time of the video in seconds;\n   * in all but the rarest use cases an argument will NOT be passed to the method\n   *\n   * > **NOTE**: The video must have started loading before the duration can be\n   * known, and in the case of Flash, may not be known until the video starts\n   * playing.\n   *\n   * @fires Player#durationchange\n   *\n   * @param {number} [seconds]\n   *        The duration of the video to set in seconds\n   *\n   * @return {number}\n   *         - The duration of the video in seconds when getting\n   */\n\n\n  Player.prototype.duration = function duration(seconds) {\n    if (seconds === undefined) {\n      // return NaN if the duration is not known\n      return this.cache_.duration !== undefined ? this.cache_.duration : NaN;\n    }\n\n    seconds = parseFloat(seconds);\n\n    // Standardize on Inifity for signaling video is live\n    if (seconds < 0) {\n      seconds = Infinity;\n    }\n\n    if (seconds !== this.cache_.duration) {\n      // Cache the last set value for optimized scrubbing (esp. Flash)\n      this.cache_.duration = seconds;\n\n      if (seconds === Infinity) {\n        this.addClass('vjs-live');\n      } else {\n        this.removeClass('vjs-live');\n      }\n      /**\n       * @event Player#durationchange\n       * @type {EventTarget~Event}\n       */\n      this.trigger('durationchange');\n    }\n  };\n\n  /**\n   * Calculates how much time is left in the video. Not part\n   * of the native video API.\n   *\n   * @return {number}\n   *         The time remaining in seconds\n   */\n\n\n  Player.prototype.remainingTime = function remainingTime() {\n    return this.duration() - this.currentTime();\n  };\n\n  /**\n   * A remaining time function that is intented to be used when\n   * the time is to be displayed directly to the user.\n   *\n   * @return {number}\n   *         The rounded time remaining in seconds\n   */\n\n\n  Player.prototype.remainingTimeDisplay = function remainingTimeDisplay() {\n    return Math.floor(this.duration()) - Math.floor(this.currentTime());\n  };\n\n  //\n  // Kind of like an array of portions of the video that have been downloaded.\n\n  /**\n   * Get a TimeRange object with an array of the times of the video\n   * that have been downloaded. If you just want the percent of the\n   * video that's been downloaded, use bufferedPercent.\n   *\n   * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}\n   *\n   * @return {TimeRange}\n   *         A mock TimeRange object (following HTML spec)\n   */\n\n\n  Player.prototype.buffered = function buffered() {\n    var buffered = this.techGet_('buffered');\n\n    if (!buffered || !buffered.length) {\n      buffered = createTimeRanges(0, 0);\n    }\n\n    return buffered;\n  };\n\n  /**\n   * Get the percent (as a decimal) of the video that's been downloaded.\n   * This method is not a part of the native HTML video API.\n   *\n   * @return {number}\n   *         A decimal between 0 and 1 representing the percent\n   *         that is bufferred 0 being 0% and 1 being 100%\n   */\n\n\n  Player.prototype.bufferedPercent = function bufferedPercent$$1() {\n    return bufferedPercent(this.buffered(), this.duration());\n  };\n\n  /**\n   * Get the ending time of the last buffered time range\n   * This is used in the progress bar to encapsulate all time ranges.\n   *\n   * @return {number}\n   *         The end of the last buffered time range\n   */\n\n\n  Player.prototype.bufferedEnd = function bufferedEnd() {\n    var buffered = this.buffered();\n    var duration = this.duration();\n    var end = buffered.end(buffered.length - 1);\n\n    if (end > duration) {\n      end = duration;\n    }\n\n    return end;\n  };\n\n  /**\n   * Get or set the current volume of the media\n   *\n   * @param  {number} [percentAsDecimal]\n   *         The new volume as a decimal percent:\n   *         - 0 is muted/0%/off\n   *         - 1.0 is 100%/full\n   *         - 0.5 is half volume or 50%\n   *\n   * @return {number}\n   *         The current volume as a percent when getting\n   */\n\n\n  Player.prototype.volume = function volume(percentAsDecimal) {\n    var vol = void 0;\n\n    if (percentAsDecimal !== undefined) {\n      // Force value to between 0 and 1\n      vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));\n      this.cache_.volume = vol;\n      this.techCall_('setVolume', vol);\n\n      if (vol > 0) {\n        this.lastVolume_(vol);\n      }\n\n      return;\n    }\n\n    // Default to 1 when returning current volume.\n    vol = parseFloat(this.techGet_('volume'));\n    return isNaN(vol) ? 1 : vol;\n  };\n\n  /**\n   * Get the current muted state, or turn mute on or off\n   *\n   * @param {boolean} [muted]\n   *        - true to mute\n   *        - false to unmute\n   *\n   * @return {boolean}\n   *         - true if mute is on and getting\n   *         - false if mute is off and getting\n   */\n\n\n  Player.prototype.muted = function muted(_muted) {\n    if (_muted !== undefined) {\n      this.techCall_('setMuted', _muted);\n      return;\n    }\n    return this.techGet_('muted') || false;\n  };\n\n  /**\n   * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted\n   * indicates the state of muted on intial playback.\n   *\n   * ```js\n   *   var myPlayer = videojs('some-player-id');\n   *\n   *   myPlayer.src(\"http://www.example.com/path/to/video.mp4\");\n   *\n   *   // get, should be false\n   *   console.log(myPlayer.defaultMuted());\n   *   // set to true\n   *   myPlayer.defaultMuted(true);\n   *   // get should be true\n   *   console.log(myPlayer.defaultMuted());\n   * ```\n   *\n   * @param {boolean} [defaultMuted]\n   *        - true to mute\n   *        - false to unmute\n   *\n   * @return {boolean|Player}\n   *         - true if defaultMuted is on and getting\n   *         - false if defaultMuted is off and getting\n   *         - A reference to the current player when setting\n   */\n\n\n  Player.prototype.defaultMuted = function defaultMuted(_defaultMuted) {\n    if (_defaultMuted !== undefined) {\n      return this.techCall_('setDefaultMuted', _defaultMuted);\n    }\n    return this.techGet_('defaultMuted') || false;\n  };\n\n  /**\n   * Get the last volume, or set it\n   *\n   * @param  {number} [percentAsDecimal]\n   *         The new last volume as a decimal percent:\n   *         - 0 is muted/0%/off\n   *         - 1.0 is 100%/full\n   *         - 0.5 is half volume or 50%\n   *\n   * @return {number}\n   *         the current value of lastVolume as a percent when getting\n   *\n   * @private\n   */\n\n\n  Player.prototype.lastVolume_ = function lastVolume_(percentAsDecimal) {\n    if (percentAsDecimal !== undefined && percentAsDecimal !== 0) {\n      this.cache_.lastVolume = percentAsDecimal;\n      return;\n    }\n    return this.cache_.lastVolume;\n  };\n\n  /**\n   * Check if current tech can support native fullscreen\n   * (e.g. with built in controls like iOS, so not our flash swf)\n   *\n   * @return {boolean}\n   *         if native fullscreen is supported\n   */\n\n\n  Player.prototype.supportsFullScreen = function supportsFullScreen() {\n    return this.techGet_('supportsFullScreen') || false;\n  };\n\n  /**\n   * Check if the player is in fullscreen mode or tell the player that it\n   * is or is not in fullscreen mode.\n   *\n   * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official\n   * property and instead document.fullscreenElement is used. But isFullscreen is\n   * still a valuable property for internal player workings.\n   *\n   * @param  {boolean} [isFS]\n   *         Set the players current fullscreen state\n   *\n   * @return {boolean}\n   *         - true if fullscreen is on and getting\n   *         - false if fullscreen is off and getting\n   */\n\n\n  Player.prototype.isFullscreen = function isFullscreen(isFS) {\n    if (isFS !== undefined) {\n      this.isFullscreen_ = !!isFS;\n      return;\n    }\n    return !!this.isFullscreen_;\n  };\n\n  /**\n   * Increase the size of the video to full screen\n   * In some browsers, full screen is not supported natively, so it enters\n   * \"full window mode\", where the video fills the browser window.\n   * In browsers and devices that support native full screen, sometimes the\n   * browser's default controls will be shown, and not the Video.js custom skin.\n   * This includes most mobile devices (iOS, Android) and older versions of\n   * Safari.\n   *\n   * @fires Player#fullscreenchange\n   */\n\n\n  Player.prototype.requestFullscreen = function requestFullscreen() {\n    var fsApi = FullscreenApi;\n\n    this.isFullscreen(true);\n\n    if (fsApi.requestFullscreen) {\n      // the browser supports going fullscreen at the element level so we can\n      // take the controls fullscreen as well as the video\n\n      // Trigger fullscreenchange event after change\n      // We have to specifically add this each time, and remove\n      // when canceling fullscreen. Otherwise if there's multiple\n      // players on a page, they would all be reacting to the same fullscreen\n      // events\n      on(document, fsApi.fullscreenchange, bind(this, function documentFullscreenChange(e) {\n        this.isFullscreen(document[fsApi.fullscreenElement]);\n\n        // If cancelling fullscreen, remove event listener.\n        if (this.isFullscreen() === false) {\n          off(document, fsApi.fullscreenchange, documentFullscreenChange);\n        }\n        /**\n         * @event Player#fullscreenchange\n         * @type {EventTarget~Event}\n         */\n        this.trigger('fullscreenchange');\n      }));\n\n      this.el_[fsApi.requestFullscreen]();\n    } else if (this.tech_.supportsFullScreen()) {\n      // we can't take the video.js controls fullscreen but we can go fullscreen\n      // with native controls\n      this.techCall_('enterFullScreen');\n    } else {\n      // fullscreen isn't supported so we'll just stretch the video element to\n      // fill the viewport\n      this.enterFullWindow();\n      /**\n       * @event Player#fullscreenchange\n       * @type {EventTarget~Event}\n       */\n      this.trigger('fullscreenchange');\n    }\n  };\n\n  /**\n   * Return the video to its normal size after having been in full screen mode\n   *\n   * @fires Player#fullscreenchange\n   */\n\n\n  Player.prototype.exitFullscreen = function exitFullscreen() {\n    var fsApi = FullscreenApi;\n\n    this.isFullscreen(false);\n\n    // Check for browser element fullscreen support\n    if (fsApi.requestFullscreen) {\n      document[fsApi.exitFullscreen]();\n    } else if (this.tech_.supportsFullScreen()) {\n      this.techCall_('exitFullScreen');\n    } else {\n      this.exitFullWindow();\n      /**\n       * @event Player#fullscreenchange\n       * @type {EventTarget~Event}\n       */\n      this.trigger('fullscreenchange');\n    }\n  };\n\n  /**\n   * When fullscreen isn't supported we can stretch the\n   * video container to as wide as the browser will let us.\n   *\n   * @fires Player#enterFullWindow\n   */\n\n\n  Player.prototype.enterFullWindow = function enterFullWindow() {\n    this.isFullWindow = true;\n\n    // Storing original doc overflow value to return to when fullscreen is off\n    this.docOrigOverflow = document.documentElement.style.overflow;\n\n    // Add listener for esc key to exit fullscreen\n    on(document, 'keydown', bind(this, this.fullWindowOnEscKey));\n\n    // Hide any scroll bars\n    document.documentElement.style.overflow = 'hidden';\n\n    // Apply fullscreen styles\n    addClass(document.body, 'vjs-full-window');\n\n    /**\n     * @event Player#enterFullWindow\n     * @type {EventTarget~Event}\n     */\n    this.trigger('enterFullWindow');\n  };\n\n  /**\n   * Check for call to either exit full window or\n   * full screen on ESC key\n   *\n   * @param {string} event\n   *        Event to check for key press\n   */\n\n\n  Player.prototype.fullWindowOnEscKey = function fullWindowOnEscKey(event) {\n    if (event.keyCode === 27) {\n      if (this.isFullscreen() === true) {\n        this.exitFullscreen();\n      } else {\n        this.exitFullWindow();\n      }\n    }\n  };\n\n  /**\n   * Exit full window\n   *\n   * @fires Player#exitFullWindow\n   */\n\n\n  Player.prototype.exitFullWindow = function exitFullWindow() {\n    this.isFullWindow = false;\n    off(document, 'keydown', this.fullWindowOnEscKey);\n\n    // Unhide scroll bars.\n    document.documentElement.style.overflow = this.docOrigOverflow;\n\n    // Remove fullscreen styles\n    removeClass(document.body, 'vjs-full-window');\n\n    // Resize the box, controller, and poster to original sizes\n    // this.positionAll();\n    /**\n     * @event Player#exitFullWindow\n     * @type {EventTarget~Event}\n     */\n    this.trigger('exitFullWindow');\n  };\n\n  /**\n   * Check whether the player can play a given mimetype\n   *\n   * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype\n   *\n   * @param {string} type\n   *        The mimetype to check\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */\n\n\n  Player.prototype.canPlayType = function canPlayType(type) {\n    var can = void 0;\n\n    // Loop through each playback technology in the options order\n    for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {\n      var techName = j[i];\n      var tech = Tech.getTech(techName);\n\n      // Support old behavior of techs being registered as components.\n      // Remove once that deprecated behavior is removed.\n      if (!tech) {\n        tech = Component.getComponent(techName);\n      }\n\n      // Check if the current tech is defined before continuing\n      if (!tech) {\n        log$1.error('The \"' + techName + '\" tech is undefined. Skipped browser support check for that tech.');\n        continue;\n      }\n\n      // Check if the browser supports this technology\n      if (tech.isSupported()) {\n        can = tech.canPlayType(type);\n\n        if (can) {\n          return can;\n        }\n      }\n    }\n\n    return '';\n  };\n\n  /**\n   * Select source based on tech-order or source-order\n   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,\n   * defaults to tech-order selection\n   *\n   * @param {Array} sources\n   *        The sources for a media asset\n   *\n   * @return {Object|boolean}\n   *         Object of source and tech order or false\n   */\n\n\n  Player.prototype.selectSource = function selectSource(sources) {\n    var _this6 = this;\n\n    // Get only the techs specified in `techOrder` that exist and are supported by the\n    // current platform\n    var techs = this.options_.techOrder.map(function (techName) {\n      return [techName, Tech.getTech(techName)];\n    }).filter(function (_ref) {\n      var techName = _ref[0],\n          tech = _ref[1];\n\n      // Check if the current tech is defined before continuing\n      if (tech) {\n        // Check if the browser supports this technology\n        return tech.isSupported();\n      }\n\n      log$1.error('The \"' + techName + '\" tech is undefined. Skipped browser support check for that tech.');\n      return false;\n    });\n\n    // Iterate over each `innerArray` element once per `outerArray` element and execute\n    // `tester` with both. If `tester` returns a non-falsy value, exit early and return\n    // that value.\n    var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair(outerArray, innerArray, tester) {\n      var found = void 0;\n\n      outerArray.some(function (outerChoice) {\n        return innerArray.some(function (innerChoice) {\n          found = tester(outerChoice, innerChoice);\n\n          if (found) {\n            return true;\n          }\n        });\n      });\n\n      return found;\n    };\n\n    var foundSourceAndTech = void 0;\n    var flip = function flip(fn) {\n      return function (a, b) {\n        return fn(b, a);\n      };\n    };\n    var finder = function finder(_ref2, source) {\n      var techName = _ref2[0],\n          tech = _ref2[1];\n\n      if (tech.canPlaySource(source, _this6.options_[techName.toLowerCase()])) {\n        return { source: source, tech: techName };\n      }\n    };\n\n    // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources\n    // to select from them based on their priority.\n    if (this.options_.sourceOrder) {\n      // Source-first ordering\n      foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));\n    } else {\n      // Tech-first ordering\n      foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);\n    }\n\n    return foundSourceAndTech || false;\n  };\n\n  /**\n   * Get or set the video source.\n   *\n   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]\n   *        A SourceObject, an array of SourceObjects, or a string referencing\n   *        a URL to a media source. It is _highly recommended_ that an object\n   *        or array of objects is used here, so that source selection\n   *        algorithms can take the `type` into account.\n   *\n   *        If not provided, this method acts as a getter.\n   *\n   * @return {string|undefined}\n   *         If the `source` argument is missing, returns the current source\n   *         URL. Otherwise, returns nothing/undefined.\n   */\n\n\n  Player.prototype.src = function src(source) {\n    var _this7 = this;\n\n    // getter usage\n    if (typeof source === 'undefined') {\n      return this.cache_.src || '';\n    }\n    // filter out invalid sources and turn our source into\n    // an array of source objects\n    var sources = filterSource(source);\n\n    // if a source was passed in then it is invalid because\n    // it was filtered to a zero length Array. So we have to\n    // show an error\n    if (!sources.length) {\n      this.setTimeout(function () {\n        this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });\n      }, 0);\n      return;\n    }\n\n    // intial sources\n    this.cache_.sources = sources;\n    this.changingSrc_ = true;\n\n    // intial source\n    this.cache_.source = sources[0];\n\n    // middlewareSource is the source after it has been changed by middleware\n    setSource(this, sources[0], function (middlewareSource, mws) {\n      _this7.middleware_ = mws;\n\n      var err = _this7.src_(middlewareSource);\n\n      if (err) {\n        if (sources.length > 1) {\n          return _this7.src(sources.slice(1));\n        }\n\n        // We need to wrap this in a timeout to give folks a chance to add error event handlers\n        _this7.setTimeout(function () {\n          this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });\n        }, 0);\n\n        // we could not find an appropriate tech, but let's still notify the delegate that this is it\n        // this needs a better comment about why this is needed\n        _this7.triggerReady();\n\n        return;\n      }\n\n      _this7.changingSrc_ = false;\n      // video element listed source\n      _this7.cache_.src = middlewareSource.src;\n\n      setTech(mws, _this7.tech_);\n    });\n  };\n\n  /**\n   * Set the source object on the tech, returns a boolean that indicates wether\n   * there is a tech that can play the source or not\n   *\n   * @param {Tech~SourceObject} source\n   *        The source object to set on the Tech\n   *\n   * @return {Boolean}\n   *         - True if there is no Tech to playback this source\n   *         - False otherwise\n   *\n   * @private\n   */\n\n\n  Player.prototype.src_ = function src_(source) {\n    var sourceTech = this.selectSource([source]);\n\n    if (!sourceTech) {\n      return true;\n    }\n\n    if (!titleCaseEquals(sourceTech.tech, this.techName_)) {\n      this.changingSrc_ = true;\n\n      // load this technology with the chosen source\n      this.loadTech_(sourceTech.tech, sourceTech.source);\n      return false;\n    }\n\n    // wait until the tech is ready to set the source\n    this.ready(function () {\n\n      // The setSource tech method was added with source handlers\n      // so older techs won't support it\n      // We need to check the direct prototype for the case where subclasses\n      // of the tech do not support source handlers\n      if (this.tech_.constructor.prototype.hasOwnProperty('setSource')) {\n        this.techCall_('setSource', source);\n      } else {\n        this.techCall_('src', source.src);\n      }\n\n      if (this.options_.preload === 'auto') {\n        this.load();\n      }\n\n      // Set the source synchronously if possible (#2326)\n    }, true);\n\n    return false;\n  };\n\n  /**\n   * Begin loading the src data.\n   */\n\n\n  Player.prototype.load = function load() {\n    this.techCall_('load');\n  };\n\n  /**\n   * Reset the player. Loads the first tech in the techOrder,\n   * and calls `reset` on the tech`.\n   */\n\n\n  Player.prototype.reset = function reset() {\n    this.loadTech_(this.options_.techOrder[0], null);\n    this.techCall_('reset');\n  };\n\n  /**\n   * Returns all of the current source objects.\n   *\n   * @return {Tech~SourceObject[]}\n   *         The current source objects\n   */\n\n\n  Player.prototype.currentSources = function currentSources() {\n    var source = this.currentSource();\n    var sources = [];\n\n    // assume `{}` or `{ src }`\n    if (Object.keys(source).length !== 0) {\n      sources.push(source);\n    }\n\n    return this.cache_.sources || sources;\n  };\n\n  /**\n   * Returns the current source object.\n   *\n   * @return {Tech~SourceObject}\n   *         The current source object\n   */\n\n\n  Player.prototype.currentSource = function currentSource() {\n    return this.cache_.source || {};\n  };\n\n  /**\n   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4\n   * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.\n   *\n   * @return {string}\n   *         The current source\n   */\n\n\n  Player.prototype.currentSrc = function currentSrc() {\n    return this.currentSource() && this.currentSource().src || '';\n  };\n\n  /**\n   * Get the current source type e.g. video/mp4\n   * This can allow you rebuild the current source object so that you could load the same\n   * source and tech later\n   *\n   * @return {string}\n   *         The source MIME type\n   */\n\n\n  Player.prototype.currentType = function currentType() {\n    return this.currentSource() && this.currentSource().type || '';\n  };\n\n  /**\n   * Get or set the preload attribute\n   *\n   * @param {boolean} [value]\n   *        - true means that we should preload\n   *        - false maens that we should not preload\n   *\n   * @return {string}\n   *         The preload attribute value when getting\n   */\n\n\n  Player.prototype.preload = function preload(value) {\n    if (value !== undefined) {\n      this.techCall_('setPreload', value);\n      this.options_.preload = value;\n      return;\n    }\n    return this.techGet_('preload');\n  };\n\n  /**\n   * Get or set the autoplay attribute.\n   *\n   * @param {boolean} [value]\n   *        - true means that we should autoplay\n   *        - false means that we should not autoplay\n   *\n   * @return {string}\n   *         The current value of autoplay when getting\n   */\n\n\n  Player.prototype.autoplay = function autoplay(value) {\n    if (value !== undefined) {\n      this.techCall_('setAutoplay', value);\n      this.options_.autoplay = value;\n      this.ready(this.forceAutoplayInChrome_);\n      return;\n    }\n    return this.techGet_('autoplay', value);\n  };\n\n  /**\n   * chrome started pausing the video when moving in the DOM\n   * causing autoplay to not continue due to how Video.js functions.\n   * See #4720 for more info.\n   *\n   * @private\n   */\n\n\n  Player.prototype.forceAutoplayInChrome_ = function forceAutoplayInChrome_() {\n    if (this.paused() && (\n    // read from the video element or options\n    this.autoplay() || this.options_.autoplay) &&\n    // only target desktop chrome\n    IS_CHROME && !IS_ANDROID) {\n      this.play();\n    }\n  };\n\n  /**\n   * Set or unset the playsinline attribute.\n   * Playsinline tells the browser that non-fullscreen playback is preferred.\n   *\n   * @param {boolean} [value]\n   *        - true means that we should try to play inline by default\n   *        - false means that we should use the browser's default playback mode,\n   *          which in most cases is inline. iOS Safari is a notable exception\n   *          and plays fullscreen by default.\n   *\n   * @return {string|Player}\n   *         - the current value of playsinline\n   *         - the player when setting\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n   */\n\n\n  Player.prototype.playsinline = function playsinline(value) {\n    if (value !== undefined) {\n      this.techCall_('setPlaysinline', value);\n      this.options_.playsinline = value;\n      return this;\n    }\n    return this.techGet_('playsinline');\n  };\n\n  /**\n   * Get or set the loop attribute on the video element.\n   *\n   * @param {boolean} [value]\n   *        - true means that we should loop the video\n   *        - false means that we should not loop the video\n   *\n   * @return {string}\n   *         The current value of loop when getting\n   */\n\n\n  Player.prototype.loop = function loop(value) {\n    if (value !== undefined) {\n      this.techCall_('setLoop', value);\n      this.options_.loop = value;\n      return;\n    }\n    return this.techGet_('loop');\n  };\n\n  /**\n   * Get or set the poster image source url\n   *\n   * @fires Player#posterchange\n   *\n   * @param {string} [src]\n   *        Poster image source URL\n   *\n   * @return {string}\n   *         The current value of poster when getting\n   */\n\n\n  Player.prototype.poster = function poster(src) {\n    if (src === undefined) {\n      return this.poster_;\n    }\n\n    // The correct way to remove a poster is to set as an empty string\n    // other falsey values will throw errors\n    if (!src) {\n      src = '';\n    }\n\n    // update the internal poster variable\n    this.poster_ = src;\n\n    // update the tech's poster\n    this.techCall_('setPoster', src);\n\n    // alert components that the poster has been set\n    /**\n     * This event fires when the poster image is changed on the player.\n     *\n     * @event Player#posterchange\n     * @type {EventTarget~Event}\n     */\n    this.trigger('posterchange');\n  };\n\n  /**\n   * Some techs (e.g. YouTube) can provide a poster source in an\n   * asynchronous way. We want the poster component to use this\n   * poster source so that it covers up the tech's controls.\n   * (YouTube's play button). However we only want to use this\n   * source if the player user hasn't set a poster through\n   * the normal APIs.\n   *\n   * @fires Player#posterchange\n   * @listens Tech#posterchange\n   * @private\n   */\n\n\n  Player.prototype.handleTechPosterChange_ = function handleTechPosterChange_() {\n    if (!this.poster_ && this.tech_ && this.tech_.poster) {\n      this.poster_ = this.tech_.poster() || '';\n\n      // Let components know the poster has changed\n      this.trigger('posterchange');\n    }\n  };\n\n  /**\n   * Get or set whether or not the controls are showing.\n   *\n   * @fires Player#controlsenabled\n   *\n   * @param {boolean} [bool]\n   *        - true to turn controls on\n   *        - false to turn controls off\n   *\n   * @return {boolean}\n   *         The current value of controls when getting\n   */\n\n\n  Player.prototype.controls = function controls(bool) {\n    if (bool === undefined) {\n      return !!this.controls_;\n    }\n\n    bool = !!bool;\n\n    // Don't trigger a change event unless it actually changed\n    if (this.controls_ === bool) {\n      return;\n    }\n\n    this.controls_ = bool;\n\n    if (this.usingNativeControls()) {\n      this.techCall_('setControls', bool);\n    }\n\n    if (this.controls_) {\n      this.removeClass('vjs-controls-disabled');\n      this.addClass('vjs-controls-enabled');\n      /**\n       * @event Player#controlsenabled\n       * @type {EventTarget~Event}\n       */\n      this.trigger('controlsenabled');\n      if (!this.usingNativeControls()) {\n        this.addTechControlsListeners_();\n      }\n    } else {\n      this.removeClass('vjs-controls-enabled');\n      this.addClass('vjs-controls-disabled');\n      /**\n       * @event Player#controlsdisabled\n       * @type {EventTarget~Event}\n       */\n      this.trigger('controlsdisabled');\n      if (!this.usingNativeControls()) {\n        this.removeTechControlsListeners_();\n      }\n    }\n  };\n\n  /**\n   * Toggle native controls on/off. Native controls are the controls built into\n   * devices (e.g. default iPhone controls), Flash, or other techs\n   * (e.g. Vimeo Controls)\n   * **This should only be set by the current tech, because only the tech knows\n   * if it can support native controls**\n   *\n   * @fires Player#usingnativecontrols\n   * @fires Player#usingcustomcontrols\n   *\n   * @param {boolean} [bool]\n   *        - true to turn native controls on\n   *        - false to turn native controls off\n   *\n   * @return {boolean}\n   *         The current value of native controls when getting\n   */\n\n\n  Player.prototype.usingNativeControls = function usingNativeControls(bool) {\n    if (bool === undefined) {\n      return !!this.usingNativeControls_;\n    }\n\n    bool = !!bool;\n\n    // Don't trigger a change event unless it actually changed\n    if (this.usingNativeControls_ === bool) {\n      return;\n    }\n\n    this.usingNativeControls_ = bool;\n\n    if (this.usingNativeControls_) {\n      this.addClass('vjs-using-native-controls');\n\n      /**\n       * player is using the native device controls\n       *\n       * @event Player#usingnativecontrols\n       * @type {EventTarget~Event}\n       */\n      this.trigger('usingnativecontrols');\n    } else {\n      this.removeClass('vjs-using-native-controls');\n\n      /**\n       * player is using the custom HTML controls\n       *\n       * @event Player#usingcustomcontrols\n       * @type {EventTarget~Event}\n       */\n      this.trigger('usingcustomcontrols');\n    }\n  };\n\n  /**\n   * Set or get the current MediaError\n   *\n   * @fires Player#error\n   *\n   * @param  {MediaError|string|number} [err]\n   *         A MediaError or a string/number to be turned\n   *         into a MediaError\n   *\n   * @return {MediaError|null}\n   *         The current MediaError when getting (or null)\n   */\n\n\n  Player.prototype.error = function error(err) {\n    if (err === undefined) {\n      return this.error_ || null;\n    }\n\n    // restoring to default\n    if (err === null) {\n      this.error_ = err;\n      this.removeClass('vjs-error');\n      if (this.errorDisplay) {\n        this.errorDisplay.close();\n      }\n      return;\n    }\n\n    this.error_ = new MediaError(err);\n\n    // add the vjs-error classname to the player\n    this.addClass('vjs-error');\n\n    // log the name of the error type and any message\n    // ie8 just logs \"[object object]\" if you just log the error object\n    log$1.error('(CODE:' + this.error_.code + ' ' + MediaError.errorTypes[this.error_.code] + ')', this.error_.message, this.error_);\n\n    /**\n     * @event Player#error\n     * @type {EventTarget~Event}\n     */\n    this.trigger('error');\n\n    return;\n  };\n\n  /**\n   * Report user activity\n   *\n   * @param {Object} event\n   *        Event object\n   */\n\n\n  Player.prototype.reportUserActivity = function reportUserActivity(event) {\n    this.userActivity_ = true;\n  };\n\n  /**\n   * Get/set if user is active\n   *\n   * @fires Player#useractive\n   * @fires Player#userinactive\n   *\n   * @param {boolean} [bool]\n   *        - true if the user is active\n   *        - false if the user is inactive\n   *\n   * @return {boolean}\n   *         The current value of userActive when getting\n   */\n\n\n  Player.prototype.userActive = function userActive(bool) {\n    if (bool === undefined) {\n      return this.userActive_;\n    }\n\n    bool = !!bool;\n\n    if (bool === this.userActive_) {\n      return;\n    }\n\n    this.userActive_ = bool;\n\n    if (this.userActive_) {\n      this.userActivity_ = true;\n      this.removeClass('vjs-user-inactive');\n      this.addClass('vjs-user-active');\n      /**\n       * @event Player#useractive\n       * @type {EventTarget~Event}\n       */\n      this.trigger('useractive');\n      return;\n    }\n\n    // Chrome/Safari/IE have bugs where when you change the cursor it can\n    // trigger a mousemove event. This causes an issue when you're hiding\n    // the cursor when the user is inactive, and a mousemove signals user\n    // activity. Making it impossible to go into inactive mode. Specifically\n    // this happens in fullscreen when we really need to hide the cursor.\n    //\n    // When this gets resolved in ALL browsers it can be removed\n    // https://code.google.com/p/chromium/issues/detail?id=103041\n    if (this.tech_) {\n      this.tech_.one('mousemove', function (e) {\n        e.stopPropagation();\n        e.preventDefault();\n      });\n    }\n\n    this.userActivity_ = false;\n    this.removeClass('vjs-user-active');\n    this.addClass('vjs-user-inactive');\n    /**\n     * @event Player#userinactive\n     * @type {EventTarget~Event}\n     */\n    this.trigger('userinactive');\n  };\n\n  /**\n   * Listen for user activity based on timeout value\n   *\n   * @private\n   */\n\n\n  Player.prototype.listenForUserActivity_ = function listenForUserActivity_() {\n    var mouseInProgress = void 0;\n    var lastMoveX = void 0;\n    var lastMoveY = void 0;\n    var handleActivity = bind(this, this.reportUserActivity);\n\n    var handleMouseMove = function handleMouseMove(e) {\n      // #1068 - Prevent mousemove spamming\n      // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970\n      if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {\n        lastMoveX = e.screenX;\n        lastMoveY = e.screenY;\n        handleActivity();\n      }\n    };\n\n    var handleMouseDown = function handleMouseDown() {\n      handleActivity();\n      // For as long as the they are touching the device or have their mouse down,\n      // we consider them active even if they're not moving their finger or mouse.\n      // So we want to continue to update that they are active\n      this.clearInterval(mouseInProgress);\n      // Setting userActivity=true now and setting the interval to the same time\n      // as the activityCheck interval (250) should ensure we never miss the\n      // next activityCheck\n      mouseInProgress = this.setInterval(handleActivity, 250);\n    };\n\n    var handleMouseUp = function handleMouseUp(event) {\n      handleActivity();\n      // Stop the interval that maintains activity if the mouse/touch is down\n      this.clearInterval(mouseInProgress);\n    };\n\n    // Any mouse movement will be considered user activity\n    this.on('mousedown', handleMouseDown);\n    this.on('mousemove', handleMouseMove);\n    this.on('mouseup', handleMouseUp);\n\n    // Listen for keyboard navigation\n    // Shouldn't need to use inProgress interval because of key repeat\n    this.on('keydown', handleActivity);\n    this.on('keyup', handleActivity);\n\n    // Run an interval every 250 milliseconds instead of stuffing everything into\n    // the mousemove/touchmove function itself, to prevent performance degradation.\n    // `this.reportUserActivity` simply sets this.userActivity_ to true, which\n    // then gets picked up by this loop\n    // http://ejohn.org/blog/learning-from-twitter/\n    var inactivityTimeout = void 0;\n\n    this.setInterval(function () {\n      // Check to see if mouse/touch activity has happened\n      if (!this.userActivity_) {\n        return;\n      }\n\n      // Reset the activity tracker\n      this.userActivity_ = false;\n\n      // If the user state was inactive, set the state to active\n      this.userActive(true);\n\n      // Clear any existing inactivity timeout to start the timer over\n      this.clearTimeout(inactivityTimeout);\n\n      var timeout = this.options_.inactivityTimeout;\n\n      if (timeout <= 0) {\n        return;\n      }\n\n      // In <timeout> milliseconds, if no more activity has occurred the\n      // user will be considered inactive\n      inactivityTimeout = this.setTimeout(function () {\n        // Protect against the case where the inactivityTimeout can trigger just\n        // before the next user activity is picked up by the activity check loop\n        // causing a flicker\n        if (!this.userActivity_) {\n          this.userActive(false);\n        }\n      }, timeout);\n    }, 250);\n  };\n\n  /**\n   * Gets or sets the current playback rate. A playback rate of\n   * 1.0 represents normal speed and 0.5 would indicate half-speed\n   * playback, for instance.\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate\n   *\n   * @param {number} [rate]\n   *       New playback rate to set.\n   *\n   * @return {number}\n   *         The current playback rate when getting or 1.0\n   */\n\n\n  Player.prototype.playbackRate = function playbackRate(rate) {\n    if (rate !== undefined) {\n      this.techCall_('setPlaybackRate', rate);\n      return;\n    }\n\n    if (this.tech_ && this.tech_.featuresPlaybackRate) {\n      return this.techGet_('playbackRate');\n    }\n    return 1.0;\n  };\n\n  /**\n   * Gets or sets the current default playback rate. A default playback rate of\n   * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.\n   * defaultPlaybackRate will only represent what the intial playbackRate of a video was, not\n   * not the current playbackRate.\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate\n   *\n   * @param {number} [rate]\n   *       New default playback rate to set.\n   *\n   * @return {number|Player}\n   *         - The default playback rate when getting or 1.0\n   *         - the player when setting\n   */\n\n\n  Player.prototype.defaultPlaybackRate = function defaultPlaybackRate(rate) {\n    if (rate !== undefined) {\n      return this.techCall_('setDefaultPlaybackRate', rate);\n    }\n\n    if (this.tech_ && this.tech_.featuresPlaybackRate) {\n      return this.techGet_('defaultPlaybackRate');\n    }\n    return 1.0;\n  };\n\n  /**\n   * Gets or sets the audio flag\n   *\n   * @param {boolean} bool\n   *        - true signals that this is an audio player\n   *        - false signals that this is not an audio player\n   *\n   * @return {boolean}\n   *         The current value of isAudio when getting\n   */\n\n\n  Player.prototype.isAudio = function isAudio(bool) {\n    if (bool !== undefined) {\n      this.isAudio_ = !!bool;\n      return;\n    }\n\n    return !!this.isAudio_;\n  };\n\n  /**\n   * A helper method for adding a {@link TextTrack} to our\n   * {@link TextTrackList}.\n   *\n   * In addition to the W3C settings we allow adding additional info through options.\n   *\n   * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack\n   *\n   * @param {string} [kind]\n   *        the kind of TextTrack you are adding\n   *\n   * @param {string} [label]\n   *        the label to give the TextTrack label\n   *\n   * @param {string} [language]\n   *        the language to set on the TextTrack\n   *\n   * @return {TextTrack|undefined}\n   *         the TextTrack that was added or undefined\n   *         if there is no tech\n   */\n\n\n  Player.prototype.addTextTrack = function addTextTrack(kind, label, language) {\n    if (this.tech_) {\n      return this.tech_.addTextTrack(kind, label, language);\n    }\n  };\n\n  /**\n   * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}. It will\n   * automatically removed from the video element whenever the source changes, unless\n   * manualCleanup is set to false.\n   *\n   * @param {Object} options\n   *        Options to pass to {@link HTMLTrackElement} during creation. See\n   *        {@link HTMLTrackElement} for object properties that you should use.\n   *\n   * @param {boolean} [manualCleanup=true] if set to false, the TextTrack will be\n   *\n   * @return {HtmlTrackElement}\n   *         the HTMLTrackElement that was created and added\n   *         to the HtmlTrackElementList and the remote\n   *         TextTrackList\n   *\n   * @deprecated The default value of the \"manualCleanup\" parameter will default\n   *             to \"false\" in upcoming versions of Video.js\n   */\n\n\n  Player.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {\n    if (this.tech_) {\n      return this.tech_.addRemoteTextTrack(options, manualCleanup);\n    }\n  };\n\n  /**\n   * Remove a remote {@link TextTrack} from the respective\n   * {@link TextTrackList} and {@link HtmlTrackElementList}.\n   *\n   * @param {Object} track\n   *        Remote {@link TextTrack} to remove\n   *\n   * @return {undefined}\n   *         does not return anything\n   */\n\n\n  Player.prototype.removeRemoteTextTrack = function removeRemoteTextTrack() {\n    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$track = _ref3.track,\n        track = _ref3$track === undefined ? arguments[0] : _ref3$track;\n\n    // destructure the input into an object with a track argument, defaulting to arguments[0]\n    // default the whole argument to an empty object if nothing was passed in\n\n    if (this.tech_) {\n      return this.tech_.removeRemoteTextTrack(track);\n    }\n  };\n\n  /**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object|undefined}\n   *         An object with supported media playback quality metrics or undefined if there\n   *         is no tech or the tech does not support it.\n   */\n\n\n  Player.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\n    return this.techGet_('getVideoPlaybackQuality');\n  };\n\n  /**\n   * Get video width\n   *\n   * @return {number}\n   *         current video width\n   */\n\n\n  Player.prototype.videoWidth = function videoWidth() {\n    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;\n  };\n\n  /**\n   * Get video height\n   *\n   * @return {number}\n   *         current video height\n   */\n\n\n  Player.prototype.videoHeight = function videoHeight() {\n    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;\n  };\n\n  /**\n   * The player's language code\n   * NOTE: The language should be set in the player options if you want the\n   * the controls to be built with a specific language. Changing the lanugage\n   * later will not update controls text.\n   *\n   * @param {string} [code]\n   *        the language code to set the player to\n   *\n   * @return {string}\n   *         The current language code when getting\n   */\n\n\n  Player.prototype.language = function language(code) {\n    if (code === undefined) {\n      return this.language_;\n    }\n\n    this.language_ = String(code).toLowerCase();\n  };\n\n  /**\n   * Get the player's language dictionary\n   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time\n   * Languages specified directly in the player options have precedence\n   *\n   * @return {Array}\n   *         An array of of supported languages\n   */\n\n\n  Player.prototype.languages = function languages() {\n    return mergeOptions(Player.prototype.options_.languages, this.languages_);\n  };\n\n  /**\n   * returns a JavaScript object reperesenting the current track\n   * information. **DOES not return it as JSON**\n   *\n   * @return {Object}\n   *         Object representing the current of track info\n   */\n\n\n  Player.prototype.toJSON = function toJSON() {\n    var options = mergeOptions(this.options_);\n    var tracks = options.tracks;\n\n    options.tracks = [];\n\n    for (var i = 0; i < tracks.length; i++) {\n      var track = tracks[i];\n\n      // deep merge tracks and null out player so no circular references\n      track = mergeOptions(track);\n      track.player = undefined;\n      options.tracks[i] = track;\n    }\n\n    return options;\n  };\n\n  /**\n   * Creates a simple modal dialog (an instance of the {@link ModalDialog}\n   * component) that immediately overlays the player with arbitrary\n   * content and removes itself when closed.\n   *\n   * @param {string|Function|Element|Array|null} content\n   *        Same as {@link ModalDialog#content}'s param of the same name.\n   *        The most straight-forward usage is to provide a string or DOM\n   *        element.\n   *\n   * @param {Object} [options]\n   *        Extra options which will be passed on to the {@link ModalDialog}.\n   *\n   * @return {ModalDialog}\n   *         the {@link ModalDialog} that was created\n   */\n\n\n  Player.prototype.createModal = function createModal(content, options) {\n    var _this8 = this;\n\n    options = options || {};\n    options.content = content || '';\n\n    var modal = new ModalDialog(this, options);\n\n    this.addChild(modal);\n    modal.on('dispose', function () {\n      _this8.removeChild(modal);\n    });\n\n    modal.open();\n    return modal;\n  };\n\n  /**\n   * Gets tag settings\n   *\n   * @param {Element} tag\n   *        The player tag\n   *\n   * @return {Object}\n   *         An object containing all of the settings\n   *         for a player tag\n   */\n\n\n  Player.getTagSettings = function getTagSettings(tag) {\n    var baseOptions = {\n      sources: [],\n      tracks: []\n    };\n\n    var tagOptions = getAttributes(tag);\n    var dataSetup = tagOptions['data-setup'];\n\n    if (hasClass(tag, 'vjs-fluid')) {\n      tagOptions.fluid = true;\n    }\n\n    // Check if data-setup attr exists.\n    if (dataSetup !== null) {\n      // Parse options JSON\n      // If empty string, make it a parsable json object.\n      var _safeParseTuple = safeParseTuple(dataSetup || '{}'),\n          err = _safeParseTuple[0],\n          data = _safeParseTuple[1];\n\n      if (err) {\n        log$1.error(err);\n      }\n      assign(tagOptions, data);\n    }\n\n    assign(baseOptions, tagOptions);\n\n    // Get tag children settings\n    if (tag.hasChildNodes()) {\n      var children = tag.childNodes;\n\n      for (var i = 0, j = children.length; i < j; i++) {\n        var child = children[i];\n        // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/\n        var childName = child.nodeName.toLowerCase();\n\n        if (childName === 'source') {\n          baseOptions.sources.push(getAttributes(child));\n        } else if (childName === 'track') {\n          baseOptions.tracks.push(getAttributes(child));\n        }\n      }\n    }\n\n    return baseOptions;\n  };\n\n  /**\n   * Determine wether or not flexbox is supported\n   *\n   * @return {boolean}\n   *         - true if flexbox is supported\n   *         - false if flexbox is not supported\n   */\n\n\n  Player.prototype.flexNotSupported_ = function flexNotSupported_() {\n    var elem = document.createElement('i');\n\n    // Note: We don't actually use flexBasis (or flexOrder), but it's one of the more\n    // common flex features that we can rely on when checking for flex support.\n    return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style ||\n    // IE10-specific (2012 flex spec)\n    'msFlexOrder' in elem.style);\n  };\n\n  return Player;\n}(Component);\n\n/**\n * Get the {@link VideoTrackList}\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist\n *\n * @return {VideoTrackList}\n *         the current video track list\n *\n * @method Player.prototype.videoTracks\n */\n\n/**\n * Get the {@link AudioTrackList}\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist\n *\n * @return {AudioTrackList}\n *         the current audio track list\n *\n * @method Player.prototype.audioTracks\n */\n\n/**\n * Get the {@link TextTrackList}\n *\n * @link http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks\n *\n * @return {TextTrackList}\n *         the current text track list\n *\n * @method Player.prototype.textTracks\n */\n\n/**\n * Get the remote {@link TextTrackList}\n *\n * @return {TextTrackList}\n *         The current remote text track list\n *\n * @method Player.prototype.remoteTextTracks\n */\n\n/**\n * Get the remote {@link HtmlTrackElementList} tracks.\n *\n * @return {HtmlTrackElementList}\n *         The current remote text track element list\n *\n * @method Player.prototype.remoteTextTrackEls\n */\n\nALL.names.forEach(function (name$$1) {\n  var props = ALL[name$$1];\n\n  Player.prototype[props.getterName] = function () {\n    if (this.tech_) {\n      return this.tech_[props.getterName]();\n    }\n\n    // if we have not yet loadTech_, we create {video,audio,text}Tracks_\n    // these will be passed to the tech during loading\n    this[props.privateName] = this[props.privateName] || new props.ListClass();\n    return this[props.privateName];\n  };\n});\n\n/**\n * Global player list\n *\n * @type {Object}\n */\nPlayer.players = {};\n\nvar navigator = window.navigator;\n\n/*\n * Player instance options, surfaced using options\n * options = Player.prototype.options_\n * Make changes in options, not here.\n *\n * @type {Object}\n * @private\n */\nPlayer.prototype.options_ = {\n  // Default order of fallback technology\n  techOrder: Tech.defaultTechOrder_,\n\n  html5: {},\n  flash: {},\n\n  // default inactivity timeout\n  inactivityTimeout: 2000,\n\n  // default playback rates\n  playbackRates: [],\n  // Add playback rate selection by adding rates\n  // 'playbackRates': [0.5, 1, 1.5, 2],\n\n  // Included control sets\n  children: ['mediaLoader', 'posterImage', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'controlBar', 'errorDisplay', 'textTrackSettings'],\n\n  language: navigator && (navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language) || 'en',\n\n  // locales and their language translations\n  languages: {},\n\n  // Default message to show when a video cannot be played.\n  notSupportedMessage: 'No compatible source was found for this media.'\n};\n\n[\n/**\n * Returns whether or not the player is in the \"ended\" state.\n *\n * @return {Boolean} True if the player is in the ended state, false if not.\n * @method Player#ended\n */\n'ended',\n/**\n * Returns whether or not the player is in the \"seeking\" state.\n *\n * @return {Boolean} True if the player is in the seeking state, false if not.\n * @method Player#seeking\n */\n'seeking',\n/**\n * Returns the TimeRanges of the media that are currently available\n * for seeking to.\n *\n * @return {TimeRanges} the seekable intervals of the media timeline\n * @method Player#seekable\n */\n'seekable',\n/**\n * Returns the current state of network activity for the element, from\n * the codes in the list below.\n * - NETWORK_EMPTY (numeric value 0)\n *   The element has not yet been initialised. All attributes are in\n *   their initial states.\n * - NETWORK_IDLE (numeric value 1)\n *   The element's resource selection algorithm is active and has\n *   selected a resource, but it is not actually using the network at\n *   this time.\n * - NETWORK_LOADING (numeric value 2)\n *   The user agent is actively trying to download data.\n * - NETWORK_NO_SOURCE (numeric value 3)\n *   The element's resource selection algorithm is active, but it has\n *   not yet found a resource to use.\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states\n * @return {number} the current network activity state\n * @method Player#networkState\n */\n'networkState',\n/**\n * Returns a value that expresses the current state of the element\n * with respect to rendering the current playback position, from the\n * codes in the list below.\n * - HAVE_NOTHING (numeric value 0)\n *   No information regarding the media resource is available.\n * - HAVE_METADATA (numeric value 1)\n *   Enough of the resource has been obtained that the duration of the\n *   resource is available.\n * - HAVE_CURRENT_DATA (numeric value 2)\n *   Data for the immediate current playback position is available.\n * - HAVE_FUTURE_DATA (numeric value 3)\n *   Data for the immediate current playback position is available, as\n *   well as enough data for the user agent to advance the current\n *   playback position in the direction of playback.\n * - HAVE_ENOUGH_DATA (numeric value 4)\n *   The user agent estimates that enough data is available for\n *   playback to proceed uninterrupted.\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate\n * @return {number} the current playback rendering state\n * @method Player#readyState\n */\n'readyState'].forEach(function (fn) {\n  Player.prototype[fn] = function () {\n    return this.techGet_(fn);\n  };\n});\n\nTECH_EVENTS_RETRIGGER.forEach(function (event) {\n  Player.prototype['handleTech' + toTitleCase(event) + '_'] = function () {\n    return this.trigger(event);\n  };\n});\n\n/**\n * Fired when the player has initial duration and dimension information\n *\n * @event Player#loadedmetadata\n * @type {EventTarget~Event}\n */\n\n/**\n * Fired when the player has downloaded data at the current playback position\n *\n * @event Player#loadeddata\n * @type {EventTarget~Event}\n */\n\n/**\n * Fired when the current playback position has changed *\n * During playback this is fired every 15-250 milliseconds, depending on the\n * playback technology in use.\n *\n * @event Player#timeupdate\n * @type {EventTarget~Event}\n */\n\n/**\n * Fired when the volume changes\n *\n * @event Player#volumechange\n * @type {EventTarget~Event}\n */\n\n/**\n * Reports whether or not a player has a plugin available.\n *\n * This does not report whether or not the plugin has ever been initialized\n * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.\n *\n * @method Player#hasPlugin\n * @param  {string}  name\n *         The name of a plugin.\n *\n * @return {boolean}\n *         Whether or not this player has the requested plugin available.\n */\n\n/**\n * Reports whether or not a player is using a plugin by name.\n *\n * For basic plugins, this only reports whether the plugin has _ever_ been\n * initialized on this player.\n *\n * @method Player#usingPlugin\n * @param  {string} name\n *         The name of a plugin.\n *\n * @return {boolean}\n *         Whether or not this player is using the requested plugin.\n */\n\nComponent.registerComponent('Player', Player);\n\n/**\n * @file plugin.js\n */\n/**\n * The base plugin name.\n *\n * @private\n * @constant\n * @type {string}\n */\nvar BASE_PLUGIN_NAME = 'plugin';\n\n/**\n * The key on which a player's active plugins cache is stored.\n *\n * @private\n * @constant\n * @type     {string}\n */\nvar PLUGIN_CACHE_KEY = 'activePlugins_';\n\n/**\n * Stores registered plugins in a private space.\n *\n * @private\n * @type    {Object}\n */\nvar pluginStorage = {};\n\n/**\n * Reports whether or not a plugin has been registered.\n *\n * @private\n * @param   {string} name\n *          The name of a plugin.\n *\n * @returns {boolean}\n *          Whether or not the plugin has been registered.\n */\nvar pluginExists = function pluginExists(name) {\n  return pluginStorage.hasOwnProperty(name);\n};\n\n/**\n * Get a single registered plugin by name.\n *\n * @private\n * @param   {string} name\n *          The name of a plugin.\n *\n * @returns {Function|undefined}\n *          The plugin (or undefined).\n */\nvar getPlugin = function getPlugin(name) {\n  return pluginExists(name) ? pluginStorage[name] : undefined;\n};\n\n/**\n * Marks a plugin as \"active\" on a player.\n *\n * Also, ensures that the player has an object for tracking active plugins.\n *\n * @private\n * @param   {Player} player\n *          A Video.js player instance.\n *\n * @param   {string} name\n *          The name of a plugin.\n */\nvar markPluginAsActive = function markPluginAsActive(player, name) {\n  player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};\n  player[PLUGIN_CACHE_KEY][name] = true;\n};\n\n/**\n * Triggers a pair of plugin setup events.\n *\n * @private\n * @param  {Player} player\n *         A Video.js player instance.\n *\n * @param  {Plugin~PluginEventHash} hash\n *         A plugin event hash.\n *\n * @param  {Boolean} [before]\n *         If true, prefixes the event name with \"before\". In other words,\n *         use this to trigger \"beforepluginsetup\" instead of \"pluginsetup\".\n */\nvar triggerSetupEvent = function triggerSetupEvent(player, hash, before) {\n  var eventName = (before ? 'before' : '') + 'pluginsetup';\n\n  player.trigger(eventName, hash);\n  player.trigger(eventName + ':' + hash.name, hash);\n};\n\n/**\n * Takes a basic plugin function and returns a wrapper function which marks\n * on the player that the plugin has been activated.\n *\n * @private\n * @param   {string} name\n *          The name of the plugin.\n *\n * @param   {Function} plugin\n *          The basic plugin.\n *\n * @returns {Function}\n *          A wrapper function for the given plugin.\n */\nvar createBasicPlugin = function createBasicPlugin(name, plugin) {\n  var basicPluginWrapper = function basicPluginWrapper() {\n\n    // We trigger the \"beforepluginsetup\" and \"pluginsetup\" events on the player\n    // regardless, but we want the hash to be consistent with the hash provided\n    // for advanced plugins.\n    //\n    // The only potentially counter-intuitive thing here is the `instance` in\n    // the \"pluginsetup\" event is the value returned by the `plugin` function.\n    triggerSetupEvent(this, { name: name, plugin: plugin, instance: null }, true);\n\n    var instance = plugin.apply(this, arguments);\n\n    markPluginAsActive(this, name);\n    triggerSetupEvent(this, { name: name, plugin: plugin, instance: instance });\n\n    return instance;\n  };\n\n  Object.keys(plugin).forEach(function (prop) {\n    basicPluginWrapper[prop] = plugin[prop];\n  });\n\n  return basicPluginWrapper;\n};\n\n/**\n * Takes a plugin sub-class and returns a factory function for generating\n * instances of it.\n *\n * This factory function will replace itself with an instance of the requested\n * sub-class of Plugin.\n *\n * @private\n * @param   {string} name\n *          The name of the plugin.\n *\n * @param   {Plugin} PluginSubClass\n *          The advanced plugin.\n *\n * @returns {Function}\n */\nvar createPluginFactory = function createPluginFactory(name, PluginSubClass) {\n\n  // Add a `name` property to the plugin prototype so that each plugin can\n  // refer to itself by name.\n  PluginSubClass.prototype.name = name;\n\n  return function () {\n    triggerSetupEvent(this, { name: name, plugin: PluginSubClass, instance: null }, true);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var instance = new (Function.prototype.bind.apply(PluginSubClass, [null].concat([this].concat(args))))();\n\n    // The plugin is replaced by a function that returns the current instance.\n    this[name] = function () {\n      return instance;\n    };\n\n    triggerSetupEvent(this, instance.getEventHash());\n\n    return instance;\n  };\n};\n\n/**\n * Parent class for all advanced plugins.\n *\n * @mixes   module:evented~EventedMixin\n * @mixes   module:stateful~StatefulMixin\n * @fires   Player#beforepluginsetup\n * @fires   Player#beforepluginsetup:$name\n * @fires   Player#pluginsetup\n * @fires   Player#pluginsetup:$name\n * @listens Player#dispose\n * @throws  {Error}\n *          If attempting to instantiate the base {@link Plugin} class\n *          directly instead of via a sub-class.\n */\n\nvar Plugin = function () {\n\n  /**\n   * Creates an instance of this class.\n   *\n   * Sub-classes should call `super` to ensure plugins are properly initialized.\n   *\n   * @param {Player} player\n   *        A Video.js player instance.\n   */\n  function Plugin(player) {\n    classCallCheck(this, Plugin);\n\n    if (this.constructor === Plugin) {\n      throw new Error('Plugin must be sub-classed; not directly instantiated.');\n    }\n\n    this.player = player;\n\n    // Make this object evented, but remove the added `trigger` method so we\n    // use the prototype version instead.\n    evented(this);\n    delete this.trigger;\n\n    stateful(this, this.constructor.defaultState);\n    markPluginAsActive(player, this.name);\n\n    // Auto-bind the dispose method so we can use it as a listener and unbind\n    // it later easily.\n    this.dispose = bind(this, this.dispose);\n\n    // If the player is disposed, dispose the plugin.\n    player.on('dispose', this.dispose);\n  }\n\n  /**\n   * Get the version of the plugin that was set on <pluginName>.VERSION\n   */\n\n\n  Plugin.prototype.version = function version() {\n    return this.constructor.VERSION;\n  };\n\n  /**\n   * Each event triggered by plugins includes a hash of additional data with\n   * conventional properties.\n   *\n   * This returns that object or mutates an existing hash.\n   *\n   * @param   {Object} [hash={}]\n   *          An object to be used as event an event hash.\n   *\n   * @returns {Plugin~PluginEventHash}\n   *          An event hash object with provided properties mixed-in.\n   */\n\n\n  Plugin.prototype.getEventHash = function getEventHash() {\n    var hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    hash.name = this.name;\n    hash.plugin = this.constructor;\n    hash.instance = this;\n    return hash;\n  };\n\n  /**\n   * Triggers an event on the plugin object and overrides\n   * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.\n   *\n   * @param   {string|Object} event\n   *          An event type or an object with a type property.\n   *\n   * @param   {Object} [hash={}]\n   *          Additional data hash to merge with a\n   *          {@link Plugin~PluginEventHash|PluginEventHash}.\n   *\n   * @returns {boolean}\n   *          Whether or not default was prevented.\n   */\n\n\n  Plugin.prototype.trigger = function trigger$$1(event) {\n    var hash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    return trigger(this.eventBusEl_, event, this.getEventHash(hash));\n  };\n\n  /**\n   * Handles \"statechanged\" events on the plugin. No-op by default, override by\n   * subclassing.\n   *\n   * @abstract\n   * @param    {Event} e\n   *           An event object provided by a \"statechanged\" event.\n   *\n   * @param    {Object} e.changes\n   *           An object describing changes that occurred with the \"statechanged\"\n   *           event.\n   */\n\n\n  Plugin.prototype.handleStateChanged = function handleStateChanged(e) {};\n\n  /**\n   * Disposes a plugin.\n   *\n   * Subclasses can override this if they want, but for the sake of safety,\n   * it's probably best to subscribe the \"dispose\" event.\n   *\n   * @fires Plugin#dispose\n   */\n\n\n  Plugin.prototype.dispose = function dispose() {\n    var name = this.name,\n        player = this.player;\n\n    /**\n     * Signals that a advanced plugin is about to be disposed.\n     *\n     * @event Plugin#dispose\n     * @type  {EventTarget~Event}\n     */\n\n    this.trigger('dispose');\n    this.off();\n    player.off('dispose', this.dispose);\n\n    // Eliminate any possible sources of leaking memory by clearing up\n    // references between the player and the plugin instance and nulling out\n    // the plugin's state and replacing methods with a function that throws.\n    player[PLUGIN_CACHE_KEY][name] = false;\n    this.player = this.state = null;\n\n    // Finally, replace the plugin name on the player with a new factory\n    // function, so that the plugin is ready to be set up again.\n    player[name] = createPluginFactory(name, pluginStorage[name]);\n  };\n\n  /**\n   * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).\n   *\n   * @param   {string|Function} plugin\n   *          If a string, matches the name of a plugin. If a function, will be\n   *          tested directly.\n   *\n   * @returns {boolean}\n   *          Whether or not a plugin is a basic plugin.\n   */\n\n\n  Plugin.isBasic = function isBasic(plugin) {\n    var p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;\n\n    return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);\n  };\n\n  /**\n   * Register a Video.js plugin.\n   *\n   * @param   {string} name\n   *          The name of the plugin to be registered. Must be a string and\n   *          must not match an existing plugin or a method on the `Player`\n   *          prototype.\n   *\n   * @param   {Function} plugin\n   *          A sub-class of `Plugin` or a function for basic plugins.\n   *\n   * @returns {Function}\n   *          For advanced plugins, a factory function for that plugin. For\n   *          basic plugins, a wrapper function that initializes the plugin.\n   */\n\n\n  Plugin.registerPlugin = function registerPlugin(name, plugin) {\n    if (typeof name !== 'string') {\n      throw new Error('Illegal plugin name, \"' + name + '\", must be a string, was ' + (typeof name === 'undefined' ? 'undefined' : _typeof(name)) + '.');\n    }\n\n    if (pluginExists(name)) {\n      log$1.warn('A plugin named \"' + name + '\" already exists. You may want to avoid re-registering plugins!');\n    } else if (Player.prototype.hasOwnProperty(name)) {\n      throw new Error('Illegal plugin name, \"' + name + '\", cannot share a name with an existing player method!');\n    }\n\n    if (typeof plugin !== 'function') {\n      throw new Error('Illegal plugin for \"' + name + '\", must be a function, was ' + (typeof plugin === 'undefined' ? 'undefined' : _typeof(plugin)) + '.');\n    }\n\n    pluginStorage[name] = plugin;\n\n    // Add a player prototype method for all sub-classed plugins (but not for\n    // the base Plugin class).\n    if (name !== BASE_PLUGIN_NAME) {\n      if (Plugin.isBasic(plugin)) {\n        Player.prototype[name] = createBasicPlugin(name, plugin);\n      } else {\n        Player.prototype[name] = createPluginFactory(name, plugin);\n      }\n    }\n\n    return plugin;\n  };\n\n  /**\n   * De-register a Video.js plugin.\n   *\n   * @param {string} name\n   *        The name of the plugin to be deregistered.\n   */\n\n\n  Plugin.deregisterPlugin = function deregisterPlugin(name) {\n    if (name === BASE_PLUGIN_NAME) {\n      throw new Error('Cannot de-register base plugin.');\n    }\n    if (pluginExists(name)) {\n      delete pluginStorage[name];\n      delete Player.prototype[name];\n    }\n  };\n\n  /**\n   * Gets an object containing multiple Video.js plugins.\n   *\n   * @param   {Array} [names]\n   *          If provided, should be an array of plugin names. Defaults to _all_\n   *          plugin names.\n   *\n   * @returns {Object|undefined}\n   *          An object containing plugin(s) associated with their name(s) or\n   *          `undefined` if no matching plugins exist).\n   */\n\n\n  Plugin.getPlugins = function getPlugins() {\n    var names = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.keys(pluginStorage);\n\n    var result = void 0;\n\n    names.forEach(function (name) {\n      var plugin = getPlugin(name);\n\n      if (plugin) {\n        result = result || {};\n        result[name] = plugin;\n      }\n    });\n\n    return result;\n  };\n\n  /**\n   * Gets a plugin's version, if available\n   *\n   * @param   {string} name\n   *          The name of a plugin.\n   *\n   * @returns {string}\n   *          The plugin's version or an empty string.\n   */\n\n\n  Plugin.getPluginVersion = function getPluginVersion(name) {\n    var plugin = getPlugin(name);\n\n    return plugin && plugin.VERSION || '';\n  };\n\n  return Plugin;\n}();\n\n/**\n * Gets a plugin by name if it exists.\n *\n * @static\n * @method   getPlugin\n * @memberOf Plugin\n * @param    {string} name\n *           The name of a plugin.\n *\n * @returns  {Function|undefined}\n *           The plugin (or `undefined`).\n */\n\n\nPlugin.getPlugin = getPlugin;\n\n/**\n * The name of the base plugin class as it is registered.\n *\n * @type {string}\n */\nPlugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;\n\nPlugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);\n\n/**\n * Documented in player.js\n *\n * @ignore\n */\nPlayer.prototype.usingPlugin = function (name) {\n  return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;\n};\n\n/**\n * Documented in player.js\n *\n * @ignore\n */\nPlayer.prototype.hasPlugin = function (name) {\n  return !!pluginExists(name);\n};\n\n/**\n * Signals that a plugin is about to be set up on a player.\n *\n * @event    Player#beforepluginsetup\n * @type     {Plugin~PluginEventHash}\n */\n\n/**\n * Signals that a plugin is about to be set up on a player - by name. The name\n * is the name of the plugin.\n *\n * @event    Player#beforepluginsetup:$name\n * @type     {Plugin~PluginEventHash}\n */\n\n/**\n * Signals that a plugin has just been set up on a player.\n *\n * @event    Player#pluginsetup\n * @type     {Plugin~PluginEventHash}\n */\n\n/**\n * Signals that a plugin has just been set up on a player - by name. The name\n * is the name of the plugin.\n *\n * @event    Player#pluginsetup:$name\n * @type     {Plugin~PluginEventHash}\n */\n\n/**\n * @typedef  {Object} Plugin~PluginEventHash\n *\n * @property {string} instance\n *           For basic plugins, the return value of the plugin function. For\n *           advanced plugins, the plugin instance on which the event is fired.\n *\n * @property {string} name\n *           The name of the plugin.\n *\n * @property {string} plugin\n *           For basic plugins, the plugin function. For advanced plugins, the\n *           plugin class/constructor.\n */\n\n/**\n * @file extend.js\n * @module extend\n */\n\n/**\n * A combination of node inherits and babel's inherits (after transpile).\n * Both work the same but node adds `super_` to the subClass\n * and Bable adds the superClass as __proto__. Both seem useful.\n *\n * @param {Object} subClass\n *        The class to inherit to\n *\n * @param {Object} superClass\n *        The class to inherit from\n *\n * @private\n */\nvar _inherits = function _inherits(subClass, superClass) {\n  if (typeof superClass !== 'function' && superClass !== null) {\n    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (superClass) {\n    // node\n    subClass.super_ = superClass;\n  }\n};\n\n/**\n * Function for subclassing using the same inheritance that\n * videojs uses internally\n *\n * @static\n * @const\n *\n * @param {Object} superClass\n *        The class to inherit from\n *\n * @param {Object} [subClassMethods={}]\n *        The class to inherit to\n *\n * @return {Object}\n *         The new object with subClassMethods that inherited superClass.\n */\nvar extendFn = function extendFn(superClass) {\n  var subClassMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var subClass = function subClass() {\n    superClass.apply(this, arguments);\n  };\n\n  var methods = {};\n\n  if ((typeof subClassMethods === 'undefined' ? 'undefined' : _typeof(subClassMethods)) === 'object') {\n    if (subClassMethods.constructor !== Object.prototype.constructor) {\n      subClass = subClassMethods.constructor;\n    }\n    methods = subClassMethods;\n  } else if (typeof subClassMethods === 'function') {\n    subClass = subClassMethods;\n  }\n\n  _inherits(subClass, superClass);\n\n  // Extend subObj's prototype with functions and other properties from props\n  for (var name in methods) {\n    if (methods.hasOwnProperty(name)) {\n      subClass.prototype[name] = methods[name];\n    }\n  }\n\n  return subClass;\n};\n\n/**\n * @file video.js\n * @module videojs\n */\n// Include the built-in techs\n// HTML5 Element Shim for IE8\nif (typeof HTMLVideoElement === 'undefined' && isReal()) {\n  document.createElement('video');\n  document.createElement('audio');\n  document.createElement('track');\n  document.createElement('video-js');\n}\n\n/**\n * Doubles as the main function for users to create a player instance and also\n * the main library object.\n * The `videojs` function can be used to initialize or retrieve a player.\n  *\n * @param {string|Element} id\n *        Video element or video element ID\n *\n * @param {Object} [options]\n *        Optional options object for config/settings\n *\n * @param {Component~ReadyCallback} [ready]\n *        Optional ready callback\n *\n * @return {Player}\n *         A player instance\n */\nfunction videojs(id, options, ready) {\n  var tag = void 0;\n\n  // Allow for element or ID to be passed in\n  // String ID\n  if (typeof id === 'string') {\n    var players = videojs.getPlayers();\n\n    // Adjust for jQuery ID syntax\n    if (id.indexOf('#') === 0) {\n      id = id.slice(1);\n    }\n\n    // If a player instance has already been created for this ID return it.\n    if (players[id]) {\n\n      // If options or ready function are passed, warn\n      if (options) {\n        log$1.warn('Player \"' + id + '\" is already initialised. Options will not be applied.');\n      }\n\n      if (ready) {\n        players[id].ready(ready);\n      }\n\n      return players[id];\n    }\n\n    // Otherwise get element for ID\n    tag = $('#' + id);\n\n    // ID is a media element\n  } else {\n    tag = id;\n  }\n\n  // Check for a useable element\n  // re: nodeName, could be a box div also\n  if (!tag || !tag.nodeName) {\n    throw new TypeError('The element or ID supplied is not valid. (videojs)');\n  }\n\n  // Element may have a player attr referring to an already created player instance.\n  // If so return that otherwise set up a new player below\n  if (tag.player || Player.players[tag.playerId]) {\n    return tag.player || Player.players[tag.playerId];\n  }\n\n  // Check if element is included in the DOM\n  if (isEl(tag) && !document.body.contains(tag)) {\n    log$1.warn('The element supplied is not included in the DOM');\n  }\n\n  options = options || {};\n\n  videojs.hooks('beforesetup').forEach(function (hookFunction) {\n    var opts = hookFunction(tag, mergeOptions(options));\n\n    if (!isObject(opts) || Array.isArray(opts)) {\n      log$1.error('please return an object in beforesetup hooks');\n      return;\n    }\n\n    options = mergeOptions(options, opts);\n  });\n\n  var PlayerComponent = Component.getComponent('Player');\n  // If not, set up a new player\n  var player = new PlayerComponent(tag, options, ready);\n\n  videojs.hooks('setup').forEach(function (hookFunction) {\n    return hookFunction(player);\n  });\n\n  return player;\n}\n\n/**\n * An Object that contains lifecycle hooks as keys which point to an array\n * of functions that are run when a lifecycle is triggered\n */\nvideojs.hooks_ = {};\n\n/**\n * Get a list of hooks for a specific lifecycle\n * @function videojs.hooks\n *\n * @param {string} type\n *        the lifecyle to get hooks from\n *\n * @param {Function|Function[]} [fn]\n *        Optionally add a hook (or hooks) to the lifecycle that your are getting.\n *\n * @return {Array}\n *         an array of hooks, or an empty array if there are none.\n */\nvideojs.hooks = function (type, fn) {\n  videojs.hooks_[type] = videojs.hooks_[type] || [];\n  if (fn) {\n    videojs.hooks_[type] = videojs.hooks_[type].concat(fn);\n  }\n  return videojs.hooks_[type];\n};\n\n/**\n * Add a function hook to a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle to hook the function to.\n *\n * @param {Function|Function[]}\n *        The function or array of functions to attach.\n */\nvideojs.hook = function (type, fn) {\n  videojs.hooks(type, fn);\n};\n\n/**\n * Add a function hook that will only run once to a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle to hook the function to.\n *\n * @param {Function|Function[]}\n *        The function or array of functions to attach.\n */\nvideojs.hookOnce = function (type, fn) {\n  videojs.hooks(type, [].concat(fn).map(function (original) {\n    var wrapper = function wrapper() {\n      videojs.removeHook(type, wrapper);\n      return original.apply(undefined, arguments);\n    };\n\n    return wrapper;\n  }));\n};\n\n/**\n * Remove a hook from a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle that the function hooked to\n *\n * @param {Function} fn\n *        The hooked function to remove\n *\n * @return {boolean}\n *         The function that was removed or undef\n */\nvideojs.removeHook = function (type, fn) {\n  var index = videojs.hooks(type).indexOf(fn);\n\n  if (index <= -1) {\n    return false;\n  }\n\n  videojs.hooks_[type] = videojs.hooks_[type].slice();\n  videojs.hooks_[type].splice(index, 1);\n\n  return true;\n};\n\n// Add default styles\nif (window.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {\n  var style = $('.vjs-styles-defaults');\n\n  if (!style) {\n    style = createStyleElement('vjs-styles-defaults');\n    var head = $('head');\n\n    if (head) {\n      head.insertBefore(style, head.firstChild);\n    }\n    setTextContent(style, '\\n      .video-js {\\n        width: 300px;\\n        height: 150px;\\n      }\\n\\n      .vjs-fluid {\\n        padding-top: 56.25%\\n      }\\n    ');\n  }\n}\n\n// Run Auto-load players\n// You have to wait at least once in case this script is loaded after your\n// video in the DOM (weird behavior only with minified version)\nautoSetupTimeout(1, videojs);\n\n/**\n * Current software version. Follows semver.\n *\n * @type {string}\n */\nvideojs.VERSION = version;\n\n/**\n * The global options object. These are the settings that take effect\n * if no overrides are specified when the player is created.\n *\n * @type {Object}\n */\nvideojs.options = Player.prototype.options_;\n\n/**\n * Get an object with the currently created players, keyed by player ID\n *\n * @return {Object}\n *         The created players\n */\nvideojs.getPlayers = function () {\n  return Player.players;\n};\n\n/**\n * Expose players object.\n *\n * @memberOf videojs\n * @property {Object} players\n */\nvideojs.players = Player.players;\n\n/**\n * Get a component class object by name\n *\n * @borrows Component.getComponent as videojs.getComponent\n */\nvideojs.getComponent = Component.getComponent;\n\n/**\n * Register a component so it can referred to by name. Used when adding to other\n * components, either through addChild `component.addChild('myComponent')` or through\n * default children options  `{ children: ['myComponent'] }`.\n *\n * > NOTE: You could also just initialize the component before adding.\n * `component.addChild(new MyComponent());`\n *\n * @param {string} name\n *        The class name of the component\n *\n * @param {Component} comp\n *        The component class\n *\n * @return {Component}\n *         The newly registered component\n */\nvideojs.registerComponent = function (name$$1, comp) {\n  if (Tech.isTech(comp)) {\n    log$1.warn('The ' + name$$1 + ' tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)');\n  }\n\n  Component.registerComponent.call(Component, name$$1, comp);\n};\n\n/**\n * Get a Tech class object by name\n *\n * @borrows Tech.getTech as videojs.getTech\n */\nvideojs.getTech = Tech.getTech;\n\n/**\n * Register a Tech so it can referred to by name.\n * This is used in the tech order for the player.\n *\n * @borrows Tech.registerTech as videojs.registerTech\n */\nvideojs.registerTech = Tech.registerTech;\n\nvideojs.use = use;\n\n/**\n * A suite of browser and device tests from {@link browser}.\n *\n * @type {Object}\n * @private\n */\nvideojs.browser = browser;\n\n/**\n * Whether or not the browser supports touch events. Included for backward\n * compatibility with 4.x, but deprecated. Use `videojs.browser.TOUCH_ENABLED`\n * instead going forward.\n *\n * @deprecated since version 5.0\n * @type {boolean}\n */\nvideojs.TOUCH_ENABLED = TOUCH_ENABLED;\n\n/**\n * Subclass an existing class\n * Mimics ES6 subclassing with the `extend` keyword\n *\n * @borrows extend:extendFn as videojs.extend\n */\nvideojs.extend = extendFn;\n\n/**\n * Merge two options objects recursively\n * Performs a deep merge like lodash.merge but **only merges plain objects**\n * (not arrays, elements, anything else)\n * Other values will be copied directly from the second object.\n *\n * @borrows merge-options:mergeOptions as videojs.mergeOptions\n */\nvideojs.mergeOptions = mergeOptions;\n\n/**\n * Change the context (this) of a function\n *\n * > NOTE: as of v5.0 we require an ES5 shim, so you should use the native\n * `function() {}.bind(newContext);` instead of this.\n *\n * @borrows fn:bind as videojs.bind\n */\nvideojs.bind = bind;\n\n/**\n * Register a Video.js plugin.\n *\n * @borrows plugin:registerPlugin as videojs.registerPlugin\n * @method registerPlugin\n *\n * @param  {string} name\n *         The name of the plugin to be registered. Must be a string and\n *         must not match an existing plugin or a method on the `Player`\n *         prototype.\n *\n * @param  {Function} plugin\n *         A sub-class of `Plugin` or a function for basic plugins.\n *\n * @return {Function}\n *         For advanced plugins, a factory function for that plugin. For\n *         basic plugins, a wrapper function that initializes the plugin.\n */\nvideojs.registerPlugin = Plugin.registerPlugin;\n\n/**\n * Deprecated method to register a plugin with Video.js\n *\n * @deprecated\n *        videojs.plugin() is deprecated; use videojs.registerPlugin() instead\n *\n * @param {string} name\n *        The plugin name\n *\n * @param {Plugin|Function} plugin\n *         The plugin sub-class or function\n */\nvideojs.plugin = function (name$$1, plugin) {\n  log$1.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');\n  return Plugin.registerPlugin(name$$1, plugin);\n};\n\n/**\n * Gets an object containing multiple Video.js plugins.\n *\n * @param  {Array} [names]\n *         If provided, should be an array of plugin names. Defaults to _all_\n *         plugin names.\n *\n * @return {Object|undefined}\n *         An object containing plugin(s) associated with their name(s) or\n *         `undefined` if no matching plugins exist).\n */\nvideojs.getPlugins = Plugin.getPlugins;\n\n/**\n * Gets a plugin by name if it exists.\n *\n * @param  {string} name\n *         The name of a plugin.\n *\n * @return {Function|undefined}\n *         The plugin (or `undefined`).\n */\nvideojs.getPlugin = Plugin.getPlugin;\n\n/**\n * Gets a plugin's version, if available\n *\n * @param  {string} name\n *         The name of a plugin.\n *\n * @return {string}\n *         The plugin's version or an empty string.\n */\nvideojs.getPluginVersion = Plugin.getPluginVersion;\n\n/**\n * Adding languages so that they're available to all players.\n * Example: `videojs.addLanguage('es', { 'Hello': 'Hola' });`\n *\n * @param {string} code\n *        The language code or dictionary property\n *\n * @param {Object} data\n *        The data values to be translated\n *\n * @return {Object}\n *         The resulting language dictionary object\n */\nvideojs.addLanguage = function (code, data) {\n  var _mergeOptions;\n\n  code = ('' + code).toLowerCase();\n\n  videojs.options.languages = mergeOptions(videojs.options.languages, (_mergeOptions = {}, _mergeOptions[code] = data, _mergeOptions));\n\n  return videojs.options.languages[code];\n};\n\n/**\n * Log messages\n *\n * @borrows log:log as videojs.log\n */\nvideojs.log = log$1;\n\n/**\n * Creates an emulated TimeRange object.\n *\n * @borrows time-ranges:createTimeRanges as videojs.createTimeRange\n */\n/**\n * @borrows time-ranges:createTimeRanges as videojs.createTimeRanges\n */\nvideojs.createTimeRange = videojs.createTimeRanges = createTimeRanges;\n\n/**\n * Format seconds as a time string, H:MM:SS or M:SS\n * Supplying a guide (in seconds) will force a number of leading zeros\n * to cover the length of the guide\n *\n * @borrows format-time:formatTime as videojs.formatTime\n */\nvideojs.formatTime = formatTime;\n\n/**\n * Resolve and parse the elements of a URL\n *\n * @borrows url:parseUrl as videojs.parseUrl\n */\nvideojs.parseUrl = parseUrl;\n\n/**\n * Returns whether the url passed is a cross domain request or not.\n *\n * @borrows url:isCrossOrigin as videojs.isCrossOrigin\n */\nvideojs.isCrossOrigin = isCrossOrigin;\n\n/**\n * Event target class.\n *\n * @borrows EventTarget as videojs.EventTarget\n */\nvideojs.EventTarget = EventTarget;\n\n/**\n * Add an event listener to element\n * It stores the handler function in a separate cache object\n * and adds a generic handler to the element's event,\n * along with a unique id (guid) to the element.\n *\n * @borrows events:on as videojs.on\n */\nvideojs.on = on;\n\n/**\n * Trigger a listener only once for an event\n *\n * @borrows events:one as videojs.one\n */\nvideojs.one = one;\n\n/**\n * Removes event listeners from an element\n *\n * @borrows events:off as videojs.off\n */\nvideojs.off = off;\n\n/**\n * Trigger an event for an element\n *\n * @borrows events:trigger as videojs.trigger\n */\nvideojs.trigger = trigger;\n\n/**\n * A cross-browser XMLHttpRequest wrapper. Here's a simple example:\n *\n * @param {Object} options\n *        settings for the request.\n *\n * @return {XMLHttpRequest|XDomainRequest}\n *         The request object.\n *\n * @see https://github.com/Raynos/xhr\n */\nvideojs.xhr = xhr;\n\n/**\n * TextTrack class\n *\n * @borrows TextTrack as videojs.TextTrack\n */\nvideojs.TextTrack = TextTrack;\n\n/**\n * export the AudioTrack class so that source handlers can create\n * AudioTracks and then add them to the players AudioTrackList\n *\n * @borrows AudioTrack as videojs.AudioTrack\n */\nvideojs.AudioTrack = AudioTrack;\n\n/**\n * export the VideoTrack class so that source handlers can create\n * VideoTracks and then add them to the players VideoTrackList\n *\n * @borrows VideoTrack as videojs.VideoTrack\n */\nvideojs.VideoTrack = VideoTrack;\n\n/**\n * Determines, via duck typing, whether or not a value is a DOM element.\n *\n * @borrows dom:isEl as videojs.isEl\n * @deprecated Use videojs.dom.isEl() instead\n */\n\n/**\n * Determines, via duck typing, whether or not a value is a text node.\n *\n * @borrows dom:isTextNode as videojs.isTextNode\n * @deprecated Use videojs.dom.isTextNode() instead\n */\n\n/**\n * Creates an element and applies properties.\n *\n * @borrows dom:createEl as videojs.createEl\n * @deprecated Use videojs.dom.createEl() instead\n */\n\n/**\n * Check if an element has a CSS class\n *\n * @borrows dom:hasElClass as videojs.hasClass\n * @deprecated Use videojs.dom.hasClass() instead\n */\n\n/**\n * Add a CSS class name to an element\n *\n * @borrows dom:addElClass as videojs.addClass\n * @deprecated Use videojs.dom.addClass() instead\n */\n\n/**\n * Remove a CSS class name from an element\n *\n * @borrows dom:removeElClass as videojs.removeClass\n * @deprecated Use videojs.dom.removeClass() instead\n */\n\n/**\n * Adds or removes a CSS class name on an element depending on an optional\n * condition or the presence/absence of the class name.\n *\n * @borrows dom:toggleElClass as videojs.toggleClass\n * @deprecated Use videojs.dom.toggleClass() instead\n */\n\n/**\n * Apply attributes to an HTML element.\n *\n * @borrows dom:setElAttributes as videojs.setAttribute\n * @deprecated Use videojs.dom.setAttributes() instead\n */\n\n/**\n * Get an element's attribute values, as defined on the HTML tag\n * Attributes are not the same as properties. They're defined on the tag\n * or with setAttribute (which shouldn't be used with HTML)\n * This will return true or false for boolean attributes.\n *\n * @borrows dom:getElAttributes as videojs.getAttributes\n * @deprecated Use videojs.dom.getAttributes() instead\n */\n\n/**\n * Empties the contents of an element.\n *\n * @borrows dom:emptyEl as videojs.emptyEl\n * @deprecated Use videojs.dom.emptyEl() instead\n */\n\n/**\n * Normalizes and appends content to an element.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * - String\n *   Normalized into a text node.\n *\n * - Element, TextNode\n *   Passed through.\n *\n * - Array\n *   A one-dimensional array of strings, elements, nodes, or functions (which\n *   return single strings, elements, or nodes).\n *\n * - Function\n *   If the sole argument, is expected to produce a string, element,\n *   node, or array.\n *\n * @borrows dom:appendContents as videojs.appendContet\n * @deprecated Use videojs.dom.appendContent() instead\n */\n\n/**\n * Normalizes and inserts content into an element; this is identical to\n * `appendContent()`, except it empties the element first.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * - String\n *   Normalized into a text node.\n *\n * - Element, TextNode\n *   Passed through.\n *\n * - Array\n *   A one-dimensional array of strings, elements, nodes, or functions (which\n *   return single strings, elements, or nodes).\n *\n * - Function\n *   If the sole argument, is expected to produce a string, element,\n *   node, or array.\n *\n * @borrows dom:insertContent as videojs.insertContent\n * @deprecated Use videojs.dom.insertContent() instead\n */\n['isEl', 'isTextNode', 'createEl', 'hasClass', 'addClass', 'removeClass', 'toggleClass', 'setAttributes', 'getAttributes', 'emptyEl', 'appendContent', 'insertContent'].forEach(function (k) {\n  videojs[k] = function () {\n    log$1.warn('videojs.' + k + '() is deprecated; use videojs.dom.' + k + '() instead');\n    return Dom[k].apply(null, arguments);\n  };\n});\n\n/**\n * A safe getComputedStyle with an IE8 fallback.\n *\n * This is because in Firefox, if the player is loaded in an iframe with `display:none`,\n * then `getComputedStyle` returns `null`, so, we do a null-check to make sure\n * that the player doesn't break in these cases.\n * See https://bugzilla.mozilla.org/show_bug.cgi?id=548397 for more details.\n *\n * @borrows computed-style:computedStyle as videojs.computedStyle\n */\nvideojs.computedStyle = computedStyle;\n\n/**\n * Export the Dom utilities for use in external plugins\n * and Tech's\n */\nvideojs.dom = Dom;\n\n/**\n * Export the Url utilities for use in external plugins\n * and Tech's\n */\nvideojs.url = Url;\n\nmodule.exports = videojs;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvZGlzdC92aWRlby5janMuanM/MGUyNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixpRkFBaUY7O0FBRWhIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7Ozs7Ozs7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O0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLG9DQUFvQztBQUNsRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtB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QUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsMEJBQTBCLDREQUE0RDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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OztBQUVEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsYUFBYSxPQUFPLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGFBQWEsT0FBTyxZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQSx1Q0FBdUMsbUJBQW1COztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHFDQUFxQztBQUMvQztBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSx3Q0FBd0M7QUFDOUM7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsNERBQTRELG1CQUFtQjs7QUFFL0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLDREQUE0RCxvQkFBb0I7O0FBRWhGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxpQkFBaUIs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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLElBQUk7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsdUJBQXVCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHFCQUFxQiw2Q0FBNkM7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsdUJBQXVCO0FBQzlDOztBQUVBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGtCQUFrQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx5QkFBeUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLDRCQUE0QjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDZEQUE2RCxXQUFXO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwwREFBMEQsV0FBVztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNERBQTRELFdBQVc7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSw0REFBNEQsV0FBVztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsK0RBQStELFdBQVc7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLCtEQUErRCxXQUFXO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwrREFBK0QsV0FBVztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMkRBQTJELFdBQVc7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGlFQUFpRSxXQUFXO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxvRUFBb0UsV0FBVztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLHFCQUFxQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTRELFdBQVc7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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MUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxR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QUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBWaWRlby5qcyA2LjYuMyA8aHR0cDovL3ZpZGVvanMuY29tLz5cbiAqIENvcHlyaWdodCBCcmlnaHRjb3ZlLCBJbmMuIDxodHRwczovL3d3dy5icmlnaHRjb3ZlLmNvbS8+XG4gKiBBdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjBcbiAqIDxodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9ibG9iL21hc3Rlci9MSUNFTlNFPlxuICpcbiAqIEluY2x1ZGVzIHZ0dC5qcyA8aHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvdnR0LmpzPlxuICogQXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wXG4gKiA8aHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvdnR0LmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0U+XG4gKi9cblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciB3aW5kb3cgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpKTtcbnZhciBkb2N1bWVudCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdnbG9iYWwvZG9jdW1lbnQnKSk7XG52YXIgdHNtbCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd0c21sJykpO1xudmFyIHNhZmVQYXJzZVR1cGxlID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3NhZmUtanNvbi1wYXJzZS90dXBsZScpKTtcbnZhciB4aHIgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgneGhyJykpO1xudmFyIHZ0dCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd2aWRlb2pzLXZ0dC5qcycpKTtcblxudmFyIHZlcnNpb24gPSBcIjYuNi4zXCI7XG5cbi8qKlxuICogQGZpbGUgYnJvd3Nlci5qc1xuICogQG1vZHVsZSBicm93c2VyXG4gKi9cbnZhciBVU0VSX0FHRU5UID0gd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbnZhciB3ZWJraXRWZXJzaW9uTWFwID0gL0FwcGxlV2ViS2l0XFwvKFtcXGQuXSspL2kuZXhlYyhVU0VSX0FHRU5UKTtcbnZhciBhcHBsZVdlYmtpdFZlcnNpb24gPSB3ZWJraXRWZXJzaW9uTWFwID8gcGFyc2VGbG9hdCh3ZWJraXRWZXJzaW9uTWFwLnBvcCgpKSA6IG51bGw7XG5cbi8qXG4gKiBEZXZpY2UgaXMgYW4gaVBob25lXG4gKlxuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAY29uc3RhbnRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBJU19JUEFEID0gL2lQYWQvaS50ZXN0KFVTRVJfQUdFTlQpO1xuXG4vLyBUaGUgRmFjZWJvb2sgYXBwJ3MgVUlXZWJWaWV3IGlkZW50aWZpZXMgYXMgYm90aCBhbiBpUGhvbmUgYW5kIGlQYWQsIHNvXG4vLyB0byBpZGVudGlmeSBpUGhvbmVzLCB3ZSBuZWVkIHRvIGV4Y2x1ZGUgaVBhZHMuXG4vLyBodHRwOi8vYXJ0c3kuZ2l0aHViLmlvL2Jsb2cvMjAxMi8xMC8xOC90aGUtcGVyaWxzLW9mLWlvcy11c2VyLWFnZW50LXNuaWZmaW5nL1xudmFyIElTX0lQSE9ORSA9IC9pUGhvbmUvaS50ZXN0KFVTRVJfQUdFTlQpICYmICFJU19JUEFEO1xudmFyIElTX0lQT0QgPSAvaVBvZC9pLnRlc3QoVVNFUl9BR0VOVCk7XG52YXIgSVNfSU9TID0gSVNfSVBIT05FIHx8IElTX0lQQUQgfHwgSVNfSVBPRDtcblxudmFyIElPU19WRVJTSU9OID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWF0Y2ggPSBVU0VSX0FHRU5ULm1hdGNoKC9PUyAoXFxkKylfL2kpO1xuXG4gIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkge1xuICAgIHJldHVybiBtYXRjaFsxXTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0oKTtcblxudmFyIElTX0FORFJPSUQgPSAvQW5kcm9pZC9pLnRlc3QoVVNFUl9BR0VOVCk7XG52YXIgQU5EUk9JRF9WRVJTSU9OID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaGlzIG1hdGNoZXMgQW5kcm9pZCBNYWpvci5NaW5vci5QYXRjaCB2ZXJzaW9uc1xuICAvLyBBTkRST0lEX1ZFUlNJT04gaXMgTWFqb3IuTWlub3IgYXMgYSBOdW1iZXIsIGlmIE1pbm9yIGlzbid0IGF2YWlsYWJsZSwgdGhlbiBvbmx5IE1ham9yIGlzIHJldHVybmVkXG4gIHZhciBtYXRjaCA9IFVTRVJfQUdFTlQubWF0Y2goL0FuZHJvaWQgKFxcZCspKD86XFwuKFxcZCspKT8oPzpcXC4oXFxkKykpKi9pKTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWFqb3IgPSBtYXRjaFsxXSAmJiBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIG1pbm9yID0gbWF0Y2hbMl0gJiYgcGFyc2VGbG9hdChtYXRjaFsyXSk7XG5cbiAgaWYgKG1ham9yICYmIG1pbm9yKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMV0gKyAnLicgKyBtYXRjaFsyXSk7XG4gIH0gZWxzZSBpZiAobWFqb3IpIHtcbiAgICByZXR1cm4gbWFqb3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KCk7XG5cbi8vIE9sZCBBbmRyb2lkIGlzIGRlZmluZWQgYXMgVmVyc2lvbiBvbGRlciB0aGFuIDIuMywgYW5kIHJlcXVpcmluZyBhIHdlYmtpdCB2ZXJzaW9uIG9mIHRoZSBhbmRyb2lkIGJyb3dzZXJcbnZhciBJU19PTERfQU5EUk9JRCA9IElTX0FORFJPSUQgJiYgL3dlYmtpdC9pLnRlc3QoVVNFUl9BR0VOVCkgJiYgQU5EUk9JRF9WRVJTSU9OIDwgMi4zO1xudmFyIElTX05BVElWRV9BTkRST0lEID0gSVNfQU5EUk9JRCAmJiBBTkRST0lEX1ZFUlNJT04gPCA1ICYmIGFwcGxlV2Via2l0VmVyc2lvbiA8IDUzNztcblxudmFyIElTX0ZJUkVGT1ggPSAvRmlyZWZveC9pLnRlc3QoVVNFUl9BR0VOVCk7XG52YXIgSVNfRURHRSA9IC9FZGdlL2kudGVzdChVU0VSX0FHRU5UKTtcbnZhciBJU19DSFJPTUUgPSAhSVNfRURHRSAmJiAvQ2hyb21lL2kudGVzdChVU0VSX0FHRU5UKTtcbnZhciBDSFJPTUVfVkVSU0lPTiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1hdGNoID0gVVNFUl9BR0VOVC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG5cbiAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB9XG4gIHJldHVybiBudWxsO1xufSgpO1xudmFyIElTX0lFOCA9IC9NU0lFXFxzOFxcLjAvLnRlc3QoVVNFUl9BR0VOVCk7XG52YXIgSUVfVkVSU0lPTiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlc3VsdCA9IC9NU0lFXFxzKFxcZCspXFwuXFxkLy5leGVjKFVTRVJfQUdFTlQpO1xuICB2YXIgdmVyc2lvbiA9IHJlc3VsdCAmJiBwYXJzZUZsb2F0KHJlc3VsdFsxXSk7XG5cbiAgaWYgKCF2ZXJzaW9uICYmIC9UcmlkZW50XFwvNy4wL2kudGVzdChVU0VSX0FHRU5UKSAmJiAvcnY6MTEuMC8udGVzdChVU0VSX0FHRU5UKSkge1xuICAgIC8vIElFIDExIGhhcyBhIGRpZmZlcmVudCB1c2VyIGFnZW50IHN0cmluZyB0aGFuIG90aGVyIElFIHZlcnNpb25zXG4gICAgdmVyc2lvbiA9IDExLjA7XG4gIH1cblxuICByZXR1cm4gdmVyc2lvbjtcbn0oKTtcblxudmFyIElTX1NBRkFSSSA9IC9TYWZhcmkvaS50ZXN0KFVTRVJfQUdFTlQpICYmICFJU19DSFJPTUUgJiYgIUlTX0FORFJPSUQgJiYgIUlTX0VER0U7XG52YXIgSVNfQU5ZX1NBRkFSSSA9IElTX1NBRkFSSSB8fCBJU19JT1M7XG5cbnZhciBUT1VDSF9FTkFCTEVEID0gaXNSZWFsKCkgJiYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiB3aW5kb3cuZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCk7XG5cbnZhciBCQUNLR1JPVU5EX1NJWkVfU1VQUE9SVEVEID0gaXNSZWFsKCkgJiYgJ2JhY2tncm91bmRTaXplJyBpbiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKS5zdHlsZTtcblxudmFyIGJyb3dzZXIgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0SVNfSVBBRDogSVNfSVBBRCxcblx0SVNfSVBIT05FOiBJU19JUEhPTkUsXG5cdElTX0lQT0Q6IElTX0lQT0QsXG5cdElTX0lPUzogSVNfSU9TLFxuXHRJT1NfVkVSU0lPTjogSU9TX1ZFUlNJT04sXG5cdElTX0FORFJPSUQ6IElTX0FORFJPSUQsXG5cdEFORFJPSURfVkVSU0lPTjogQU5EUk9JRF9WRVJTSU9OLFxuXHRJU19PTERfQU5EUk9JRDogSVNfT0xEX0FORFJPSUQsXG5cdElTX05BVElWRV9BTkRST0lEOiBJU19OQVRJVkVfQU5EUk9JRCxcblx0SVNfRklSRUZPWDogSVNfRklSRUZPWCxcblx0SVNfRURHRTogSVNfRURHRSxcblx0SVNfQ0hST01FOiBJU19DSFJPTUUsXG5cdENIUk9NRV9WRVJTSU9OOiBDSFJPTUVfVkVSU0lPTixcblx0SVNfSUU4OiBJU19JRTgsXG5cdElFX1ZFUlNJT046IElFX1ZFUlNJT04sXG5cdElTX1NBRkFSSTogSVNfU0FGQVJJLFxuXHRJU19BTllfU0FGQVJJOiBJU19BTllfU0FGQVJJLFxuXHRUT1VDSF9FTkFCTEVEOiBUT1VDSF9FTkFCTEVELFxuXHRCQUNLR1JPVU5EX1NJWkVfU1VQUE9SVEVEOiBCQUNLR1JPVU5EX1NJWkVfU1VQUE9SVEVEXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UgPSBmdW5jdGlvbiAoc3RyaW5ncywgcmF3KSB7XG4gIHN0cmluZ3MucmF3ID0gcmF3O1xuICByZXR1cm4gc3RyaW5ncztcbn07XG5cbi8qKlxuICogQGZpbGUgb2JqLmpzXG4gKiBAbW9kdWxlIG9ialxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9iajpFYWNoQ2FsbGJhY2tcbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogICAgICAgIFRoZSBjdXJyZW50IGtleSBmb3IgdGhlIG9iamVjdCB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogICAgICAgIFRoZSBjdXJyZW50IGtleS12YWx1ZSBmb3Igb2JqZWN0IHRoYXQgaXMgYmVpbmcgaXRlcmF0ZWQgb3ZlclxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9iajpSZWR1Y2VDYWxsYmFja1xuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFjY3VtXG4gKiAgICAgICAgVGhlIHZhbHVlIHRoYXQgaXMgYWNjdW11bGF0aW5nIG92ZXIgdGhlIHJlZHVjZSBsb29wLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiAgICAgICAgVGhlIGN1cnJlbnQga2V5IGZvciB0aGUgb2JqZWN0IHRoYXQgaXMgYmVpbmcgaXRlcmF0ZWQgb3Zlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiAgICAgICAgVGhlIGN1cnJlbnQga2V5LXZhbHVlIGZvciBvYmplY3QgdGhhdCBpcyBiZWluZyBpdGVyYXRlZCBvdmVyXG4gKlxuICogQHJldHVybiB7TWl4ZWR9XG4gKiAgICAgICAgIFRoZSBuZXcgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogR2V0IHRoZSBrZXlzIG9mIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogICAgICAgIFRoZSBPYmplY3QgdG8gZ2V0IHRoZSBrZXlzIGZyb21cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX1cbiAqICAgICAgICAgQW4gYXJyYXkgb2YgdGhlIGtleXMgZnJvbSB0aGUgb2JqZWN0LiBSZXR1cm5zIGFuIGVtcHR5IGFycmF5IGlmIHRoZVxuICogICAgICAgICBvYmplY3QgcGFzc2VkIGluIHdhcyBpbnZhbGlkIG9yIGhhZCBubyBrZXlzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBrZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgPyBPYmplY3Qua2V5cyhvYmplY3QpIDogW107XG59O1xuXG4vKipcbiAqIEFycmF5LWxpa2UgaXRlcmF0aW9uIGZvciBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqICAgICAgICBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3ZlclxuICpcbiAqIEBwYXJhbSB7b2JqOkVhY2hDYWxsYmFja30gZm5cbiAqICAgICAgICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGZvciBlYWNoIGtleSBpbiB0aGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBlYWNoKG9iamVjdCwgZm4pIHtcbiAga2V5cyhvYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBmbihvYmplY3Rba2V5XSwga2V5KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQXJyYXktbGlrZSByZWR1Y2UgZm9yIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogICAgICAgIFRoZSBPYmplY3QgdGhhdCB5b3Ugd2FudCB0byByZWR1Y2UuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqICAgICAgICAgQSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZm9yIGVhY2gga2V5IGluIHRoZSBvYmplY3QuIEl0XG4gKiAgICAgICAgIHJlY2VpdmVzIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBhbmQgdGhlIHBlci1pdGVyYXRpb24gdmFsdWUgYW5kIGtleVxuICogICAgICAgICBhcyBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gW2luaXRpYWwgPSAwXVxuICogICAgICAgIFN0YXJ0aW5nIHZhbHVlXG4gKlxuICogQHJldHVybiB7TWl4ZWR9XG4gKiAgICAgICAgIFRoZSBmaW5hbCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcmVkdWNlKG9iamVjdCwgZm4pIHtcbiAgdmFyIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG5cbiAgcmV0dXJuIGtleXMob2JqZWN0KS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBrZXkpIHtcbiAgICByZXR1cm4gZm4oYWNjdW0sIG9iamVjdFtrZXldLCBrZXkpO1xuICB9LCBpbml0aWFsKTtcbn1cblxuLyoqXG4gKiBPYmplY3QuYXNzaWduLXN0eWxlIG9iamVjdCBzaGFsbG93IG1lcmdlL2V4dGVuZC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtICB7T2JqZWN0fSAuLi5zb3VyY2VzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc291cmNlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoT2JqZWN0LmFzc2lnbikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgW3RhcmdldF0uY29uY2F0KHNvdXJjZXMpKTtcbiAgfVxuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlYWNoKHNvdXJjZSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgdmFsdWUgaXMgYW4gb2JqZWN0IG9mIGFueSBraW5kIC0gaW5jbHVkaW5nIERPTSBub2RlcyxcbiAqIGFycmF5cywgcmVndWxhciBleHByZXNzaW9ucywgZXRjLiBOb3QgZnVuY3Rpb25zLCB0aG91Z2guXG4gKlxuICogVGhpcyBhdm9pZHMgdGhlIGdvdGNoYSB3aGVyZSB1c2luZyBgdHlwZW9mYCBvbiBhIGBudWxsYCB2YWx1ZVxuICogcmVzdWx0cyBpbiBgJ29iamVjdCdgLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgYXBwZWFycyB0byBiZSBhIFwicGxhaW5cIiBvYmplY3QgLSB0aGF0IGlzLCBhXG4gKiBkaXJlY3QgaW5zdGFuY2Ugb2YgYE9iamVjdGAuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufVxuXG4vKipcbiAqIEBmaWxlIGxvZy5qc1xuICogQG1vZHVsZSBsb2dcbiAqL1xudmFyIGxvZyA9IHZvaWQgMDtcblxuLy8gVGhpcyBpcyB0aGUgcHJpdmF0ZSB0cmFja2luZyB2YXJpYWJsZSBmb3IgbG9nZ2luZyBsZXZlbC5cbnZhciBsZXZlbCA9ICdpbmZvJztcblxuLy8gVGhpcyBpcyB0aGUgcHJpdmF0ZSB0cmFja2luZyB2YXJpYWJsZSBmb3IgdGhlIGxvZ2dpbmcgaGlzdG9yeS5cbnZhciBoaXN0b3J5ID0gW107XG5cbi8qKlxuICogTG9nIG1lc3NhZ2VzIHRvIHRoZSBjb25zb2xlIGFuZCBoaXN0b3J5IGJhc2VkIG9uIHRoZSB0eXBlIG9mIG1lc3NhZ2VcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBjb25zb2xlIG1ldGhvZCB0byB1c2UuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGFyZ3NcbiAqICAgICAgICAgVGhlIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gdGhlIG1hdGNoaW5nIGNvbnNvbGUgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtzdHJpbmdpZnldXG4gKiAgICAgICAgIEJ5IGRlZmF1bHQsIG9ubHkgb2xkIElFcyBzaG91bGQgZ2V0IGNvbnNvbGUgYXJndW1lbnQgc3RyaW5naWZpY2F0aW9uLFxuICogICAgICAgICBidXQgdGhpcyBpcyBleHBvc2VkIGFzIGEgcGFyYW1ldGVyIHRvIGZhY2lsaXRhdGUgdGVzdGluZy5cbiAqL1xudmFyIGxvZ0J5VHlwZSA9IGZ1bmN0aW9uIGxvZ0J5VHlwZSh0eXBlLCBhcmdzKSB7XG4gIHZhciBzdHJpbmdpZnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICEhSUVfVkVSU0lPTiAmJiBJRV9WRVJTSU9OIDwgMTE7XG5cbiAgdmFyIGx2bCA9IGxvZy5sZXZlbHNbbGV2ZWxdO1xuICB2YXIgbHZsUmVnRXhwID0gbmV3IFJlZ0V4cCgnXignICsgbHZsICsgJykkJyk7XG5cbiAgaWYgKHR5cGUgIT09ICdsb2cnKSB7XG5cbiAgICAvLyBBZGQgdGhlIHR5cGUgdG8gdGhlIGZyb250IG9mIHRoZSBtZXNzYWdlIHdoZW4gaXQncyBub3QgXCJsb2dcIi5cbiAgICBhcmdzLnVuc2hpZnQodHlwZS50b1VwcGVyQ2FzZSgpICsgJzonKTtcbiAgfVxuXG4gIC8vIEFkZCBhIGNsb25lIG9mIHRoZSBhcmdzIGF0IHRoaXMgcG9pbnQgdG8gaGlzdG9yeS5cbiAgaWYgKGhpc3RvcnkpIHtcbiAgICBoaXN0b3J5LnB1c2goW10uY29uY2F0KGFyZ3MpKTtcbiAgfVxuXG4gIC8vIEFkZCBjb25zb2xlIHByZWZpeCBhZnRlciBhZGRpbmcgdG8gaGlzdG9yeS5cbiAgYXJncy51bnNoaWZ0KCdWSURFT0pTOicpO1xuXG4gIC8vIElmIHRoZXJlJ3Mgbm8gY29uc29sZSB0aGVuIGRvbid0IHRyeSB0byBvdXRwdXQgbWVzc2FnZXMsIGJ1dCB0aGV5IHdpbGxcbiAgLy8gc3RpbGwgYmUgc3RvcmVkIGluIGhpc3RvcnkuXG4gIGlmICghd2luZG93LmNvbnNvbGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBXYXMgc2V0dGluZyB0aGVzZSBvbmNlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbiwgYnV0IGNvbnRhaW5pbmcgdGhlbVxuICAvLyBpbiB0aGUgZnVuY3Rpb24gbWFrZXMgaXQgZWFzaWVyIHRvIHRlc3QgY2FzZXMgd2hlcmUgY29uc29sZSBkb2Vzbid0IGV4aXN0XG4gIC8vIHdoZW4gdGhlIG1vZHVsZSBpcyBleGVjdXRlZC5cbiAgdmFyIGZuID0gd2luZG93LmNvbnNvbGVbdHlwZV07XG5cbiAgaWYgKCFmbiAmJiB0eXBlID09PSAnZGVidWcnKSB7XG4gICAgLy8gQ2VydGFpbiBicm93c2VycyBkb24ndCBoYXZlIHN1cHBvcnQgZm9yIGNvbnNvbGUuZGVidWcuIEZvciB0aG9zZSwgd2VcbiAgICAvLyBzaG91bGQgZGVmYXVsdCB0byB0aGUgY2xvc2VzdCBjb21wYXJhYmxlIGxvZy5cbiAgICBmbiA9IHdpbmRvdy5jb25zb2xlLmluZm8gfHwgd2luZG93LmNvbnNvbGUubG9nO1xuICB9XG5cbiAgLy8gQmFpbCBvdXQgaWYgdGhlcmUncyBubyBjb25zb2xlIG9yIGlmIHRoaXMgdHlwZSBpcyBub3QgYWxsb3dlZCBieSB0aGVcbiAgLy8gY3VycmVudCBsb2dnaW5nIGxldmVsLlxuICBpZiAoIWZuIHx8ICFsdmwgfHwgIWx2bFJlZ0V4cC50ZXN0KHR5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSUVzIHByZXZpb3VzIHRvIDExIGxvZyBvYmplY3RzIHVzZWxlc3NseSBhcyBcIltvYmplY3QgT2JqZWN0XVwiOyBzbywgSlNPTmlmeVxuICAvLyBvYmplY3RzIGFuZCBhcnJheXMgZm9yIHRob3NlIGxlc3MtY2FwYWJsZSBicm93c2Vycy5cbiAgaWYgKHN0cmluZ2lmeSkge1xuICAgIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgaWYgKGlzT2JqZWN0KGEpIHx8IEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENhc3QgdG8gc3RyaW5nIGJlZm9yZSBqb2luaW5nLCBzbyB3ZSBnZXQgbnVsbCBhbmQgdW5kZWZpbmVkIGV4cGxpY2l0bHlcbiAgICAgIC8vIGluY2x1ZGVkIGluIG91dHB1dCAoYXMgd2Ugd291bGQgaW4gYSBtb2Rlcm4gY29uc29sZSkuXG4gICAgICByZXR1cm4gU3RyaW5nKGEpO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxuXG4gIC8vIE9sZCBJRSB2ZXJzaW9ucyBkbyBub3QgYWxsb3cgLmFwcGx5KCkgZm9yIGNvbnNvbGUgbWV0aG9kcyAodGhleSBhcmVcbiAgLy8gcmVwb3J0ZWQgYXMgb2JqZWN0cyByYXRoZXIgdGhhbiBmdW5jdGlvbnMpLlxuICBpZiAoIWZuLmFwcGx5KSB7XG4gICAgZm4oYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgZm5bQXJyYXkuaXNBcnJheShhcmdzKSA/ICdhcHBseScgOiAnY2FsbCddKHdpbmRvdy5jb25zb2xlLCBhcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBMb2dzIHBsYWluIGRlYnVnIG1lc3NhZ2VzLiBTaW1pbGFyIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0gICAge01peGVkW119IGFyZ3NcbiAqICAgICAgICAgICBPbmUgb3IgbW9yZSBtZXNzYWdlcyBvciBvYmplY3RzIHRoYXQgc2hvdWxkIGJlIGxvZ2dlZC5cbiAqL1xubG9nID0gZnVuY3Rpb24gbG9nKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBsb2dCeVR5cGUoJ2xvZycsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBhdmFpbGFibGUgbG9nZ2luZyBsZXZlbHMsIHdoZXJlIHRoZSBrZXlzIGFyZSB0aGUgbGV2ZWwgbmFtZXNcbiAqIGFuZCB0aGUgdmFsdWVzIGFyZSBgfGAtc2VwYXJhdGVkIHN0cmluZ3MgY29udGFpbmluZyBsb2dnaW5nIG1ldGhvZHMgYWxsb3dlZFxuICogaW4gdGhhdCBsb2dnaW5nIGxldmVsLiBUaGVzZSBzdHJpbmdzIGFyZSB1c2VkIHRvIGNyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICogbWF0Y2hpbmcgdGhlIGZ1bmN0aW9uIG5hbWUgYmVpbmcgY2FsbGVkLlxuICpcbiAqIExldmVscyBwcm92aWRlZCBieSB2aWRlby5qcyBhcmU6XG4gKlxuICogLSBgb2ZmYDogTWF0Y2hlcyBubyBjYWxscy4gQW55IHZhbHVlIHRoYXQgY2FuIGJlIGNhc3QgdG8gYGZhbHNlYCB3aWxsIGhhdmVcbiAqICAgdGhpcyBlZmZlY3QuIFRoZSBtb3N0IHJlc3RyaWN0aXZlLlxuICogLSBgYWxsYDogTWF0Y2hlcyBvbmx5IFZpZGVvLmpzLXByb3ZpZGVkIGZ1bmN0aW9ucyAoYGRlYnVnYCwgYGxvZ2AsXG4gKiAgIGBsb2cud2FybmAsIGFuZCBgbG9nLmVycm9yYCkuXG4gKiAtIGBkZWJ1Z2A6IE1hdGNoZXMgYGxvZy5kZWJ1Z2AsIGBsb2dgLCBgbG9nLndhcm5gLCBhbmQgYGxvZy5lcnJvcmAgY2FsbHMuXG4gKiAtIGBpbmZvYCAoZGVmYXVsdCk6IE1hdGNoZXMgYGxvZ2AsIGBsb2cud2FybmAsIGFuZCBgbG9nLmVycm9yYCBjYWxscy5cbiAqIC0gYHdhcm5gOiBNYXRjaGVzIGBsb2cud2FybmAgYW5kIGBsb2cuZXJyb3JgIGNhbGxzLlxuICogLSBgZXJyb3JgOiBNYXRjaGVzIG9ubHkgYGxvZy5lcnJvcmAgY2FsbHMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xubG9nLmxldmVscyA9IHtcbiAgYWxsOiAnZGVidWd8bG9nfHdhcm58ZXJyb3InLFxuICBvZmY6ICcnLFxuICBkZWJ1ZzogJ2RlYnVnfGxvZ3x3YXJufGVycm9yJyxcbiAgaW5mbzogJ2xvZ3x3YXJufGVycm9yJyxcbiAgd2FybjogJ3dhcm58ZXJyb3InLFxuICBlcnJvcjogJ2Vycm9yJyxcbiAgREVGQVVMVDogbGV2ZWxcbn07XG5cbi8qKlxuICogR2V0IG9yIHNldCB0aGUgY3VycmVudCBsb2dnaW5nIGxldmVsLiBJZiBhIHN0cmluZyBtYXRjaGluZyBhIGtleSBmcm9tXG4gKiB7QGxpbmsgbG9nLmxldmVsc30gaXMgcHJvdmlkZWQsIGFjdHMgYXMgYSBzZXR0ZXIuIFJlZ2FyZGxlc3Mgb2YgYXJndW1lbnQsXG4gKiByZXR1cm5zIHRoZSBjdXJyZW50IGxvZ2dpbmcgbGV2ZWwuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBbbHZsXVxuICogICAgICAgICBQYXNzIHRvIHNldCBhIG5ldyBsb2dnaW5nIGxldmVsLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIGN1cnJlbnQgbG9nZ2luZyBsZXZlbC5cbiAqL1xubG9nLmxldmVsID0gZnVuY3Rpb24gKGx2bCkge1xuICBpZiAodHlwZW9mIGx2bCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIWxvZy5sZXZlbHMuaGFzT3duUHJvcGVydHkobHZsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBsdmwgKyAnXCIgaW4gbm90IGEgdmFsaWQgbG9nIGxldmVsJyk7XG4gICAgfVxuICAgIGxldmVsID0gbHZsO1xuICB9XG4gIHJldHVybiBsZXZlbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGV2ZXJ5dGhpbmcgdGhhdCBoYXMgYmVlbiBsb2dnZWQgdG8gdGhlIGhpc3RvcnkuXG4gKlxuICogVGhpcyBhcnJheSBpcyBhIHNoYWxsb3cgY2xvbmUgb2YgdGhlIGludGVybmFsIGhpc3RvcnkgcmVjb3JkLiBIb3dldmVyLCBpdHNcbiAqIGNvbnRlbnRzIGFyZSBfbm90XyBjbG9uZWQ7IHNvLCBtdXRhdGluZyBvYmplY3RzIGluc2lkZSB0aGlzIGFycmF5IHdpbGxcbiAqIG11dGF0ZSB0aGVtIGluIGhpc3RvcnkuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmxvZy5oaXN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaGlzdG9yeSA/IFtdLmNvbmNhdChoaXN0b3J5KSA6IFtdO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGludGVybmFsIGhpc3RvcnkgdHJhY2tpbmcsIGJ1dCBkb2VzIG5vdCBwcmV2ZW50IGZ1cnRoZXIgaGlzdG9yeVxuICogdHJhY2tpbmcuXG4gKi9cbmxvZy5oaXN0b3J5LmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaGlzdG9yeSkge1xuICAgIGhpc3RvcnkubGVuZ3RoID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBEaXNhYmxlIGhpc3RvcnkgdHJhY2tpbmcgaWYgaXQgaXMgY3VycmVudGx5IGVuYWJsZWQuXG4gKi9cbmxvZy5oaXN0b3J5LmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChoaXN0b3J5ICE9PSBudWxsKSB7XG4gICAgaGlzdG9yeS5sZW5ndGggPSAwO1xuICAgIGhpc3RvcnkgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEVuYWJsZSBoaXN0b3J5IHRyYWNraW5nIGlmIGl0IGlzIGN1cnJlbnRseSBkaXNhYmxlZC5cbiAqL1xubG9nLmhpc3RvcnkuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaGlzdG9yeSA9PT0gbnVsbCkge1xuICAgIGhpc3RvcnkgPSBbXTtcbiAgfVxufTtcblxuLyoqXG4gKiBMb2dzIGVycm9yIG1lc3NhZ2VzLiBTaW1pbGFyIHRvIGBjb25zb2xlLmVycm9yYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkW119IGFyZ3NcbiAqICAgICAgICBPbmUgb3IgbW9yZSBtZXNzYWdlcyBvciBvYmplY3RzIHRoYXQgc2hvdWxkIGJlIGxvZ2dlZCBhcyBhbiBlcnJvclxuICovXG5sb2cuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgcmV0dXJuIGxvZ0J5VHlwZSgnZXJyb3InLCBhcmdzKTtcbn07XG5cbi8qKlxuICogTG9ncyB3YXJuaW5nIG1lc3NhZ2VzLiBTaW1pbGFyIHRvIGBjb25zb2xlLndhcm5gLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWRbXX0gYXJnc1xuICogICAgICAgIE9uZSBvciBtb3JlIG1lc3NhZ2VzIG9yIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgbG9nZ2VkIGFzIGEgd2FybmluZy5cbiAqL1xubG9nLndhcm4gPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG5cbiAgcmV0dXJuIGxvZ0J5VHlwZSgnd2FybicsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBMb2dzIGRlYnVnIG1lc3NhZ2VzLiBTaW1pbGFyIHRvIGBjb25zb2xlLmRlYnVnYCwgYnV0IG1heSBhbHNvIGFjdCBhcyBhIGNvbXBhcmFibGVcbiAqIGxvZyBpZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZVxuICpcbiAqIEBwYXJhbSB7TWl4ZWRbXX0gYXJnc1xuICogICAgICAgIE9uZSBvciBtb3JlIG1lc3NhZ2VzIG9yIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgbG9nZ2VkIGFzIGRlYnVnLlxuICovXG5sb2cuZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgcmV0dXJuIGxvZ0J5VHlwZSgnZGVidWcnLCBhcmdzKTtcbn07XG5cbnZhciBsb2ckMSA9IGxvZztcblxuLyoqXG4gKiBAZmlsZSBjb21wdXRlZC1zdHlsZS5qc1xuICogQG1vZHVsZSBjb21wdXRlZC1zdHlsZVxuICovXG4vKipcbiAqIEEgc2FmZSBnZXRDb21wdXRlZFN0eWxlIHdpdGggYW4gSUU4IGZhbGxiYWNrLlxuICpcbiAqIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgaW4gRmlyZWZveCwgaWYgdGhlIHBsYXllciBpcyBsb2FkZWQgaW4gYW4gaWZyYW1lIHdpdGhcbiAqIGBkaXNwbGF5Om5vbmVgLCB0aGVuIGBnZXRDb21wdXRlZFN0eWxlYCByZXR1cm5zIGBudWxsYCwgc28sIHdlIGRvIGEgbnVsbC1jaGVjayB0b1xuICogbWFrZSBzdXJlICB0aGF0IHRoZSBwbGF5ZXIgZG9lc24ndCBicmVhayBpbiB0aGVzZSBjYXNlcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgVGhlIGVsZW1lbnQgeW91IHdhbnQgdGhlIGNvbXB1dGVkIHN0eWxlIG9mXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqICAgICAgICBUaGUgcHJvcGVydHkgbmFtZSB5b3Ugd2FudFxuICpcbiAqIEBzZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVkU3R5bGUoZWwsIHByb3ApIHtcbiAgaWYgKCFlbCB8fCAhcHJvcCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2Ygd2luZG93LmdldENvbXB1dGVkU3R5bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgY3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cbiAgICByZXR1cm4gY3MgPyBjc1twcm9wXSA6ICcnO1xuICB9XG5cbiAgcmV0dXJuIGVsLmN1cnJlbnRTdHlsZVtwcm9wXSB8fCAnJztcbn1cblxudmFyIF90ZW1wbGF0ZU9iamVjdCA9IHRhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFsnU2V0dGluZyBhdHRyaWJ1dGVzIGluIHRoZSBzZWNvbmQgYXJndW1lbnQgb2YgY3JlYXRlRWwoKVxcbiAgICAgICAgICAgICAgICBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgdGhlIHRoaXJkIGFyZ3VtZW50IGluc3RlYWQuXFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsKHR5cGUsIHByb3BlcnRpZXMsIGF0dHJpYnV0ZXMpLiBBdHRlbXB0aW5nIHRvIHNldCAnLCAnIHRvICcsICcuJ10sIFsnU2V0dGluZyBhdHRyaWJ1dGVzIGluIHRoZSBzZWNvbmQgYXJndW1lbnQgb2YgY3JlYXRlRWwoKVxcbiAgICAgICAgICAgICAgICBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgdGhlIHRoaXJkIGFyZ3VtZW50IGluc3RlYWQuXFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsKHR5cGUsIHByb3BlcnRpZXMsIGF0dHJpYnV0ZXMpLiBBdHRlbXB0aW5nIHRvIHNldCAnLCAnIHRvICcsICcuJ10pO1xuXG4vKipcbiAqIEBmaWxlIGRvbS5qc1xuICogQG1vZHVsZSBkb21cbiAqL1xuLyoqXG4gKiBEZXRlY3QgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZyB3aXRoIGFueSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqICAgICAgICBUaGUgc3RyaW5nIHRvIGNoZWNrXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgbm9uLWJsYW5rXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKlxuICovXG5mdW5jdGlvbiBpc05vbkJsYW5rU3RyaW5nKHN0cikge1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgL1xcUy8udGVzdChzdHIpO1xufVxuXG4vKipcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcGFzc2VkIHN0cmluZyBoYXMgd2hpdGVzcGFjZS4gVGhpcyBpcyB1c2VkIGJ5XG4gKiBjbGFzcyBtZXRob2RzIHRvIGJlIHJlbGF0aXZlbHkgY29uc2lzdGVudCB3aXRoIHRoZSBjbGFzc0xpc3QgQVBJLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqICAgICAgICAgVGhlIHN0cmluZyB0byBjaGVjayBmb3Igd2hpdGVzcGFjZS5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqICAgICAgICAgVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGlzIHdoaXRlc3BhY2UgaW4gdGhlIHN0cmluZy5cbiAqXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZXaGl0ZXNwYWNlKHN0cikge1xuICBpZiAoL1xccy8udGVzdChzdHIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGFzcyBoYXMgaWxsZWdhbCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMnKTtcbiAgfVxufVxuXG4vKipcbiAqIFByb2R1Y2UgYSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIGEgY2xhc3NOYW1lIHdpdGhpbiBhbiBlbGVtZW50cyBjbGFzc05hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICogICAgICAgICBUaGUgY2xhc3NOYW1lIHRvIGdlbmVyYXRlIHRoZSBSZWdFeHAgZm9yLlxuICpcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqICAgICAgICAgVGhlIFJlZ0V4cCB0aGF0IHdpbGwgY2hlY2sgZm9yIGEgc3BlY2lmaWMgYGNsYXNzTmFtZWAgaW4gYW4gZWxlbWVudHNcbiAqICAgICAgICAgY2xhc3NOYW1lLlxuICovXG5mdW5jdGlvbiBjbGFzc1JlZ0V4cChjbGFzc05hbWUpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBjbGFzc05hbWUgKyAnKCR8XFxcXHMpJyk7XG59XG5cbi8qKlxuICogV2hldGhlciB0aGUgY3VycmVudCBET00gaW50ZXJmYWNlIGFwcGVhcnMgdG8gYmUgcmVhbC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc1JlYWwoKSB7XG4gIHJldHVybiAoXG5cbiAgICAvLyBCb3RoIGRvY3VtZW50IGFuZCB3aW5kb3cgd2lsbCBuZXZlciBiZSB1bmRlZmluZWQgdGhhbmtzIHRvIGBnbG9iYWxgLlxuICAgIGRvY3VtZW50ID09PSB3aW5kb3cuZG9jdW1lbnQgJiZcblxuICAgIC8vIEluIElFIDwgOSwgRE9NIG1ldGhvZHMgcmV0dXJuIFwib2JqZWN0XCIgYXMgdGhlaXIgdHlwZSwgc28gYWxsIHdlIGNhblxuICAgIC8vIGNvbmZpZGVudGx5IGNoZWNrIGlzIHRoYXQgaXQgZXhpc3RzLlxuICAgIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIERldGVybWluZXMsIHZpYSBkdWNrIHR5cGluZywgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIERPTSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiAgICAgICAgVGhlIHRoaW5nIHRvIGNoZWNrXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIGl0IGlzIGEgRE9NIGVsZW1lbnRcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaXNFbCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgRE9NIGlzIGVtYmVkZGVkIGluIGFuIGlmcmFtZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICpcbiAqL1xuZnVuY3Rpb24gaXNJbkZyYW1lKCkge1xuXG4gIC8vIFdlIG5lZWQgYSB0cnkvY2F0Y2ggaGVyZSBiZWNhdXNlIFNhZmFyaSB3aWxsIHRocm93IGVycm9ycyB3aGVuIGF0dGVtcHRpbmdcbiAgLy8gdG8gZ2V0IGVpdGhlciBgcGFyZW50YCBvciBgc2VsZmBcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LnBhcmVudCAhPT0gd2luZG93LnNlbGY7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgZnVuY3Rpb25zIHRvIHF1ZXJ5IHRoZSBET00gdXNpbmcgYSBnaXZlbiBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICogICAgICAgICBUaGUgbWV0aG9kIHRvIGNyZWF0ZSB0aGUgcXVlcnkgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqICAgICAgICAgVGhlIHF1ZXJ5IG1ldGhvZFxuICovXG5mdW5jdGlvbiBjcmVhdGVRdWVyaWVyKG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpc05vbkJsYW5rU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50W21ldGhvZF0obnVsbCk7XG4gICAgfVxuICAgIGlmIChpc05vbkJsYW5rU3RyaW5nKGNvbnRleHQpKSB7XG4gICAgICBjb250ZXh0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250ZXh0KTtcbiAgICB9XG5cbiAgICB2YXIgY3R4ID0gaXNFbChjb250ZXh0KSA/IGNvbnRleHQgOiBkb2N1bWVudDtcblxuICAgIHJldHVybiBjdHhbbWV0aG9kXSAmJiBjdHhbbWV0aG9kXShzZWxlY3Rvcik7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbGVtZW50IGFuZCBhcHBsaWVzIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFt0YWdOYW1lPSdkaXYnXVxuICogICAgICAgICBOYW1lIG9mIHRhZyB0byBiZSBjcmVhdGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV1cbiAqICAgICAgICAgRWxlbWVudCBwcm9wZXJ0aWVzIHRvIGJlIGFwcGxpZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzPXt9XVxuICogICAgICAgICBFbGVtZW50IGF0dHJpYnV0ZXMgdG8gYmUgYXBwbGllZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fFRleHROb2RlfEFycmF5fEZ1bmN0aW9ufSBbY29udGVudF1cbiAqICAgICAgICAgQ29udGVudHMgZm9yIHRoZSBlbGVtZW50IChzZWU6IHtAbGluayBkb206bm9ybWFsaXplQ29udGVudH0pXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gIHZhciB0YWdOYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnZGl2JztcbiAgdmFyIHByb3BlcnRpZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBjb250ZW50ID0gYXJndW1lbnRzWzNdO1xuXG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG5cbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICB2YXIgdmFsID0gcHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAvLyBTZWUgIzIxNzZcbiAgICAvLyBXZSBvcmlnaW5hbGx5IHdlcmUgYWNjZXB0aW5nIGJvdGggcHJvcGVydGllcyBhbmQgYXR0cmlidXRlcyBpbiB0aGVcbiAgICAvLyBzYW1lIG9iamVjdCwgYnV0IHRoYXQgZG9lc24ndCB3b3JrIHNvIHdlbGwuXG4gICAgaWYgKHByb3BOYW1lLmluZGV4T2YoJ2FyaWEtJykgIT09IC0xIHx8IHByb3BOYW1lID09PSAncm9sZScgfHwgcHJvcE5hbWUgPT09ICd0eXBlJykge1xuICAgICAgbG9nJDEud2Fybih0c21sKF90ZW1wbGF0ZU9iamVjdCwgcHJvcE5hbWUsIHZhbCkpO1xuICAgICAgZWwuc2V0QXR0cmlidXRlKHByb3BOYW1lLCB2YWwpO1xuXG4gICAgICAvLyBIYW5kbGUgdGV4dENvbnRlbnQgc2luY2UgaXQncyBub3Qgc3VwcG9ydGVkIGV2ZXJ5d2hlcmUgYW5kIHdlIGhhdmUgYVxuICAgICAgLy8gbWV0aG9kIGZvciBpdC5cbiAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSAndGV4dENvbnRlbnQnKSB7XG4gICAgICB0ZXh0Q29udGVudChlbCwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxbcHJvcE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJpYnV0ZXNbYXR0ck5hbWVdKTtcbiAgfSk7XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBhcHBlbmRDb250ZW50KGVsLCBjb250ZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBJbmplY3RzIHRleHQgaW50byBhbiBlbGVtZW50LCByZXBsYWNpbmcgYW55IGV4aXN0aW5nIGNvbnRlbnRzIGVudGlyZWx5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgZWxlbWVudCB0byBhZGQgdGV4dCBjb250ZW50IGludG9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogICAgICAgIFRoZSB0ZXh0IGNvbnRlbnQgdG8gYWRkLlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHdpdGggYWRkZWQgdGV4dCBjb250ZW50LlxuICovXG5mdW5jdGlvbiB0ZXh0Q29udGVudChlbCwgdGV4dCkge1xuICBpZiAodHlwZW9mIGVsLnRleHRDb250ZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIGVsLmlubmVyVGV4dCA9IHRleHQ7XG4gIH0gZWxzZSB7XG4gICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBJbnNlcnQgYW4gZWxlbWVudCBhcyB0aGUgZmlyc3QgY2hpbGQgbm9kZSBvZiBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBjaGlsZFxuICogICAgICAgIEVsZW1lbnQgdG8gaW5zZXJ0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAqICAgICAgICBFbGVtZW50IHRvIGluc2VydCBjaGlsZCBpbnRvXG4gKi9cbmZ1bmN0aW9uIHByZXBlbmRUbyhjaGlsZCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHBhcmVudC5maXJzdENoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBoYXMgYSBDU1MgY2xhc3NcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgICAgICBFbGVtZW50IHRvIGNoZWNrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9DaGVja1xuICogICAgICAgIENsYXNzIG5hbWUgdG8gY2hlY2sgZm9yXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIHRoZSBlbGVtZW50IGhhZCB0aGUgY2xhc3NcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHRocm93cyB7RXJyb3J9XG4gKiAgICAgICAgIFRocm93cyBhbiBlcnJvciBpZiBgY2xhc3NUb0NoZWNrYCBoYXMgd2hpdGUgc3BhY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzVG9DaGVjaykge1xuICB0aHJvd0lmV2hpdGVzcGFjZShjbGFzc1RvQ2hlY2spO1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NUb0NoZWNrKTtcbiAgfVxuICByZXR1cm4gY2xhc3NSZWdFeHAoY2xhc3NUb0NoZWNrKS50ZXN0KGVsZW1lbnQuY2xhc3NOYW1lKTtcbn1cblxuLyoqXG4gKiBBZGQgYSBDU1MgY2xhc3MgbmFtZSB0byBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgICAgICAgRWxlbWVudCB0byBhZGQgY2xhc3MgbmFtZSB0by5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NUb0FkZFxuICogICAgICAgIENsYXNzIG5hbWUgdG8gYWRkLlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBkb20gZWxlbWVudCB3aXRoIHRoZSBhZGRlZCBjbGFzcyBuYW1lLlxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc1RvQWRkKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc1RvQWRkKTtcblxuICAgIC8vIERvbid0IG5lZWQgdG8gYHRocm93SWZXaGl0ZXNwYWNlYCBoZXJlIGJlY2F1c2UgYGhhc0VsQ2xhc3NgIHdpbGwgZG8gaXRcbiAgICAvLyBpbiB0aGUgY2FzZSBvZiBjbGFzc0xpc3Qgbm90IGJlaW5nIHN1cHBvcnRlZC5cbiAgfSBlbHNlIGlmICghaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NUb0FkZCkpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IChlbGVtZW50LmNsYXNzTmFtZSArICcgJyArIGNsYXNzVG9BZGQpLnRyaW0oKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIENTUyBjbGFzcyBuYW1lIGZyb20gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogICAgICAgIEVsZW1lbnQgdG8gcmVtb3ZlIGEgY2xhc3MgbmFtZSBmcm9tLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvUmVtb3ZlXG4gKiAgICAgICAgQ2xhc3MgbmFtZSB0byByZW1vdmVcbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZG9tIGVsZW1lbnQgd2l0aCBjbGFzcyBuYW1lIHJlbW92ZWQuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzVG9SZW1vdmUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzVG9SZW1vdmUpO1xuICB9IGVsc2Uge1xuICAgIHRocm93SWZXaGl0ZXNwYWNlKGNsYXNzVG9SZW1vdmUpO1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoL1xccysvKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjICE9PSBjbGFzc1RvUmVtb3ZlO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIFRoZSBjYWxsYmFjayBkZWZpbml0aW9uIGZvciB0b2dnbGVFbENsYXNzLlxuICpcbiAqIEBjYWxsYmFjayBEb21+UHJlZGljYXRlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogICAgICAgIFRoZSBET00gZWxlbWVudCBvZiB0aGUgQ29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvVG9nZ2xlXG4gKiAgICAgICAgVGhlIGBjbGFzc05hbWVgIHRoYXQgd2FudHMgdG8gYmUgdG9nZ2xlZFxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfVxuICogICAgICAgICAtIElmIHRydWUgdGhlIGBjbGFzc1RvVG9nZ2xlYCB3aWxsIGdldCBhZGRlZCB0byBgZWxlbWVudGAuXG4gKiAgICAgICAgIC0gSWYgZmFsc2UgdGhlIGBjbGFzc1RvVG9nZ2xlYCB3aWxsIGdldCByZW1vdmVkIGZyb20gYGVsZW1lbnRgLlxuICogICAgICAgICAtIElmIHVuZGVmaW5lZCB0aGlzIGNhbGxiYWNrIHdpbGwgYmUgaWdub3JlZFxuICovXG5cbi8qKlxuICogQWRkcyBvciByZW1vdmVzIGEgQ1NTIGNsYXNzIG5hbWUgb24gYW4gZWxlbWVudCBkZXBlbmRpbmcgb24gYW4gb3B0aW9uYWxcbiAqIGNvbmRpdGlvbiBvciB0aGUgcHJlc2VuY2UvYWJzZW5jZSBvZiB0aGUgY2xhc3MgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgICAgICBUaGUgZWxlbWVudCB0byB0b2dnbGUgYSBjbGFzcyBuYW1lIG9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvVG9nZ2xlXG4gKiAgICAgICAgVGhlIGNsYXNzIHRoYXQgc2hvdWxkIGJlIHRvZ2dsZWRcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW58UHJlZGljYXRlQ2FsbGJhY2t9IFtwcmVkaWNhdGVdXG4gKiAgICAgICAgU2VlIHRoZSByZXR1cm4gdmFsdWUgZm9yIHtAbGluayBEb21+UHJlZGljYXRlQ2FsbGJhY2t9XG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgd2l0aCBhIGNsYXNzIHRoYXQgaGFzIGJlZW4gdG9nZ2xlZC5cbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSwgcHJlZGljYXRlKSB7XG5cbiAgLy8gVGhpcyBDQU5OT1QgdXNlIGBjbGFzc0xpc3RgIGludGVybmFsbHkgYmVjYXVzZSBJRSBkb2VzIG5vdCBzdXBwb3J0IHRoZVxuICAvLyBzZWNvbmQgcGFyYW1ldGVyIHRvIHRoZSBgY2xhc3NMaXN0LnRvZ2dsZSgpYCBtZXRob2QhIFdoaWNoIGlzIGZpbmUgYmVjYXVzZVxuICAvLyBgY2xhc3NMaXN0YCB3aWxsIGJlIHVzZWQgYnkgdGhlIGFkZC9yZW1vdmUgZnVuY3Rpb25zLlxuICB2YXIgaGFzID0gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSk7XG5cbiAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcmVkaWNhdGUgPSBwcmVkaWNhdGUoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcHJlZGljYXRlID0gIWhhcztcbiAgfVxuXG4gIC8vIElmIHRoZSBuZWNlc3NhcnkgY2xhc3Mgb3BlcmF0aW9uIG1hdGNoZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlXG4gIC8vIGVsZW1lbnQsIG5vIGFjdGlvbiBpcyByZXF1aXJlZC5cbiAgaWYgKHByZWRpY2F0ZSA9PT0gaGFzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByZWRpY2F0ZSkge1xuICAgIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzVG9Ub2dnbGUpO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzVG9Ub2dnbGUpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogQXBwbHkgYXR0cmlidXRlcyB0byBhbiBIVE1MIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEVsZW1lbnQgdG8gYWRkIGF0dHJpYnV0ZXMgdG8uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXVxuICogICAgICAgIEF0dHJpYnV0ZXMgdG8gYmUgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbCwgYXR0cmlidXRlcykge1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyaWJ1dGVzW2F0dHJOYW1lXTtcblxuICAgIGlmIChhdHRyVmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIGF0dHJWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXR0clZhbHVlID09PSBmYWxzZSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUgPT09IHRydWUgPyAnJyA6IGF0dHJWYWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZSB2YWx1ZXMsIGFzIGRlZmluZWQgb24gdGhlIEhUTUwgdGFnXG4gKiBBdHRyaWJ1dGVzIGFyZSBub3QgdGhlIHNhbWUgYXMgcHJvcGVydGllcy4gVGhleSdyZSBkZWZpbmVkIG9uIHRoZSB0YWdcbiAqIG9yIHdpdGggc2V0QXR0cmlidXRlICh3aGljaCBzaG91bGRuJ3QgYmUgdXNlZCB3aXRoIEhUTUwpXG4gKiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgb3IgZmFsc2UgZm9yIGJvb2xlYW4gYXR0cmlidXRlcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhZ1xuICogICAgICAgIEVsZW1lbnQgZnJvbSB3aGljaCB0byBnZXQgdGFnIGF0dHJpYnV0ZXMuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBBbGwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyh0YWcpIHtcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIC8vIGtub3duIGJvb2xlYW4gYXR0cmlidXRlc1xuICAvLyB3ZSBjYW4gY2hlY2sgZm9yIG1hdGNoaW5nIGJvb2xlYW4gcHJvcGVydGllcywgYnV0IG9sZGVyIGJyb3dzZXJzXG4gIC8vIHdvbid0IGtub3cgYWJvdXQgSFRNTDUgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXQgd2Ugc3RpbGwgcmVhZCBmcm9tXG4gIHZhciBrbm93bkJvb2xlYW5zID0gJywnICsgJ2F1dG9wbGF5LGNvbnRyb2xzLHBsYXlzaW5saW5lLGxvb3AsbXV0ZWQsZGVmYXVsdCxkZWZhdWx0TXV0ZWQnICsgJywnO1xuXG4gIGlmICh0YWcgJiYgdGFnLmF0dHJpYnV0ZXMgJiYgdGFnLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBhdHRycyA9IHRhZy5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yICh2YXIgaSA9IGF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYXR0ck5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgICAgdmFyIGF0dHJWYWwgPSBhdHRyc1tpXS52YWx1ZTtcblxuICAgICAgLy8gY2hlY2sgZm9yIGtub3duIGJvb2xlYW5zXG4gICAgICAvLyB0aGUgbWF0Y2hpbmcgZWxlbWVudCBwcm9wZXJ0eSB3aWxsIHJldHVybiBhIHZhbHVlIGZvciB0eXBlb2ZcbiAgICAgIGlmICh0eXBlb2YgdGFnW2F0dHJOYW1lXSA9PT0gJ2Jvb2xlYW4nIHx8IGtub3duQm9vbGVhbnMuaW5kZXhPZignLCcgKyBhdHRyTmFtZSArICcsJykgIT09IC0xKSB7XG4gICAgICAgIC8vIHRoZSB2YWx1ZSBvZiBhbiBpbmNsdWRlZCBib29sZWFuIGF0dHJpYnV0ZSBpcyB0eXBpY2FsbHkgYW4gZW1wdHlcbiAgICAgICAgLy8gc3RyaW5nICgnJykgd2hpY2ggd291bGQgZXF1YWwgZmFsc2UgaWYgd2UganVzdCBjaGVjayBmb3IgYSBmYWxzZSB2YWx1ZS5cbiAgICAgICAgLy8gd2UgYWxzbyBkb24ndCB3YW50IHN1cHBvcnQgYmFkIGNvZGUgbGlrZSBhdXRvcGxheT0nZmFsc2UnXG4gICAgICAgIGF0dHJWYWwgPSBhdHRyVmFsICE9PSBudWxsID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBvYmpbYXR0ck5hbWVdID0gYXR0clZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBBIERPTSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogICAgICAgIEF0dHJpYnV0ZSB0byBnZXQgdGhlIHZhbHVlIG9mXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlXG4gKi9cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZShlbCwgYXR0cmlidXRlKSB7XG4gIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGFuIGVsZW1lbnQncyBhdHRyaWJ1dGVcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgQSBET00gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqICAgICAgICBBdHRyaWJ1dGUgdG8gc2V0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiAgICAgICAgVmFsdWUgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgdG9cbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlKGVsLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gIGVsLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBBIERPTSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogICAgICAgIEF0dHJpYnV0ZSB0byByZW1vdmVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGVsLCBhdHRyaWJ1dGUpIHtcbiAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBibG9jayB0aGUgYWJpbGl0eSB0byBzZWxlY3QgdGV4dCB3aGlsZSBkcmFnZ2luZyBjb250cm9sc1xuICovXG5mdW5jdGlvbiBibG9ja1RleHRTZWxlY3Rpb24oKSB7XG4gIGRvY3VtZW50LmJvZHkuZm9jdXMoKTtcbiAgZG9jdW1lbnQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG5cbi8qKlxuICogVHVybiBvZmYgdGV4dCBzZWxlY3Rpb24gYmxvY2tpbmdcbiAqL1xuZnVuY3Rpb24gdW5ibG9ja1RleHRTZWxlY3Rpb24oKSB7XG4gIGRvY3VtZW50Lm9uc2VsZWN0c3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbi8qKlxuICogSWRlbnRpY2FsIHRvIHRoZSBuYXRpdmUgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgZnVuY3Rpb24sIGJ1dCBlbnN1cmVzIHRoYXRcbiAqIHRoZSBtZXRob2QgaXMgc3VwcG9ydGVkIGF0IGFsbCAoaXQgaXMgaW4gYWxsIGJyb3dzZXJzIHdlIGNsYWltIHRvIHN1cHBvcnQpXG4gKiBhbmQgdGhhdCB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NIGJlZm9yZSBjb250aW51aW5nLlxuICpcbiAqIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBhbHNvIHNoaW1zIHByb3BlcnRpZXMgd2hpY2ggYXJlIG5vdCBwcm92aWRlZCBieSBzb21lXG4gKiBvbGRlciBicm93c2VycyAobmFtZWx5LCBJRTgpLlxuICpcbiAqIEFkZGl0aW9uYWxseSwgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBhZGRpbmcgcHJvcGVydGllcyB0byBhXG4gKiBgQ2xpZW50UmVjdGAvYERPTVJlY3RgIG9iamVjdDsgc28sIHdlIHNoYWxsb3ctY29weSBpdCB3aXRoIHRoZSBzdGFuZGFyZFxuICogcHJvcGVydGllcyAoZXhjZXB0IGB4YCBhbmQgYHlgIHdoaWNoIGFyZSBub3Qgd2lkZWx5IHN1cHBvcnRlZCkuIFRoaXMgaGVscHNcbiAqIGF2b2lkIGltcGxlbWVudGF0aW9ucyB3aGVyZSBrZXlzIGFyZSBub24tZW51bWVyYWJsZS5cbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogICAgICAgICBFbGVtZW50IHdob3NlIGBDbGllbnRSZWN0YCB3ZSB3YW50IHRvIGNhbGN1bGF0ZS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICogICAgICAgICBBbHdheXMgcmV0dXJucyBhIHBsYWluXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbCkge1xuICBpZiAoZWwgJiYgZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgIFsnYm90dG9tJywgJ2hlaWdodCcsICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICd3aWR0aCddLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChyZWN0W2tdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVjdFtrXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghcmVzdWx0LmhlaWdodCkge1xuICAgICAgcmVzdWx0LmhlaWdodCA9IHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZShlbCwgJ2hlaWdodCcpKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlc3VsdC53aWR0aCkge1xuICAgICAgcmVzdWx0LndpZHRoID0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlKGVsLCAnd2lkdGgnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBwb3N0aW9uIG9mIGEgRE9NIGVsZW1lbnQgb24gdGhlIHBhZ2UuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmRvbX5Qb3NpdGlvblxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0XG4gKiAgICAgICAgICAgUGl4ZWxzIHRvIHRoZSBsZWZ0XG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcFxuICogICAgICAgICAgIFBpeGVscyBvbiB0b3BcbiAqL1xuXG4vKipcbiAqIE9mZnNldCBMZWZ0LlxuICogZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHRlY2huaXF1ZSBmcm9tXG4gKiBKb2huIFJlc2lnXG4gKlxuICogQHNlZSBodHRwOi8vZWpvaG4ub3JnL2Jsb2cvZ2V0Ym91bmRpbmdjbGllbnRyZWN0LWlzLWF3ZXNvbWUvXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEVsZW1lbnQgZnJvbSB3aGljaCB0byBnZXQgb2Zmc2V0XG4gKlxuICogQHJldHVybiB7bW9kdWxlOmRvbX5Qb3NpdGlvbn1cbiAqICAgICAgICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBpbi5cbiAqL1xuZnVuY3Rpb24gZmluZFBvc2l0aW9uKGVsKSB7XG4gIHZhciBib3ggPSB2b2lkIDA7XG5cbiAgaWYgKGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgYm94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICBpZiAoIWJveCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgfVxuXG4gIHZhciBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXG4gIHZhciBjbGllbnRMZWZ0ID0gZG9jRWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMDtcbiAgdmFyIHNjcm9sbExlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgYm9keS5zY3JvbGxMZWZ0O1xuICB2YXIgbGVmdCA9IGJveC5sZWZ0ICsgc2Nyb2xsTGVmdCAtIGNsaWVudExlZnQ7XG5cbiAgdmFyIGNsaWVudFRvcCA9IGRvY0VsLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xuICB2YXIgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGJvZHkuc2Nyb2xsVG9wO1xuICB2YXIgdG9wID0gYm94LnRvcCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcDtcblxuICAvLyBBbmRyb2lkIHNvbWV0aW1lcyByZXR1cm5zIHNsaWdodGx5IG9mZiBkZWNpbWFsIHZhbHVlcywgc28gbmVlZCB0byByb3VuZFxuICByZXR1cm4ge1xuICAgIGxlZnQ6IE1hdGgucm91bmQobGVmdCksXG4gICAgdG9wOiBNYXRoLnJvdW5kKHRvcClcbiAgfTtcbn1cblxuLyoqXG4gKiB4IGFuZCB5IGNvb3JkaW5hdGVzIGZvciBhIGRvbSBlbGVtZW50IG9yIG1vdXNlIHBvaW50ZXJcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEb21+Q29vcmRpbmF0ZXNcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0geFxuICogICAgICAgICAgIHggY29vcmRpbmF0ZSBpbiBwaXhlbHNcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0geVxuICogICAgICAgICAgIHkgY29vcmRpbmF0ZSBpbiBwaXhlbHNcbiAqL1xuXG4vKipcbiAqIEdldCBwb2ludGVyIHBvc2l0aW9uIGluIGVsZW1lbnRcbiAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggeCBhbmQgeSBjb29yZGluYXRlcy5cbiAqIFRoZSBiYXNlIG9uIHRoZSBjb29yZGluYXRlcyBhcmUgdGhlIGJvdHRvbSBsZWZ0IG9mIHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBFbGVtZW50IG9uIHdoaWNoIHRvIGdldCB0aGUgcG9pbnRlciBwb3NpdGlvbiBvblxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gKiAgICAgICAgRXZlbnQgb2JqZWN0XG4gKlxuICogQHJldHVybiB7RG9tfkNvb3JkaW5hdGVzfVxuICogICAgICAgICBBIENvb3JkaW5hdGVzIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBtb3VzZSBwb3NpdGlvbi5cbiAqXG4gKi9cbmZ1bmN0aW9uIGdldFBvaW50ZXJQb3NpdGlvbihlbCwgZXZlbnQpIHtcbiAgdmFyIHBvc2l0aW9uID0ge307XG4gIHZhciBib3ggPSBmaW5kUG9zaXRpb24oZWwpO1xuICB2YXIgYm94VyA9IGVsLm9mZnNldFdpZHRoO1xuICB2YXIgYm94SCA9IGVsLm9mZnNldEhlaWdodDtcblxuICB2YXIgYm94WSA9IGJveC50b3A7XG4gIHZhciBib3hYID0gYm94LmxlZnQ7XG4gIHZhciBwYWdlWSA9IGV2ZW50LnBhZ2VZO1xuICB2YXIgcGFnZVggPSBldmVudC5wYWdlWDtcblxuICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICBwYWdlWCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgIHBhZ2VZID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XG4gIH1cblxuICBwb3NpdGlvbi55ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKGJveFkgLSBwYWdlWSArIGJveEgpIC8gYm94SCkpO1xuICBwb3NpdGlvbi54ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHBhZ2VYIC0gYm94WCkgLyBib3hXKSk7XG5cbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuXG4vKipcbiAqIERldGVybWluZXMsIHZpYSBkdWNrIHR5cGluZywgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIHRleHQgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogICAgICAgIENoZWNrIGlmIHRoaXMgdmFsdWUgaXMgYSB0ZXh0IG5vZGUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIGl0IGlzIGEgdGV4dCBub2RlXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMztcbn1cblxuLyoqXG4gKiBFbXB0aWVzIHRoZSBjb250ZW50cyBvZiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgZWxlbWVudCB0byBlbXB0eSBjaGlsZHJlbiBmcm9tXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgd2l0aCBubyBjaGlsZHJlblxuICovXG5mdW5jdGlvbiBlbXB0eUVsKGVsKSB7XG4gIHdoaWxlIChlbC5maXJzdENoaWxkKSB7XG4gICAgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgY29udGVudCBmb3IgZXZlbnR1YWwgaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cbiAqXG4gKiBUaGlzIGFsbG93cyBhIHdpZGUgcmFuZ2Ugb2YgY29udGVudCBkZWZpbml0aW9uIG1ldGhvZHMsIGJ1dCBwcm90ZWN0c1xuICogZnJvbSBmYWxsaW5nIGludG8gdGhlIHRyYXAgb2Ygc2ltcGx5IHdyaXRpbmcgdG8gYGlubmVySFRNTGAsIHdoaWNoIGlzXG4gKiBhbiBYU1MgY29uY2Vybi5cbiAqXG4gKiBUaGUgY29udGVudCBmb3IgYW4gZWxlbWVudCBjYW4gYmUgcGFzc2VkIGluIG11bHRpcGxlIHR5cGVzIGFuZFxuICogY29tYmluYXRpb25zLCB3aG9zZSBiZWhhdmlvciBpcyBhcyBmb2xsb3dzOlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8VGV4dE5vZGV8QXJyYXl8RnVuY3Rpb259IGNvbnRlbnRcbiAqICAgICAgICAtIFN0cmluZzogTm9ybWFsaXplZCBpbnRvIGEgdGV4dCBub2RlLlxuICogICAgICAgIC0gRWxlbWVudC9UZXh0Tm9kZTogUGFzc2VkIHRocm91Z2guXG4gKiAgICAgICAgLSBBcnJheTogQSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2Ygc3RyaW5ncywgZWxlbWVudHMsIG5vZGVzLCBvciBmdW5jdGlvbnNcbiAqICAgICAgICAgICh3aGljaCByZXR1cm4gc2luZ2xlIHN0cmluZ3MsIGVsZW1lbnRzLCBvciBub2RlcykuXG4gKiAgICAgICAgLSBGdW5jdGlvbjogSWYgdGhlIHNvbGUgYXJndW1lbnQsIGlzIGV4cGVjdGVkIHRvIHByb2R1Y2UgYSBzdHJpbmcsIGVsZW1lbnQsXG4gKiAgICAgICAgICBub2RlLCBvciBhcnJheSBhcyBkZWZpbmVkIGFib3ZlLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogICAgICAgICBBbGwgb2YgdGhlIGNvbnRlbnQgdGhhdCB3YXMgcGFzc2VkIGluIG5vcm1hbGl6ZWQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnRlbnQoY29udGVudCkge1xuXG4gIC8vIEZpcnN0LCBpbnZva2UgY29udGVudCBpZiBpdCBpcyBhIGZ1bmN0aW9uLiBJZiBpdCBwcm9kdWNlcyBhbiBhcnJheSxcbiAgLy8gdGhhdCBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIG5vcm1hbGl6YXRpb24uXG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnRlbnQgPSBjb250ZW50KCk7XG4gIH1cblxuICAvLyBOZXh0IHVwLCBub3JtYWxpemUgdG8gYW4gYXJyYXksIHNvIG9uZSBvciBtYW55IGl0ZW1zIGNhbiBiZSBub3JtYWxpemVkLFxuICAvLyBmaWx0ZXJlZCwgYW5kIHJldHVybmVkLlxuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICAvLyBGaXJzdCwgaW52b2tlIHZhbHVlIGlmIGl0IGlzIGEgZnVuY3Rpb24gdG8gcHJvZHVjZSBhIG5ldyB2YWx1ZSxcbiAgICAvLyB3aGljaCB3aWxsIGJlIHN1YnNlcXVlbnRseSBub3JtYWxpemVkIHRvIGEgTm9kZSBvZiBzb21lIGtpbmQuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgIH1cblxuICAgIGlmIChpc0VsKHZhbHVlKSB8fCBpc1RleHROb2RlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIC9cXFMvLnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICAgIH1cbiAgfSkuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBhbmQgYXBwZW5kcyBjb250ZW50IHRvIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEVsZW1lbnQgdG8gYXBwZW5kIG5vcm1hbGl6ZWQgY29udGVudCB0by5cbiAqXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxUZXh0Tm9kZXxBcnJheXxGdW5jdGlvbn0gY29udGVudFxuICogICAgICAgIFNlZSB0aGUgYGNvbnRlbnRgIGFyZ3VtZW50IG9mIHtAbGluayBkb206bm9ybWFsaXplQ29udGVudH1cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB3aXRoIGFwcGVuZGVkIG5vcm1hbGl6ZWQgY29udGVudC5cbiAqL1xuZnVuY3Rpb24gYXBwZW5kQ29udGVudChlbCwgY29udGVudCkge1xuICBub3JtYWxpemVDb250ZW50KGNvbnRlbnQpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gZWwuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIH0pO1xuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBhbmQgaW5zZXJ0cyBjb250ZW50IGludG8gYW4gZWxlbWVudDsgdGhpcyBpcyBpZGVudGljYWwgdG9cbiAqIGBhcHBlbmRDb250ZW50KClgLCBleGNlcHQgaXQgZW1wdGllcyB0aGUgZWxlbWVudCBmaXJzdC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgRWxlbWVudCB0byBpbnNlcnQgbm9ybWFsaXplZCBjb250ZW50IGludG8uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxUZXh0Tm9kZXxBcnJheXxGdW5jdGlvbn0gY29udGVudFxuICogICAgICAgIFNlZSB0aGUgYGNvbnRlbnRgIGFyZ3VtZW50IG9mIHtAbGluayBkb206bm9ybWFsaXplQ29udGVudH1cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB3aXRoIGluc2VydGVkIG5vcm1hbGl6ZWQgY29udGVudC5cbiAqXG4gKi9cbmZ1bmN0aW9uIGluc2VydENvbnRlbnQoZWwsIGNvbnRlbnQpIHtcbiAgcmV0dXJuIGFwcGVuZENvbnRlbnQoZW1wdHlFbChlbCksIGNvbnRlbnQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGV2ZW50IHdhcyBhIHNpbmdsZSBsZWZ0IGNsaWNrXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAqICAgICAgICBFdmVudCBvYmplY3RcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgYSBsZWZ0IGNsaWNrXG4gKiAgICAgICAgIC0gRmFsc2UgaWYgbm90IGEgbGVmdCBjbGlja1xuICovXG5mdW5jdGlvbiBpc1NpbmdsZUxlZnRDbGljayhldmVudCkge1xuICAvLyBOb3RlOiBpZiB5b3UgY3JlYXRlIHNvbWV0aGluZyBkcmFnZ2FibGUsIGJlIHN1cmUgdG9cbiAgLy8gY2FsbCBpdCBvbiBib3RoIGBtb3VzZWRvd25gIGFuZCBgbW91c2Vtb3ZlYCBldmVudCxcbiAgLy8gb3RoZXJ3aXNlIGBtb3VzZWRvd25gIHNob3VsZCBiZSBlbm91Z2ggZm9yIGEgYnV0dG9uXG5cbiAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gdW5kZWZpbmVkICYmIGV2ZW50LmJ1dHRvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFdoeSBkbyB3ZSBuZWVkIGBidXR0dG9uc2AgP1xuICAgIC8vIEJlY2F1c2UsIG1pZGRsZSBtb3VzZSBzb21ldGltZXMgaGF2ZSB0aGlzOlxuICAgIC8vIGUuYnV0dG9uID09PSAwIGFuZCBlLmJ1dHRvbnMgPT09IDRcbiAgICAvLyBGdXJ0aGVybW9yZSwgd2Ugd2FudCB0byBwcmV2ZW50IGNvbWJpbmF0aW9uIGNsaWNrLCBzb21ldGhpbmcgbGlrZVxuICAgIC8vIEhPTEQgbWlkZGxlbW91c2UgdGhlbiBsZWZ0IGNsaWNrLCB0aGF0IHdvdWxkIGJlXG4gICAgLy8gZS5idXR0b24gPT09IDAsIGUuYnV0dG9ucyA9PT0gNVxuICAgIC8vIGp1c3QgYGJ1dHRvbmAgaXMgbm90IGdvbm5hIHdvcmtcblxuICAgIC8vIEFscmlnaHQsIHRoZW4gd2hhdCB0aGlzIGJsb2NrIGRvZXMgP1xuICAgIC8vIHRoaXMgaXMgZm9yIGNocm9tZSBgc2ltdWxhdGUgbW9iaWxlIGRldmljZXNgXG4gICAgLy8gSSB3YW50IHRvIHN1cHBvcnQgdGhpcyBhcyB3ZWxsXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChldmVudC5idXR0b24gPT09IDAgJiYgZXZlbnQuYnV0dG9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gVG91Y2ggc2NyZWVuLCBzb21ldGltZXMgb24gc29tZSBzcGVjaWZpYyBkZXZpY2UsIGBidXR0b25zYFxuICAgIC8vIGRvZXNuJ3QgaGF2ZSBhbnl0aGluZyAoc2FmYXJpIG9uIGlvcywgYmxhY2tiZXJyeS4uLilcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKElFX1ZFUlNJT04gPT09IDkpIHtcbiAgICAvLyBJZ25vcmUgSUU5XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuYnV0dG9ucyAhPT0gMSkge1xuICAgIC8vIFRoaXMgaXMgdGhlIHJlYXNvbiB3ZSBoYXZlIHRob3NlIGlmIGVsc2UgYmxvY2sgYWJvdmVcbiAgICAvLyBpZiBhbnkgc3BlY2lhbCBjYXNlIHdlIGNhbiBjYXRjaCBhbmQgbGV0IGl0IHNsaWRlXG4gICAgLy8gd2UgZG8gaXQgYWJvdmUsIHdoZW4gZ2V0IHRvIGhlcmUsIHRoaXMgZGVmaW5pdGVseVxuICAgIC8vIGlzLW5vdC1sZWZ0LWNsaWNrXG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBGaW5kcyBhIHNpbmdsZSBET00gZWxlbWVudCBtYXRjaGluZyBgc2VsZWN0b3JgIHdpdGhpbiB0aGUgb3B0aW9uYWxcbiAqIGBjb250ZXh0YCBvZiBhbm90aGVyIERPTSBlbGVtZW50IChkZWZhdWx0aW5nIHRvIGBkb2N1bWVudGApLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogICAgICAgIEEgdmFsaWQgQ1NTIHNlbGVjdG9yLCB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBgcXVlcnlTZWxlY3RvcmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gW2NvbnRleHQ9ZG9jdW1lbnRdXG4gKiAgICAgICAgQSBET00gZWxlbWVudCB3aXRoaW4gd2hpY2ggdG8gcXVlcnkuIENhbiBhbHNvIGJlIGEgc2VsZWN0b3JcbiAqICAgICAgICBzdHJpbmcgaW4gd2hpY2ggY2FzZSB0aGUgZmlyc3QgbWF0Y2hpbmcgZWxlbWVudCB3aWxsIGJlIHVzZWRcbiAqICAgICAgICBhcyBjb250ZXh0LiBJZiBtaXNzaW5nIChvciBubyBlbGVtZW50IG1hdGNoZXMgc2VsZWN0b3IpLCBmYWxsc1xuICogICAgICAgIGJhY2sgdG8gYGRvY3VtZW50YC5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fG51bGx9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGZvdW5kIG9yIG51bGwuXG4gKi9cbnZhciAkID0gY3JlYXRlUXVlcmllcigncXVlcnlTZWxlY3RvcicpO1xuXG4vKipcbiAqIEZpbmRzIGEgYWxsIERPTSBlbGVtZW50cyBtYXRjaGluZyBgc2VsZWN0b3JgIHdpdGhpbiB0aGUgb3B0aW9uYWxcbiAqIGBjb250ZXh0YCBvZiBhbm90aGVyIERPTSBlbGVtZW50IChkZWZhdWx0aW5nIHRvIGBkb2N1bWVudGApLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogICAgICAgICAgIEEgdmFsaWQgQ1NTIHNlbGVjdG9yLCB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBgcXVlcnlTZWxlY3RvckFsbGAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gW2NvbnRleHQ9ZG9jdW1lbnRdXG4gKiAgICAgICAgICAgQSBET00gZWxlbWVudCB3aXRoaW4gd2hpY2ggdG8gcXVlcnkuIENhbiBhbHNvIGJlIGEgc2VsZWN0b3JcbiAqICAgICAgICAgICBzdHJpbmcgaW4gd2hpY2ggY2FzZSB0aGUgZmlyc3QgbWF0Y2hpbmcgZWxlbWVudCB3aWxsIGJlIHVzZWRcbiAqICAgICAgICAgICBhcyBjb250ZXh0LiBJZiBtaXNzaW5nIChvciBubyBlbGVtZW50IG1hdGNoZXMgc2VsZWN0b3IpLCBmYWxsc1xuICogICAgICAgICAgIGJhY2sgdG8gYGRvY3VtZW50YC5cbiAqXG4gKiBAcmV0dXJuIHtOb2RlTGlzdH1cbiAqICAgICAgICAgQSBlbGVtZW50IGxpc3Qgb2YgZWxlbWVudHMgdGhhdCB3ZXJlIGZvdW5kLiBXaWxsIGJlIGVtcHR5IGlmIG5vbmUgd2VyZSBmb3VuZC5cbiAqXG4gKi9cbnZhciAkJCA9IGNyZWF0ZVF1ZXJpZXIoJ3F1ZXJ5U2VsZWN0b3JBbGwnKTtcblxuXG5cbnZhciBEb20gPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0aXNSZWFsOiBpc1JlYWwsXG5cdGlzRWw6IGlzRWwsXG5cdGlzSW5GcmFtZTogaXNJbkZyYW1lLFxuXHRjcmVhdGVFbDogY3JlYXRlRWwsXG5cdHRleHRDb250ZW50OiB0ZXh0Q29udGVudCxcblx0cHJlcGVuZFRvOiBwcmVwZW5kVG8sXG5cdGhhc0NsYXNzOiBoYXNDbGFzcyxcblx0YWRkQ2xhc3M6IGFkZENsYXNzLFxuXHRyZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXG5cdHRvZ2dsZUNsYXNzOiB0b2dnbGVDbGFzcyxcblx0c2V0QXR0cmlidXRlczogc2V0QXR0cmlidXRlcyxcblx0Z2V0QXR0cmlidXRlczogZ2V0QXR0cmlidXRlcyxcblx0Z2V0QXR0cmlidXRlOiBnZXRBdHRyaWJ1dGUsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlLFxuXHRyZW1vdmVBdHRyaWJ1dGU6IHJlbW92ZUF0dHJpYnV0ZSxcblx0YmxvY2tUZXh0U2VsZWN0aW9uOiBibG9ja1RleHRTZWxlY3Rpb24sXG5cdHVuYmxvY2tUZXh0U2VsZWN0aW9uOiB1bmJsb2NrVGV4dFNlbGVjdGlvbixcblx0Z2V0Qm91bmRpbmdDbGllbnRSZWN0OiBnZXRCb3VuZGluZ0NsaWVudFJlY3QsXG5cdGZpbmRQb3NpdGlvbjogZmluZFBvc2l0aW9uLFxuXHRnZXRQb2ludGVyUG9zaXRpb246IGdldFBvaW50ZXJQb3NpdGlvbixcblx0aXNUZXh0Tm9kZTogaXNUZXh0Tm9kZSxcblx0ZW1wdHlFbDogZW1wdHlFbCxcblx0bm9ybWFsaXplQ29udGVudDogbm9ybWFsaXplQ29udGVudCxcblx0YXBwZW5kQ29udGVudDogYXBwZW5kQ29udGVudCxcblx0aW5zZXJ0Q29udGVudDogaW5zZXJ0Q29udGVudCxcblx0aXNTaW5nbGVMZWZ0Q2xpY2s6IGlzU2luZ2xlTGVmdENsaWNrLFxuXHQkOiAkLFxuXHQkJDogJCRcbn0pO1xuXG4vKipcbiAqIEBmaWxlIGd1aWQuanNcbiAqIEBtb2R1bGUgZ3VpZFxuICovXG5cbi8qKlxuICogVW5pcXVlIElEIGZvciBhbiBlbGVtZW50IG9yIGZ1bmN0aW9uXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG52YXIgX2d1aWQgPSAxO1xuXG4vKipcbiAqIEdldCBhIHVuaXF1ZSBhdXRvLWluY3JlbWVudGluZyBJRCBieSBudW1iZXIgdGhhdCBoYXMgbm90IGJlZW4gcmV0dXJuZWQgYmVmb3JlLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgQSBuZXcgdW5pcXVlIElELlxuICovXG5mdW5jdGlvbiBuZXdHVUlEKCkge1xuICByZXR1cm4gX2d1aWQrKztcbn1cblxuLyoqXG4gKiBAZmlsZSBkb20tZGF0YS5qc1xuICogQG1vZHVsZSBkb20tZGF0YVxuICovXG4vKipcbiAqIEVsZW1lbnQgRGF0YSBTdG9yZS5cbiAqXG4gKiBBbGxvd3MgZm9yIGJpbmRpbmcgZGF0YSB0byBhbiBlbGVtZW50IHdpdGhvdXQgcHV0dGluZyBpdCBkaXJlY3RseSBvbiB0aGVcbiAqIGVsZW1lbnQuIEV4LiBFdmVudCBsaXN0ZW5lcnMgYXJlIHN0b3JlZCBoZXJlLlxuICogKGFsc28gZnJvbSBqc25pbmphLmNvbSwgc2xpZ2h0bHkgbW9kaWZpZWQgYW5kIHVwZGF0ZWQgZm9yIGNsb3N1cmUgY29tcGlsZXIpXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBlbERhdGEgPSB7fTtcblxuLypcbiAqIFVuaXF1ZSBhdHRyaWJ1dGUgbmFtZSB0byBzdG9yZSBhbiBlbGVtZW50J3MgZ3VpZCBpblxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAY29uc3RhbnRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBlbElkQXR0ciA9ICd2ZGF0YScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3Qgd2hlcmUgZGF0YSBmb3IgYW4gZWxlbWVudCBpcyBzdG9yZWRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgRWxlbWVudCB0byBzdG9yZSBkYXRhIGZvci5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIFRoZSBjYWNoZSBvYmplY3QgZm9yIHRoYXQgZWwgdGhhdCB3YXMgcGFzc2VkIGluLlxuICovXG5mdW5jdGlvbiBnZXREYXRhKGVsKSB7XG4gIHZhciBpZCA9IGVsW2VsSWRBdHRyXTtcblxuICBpZiAoIWlkKSB7XG4gICAgaWQgPSBlbFtlbElkQXR0cl0gPSBuZXdHVUlEKCk7XG4gIH1cblxuICBpZiAoIWVsRGF0YVtpZF0pIHtcbiAgICBlbERhdGFbaWRdID0ge307XG4gIH1cblxuICByZXR1cm4gZWxEYXRhW2lkXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIGVsZW1lbnQgaGFzIGNhY2hlZCBkYXRhXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIENoZWNrIGlmIHRoaXMgZWxlbWVudCBoYXMgY2FjaGVkIGRhdGEuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIHRoZSBET00gZWxlbWVudCBoYXMgY2FjaGVkIGRhdGEuXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBoYXNEYXRhKGVsKSB7XG4gIHZhciBpZCA9IGVsW2VsSWRBdHRyXTtcblxuICBpZiAoIWlkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZWxEYXRhW2lkXSkubGVuZ3RoO1xufVxuXG4vKipcbiAqIERlbGV0ZSBkYXRhIGZvciB0aGUgZWxlbWVudCBmcm9tIHRoZSBjYWNoZSBhbmQgdGhlIGd1aWQgYXR0ciBmcm9tIGdldEVsZW1lbnRCeUlkXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFJlbW92ZSBjYWNoZWQgZGF0YSBmb3IgdGhpcyBlbGVtZW50LlxuICovXG5mdW5jdGlvbiByZW1vdmVEYXRhKGVsKSB7XG4gIHZhciBpZCA9IGVsW2VsSWRBdHRyXTtcblxuICBpZiAoIWlkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUmVtb3ZlIGFsbCBzdG9yZWQgZGF0YVxuICBkZWxldGUgZWxEYXRhW2lkXTtcblxuICAvLyBSZW1vdmUgdGhlIGVsSWRBdHRyIHByb3BlcnR5IGZyb20gdGhlIERPTSBub2RlXG4gIHRyeSB7XG4gICAgZGVsZXRlIGVsW2VsSWRBdHRyXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlbC5yZW1vdmVBdHRyaWJ1dGUpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShlbElkQXR0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElFIGRvZXNuJ3QgYXBwZWFyIHRvIHN1cHBvcnQgcmVtb3ZlQXR0cmlidXRlIG9uIHRoZSBkb2N1bWVudCBlbGVtZW50XG4gICAgICBlbFtlbElkQXR0cl0gPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBmaWxlIGV2ZW50cy5qcy4gQW4gRXZlbnQgU3lzdGVtIChKb2huIFJlc2lnIC0gU2VjcmV0cyBvZiBhIEpTIE5pbmphIGh0dHA6Ly9qc25pbmphLmNvbS8pXG4gKiAoT3JpZ2luYWwgYm9vayB2ZXJzaW9uIHdhc24ndCBjb21wbGV0ZWx5IHVzYWJsZSwgc28gZml4ZWQgc29tZSB0aGluZ3MgYW5kIG1hZGUgQ2xvc3VyZSBDb21waWxlciBjb21wYXRpYmxlKVxuICogVGhpcyBzaG91bGQgd29yayB2ZXJ5IHNpbWlsYXJseSB0byBqUXVlcnkncyBldmVudHMsIGhvd2V2ZXIgaXQncyBiYXNlZCBvZmYgdGhlIGJvb2sgdmVyc2lvbiB3aGljaCBpc24ndCBhc1xuICogcm9idXN0IGFzIGpxdWVyeSdzLCBzbyB0aGVyZSdzIHByb2JhYmx5IHNvbWUgZGlmZmVyZW5jZXMuXG4gKlxuICogQG1vZHVsZSBldmVudHNcbiAqL1xuXG4vKipcbiAqIENsZWFuIHVwIHRoZSBsaXN0ZW5lciBjYWNoZSBhbmQgZGlzcGF0Y2hlcnNcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXG4gKiAgICAgICAgRWxlbWVudCB0byBjbGVhbiB1cFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgVHlwZSBvZiBldmVudCB0byBjbGVhbiB1cFxuICovXG5mdW5jdGlvbiBfY2xlYW5VcEV2ZW50cyhlbGVtLCB0eXBlKSB7XG4gIHZhciBkYXRhID0gZ2V0RGF0YShlbGVtKTtcblxuICAvLyBSZW1vdmUgdGhlIGV2ZW50cyBvZiBhIHBhcnRpY3VsYXIgdHlwZSBpZiB0aGVyZSBhcmUgbm9uZSBsZWZ0XG4gIGlmIChkYXRhLmhhbmRsZXJzW3R5cGVdLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlbGV0ZSBkYXRhLmhhbmRsZXJzW3R5cGVdO1xuICAgIC8vIGRhdGEuaGFuZGxlcnNbdHlwZV0gPSBudWxsO1xuICAgIC8vIFNldHRpbmcgdG8gbnVsbCB3YXMgY2F1c2luZyBhbiBlcnJvciB3aXRoIGRhdGEuaGFuZGxlcnNcblxuICAgIC8vIFJlbW92ZSB0aGUgbWV0YS1oYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICBpZiAoZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZGF0YS5kaXNwYXRjaGVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChlbGVtLmRldGFjaEV2ZW50KSB7XG4gICAgICBlbGVtLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBkYXRhLmRpc3BhdGNoZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSB0aGUgZXZlbnRzIG9iamVjdCBpZiB0aGVyZSBhcmUgbm8gdHlwZXMgbGVmdFxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGF0YS5oYW5kbGVycykubGVuZ3RoIDw9IDApIHtcbiAgICBkZWxldGUgZGF0YS5oYW5kbGVycztcbiAgICBkZWxldGUgZGF0YS5kaXNwYXRjaGVyO1xuICAgIGRlbGV0ZSBkYXRhLmRpc2FibGVkO1xuICB9XG5cbiAgLy8gRmluYWxseSByZW1vdmUgdGhlIGVsZW1lbnQgZGF0YSBpZiB0aGVyZSBpcyBubyBkYXRhIGxlZnRcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJlbW92ZURhdGEoZWxlbSk7XG4gIH1cbn1cblxuLyoqXG4gKiBMb29wcyB0aHJvdWdoIGFuIGFycmF5IG9mIGV2ZW50IHR5cGVzIGFuZCBjYWxscyB0aGUgcmVxdWVzdGVkIG1ldGhvZCBmb3IgZWFjaCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiAgICAgICAgVGhlIGV2ZW50IG1ldGhvZCB3ZSB3YW50IHRvIHVzZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXG4gKiAgICAgICAgRWxlbWVudCBvciBvYmplY3QgdG8gYmluZCBsaXN0ZW5lcnMgdG9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIFR5cGUgb2YgZXZlbnQgdG8gYmluZCB0by5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGNhbGxiYWNrXG4gKiAgICAgICAgRXZlbnQgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhmbiwgZWxlbSwgdHlwZXMsIGNhbGxiYWNrKSB7XG4gIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAvLyBDYWxsIHRoZSBldmVudCBtZXRob2QgZm9yIGVhY2ggb25lIG9mIHRoZSB0eXBlc1xuICAgIGZuKGVsZW0sIHR5cGUsIGNhbGxiYWNrKTtcbiAgfSk7XG59XG5cbi8qKlxuICogRml4IGEgbmF0aXZlIGV2ZW50IHRvIGhhdmUgc3RhbmRhcmQgcHJvcGVydHkgdmFsdWVzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gKiAgICAgICAgRXZlbnQgb2JqZWN0IHRvIGZpeC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIEZpeGVkIGV2ZW50IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZml4RXZlbnQoZXZlbnQpIHtcblxuICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBpZiBmaXhpbmcgdXAgaXMgbmVlZGVkXG4gIC8vIFVzZWQgdG8gY2hlY2sgaWYgIWV2ZW50LnN0b3BQcm9wYWdhdGlvbiBpbnN0ZWFkIG9mIGlzUHJvcGFnYXRpb25TdG9wcGVkXG4gIC8vIEJ1dCBuYXRpdmUgZXZlbnRzIHJldHVybiB0cnVlIGZvciBzdG9wUHJvcGFnYXRpb24sIGJ1dCBkb24ndCBoYXZlXG4gIC8vIG90aGVyIGV4cGVjdGVkIG1ldGhvZHMgbGlrZSBpc1Byb3BhZ2F0aW9uU3RvcHBlZC4gU2VlbXMgdG8gYmUgYSBwcm9ibGVtXG4gIC8vIHdpdGggdGhlIEphdmFzY3JpcHQgTmluamEgY29kZS4gU28gd2UncmUganVzdCBvdmVycmlkaW5nIGFsbCBldmVudHMgbm93LlxuICBpZiAoIWV2ZW50IHx8ICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgIHZhciBvbGQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICBldmVudCA9IHt9O1xuICAgIC8vIENsb25lIHRoZSBvbGQgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIG1vZGlmeSB0aGUgdmFsdWVzIGV2ZW50ID0ge307XG4gICAgLy8gSUU4IERvZXNuJ3QgbGlrZSB3aGVuIHlvdSBtZXNzIHdpdGggbmF0aXZlIGV2ZW50IHByb3BlcnRpZXNcbiAgICAvLyBGaXJlZm94IHJldHVybnMgZmFsc2UgZm9yIGV2ZW50Lmhhc093blByb3BlcnR5KCd0eXBlJykgYW5kIG90aGVyIHByb3BzXG4gICAgLy8gIHdoaWNoIG1ha2VzIGNvcHlpbmcgbW9yZSBkaWZmaWN1bHQuXG4gICAgLy8gVE9ETzogUHJvYmFibHkgYmVzdCB0byBjcmVhdGUgYSB3aGl0ZWxpc3Qgb2YgZXZlbnQgcHJvcHNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2xkKSB7XG4gICAgICAvLyBTYWZhcmkgNi4wLjMgd2FybnMgeW91IGlmIHlvdSB0cnkgdG8gY29weSBkZXByZWNhdGVkIGxheWVyWC9ZXG4gICAgICAvLyBDaHJvbWUgd2FybnMgeW91IGlmIHlvdSB0cnkgdG8gY29weSBkZXByZWNhdGVkIGtleWJvYXJkRXZlbnQua2V5TG9jYXRpb25cbiAgICAgIC8vIGFuZCB3ZWJraXRNb3ZlbWVudFgvWVxuICAgICAgaWYgKGtleSAhPT0gJ2xheWVyWCcgJiYga2V5ICE9PSAnbGF5ZXJZJyAmJiBrZXkgIT09ICdrZXlMb2NhdGlvbicgJiYga2V5ICE9PSAnd2Via2l0TW92ZW1lbnRYJyAmJiBrZXkgIT09ICd3ZWJraXRNb3ZlbWVudFknKSB7XG4gICAgICAgIC8vIENocm9tZSAzMisgd2FybnMgaWYgeW91IHRyeSB0byBjb3B5IGRlcHJlY2F0ZWQgcmV0dXJuVmFsdWUsIGJ1dFxuICAgICAgICAvLyB3ZSBzdGlsbCB3YW50IHRvIGlmIHByZXZlbnREZWZhdWx0IGlzbid0IHN1cHBvcnRlZCAoSUU4KS5cbiAgICAgICAgaWYgKCEoa2V5ID09PSAncmV0dXJuVmFsdWUnICYmIG9sZC5wcmV2ZW50RGVmYXVsdCkpIHtcbiAgICAgICAgICBldmVudFtrZXldID0gb2xkW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgZXZlbnQgb2NjdXJyZWQgb24gdGhpcyBlbGVtZW50XG4gICAgaWYgKCFldmVudC50YXJnZXQpIHtcbiAgICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LnNyY0VsZW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHdoaWNoIG90aGVyIGVsZW1lbnQgdGhlIGV2ZW50IGlzIHJlbGF0ZWQgdG9cbiAgICBpZiAoIWV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIGV2ZW50LnJlbGF0ZWRUYXJnZXQgPSBldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQudGFyZ2V0ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gU3RvcCB0aGUgZGVmYXVsdCBicm93c2VyIGFjdGlvblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG9sZC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBvbGQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICBvbGQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICBldmVudC5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG5cbiAgICAvLyBTdG9wIHRoZSBldmVudCBmcm9tIGJ1YmJsaW5nXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG9sZC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgb2xkLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIG9sZC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgIH07XG5cbiAgICBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVybkZhbHNlO1xuXG4gICAgLy8gU3RvcCB0aGUgZXZlbnQgZnJvbSBidWJibGluZyBhbmQgZXhlY3V0aW5nIG90aGVyIGhhbmRsZXJzXG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG9sZC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcbiAgICAgICAgb2xkLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfTtcblxuICAgIGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuRmFsc2U7XG5cbiAgICAvLyBIYW5kbGUgbW91c2UgcG9zaXRpb25cbiAgICBpZiAoZXZlbnQuY2xpZW50WCAhPT0gbnVsbCAmJiBldmVudC5jbGllbnRYICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cbiAgICAgIGV2ZW50LnBhZ2VYID0gZXZlbnQuY2xpZW50WCArIChkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCkgLSAoZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDApO1xuICAgICAgZXZlbnQucGFnZVkgPSBldmVudC5jbGllbnRZICsgKGRvYyAmJiBkb2Muc2Nyb2xsVG9wIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgfHwgMCkgLSAoZG9jICYmIGRvYy5jbGllbnRUb3AgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCB8fCAwKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUga2V5IHByZXNzZXNcbiAgICBldmVudC53aGljaCA9IGV2ZW50LmNoYXJDb2RlIHx8IGV2ZW50LmtleUNvZGU7XG5cbiAgICAvLyBGaXggYnV0dG9uIGZvciBtb3VzZSBjbGlja3M6XG4gICAgLy8gMCA9PSBsZWZ0OyAxID09IG1pZGRsZTsgMiA9PSByaWdodFxuICAgIGlmIChldmVudC5idXR0b24gIT09IG51bGwgJiYgZXZlbnQuYnV0dG9uICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBpcyBkaXNhYmxlZCBiZWNhdXNlIGl0IGRvZXMgbm90IHBhc3MgdmlkZW9qcy1zdGFuZGFyZFxuICAgICAgLy8gYW5kLi4uIHlpa2VzLlxuICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAgIGV2ZW50LmJ1dHRvbiA9IGV2ZW50LmJ1dHRvbiAmIDEgPyAwIDogZXZlbnQuYnV0dG9uICYgNCA/IDEgOiBldmVudC5idXR0b24gJiAyID8gMiA6IDA7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBmaXhlZC11cCBpbnN0YW5jZVxuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogV2hldGhlciBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycyBhcmUgc3VwcG9ydGVkXG4gKi9cbnZhciBfc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIF9zdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZGlzcmVnYXJkXG4gIH1cbn0pKCk7XG5cbi8qKlxuICogVG91Y2ggZXZlbnRzIENocm9tZSBleHBlY3RzIHRvIGJlIHBhc3NpdmVcbiAqL1xudmFyIHBhc3NpdmVFdmVudHMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJ107XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGVsZW1lbnRcbiAqIEl0IHN0b3JlcyB0aGUgaGFuZGxlciBmdW5jdGlvbiBpbiBhIHNlcGFyYXRlIGNhY2hlIG9iamVjdFxuICogYW5kIGFkZHMgYSBnZW5lcmljIGhhbmRsZXIgdG8gdGhlIGVsZW1lbnQncyBldmVudCxcbiAqIGFsb25nIHdpdGggYSB1bmlxdWUgaWQgKGd1aWQpIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW1cbiAqICAgICAgICBFbGVtZW50IG9yIG9iamVjdCB0byBiaW5kIGxpc3RlbmVycyB0b1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlXG4gKiAgICAgICAgVHlwZSBvZiBldmVudCB0byBiaW5kIHRvLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gZm5cbiAqICAgICAgICBFdmVudCBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gb24oZWxlbSwgdHlwZSwgZm4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICByZXR1cm4gX2hhbmRsZU11bHRpcGxlRXZlbnRzKG9uLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cblxuICB2YXIgZGF0YSA9IGdldERhdGEoZWxlbSk7XG5cbiAgLy8gV2UgbmVlZCBhIHBsYWNlIHRvIHN0b3JlIGFsbCBvdXIgaGFuZGxlciBkYXRhXG4gIGlmICghZGF0YS5oYW5kbGVycykge1xuICAgIGRhdGEuaGFuZGxlcnMgPSB7fTtcbiAgfVxuXG4gIGlmICghZGF0YS5oYW5kbGVyc1t0eXBlXSkge1xuICAgIGRhdGEuaGFuZGxlcnNbdHlwZV0gPSBbXTtcbiAgfVxuXG4gIGlmICghZm4uZ3VpZCkge1xuICAgIGZuLmd1aWQgPSBuZXdHVUlEKCk7XG4gIH1cblxuICBkYXRhLmhhbmRsZXJzW3R5cGVdLnB1c2goZm4pO1xuXG4gIGlmICghZGF0YS5kaXNwYXRjaGVyKSB7XG4gICAgZGF0YS5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgZGF0YS5kaXNwYXRjaGVyID0gZnVuY3Rpb24gKGV2ZW50LCBoYXNoKSB7XG5cbiAgICAgIGlmIChkYXRhLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZlbnQgPSBmaXhFdmVudChldmVudCk7XG5cbiAgICAgIHZhciBoYW5kbGVycyA9IGRhdGEuaGFuZGxlcnNbZXZlbnQudHlwZV07XG5cbiAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAvLyBDb3B5IGhhbmRsZXJzIHNvIGlmIGhhbmRsZXJzIGFyZSBhZGRlZC9yZW1vdmVkIGR1cmluZyB0aGUgcHJvY2VzcyBpdCBkb2Vzbid0IHRocm93IGV2ZXJ5dGhpbmcgb2ZmLlxuICAgICAgICB2YXIgaGFuZGxlcnNDb3B5ID0gaGFuZGxlcnMuc2xpY2UoMCk7XG5cbiAgICAgICAgZm9yICh2YXIgbSA9IDAsIG4gPSBoYW5kbGVyc0NvcHkubGVuZ3RoOyBtIDwgbjsgbSsrKSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBoYW5kbGVyc0NvcHlbbV0uY2FsbChlbGVtLCBldmVudCwgaGFzaCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGxvZyQxLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpZiAoZGF0YS5oYW5kbGVyc1t0eXBlXS5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhbHNlO1xuXG4gICAgICBpZiAoX3N1cHBvcnRzUGFzc2l2ZSAmJiBwYXNzaXZlRXZlbnRzLmluZGV4T2YodHlwZSkgPiAtMSkge1xuICAgICAgICBvcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XG4gICAgICB9XG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZGF0YS5kaXNwYXRjaGVyLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpIHtcbiAgICAgIGVsZW0uYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGRhdGEuZGlzcGF0Y2hlcik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgZnJvbSBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbVxuICogICAgICAgIE9iamVjdCB0byByZW1vdmUgbGlzdGVuZXJzIGZyb20uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt0eXBlXVxuICogICAgICAgIFR5cGUgb2YgbGlzdGVuZXIgdG8gcmVtb3ZlLiBEb24ndCBpbmNsdWRlIHRvIHJlbW92ZSBhbGwgZXZlbnRzIGZyb20gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IFtmbl1cbiAqICAgICAgICBTcGVjaWZpYyBsaXN0ZW5lciB0byByZW1vdmUuIERvbid0IGluY2x1ZGUgdG8gcmVtb3ZlIGxpc3RlbmVycyBmb3IgYW4gZXZlbnRcbiAqICAgICAgICB0eXBlLlxuICovXG5mdW5jdGlvbiBvZmYoZWxlbSwgdHlwZSwgZm4pIHtcbiAgLy8gRG9uJ3Qgd2FudCB0byBhZGQgYSBjYWNoZSBvYmplY3QgdGhyb3VnaCBnZXRFbERhdGEgaWYgbm90IG5lZWRlZFxuICBpZiAoIWhhc0RhdGEoZWxlbSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IGdldERhdGEoZWxlbSk7XG5cbiAgLy8gSWYgbm8gZXZlbnRzIGV4aXN0LCBub3RoaW5nIHRvIHVuYmluZFxuICBpZiAoIWRhdGEuaGFuZGxlcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIHJldHVybiBfaGFuZGxlTXVsdGlwbGVFdmVudHMob2ZmLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cblxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uXG4gIHZhciByZW1vdmVUeXBlID0gZnVuY3Rpb24gcmVtb3ZlVHlwZShlbCwgdCkge1xuICAgIGRhdGEuaGFuZGxlcnNbdF0gPSBbXTtcbiAgICBfY2xlYW5VcEV2ZW50cyhlbCwgdCk7XG4gIH07XG5cbiAgLy8gQXJlIHdlIHJlbW92aW5nIGFsbCBib3VuZCBldmVudHM/XG4gIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciB0IGluIGRhdGEuaGFuZGxlcnMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YS5oYW5kbGVycyB8fCB7fSwgdCkpIHtcbiAgICAgICAgcmVtb3ZlVHlwZShlbGVtLCB0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJzID0gZGF0YS5oYW5kbGVyc1t0eXBlXTtcblxuICAvLyBJZiBubyBoYW5kbGVycyBleGlzdCwgbm90aGluZyB0byB1bmJpbmRcbiAgaWYgKCFoYW5kbGVycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIG5vIGxpc3RlbmVyIHdhcyBwcm92aWRlZCwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHR5cGVcbiAgaWYgKCFmbikge1xuICAgIHJlbW92ZVR5cGUoZWxlbSwgdHlwZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gV2UncmUgb25seSByZW1vdmluZyBhIHNpbmdsZSBoYW5kbGVyXG4gIGlmIChmbi5ndWlkKSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBoYW5kbGVycy5sZW5ndGg7IG4rKykge1xuICAgICAgaWYgKGhhbmRsZXJzW25dLmd1aWQgPT09IGZuLmd1aWQpIHtcbiAgICAgICAgaGFuZGxlcnMuc3BsaWNlKG4tLSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NsZWFuVXBFdmVudHMoZWxlbSwgdHlwZSk7XG59XG5cbi8qKlxuICogVHJpZ2dlciBhbiBldmVudCBmb3IgYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW1cbiAqICAgICAgICBFbGVtZW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgb25cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fHN0cmluZ30gZXZlbnRcbiAqICAgICAgICBBIHN0cmluZyAodGhlIHR5cGUpIG9yIGFuIGV2ZW50IG9iamVjdCB3aXRoIGEgdHlwZSBhdHRyaWJ1dGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2hhc2hdXG4gKiAgICAgICAgZGF0YSBoYXNoIHRvIHBhc3MgYWxvbmcgd2l0aCB0aGUgZXZlbnRcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cbiAqICAgICAgICAgLSBSZXR1cm5zIHRoZSBvcHBvc2l0ZSBvZiBgZGVmYXVsdFByZXZlbnRlZGAgaWYgZGVmYXVsdCB3YXMgcHJldmVudGVkXG4gKiAgICAgICAgIC0gT3RoZXJ3aXNlIHJldHVybnMgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXIoZWxlbSwgZXZlbnQsIGhhc2gpIHtcbiAgLy8gRmV0Y2hlcyBlbGVtZW50IGRhdGEgYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgKGZvciBidWJibGluZykuXG4gIC8vIERvbid0IHdhbnQgdG8gYWRkIGEgZGF0YSBvYmplY3QgdG8gY2FjaGUgZm9yIGV2ZXJ5IHBhcmVudCxcbiAgLy8gc28gY2hlY2tpbmcgaGFzRWxEYXRhIGZpcnN0LlxuICB2YXIgZWxlbURhdGEgPSBoYXNEYXRhKGVsZW0pID8gZ2V0RGF0YShlbGVtKSA6IHt9O1xuICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlIHx8IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgLy8gdHlwZSA9IGV2ZW50LnR5cGUgfHwgZXZlbnQsXG4gIC8vIGhhbmRsZXI7XG5cbiAgLy8gSWYgYW4gZXZlbnQgbmFtZSB3YXMgcGFzc2VkIGFzIGEgc3RyaW5nLCBjcmVhdGVzIGFuIGV2ZW50IG91dCBvZiBpdFxuICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgIGV2ZW50ID0geyB0eXBlOiBldmVudCwgdGFyZ2V0OiBlbGVtIH07XG4gIH1cbiAgLy8gTm9ybWFsaXplcyB0aGUgZXZlbnQgcHJvcGVydGllcy5cbiAgZXZlbnQgPSBmaXhFdmVudChldmVudCk7XG5cbiAgLy8gSWYgdGhlIHBhc3NlZCBlbGVtZW50IGhhcyBhIGRpc3BhdGNoZXIsIGV4ZWN1dGVzIHRoZSBlc3RhYmxpc2hlZCBoYW5kbGVycy5cbiAgaWYgKGVsZW1EYXRhLmRpc3BhdGNoZXIpIHtcbiAgICBlbGVtRGF0YS5kaXNwYXRjaGVyLmNhbGwoZWxlbSwgZXZlbnQsIGhhc2gpO1xuICB9XG5cbiAgLy8gVW5sZXNzIGV4cGxpY2l0bHkgc3RvcHBlZCBvciB0aGUgZXZlbnQgZG9lcyBub3QgYnViYmxlIChlLmcuIG1lZGlhIGV2ZW50cylcbiAgLy8gcmVjdXJzaXZlbHkgY2FsbHMgdGhpcyBmdW5jdGlvbiB0byBidWJibGUgdGhlIGV2ZW50IHVwIHRoZSBET00uXG4gIGlmIChwYXJlbnQgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgJiYgZXZlbnQuYnViYmxlcyA9PT0gdHJ1ZSkge1xuICAgIHRyaWdnZXIuY2FsbChudWxsLCBwYXJlbnQsIGV2ZW50LCBoYXNoKTtcblxuICAgIC8vIElmIGF0IHRoZSB0b3Agb2YgdGhlIERPTSwgdHJpZ2dlcnMgdGhlIGRlZmF1bHQgYWN0aW9uIHVubGVzcyBkaXNhYmxlZC5cbiAgfSBlbHNlIGlmICghcGFyZW50ICYmICFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdmFyIHRhcmdldERhdGEgPSBnZXREYXRhKGV2ZW50LnRhcmdldCk7XG5cbiAgICAvLyBDaGVja3MgaWYgdGhlIHRhcmdldCBoYXMgYSBkZWZhdWx0IGFjdGlvbiBmb3IgdGhpcyBldmVudC5cbiAgICBpZiAoZXZlbnQudGFyZ2V0W2V2ZW50LnR5cGVdKSB7XG4gICAgICAvLyBUZW1wb3JhcmlseSBkaXNhYmxlcyBldmVudCBkaXNwYXRjaGluZyBvbiB0aGUgdGFyZ2V0IGFzIHdlIGhhdmUgYWxyZWFkeSBleGVjdXRlZCB0aGUgaGFuZGxlci5cbiAgICAgIHRhcmdldERhdGEuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgLy8gRXhlY3V0ZXMgdGhlIGRlZmF1bHQgYWN0aW9uLlxuICAgICAgaWYgKHR5cGVvZiBldmVudC50YXJnZXRbZXZlbnQudHlwZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXZlbnQudGFyZ2V0W2V2ZW50LnR5cGVdKCk7XG4gICAgICB9XG4gICAgICAvLyBSZS1lbmFibGVzIGV2ZW50IGRpc3BhdGNoaW5nLlxuICAgICAgdGFyZ2V0RGF0YS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluZm9ybSB0aGUgdHJpZ2dlcmVyIGlmIHRoZSBkZWZhdWx0IHdhcyBwcmV2ZW50ZWQgYnkgcmV0dXJuaW5nIGZhbHNlXG4gIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGEgbGlzdGVuZXIgb25seSBvbmNlIGZvciBhbiBldmVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW1cbiAqICAgICAgICBFbGVtZW50IG9yIG9iamVjdCB0byBiaW5kIHRvLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlXG4gKiAgICAgICAgTmFtZS90eXBlIG9mIGV2ZW50XG4gKlxuICogQHBhcmFtIHtFdmVudH5FdmVudExpc3RlbmVyfSBmblxuICogICAgICAgIEV2ZW50IExpc3RlbmVyIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIG9uZShlbGVtLCB0eXBlLCBmbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIHJldHVybiBfaGFuZGxlTXVsdGlwbGVFdmVudHMob25lLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cbiAgdmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKCkge1xuICAgIG9mZihlbGVtLCB0eXBlLCBmdW5jKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIGNvcHkgdGhlIGd1aWQgdG8gdGhlIG5ldyBmdW5jdGlvbiBzbyBpdCBjYW4gcmVtb3ZlZCB1c2luZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24ncyBJRFxuICBmdW5jLmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBuZXdHVUlEKCk7XG4gIG9uKGVsZW0sIHR5cGUsIGZ1bmMpO1xufVxuXG52YXIgRXZlbnRzID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7XG5cdGZpeEV2ZW50OiBmaXhFdmVudCxcblx0b246IG9uLFxuXHRvZmY6IG9mZixcblx0dHJpZ2dlcjogdHJpZ2dlcixcblx0b25lOiBvbmVcbn0pO1xuXG4vKipcbiAqIEBmaWxlIHNldHVwLmpzIC0gRnVuY3Rpb25zIGZvciBzZXR0aW5nIHVwIGEgcGxheWVyIHdpdGhvdXRcbiAqIHVzZXIgaW50ZXJhY3Rpb24gYmFzZWQgb24gdGhlIGRhdGEtc2V0dXAgYGF0dHJpYnV0ZWAgb2YgdGhlIHZpZGVvIHRhZy5cbiAqXG4gKiBAbW9kdWxlIHNldHVwXG4gKi9cbnZhciBfd2luZG93TG9hZGVkID0gZmFsc2U7XG52YXIgdmlkZW9qcyQyID0gdm9pZCAwO1xuXG4vKipcbiAqIFNldCB1cCBhbnkgdGFncyB0aGF0IGhhdmUgYSBkYXRhLXNldHVwIGBhdHRyaWJ1dGVgIHdoZW4gdGhlIHBsYXllciBpcyBzdGFydGVkLlxuICovXG52YXIgYXV0b1NldHVwID0gZnVuY3Rpb24gYXV0b1NldHVwKCkge1xuXG4gIC8vIFByb3RlY3QgYWdhaW5zdCBicmVha2FnZSBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMuXG4gIGlmICghaXNSZWFsKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBPbmUgZGF5LCB3aGVuIHdlIHN0b3Agc3VwcG9ydGluZyBJRTgsIGdvIGJhY2sgdG8gdGhpcywgYnV0IGluIHRoZSBtZWFudGltZS4uLipoYWNrIGhhY2sgaGFjaypcbiAgLy8gdmFyIHZpZHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKSk7XG4gIC8vIHZhciBhdWRpb3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYXVkaW8nKSk7XG4gIC8vIHZhciBtZWRpYUVscyA9IHZpZHMuY29uY2F0KGF1ZGlvcyk7XG5cbiAgLy8gQmVjYXVzZSBJRTggZG9lc24ndCBzdXBwb3J0IGNhbGxpbmcgc2xpY2Ugb24gYSBub2RlIGxpc3QsIHdlIG5lZWQgdG8gbG9vcFxuICAvLyB0aHJvdWdoIGVhY2ggbGlzdCBvZiBlbGVtZW50cyB0byBidWlsZCB1cCBhIG5ldywgY29tYmluZWQgbGlzdCBvZiBlbGVtZW50cy5cbiAgdmFyIHZpZHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKTtcbiAgdmFyIGF1ZGlvcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhdWRpbycpO1xuICB2YXIgZGl2cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd2aWRlby1qcycpO1xuICB2YXIgbWVkaWFFbHMgPSBbXTtcblxuICBpZiAodmlkcyAmJiB2aWRzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZSA9IHZpZHMubGVuZ3RoOyBpIDwgZTsgaSsrKSB7XG4gICAgICBtZWRpYUVscy5wdXNoKHZpZHNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhdWRpb3MgJiYgYXVkaW9zLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9lID0gYXVkaW9zLmxlbmd0aDsgX2kgPCBfZTsgX2krKykge1xuICAgICAgbWVkaWFFbHMucHVzaChhdWRpb3NbX2ldKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGl2cyAmJiBkaXZzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBfaTIgPSAwLCBfZTIgPSBkaXZzLmxlbmd0aDsgX2kyIDwgX2UyOyBfaTIrKykge1xuICAgICAgbWVkaWFFbHMucHVzaChkaXZzW19pMl0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIGlmIGFueSBtZWRpYSBlbGVtZW50cyBleGlzdFxuICBpZiAobWVkaWFFbHMgJiYgbWVkaWFFbHMubGVuZ3RoID4gMCkge1xuXG4gICAgZm9yICh2YXIgX2kzID0gMCwgX2UzID0gbWVkaWFFbHMubGVuZ3RoOyBfaTMgPCBfZTM7IF9pMysrKSB7XG4gICAgICB2YXIgbWVkaWFFbCA9IG1lZGlhRWxzW19pM107XG5cbiAgICAgIC8vIENoZWNrIGlmIGVsZW1lbnQgZXhpc3RzLCBoYXMgZ2V0QXR0cmlidXRlIGZ1bmMuXG4gICAgICAvLyBJRSBzZWVtcyB0byBjb25zaWRlciB0eXBlb2YgZWwuZ2V0QXR0cmlidXRlID09ICdvYmplY3QnIGluc3RlYWQgb2ZcbiAgICAgIC8vICdmdW5jdGlvbicgbGlrZSBleHBlY3RlZCwgYXQgbGVhc3Qgd2hlbiBsb2FkaW5nIHRoZSBwbGF5ZXIgaW1tZWRpYXRlbHkuXG4gICAgICBpZiAobWVkaWFFbCAmJiBtZWRpYUVsLmdldEF0dHJpYnV0ZSkge1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIHBsYXllciBoYXNuJ3QgYWxyZWFkeSBiZWVuIHNldCB1cC5cbiAgICAgICAgaWYgKG1lZGlhRWwucGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IG1lZGlhRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNldHVwJyk7XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiBkYXRhLXNldHVwIGF0dHIgZXhpc3RzLlxuICAgICAgICAgIC8vIFdlIG9ubHkgYXV0by1zZXR1cCBpZiB0aGV5J3ZlIGFkZGVkIHRoZSBkYXRhLXNldHVwIGF0dHIuXG4gICAgICAgICAgaWYgKG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgdmlkZW8uanMgaW5zdGFuY2UuXG4gICAgICAgICAgICB2aWRlb2pzJDIobWVkaWFFbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgZ2V0QXR0cmlidXRlIGlzbid0IGRlZmluZWQsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIERPTS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF1dG9TZXR1cFRpbWVvdXQoMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIHZpZGVvcyB3ZXJlIGZvdW5kLCBzbyBrZWVwIGxvb3BpbmcgdW5sZXNzIHBhZ2UgaXMgZmluaXNoZWQgbG9hZGluZy5cbiAgfSBlbHNlIGlmICghX3dpbmRvd0xvYWRlZCkge1xuICAgIGF1dG9TZXR1cFRpbWVvdXQoMSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FpdCB1bnRpbCB0aGUgcGFnZSBpcyBsb2FkZWQgYmVmb3JlIHJ1bm5pbmcgYXV0b1NldHVwLiBUaGlzIHdpbGwgYmUgY2FsbGVkIGluXG4gKiBhdXRvU2V0dXAgaWYgYGhhc0xvYWRlZGAgcmV0dXJucyBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gd2FpdFxuICogICAgICAgIEhvdyBsb25nIHRvIHdhaXQgaW4gbXNcbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp2aWRlb2pzfSBbdmpzXVxuICogICAgICAgIFRoZSB2aWRlb2pzIGxpYnJhcnkgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gYXV0b1NldHVwVGltZW91dCh3YWl0LCB2anMpIHtcbiAgaWYgKHZqcykge1xuICAgIHZpZGVvanMkMiA9IHZqcztcbiAgfVxuXG4gIHdpbmRvdy5zZXRUaW1lb3V0KGF1dG9TZXR1cCwgd2FpdCk7XG59XG5cbmlmIChpc1JlYWwoKSAmJiBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gIF93aW5kb3dMb2FkZWQgPSB0cnVlO1xufSBlbHNlIHtcbiAgLyoqXG4gICAqIExpc3RlbiBmb3IgdGhlIGxvYWQgZXZlbnQgb24gd2luZG93LCBhbmQgc2V0IF93aW5kb3dMb2FkZWQgdG8gdHJ1ZS5cbiAgICpcbiAgICogQGxpc3RlbnMgbG9hZFxuICAgKi9cbiAgb25lKHdpbmRvdywgJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgX3dpbmRvd0xvYWRlZCA9IHRydWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEBmaWxlIHN0eWxlc2hlZXQuanNcbiAqIEBtb2R1bGUgc3R5bGVzaGVldFxuICovXG4vKipcbiAqIENyZWF0ZSBhIERPTSBzeWxlIGVsZW1lbnQgZ2l2ZW4gYSBjbGFzc05hbWUgZm9yIGl0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAqICAgICAgICBUaGUgY2xhc3NOYW1lIHRvIGFkZCB0byB0aGUgY3JlYXRlZCBzdHlsZSBlbGVtZW50LlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gKi9cbnZhciBjcmVhdGVTdHlsZUVsZW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQoY2xhc3NOYW1lKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgc3R5bGUuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cbi8qKlxuICogQWRkIHRleHQgdG8gYSBET00gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgVGhlIEVsZW1lbnQgdG8gYWRkIHRleHQgY29udGVudCB0by5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogICAgICAgIFRoZSB0ZXh0IHRvIGFkZCB0byB0aGUgZWxlbWVudC5cbiAqL1xudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQoZWwsIGNvbnRlbnQpIHtcbiAgaWYgKGVsLnN0eWxlU2hlZXQpIHtcbiAgICBlbC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjb250ZW50O1xuICB9IGVsc2Uge1xuICAgIGVsLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgfVxufTtcblxuLyoqXG4gKiBAZmlsZSBmbi5qc1xuICogQG1vZHVsZSBmblxuICovXG4vKipcbiAqIEJpbmQgKGEuay5hIHByb3h5IG9yIENvbnRleHQpLiBBIHNpbXBsZSBtZXRob2QgZm9yIGNoYW5naW5nIHRoZSBjb250ZXh0IG9mIGEgZnVuY3Rpb25cbiAqIEl0IGFsc28gc3RvcmVzIGEgdW5pcXVlIGlkIG9uIHRoZSBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgZWFzaWx5IHJlbW92ZWQgZnJvbSBldmVudHMuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dFxuICogICAgICAgIFRoZSBvYmplY3QgdG8gYmluZCBhcyBzY29wZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBiZSBib3VuZCB0byBhIHNjb3BlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdWlkXVxuICogICAgICAgIEFuIG9wdGlvbmFsIHVuaXF1ZSBJRCBmb3IgdGhlIGZ1bmN0aW9uIHRvIGJlIHNldFxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogICAgICAgICBUaGUgbmV3IGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBib3VuZCBpbnRvIHRoZSBjb250ZXh0IGdpdmVuXG4gKi9cbnZhciBiaW5kID0gZnVuY3Rpb24gYmluZChjb250ZXh0LCBmbiwgdWlkKSB7XG4gIC8vIE1ha2Ugc3VyZSB0aGUgZnVuY3Rpb24gaGFzIGEgdW5pcXVlIElEXG4gIGlmICghZm4uZ3VpZCkge1xuICAgIGZuLmd1aWQgPSBuZXdHVUlEKCk7XG4gIH1cblxuICAvLyBDcmVhdGUgdGhlIG5ldyBmdW5jdGlvbiB0aGF0IGNoYW5nZXMgdGhlIGNvbnRleHRcbiAgdmFyIGJvdW5kID0gZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQWxsb3cgZm9yIHRoZSBhYmlsaXR5IHRvIGluZGl2aWR1YWxpemUgdGhpcyBmdW5jdGlvblxuICAvLyBOZWVkZWQgaW4gdGhlIGNhc2Ugd2hlcmUgbXVsdGlwbGUgb2JqZWN0cyBtaWdodCBzaGFyZSB0aGUgc2FtZSBwcm90b3R5cGVcbiAgLy8gSUYgYm90aCBpdGVtcyBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgd2l0aCB0aGUgc2FtZSBmdW5jdGlvbiwgdGhlbiB5b3UgdHJ5IHRvIHJlbW92ZSBqdXN0IG9uZVxuICAvLyBpdCB3aWxsIHJlbW92ZSBib3RoIGJlY2F1c2UgdGhleSBib3RoIGhhdmUgdGhlIHNhbWUgZ3VpZC5cbiAgLy8gd2hlbiB1c2luZyB0aGlzLCB5b3UgbmVlZCB0byB1c2UgdGhlIGJpbmQgbWV0aG9kIHdoZW4geW91IHJlbW92ZSB0aGUgbGlzdGVuZXIgYXMgd2VsbC5cbiAgLy8gY3VycmVudGx5IHVzZWQgaW4gdGV4dCB0cmFja3NcbiAgYm91bmQuZ3VpZCA9IHVpZCA/IHVpZCArICdfJyArIGZuLmd1aWQgOiBmbi5ndWlkO1xuXG4gIHJldHVybiBib3VuZDtcbn07XG5cbi8qKlxuICogV3JhcHMgdGhlIGdpdmVuIGZ1bmN0aW9uLCBgZm5gLCB3aXRoIGEgbmV3IGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmbmBcbiAqIGF0IG1vc3Qgb25jZSBwZXIgZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAqICAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGJlIHRocm90dGxlZC5cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgd2FpdFxuICogICAgICAgICBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBieSB3aGljaCB0byB0aHJvdHRsZS5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xudmFyIHRocm90dGxlID0gZnVuY3Rpb24gdGhyb3R0bGUoZm4sIHdhaXQpIHtcbiAgdmFyIGxhc3QgPSBEYXRlLm5vdygpO1xuXG4gIHZhciB0aHJvdHRsZWQgPSBmdW5jdGlvbiB0aHJvdHRsZWQoKSB7XG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBpZiAobm93IC0gbGFzdCA+PSB3YWl0KSB7XG4gICAgICBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICBsYXN0ID0gbm93O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhyb3R0bGVkO1xufTtcblxuLyoqXG4gKiBAZmlsZSBzcmMvanMvZXZlbnQtdGFyZ2V0LmpzXG4gKi9cbi8qKlxuICogYEV2ZW50VGFyZ2V0YCBpcyBhIGNsYXNzIHRoYXQgY2FuIGhhdmUgdGhlIHNhbWUgQVBJIGFzIHRoZSBET00gYEV2ZW50VGFyZ2V0YC4gSXRcbiAqIGFkZHMgc2hvcnRoYW5kIGZ1bmN0aW9ucyB0aGF0IHdyYXAgYXJvdW5kIGxlbmd0aHkgZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAqIHRoZSBgb25gIGZ1bmN0aW9uIGlzIGEgd3JhcHBlciBhcm91bmQgYGFkZEV2ZW50TGlzdGVuZXJgLlxuICpcbiAqIEBzZWUgW0V2ZW50VGFyZ2V0IFNwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1FdmVudHMvZXZlbnRzLmh0bWwjRXZlbnRzLUV2ZW50VGFyZ2V0fVxuICogQGNsYXNzIEV2ZW50VGFyZ2V0XG4gKi9cbnZhciBFdmVudFRhcmdldCA9IGZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge307XG5cbi8qKlxuICogQSBDdXN0b20gRE9NIGV2ZW50LlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV2ZW50VGFyZ2V0fkV2ZW50XG4gKiBAc2VlIFtQcm9wZXJ0aWVzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnR9XG4gKi9cblxuLyoqXG4gKiBBbGwgZXZlbnQgbGlzdGVuZXJzIHNob3VsZCBmb2xsb3cgdGhlIGZvbGxvd2luZyBmb3JtYXQuXG4gKlxuICogQGNhbGxiYWNrIEV2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJcbiAqIEB0aGlzIHtFdmVudFRhcmdldH1cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICogICAgICAgIHRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtoYXNoXVxuICogICAgICAgIGhhc2ggb2YgZGF0YSBzZW50IGR1cmluZyB0aGUgZXZlbnRcbiAqL1xuXG4vKipcbiAqIEFuIG9iamVjdCBjb250YWluaW5nIGV2ZW50IG5hbWVzIGFzIGtleXMgYW5kIGJvb2xlYW5zIGFzIHZhbHVlcy5cbiAqXG4gKiA+IE5PVEU6IElmIGFuIGV2ZW50IG5hbWUgaXMgc2V0IHRvIGEgdHJ1ZSB2YWx1ZSBoZXJlIHtAbGluayBFdmVudFRhcmdldCN0cmlnZ2VyfVxuICogICAgICAgICB3aWxsIGhhdmUgZXh0cmEgZnVuY3Rpb25hbGl0eS4gU2VlIHRoYXQgZnVuY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHByb3BlcnR5IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzX1xuICogQHByaXZhdGVcbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge307XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnQgbGlzdGVuZXJgIHRvIGFuIGluc3RhbmNlIG9mIGFuIGBFdmVudFRhcmdldGAuIEFuIGBldmVudCBsaXN0ZW5lcmAgaXMgYVxuICogZnVuY3Rpb24gdGhhdCB3aWxsIGdldCBjYWxsZWQgd2hlbiBhbiBldmVudCB3aXRoIGEgY2VydGFpbiBuYW1lIGdldHMgdHJpZ2dlcmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlXG4gKiAgICAgICAgQW4gZXZlbnQgbmFtZSBvciBhbiBhcnJheSBvZiBldmVudCBuYW1lcy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZuXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBgRXZlbnRUYXJnZXRgc1xuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgLy8gUmVtb3ZlIHRoZSBhZGRFdmVudExpc3RlbmVyIGFsaWFzIGJlZm9yZSBjYWxsaW5nIEV2ZW50cy5vblxuICAvLyBzbyB3ZSBkb24ndCBnZXQgaW50byBhbiBpbmZpbml0ZSB0eXBlIGxvb3BcbiAgdmFyIGFlbCA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcjtcblxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgb24odGhpcywgdHlwZSwgZm4pO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBhZWw7XG59O1xuXG4vKipcbiAqIEFuIGFsaWFzIG9mIHtAbGluayBFdmVudFRhcmdldCNvbn0uIEFsbG93cyBgRXZlbnRUYXJnZXRgIHRvIG1pbWljXG4gKiB0aGUgc3RhbmRhcmQgRE9NIEFQSS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBzZWUge0BsaW5rIEV2ZW50VGFyZ2V0I29ufVxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbjtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGBldmVudCBsaXN0ZW5lcmAgZm9yIGEgc3BlY2lmaWMgZXZlbnQgZnJvbSBhbiBpbnN0YW5jZSBvZiBgRXZlbnRUYXJnZXRgLlxuICogVGhpcyBtYWtlcyBpdCBzbyB0aGF0IHRoZSBgZXZlbnQgbGlzdGVuZXJgIHdpbGwgbm8gbG9uZ2VyIGdldCBjYWxsZWQgd2hlbiB0aGVcbiAqIG5hbWVkIGV2ZW50IGhhcHBlbnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHR5cGVcbiAqICAgICAgICBBbiBldmVudCBuYW1lIG9yIGFuIGFycmF5IG9mIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gZm5cbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gcmVtb3ZlLlxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gIG9mZih0aGlzLCB0eXBlLCBmbik7XG59O1xuXG4vKipcbiAqIEFuIGFsaWFzIG9mIHtAbGluayBFdmVudFRhcmdldCNvZmZ9LiBBbGxvd3MgYEV2ZW50VGFyZ2V0YCB0byBtaW1pY1xuICogdGhlIHN0YW5kYXJkIERPTSBBUEkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAc2VlIHtAbGluayBFdmVudFRhcmdldCNvZmZ9XG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLm9mZjtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWRkIGFuIGBldmVudCBsaXN0ZW5lcmAgdGhhdCBnZXRzIHRyaWdnZXJlZCBvbmx5IG9uY2UuIEFmdGVyIHRoZVxuICogZmlyc3QgdHJpZ2dlciBpdCB3aWxsIGdldCByZW1vdmVkLiBUaGlzIGlzIGxpa2UgYWRkaW5nIGFuIGBldmVudCBsaXN0ZW5lcmBcbiAqIHdpdGgge0BsaW5rIEV2ZW50VGFyZ2V0I29ufSB0aGF0IGNhbGxzIHtAbGluayBFdmVudFRhcmdldCNvZmZ9IG9uIGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdHlwZVxuICogICAgICAgIEFuIGV2ZW50IG5hbWUgb3IgYW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMuXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBmblxuICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBldmVudCBuYW1lLlxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUub25lID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gIC8vIFJlbW92ZSB0aGUgYWRkRXZlbnRMaXN0ZW5lciBhbGlhbGluZyBFdmVudHMub25cbiAgLy8gc28gd2UgZG9uJ3QgZ2V0IGludG8gYW4gaW5maW5pdGUgdHlwZSBsb29wXG4gIHZhciBhZWwgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXI7XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKCkge307XG4gIG9uZSh0aGlzLCB0eXBlLCBmbik7XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGFlbDtcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYXVzZXMgYW4gZXZlbnQgdG8gaGFwcGVuLiBUaGlzIHdpbGwgdGhlbiBjYXVzZSBhbnkgYGV2ZW50IGxpc3RlbmVyc2BcbiAqIHRoYXQgYXJlIHdhaXRpbmcgZm9yIHRoYXQgZXZlbnQsIHRvIGdldCBjYWxsZWQuIElmIHRoZXJlIGFyZSBubyBgZXZlbnQgbGlzdGVuZXJzYFxuICogZm9yIGFuIGV2ZW50IHRoZW4gbm90aGluZyB3aWxsIGhhcHBlbi5cbiAqXG4gKiBJZiB0aGUgbmFtZSBvZiB0aGUgYEV2ZW50YCB0aGF0IGlzIGJlaW5nIHRyaWdnZXJlZCBpcyBpbiBgRXZlbnRUYXJnZXQuYWxsb3dlZEV2ZW50c19gLlxuICogVHJpZ2dlciB3aWxsIGFsc28gY2FsbCB0aGUgYG9uYCArIGB1cHBlcmNhc2VFdmVudE5hbWVgIGZ1bmN0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKiAnY2xpY2snIGlzIGluIGBFdmVudFRhcmdldC5hbGxvd2VkRXZlbnRzX2AsIHNvLCB0cmlnZ2VyIHdpbGwgYXR0ZW1wdCB0byBjYWxsXG4gKiBgb25DbGlja2AgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEV2ZW50VGFyZ2V0fkV2ZW50fE9iamVjdH0gZXZlbnRcbiAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQsIGFuIGBFdmVudGAsIG9yIGFuIG9iamVjdCB3aXRoIGEga2V5IG9mIHR5cGUgc2V0IHRvXG4gKiAgICAgICAgYW4gZXZlbnQgbmFtZS5cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8IGV2ZW50O1xuXG4gIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgZXZlbnQgPSB7IHR5cGU6IHR5cGUgfTtcbiAgfVxuICBldmVudCA9IGZpeEV2ZW50KGV2ZW50KTtcblxuICBpZiAodGhpcy5hbGxvd2VkRXZlbnRzX1t0eXBlXSAmJiB0aGlzWydvbicgKyB0eXBlXSkge1xuICAgIHRoaXNbJ29uJyArIHR5cGVdKGV2ZW50KTtcbiAgfVxuXG4gIHRyaWdnZXIodGhpcywgZXZlbnQpO1xufTtcblxuLyoqXG4gKiBBbiBhbGlhcyBvZiB7QGxpbmsgRXZlbnRUYXJnZXQjdHJpZ2dlcn0uIEFsbG93cyBgRXZlbnRUYXJnZXRgIHRvIG1pbWljXG4gKiB0aGUgc3RhbmRhcmQgRE9NIEFQSS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBzZWUge0BsaW5rIEV2ZW50VGFyZ2V0I3RyaWdnZXJ9XG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLnRyaWdnZXI7XG5cbi8qKlxuICogQGZpbGUgbWl4aW5zL2V2ZW50ZWQuanNcbiAqIEBtb2R1bGUgZXZlbnRlZFxuICovXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGhhcyBoYWQgdGhlIGV2ZW50ZWQgbWl4aW4gYXBwbGllZC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iamVjdFxuICogICAgICAgICBBbiBvYmplY3QgdG8gdGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGFwcGVhcnMgdG8gYmUgZXZlbnRlZC5cbiAqL1xudmFyIGlzRXZlbnRlZCA9IGZ1bmN0aW9uIGlzRXZlbnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0IHx8ICEhb2JqZWN0LmV2ZW50QnVzRWxfICYmIFsnb24nLCAnb25lJywgJ29mZicsICd0cmlnZ2VyJ10uZXZlcnkoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdFtrXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfSk7XG59O1xuXG4vKipcbiAqIFdoZXRoZXIgYSB2YWx1ZSBpcyBhIHZhbGlkIGV2ZW50IHR5cGUgLSBub24tZW1wdHkgc3RyaW5nIG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl9IHR5cGVcbiAqICAgICAgICAgVGhlIHR5cGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgdHlwZSBpcyBhIHZhbGlkIGV2ZW50IHR5cGUuXG4gKi9cbnZhciBpc1ZhbGlkRXZlbnRUeXBlID0gZnVuY3Rpb24gaXNWYWxpZEV2ZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiAoXG4gICAgLy8gVGhlIHJlZ2V4IGhlcmUgdmVyaWZpZXMgdGhhdCB0aGUgYHR5cGVgIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBub24tXG4gICAgLy8gd2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gICAgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnICYmIC9cXFMvLnRlc3QodHlwZSkgfHwgQXJyYXkuaXNBcnJheSh0eXBlKSAmJiAhIXR5cGUubGVuZ3RoXG4gICk7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBhIHZhbHVlIHRvIGRldGVybWluZSBpZiBpdCBpcyBhIHZhbGlkIGV2ZW50IHRhcmdldC4gVGhyb3dzIGlmIG5vdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHRocm93cyB7RXJyb3J9XG4gKiAgICAgICAgIElmIHRoZSB0YXJnZXQgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgdmFsaWQgZXZlbnQgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gKiAgICAgICAgIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqL1xudmFyIHZhbGlkYXRlVGFyZ2V0ID0gZnVuY3Rpb24gdmFsaWRhdGVUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICghdGFyZ2V0Lm5vZGVOYW1lICYmICFpc0V2ZW50ZWQodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YXJnZXQ7IG11c3QgYmUgYSBET00gbm9kZSBvciBldmVudGVkIG9iamVjdC4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB2YWx1ZSB0byBkZXRlcm1pbmUgaWYgaXQgaXMgYSB2YWxpZCBldmVudCB0YXJnZXQuIFRocm93cyBpZiBub3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogICAgICAgICBJZiB0aGUgdHlwZSBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSB2YWxpZCBldmVudCB0eXBlLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ3xBcnJheX0gdHlwZVxuICogICAgICAgICBUaGUgdHlwZSB0byB0ZXN0LlxuICovXG52YXIgdmFsaWRhdGVFdmVudFR5cGUgPSBmdW5jdGlvbiB2YWxpZGF0ZUV2ZW50VHlwZSh0eXBlKSB7XG4gIGlmICghaXNWYWxpZEV2ZW50VHlwZSh0eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBldmVudCB0eXBlOyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciBhcnJheS4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB2YWx1ZSB0byBkZXRlcm1pbmUgaWYgaXQgaXMgYSB2YWxpZCBsaXN0ZW5lci4gVGhyb3dzIGlmIG5vdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHRocm93cyB7RXJyb3J9XG4gKiAgICAgICAgIElmIHRoZSBsaXN0ZW5lciBpcyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqICAgICAgICAgVGhlIGxpc3RlbmVyIHRvIHRlc3QuXG4gKi9cbnZhciB2YWxpZGF0ZUxpc3RlbmVyID0gZnVuY3Rpb24gdmFsaWRhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3RlbmVyOyBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cbn07XG5cbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIGdpdmVuIHRvIGBvbigpYCBvciBgb25lKClgLCB2YWxpZGF0ZXMgdGhlbSwgYW5kXG4gKiBub3JtYWxpemVzIHRoZW0gaW50byBhbiBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge09iamVjdH0gc2VsZlxuICogICAgICAgICBUaGUgZXZlbnRlZCBvYmplY3Qgb24gd2hpY2ggYG9uKClgIG9yIGBvbmUoKWAgd2FzIGNhbGxlZC4gVGhpc1xuICogICAgICAgICBvYmplY3Qgd2lsbCBiZSBib3VuZCBhcyB0aGUgYHRoaXNgIHZhbHVlIGZvciB0aGUgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGFyZ3NcbiAqICAgICAgICAgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHBhc3NlZCB0byBgb24oKWAgb3IgYG9uZSgpYC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHVzZWZ1bCB2YWx1ZXMgZm9yIGBvbigpYCBvciBgb25lKClgIGNhbGxzLlxuICovXG52YXIgbm9ybWFsaXplTGlzdGVuQXJncyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUxpc3RlbkFyZ3Moc2VsZiwgYXJncykge1xuXG4gIC8vIElmIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGlzIGxlc3MgdGhhbiAzLCB0aGUgdGFyZ2V0IGlzIGFsd2F5cyB0aGVcbiAgLy8gZXZlbnRlZCBvYmplY3QgaXRzZWxmLlxuICB2YXIgaXNUYXJnZXRpbmdTZWxmID0gYXJncy5sZW5ndGggPCAzIHx8IGFyZ3NbMF0gPT09IHNlbGYgfHwgYXJnc1swXSA9PT0gc2VsZi5ldmVudEJ1c0VsXztcbiAgdmFyIHRhcmdldCA9IHZvaWQgMDtcbiAgdmFyIHR5cGUgPSB2b2lkIDA7XG4gIHZhciBsaXN0ZW5lciA9IHZvaWQgMDtcblxuICBpZiAoaXNUYXJnZXRpbmdTZWxmKSB7XG4gICAgdGFyZ2V0ID0gc2VsZi5ldmVudEJ1c0VsXztcblxuICAgIC8vIERlYWwgd2l0aCBjYXNlcyB3aGVyZSB3ZSBnb3QgMyBhcmd1bWVudHMsIGJ1dCB3ZSBhcmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gdGhlIGV2ZW50ZWQgb2JqZWN0IGl0c2VsZi5cbiAgICBpZiAoYXJncy5sZW5ndGggPj0gMykge1xuICAgICAgYXJncy5zaGlmdCgpO1xuICAgIH1cblxuICAgIHR5cGUgPSBhcmdzWzBdO1xuICAgIGxpc3RlbmVyID0gYXJnc1sxXTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSBhcmdzWzBdO1xuICAgIHR5cGUgPSBhcmdzWzFdO1xuICAgIGxpc3RlbmVyID0gYXJnc1syXTtcbiAgfVxuXG4gIHZhbGlkYXRlVGFyZ2V0KHRhcmdldCk7XG4gIHZhbGlkYXRlRXZlbnRUeXBlKHR5cGUpO1xuICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBsaXN0ZW5lciA9IGJpbmQoc2VsZiwgbGlzdGVuZXIpO1xuXG4gIHJldHVybiB7IGlzVGFyZ2V0aW5nU2VsZjogaXNUYXJnZXRpbmdTZWxmLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG59O1xuXG4vKipcbiAqIEFkZHMgdGhlIGxpc3RlbmVyIHRvIHRoZSBldmVudCB0eXBlKHMpIG9uIHRoZSB0YXJnZXQsIG5vcm1hbGl6aW5nIGZvclxuICogdGhlIHR5cGUgb2YgdGFyZ2V0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtFbGVtZW50fE9iamVjdH0gdGFyZ2V0XG4gKiAgICAgICAgIEEgRE9NIG5vZGUgb3IgZXZlbnRlZCBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBtZXRob2RcbiAqICAgICAgICAgVGhlIGV2ZW50IGJpbmRpbmcgbWV0aG9kIHRvIHVzZSAoXCJvblwiIG9yIFwib25lXCIpLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ3xBcnJheX0gdHlwZVxuICogICAgICAgICBPbmUgb3IgbW9yZSBldmVudCB0eXBlKHMpLlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICogICAgICAgICBBIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICovXG52YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgbWV0aG9kLCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YWxpZGF0ZVRhcmdldCh0YXJnZXQpO1xuXG4gIGlmICh0YXJnZXQubm9kZU5hbWUpIHtcbiAgICBFdmVudHNbbWV0aG9kXSh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRbbWV0aG9kXSh0eXBlLCBsaXN0ZW5lcik7XG4gIH1cbn07XG5cbi8qKlxuICogQ29udGFpbnMgbWV0aG9kcyB0aGF0IHByb3ZpZGUgZXZlbnQgY2FwYWJpbGl0ZXMgdG8gYW4gb2JqZWN0IHdoaWNoIGlzIHBhc3NlZFxuICogdG8ge0BsaW5rIG1vZHVsZTpldmVudGVkfGV2ZW50ZWR9LlxuICpcbiAqIEBtaXhpbiBFdmVudGVkTWl4aW5cbiAqL1xudmFyIEV2ZW50ZWRNaXhpbiA9IHtcblxuICAvKipcbiAgICogQWRkIGEgbGlzdGVuZXIgdG8gYW4gZXZlbnQgKG9yIGV2ZW50cykgb24gdGhpcyBvYmplY3Qgb3IgYW5vdGhlciBldmVudGVkXG4gICAqIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEFycmF5fEVsZW1lbnR8T2JqZWN0fSB0YXJnZXRPclR5cGVcbiAgICogICAgICAgICBJZiB0aGlzIGlzIGEgc3RyaW5nIG9yIGFycmF5LCBpdCByZXByZXNlbnRzIHRoZSBldmVudCB0eXBlKHMpXG4gICAqICAgICAgICAgdGhhdCB3aWxsIHRyaWdnZXIgdGhlIGxpc3RlbmVyLlxuICAgKlxuICAgKiAgICAgICAgIEFub3RoZXIgZXZlbnRlZCBvYmplY3QgY2FuIGJlIHBhc3NlZCBoZXJlIGluc3RlYWQsIHdoaWNoIHdpbGxcbiAgICogICAgICAgICBjYXVzZSB0aGUgbGlzdGVuZXIgdG8gbGlzdGVuIGZvciBldmVudHMgb24gX3RoYXRfIG9iamVjdC5cbiAgICpcbiAgICogICAgICAgICBJbiBlaXRoZXIgY2FzZSwgdGhlIGxpc3RlbmVyJ3MgYHRoaXNgIHZhbHVlIHdpbGwgYmUgYm91bmQgdG9cbiAgICogICAgICAgICB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEFycmF5fEZ1bmN0aW9ufSB0eXBlT3JMaXN0ZW5lclxuICAgKiAgICAgICAgIElmIHRoZSBmaXJzdCBhcmd1bWVudCB3YXMgYSBzdHJpbmcgb3IgYXJyYXksIHRoaXMgc2hvdWxkIGJlIHRoZVxuICAgKiAgICAgICAgIGxpc3RlbmVyIGZ1bmN0aW9uLiBPdGhlcndpc2UsIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXkgb2YgZXZlbnRcbiAgICogICAgICAgICB0eXBlKHMpLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2xpc3RlbmVyXVxuICAgKiAgICAgICAgIElmIHRoZSBmaXJzdCBhcmd1bWVudCB3YXMgYW5vdGhlciBldmVudGVkIG9iamVjdCwgdGhpcyB3aWxsIGJlXG4gICAqICAgICAgICAgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgb246IGZ1bmN0aW9uIG9uJCQxKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgX25vcm1hbGl6ZUxpc3RlbkFyZ3MgPSBub3JtYWxpemVMaXN0ZW5BcmdzKHRoaXMsIGFyZ3MpLFxuICAgICAgICBpc1RhcmdldGluZ1NlbGYgPSBfbm9ybWFsaXplTGlzdGVuQXJncy5pc1RhcmdldGluZ1NlbGYsXG4gICAgICAgIHRhcmdldCA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzLnRhcmdldCxcbiAgICAgICAgdHlwZSA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzLnR5cGUsXG4gICAgICAgIGxpc3RlbmVyID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MubGlzdGVuZXI7XG5cbiAgICBsaXN0ZW4odGFyZ2V0LCAnb24nLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgICAvLyBJZiB0aGlzIG9iamVjdCBpcyBsaXN0ZW5pbmcgdG8gYW5vdGhlciBldmVudGVkIG9iamVjdC5cbiAgICBpZiAoIWlzVGFyZ2V0aW5nU2VsZikge1xuXG4gICAgICAvLyBJZiB0aGlzIG9iamVjdCBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICAgIHZhciByZW1vdmVMaXN0ZW5lck9uRGlzcG9zZSA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyT25EaXNwb3NlKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMub2ZmKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgfTtcblxuICAgICAgLy8gVXNlIHRoZSBzYW1lIGZ1bmN0aW9uIElEIGFzIHRoZSBsaXN0ZW5lciBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGxhdGVyIGl0XG4gICAgICAvLyB1c2luZyB0aGUgSUQgb2YgdGhlIG9yaWdpbmFsIGxpc3RlbmVyLlxuICAgICAgcmVtb3ZlTGlzdGVuZXJPbkRpc3Bvc2UuZ3VpZCA9IGxpc3RlbmVyLmd1aWQ7XG5cbiAgICAgIC8vIEFkZCBhIGxpc3RlbmVyIHRvIHRoZSB0YXJnZXQncyBkaXNwb3NlIGV2ZW50IGFzIHdlbGwuIFRoaXMgZW5zdXJlc1xuICAgICAgLy8gdGhhdCBpZiB0aGUgdGFyZ2V0IGlzIGRpc3Bvc2VkIEJFRk9SRSB0aGlzIG9iamVjdCwgd2UgcmVtb3ZlIHRoZVxuICAgICAgLy8gcmVtb3ZhbCBsaXN0ZW5lciB0aGF0IHdhcyBqdXN0IGFkZGVkLiBPdGhlcndpc2UsIHdlIGNyZWF0ZSBhIG1lbW9yeSBsZWFrLlxuICAgICAgdmFyIHJlbW92ZVJlbW92ZXJPblRhcmdldERpc3Bvc2UgPSBmdW5jdGlvbiByZW1vdmVSZW1vdmVyT25UYXJnZXREaXNwb3NlKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMub2ZmKCdkaXNwb3NlJywgcmVtb3ZlTGlzdGVuZXJPbkRpc3Bvc2UpO1xuICAgICAgfTtcblxuICAgICAgLy8gVXNlIHRoZSBzYW1lIGZ1bmN0aW9uIElEIGFzIHRoZSBsaXN0ZW5lciBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGxhdGVyXG4gICAgICAvLyBpdCB1c2luZyB0aGUgSUQgb2YgdGhlIG9yaWdpbmFsIGxpc3RlbmVyLlxuICAgICAgcmVtb3ZlUmVtb3Zlck9uVGFyZ2V0RGlzcG9zZS5ndWlkID0gbGlzdGVuZXIuZ3VpZDtcblxuICAgICAgbGlzdGVuKHRoaXMsICdvbicsICdkaXNwb3NlJywgcmVtb3ZlTGlzdGVuZXJPbkRpc3Bvc2UpO1xuICAgICAgbGlzdGVuKHRhcmdldCwgJ29uJywgJ2Rpc3Bvc2UnLCByZW1vdmVSZW1vdmVyT25UYXJnZXREaXNwb3NlKTtcbiAgICB9XG4gIH0sXG5cblxuICAvKipcbiAgICogQWRkIGEgbGlzdGVuZXIgdG8gYW4gZXZlbnQgKG9yIGV2ZW50cykgb24gdGhpcyBvYmplY3Qgb3IgYW5vdGhlciBldmVudGVkXG4gICAqIG9iamVjdC4gVGhlIGxpc3RlbmVyIHdpbGwgb25seSBiZSBjYWxsZWQgb25jZSBhbmQgdGhlbiByZW1vdmVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8RWxlbWVudHxPYmplY3R9IHRhcmdldE9yVHlwZVxuICAgKiAgICAgICAgIElmIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXksIGl0IHJlcHJlc2VudHMgdGhlIGV2ZW50IHR5cGUocylcbiAgICogICAgICAgICB0aGF0IHdpbGwgdHJpZ2dlciB0aGUgbGlzdGVuZXIuXG4gICAqXG4gICAqICAgICAgICAgQW5vdGhlciBldmVudGVkIG9iamVjdCBjYW4gYmUgcGFzc2VkIGhlcmUgaW5zdGVhZCwgd2hpY2ggd2lsbFxuICAgKiAgICAgICAgIGNhdXNlIHRoZSBsaXN0ZW5lciB0byBsaXN0ZW4gZm9yIGV2ZW50cyBvbiBfdGhhdF8gb2JqZWN0LlxuICAgKlxuICAgKiAgICAgICAgIEluIGVpdGhlciBjYXNlLCB0aGUgbGlzdGVuZXIncyBgdGhpc2AgdmFsdWUgd2lsbCBiZSBib3VuZCB0b1xuICAgKiAgICAgICAgIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8RnVuY3Rpb259IHR5cGVPckxpc3RlbmVyXG4gICAqICAgICAgICAgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBhIHN0cmluZyBvciBhcnJheSwgdGhpcyBzaG91bGQgYmUgdGhlXG4gICAqICAgICAgICAgbGlzdGVuZXIgZnVuY3Rpb24uIE90aGVyd2lzZSwgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSBvZiBldmVudFxuICAgKiAgICAgICAgIHR5cGUocykuXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbbGlzdGVuZXJdXG4gICAqICAgICAgICAgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LCB0aGlzIHdpbGwgYmVcbiAgICogICAgICAgICB0aGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gICAqL1xuICBvbmU6IGZ1bmN0aW9uIG9uZSQkMSgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgdmFyIF9ub3JtYWxpemVMaXN0ZW5BcmdzMiA9IG5vcm1hbGl6ZUxpc3RlbkFyZ3ModGhpcywgYXJncyksXG4gICAgICAgIGlzVGFyZ2V0aW5nU2VsZiA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzMi5pc1RhcmdldGluZ1NlbGYsXG4gICAgICAgIHRhcmdldCA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzMi50YXJnZXQsXG4gICAgICAgIHR5cGUgPSBfbm9ybWFsaXplTGlzdGVuQXJnczIudHlwZSxcbiAgICAgICAgbGlzdGVuZXIgPSBfbm9ybWFsaXplTGlzdGVuQXJnczIubGlzdGVuZXI7XG5cbiAgICAvLyBUYXJnZXRpbmcgdGhpcyBldmVudGVkIG9iamVjdC5cblxuXG4gICAgaWYgKGlzVGFyZ2V0aW5nU2VsZikge1xuICAgICAgbGlzdGVuKHRhcmdldCwgJ29uZScsIHR5cGUsIGxpc3RlbmVyKTtcblxuICAgICAgLy8gVGFyZ2V0aW5nIGFub3RoZXIgZXZlbnRlZCBvYmplY3QuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBsYXJncyA9IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgICAgbGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMi5vZmYodGFyZ2V0LCB0eXBlLCB3cmFwcGVyKTtcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkobnVsbCwgbGFyZ3MpO1xuICAgICAgfTtcblxuICAgICAgLy8gVXNlIHRoZSBzYW1lIGZ1bmN0aW9uIElEIGFzIHRoZSBsaXN0ZW5lciBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGxhdGVyXG4gICAgICAvLyBpdCB1c2luZyB0aGUgSUQgb2YgdGhlIG9yaWdpbmFsIGxpc3RlbmVyLlxuICAgICAgd3JhcHBlci5ndWlkID0gbGlzdGVuZXIuZ3VpZDtcbiAgICAgIGxpc3Rlbih0YXJnZXQsICdvbmUnLCB0eXBlLCB3cmFwcGVyKTtcbiAgICB9XG4gIH0sXG5cblxuICAvKipcbiAgICogUmVtb3ZlcyBsaXN0ZW5lcihzKSBmcm9tIGV2ZW50KHMpIG9uIGFuIGV2ZW50ZWQgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8RWxlbWVudHxPYmplY3R9IFt0YXJnZXRPclR5cGVdXG4gICAqICAgICAgICAgSWYgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSwgaXQgcmVwcmVzZW50cyB0aGUgZXZlbnQgdHlwZShzKS5cbiAgICpcbiAgICogICAgICAgICBBbm90aGVyIGV2ZW50ZWQgb2JqZWN0IGNhbiBiZSBwYXNzZWQgaGVyZSBpbnN0ZWFkLCBpbiB3aGljaCBjYXNlXG4gICAqICAgICAgICAgQUxMIDMgYXJndW1lbnRzIGFyZSBfcmVxdWlyZWRfLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8RnVuY3Rpb259IFt0eXBlT3JMaXN0ZW5lcl1cbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGEgc3RyaW5nIG9yIGFycmF5LCB0aGlzIG1heSBiZSB0aGVcbiAgICogICAgICAgICBsaXN0ZW5lciBmdW5jdGlvbi4gT3RoZXJ3aXNlLCB0aGlzIGlzIGEgc3RyaW5nIG9yIGFycmF5IG9mIGV2ZW50XG4gICAqICAgICAgICAgdHlwZShzKS5cbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtsaXN0ZW5lcl1cbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGFub3RoZXIgZXZlbnRlZCBvYmplY3QsIHRoaXMgd2lsbCBiZVxuICAgKiAgICAgICAgIHRoZSBsaXN0ZW5lciBmdW5jdGlvbjsgb3RoZXJ3aXNlLCBfYWxsXyBsaXN0ZW5lcnMgYm91bmQgdG8gdGhlXG4gICAqICAgICAgICAgZXZlbnQgdHlwZShzKSB3aWxsIGJlIHJlbW92ZWQuXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIG9mZiQkMSh0YXJnZXRPclR5cGUsIHR5cGVPckxpc3RlbmVyLCBsaXN0ZW5lcikge1xuXG4gICAgLy8gVGFyZ2V0aW5nIHRoaXMgZXZlbnRlZCBvYmplY3QuXG4gICAgaWYgKCF0YXJnZXRPclR5cGUgfHwgaXNWYWxpZEV2ZW50VHlwZSh0YXJnZXRPclR5cGUpKSB7XG4gICAgICBvZmYodGhpcy5ldmVudEJ1c0VsXywgdGFyZ2V0T3JUeXBlLCB0eXBlT3JMaXN0ZW5lcik7XG5cbiAgICAgIC8vIFRhcmdldGluZyBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LlxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0T3JUeXBlO1xuICAgICAgdmFyIHR5cGUgPSB0eXBlT3JMaXN0ZW5lcjtcblxuICAgICAgLy8gRmFpbCBmYXN0IGFuZCBpbiBhIG1lYW5pbmdmdWwgd2F5IVxuICAgICAgdmFsaWRhdGVUYXJnZXQodGFyZ2V0KTtcbiAgICAgIHZhbGlkYXRlRXZlbnRUeXBlKHR5cGUpO1xuICAgICAgdmFsaWRhdGVMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIC8vIEVuc3VyZSB0aGVyZSdzIGF0IGxlYXN0IGEgZ3VpZCwgZXZlbiBpZiB0aGUgZnVuY3Rpb24gaGFzbid0IGJlZW4gdXNlZFxuICAgICAgbGlzdGVuZXIgPSBiaW5kKHRoaXMsIGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBkaXNwb3NlIGxpc3RlbmVyIG9uIHRoaXMgZXZlbnRlZCBvYmplY3QsIHdoaWNoIHdhcyBnaXZlblxuICAgICAgLy8gdGhlIHNhbWUgZ3VpZCBhcyB0aGUgZXZlbnQgbGlzdGVuZXIgaW4gb24oKS5cbiAgICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgbGlzdGVuZXIpO1xuXG4gICAgICBpZiAodGFyZ2V0Lm5vZGVOYW1lKSB7XG4gICAgICAgIG9mZih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgb2ZmKHRhcmdldCwgJ2Rpc3Bvc2UnLCBsaXN0ZW5lcik7XG4gICAgICB9IGVsc2UgaWYgKGlzRXZlbnRlZCh0YXJnZXQpKSB7XG4gICAgICAgIHRhcmdldC5vZmYodHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICB0YXJnZXQub2ZmKCdkaXNwb3NlJywgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBGaXJlIGFuIGV2ZW50IG9uIHRoaXMgZXZlbnRlZCBvYmplY3QsIGNhdXNpbmcgaXRzIGxpc3RlbmVycyB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd8T2JqZWN0fSBldmVudFxuICAgKiAgICAgICAgICBBbiBldmVudCB0eXBlIG9yIGFuIG9iamVjdCB3aXRoIGEgdHlwZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtICAge09iamVjdH0gW2hhc2hdXG4gICAqICAgICAgICAgIEFuIGFkZGl0aW9uYWwgb2JqZWN0IHRvIHBhc3MgYWxvbmcgdG8gbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICogICAgICAgICAgV2hldGhlciBvciBub3QgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2FzIHByZXZlbnRlZC5cbiAgICovXG4gIHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIkJDEoZXZlbnQsIGhhc2gpIHtcbiAgICByZXR1cm4gdHJpZ2dlcih0aGlzLmV2ZW50QnVzRWxfLCBldmVudCwgaGFzaCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXBwbGllcyB7QGxpbmsgbW9kdWxlOmV2ZW50ZWR+RXZlbnRlZE1peGlufEV2ZW50ZWRNaXhpbn0gdG8gYSB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gKiAgICAgICAgIFRoZSBvYmplY3QgdG8gd2hpY2ggdG8gYWRkIGV2ZW50IG1ldGhvZHMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAqICAgICAgICAgT3B0aW9ucyBmb3IgY3VzdG9taXppbmcgdGhlIG1peGluIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gW29wdGlvbnMuZXZlbnRCdXNLZXldXG4gKiAgICAgICAgIEJ5IGRlZmF1bHQsIGFkZHMgYSBgZXZlbnRCdXNFbF9gIERPTSBlbGVtZW50IHRvIHRoZSB0YXJnZXQgb2JqZWN0LFxuICogICAgICAgICB3aGljaCBpcyB1c2VkIGFzIGFuIGV2ZW50IGJ1cy4gSWYgdGhlIHRhcmdldCBvYmplY3QgYWxyZWFkeSBoYXMgYVxuICogICAgICAgICBET00gZWxlbWVudCB0aGF0IHNob3VsZCBiZSB1c2VkLCBwYXNzIGl0cyBrZXkgaGVyZS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIFRoZSB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBldmVudGVkKHRhcmdldCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBldmVudEJ1c0tleSA9IG9wdGlvbnMuZXZlbnRCdXNLZXk7XG5cbiAgLy8gU2V0IG9yIGNyZWF0ZSB0aGUgZXZlbnRCdXNFbF8uXG5cbiAgaWYgKGV2ZW50QnVzS2V5KSB7XG4gICAgaWYgKCF0YXJnZXRbZXZlbnRCdXNLZXldLm5vZGVOYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBldmVudEJ1c0tleSBcIicgKyBldmVudEJ1c0tleSArICdcIiBkb2VzIG5vdCByZWZlciB0byBhbiBlbGVtZW50LicpO1xuICAgIH1cbiAgICB0YXJnZXQuZXZlbnRCdXNFbF8gPSB0YXJnZXRbZXZlbnRCdXNLZXldO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5ldmVudEJ1c0VsXyA9IGNyZWF0ZUVsKCdzcGFuJywgeyBjbGFzc05hbWU6ICd2anMtZXZlbnQtYnVzJyB9KTtcbiAgfVxuXG4gIGFzc2lnbih0YXJnZXQsIEV2ZW50ZWRNaXhpbik7XG5cbiAgLy8gV2hlbiBhbnkgZXZlbnRlZCBvYmplY3QgaXMgZGlzcG9zZWQsIGl0IHJlbW92ZXMgYWxsIGl0cyBsaXN0ZW5lcnMuXG4gIHRhcmdldC5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICB0YXJnZXQub2ZmKCk7XG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGFyZ2V0LmV2ZW50QnVzRWxfID0gbnVsbDtcbiAgICB9LCAwKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBAZmlsZSBtaXhpbnMvc3RhdGVmdWwuanNcbiAqIEBtb2R1bGUgc3RhdGVmdWxcbiAqL1xuLyoqXG4gKiBDb250YWlucyBtZXRob2RzIHRoYXQgcHJvdmlkZSBzdGF0ZWZ1bG5lc3MgdG8gYW4gb2JqZWN0IHdoaWNoIGlzIHBhc3NlZFxuICogdG8ge0BsaW5rIG1vZHVsZTpzdGF0ZWZ1bH0uXG4gKlxuICogQG1peGluIFN0YXRlZnVsTWl4aW5cbiAqL1xudmFyIFN0YXRlZnVsTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEEgaGFzaCBjb250YWluaW5nIGFyYml0cmFyeSBrZXlzIGFuZCB2YWx1ZXMgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZlxuICAgKiB0aGUgb2JqZWN0LlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGU6IHt9LFxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0YXRlIG9mIGFuIG9iamVjdCBieSBtdXRhdGluZyBpdHNcbiAgICoge0BsaW5rIG1vZHVsZTpzdGF0ZWZ1bH5TdGF0ZWZ1bE1peGluLnN0YXRlfHN0YXRlfSBvYmplY3QgaW4gcGxhY2UuXG4gICAqXG4gICAqIEBmaXJlcyAgIG1vZHVsZTpzdGF0ZWZ1bH5TdGF0ZWZ1bE1peGluI3N0YXRlY2hhbmdlZFxuICAgKiBAcGFyYW0gICB7T2JqZWN0fEZ1bmN0aW9ufSBzdGF0ZVVwZGF0ZXNcbiAgICogICAgICAgICAgQSBuZXcgc2V0IG9mIHByb3BlcnRpZXMgdG8gc2hhbGxvdy1tZXJnZSBpbnRvIHRoZSBwbHVnaW4gc3RhdGUuXG4gICAqICAgICAgICAgIENhbiBiZSBhIHBsYWluIG9iamVjdCBvciBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHBsYWluIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIGNoYW5nZXMgdGhhdCBvY2N1cnJlZC4gSWYgbm8gY2hhbmdlc1xuICAgKiAgICAgICAgICBvY2N1cnJlZCwgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICovXG4gIHNldFN0YXRlOiBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZVVwZGF0ZXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gU3VwcG9ydCBwcm92aWRpbmcgdGhlIGBzdGF0ZVVwZGF0ZXNgIHN0YXRlIGFzIGEgZnVuY3Rpb24uXG4gICAgaWYgKHR5cGVvZiBzdGF0ZVVwZGF0ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlVXBkYXRlcyA9IHN0YXRlVXBkYXRlcygpO1xuICAgIH1cblxuICAgIHZhciBjaGFuZ2VzID0gdm9pZCAwO1xuXG4gICAgZWFjaChzdGF0ZVVwZGF0ZXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhbmdlIGlmIHRoZSB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSB3aGF0J3MgaW4gdGhlXG4gICAgICAvLyBjdXJyZW50IHN0YXRlLlxuICAgICAgaWYgKF90aGlzLnN0YXRlW2tleV0gIT09IHZhbHVlKSB7XG4gICAgICAgIGNoYW5nZXMgPSBjaGFuZ2VzIHx8IHt9O1xuICAgICAgICBjaGFuZ2VzW2tleV0gPSB7XG4gICAgICAgICAgZnJvbTogX3RoaXMuc3RhdGVba2V5XSxcbiAgICAgICAgICB0bzogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc3RhdGVba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgLy8gT25seSB0cmlnZ2VyIFwic3RhdGVjaGFuZ2VcIiBpZiB0aGVyZSB3ZXJlIGNoYW5nZXMgQU5EIHdlIGhhdmUgYSB0cmlnZ2VyXG4gICAgLy8gZnVuY3Rpb24uIFRoaXMgYWxsb3dzIHVzIHRvIG5vdCByZXF1aXJlIHRoYXQgdGhlIHRhcmdldCBvYmplY3QgYmUgYW5cbiAgICAvLyBldmVudGVkIG9iamVjdC5cbiAgICBpZiAoY2hhbmdlcyAmJiBpc0V2ZW50ZWQodGhpcykpIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBBbiBldmVudCB0cmlnZ2VyZWQgb24gYW4gb2JqZWN0IHRoYXQgaXMgYm90aFxuICAgICAgICoge0BsaW5rIG1vZHVsZTpzdGF0ZWZ1bHxzdGF0ZWZ1bH0gYW5kIHtAbGluayBtb2R1bGU6ZXZlbnRlZHxldmVudGVkfVxuICAgICAgICogaW5kaWNhdGluZyB0aGF0IGl0cyBzdGF0ZSBoYXMgY2hhbmdlZC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgICAgbW9kdWxlOnN0YXRlZnVsflN0YXRlZnVsTWl4aW4jc3RhdGVjaGFuZ2VkXG4gICAgICAgKiBAdHlwZSAgICAge09iamVjdH1cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjaGFuZ2VzXG4gICAgICAgKiAgICAgICAgICAgQSBoYXNoIGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgdGhhdCB3ZXJlIGNoYW5nZWQgYW5kXG4gICAgICAgKiAgICAgICAgICAgdGhlIHZhbHVlcyB0aGV5IHdlcmUgY2hhbmdlZCBgZnJvbWAgYW5kIGB0b2AuXG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcih7XG4gICAgICAgIGNoYW5nZXM6IGNoYW5nZXMsXG4gICAgICAgIHR5cGU6ICdzdGF0ZWNoYW5nZWQnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlcztcbiAgfVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIHtAbGluayBtb2R1bGU6c3RhdGVmdWx+U3RhdGVmdWxNaXhpbnxTdGF0ZWZ1bE1peGlufSB0byBhIHRhcmdldFxuICogb2JqZWN0LlxuICpcbiAqIElmIHRoZSB0YXJnZXQgb2JqZWN0IGlzIHtAbGluayBtb2R1bGU6ZXZlbnRlZHxldmVudGVkfSBhbmQgaGFzIGFcbiAqIGBoYW5kbGVTdGF0ZUNoYW5nZWRgIG1ldGhvZCwgdGhhdCBtZXRob2Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kIHRvIHRoZVxuICogYHN0YXRlY2hhbmdlZGAgZXZlbnQgb24gaXRzZWxmLlxuICpcbiAqIEBwYXJhbSAgIHtPYmplY3R9IHRhcmdldFxuICogICAgICAgICAgVGhlIG9iamVjdCB0byBiZSBtYWRlIHN0YXRlZnVsLlxuICpcbiAqIEBwYXJhbSAgIHtPYmplY3R9IFtkZWZhdWx0U3RhdGVdXG4gKiAgICAgICAgICBBIGRlZmF1bHQgc2V0IG9mIHByb3BlcnRpZXMgdG8gcG9wdWxhdGUgdGhlIG5ld2x5LXN0YXRlZnVsIG9iamVjdCdzXG4gKiAgICAgICAgICBgc3RhdGVgIHByb3BlcnR5LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiAgICAgICAgICBSZXR1cm5zIHRoZSBgdGFyZ2V0YC5cbiAqL1xuZnVuY3Rpb24gc3RhdGVmdWwodGFyZ2V0LCBkZWZhdWx0U3RhdGUpIHtcbiAgYXNzaWduKHRhcmdldCwgU3RhdGVmdWxNaXhpbik7XG5cbiAgLy8gVGhpcyBoYXBwZW5zIGFmdGVyIHRoZSBtaXhpbmctaW4gYmVjYXVzZSB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhlIGBzdGF0ZWBcbiAgLy8gYWRkZWQgaW4gdGhhdCBzdGVwLlxuICB0YXJnZXQuc3RhdGUgPSBhc3NpZ24oe30sIHRhcmdldC5zdGF0ZSwgZGVmYXVsdFN0YXRlKTtcblxuICAvLyBBdXRvLWJpbmQgdGhlIGBoYW5kbGVTdGF0ZUNoYW5nZWRgIG1ldGhvZCBvZiB0aGUgdGFyZ2V0IG9iamVjdCBpZiBpdCBleGlzdHMuXG4gIGlmICh0eXBlb2YgdGFyZ2V0LmhhbmRsZVN0YXRlQ2hhbmdlZCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0V2ZW50ZWQodGFyZ2V0KSkge1xuICAgIHRhcmdldC5vbignc3RhdGVjaGFuZ2VkJywgdGFyZ2V0LmhhbmRsZVN0YXRlQ2hhbmdlZCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEBmaWxlIHRvLXRpdGxlLWNhc2UuanNcbiAqIEBtb2R1bGUgdG8tdGl0bGUtY2FzZVxuICovXG5cbi8qKlxuICogVXBwZXJjYXNlIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogICAgICAgIFN0cmluZyB0byBiZSB1cHBlcmNhc2VkXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgc3RyaW5nIHdpdGggYW4gdXBwZXJjYXNlZCBmaXJzdCBsZXR0ZXJcbiAqL1xuZnVuY3Rpb24gdG9UaXRsZUNhc2Uoc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHRoZSBUaXRsZUNhc2UgdmVyc2lvbnMgb2YgdGhlIHR3byBzdHJpbmdzIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyMVxuICogICAgICAgIFRoZSBmaXJzdCBzdHJpbmcgdG8gY29tcGFyZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIyXG4gKiAgICAgICAgVGhlIHNlY29uZCBzdHJpbmcgdG8gY29tcGFyZVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgdGhlIFRpdGxlQ2FzZSB2ZXJzaW9ucyBvZiB0aGUgc3RyaW5ncyBhcmUgZXF1YWxcbiAqL1xuZnVuY3Rpb24gdGl0bGVDYXNlRXF1YWxzKHN0cjEsIHN0cjIpIHtcbiAgcmV0dXJuIHRvVGl0bGVDYXNlKHN0cjEpID09PSB0b1RpdGxlQ2FzZShzdHIyKTtcbn1cblxuLyoqXG4gKiBAZmlsZSBtZXJnZS1vcHRpb25zLmpzXG4gKiBAbW9kdWxlIG1lcmdlLW9wdGlvbnNcbiAqL1xuLyoqXG4gKiBEZWVwLW1lcmdlIG9uZSBvciBtb3JlIG9wdGlvbnMgb2JqZWN0cywgcmVjdXJzaXZlbHkgbWVyZ2luZyAqKm9ubHkqKiBwbGFpblxuICogb2JqZWN0IHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtICAge09iamVjdFtdfSBzb3VyY2VzXG4gKiAgICAgICAgICBPbmUgb3IgbW9yZSBvYmplY3RzIHRvIG1lcmdlIGludG8gYSBuZXcgb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiAgICAgICAgICBBIG5ldyBvYmplY3QgdGhhdCBpcyB0aGUgbWVyZ2VkIHJlc3VsdCBvZiBhbGwgc291cmNlcy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKCkge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzb3VyY2VzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVhY2goc291cmNlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgaWYgKCFpc1BsYWluKHZhbHVlKSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNQbGFpbihyZXN1bHRba2V5XSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZU9wdGlvbnMocmVzdWx0W2tleV0sIHZhbHVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBQbGF5ZXIgQ29tcG9uZW50IC0gQmFzZSBjbGFzcyBmb3IgYWxsIFVJIG9iamVjdHNcbiAqXG4gKiBAZmlsZSBjb21wb25lbnQuanNcbiAqL1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgVUkgQ29tcG9uZW50cy5cbiAqIENvbXBvbmVudHMgYXJlIFVJIG9iamVjdHMgd2hpY2ggcmVwcmVzZW50IGJvdGggYSBqYXZhc2NyaXB0IG9iamVjdCBhbmQgYW4gZWxlbWVudFxuICogaW4gdGhlIERPTS4gVGhleSBjYW4gYmUgY2hpbGRyZW4gb2Ygb3RoZXIgY29tcG9uZW50cywgYW5kIGNhbiBoYXZlXG4gKiBjaGlsZHJlbiB0aGVtc2VsdmVzLlxuICpcbiAqIENvbXBvbmVudHMgY2FuIGFsc28gdXNlIG1ldGhvZHMgZnJvbSB7QGxpbmsgRXZlbnRUYXJnZXR9XG4gKi9cblxudmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlYWR5LiBEb2VzIG5vdCBoYXZlIGFueVxuICAgKiBwYXJhbXRlcnMgYW5kIGFueSBjYWxsYmFjayB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQuXG4gICAqXG4gICAqIEBjYWxsYmFjayBDb21wb25lbnR+UmVhZHlDYWxsYmFja1xuICAgKiBAdGhpcyBDb21wb25lbnRcbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IFtvcHRpb25zLmNoaWxkcmVuXVxuICAgKiAgICAgICAgQW4gYXJyYXkgb2YgY2hpbGRyZW4gb2JqZWN0cyB0byBpbnRpYWxpemUgdGhpcyBjb21wb25lbnQgd2l0aC4gQ2hpbGRyZW4gb2JqZWN0cyBoYXZlXG4gICAqICAgICAgICBhIG5hbWUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIHVzZWQgaWYgbW9yZSB0aGFuIG9uZSBjb21wb25lbnQgb2YgdGhlIHNhbWUgdHlwZSBuZWVkcyB0byBiZVxuICAgKiAgICAgICAgYWRkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIEZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgYENvbXBvbmVudGAgaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBDb21wb25lbnQocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbXBvbmVudCk7XG5cblxuICAgIC8vIFRoZSBjb21wb25lbnQgbWlnaHQgYmUgdGhlIHBsYXllciBpdHNlbGYgYW5kIHdlIGNhbid0IHBhc3MgYHRoaXNgIHRvIHN1cGVyXG4gICAgaWYgKCFwbGF5ZXIgJiYgdGhpcy5wbGF5KSB7XG4gICAgICB0aGlzLnBsYXllcl8gPSBwbGF5ZXIgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXyA9IHBsYXllcjtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGEgY29weSBvZiBwcm90b3R5cGUub3B0aW9uc18gdG8gcHJvdGVjdCBhZ2FpbnN0IG92ZXJyaWRpbmcgZGVmYXVsdHNcbiAgICB0aGlzLm9wdGlvbnNfID0gbWVyZ2VPcHRpb25zKHt9LCB0aGlzLm9wdGlvbnNfKTtcblxuICAgIC8vIFVwZGF0ZWQgb3B0aW9ucyB3aXRoIHN1cHBsaWVkIG9wdGlvbnNcbiAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zXyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnNfLCBvcHRpb25zKTtcblxuICAgIC8vIEdldCBJRCBmcm9tIG9wdGlvbnMgb3Igb3B0aW9ucyBlbGVtZW50IGlmIG9uZSBpcyBzdXBwbGllZFxuICAgIHRoaXMuaWRfID0gb3B0aW9ucy5pZCB8fCBvcHRpb25zLmVsICYmIG9wdGlvbnMuZWwuaWQ7XG5cbiAgICAvLyBJZiB0aGVyZSB3YXMgbm8gSUQgZnJvbSB0aGUgb3B0aW9ucywgZ2VuZXJhdGUgb25lXG4gICAgaWYgKCF0aGlzLmlkXykge1xuICAgICAgLy8gRG9uJ3QgcmVxdWlyZSB0aGUgcGxheWVyIElEIGZ1bmN0aW9uIGluIHRoZSBjYXNlIG9mIG1vY2sgcGxheWVyc1xuICAgICAgdmFyIGlkID0gcGxheWVyICYmIHBsYXllci5pZCAmJiBwbGF5ZXIuaWQoKSB8fCAnbm9fcGxheWVyJztcblxuICAgICAgdGhpcy5pZF8gPSBpZCArICdfY29tcG9uZW50XycgKyBuZXdHVUlEKCk7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lXyA9IG9wdGlvbnMubmFtZSB8fCBudWxsO1xuXG4gICAgLy8gQ3JlYXRlIGVsZW1lbnQgaWYgb25lIHdhc24ndCBwcm92aWRlZCBpbiBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMuZWwpIHtcbiAgICAgIHRoaXMuZWxfID0gb3B0aW9ucy5lbDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuY3JlYXRlRWwgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmVsXyA9IHRoaXMuY3JlYXRlRWwoKTtcbiAgICB9XG5cbiAgICAvLyBpZiBldmVudGVkIGlzIGFueXRoaW5nIGV4Y2VwdCBmYWxzZSwgd2Ugd2FudCB0byBtaXhpbiBpbiBldmVudGVkXG4gICAgaWYgKG9wdGlvbnMuZXZlbnRlZCAhPT0gZmFsc2UpIHtcbiAgICAgIC8vIE1ha2UgdGhpcyBhbiBldmVudGVkIG9iamVjdCBhbmQgdXNlIGBlbF9gLCBpZiBhdmFpbGFibGUsIGFzIGl0cyBldmVudCBidXNcbiAgICAgIGV2ZW50ZWQodGhpcywgeyBldmVudEJ1c0tleTogdGhpcy5lbF8gPyAnZWxfJyA6IG51bGwgfSk7XG4gICAgfVxuICAgIHN0YXRlZnVsKHRoaXMsIHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdFN0YXRlKTtcblxuICAgIHRoaXMuY2hpbGRyZW5fID0gW107XG4gICAgdGhpcy5jaGlsZEluZGV4XyA9IHt9O1xuICAgIHRoaXMuY2hpbGROYW1lSW5kZXhfID0ge307XG5cbiAgICAvLyBBZGQgYW55IGNoaWxkIGNvbXBvbmVudHMgaW4gb3B0aW9uc1xuICAgIGlmIChvcHRpb25zLmluaXRDaGlsZHJlbiAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuaW5pdENoaWxkcmVuKCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWFkeShyZWFkeSk7XG4gICAgLy8gRG9uJ3Qgd2FudCB0byB0cmlnZ2VyIHJlYWR5IGhlcmUgb3IgaXQgd2lsbCBiZWZvcmUgaW5pdCBpcyBhY3R1YWxseVxuICAgIC8vIGZpbmlzaGVkIGZvciBhbGwgY2hpbGRyZW4gdGhhdCBydW4gdGhpcyBjb25zdHJ1Y3RvclxuXG4gICAgaWYgKG9wdGlvbnMucmVwb3J0VG91Y2hBY3Rpdml0eSAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZW5hYmxlVG91Y2hBY3Rpdml0eSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIG9mIHRoZSBgQ29tcG9uZW50YCBhbmQgYWxsIGNoaWxkIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBmaXJlcyBDb21wb25lbnQjZGlzcG9zZVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGBDb21wb25lbnRgIGlzIGRpc3Bvc2VkLlxuICAgICAqXG4gICAgICogQGV2ZW50IENvbXBvbmVudCNkaXNwb3NlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYnViYmxlcz1mYWxzZV1cbiAgICAgKiAgICAgICAgICAgc2V0IHRvIGZhbHNlIHNvIHRoYXQgdGhlIGNsb3NlIGV2ZW50IGRvZXMgbm90XG4gICAgICogICAgICAgICAgIGJ1YmJsZSB1cFxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICdkaXNwb3NlJywgYnViYmxlczogZmFsc2UgfSk7XG5cbiAgICAvLyBEaXNwb3NlIGFsbCBjaGlsZHJlbi5cbiAgICBpZiAodGhpcy5jaGlsZHJlbl8pIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNoaWxkcmVuXy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl9baV0uZGlzcG9zZSkge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW5fW2ldLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlbGV0ZSBjaGlsZCByZWZlcmVuY2VzXG4gICAgdGhpcy5jaGlsZHJlbl8gPSBudWxsO1xuICAgIHRoaXMuY2hpbGRJbmRleF8gPSBudWxsO1xuICAgIHRoaXMuY2hpbGROYW1lSW5kZXhfID0gbnVsbDtcblxuICAgIGlmICh0aGlzLmVsXykge1xuICAgICAgLy8gUmVtb3ZlIGVsZW1lbnQgZnJvbSBET01cbiAgICAgIGlmICh0aGlzLmVsXy5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuZWxfLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbF8pO1xuICAgICAgfVxuXG4gICAgICByZW1vdmVEYXRhKHRoaXMuZWxfKTtcbiAgICAgIHRoaXMuZWxfID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIHRoZSBwbGF5ZXIgYWZ0ZXIgZGlzcG9zaW5nIG9mIHRoZSBlbGVtZW50XG4gICAgdGhpcy5wbGF5ZXJfID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB7QGxpbmsgUGxheWVyfSB0aGF0IHRoZSBgQ29tcG9uZW50YCBoYXMgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEByZXR1cm4ge1BsYXllcn1cbiAgICogICAgICAgICBUaGUgcGxheWVyIHRoYXQgdGhpcyBgQ29tcG9uZW50YCBoYXMgYXR0YWNoZWQgdG8uXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5wbGF5ZXIgPSBmdW5jdGlvbiBwbGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyXztcbiAgfTtcblxuICAvKipcbiAgICogRGVlcCBtZXJnZSBvZiBvcHRpb25zIG9iamVjdHMgd2l0aCBuZXcgb3B0aW9ucy5cbiAgICogPiBOb3RlOiBXaGVuIGJvdGggYG9iamAgYW5kIGBvcHRpb25zYCBjb250YWluIHByb3BlcnRpZXMgd2hvc2UgdmFsdWVzIGFyZSBvYmplY3RzLlxuICAgKiAgICAgICAgIFRoZSB0d28gcHJvcGVydGllcyBnZXQgbWVyZ2VkIHVzaW5nIHtAbGluayBtb2R1bGU6bWVyZ2VPcHRpb25zfVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqICAgICAgICBUaGUgb2JqZWN0IHRoYXQgY29udGFpbnMgbmV3IG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBBIG5ldyBvYmplY3Qgb2YgYHRoaXMub3B0aW9uc19gIGFuZCBgb2JqYCBtZXJnZWQgdG9nZXRoZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUub3B0aW9ucyA9IGZ1bmN0aW9uIG9wdGlvbnMob2JqKSB7XG4gICAgbG9nJDEud2FybigndGhpcy5vcHRpb25zKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSBtb3ZlZCB0byB0aGUgY29uc3RydWN0b3IgaW4gNi4wJyk7XG5cbiAgICBpZiAoIW9iaikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc187XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zXyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnNfLCBvYmopO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGBDb21wb25lbnRgcyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBET00gZWxlbWVudCBmb3IgdGhpcyBgQ29tcG9uZW50YC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmVsID0gZnVuY3Rpb24gZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0YWdOYW1lXVxuICAgKiAgICAgICAgRWxlbWVudCdzIERPTSBub2RlIHR5cGUuIGUuZy4gJ2RpdidcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBzZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKHRhZ05hbWUsIHByb3BlcnRpZXMsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gY3JlYXRlRWwodGFnTmFtZSwgcHJvcGVydGllcywgYXR0cmlidXRlcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvY2FsaXplIGEgc3RyaW5nIGdpdmVuIHRoZSBzdHJpbmcgaW4gZW5nbGlzaC5cbiAgICpcbiAgICogSWYgdG9rZW5zIGFyZSBwcm92aWRlZCwgaXQnbGwgdHJ5IGFuZCBydW4gYSBzaW1wbGUgdG9rZW4gcmVwbGFjZW1lbnQgb24gdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICogVGhlIHRva2VucyBpdCBsb29va3MgZm9yIGxvb2sgbGlrZSBgezF9YCB3aXRoIHRoZSBpbmRleCBiZWluZyAxLWluZGV4ZWQgaW50byB0aGUgdG9rZW5zIGFycmF5LlxuICAgKlxuICAgKiBJZiBhIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBpdCdsbCB1c2UgdGhhdCBvdmVyIGBzdHJpbmdgLFxuICAgKiBpZiBhIHZhbHVlIGlzbid0IGZvdW5kIGluIHByb3ZpZGVkIGxhbmd1YWdlIGZpbGVzLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBoYXZlIGEgZGVzY3JpcHRpdmUga2V5IGZvciB0b2tlbiByZXBsYWNlbWVudFxuICAgKiBidXQgaGF2ZSBhIHN1Y2NpbmN0IGxvY2FsaXplZCBzdHJpbmcgYW5kIG5vdCByZXF1aXJlIGBlbi5qc29uYCB0byBiZSBpbmNsdWRlZC5cbiAgICpcbiAgICogQ3VycmVudGx5LCBpdCBpcyB1c2VkIGZvciB0aGUgcHJvZ3Jlc3MgYmFyIHRpbWluZy5cbiAgICogYGBganNcbiAgICoge1xuICAgKiAgIFwicHJvZ3Jlc3MgYmFyIHRpbWluZzogY3VycmVudFRpbWU9ezF9IGR1cmF0aW9uPXsyfVwiOiBcInsxfSBvZiB7Mn1cIlxuICAgKiB9XG4gICAqIGBgYFxuICAgKiBJdCBpcyB0aGVuIHVzZWQgbGlrZSBzbzpcbiAgICogYGBganNcbiAgICogdGhpcy5sb2NhbGl6ZSgncHJvZ3Jlc3MgYmFyIHRpbWluZzogY3VycmVudFRpbWU9ezF9IGR1cmF0aW9uezJ9JyxcbiAgICogICAgICAgICAgICAgICBbdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCksIHRoaXMucGxheWVyXy5kdXJhdGlvbigpXSxcbiAgICogICAgICAgICAgICAgICAnezF9IG9mIHsyfScpO1xuICAgKiBgYGBcbiAgICpcbiAgICogV2hpY2ggb3V0cHV0cyBzb21ldGhpbmcgbGlrZTogYDAxOjIzIG9mIDI0OjU2YC5cbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKiAgICAgICAgVGhlIHN0cmluZyB0byBsb2NhbGl6ZSBhbmQgdGhlIGtleSB0byBsb29rdXAgaW4gdGhlIGxhbmd1YWdlIGZpbGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbdG9rZW5zXVxuICAgKiAgICAgICAgSWYgdGhlIGN1cnJlbnQgaXRlbSBoYXMgdG9rZW4gcmVwbGFjZW1lbnRzLCBwcm92aWRlIHRoZSB0b2tlbnMgaGVyZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0VmFsdWVdXG4gICAqICAgICAgICBEZWZhdWx0cyB0byBgc3RyaW5nYC4gQ2FuIGJlIGEgZGVmYXVsdCB2YWx1ZSB0byB1c2UgZm9yIHRva2VuIHJlcGxhY2VtZW50XG4gICAqICAgICAgICBpZiB0aGUgbG9va3VwIGtleSBpcyBuZWVkZWQgdG8gYmUgc2VwYXJhdGUuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgbG9jYWxpemVkIHN0cmluZyBvciBpZiBubyBsb2NhbGl6YXRpb24gZXhpc3RzIHRoZSBlbmdsaXNoIHN0cmluZy5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmxvY2FsaXplID0gZnVuY3Rpb24gbG9jYWxpemUoc3RyaW5nLCB0b2tlbnMpIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBzdHJpbmc7XG5cbiAgICB2YXIgY29kZSA9IHRoaXMucGxheWVyXy5sYW5ndWFnZSAmJiB0aGlzLnBsYXllcl8ubGFuZ3VhZ2UoKTtcbiAgICB2YXIgbGFuZ3VhZ2VzID0gdGhpcy5wbGF5ZXJfLmxhbmd1YWdlcyAmJiB0aGlzLnBsYXllcl8ubGFuZ3VhZ2VzKCk7XG4gICAgdmFyIGxhbmd1YWdlID0gbGFuZ3VhZ2VzICYmIGxhbmd1YWdlc1tjb2RlXTtcbiAgICB2YXIgcHJpbWFyeUNvZGUgPSBjb2RlICYmIGNvZGUuc3BsaXQoJy0nKVswXTtcbiAgICB2YXIgcHJpbWFyeUxhbmcgPSBsYW5ndWFnZXMgJiYgbGFuZ3VhZ2VzW3ByaW1hcnlDb2RlXTtcblxuICAgIHZhciBsb2NhbGl6ZWRTdHJpbmcgPSBkZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAobGFuZ3VhZ2UgJiYgbGFuZ3VhZ2Vbc3RyaW5nXSkge1xuICAgICAgbG9jYWxpemVkU3RyaW5nID0gbGFuZ3VhZ2Vbc3RyaW5nXTtcbiAgICB9IGVsc2UgaWYgKHByaW1hcnlMYW5nICYmIHByaW1hcnlMYW5nW3N0cmluZ10pIHtcbiAgICAgIGxvY2FsaXplZFN0cmluZyA9IHByaW1hcnlMYW5nW3N0cmluZ107XG4gICAgfVxuXG4gICAgaWYgKHRva2Vucykge1xuICAgICAgbG9jYWxpemVkU3RyaW5nID0gbG9jYWxpemVkU3RyaW5nLnJlcGxhY2UoL1xceyhcXGQrKVxcfS9nLCBmdW5jdGlvbiAobWF0Y2gsIGluZGV4KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRva2Vuc1tpbmRleCAtIDFdO1xuICAgICAgICB2YXIgcmV0ID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXQgPSBtYXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYWxpemVkU3RyaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGBDb21wb25lbnRgcyBET00gZWxlbWVudC4gVGhpcyBpcyB3aGVyZSBjaGlsZHJlbiBnZXQgaW5zZXJ0ZWQuXG4gICAqIFRoaXMgd2lsbCB1c3VhbGx5IGJlIHRoZSB0aGUgc2FtZSBhcyB0aGUgZWxlbWVudCByZXR1cm5lZCBpbiB7QGxpbmsgQ29tcG9uZW50I2VsfS5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgY29udGVudCBlbGVtZW50IGZvciB0aGlzIGBDb21wb25lbnRgLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY29udGVudEVsID0gZnVuY3Rpb24gY29udGVudEVsKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRFbF8gfHwgdGhpcy5lbF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGlzIGBDb21wb25lbnRgcyBJRFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGlkIG9mIHRoaXMgYENvbXBvbmVudGBcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGBDb21wb25lbnRgcyBuYW1lLiBUaGUgbmFtZSBnZXRzIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSBgQ29tcG9uZW50YFxuICAgKiBhbmQgaXMgc2V0IGR1cmluZyByZWdpc3RyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgbmFtZSBvZiB0aGlzIGBDb21wb25lbnRgLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiBhcnJheSBvZiBhbGwgY2hpbGQgY29tcG9uZW50c1xuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogICAgICAgICBUaGUgY2hpbGRyZW5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24gY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZCBgQ29tcG9uZW50YCB3aXRoIHRoZSBnaXZlbiBgaWRgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICogICAgICAgIFRoZSBpZCBvZiB0aGUgY2hpbGQgYENvbXBvbmVudGAgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIFRoZSBjaGlsZCBgQ29tcG9uZW50YCB3aXRoIHRoZSBnaXZlbiBgaWRgIG9yIHVuZGVmaW5lZC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmdldENoaWxkQnlJZCA9IGZ1bmN0aW9uIGdldENoaWxkQnlJZChpZCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkSW5kZXhfW2lkXTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2hpbGQgYENvbXBvbmVudGAgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGNoaWxkIGBDb21wb25lbnRgIHRvIGdldC5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fHVuZGVmaW5lZH1cbiAgICogICAgICAgICBUaGUgY2hpbGQgYENvbXBvbmVudGAgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgIG9yIHVuZGVmaW5lZC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24gZ2V0Q2hpbGQobmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5hbWUgPSB0b1RpdGxlQ2FzZShuYW1lKTtcblxuICAgIHJldHVybiB0aGlzLmNoaWxkTmFtZUluZGV4X1tuYW1lXTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2hpbGQgYENvbXBvbmVudGAgaW5zaWRlIHRoZSBjdXJyZW50IGBDb21wb25lbnRgLlxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xDb21wb25lbnR9IGNoaWxkXG4gICAqICAgICAgICBUaGUgbmFtZSBvciBpbnN0YW5jZSBvZiBhIGNoaWxkIHRvIGFkZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBvcHRpb25zIHRoYXQgd2lsbCBnZXQgcGFzc2VkIHRvIGNoaWxkcmVuIG9mXG4gICAqICAgICAgICB0aGUgY2hpbGQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9dGhpcy5jaGlsZHJlbl8ubGVuZ3RoXVxuICAgKiAgICAgICAgVGhlIGluZGV4IHRvIGF0dGVtcHQgdG8gYWRkIGEgY2hpbGQgaW50by5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiAgICAgICAgIFRoZSBgQ29tcG9uZW50YCB0aGF0IGdldHMgYWRkZWQgYXMgYSBjaGlsZC4gV2hlbiB1c2luZyBhIHN0cmluZyB0aGVcbiAgICogICAgICAgICBgQ29tcG9uZW50YCB3aWxsIGdldCBjcmVhdGVkIGJ5IHRoaXMgcHJvY2Vzcy5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmNoaWxkcmVuXy5sZW5ndGg7XG5cbiAgICB2YXIgY29tcG9uZW50ID0gdm9pZCAwO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gdm9pZCAwO1xuXG4gICAgLy8gSWYgY2hpbGQgaXMgYSBzdHJpbmcsIGNyZWF0ZSBjb21wb25lbnQgd2l0aCBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0b1RpdGxlQ2FzZShjaGlsZCk7XG5cbiAgICAgIHZhciBjb21wb25lbnRDbGFzc05hbWUgPSBvcHRpb25zLmNvbXBvbmVudENsYXNzIHx8IGNvbXBvbmVudE5hbWU7XG5cbiAgICAgIC8vIFNldCBuYW1lIHRocm91Z2ggb3B0aW9uc1xuICAgICAgb3B0aW9ucy5uYW1lID0gY29tcG9uZW50TmFtZTtcblxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IG9iamVjdCAmIGVsZW1lbnQgZm9yIHRoaXMgY29udHJvbHMgc2V0XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIC5wbGF5ZXJfLCB0aGlzIGlzIGEgcGxheWVyXG4gICAgICB2YXIgQ29tcG9uZW50Q2xhc3MgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KGNvbXBvbmVudENsYXNzTmFtZSk7XG5cbiAgICAgIGlmICghQ29tcG9uZW50Q2xhc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wb25lbnQgJyArIGNvbXBvbmVudENsYXNzTmFtZSArICcgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgIH1cblxuICAgICAgLy8gZGF0YSBzdG9yZWQgZGlyZWN0bHkgb24gdGhlIHZpZGVvanMgb2JqZWN0IG1heSBiZVxuICAgICAgLy8gbWlzaWRlbnRpZmllZCBhcyBhIGNvbXBvbmVudCB0byByZXRhaW5cbiAgICAgIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdpdGggNC54LiBjaGVjayB0byBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBjb21wb25lbnQgY2xhc3MgY2FuIGJlIGluc3RhbnRpYXRlZC5cbiAgICAgIGlmICh0eXBlb2YgQ29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnRDbGFzcyh0aGlzLnBsYXllcl8gfHwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIGNoaWxkIGlzIGEgY29tcG9uZW50IGluc3RhbmNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudCA9IGNoaWxkO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRyZW5fLnNwbGljZShpbmRleCwgMCwgY29tcG9uZW50KTtcblxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50LmlkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmNoaWxkSW5kZXhfW2NvbXBvbmVudC5pZCgpXSA9IGNvbXBvbmVudDtcbiAgICB9XG5cbiAgICAvLyBJZiBhIG5hbWUgd2Fzbid0IHVzZWQgdG8gY3JlYXRlIHRoZSBjb21wb25lbnQsIGNoZWNrIGlmIHdlIGNhbiB1c2UgdGhlXG4gICAgLy8gbmFtZSBmdW5jdGlvbiBvZiB0aGUgY29tcG9uZW50XG4gICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgY29tcG9uZW50Lm5hbWUgJiYgdG9UaXRsZUNhc2UoY29tcG9uZW50Lm5hbWUoKSk7XG5cbiAgICBpZiAoY29tcG9uZW50TmFtZSkge1xuICAgICAgdGhpcy5jaGlsZE5hbWVJbmRleF9bY29tcG9uZW50TmFtZV0gPSBjb21wb25lbnQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBVSSBvYmplY3QncyBlbGVtZW50IHRvIHRoZSBjb250YWluZXIgZGl2IChib3gpXG4gICAgLy8gSGF2aW5nIGFuIGVsZW1lbnQgaXMgbm90IHJlcXVpcmVkXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQuZWwgPT09ICdmdW5jdGlvbicgJiYgY29tcG9uZW50LmVsKCkpIHtcbiAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpcy5jb250ZW50RWwoKS5jaGlsZHJlbjtcbiAgICAgIHZhciByZWZOb2RlID0gY2hpbGROb2Rlc1tpbmRleF0gfHwgbnVsbDtcblxuICAgICAgdGhpcy5jb250ZW50RWwoKS5pbnNlcnRCZWZvcmUoY29tcG9uZW50LmVsKCksIHJlZk5vZGUpO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBzbyBpdCBjYW4gc3RvcmVkIG9uIHBhcmVudCBvYmplY3QgaWYgZGVzaXJlZC5cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjaGlsZCBgQ29tcG9uZW50YCBmcm9tIHRoaXMgYENvbXBvbmVudGBzIGxpc3Qgb2YgY2hpbGRyZW4uIEFsc28gcmVtb3Zlc1xuICAgKiB0aGUgY2hpbGQgYENvbXBvbmVudGBzIGVsZW1lbnQgZnJvbSB0aGlzIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gY29tcG9uZW50XG4gICAqICAgICAgICBUaGUgY2hpbGQgYENvbXBvbmVudGAgdG8gcmVtb3ZlLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZChjb21wb25lbnQpIHtcbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbXBvbmVudCA9IHRoaXMuZ2V0Q2hpbGQoY29tcG9uZW50KTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbXBvbmVudCB8fCAhdGhpcy5jaGlsZHJlbl8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRGb3VuZCA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IHRoaXMuY2hpbGRyZW5fLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbl9baV0gPT09IGNvbXBvbmVudCkge1xuICAgICAgICBjaGlsZEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbl8uc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkRm91bmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNoaWxkSW5kZXhfW2NvbXBvbmVudC5pZCgpXSA9IG51bGw7XG4gICAgdGhpcy5jaGlsZE5hbWVJbmRleF9bY29tcG9uZW50Lm5hbWUoKV0gPSBudWxsO1xuXG4gICAgdmFyIGNvbXBFbCA9IGNvbXBvbmVudC5lbCgpO1xuXG4gICAgaWYgKGNvbXBFbCAmJiBjb21wRWwucGFyZW50Tm9kZSA9PT0gdGhpcy5jb250ZW50RWwoKSkge1xuICAgICAgdGhpcy5jb250ZW50RWwoKS5yZW1vdmVDaGlsZChjb21wb25lbnQuZWwoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYW5kIGluaXRpYWxpemUgZGVmYXVsdCBjaGlsZCBgQ29tcG9uZW50YHMgYmFzZWQgdXBvbiBvcHRpb25zLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaW5pdENoaWxkcmVuID0gZnVuY3Rpb24gaW5pdENoaWxkcmVuKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLm9wdGlvbnNfLmNoaWxkcmVuO1xuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAvLyBgdGhpc2AgaXMgYHBhcmVudGBcbiAgICAgIHZhciBwYXJlbnRPcHRpb25zID0gdGhpcy5vcHRpb25zXztcblxuICAgICAgdmFyIGhhbmRsZUFkZCA9IGZ1bmN0aW9uIGhhbmRsZUFkZChjaGlsZCkge1xuICAgICAgICB2YXIgbmFtZSA9IGNoaWxkLm5hbWU7XG4gICAgICAgIHZhciBvcHRzID0gY2hpbGQub3B0cztcblxuICAgICAgICAvLyBBbGxvdyBvcHRpb25zIGZvciBjaGlsZHJlbiB0byBiZSBzZXQgYXQgdGhlIHBhcmVudCBvcHRpb25zXG4gICAgICAgIC8vIGUuZy4gdmlkZW9qcyhpZCwgeyBjb250cm9sQmFyOiBmYWxzZSB9KTtcbiAgICAgICAgLy8gaW5zdGVhZCBvZiB2aWRlb2pzKGlkLCB7IGNoaWxkcmVuOiB7IGNvbnRyb2xCYXI6IGZhbHNlIH0pO1xuICAgICAgICBpZiAocGFyZW50T3B0aW9uc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0cyA9IHBhcmVudE9wdGlvbnNbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGxvdyBmb3IgZGlzYWJsaW5nIGRlZmF1bHQgY29tcG9uZW50c1xuICAgICAgICAvLyBlLmcuIG9wdGlvbnNbJ2NoaWxkcmVuJ11bJ3Bvc3RlckltYWdlJ10gPSBmYWxzZVxuICAgICAgICBpZiAob3B0cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGxvdyBvcHRpb25zIHRvIGJlIHBhc3NlZCBhcyBhIHNpbXBsZSBib29sZWFuIGlmIG5vIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgLy8gaXMgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAob3B0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGFsc28gd2FudCB0byBwYXNzIHRoZSBvcmlnaW5hbCBwbGF5ZXIgb3B0aW9uc1xuICAgICAgICAvLyB0byBlYWNoIGNvbXBvbmVudCBhcyB3ZWxsIHNvIHRoZXkgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAvLyByZWFjaCBiYWNrIGludG8gdGhlIHBsYXllciBmb3Igb3B0aW9ucyBsYXRlci5cbiAgICAgICAgb3B0cy5wbGF5ZXJPcHRpb25zID0gX3RoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucztcblxuICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCB0aGUgY2hpbGQgY29tcG9uZW50LlxuICAgICAgICAvLyBBZGQgYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBjaGlsZCBieSBuYW1lIG9uIHRoZSBwYXJlbnQgaW5zdGFuY2UuXG4gICAgICAgIC8vIElmIHR3byBvZiB0aGUgc2FtZSBjb21wb25lbnQgYXJlIHVzZWQsIGRpZmZlcmVudCBuYW1lcyBzaG91bGQgYmUgc3VwcGxpZWRcbiAgICAgICAgLy8gZm9yIGVhY2hcbiAgICAgICAgdmFyIG5ld0NoaWxkID0gX3RoaXMuYWRkQ2hpbGQobmFtZSwgb3B0cyk7XG5cbiAgICAgICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICAgICAgX3RoaXNbbmFtZV0gPSBuZXdDaGlsZDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gQWxsb3cgZm9yIGFuIGFycmF5IG9mIGNoaWxkcmVuIGRldGFpbHMgdG8gcGFzc2VkIGluIHRoZSBvcHRpb25zXG4gICAgICB2YXIgd29ya2luZ0NoaWxkcmVuID0gdm9pZCAwO1xuICAgICAgdmFyIFRlY2ggPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KCdUZWNoJyk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICB3b3JraW5nQ2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmtpbmdDaGlsZHJlbiA9IE9iamVjdC5rZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cblxuICAgICAgd29ya2luZ0NoaWxkcmVuXG4gICAgICAvLyBjaGlsZHJlbiB0aGF0IGFyZSBpbiB0aGlzLm9wdGlvbnNfIGJ1dCBhbHNvIGluIHdvcmtpbmdDaGlsZHJlbiAgd291bGRcbiAgICAgIC8vIGdpdmUgdXMgZXh0cmEgY2hpbGRyZW4gd2UgZG8gbm90IHdhbnQuIFNvLCB3ZSB3YW50IHRvIGZpbHRlciB0aGVtIG91dC5cbiAgICAgIC5jb25jYXQoT2JqZWN0LmtleXModGhpcy5vcHRpb25zXykuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gIXdvcmtpbmdDaGlsZHJlbi5zb21lKGZ1bmN0aW9uICh3Y2hpbGQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gd2NoaWxkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2hpbGQgPT09IHdjaGlsZC5uYW1lO1xuICAgICAgICB9KTtcbiAgICAgIH0pKS5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZhciBuYW1lID0gdm9pZCAwO1xuICAgICAgICB2YXIgb3B0cyA9IHZvaWQgMDtcblxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG5hbWUgPSBjaGlsZDtcbiAgICAgICAgICBvcHRzID0gY2hpbGRyZW5bbmFtZV0gfHwgX3RoaXMub3B0aW9uc19bbmFtZV0gfHwge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IGNoaWxkLm5hbWU7XG4gICAgICAgICAgb3B0cyA9IGNoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgb3B0czogb3B0cyB9O1xuICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAvLyB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IGNoaWxkLm5hbWUgaXNuJ3QgaW4gdGhlIHRlY2hPcmRlciBzaW5jZVxuICAgICAgICAvLyB0ZWNocyBhcmUgcmVnaXN0ZXJkIGFzIENvbXBvbmVudHMgYnV0IGNhbid0IGFyZW4ndCBjb21wYXRpYmxlXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvMjc3MlxuICAgICAgICB2YXIgYyA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoY2hpbGQub3B0cy5jb21wb25lbnRDbGFzcyB8fCB0b1RpdGxlQ2FzZShjaGlsZC5uYW1lKSk7XG5cbiAgICAgICAgcmV0dXJuIGMgJiYgIVRlY2guaXNUZWNoKGMpO1xuICAgICAgfSkuZm9yRWFjaChoYW5kbGVBZGQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBjbGFzcyBuYW1lLiBTaG91bGQgYmUgb3ZlcnJpZGVuIGJ5IHN1Yi1jb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBjbGFzcyBuYW1lIGZvciB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICAvLyBDaGlsZCBjbGFzc2VzIGNhbiBpbmNsdWRlIGEgZnVuY3Rpb24gdGhhdCBkb2VzOlxuICAgIC8vIHJldHVybiAnQ0xBU1MgTkFNRScgKyB0aGlzLl9zdXBlcigpO1xuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogQmluZCBhIGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByZWFkeSBzdGF0ZS5cbiAgICogRGlmZmVyZW50IGZyb20gZXZlbnQgbGlzdGVuZXJzIGluIHRoYXQgaWYgdGhlIHJlYWR5IGV2ZW50IGhhcyBhbHJlYWR5IGhhcHBlbmVkXG4gICAqIGl0IHdpbGwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gaW1tZWRpYXRlbHkuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogICAgICAgICBSZXR1cm5zIGl0c2VsZjsgbWV0aG9kIGNhbiBiZSBjaGFpbmVkLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiByZWFkeShmbikge1xuICAgIHZhciBzeW5jID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIGlmICghZm4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNSZWFkeV8pIHtcbiAgICAgIHRoaXMucmVhZHlRdWV1ZV8gPSB0aGlzLnJlYWR5UXVldWVfIHx8IFtdO1xuICAgICAgdGhpcy5yZWFkeVF1ZXVlXy5wdXNoKGZuKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgZm4uY2FsbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FsbCB0aGUgZnVuY3Rpb24gYXN5bmNocm9ub3VzbHkgYnkgZGVmYXVsdCBmb3IgY29uc2lzdGVuY3lcbiAgICAgIHRoaXMuc2V0VGltZW91dChmbiwgMSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFsbCB0aGUgcmVhZHkgbGlzdGVuZXJzIGZvciB0aGlzIGBDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmlyZXMgQ29tcG9uZW50I3JlYWR5XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyUmVhZHkgPSBmdW5jdGlvbiB0cmlnZ2VyUmVhZHkoKSB7XG4gICAgdGhpcy5pc1JlYWR5XyA9IHRydWU7XG5cbiAgICAvLyBFbnN1cmUgcmVhZHkgaXMgdHJpZ2dlcmQgYXN5bmNocm9ub3VzbHlcbiAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlYWR5UXVldWUgPSB0aGlzLnJlYWR5UXVldWVfO1xuXG4gICAgICAvLyBSZXNldCBSZWFkeSBRdWV1ZVxuICAgICAgdGhpcy5yZWFkeVF1ZXVlXyA9IFtdO1xuXG4gICAgICBpZiAocmVhZHlRdWV1ZSAmJiByZWFkeVF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVhZHlRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIGZuLmNhbGwodGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyBmb3IgdXNpbmcgZXZlbnQgbGlzdGVuZXJzIGFsc29cbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlcmVkIHdoZW4gYSBgQ29tcG9uZW50YCBpcyByZWFkeS5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgQ29tcG9uZW50I3JlYWR5XG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcigncmVhZHknKTtcbiAgICB9LCAxKTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCBhIHNpbmdsZSBET00gZWxlbWVudCBtYXRjaGluZyBhIGBzZWxlY3RvcmAuIFRoaXMgY2FuIGJlIHdpdGhpbiB0aGUgYENvbXBvbmVudGBzXG4gICAqIGBjb250ZW50RWwoKWAgb3IgYW5vdGhlciBjdXN0b20gY29udGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqICAgICAgICBBIHZhbGlkIENTUyBzZWxlY3Rvciwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYHF1ZXJ5U2VsZWN0b3JgLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBbY29udGV4dD10aGlzLmNvbnRlbnRFbCgpXVxuICAgKiAgICAgICAgQSBET00gZWxlbWVudCB3aXRoaW4gd2hpY2ggdG8gcXVlcnkuIENhbiBhbHNvIGJlIGEgc2VsZWN0b3Igc3RyaW5nIGluXG4gICAqICAgICAgICB3aGljaCBjYXNlIHRoZSBmaXJzdCBtYXRjaGluZyBlbGVtZW50IHdpbGwgZ2V0IHVzZWQgYXMgY29udGV4dC4gSWZcbiAgICogICAgICAgIG1pc3NpbmcgYHRoaXMuY29udGVudEVsKClgIGdldHMgdXNlZC4gSWYgIGB0aGlzLmNvbnRlbnRFbCgpYCByZXR1cm5zXG4gICAqICAgICAgICBub3RoaW5nIGl0IGZhbGxzIGJhY2sgdG8gYGRvY3VtZW50YC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudHxudWxsfVxuICAgKiAgICAgICAgIHRoZSBkb20gZWxlbWVudCB0aGF0IHdhcyBmb3VuZCwgb3IgbnVsbFxuICAgKlxuICAgKiBAc2VlIFtJbmZvcm1hdGlvbiBvbiBDU1MgU2VsZWN0b3JzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9DU1MvR2V0dGluZ19TdGFydGVkL1NlbGVjdG9ycylcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLiQgPSBmdW5jdGlvbiAkJCQxKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuICQoc2VsZWN0b3IsIGNvbnRleHQgfHwgdGhpcy5jb250ZW50RWwoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBET00gZWxlbWVudCBtYXRjaGluZyBhIGBzZWxlY3RvcmAuIFRoaXMgY2FuIGJlIHdpdGhpbiB0aGUgYENvbXBvbmVudGBzXG4gICAqIGBjb250ZW50RWwoKWAgb3IgYW5vdGhlciBjdXN0b20gY29udGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqICAgICAgICBBIHZhbGlkIENTUyBzZWxlY3Rvciwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYHF1ZXJ5U2VsZWN0b3JBbGxgLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBbY29udGV4dD10aGlzLmNvbnRlbnRFbCgpXVxuICAgKiAgICAgICAgQSBET00gZWxlbWVudCB3aXRoaW4gd2hpY2ggdG8gcXVlcnkuIENhbiBhbHNvIGJlIGEgc2VsZWN0b3Igc3RyaW5nIGluXG4gICAqICAgICAgICB3aGljaCBjYXNlIHRoZSBmaXJzdCBtYXRjaGluZyBlbGVtZW50IHdpbGwgZ2V0IHVzZWQgYXMgY29udGV4dC4gSWZcbiAgICogICAgICAgIG1pc3NpbmcgYHRoaXMuY29udGVudEVsKClgIGdldHMgdXNlZC4gSWYgIGB0aGlzLmNvbnRlbnRFbCgpYCByZXR1cm5zXG4gICAqICAgICAgICBub3RoaW5nIGl0IGZhbGxzIGJhY2sgdG8gYGRvY3VtZW50YC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZUxpc3R9XG4gICAqICAgICAgICAgYSBsaXN0IG9mIGRvbSBlbGVtZW50cyB0aGF0IHdlcmUgZm91bmRcbiAgICpcbiAgICogQHNlZSBbSW5mb3JtYXRpb24gb24gQ1NTIFNlbGVjdG9yc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvQ1NTL0dldHRpbmdfU3RhcnRlZC9TZWxlY3RvcnMpXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS4kJCA9IGZ1bmN0aW9uICQkJCQxKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuICQkKHNlbGVjdG9yLCBjb250ZXh0IHx8IHRoaXMuY29udGVudEVsKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGNvbXBvbmVudCdzIGVsZW1lbnQgaGFzIGEgQ1NTIGNsYXNzIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvQ2hlY2tcbiAgICogICAgICAgIENTUyBjbGFzcyBuYW1lIHRvIGNoZWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgYENvbXBvbmVudGAgaGFzIHRoZSBjbGFzcy5cbiAgICogICAgICAgICAtIEZhbHNlIGlmIHRoZSBgQ29tcG9uZW50YCBkb2VzIG5vdCBoYXZlIHRoZSBjbGFzc2BcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmhhc0NsYXNzID0gZnVuY3Rpb24gaGFzQ2xhc3MkJDEoY2xhc3NUb0NoZWNrKSB7XG4gICAgcmV0dXJuIGhhc0NsYXNzKHRoaXMuZWxfLCBjbGFzc1RvQ2hlY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBDU1MgY2xhc3MgbmFtZSB0byB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvQWRkXG4gICAqICAgICAgICBDU1MgY2xhc3MgbmFtZSB0byBhZGRcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3MkJDEoY2xhc3NUb0FkZCkge1xuICAgIGFkZENsYXNzKHRoaXMuZWxfLCBjbGFzc1RvQWRkKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgQ1NTIGNsYXNzIG5hbWUgZnJvbSB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvUmVtb3ZlXG4gICAqICAgICAgICBDU1MgY2xhc3MgbmFtZSB0byByZW1vdmVcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3MkJDEoY2xhc3NUb1JlbW92ZSkge1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxfLCBjbGFzc1RvUmVtb3ZlKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIG9yIHJlbW92ZSBhIENTUyBjbGFzcyBuYW1lIGZyb20gdGhlIGNvbXBvbmVudCdzIGVsZW1lbnQuXG4gICAqIC0gYGNsYXNzVG9Ub2dnbGVgIGdldHMgYWRkZWQgd2hlbiB7QGxpbmsgQ29tcG9uZW50I2hhc0NsYXNzfSB3b3VsZCByZXR1cm4gZmFsc2UuXG4gICAqIC0gYGNsYXNzVG9Ub2dnbGVgIGdldHMgcmVtb3ZlZCB3aGVuIHtAbGluayBDb21wb25lbnQjaGFzQ2xhc3N9IHdvdWxkIHJldHVybiB0cnVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNsYXNzVG9Ub2dnbGVcbiAgICogICAgICAgICBUaGUgY2xhc3MgdG8gYWRkIG9yIHJlbW92ZSBiYXNlZCBvbiAoQGxpbmsgQ29tcG9uZW50I2hhc0NsYXNzfVxuICAgKlxuICAgKiBAcGFyYW0gIHtib29sZWFufERvbX5wcmVkaWNhdGV9IFtwcmVkaWNhdGVdXG4gICAqICAgICAgICAgQW4ge0BsaW5rIERvbX5wcmVkaWNhdGV9IGZ1bmN0aW9uIG9yIGEgYm9vbGVhblxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUudG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiB0b2dnbGVDbGFzcyQkMShjbGFzc1RvVG9nZ2xlLCBwcmVkaWNhdGUpIHtcbiAgICB0b2dnbGVDbGFzcyh0aGlzLmVsXywgY2xhc3NUb1RvZ2dsZSwgcHJlZGljYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2hvdyB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQgaWYgaXQgaXMgaGlkZGVuIGJ5IHJlbW92aW5nIHRoZVxuICAgKiAndmpzLWhpZGRlbicgY2xhc3MgbmFtZSBmcm9tIGl0LlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudCBpZiBpdCBpcyBjdXJyZW50bHkgc2hvd2luZyBieSBhZGRpbmcgdGhlXG4gICAqICd2anMtaGlkZGVuYCBjbGFzcyBuYW1lIHRvIGl0LlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2NrIGEgYENvbXBvbmVudGBzIGVsZW1lbnQgaW4gaXRzIHZpc2libGUgc3RhdGUgYnkgYWRkaW5nIHRoZSAndmpzLWxvY2stc2hvd2luZydcbiAgICogY2xhc3MgbmFtZSB0byBpdC4gVXNlZCBkdXJpbmcgZmFkZUluL2ZhZGVPdXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5sb2NrU2hvd2luZyA9IGZ1bmN0aW9uIGxvY2tTaG93aW5nKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1sb2NrLXNob3dpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5sb2NrIGEgYENvbXBvbmVudGBzIGVsZW1lbnQgZnJvbSBpdHMgdmlzaWJsZSBzdGF0ZSBieSByZW1vdmluZyB0aGUgJ3Zqcy1sb2NrLXNob3dpbmcnXG4gICAqIGNsYXNzIG5hbWUgZnJvbSBpdC4gVXNlZCBkdXJpbmcgZmFkZUluL2ZhZGVPdXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS51bmxvY2tTaG93aW5nID0gZnVuY3Rpb24gdW5sb2NrU2hvd2luZygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtbG9jay1zaG93aW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICAgKiAgICAgICAgTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGdldCB0aGUgdmFsdWUgZnJvbS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gICAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSB0aGF0IHdhcyBhc2tlZCBmb3IuXG4gICAqICAgICAgICAgLSBDYW4gYmUgYW4gZW1wdHkgc3RyaW5nIG9uIHNvbWUgYnJvd3NlcnMgaWYgdGhlIGF0dHJpYnV0ZSBkb2VzIG5vdCBleGlzdFxuICAgKiAgICAgICAgICAgb3IgaGFzIG5vIHZhbHVlXG4gICAqICAgICAgICAgLSBNb3N0IGJyb3dzZXJzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIGF0dGlidXRlIGRvZXMgbm90IGV4aXN0IG9yIGhhc1xuICAgKiAgICAgICAgICAgbm8gdmFsdWUuXG4gICAqXG4gICAqIEBzZWUgW0RPTSBBUElde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEF0dHJpYnV0ZX1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZSQkMShhdHRyaWJ1dGUpIHtcbiAgICByZXR1cm4gZ2V0QXR0cmlidXRlKHRoaXMuZWxfLCBhdHRyaWJ1dGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiB0aGUgYENvbXBvbmVudGAncyBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAgICogICAgICAgIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgVmFsdWUgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgdG8uXG4gICAqXG4gICAqIEBzZWUgW0RPTSBBUElde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L3NldEF0dHJpYnV0ZX1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZSQkMShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgc2V0QXR0cmlidXRlKHRoaXMuZWxfLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICAgKiAgICAgICAgTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHJlbW92ZS5cbiAgICpcbiAgICogQHNlZSBbRE9NIEFQSV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvcmVtb3ZlQXR0cmlidXRlfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlJCQxKGF0dHJpYnV0ZSkge1xuICAgIHJlbW92ZUF0dHJpYnV0ZSh0aGlzLmVsXywgYXR0cmlidXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgd2lkdGggb2YgdGhlIGNvbXBvbmVudCBiYXNlZCB1cG9uIHRoZSBDU1Mgc3R5bGVzLlxuICAgKiBTZWUge0BsaW5rIENvbXBvbmVudCNkaW1lbnNpb259IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtudW1dXG4gICAqICAgICAgICBUaGUgd2lkdGggdGhhdCB5b3Ugd2FudCB0byBzZXQgcG9zdGZpeGVkIHdpdGggJyUnLCAncHgnIG9yIG5vdGhpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBMaXN0ZW5lcnNdXG4gICAqICAgICAgICBTa2lwIHRoZSBjb21wb25lbnRyZXNpemUgZXZlbnQgdHJpZ2dlclxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSB3aWR0aCB3aGVuIGdldHRpbmcsIHplcm8gaWYgdGhlcmUgaXMgbm8gd2lkdGguIENhbiBiZSBhIHN0cmluZ1xuICAgKiAgICAgICAgICAgcG9zdHBpeGVkIHdpdGggJyUnIG9yICdweCcuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uIHdpZHRoKG51bSwgc2tpcExpc3RlbmVycykge1xuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbignd2lkdGgnLCBudW0sIHNraXBMaXN0ZW5lcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBoZWlnaHQgb2YgdGhlIGNvbXBvbmVudCBiYXNlZCB1cG9uIHRoZSBDU1Mgc3R5bGVzLlxuICAgKiBTZWUge0BsaW5rIENvbXBvbmVudCNkaW1lbnNpb259IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtudW1dXG4gICAqICAgICAgICBUaGUgaGVpZ2h0IHRoYXQgeW91IHdhbnQgdG8gc2V0IHBvc3RmaXhlZCB3aXRoICclJywgJ3B4JyBvciBub3RoaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwTGlzdGVuZXJzXVxuICAgKiAgICAgICAgU2tpcCB0aGUgY29tcG9uZW50cmVzaXplIGV2ZW50IHRyaWdnZXJcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfHN0cmluZ31cbiAgICogICAgICAgICBUaGUgd2lkdGggd2hlbiBnZXR0aW5nLCB6ZXJvIGlmIHRoZXJlIGlzIG5vIHdpZHRoLiBDYW4gYmUgYSBzdHJpbmdcbiAgICogICAgICAgICBwb3N0cGl4ZWQgd2l0aCAnJScgb3IgJ3B4Jy5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uIGhlaWdodChudW0sIHNraXBMaXN0ZW5lcnMpIHtcbiAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24oJ2hlaWdodCcsIG51bSwgc2tpcExpc3RlbmVycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBib3RoIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBgQ29tcG9uZW50YCBlbGVtZW50IGF0IHRoZSBzYW1lIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcnxzdHJpbmd9IHdpZHRoXG4gICAqICAgICAgICAgV2lkdGggdG8gc2V0IHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudCB0by5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfHN0cmluZ30gaGVpZ2h0XG4gICAqICAgICAgICAgSGVpZ2h0IHRvIHNldCB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQgdG8uXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5kaW1lbnNpb25zID0gZnVuY3Rpb24gZGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgLy8gU2tpcCBjb21wb25lbnRyZXNpemUgbGlzdGVuZXJzIG9uIHdpZHRoIGZvciBvcHRpbWl6YXRpb25cbiAgICB0aGlzLndpZHRoKHdpZHRoLCB0cnVlKTtcbiAgICB0aGlzLmhlaWdodChoZWlnaHQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHdpZHRoIG9yIGhlaWdodCBvZiB0aGUgYENvbXBvbmVudGAgZWxlbWVudC4gVGhpcyBpcyB0aGUgc2hhcmVkIGNvZGVcbiAgICogZm9yIHRoZSB7QGxpbmsgQ29tcG9uZW50I3dpZHRofSBhbmQge0BsaW5rIENvbXBvbmVudCNoZWlnaHR9LlxuICAgKlxuICAgKiBUaGluZ3MgdG8ga25vdzpcbiAgICogLSBJZiB0aGUgd2lkdGggb3IgaGVpZ2h0IGluIGFuIG51bWJlciB0aGlzIHdpbGwgcmV0dXJuIHRoZSBudW1iZXIgcG9zdGZpeGVkIHdpdGggJ3B4Jy5cbiAgICogLSBJZiB0aGUgd2lkdGgvaGVpZ2h0IGlzIGEgcGVyY2VudCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBwZXJjZW50IHBvc3RmaXhlZCB3aXRoICclJ1xuICAgKiAtIEhpZGRlbiBlbGVtZW50cyBoYXZlIGEgd2lkdGggb2YgMCB3aXRoIGB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZWAuIFRoaXMgZnVuY3Rpb25cbiAgICogICBkZWZhdWx0cyB0byB0aGUgYENvbXBvbmVudGBzIGBzdHlsZS53aWR0aGAgYW5kIGZhbGxzIGJhY2sgdG8gYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cbiAgICogICBTZWUgW3RoaXNde0BsaW5rIGh0dHA6Ly93d3cuZm9saW90ZWsuY29tL2RldmJsb2cvZ2V0dGluZy10aGUtd2lkdGgtb2YtYS1oaWRkZW4tZWxlbWVudC13aXRoLWpxdWVyeS11c2luZy13aWR0aC99XG4gICAqICAgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAgICogLSBJZiB5b3Ugd2FudCB0aGUgY29tcHV0ZWQgc3R5bGUgb2YgdGhlIGNvbXBvbmVudCwgdXNlIHtAbGluayBDb21wb25lbnQjY3VycmVudFdpZHRofVxuICAgKiAgIGFuZCB7QGxpbmsge0NvbXBvbmVudCNjdXJyZW50SGVpZ2h0fVxuICAgKlxuICAgKiBAZmlyZXMgQ29tcG9uZW50I2NvbXBvbmVudHJlc2l6ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gd2lkdGhPckhlaWdodFxuICAgOCAgICAgICAgJ3dpZHRoJyBvciAnaGVpZ2h0J1xuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ8c3RyaW5nfSBbbnVtXVxuICAgOCAgICAgICAgIE5ldyBkaW1lbnNpb25cbiAgICpcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW3NraXBMaXN0ZW5lcnNdXG4gICAqICAgICAgICAgU2tpcCBjb21wb25lbnRyZXNpemUgZXZlbnQgdHJpZ2dlclxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGRpbWVuc2lvbiB3aGVuIGdldHRpbmcgb3IgMCBpZiB1bnNldFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gZGltZW5zaW9uKHdpZHRoT3JIZWlnaHQsIG51bSwgc2tpcExpc3RlbmVycykge1xuICAgIGlmIChudW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gU2V0IHRvIHplcm8gaWYgbnVsbCBvciBsaXRlcmFsbHkgTmFOIChOYU4gIT09IE5hTilcbiAgICAgIGlmIChudW0gPT09IG51bGwgfHwgbnVtICE9PSBudW0pIHtcbiAgICAgICAgbnVtID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdXNpbmcgY3NzIHdpZHRoL2hlaWdodCAoJSBvciBweCkgYW5kIGFkanVzdFxuICAgICAgaWYgKCgnJyArIG51bSkuaW5kZXhPZignJScpICE9PSAtMSB8fCAoJycgKyBudW0pLmluZGV4T2YoJ3B4JykgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdID0gbnVtO1xuICAgICAgfSBlbHNlIGlmIChudW0gPT09ICdhdXRvJykge1xuICAgICAgICB0aGlzLmVsXy5zdHlsZVt3aWR0aE9ySGVpZ2h0XSA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbF8uc3R5bGVbd2lkdGhPckhlaWdodF0gPSBudW0gKyAncHgnO1xuICAgICAgfVxuXG4gICAgICAvLyBza2lwTGlzdGVuZXJzIGFsbG93cyB1cyB0byBhdm9pZCB0cmlnZ2VyaW5nIHRoZSByZXNpemUgZXZlbnQgd2hlbiBzZXR0aW5nIGJvdGggd2lkdGggYW5kIGhlaWdodFxuICAgICAgaWYgKCFza2lwTGlzdGVuZXJzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZXNpemVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgQ29tcG9uZW50I2NvbXBvbmVudHJlc2l6ZVxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NvbXBvbmVudHJlc2l6ZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTm90IHNldHRpbmcgYSB2YWx1ZSwgc28gZ2V0dGluZyBpdFxuICAgIC8vIE1ha2Ugc3VyZSBlbGVtZW50IGV4aXN0c1xuICAgIGlmICghdGhpcy5lbF8pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIEdldCBkaW1lbnNpb24gdmFsdWUgZnJvbSBzdHlsZVxuICAgIHZhciB2YWwgPSB0aGlzLmVsXy5zdHlsZVt3aWR0aE9ySGVpZ2h0XTtcbiAgICB2YXIgcHhJbmRleCA9IHZhbC5pbmRleE9mKCdweCcpO1xuXG4gICAgaWYgKHB4SW5kZXggIT09IC0xKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIHBpeGVsIHZhbHVlIHdpdGggbm8gJ3B4J1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbC5zbGljZSgwLCBweEluZGV4KSwgMTApO1xuICAgIH1cblxuICAgIC8vIE5vIHB4IHNvIHVzaW5nICUgb3Igbm8gc3R5bGUgd2FzIHNldCwgc28gZmFsbGluZyBiYWNrIHRvIG9mZnNldFdpZHRoL2hlaWdodFxuICAgIC8vIElmIGNvbXBvbmVudCBoYXMgZGlzcGxheTpub25lLCBvZmZzZXQgd2lsbCByZXR1cm4gMFxuICAgIC8vIFRPRE86IGhhbmRsZSBkaXNwbGF5Om5vbmUgYW5kIG5vIGRpbWVuc2lvbiBzdHlsZSB1c2luZyBweFxuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmVsX1snb2Zmc2V0JyArIHRvVGl0bGVDYXNlKHdpZHRoT3JIZWlnaHQpXSwgMTApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdpZHRoIG9yIHRoZSBoZWlnaHQgb2YgdGhlIGBDb21wb25lbnRgIGVsZW1lbnRzIGNvbXB1dGVkIHN0eWxlLiBVc2VzXG4gICAqIGB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB3aWR0aE9ySGVpZ2h0XG4gICAqICAgICAgICBBIHN0cmluZyBjb250YWluaW5nICd3aWR0aCcgb3IgJ2hlaWdodCcuIFdoaWNoZXZlciBvbmUgeW91IHdhbnQgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGRpbWVuc2lvbiB0aGF0IGdldHMgYXNrZWQgZm9yIG9yIDAgaWYgbm90aGluZyB3YXMgc2V0XG4gICAqICAgICAgICAgZm9yIHRoYXQgZGltZW5zaW9uLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY3VycmVudERpbWVuc2lvbiA9IGZ1bmN0aW9uIGN1cnJlbnREaW1lbnNpb24od2lkdGhPckhlaWdodCkge1xuICAgIHZhciBjb21wdXRlZFdpZHRoT3JIZWlnaHQgPSAwO1xuXG4gICAgaWYgKHdpZHRoT3JIZWlnaHQgIT09ICd3aWR0aCcgJiYgd2lkdGhPckhlaWdodCAhPT0gJ2hlaWdodCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudERpbWVuc2lvbiBvbmx5IGFjY2VwdHMgd2lkdGggb3IgaGVpZ2h0IHZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsXyk7XG5cbiAgICAgIGNvbXB1dGVkV2lkdGhPckhlaWdodCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSh3aWR0aE9ySGVpZ2h0KSB8fCBjb21wdXRlZFN0eWxlW3dpZHRoT3JIZWlnaHRdO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSAncHgnIGZyb20gdmFyaWFibGUgYW5kIHBhcnNlIGFzIGludGVnZXJcbiAgICBjb21wdXRlZFdpZHRoT3JIZWlnaHQgPSBwYXJzZUZsb2F0KGNvbXB1dGVkV2lkdGhPckhlaWdodCk7XG5cbiAgICAvLyBpZiB0aGUgY29tcHV0ZWQgdmFsdWUgaXMgc3RpbGwgMCwgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBicm93c2VyIGlzIGx5aW5nXG4gICAgLy8gYW5kIHdlIHdhbnQgdG8gY2hlY2sgdGhlIG9mZnNldCB2YWx1ZXMuXG4gICAgLy8gVGhpcyBjb2RlIGFsc28gcnVucyBvbiBJRTggYW5kIHdoZXJldmVyIGdldENvbXB1dGVkU3R5bGUgZG9lc24ndCBleGlzdC5cbiAgICBpZiAoY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID09PSAwKSB7XG4gICAgICB2YXIgcnVsZSA9ICdvZmZzZXQnICsgdG9UaXRsZUNhc2Uod2lkdGhPckhlaWdodCk7XG5cbiAgICAgIGNvbXB1dGVkV2lkdGhPckhlaWdodCA9IHRoaXMuZWxfW3J1bGVdO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wdXRlZFdpZHRoT3JIZWlnaHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHdpZHRoIGFuZCBoZWlnaHQgdmFsdWVzIG9mIHRoZSBgQ29tcG9uZW50YHNcbiAgICogY29tcHV0ZWQgc3R5bGUuIFVzZXMgYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cbiAgICpcbiAgICogQHR5cGVkZWYge09iamVjdH0gQ29tcG9uZW50fkRpbWVuc2lvbk9iamVjdFxuICAgKlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGhcbiAgICogICAgICAgICAgIFRoZSB3aWR0aCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLlxuICAgKlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0XG4gICAqICAgICAgICAgICBUaGUgaGVpZ2h0IG9mIHRoZSBgQ29tcG9uZW50YHMgY29tcHV0ZWQgc3R5bGUuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZXQgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgb2YgdGhlIGBDb21wb25lbnRgc1xuICAgKiBjb21wdXRlZCBzdHlsZS5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fkRpbWVuc2lvbk9iamVjdH1cbiAgICogICAgICAgICBUaGUgZGltZW5zaW9ucyBvZiB0aGUgY29tcG9uZW50cyBlbGVtZW50XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jdXJyZW50RGltZW5zaW9ucyA9IGZ1bmN0aW9uIGN1cnJlbnREaW1lbnNpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdGhpcy5jdXJyZW50RGltZW5zaW9uKCd3aWR0aCcpLFxuICAgICAgaGVpZ2h0OiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ2hlaWdodCcpXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB3aWR0aCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLiBVc2VzIGB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gd2lkdGhcbiAgICogICAgICAgICAgIFRoZSB3aWR0aCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY3VycmVudFdpZHRoID0gZnVuY3Rpb24gY3VycmVudFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ3dpZHRoJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSBgQ29tcG9uZW50YHMgY29tcHV0ZWQgc3R5bGUuIFVzZXMgYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBoZWlnaHRcbiAgICogICAgICAgICAgIFRoZSBoZWlnaHQgb2YgdGhlIGBDb21wb25lbnRgcyBjb21wdXRlZCBzdHlsZS5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmN1cnJlbnRIZWlnaHQgPSBmdW5jdGlvbiBjdXJyZW50SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ2hlaWdodCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZvY3VzIHRvIHRoaXMgY29tcG9uZW50XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIHRoaXMuZWxfLmZvY3VzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZm9jdXMgZnJvbSB0aGlzIGNvbXBvbmVudFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgdGhpcy5lbF8uYmx1cigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbWl0IGEgJ3RhcCcgZXZlbnRzIHdoZW4gdG91Y2ggZXZlbnQgc3VwcG9ydCBnZXRzIGRldGVjdGVkLiBUaGlzIGdldHMgdXNlZCB0b1xuICAgKiBzdXBwb3J0IHRvZ2dsaW5nIHRoZSBjb250cm9scyB0aHJvdWdoIGEgdGFwIG9uIHRoZSB2aWRlby4gVGhleSBnZXQgZW5hYmxlZFxuICAgKiBiZWNhdXNlIGV2ZXJ5IHN1Yi1jb21wb25lbnQgd291bGQgaGF2ZSBleHRyYSBvdmVyaGVhZCBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmaXJlcyBDb21wb25lbnQjdGFwXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaHN0YXJ0XG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaG1vdmVcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNobGVhdmVcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoY2FuY2VsXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaGVuZFxuICAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmVtaXRUYXBFdmVudHMgPSBmdW5jdGlvbiBlbWl0VGFwRXZlbnRzKCkge1xuICAgIC8vIFRyYWNrIHRoZSBzdGFydCB0aW1lIHNvIHdlIGNhbiBkZXRlcm1pbmUgaG93IGxvbmcgdGhlIHRvdWNoIGxhc3RlZFxuICAgIHZhciB0b3VjaFN0YXJ0ID0gMDtcbiAgICB2YXIgZmlyc3RUb3VjaCA9IG51bGw7XG5cbiAgICAvLyBNYXhpbXVtIG1vdmVtZW50IGFsbG93ZWQgZHVyaW5nIGEgdG91Y2ggZXZlbnQgdG8gc3RpbGwgYmUgY29uc2lkZXJlZCBhIHRhcFxuICAgIC8vIE90aGVyIHBvcHVsYXIgbGlicyB1c2UgYW55d2hlcmUgZnJvbSAyIChoYW1tZXIuanMpIHRvIDE1LFxuICAgIC8vIHNvIDEwIHNlZW1zIGxpa2UgYSBuaWNlLCByb3VuZCBudW1iZXIuXG4gICAgdmFyIHRhcE1vdmVtZW50VGhyZXNob2xkID0gMTA7XG5cbiAgICAvLyBUaGUgbWF4aW11bSBsZW5ndGggYSB0b3VjaCBjYW4gYmUgd2hpbGUgc3RpbGwgYmVpbmcgY29uc2lkZXJlZCBhIHRhcFxuICAgIHZhciB0b3VjaFRpbWVUaHJlc2hvbGQgPSAyMDA7XG5cbiAgICB2YXIgY291bGRCZVRhcCA9IHZvaWQgMDtcblxuICAgIHRoaXMub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgZmluZ2VyLCBkb24ndCBjb25zaWRlciB0cmVhdGluZyB0aGlzIGFzIGEgY2xpY2tcbiAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBDb3B5IHBhZ2VYL3BhZ2VZIGZyb20gdGhlIG9iamVjdFxuICAgICAgICBmaXJzdFRvdWNoID0ge1xuICAgICAgICAgIHBhZ2VYOiBldmVudC50b3VjaGVzWzBdLnBhZ2VYLFxuICAgICAgICAgIHBhZ2VZOiBldmVudC50b3VjaGVzWzBdLnBhZ2VZXG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlY29yZCBzdGFydCB0aW1lIHNvIHdlIGNhbiBkZXRlY3QgYSB0YXAgdnMuIFwidG91Y2ggYW5kIGhvbGRcIlxuICAgICAgICB0b3VjaFN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIC8vIFJlc2V0IGNvdWxkQmVUYXAgdHJhY2tpbmdcbiAgICAgICAgY291bGRCZVRhcCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgZmluZ2VyLCBkb24ndCBjb25zaWRlciB0cmVhdGluZyB0aGlzIGFzIGEgY2xpY2tcbiAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY291bGRCZVRhcCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdFRvdWNoKSB7XG4gICAgICAgIC8vIFNvbWUgZGV2aWNlcyB3aWxsIHRocm93IHRvdWNobW92ZXMgZm9yIGFsbCBidXQgdGhlIHNsaWdodGVzdCBvZiB0YXBzLlxuICAgICAgICAvLyBTbywgaWYgd2UgbW92ZWQgb25seSBhIHNtYWxsIGRpc3RhbmNlLCB0aGlzIGNvdWxkIHN0aWxsIGJlIGEgdGFwXG4gICAgICAgIHZhciB4ZGlmZiA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBmaXJzdFRvdWNoLnBhZ2VYO1xuICAgICAgICB2YXIgeWRpZmYgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZmlyc3RUb3VjaC5wYWdlWTtcbiAgICAgICAgdmFyIHRvdWNoRGlzdGFuY2UgPSBNYXRoLnNxcnQoeGRpZmYgKiB4ZGlmZiArIHlkaWZmICogeWRpZmYpO1xuXG4gICAgICAgIGlmICh0b3VjaERpc3RhbmNlID4gdGFwTW92ZW1lbnRUaHJlc2hvbGQpIHtcbiAgICAgICAgICBjb3VsZEJlVGFwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBub1RhcCA9IGZ1bmN0aW9uIG5vVGFwKCkge1xuICAgICAgY291bGRCZVRhcCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBMaXN0ZW4gdG8gdGhlIG9yaWdpbmFsIHRhcmdldC4gaHR0cDovL3lvdXR1LmJlL0R1amZwWE9LVXA4P3Q9MTNtOHNcbiAgICB0aGlzLm9uKCd0b3VjaGxlYXZlJywgbm9UYXApO1xuICAgIHRoaXMub24oJ3RvdWNoY2FuY2VsJywgbm9UYXApO1xuXG4gICAgLy8gV2hlbiB0aGUgdG91Y2ggZW5kcywgbWVhc3VyZSBob3cgbG9uZyBpdCB0b29rIGFuZCB0cmlnZ2VyIHRoZSBhcHByb3ByaWF0ZVxuICAgIC8vIGV2ZW50XG4gICAgdGhpcy5vbigndG91Y2hlbmQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGZpcnN0VG91Y2ggPSBudWxsO1xuICAgICAgLy8gUHJvY2VlZCBvbmx5IGlmIHRoZSB0b3VjaG1vdmUvbGVhdmUvY2FuY2VsIGV2ZW50IGRpZG4ndCBoYXBwZW5cbiAgICAgIGlmIChjb3VsZEJlVGFwID09PSB0cnVlKSB7XG4gICAgICAgIC8vIE1lYXN1cmUgaG93IGxvbmcgdGhlIHRvdWNoIGxhc3RlZFxuICAgICAgICB2YXIgdG91Y2hUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0b3VjaFN0YXJ0O1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdG91Y2ggd2FzIGxlc3MgdGhhbiB0aGUgdGhyZXNob2xkIHRvIGJlIGNvbnNpZGVyZWQgYSB0YXBcbiAgICAgICAgaWYgKHRvdWNoVGltZSA8IHRvdWNoVGltZVRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIERvbid0IGxldCBicm93c2VyIHR1cm4gdGhpcyBpbnRvIGEgY2xpY2tcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgYENvbXBvbmVudGAgaXMgdGFwcGVkLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGV2ZW50IENvbXBvbmVudCN0YXBcbiAgICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd0YXAnKTtcbiAgICAgICAgICAvLyBJdCBtYXkgYmUgZ29vZCB0byBjb3B5IHRoZSB0b3VjaGVuZCBldmVudCBvYmplY3QgYW5kIGNoYW5nZSB0aGVcbiAgICAgICAgICAvLyB0eXBlIHRvIHRhcCwgaWYgdGhlIG90aGVyIGV2ZW50IHByb3BlcnRpZXMgYXJlbid0IGV4YWN0IGFmdGVyXG4gICAgICAgICAgLy8gRXZlbnRzLmZpeEV2ZW50IHJ1bnMgKGUuZy4gZXZlbnQudGFyZ2V0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gcmVwb3J0cyB1c2VyIGFjdGl2aXR5IHdoZW5ldmVyIHRvdWNoIGV2ZW50cyBoYXBwZW4uIFRoaXMgY2FuIGdldFxuICAgKiB0dXJuZWQgb2ZmIGJ5IGFueSBzdWItY29tcG9uZW50cyB0aGF0IHdhbnRzIHRvdWNoIGV2ZW50cyB0byBhY3QgYW5vdGhlciB3YXkuXG4gICAqXG4gICAqIFJlcG9ydCB1c2VyIHRvdWNoIGFjdGl2aXR5IHdoZW4gdG91Y2ggZXZlbnRzIG9jY3VyLiBVc2VyIGFjdGl2aXR5IGdldHMgdXNlZCB0b1xuICAgKiBkZXRlcm1pbmUgd2hlbiBjb250cm9scyBzaG91bGQgc2hvdy9oaWRlLiBJdCBpcyBzaW1wbGUgd2hlbiBpdCBjb21lcyB0byBtb3VzZVxuICAgKiBldmVudHMsIGJlY2F1c2UgYW55IG1vdXNlIGV2ZW50IHNob3VsZCBzaG93IHRoZSBjb250cm9scy4gU28gd2UgY2FwdHVyZSBtb3VzZVxuICAgKiBldmVudHMgdGhhdCBidWJibGUgdXAgdG8gdGhlIHBsYXllciBhbmQgcmVwb3J0IGFjdGl2aXR5IHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgKiBXaXRoIHRvdWNoIGV2ZW50cyBpdCBpc24ndCBhcyBlYXN5IGFzIGB0b3VjaHN0YXJ0YCBhbmQgYHRvdWNoZW5kYCB0b2dnbGUgcGxheWVyXG4gICAqIGNvbnRyb2xzLiBTbyB0b3VjaCBldmVudHMgY2FuJ3QgaGVscCB1cyBhdCB0aGUgcGxheWVyIGxldmVsIGVpdGhlci5cbiAgICpcbiAgICogVXNlciBhY3Rpdml0eSBnZXRzIGNoZWNrZWQgYXN5bmNocm9ub3VzbHkuIFNvIHdoYXQgY291bGQgaGFwcGVuIGlzIGEgdGFwIGV2ZW50XG4gICAqIG9uIHRoZSB2aWRlbyB0dXJucyB0aGUgY29udHJvbHMgb2ZmLiBUaGVuIHRoZSBgdG91Y2hlbmRgIGV2ZW50IGJ1YmJsZXMgdXAgdG9cbiAgICogdGhlIHBsYXllci4gV2hpY2gsIGlmIGl0IHJlcG9ydGVkIHVzZXIgYWN0aXZpdHksIHdvdWxkIHR1cm4gdGhlIGNvbnRyb2xzIHJpZ2h0XG4gICAqIGJhY2sgb24uIFdlIGFsc28gZG9uJ3Qgd2FudCB0byBjb21wbGV0ZWx5IGJsb2NrIHRvdWNoIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHVwLlxuICAgKiBGdXJ0aGVybW9yZSBhIGB0b3VjaG1vdmVgIGV2ZW50IGFuZCBhbnl0aGluZyBvdGhlciB0aGFuIGEgdGFwLCBzaG91bGQgbm90IHR1cm5cbiAgICogY29udHJvbHMgYmFjayBvbi5cbiAgICpcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoc3RhcnRcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNobW92ZVxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hlbmRcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoY2FuY2VsXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5lbmFibGVUb3VjaEFjdGl2aXR5ID0gZnVuY3Rpb24gZW5hYmxlVG91Y2hBY3Rpdml0eSgpIHtcbiAgICAvLyBEb24ndCBjb250aW51ZSBpZiB0aGUgcm9vdCBwbGF5ZXIgZG9lc24ndCBzdXBwb3J0IHJlcG9ydGluZyB1c2VyIGFjdGl2aXR5XG4gICAgaWYgKCF0aGlzLnBsYXllcigpIHx8ICF0aGlzLnBsYXllcigpLnJlcG9ydFVzZXJBY3Rpdml0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGxpc3RlbmVyIGZvciByZXBvcnRpbmcgdGhhdCB0aGUgdXNlciBpcyBhY3RpdmVcbiAgICB2YXIgcmVwb3J0ID0gYmluZCh0aGlzLnBsYXllcigpLCB0aGlzLnBsYXllcigpLnJlcG9ydFVzZXJBY3Rpdml0eSk7XG5cbiAgICB2YXIgdG91Y2hIb2xkaW5nID0gdm9pZCAwO1xuXG4gICAgdGhpcy5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlcG9ydCgpO1xuICAgICAgLy8gRm9yIGFzIGxvbmcgYXMgdGhlIHRoZXkgYXJlIHRvdWNoaW5nIHRoZSBkZXZpY2Ugb3IgaGF2ZSB0aGVpciBtb3VzZSBkb3duLFxuICAgICAgLy8gd2UgY29uc2lkZXIgdGhlbSBhY3RpdmUgZXZlbiBpZiB0aGV5J3JlIG5vdCBtb3ZpbmcgdGhlaXIgZmluZ2VyIG9yIG1vdXNlLlxuICAgICAgLy8gU28gd2Ugd2FudCB0byBjb250aW51ZSB0byB1cGRhdGUgdGhhdCB0aGV5IGFyZSBhY3RpdmVcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCh0b3VjaEhvbGRpbmcpO1xuICAgICAgLy8gcmVwb3J0IGF0IHRoZSBzYW1lIGludGVydmFsIGFzIGFjdGl2aXR5Q2hlY2tcbiAgICAgIHRvdWNoSG9sZGluZyA9IHRoaXMuc2V0SW50ZXJ2YWwocmVwb3J0LCAyNTApO1xuICAgIH0pO1xuXG4gICAgdmFyIHRvdWNoRW5kID0gZnVuY3Rpb24gdG91Y2hFbmQoZXZlbnQpIHtcbiAgICAgIHJlcG9ydCgpO1xuICAgICAgLy8gc3RvcCB0aGUgaW50ZXJ2YWwgdGhhdCBtYWludGFpbnMgYWN0aXZpdHkgaWYgdGhlIHRvdWNoIGlzIGhvbGRpbmdcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCh0b3VjaEhvbGRpbmcpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uKCd0b3VjaG1vdmUnLCByZXBvcnQpO1xuICAgIHRoaXMub24oJ3RvdWNoZW5kJywgdG91Y2hFbmQpO1xuICAgIHRoaXMub24oJ3RvdWNoY2FuY2VsJywgdG91Y2hFbmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGNhbGxiYWNrIHRoYXQgaGFzIG5vIHBhcmFtZXRlcnMgYW5kIGlzIGJvdW5kIGludG8gYENvbXBvbmVudGBzIGNvbnRleHQuXG4gICAqXG4gICAqIEBjYWxsYmFjayBDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrXG4gICAqIEB0aGlzIENvbXBvbmVudFxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcnVucyBhZnRlciBhbiBgeGAgbWlsbGlzZWNvbmQgdGltZW91dC4gVGhpcyBmdW5jdGlvbiBpcyBhXG4gICAqIHdyYXBwZXIgYXJvdW5kIGB3aW5kb3cuc2V0VGltZW91dGAuIFRoZXJlIGFyZSBhIGZldyByZWFzb25zIHRvIHVzZSB0aGlzIG9uZVxuICAgKiBpbnN0ZWFkIHRob3VnaDpcbiAgICogMS4gSXQgZ2V0cyBjbGVhcmVkIHZpYSAge0BsaW5rIENvbXBvbmVudCNjbGVhclRpbWVvdXR9IHdoZW5cbiAgICogICAge0BsaW5rIENvbXBvbmVudCNkaXNwb3NlfSBnZXRzIGNhbGxlZC5cbiAgICogMi4gVGhlIGZ1bmN0aW9uIGNhbGxiYWNrIHdpbGwgZ2V0cyB0dXJuZWQgaW50byBhIHtAbGluayBDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrfVxuICAgKlxuICAgKiA+IE5vdGU6IFlvdSBjYW4gdXNlIGB3aW5kb3cuY2xlYXJUaW1lb3V0YCBvbiB0aGUgaWQgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbi4gVGhpc1xuICAgKiAgICAgICAgIHdpbGwgY2F1c2UgaXRzIGRpc3Bvc2UgbGlzdGVuZXIgbm90IHRvIGdldCBjbGVhbmVkIHVwISBQbGVhc2UgdXNlXG4gICAqICAgICAgICAge0BsaW5rIENvbXBvbmVudCNjbGVhclRpbWVvdXR9IG9yIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0uXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fkdlbmVyaWNDYWxsYmFja30gZm5cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgcnVuIGFmdGVyIGB0aW1lb3V0YC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAgICogICAgICAgIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGJlZm9yZSBleGVjdXRpbmcgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFJldHVybnMgYSB0aW1lb3V0IElEIHRoYXQgZ2V0cyB1c2VkIHRvIGlkZW50aWZ5IHRoZSB0aW1lb3V0LiBJdCBjYW4gYWxzb1xuICAgKiAgICAgICAgIGdldCB1c2VkIGluIHtAbGluayBDb21wb25lbnQjY2xlYXJUaW1lb3V0fSB0byBjbGVhciB0aGUgdGltZW91dCB0aGF0XG4gICAqICAgICAgICAgd2FzIHNldC5cbiAgICpcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I2Rpc3Bvc2VcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd1RpbWVycy9zZXRUaW1lb3V0fVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uIHNldFRpbWVvdXQoZm4sIHRpbWVvdXQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGZuID0gYmluZCh0aGlzLCBmbik7XG5cbiAgICB2YXIgdGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVvdXQpO1xuICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH07XG5cbiAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtdGltZW91dC0nICsgdGltZW91dElkO1xuXG4gICAgdGhpcy5vbignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICByZXR1cm4gdGltZW91dElkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgYSB0aW1lb3V0IHRoYXQgZ2V0cyBjcmVhdGVkIHZpYSBgd2luZG93LnNldFRpbWVvdXRgIG9yXG4gICAqIHtAbGluayBDb21wb25lbnQjc2V0VGltZW91dH0uIElmIHlvdSBzZXQgYSB0aW1lb3V0IHZpYSB7QGxpbmsgQ29tcG9uZW50I3NldFRpbWVvdXR9XG4gICAqIHVzZSB0aGlzIGZ1bmN0aW9uIGluc3RlYWQgb2YgYHdpbmRvdy5jbGVhclRpbW91dGAuIElmIHlvdSBkb24ndCB5b3VyIGRpc3Bvc2VcbiAgICogbGlzdGVuZXIgd2lsbCBub3QgZ2V0IGNsZWFuZWQgdXAgdW50aWwge0BsaW5rIENvbXBvbmVudCNkaXNwb3NlfSFcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRJZFxuICAgKiAgICAgICAgVGhlIGlkIG9mIHRoZSB0aW1lb3V0IHRvIGNsZWFyLiBUaGUgcmV0dXJuIHZhbHVlIG9mXG4gICAqICAgICAgICB7QGxpbmsgQ29tcG9uZW50I3NldFRpbWVvdXR9IG9yIGB3aW5kb3cuc2V0VGltZW91dGAuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIHRoZSB0aW1lb3V0IGlkIHRoYXQgd2FzIGNsZWFyZWQuXG4gICAqXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dUaW1lcnMvY2xlYXJUaW1lb3V0fVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCkge1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcblxuICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7fTtcblxuICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy10aW1lb3V0LScgKyB0aW1lb3V0SWQ7XG5cbiAgICB0aGlzLm9mZignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICByZXR1cm4gdGltZW91dElkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIHJ1biBldmVyeSBgeGAgbWlsbGlzZWNvbmRzLiBUaGlzIGZ1bmN0aW9uIGlzIGEgd3JhcHBlclxuICAgKiBhcm91bmQgYHdpbmRvdy5zZXRJbnRlcnZhbGAuIFRoZXJlIGFyZSBhIGZldyByZWFzb25zIHRvIHVzZSB0aGlzIG9uZSBpbnN0ZWFkIHRob3VnaC5cbiAgICogMS4gSXQgZ2V0cyBjbGVhcmVkIHZpYSAge0BsaW5rIENvbXBvbmVudCNjbGVhckludGVydmFsfSB3aGVuXG4gICAqICAgIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0gZ2V0cyBjYWxsZWQuXG4gICAqIDIuIFRoZSBmdW5jdGlvbiBjYWxsYmFjayB3aWxsIGJlIGEge0BsaW5rIENvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9XG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fkdlbmVyaWNDYWxsYmFja30gZm5cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBydW4gZXZlcnkgYHhgIHNlY29uZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbFxuICAgKiAgICAgICAgRXhlY3V0ZSB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGV2ZXJ5IGB4YCBtaWxsaXNlY29uZHMuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIGFuIGlkIHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGludGVydmFsLiBJdCBjYW4gYWxzbyBiZSBiZSB1c2VkIGluXG4gICAqICAgICAgICAge0BsaW5rIENvbXBvbmVudCNjbGVhckludGVydmFsfSB0byBjbGVhciB0aGUgaW50ZXJ2YWwuXG4gICAqXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCNkaXNwb3NlXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dUaW1lcnMvc2V0SW50ZXJ2YWx9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uIHNldEludGVydmFsKGZuLCBpbnRlcnZhbCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgZm4gPSBiaW5kKHRoaXMsIGZuKTtcblxuICAgIHZhciBpbnRlcnZhbElkID0gd2luZG93LnNldEludGVydmFsKGZuLCBpbnRlcnZhbCk7XG5cbiAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge1xuICAgICAgcmV0dXJuIF90aGlzMy5jbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIH07XG5cbiAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtaW50ZXJ2YWwtJyArIGludGVydmFsSWQ7XG5cbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiBpbnRlcnZhbElkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgYW4gaW50ZXJ2YWwgdGhhdCBnZXRzIGNyZWF0ZWQgdmlhIGB3aW5kb3cuc2V0SW50ZXJ2YWxgIG9yXG4gICAqIHtAbGluayBDb21wb25lbnQjc2V0SW50ZXJ2YWx9LiBJZiB5b3Ugc2V0IGFuIGludGV2YWwgdmlhIHtAbGluayBDb21wb25lbnQjc2V0SW50ZXJ2YWx9XG4gICAqIHVzZSB0aGlzIGZ1bmN0aW9uIGluc3RlYWQgb2YgYHdpbmRvdy5jbGVhckludGVydmFsYC4gSWYgeW91IGRvbid0IHlvdXIgZGlzcG9zZVxuICAgKiBsaXN0ZW5lciB3aWxsIG5vdCBnZXQgY2xlYW5lZCB1cCB1bnRpbCB7QGxpbmsgQ29tcG9uZW50I2Rpc3Bvc2V9IVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWxJZFxuICAgKiAgICAgICAgVGhlIGlkIG9mIHRoZSBpbnRlcnZhbCB0byBjbGVhci4gVGhlIHJldHVybiB2YWx1ZSBvZlxuICAgKiAgICAgICAge0BsaW5rIENvbXBvbmVudCNzZXRJbnRlcnZhbH0gb3IgYHdpbmRvdy5zZXRJbnRlcnZhbGAuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIHRoZSBpbnRlcnZhbCBpZCB0aGF0IHdhcyBjbGVhcmVkLlxuICAgKlxuICAgKiBAc2VlIFtTaW1pbGFyIHRvXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93VGltZXJzL2NsZWFySW50ZXJ2YWx9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jbGVhckludGVydmFsID0gZnVuY3Rpb24gY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKSB7XG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG5cbiAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge307XG5cbiAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtaW50ZXJ2YWwtJyArIGludGVydmFsSWQ7XG5cbiAgICB0aGlzLm9mZignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICByZXR1cm4gaW50ZXJ2YWxJZDtcbiAgfTtcblxuICAvKipcbiAgICogUXVldWVzIHVwIGEgY2FsbGJhY2sgdG8gYmUgcGFzc2VkIHRvIHJlcXVlc3RBbmltYXRpb25GcmFtZSAockFGKSwgYnV0XG4gICAqIHdpdGggYSBmZXcgZXh0cmEgYm9udXNlczpcbiAgICpcbiAgICogLSBTdXBwb3J0cyBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHJBRiBieSBmYWxsaW5nIGJhY2sgdG9cbiAgICogICB7QGxpbmsgQ29tcG9uZW50I3NldFRpbWVvdXR9LlxuICAgKlxuICAgKiAtIFRoZSBjYWxsYmFjayBpcyB0dXJuZWQgaW50byBhIHtAbGluayBDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrfSAoaS5lLlxuICAgKiAgIGJvdW5kIHRvIHRoZSBjb21wb25lbnQpLlxuICAgKlxuICAgKiAtIEF1dG9tYXRpYyBjYW5jZWxsYXRpb24gb2YgdGhlIHJBRiBjYWxsYmFjayBpcyBoYW5kbGVkIGlmIHRoZSBjb21wb25lbnRcbiAgICogICBpcyBkaXNwb3NlZCBiZWZvcmUgaXQgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrfSBmblxuICAgKiAgICAgICAgIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGJvdW5kIHRvIHRoaXMgY29tcG9uZW50IGFuZCBleGVjdXRlZCBqdXN0XG4gICAqICAgICAgICAgYmVmb3JlIHRoZSBicm93c2VyJ3MgbmV4dCByZXBhaW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgUmV0dXJucyBhbiByQUYgSUQgdGhhdCBnZXRzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHRpbWVvdXQuIEl0IGNhblxuICAgKiAgICAgICAgIGFsc28gYmUgdXNlZCBpbiB7QGxpbmsgQ29tcG9uZW50I2NhbmNlbEFuaW1hdGlvbkZyYW1lfSB0byBjYW5jZWxcbiAgICogICAgICAgICB0aGUgYW5pbWF0aW9uIGZyYW1lIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjZGlzcG9zZVxuICAgKiBAc2VlIFtTaW1pbGFyIHRvXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZX1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShmbikge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuc3VwcG9ydHNSYWZfKSB7XG4gICAgICBmbiA9IGJpbmQodGhpcywgZm4pO1xuXG4gICAgICB2YXIgaWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICAgICAgfTtcblxuICAgICAgZGlzcG9zZUZuLmd1aWQgPSAndmpzLXJhZi0nICsgaWQ7XG4gICAgICB0aGlzLm9uKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIC8vIEZhbGwgYmFjayB0byB1c2luZyBhIHRpbWVyLlxuICAgIHJldHVybiB0aGlzLnNldFRpbWVvdXQoZm4sIDEwMDAgLyA2MCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYSBxdWV1ZWQgY2FsbGJhY2sgcGFzc2VkIHRvIHtAbGluayBDb21wb25lbnQjcmVxdWVzdEFuaW1hdGlvbkZyYW1lfVxuICAgKiAockFGKS5cbiAgICpcbiAgICogSWYgeW91IHF1ZXVlIGFuIHJBRiBjYWxsYmFjayB2aWEge0BsaW5rIENvbXBvbmVudCNyZXF1ZXN0QW5pbWF0aW9uRnJhbWV9LFxuICAgKiB1c2UgdGhpcyBmdW5jdGlvbiBpbnN0ZWFkIG9mIGB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVgLiBJZiB5b3UgZG9uJ3QsXG4gICAqIHlvdXIgZGlzcG9zZSBsaXN0ZW5lciB3aWxsIG5vdCBnZXQgY2xlYW5lZCB1cCB1bnRpbCB7QGxpbmsgQ29tcG9uZW50I2Rpc3Bvc2V9IVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaWRcbiAgICogICAgICAgIFRoZSByQUYgSUQgdG8gY2xlYXIuIFRoZSByZXR1cm4gdmFsdWUgb2Yge0BsaW5rIENvbXBvbmVudCNyZXF1ZXN0QW5pbWF0aW9uRnJhbWV9LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgUmV0dXJucyB0aGUgckFGIElEIHRoYXQgd2FzIGNsZWFyZWQuXG4gICAqXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cvY2FuY2VsQW5pbWF0aW9uRnJhbWV9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKSB7XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNSYWZfKSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuXG4gICAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge307XG5cbiAgICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy1yYWYtJyArIGlkO1xuXG4gICAgICB0aGlzLm9mZignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICAvLyBGYWxsIGJhY2sgdG8gdXNpbmcgYSB0aW1lci5cbiAgICByZXR1cm4gdGhpcy5jbGVhclRpbWVvdXQoaWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGBDb21wb25lbnRgIHdpdGggYHZpZGVvanNgIGdpdmVuIHRoZSBuYW1lIGFuZCB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiA+IE5PVEU6IHtAbGluayBUZWNofXMgc2hvdWxkIG5vdCBiZSByZWdpc3RlcmVkIGFzIGEgYENvbXBvbmVudGAuIHtAbGluayBUZWNofXNcbiAgICogICAgICAgICBzaG91bGQgYmUgcmVnaXN0ZXJlZCB1c2luZyB7QGxpbmsgVGVjaC5yZWdpc3RlclRlY2h9IG9yXG4gICAqICAgICAgICAge0BsaW5rIHZpZGVvanM6dmlkZW9qcy5yZWdpc3RlclRlY2h9LlxuICAgKlxuICAgKiA+IE5PVEU6IFRoaXMgZnVuY3Rpb24gY2FuIGFsc28gYmUgc2VlbiBvbiB2aWRlb2pzIGFzXG4gICAqICAgICAgICAge0BsaW5rIHZpZGVvanM6dmlkZW9qcy5yZWdpc3RlckNvbXBvbmVudH0uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgYENvbXBvbmVudGAgdG8gcmVnaXN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBDb21wb25lbnRUb1JlZ2lzdGVyXG4gICAqICAgICAgICBUaGUgYENvbXBvbmVudGAgY2xhc3MgdG8gcmVnaXN0ZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogICAgICAgICBUaGUgYENvbXBvbmVudGAgdGhhdCB3YXMgcmVnaXN0ZXJlZC5cbiAgICovXG5cblxuICBDb21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQgPSBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudChuYW1lLCBDb21wb25lbnRUb1JlZ2lzdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCAhbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNvbXBvbmVudCBuYW1lLCBcIicgKyBuYW1lICsgJ1wiOyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy4nKTtcbiAgICB9XG5cbiAgICB2YXIgVGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoJ1RlY2gnKTtcblxuICAgIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoaXMgY2hlY2sgaXMgb25seSBkb25lIGlmIFRlY2ggaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAgICB2YXIgaXNUZWNoID0gVGVjaCAmJiBUZWNoLmlzVGVjaChDb21wb25lbnRUb1JlZ2lzdGVyKTtcbiAgICB2YXIgaXNDb21wID0gQ29tcG9uZW50ID09PSBDb21wb25lbnRUb1JlZ2lzdGVyIHx8IENvbXBvbmVudC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihDb21wb25lbnRUb1JlZ2lzdGVyLnByb3RvdHlwZSk7XG5cbiAgICBpZiAoaXNUZWNoIHx8ICFpc0NvbXApIHtcbiAgICAgIHZhciByZWFzb24gPSB2b2lkIDA7XG5cbiAgICAgIGlmIChpc1RlY2gpIHtcbiAgICAgICAgcmVhc29uID0gJ3RlY2hzIG11c3QgYmUgcmVnaXN0ZXJlZCB1c2luZyBUZWNoLnJlZ2lzdGVyVGVjaCgpJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlYXNvbiA9ICdtdXN0IGJlIGEgQ29tcG9uZW50IHN1YmNsYXNzJztcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNvbXBvbmVudCwgXCInICsgbmFtZSArICdcIjsgJyArIHJlYXNvbiArICcuJyk7XG4gICAgfVxuXG4gICAgbmFtZSA9IHRvVGl0bGVDYXNlKG5hbWUpO1xuXG4gICAgaWYgKCFDb21wb25lbnQuY29tcG9uZW50c18pIHtcbiAgICAgIENvbXBvbmVudC5jb21wb25lbnRzXyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBQbGF5ZXIgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KCdQbGF5ZXInKTtcblxuICAgIGlmIChuYW1lID09PSAnUGxheWVyJyAmJiBQbGF5ZXIgJiYgUGxheWVyLnBsYXllcnMpIHtcbiAgICAgIHZhciBwbGF5ZXJzID0gUGxheWVyLnBsYXllcnM7XG4gICAgICB2YXIgcGxheWVyTmFtZXMgPSBPYmplY3Qua2V5cyhwbGF5ZXJzKTtcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBwbGF5ZXJzIHRoYXQgd2VyZSBkaXNwb3NlZCwgdGhlbiB0aGVpciBuYW1lIHdpbGwgc3RpbGwgYmVcbiAgICAgIC8vIGluIFBsYXllcnMucGxheWVycy4gU28sIHdlIG11c3QgbG9vcCB0aHJvdWdoIGFuZCB2ZXJpZnkgdGhhdCB0aGUgdmFsdWVcbiAgICAgIC8vIGZvciBlYWNoIGl0ZW0gaXMgbm90IG51bGwuIFRoaXMgYWxsb3dzIHJlZ2lzdHJhdGlvbiBvZiB0aGUgUGxheWVyIGNvbXBvbmVudFxuICAgICAgLy8gYWZ0ZXIgYWxsIHBsYXllcnMgaGF2ZSBiZWVuIGRpc3Bvc2VkIG9yIGJlZm9yZSBhbnkgd2VyZSBjcmVhdGVkLlxuICAgICAgaWYgKHBsYXllcnMgJiYgcGxheWVyTmFtZXMubGVuZ3RoID4gMCAmJiBwbGF5ZXJOYW1lcy5tYXAoZnVuY3Rpb24gKHBuYW1lKSB7XG4gICAgICAgIHJldHVybiBwbGF5ZXJzW3BuYW1lXTtcbiAgICAgIH0pLmV2ZXJ5KEJvb2xlYW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCByZWdpc3RlciBQbGF5ZXIgY29tcG9uZW50IGFmdGVyIHBsYXllciBoYXMgYmVlbiBjcmVhdGVkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIENvbXBvbmVudC5jb21wb25lbnRzX1tuYW1lXSA9IENvbXBvbmVudFRvUmVnaXN0ZXI7XG5cbiAgICByZXR1cm4gQ29tcG9uZW50VG9SZWdpc3RlcjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgYENvbXBvbmVudGAgYmFzZWQgb24gdGhlIG5hbWUgaXQgd2FzIHJlZ2lzdGVyZWQgd2l0aC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIFRoZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqICAgICAgICAgVGhlIGBDb21wb25lbnRgIHRoYXQgZ290IHJlZ2lzdGVyZWQgdW5kZXIgdGhlIGdpdmVuIG5hbWUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluIGB2aWRlb2pzYCA2IHRoaXMgd2lsbCBub3QgcmV0dXJuIGBDb21wb25lbnRgcyB0aGF0IHdlcmUgbm90XG4gICAqICAgICAgICAgICAgIHJlZ2lzdGVyZWQgdXNpbmcge0BsaW5rIENvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudH0uIEN1cnJlbnRseSB3ZVxuICAgKiAgICAgICAgICAgICBjaGVjayB0aGUgZ2xvYmFsIGB2aWRlb2pzYCBvYmplY3QgZm9yIGEgYENvbXBvbmVudGAgbmFtZSBhbmRcbiAgICogICAgICAgICAgICAgcmV0dXJuIHRoYXQgaWYgaXQgZXhpc3RzLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5nZXRDb21wb25lbnQgPSBmdW5jdGlvbiBnZXRDb21wb25lbnQobmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5hbWUgPSB0b1RpdGxlQ2FzZShuYW1lKTtcblxuICAgIGlmIChDb21wb25lbnQuY29tcG9uZW50c18gJiYgQ29tcG9uZW50LmNvbXBvbmVudHNfW25hbWVdKSB7XG4gICAgICByZXR1cm4gQ29tcG9uZW50LmNvbXBvbmVudHNfW25hbWVdO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ29tcG9uZW50O1xufSgpO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9uZW50IHN1cHBvcnRzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLlxuICpcbiAqIFRoaXMgaXMgZXhwb3NlZCBwcmltYXJpbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5cblxuQ29tcG9uZW50LnByb3RvdHlwZS5zdXBwb3J0c1JhZl8gPSB0eXBlb2Ygd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NvbXBvbmVudCcsIENvbXBvbmVudCk7XG5cbi8qKlxuICogQGZpbGUgdGltZS1yYW5nZXMuanNcbiAqIEBtb2R1bGUgdGltZS1yYW5nZXNcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHRpbWUgZm9yIHRoZSBzcGVjaWZpZWQgaW5kZXggYXQgdGhlIHN0YXJ0IG9yIGVuZFxuICogb2YgYSBUaW1lUmFuZ2Ugb2JqZWN0LlxuICpcbiAqIEBmdW5jdGlvbiB0aW1lLXJhbmdlczppbmRleEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD0wXVxuICogICAgICAgIFRoZSByYW5nZSBudW1iZXIgdG8gcmV0dXJuIHRoZSB0aW1lIGZvci5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB0aW1lIHRoYXQgb2Zmc2V0IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gKlxuICogQGRlcHJpY2F0ZWQgaW5kZXggbXVzdCBiZSBzZXQgdG8gYSB2YWx1ZSwgaW4gdGhlIGZ1dHVyZSB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gKi9cblxuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjb250YWlucyByYW5nZXMgb2YgdGltZSBmb3IgdmFyaW91cyByZWFzb25zLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRpbWVSYW5nZVxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZW5ndGhcbiAqICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHRpbWUgcmFuZ2VzIHJlcHJlc2VudGVkIGJ5IHRoaXMgT2JqZWN0XG4gKlxuICogQHByb3BlcnR5IHt0aW1lLXJhbmdlczppbmRleEZ1bmN0aW9ufSBzdGFydFxuICogICAgICAgICAgIFJldHVybnMgdGhlIHRpbWUgb2Zmc2V0IGF0IHdoaWNoIGEgc3BlY2lmaWVkIHRpbWUgcmFuZ2UgYmVnaW5zLlxuICpcbiAqIEBwcm9wZXJ0eSB7dGltZS1yYW5nZXM6aW5kZXhGdW5jdGlvbn0gZW5kXG4gKiAgICAgICAgICAgUmV0dXJucyB0aGUgdGltZSBvZmZzZXQgYXQgd2hpY2ggYSBzcGVjaWZpZWQgdGltZSByYW5nZSBiZWdpbnMuXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGltZVJhbmdlc1xuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYW55IG9mIHRoZSB0aW1lIHJhbmdlcyBhcmUgb3ZlciB0aGUgbWF4aW11bSBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIG5hbWUgdG8gdXNlIGZvciBsb2dnaW5nXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiAgICAgICAgVGhlIGluZGV4IHRvIGNoZWNrXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG1heEluZGV4XG4gKiAgICAgICAgVGhlIG1heGltdW0gcG9zc2libGUgaW5kZXhcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIHRpbWVSYW5nZXMgcHJvdmlkZWQgYXJlIG92ZXIgdGhlIG1heEluZGV4XG4gKi9cbmZ1bmN0aW9uIHJhbmdlQ2hlY2soZm5OYW1lLCBpbmRleCwgbWF4SW5kZXgpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicgfHwgaW5kZXggPCAwIHx8IGluZGV4ID4gbWF4SW5kZXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBleGVjdXRlIFxcJycgKyBmbk5hbWUgKyAnXFwnIG9uIFxcJ1RpbWVSYW5nZXNcXCc6IFRoZSBpbmRleCBwcm92aWRlZCAoJyArIGluZGV4ICsgJykgaXMgbm9uLW51bWVyaWMgb3Igb3V0IG9mIGJvdW5kcyAoMC0nICsgbWF4SW5kZXggKyAnKS4nKTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFueSBvZiB0aGUgdGltZSByYW5nZXMgYXJlIG92ZXIgdGhlIG1heGltdW0gaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICogICAgICAgIFRoZSBmdW5jdGlvbiBuYW1lIHRvIHVzZSBmb3IgbG9nZ2luZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZUluZGV4XG4gKiAgICAgICAgVGhlIHByb3ByZXR5IHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2V0IHRoZSB0aW1lLiBzaG91bGQgYmUgJ3N0YXJ0JyBvciAnZW5kJ1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHJhbmdlc1xuICogICAgICAgIEFuIGFycmF5IG9mIHRpbWUgcmFuZ2VzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gW3JhbmdlSW5kZXg9MF1cbiAqICAgICAgICBUaGUgaW5kZXggdG8gc3RhcnQgdGhlIHNlYXJjaCBhdFxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHRpbWUgdGhhdCBvZmZzZXQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAqXG4gKlxuICogQGRlcHJpY2F0ZWQgcmFuZ2VJbmRleCBtdXN0IGJlIHNldCB0byBhIHZhbHVlLCBpbiB0aGUgZnV0dXJlIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiByYW5nZUluZGV4IGlzIG1vcmUgdGhhbiB0aGUgbGVuZ3RoIG9mIHJhbmdlc1xuICovXG5mdW5jdGlvbiBnZXRSYW5nZShmbk5hbWUsIHZhbHVlSW5kZXgsIHJhbmdlcywgcmFuZ2VJbmRleCkge1xuICByYW5nZUNoZWNrKGZuTmFtZSwgcmFuZ2VJbmRleCwgcmFuZ2VzLmxlbmd0aCAtIDEpO1xuICByZXR1cm4gcmFuZ2VzW3JhbmdlSW5kZXhdW3ZhbHVlSW5kZXhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHRpbWUgcmFuZ2Ugb2JqZWN0IGdpdmVudCByYW5nZXMgb2YgdGltZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBbcmFuZ2VzXVxuICogICAgICAgIEFuIGFycmF5IG9mIHRpbWUgcmFuZ2VzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVUaW1lUmFuZ2VzT2JqKHJhbmdlcykge1xuICBpZiAocmFuZ2VzID09PSB1bmRlZmluZWQgfHwgcmFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZW5ndGg6IDAsXG4gICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBUaW1lUmFuZ2VzIG9iamVjdCBpcyBlbXB0eScpO1xuICAgICAgfSxcbiAgICAgIGVuZDogZnVuY3Rpb24gZW5kKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgVGltZVJhbmdlcyBvYmplY3QgaXMgZW1wdHknKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbGVuZ3RoOiByYW5nZXMubGVuZ3RoLFxuICAgIHN0YXJ0OiBnZXRSYW5nZS5iaW5kKG51bGwsICdzdGFydCcsIDAsIHJhbmdlcyksXG4gICAgZW5kOiBnZXRSYW5nZS5iaW5kKG51bGwsICdlbmQnLCAxLCByYW5nZXMpXG4gIH07XG59XG5cbi8qKlxuICogU2hvdWxkIGNyZWF0ZSBhIGZha2UgYFRpbWVSYW5nZWAgb2JqZWN0IHdoaWNoIG1pbWljcyBhbiBIVE1MNSB0aW1lIHJhbmdlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfEFycmF5fSBzdGFydFxuICogICAgICAgIFRoZSBzdGFydCBvZiBhIHNpbmdsZSByYW5nZSBvciBhbiBhcnJheSBvZiByYW5nZXNcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gKiAgICAgICAgVGhlIGVuZCBvZiBhIHNpbmdsZSByYW5nZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVUaW1lUmFuZ2VzKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RhcnQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXNPYmooc3RhcnQpO1xuICB9IGVsc2UgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlc09iaigpO1xuICB9XG4gIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzT2JqKFtbc3RhcnQsIGVuZF1dKTtcbn1cblxuLyoqXG4gKiBAZmlsZSBidWZmZXIuanNcbiAqIEBtb2R1bGUgYnVmZmVyXG4gKi9cbi8qKlxuICogQ29tcHV0ZSB0aGUgcGVyY2VudGFnZSBvZiB0aGUgbWVkaWEgdGhhdCBoYXMgYmVlbiBidWZmZXJlZC5cbiAqXG4gKiBAcGFyYW0ge1RpbWVSYW5nZX0gYnVmZmVyZWRcbiAqICAgICAgICBUaGUgY3VycmVudCBgVGltZVJhbmdlYCBvYmplY3QgcmVwcmVzZW50aW5nIGJ1ZmZlcmVkIHRpbWUgcmFuZ2VzXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG4gKiAgICAgICAgVG90YWwgZHVyYXRpb24gb2YgdGhlIG1lZGlhXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBQZXJjZW50IGJ1ZmZlcmVkIG9mIHRoZSB0b3RhbCBkdXJhdGlvbiBpbiBkZWNpbWFsIGZvcm0uXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlcmVkUGVyY2VudChidWZmZXJlZCwgZHVyYXRpb24pIHtcbiAgdmFyIGJ1ZmZlcmVkRHVyYXRpb24gPSAwO1xuICB2YXIgc3RhcnQgPSB2b2lkIDA7XG4gIHZhciBlbmQgPSB2b2lkIDA7XG5cbiAgaWYgKCFkdXJhdGlvbikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKCFidWZmZXJlZCB8fCAhYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgYnVmZmVyZWQgPSBjcmVhdGVUaW1lUmFuZ2VzKDAsIDApO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgIHN0YXJ0ID0gYnVmZmVyZWQuc3RhcnQoaSk7XG4gICAgZW5kID0gYnVmZmVyZWQuZW5kKGkpO1xuXG4gICAgLy8gYnVmZmVyZWQgZW5kIGNhbiBiZSBiaWdnZXIgdGhhbiBkdXJhdGlvbiBieSBhIHZlcnkgc21hbGwgZnJhY3Rpb25cbiAgICBpZiAoZW5kID4gZHVyYXRpb24pIHtcbiAgICAgIGVuZCA9IGR1cmF0aW9uO1xuICAgIH1cblxuICAgIGJ1ZmZlcmVkRHVyYXRpb24gKz0gZW5kIC0gc3RhcnQ7XG4gIH1cblxuICByZXR1cm4gYnVmZmVyZWREdXJhdGlvbiAvIGR1cmF0aW9uO1xufVxuXG4vKipcbiAqIEBmaWxlIGZ1bGxzY3JlZW4tYXBpLmpzXG4gKiBAbW9kdWxlIGZ1bGxzY3JlZW4tYXBpXG4gKiBAcHJpdmF0ZVxuICovXG4vKipcbiAqIFN0b3JlIHRoZSBicm93c2VyLXNwZWNpZmljIG1ldGhvZHMgZm9yIHRoZSBmdWxsc2NyZWVuIEFQSS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHNlZSBbU3BlY2lmaWNhdGlvbl17QGxpbmsgaHR0cHM6Ly9mdWxsc2NyZWVuLnNwZWMud2hhdHdnLm9yZ31cbiAqIEBzZWUgW01hcCBBcHByb2FjaCBGcm9tIFNjcmVlbmZ1bGwuanNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvc2NyZWVuZnVsbC5qc31cbiAqL1xudmFyIEZ1bGxzY3JlZW5BcGkgPSB7fTtcblxuLy8gYnJvd3NlciBBUEkgbWV0aG9kc1xudmFyIGFwaU1hcCA9IFtbJ3JlcXVlc3RGdWxsc2NyZWVuJywgJ2V4aXRGdWxsc2NyZWVuJywgJ2Z1bGxzY3JlZW5FbGVtZW50JywgJ2Z1bGxzY3JlZW5FbmFibGVkJywgJ2Z1bGxzY3JlZW5jaGFuZ2UnLCAnZnVsbHNjcmVlbmVycm9yJ10sXG4vLyBXZWJLaXRcblsnd2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4nLCAnd2Via2l0RXhpdEZ1bGxzY3JlZW4nLCAnd2Via2l0RnVsbHNjcmVlbkVsZW1lbnQnLCAnd2Via2l0RnVsbHNjcmVlbkVuYWJsZWQnLCAnd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsICd3ZWJraXRmdWxsc2NyZWVuZXJyb3InXSxcbi8vIE9sZCBXZWJLaXQgKFNhZmFyaSA1LjEpXG5bJ3dlYmtpdFJlcXVlc3RGdWxsU2NyZWVuJywgJ3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLCAnd2Via2l0Q3VycmVudEZ1bGxTY3JlZW5FbGVtZW50JywgJ3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLCAnd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsICd3ZWJraXRmdWxsc2NyZWVuZXJyb3InXSxcbi8vIE1vemlsbGFcblsnbW96UmVxdWVzdEZ1bGxTY3JlZW4nLCAnbW96Q2FuY2VsRnVsbFNjcmVlbicsICdtb3pGdWxsU2NyZWVuRWxlbWVudCcsICdtb3pGdWxsU2NyZWVuRW5hYmxlZCcsICdtb3pmdWxsc2NyZWVuY2hhbmdlJywgJ21vemZ1bGxzY3JlZW5lcnJvciddLFxuLy8gTWljcm9zb2Z0XG5bJ21zUmVxdWVzdEZ1bGxzY3JlZW4nLCAnbXNFeGl0RnVsbHNjcmVlbicsICdtc0Z1bGxzY3JlZW5FbGVtZW50JywgJ21zRnVsbHNjcmVlbkVuYWJsZWQnLCAnTVNGdWxsc2NyZWVuQ2hhbmdlJywgJ01TRnVsbHNjcmVlbkVycm9yJ11dO1xuXG52YXIgc3BlY0FwaSA9IGFwaU1hcFswXTtcbnZhciBicm93c2VyQXBpID0gdm9pZCAwO1xuXG4vLyBkZXRlcm1pbmUgdGhlIHN1cHBvcnRlZCBzZXQgb2YgZnVuY3Rpb25zXG5mb3IgKHZhciBpID0gMDsgaSA8IGFwaU1hcC5sZW5ndGg7IGkrKykge1xuICAvLyBjaGVjayBmb3IgZXhpdEZ1bGxzY3JlZW4gZnVuY3Rpb25cbiAgaWYgKGFwaU1hcFtpXVsxXSBpbiBkb2N1bWVudCkge1xuICAgIGJyb3dzZXJBcGkgPSBhcGlNYXBbaV07XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gbWFwIHRoZSBicm93c2VyIEFQSSBuYW1lcyB0byB0aGUgc3BlYyBBUEkgbmFtZXNcbmlmIChicm93c2VyQXBpKSB7XG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBicm93c2VyQXBpLmxlbmd0aDsgX2krKykge1xuICAgIEZ1bGxzY3JlZW5BcGlbc3BlY0FwaVtfaV1dID0gYnJvd3NlckFwaVtfaV07XG4gIH1cbn1cblxuLyoqXG4gKiBAZmlsZSBtZWRpYS1lcnJvci5qc1xuICovXG4vKipcbiAqIEEgQ3VzdG9tIGBNZWRpYUVycm9yYCBjbGFzcyB3aGljaCBtaW1pY3MgdGhlIHN0YW5kYXJkIEhUTUw1IGBNZWRpYUVycm9yYCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8T2JqZWN0fE1lZGlhRXJyb3J9IHZhbHVlXG4gKiAgICAgICAgVGhpcyBjYW4gYmUgb2YgbXVsdGlwbGUgdHlwZXM6XG4gKiAgICAgICAgLSBudW1iZXI6IHNob3VsZCBiZSBhIHN0YW5kYXJkIGVycm9yIGNvZGVcbiAqICAgICAgICAtIHN0cmluZzogYW4gZXJyb3IgbWVzc2FnZSAodGhlIGNvZGUgd2lsbCBiZSAwKVxuICogICAgICAgIC0gT2JqZWN0OiBhcmJpdHJhcnkgcHJvcGVydGllc1xuICogICAgICAgIC0gYE1lZGlhRXJyb3JgIChuYXRpdmUpOiB1c2VkIHRvIHBvcHVsYXRlIGEgdmlkZW8uanMgYE1lZGlhRXJyb3JgIG9iamVjdFxuICogICAgICAgIC0gYE1lZGlhRXJyb3JgICh2aWRlby5qcyk6IHdpbGwgcmV0dXJuIGl0c2VsZiBpZiBpdCdzIGFscmVhZHkgYVxuICogICAgICAgICAgdmlkZW8uanMgYE1lZGlhRXJyb3JgIG9iamVjdC5cbiAqXG4gKiBAc2VlIFtNZWRpYUVycm9yIFNwZWNde0BsaW5rIGh0dHBzOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjLWF1dGhvci12aWV3L3ZpZGVvLmh0bWwjbWVkaWFlcnJvcn1cbiAqIEBzZWUgW0VuY3J5cHRlZCBNZWRpYUVycm9yIFNwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELWVuY3J5cHRlZC1tZWRpYS0yMDEzMDUxMC8jZXJyb3ItY29kZXN9XG4gKlxuICogQGNsYXNzIE1lZGlhRXJyb3JcbiAqL1xuZnVuY3Rpb24gTWVkaWFFcnJvcih2YWx1ZSkge1xuXG4gIC8vIEFsbG93IHJlZHVuZGFudCBjYWxscyB0byB0aGlzIGNvbnN0cnVjdG9yIHRvIGF2b2lkIGhhdmluZyBgaW5zdGFuY2VvZmBcbiAgLy8gY2hlY2tzIHBlcHBlcmVkIGFyb3VuZCB0aGUgY29kZS5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWVkaWFFcnJvcikge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5jb2RlID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIC8vIGRlZmF1bHQgY29kZSBpcyB6ZXJvLCBzbyB0aGlzIGlzIGEgY3VzdG9tIGVycm9yXG4gICAgdGhpcy5tZXNzYWdlID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG5cbiAgICAvLyBXZSBhc3NpZ24gdGhlIGBjb2RlYCBwcm9wZXJ0eSBtYW51YWxseSBiZWNhdXNlIG5hdGl2ZSBgTWVkaWFFcnJvcmAgb2JqZWN0c1xuICAgIC8vIGRvIG5vdCBleHBvc2UgaXQgYXMgYW4gb3duL2VudW1lcmFibGUgcHJvcGVydHkgb2YgdGhlIG9iamVjdC5cbiAgICBpZiAodHlwZW9mIHZhbHVlLmNvZGUgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmNvZGUgPSB2YWx1ZS5jb2RlO1xuICAgIH1cblxuICAgIGFzc2lnbih0aGlzLCB2YWx1ZSk7XG4gIH1cblxuICBpZiAoIXRoaXMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IE1lZGlhRXJyb3IuZGVmYXVsdE1lc3NhZ2VzW3RoaXMuY29kZV0gfHwgJyc7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgZXJyb3IgY29kZSB0aGF0IHJlZmVycyB0d28gb25lIG9mIHRoZSBkZWZpbmVkIGBNZWRpYUVycm9yYCB0eXBlc1xuICpcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbk1lZGlhRXJyb3IucHJvdG90eXBlLmNvZGUgPSAwO1xuXG4vKipcbiAqIEFuIG9wdGlvbmFsIG1lc3NhZ2UgdGhhdCB0byBzaG93IHdpdGggdGhlIGVycm9yLiBNZXNzYWdlIGlzIG5vdCBwYXJ0IG9mIHRoZSBIVE1MNVxuICogdmlkZW8gc3BlYyBidXQgYWxsb3dzIGZvciBtb3JlIGluZm9ybWF0aXZlIGN1c3RvbSBlcnJvcnMuXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuTWVkaWFFcnJvci5wcm90b3R5cGUubWVzc2FnZSA9ICcnO1xuXG4vKipcbiAqIEFuIG9wdGlvbmFsIHN0YXR1cyBjb2RlIHRoYXQgY2FuIGJlIHNldCBieSBwbHVnaW5zIHRvIGFsbG93IGV2ZW4gbW9yZSBkZXRhaWwgYWJvdXRcbiAqIHRoZSBlcnJvci4gRm9yIGV4YW1wbGUgYSBwbHVnaW4gbWlnaHQgcHJvdmlkZSBhIHNwZWNpZmljIEhUVFAgc3RhdHVzIGNvZGUgYW5kIGFuXG4gKiBlcnJvciBtZXNzYWdlIGZvciB0aGF0IGNvZGUuIFRoZW4gd2hlbiB0aGUgcGx1Z2luIGdldHMgdGhhdCBlcnJvciB0aGlzIGNsYXNzIHdpbGxcbiAqIGtub3cgaG93IHRvIGRpc3BsYXkgYW4gZXJyb3IgbWVzc2FnZSBmb3IgaXQuIFRoaXMgYWxsb3dzIGEgY3VzdG9tIG1lc3NhZ2UgdG8gc2hvd1xuICogdXAgb24gdGhlIGBQbGF5ZXJgIGVycm9yIG92ZXJsYXkuXG4gKlxuICogQHR5cGUge0FycmF5fVxuICovXG5NZWRpYUVycm9yLnByb3RvdHlwZS5zdGF0dXMgPSBudWxsO1xuXG4vKipcbiAqIEVycm9ycyBpbmRleGVkIGJ5IHRoZSBXM0Mgc3RhbmRhcmQuIFRoZSBvcmRlciAqKkNBTk5PVCBDSEFOR0UqKiEgU2VlIHRoZVxuICogc3BlY2lmaWNhdGlvbiBsaXN0ZWQgdW5kZXIge0BsaW5rIE1lZGlhRXJyb3J9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBlbnVtIHthcnJheX1cbiAqIEByZWFkb25seVxuICogQHByb3BlcnR5IHtzdHJpbmd9IDAgLSBNRURJQV9FUlJfQ1VTVE9NXG4gKiBAcHJvcGVydHkge3N0cmluZ30gMSAtIE1FRElBX0VSUl9DVVNUT01cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAyIC0gTUVESUFfRVJSX0FCT1JURURcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAzIC0gTUVESUFfRVJSX05FVFdPUktcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSA0IC0gTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEXG4gKiBAcHJvcGVydHkge3N0cmluZ30gNSAtIE1FRElBX0VSUl9FTkNSWVBURURcbiAqL1xuTWVkaWFFcnJvci5lcnJvclR5cGVzID0gWydNRURJQV9FUlJfQ1VTVE9NJywgJ01FRElBX0VSUl9BQk9SVEVEJywgJ01FRElBX0VSUl9ORVRXT1JLJywgJ01FRElBX0VSUl9ERUNPREUnLCAnTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEJywgJ01FRElBX0VSUl9FTkNSWVBURUQnXTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBgTWVkaWFFcnJvcmAgbWVzc2FnZXMgYmFzZWQgb24gdGhlIHtAbGluayBNZWRpYUVycm9yLmVycm9yVHlwZXN9LlxuICpcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBjb25zdGFudFxuICovXG5NZWRpYUVycm9yLmRlZmF1bHRNZXNzYWdlcyA9IHtcbiAgMTogJ1lvdSBhYm9ydGVkIHRoZSBtZWRpYSBwbGF5YmFjaycsXG4gIDI6ICdBIG5ldHdvcmsgZXJyb3IgY2F1c2VkIHRoZSBtZWRpYSBkb3dubG9hZCB0byBmYWlsIHBhcnQtd2F5LicsXG4gIDM6ICdUaGUgbWVkaWEgcGxheWJhY2sgd2FzIGFib3J0ZWQgZHVlIHRvIGEgY29ycnVwdGlvbiBwcm9ibGVtIG9yIGJlY2F1c2UgdGhlIG1lZGlhIHVzZWQgZmVhdHVyZXMgeW91ciBicm93c2VyIGRpZCBub3Qgc3VwcG9ydC4nLFxuICA0OiAnVGhlIG1lZGlhIGNvdWxkIG5vdCBiZSBsb2FkZWQsIGVpdGhlciBiZWNhdXNlIHRoZSBzZXJ2ZXIgb3IgbmV0d29yayBmYWlsZWQgb3IgYmVjYXVzZSB0aGUgZm9ybWF0IGlzIG5vdCBzdXBwb3J0ZWQuJyxcbiAgNTogJ1RoZSBtZWRpYSBpcyBlbmNyeXB0ZWQgYW5kIHdlIGRvIG5vdCBoYXZlIHRoZSBrZXlzIHRvIGRlY3J5cHQgaXQuJ1xufTtcblxuLy8gQWRkIHR5cGVzIGFzIHByb3BlcnRpZXMgb24gTWVkaWFFcnJvclxuLy8gZS5nLiBNZWRpYUVycm9yLk1FRElBX0VSUl9TUkNfTk9UX1NVUFBPUlRFRCA9IDQ7XG5mb3IgKHZhciBlcnJOdW0gPSAwOyBlcnJOdW0gPCBNZWRpYUVycm9yLmVycm9yVHlwZXMubGVuZ3RoOyBlcnJOdW0rKykge1xuICBNZWRpYUVycm9yW01lZGlhRXJyb3IuZXJyb3JUeXBlc1tlcnJOdW1dXSA9IGVyck51bTtcbiAgLy8gdmFsdWVzIHNob3VsZCBiZSBhY2Nlc3NpYmxlIG9uIGJvdGggdGhlIGNsYXNzIGFuZCBpbnN0YW5jZVxuICBNZWRpYUVycm9yLnByb3RvdHlwZVtNZWRpYUVycm9yLmVycm9yVHlwZXNbZXJyTnVtXV0gPSBlcnJOdW07XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGFuIG9iamVjdCBpcyBgUHJvbWlzZWAtbGlrZSAoaS5lLiBoYXMgYSBgdGhlbmAgbWV0aG9kKS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9ICB2YWx1ZVxuICogICAgICAgICBBbiBvYmplY3QgdGhhdCBtYXkgb3IgbWF5IG5vdCBiZSBgUHJvbWlzZWAtbGlrZS5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGBQcm9taXNlYC1saWtlLlxuICovXG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogU2lsZW5jZSBhIFByb21pc2UtbGlrZSBvYmplY3QuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGF2b2lkaW5nIG5vbi1oYXJtZnVsLCBidXQgcG90ZW50aWFsbHkgY29uZnVzaW5nIFwidW5jYXVnaHRcbiAqIHBsYXkgcHJvbWlzZVwiIHJlamVjdGlvbiBlcnJvciBtZXNzYWdlcy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHZhbHVlXG4gKiAgICAgICAgIEFuIG9iamVjdCB0aGF0IG1heSBvciBtYXkgbm90IGJlIGBQcm9taXNlYC1saWtlLlxuICovXG5mdW5jdGlvbiBzaWxlbmNlUHJvbWlzZSh2YWx1ZSkge1xuICBpZiAoaXNQcm9taXNlKHZhbHVlKSkge1xuICAgIHZhbHVlLnRoZW4obnVsbCwgZnVuY3Rpb24gKGUpIHt9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stbGlzdC1jb252ZXJ0ZXIuanMgVXRpbGl0aWVzIGZvciBjYXB0dXJpbmcgdGV4dCB0cmFjayBzdGF0ZSBhbmRcbiAqIHJlLWNyZWF0aW5nIHRyYWNrcyBiYXNlZCBvbiBhIGNhcHR1cmUuXG4gKlxuICogQG1vZHVsZSB0ZXh0LXRyYWNrLWxpc3QtY29udmVydGVyXG4gKi9cblxuLyoqXG4gKiBFeGFtaW5lIGEgc2luZ2xlIHtAbGluayBUZXh0VHJhY2t9IGFuZCByZXR1cm4gYSBKU09OLWNvbXBhdGlibGUgamF2YXNjcmlwdCBvYmplY3QgdGhhdFxuICogcmVwcmVzZW50cyB0aGUge0BsaW5rIFRleHRUcmFja30ncyBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAqICAgICAgICBUaGUgdGV4dCB0cmFjayB0byBxdWVyeS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIEEgc2VyaWFsaXphYmxlIGphdmFzY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIFRleHRUcmFjay5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB0cmFja1RvSnNvbl8gPSBmdW5jdGlvbiB0cmFja1RvSnNvbl8odHJhY2spIHtcbiAgdmFyIHJldCA9IFsna2luZCcsICdsYWJlbCcsICdsYW5ndWFnZScsICdpZCcsICdpbkJhbmRNZXRhZGF0YVRyYWNrRGlzcGF0Y2hUeXBlJywgJ21vZGUnLCAnc3JjJ10ucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHByb3AsIGkpIHtcblxuICAgIGlmICh0cmFja1twcm9wXSkge1xuICAgICAgYWNjW3Byb3BdID0gdHJhY2tbcHJvcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge1xuICAgIGN1ZXM6IHRyYWNrLmN1ZXMgJiYgQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKHRyYWNrLmN1ZXMsIGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0VGltZTogY3VlLnN0YXJ0VGltZSxcbiAgICAgICAgZW5kVGltZTogY3VlLmVuZFRpbWUsXG4gICAgICAgIHRleHQ6IGN1ZS50ZXh0LFxuICAgICAgICBpZDogY3VlLmlkXG4gICAgICB9O1xuICAgIH0pXG4gIH0pO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIEV4YW1pbmUgYSB7QGxpbmsgVGVjaH0gYW5kIHJldHVybiBhIEpTT04tY29tcGF0aWJsZSBqYXZhc2NyaXB0IGFycmF5IHRoYXQgcmVwcmVzZW50cyB0aGVcbiAqIHN0YXRlIG9mIGFsbCB7QGxpbmsgVGV4dFRyYWNrfXMgY3VycmVudGx5IGNvbmZpZ3VyZWQuIFRoZSByZXR1cm4gYXJyYXkgaXMgY29tcGF0aWJsZSB3aXRoXG4gKiB7QGxpbmsgdGV4dC10cmFjay1saXN0LWNvbnZlcnRlcjpqc29uVG9UZXh0VHJhY2tzfS5cbiAqXG4gKiBAcGFyYW0ge1RlY2h9IHRlY2hcbiAqICAgICAgICBUaGUgdGVjaCBvYmplY3QgdG8gcXVlcnlcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqICAgICAgICAgQSBzZXJpYWxpemFibGUgamF2YXNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGUge0BsaW5rIFRlY2h9c1xuICogICAgICAgICB7QGxpbmsgVGV4dFRyYWNrTGlzdH0uXG4gKi9cbnZhciB0ZXh0VHJhY2tzVG9Kc29uID0gZnVuY3Rpb24gdGV4dFRyYWNrc1RvSnNvbih0ZWNoKSB7XG5cbiAgdmFyIHRyYWNrRWxzID0gdGVjaC4kJCgndHJhY2snKTtcblxuICB2YXIgdHJhY2tPYmpzID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKHRyYWNrRWxzLCBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0LnRyYWNrO1xuICB9KTtcbiAgdmFyIHRyYWNrcyA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh0cmFja0VscywgZnVuY3Rpb24gKHRyYWNrRWwpIHtcbiAgICB2YXIganNvbiA9IHRyYWNrVG9Kc29uXyh0cmFja0VsLnRyYWNrKTtcblxuICAgIGlmICh0cmFja0VsLnNyYykge1xuICAgICAganNvbi5zcmMgPSB0cmFja0VsLnNyYztcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG4gIH0pO1xuXG4gIHJldHVybiB0cmFja3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbCh0ZWNoLnRleHRUcmFja3MoKSwgZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgcmV0dXJuIHRyYWNrT2Jqcy5pbmRleE9mKHRyYWNrKSA9PT0gLTE7XG4gIH0pLm1hcCh0cmFja1RvSnNvbl8pKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgc2V0IG9mIHJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrfXMgb24gYSB7QGxpbmsgVGVjaH0gYmFzZWQgb24gYW4gYXJyYXkgb2YgamF2YXNjcmlwdFxuICogb2JqZWN0IHtAbGluayBUZXh0VHJhY2t9IHJlcHJlc2VudGF0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBqc29uXG4gKiAgICAgICAgQW4gYXJyYXkgb2YgYFRleHRUcmFja2AgcmVwcmVzZW50YXRpb24gb2JqZWN0cywgbGlrZSB0aG9zZSB0aGF0IHdvdWxkIGJlXG4gKiAgICAgICAgcHJvZHVjZWQgYnkgYHRleHRUcmFja3NUb0pzb25gLlxuICpcbiAqIEBwYXJhbSB7VGVjaH0gdGVjaFxuICogICAgICAgIFRoZSBgVGVjaGAgdG8gY3JlYXRlIHRoZSBgVGV4dFRyYWNrYHMgb24uXG4gKi9cbnZhciBqc29uVG9UZXh0VHJhY2tzID0gZnVuY3Rpb24ganNvblRvVGV4dFRyYWNrcyhqc29uLCB0ZWNoKSB7XG4gIGpzb24uZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICB2YXIgYWRkZWRUcmFjayA9IHRlY2guYWRkUmVtb3RlVGV4dFRyYWNrKHRyYWNrKS50cmFjaztcblxuICAgIGlmICghdHJhY2suc3JjICYmIHRyYWNrLmN1ZXMpIHtcbiAgICAgIHRyYWNrLmN1ZXMuZm9yRWFjaChmdW5jdGlvbiAoY3VlKSB7XG4gICAgICAgIHJldHVybiBhZGRlZFRyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGVjaC50ZXh0VHJhY2tzKCk7XG59O1xuXG52YXIgdGV4dFRyYWNrQ29udmVydGVyID0geyB0ZXh0VHJhY2tzVG9Kc29uOiB0ZXh0VHJhY2tzVG9Kc29uLCBqc29uVG9UZXh0VHJhY2tzOiBqc29uVG9UZXh0VHJhY2tzLCB0cmFja1RvSnNvbl86IHRyYWNrVG9Kc29uXyB9O1xuXG4vKipcbiAqIEBmaWxlIG1vZGFsLWRpYWxvZy5qc1xuICovXG52YXIgTU9EQUxfQ0xBU1NfTkFNRSA9ICd2anMtbW9kYWwtZGlhbG9nJztcbnZhciBFU0MgPSAyNztcblxuLyoqXG4gKiBUaGUgYE1vZGFsRGlhbG9nYCBkaXNwbGF5cyBvdmVyIHRoZSB2aWRlbyBhbmQgaXRzIGNvbnRyb2xzLCB3aGljaCBibG9ja3NcbiAqIGludGVyYWN0aW9uIHdpdGggdGhlIHBsYXllciB1bnRpbCBpdCBpcyBjbG9zZWQuXG4gKlxuICogTW9kYWwgZGlhbG9ncyBpbmNsdWRlIGEgXCJDbG9zZVwiIGJ1dHRvbiBhbmQgd2lsbCBjbG9zZSB3aGVuIHRoYXQgYnV0dG9uXG4gKiBpcyBhY3RpdmF0ZWQgLSBvciB3aGVuIEVTQyBpcyBwcmVzc2VkIGFueXdoZXJlLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBNb2RhbERpYWxvZyA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1vZGFsRGlhbG9nLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBbb3B0aW9ucy5jb250ZW50PXVuZGVmaW5lZF1cbiAgICogICAgICAgIFByb3ZpZGUgY3VzdG9taXplZCBjb250ZW50IGZvciB0aGlzIG1vZGFsLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGVzY3JpcHRpb25dXG4gICAqICAgICAgICBBIHRleHQgZGVzY3JpcHRpb24gZm9yIHRoZSBtb2RhbCwgcHJpbWFyaWx5IGZvciBhY2Nlc3NpYmlsaXR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZpbGxBbHdheXM9ZmFsc2VdXG4gICAqICAgICAgICBOb3JtYWxseSwgbW9kYWxzIGFyZSBhdXRvbWF0aWNhbGx5IGZpbGxlZCBvbmx5IHRoZSBmaXJzdCB0aW1lXG4gICAqICAgICAgICB0aGV5IG9wZW4uIFRoaXMgdGVsbHMgdGhlIG1vZGFsIHRvIHJlZnJlc2ggaXRzIGNvbnRlbnRcbiAgICogICAgICAgIGV2ZXJ5IHRpbWUgaXQgb3BlbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbF1cbiAgICogICAgICAgIEEgdGV4dCBsYWJlbCBmb3IgdGhlIG1vZGFsLCBwcmltYXJpbHkgZm9yIGFjY2Vzc2liaWxpdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGVtcG9yYXJ5PXRydWVdXG4gICAqICAgICAgICBJZiBgdHJ1ZWAsIHRoZSBtb2RhbCBjYW4gb25seSBiZSBvcGVuZWQgb25jZTsgaXQgd2lsbCBiZVxuICAgKiAgICAgICAgZGlzcG9zZWQgYXMgc29vbiBhcyBpdCdzIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51bmNsb3NlYWJsZT1mYWxzZV1cbiAgICogICAgICAgIElmIGB0cnVlYCwgdGhlIHVzZXIgd2lsbCBub3QgYmUgYWJsZSB0byBjbG9zZSB0aGUgbW9kYWxcbiAgICogICAgICAgIHRocm91Z2ggdGhlIFVJIGluIHRoZSBub3JtYWwgd2F5cy4gUHJvZ3JhbW1hdGljIGNsb3NpbmcgaXNcbiAgICogICAgICAgIHN0aWxsIHBvc3NpYmxlLlxuICAgKi9cbiAgZnVuY3Rpb24gTW9kYWxEaWFsb2cocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9kYWxEaWFsb2cpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vcGVuZWRfID0gX3RoaXMuaGFzQmVlbk9wZW5lZF8gPSBfdGhpcy5oYXNCZWVuRmlsbGVkXyA9IGZhbHNlO1xuXG4gICAgX3RoaXMuY2xvc2VhYmxlKCFfdGhpcy5vcHRpb25zXy51bmNsb3NlYWJsZSk7XG4gICAgX3RoaXMuY29udGVudChfdGhpcy5vcHRpb25zXy5jb250ZW50KTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgY29udGVudEVsIGlzIGRlZmluZWQgQUZURVIgYW55IGNoaWxkcmVuIGFyZSBpbml0aWFsaXplZFxuICAgIC8vIGJlY2F1c2Ugd2Ugb25seSB3YW50IHRoZSBjb250ZW50cyBvZiB0aGUgbW9kYWwgaW4gdGhlIGNvbnRlbnRFbFxuICAgIC8vIChub3QgdGhlIFVJIGVsZW1lbnRzIGxpa2UgdGhlIGNsb3NlIGJ1dHRvbikuXG4gICAgX3RoaXMuY29udGVudEVsXyA9IGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IE1PREFMX0NMQVNTX05BTUUgKyAnLWNvbnRlbnQnXG4gICAgfSwge1xuICAgICAgcm9sZTogJ2RvY3VtZW50J1xuICAgIH0pO1xuXG4gICAgX3RoaXMuZGVzY0VsXyA9IGNyZWF0ZUVsKCdwJywge1xuICAgICAgY2xhc3NOYW1lOiBNT0RBTF9DTEFTU19OQU1FICsgJy1kZXNjcmlwdGlvbiB2anMtY29udHJvbC10ZXh0JyxcbiAgICAgIGlkOiBfdGhpcy5lbCgpLmdldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpXG4gICAgfSk7XG5cbiAgICB0ZXh0Q29udGVudChfdGhpcy5kZXNjRWxfLCBfdGhpcy5kZXNjcmlwdGlvbigpKTtcbiAgICBfdGhpcy5lbF8uYXBwZW5kQ2hpbGQoX3RoaXMuZGVzY0VsXyk7XG4gICAgX3RoaXMuZWxfLmFwcGVuZENoaWxkKF90aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBNb2RhbERpYWxvZ2AncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBET00gZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKSxcbiAgICAgIHRhYkluZGV4OiAtMVxuICAgIH0sIHtcbiAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogdGhpcy5pZCgpICsgJ19kZXNjcmlwdGlvbicsXG4gICAgICAnYXJpYS1oaWRkZW4nOiAndHJ1ZScsXG4gICAgICAnYXJpYS1sYWJlbCc6IHRoaXMubGFiZWwoKSxcbiAgICAgICdyb2xlJzogJ2RpYWxvZydcbiAgICB9KTtcbiAgfTtcblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5jb250ZW50RWxfID0gbnVsbDtcbiAgICB0aGlzLmRlc2NFbF8gPSBudWxsO1xuICAgIHRoaXMucHJldmlvdXNseUFjdGl2ZUVsXyA9IG51bGw7XG5cbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuIE1PREFMX0NMQVNTX05BTUUgKyAnIHZqcy1oaWRkZW4gJyArIF9Db21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlcyBga2V5ZG93bmAgZXZlbnRzIG9uIHRoZSBkb2N1bWVudCwgbG9va2luZyBmb3IgRVNDLCB3aGljaCBjbG9zZXNcbiAgICogdGhlIG1vZGFsLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBlXG4gICAqICAgICAgICBUaGUga2V5cHJlc3MgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudC5cbiAgICpcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGUpIHtcbiAgICBpZiAoZS53aGljaCA9PT0gRVNDICYmIHRoaXMuY2xvc2VhYmxlKCkpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhYmVsIHN0cmluZyBmb3IgdGhpcyBtb2RhbC4gUHJpbWFyaWx5IHVzZWQgZm9yIGFjY2Vzc2liaWxpdHkuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICB0aGUgbG9jYWxpemVkIG9yIHJhdyBsYWJlbCBvZiB0aGlzIG1vZGFsLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uIGxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubGFiZWwgfHwgJ01vZGFsIFdpbmRvdycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNjcmlwdGlvbiBzdHJpbmcgZm9yIHRoaXMgbW9kYWwuIFByaW1hcmlseSB1c2VkIGZvclxuICAgKiBhY2Nlc3NpYmlsaXR5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGxvY2FsaXplZCBvciByYXcgZGVzY3JpcHRpb24gb2YgdGhpcyBtb2RhbC5cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuZGVzY3JpcHRpb24gPSBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICB2YXIgZGVzYyA9IHRoaXMub3B0aW9uc18uZGVzY3JpcHRpb24gfHwgdGhpcy5sb2NhbGl6ZSgnVGhpcyBpcyBhIG1vZGFsIHdpbmRvdy4nKTtcblxuICAgIC8vIEFwcGVuZCBhIHVuaXZlcnNhbCBjbG9zZWFiaWxpdHkgbWVzc2FnZSBpZiB0aGUgbW9kYWwgaXMgY2xvc2VhYmxlLlxuICAgIGlmICh0aGlzLmNsb3NlYWJsZSgpKSB7XG4gICAgICBkZXNjICs9ICcgJyArIHRoaXMubG9jYWxpemUoJ1RoaXMgbW9kYWwgY2FuIGJlIGNsb3NlZCBieSBwcmVzc2luZyB0aGUgRXNjYXBlIGtleSBvciBhY3RpdmF0aW5nIHRoZSBjbG9zZSBidXR0b24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2M7XG4gIH07XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBtb2RhbC5cbiAgICpcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsb3BlblxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjbW9kYWxvcGVuXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiBvcGVuKCkge1xuICAgIGlmICghdGhpcy5vcGVuZWRfKSB7XG4gICAgICB2YXIgcGxheWVyID0gdGhpcy5wbGF5ZXIoKTtcblxuICAgICAgLyoqXG4gICAgICAgICogRmlyZWQganVzdCBiZWZvcmUgYSBgTW9kYWxEaWFsb2dgIGlzIG9wZW5lZC5cbiAgICAgICAgKlxuICAgICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbG9wZW5cbiAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZW1vZGFsb3BlbicpO1xuICAgICAgdGhpcy5vcGVuZWRfID0gdHJ1ZTtcblxuICAgICAgLy8gRmlsbCBjb250ZW50IGlmIHRoZSBtb2RhbCBoYXMgbmV2ZXIgb3BlbmVkIGJlZm9yZSBhbmRcbiAgICAgIC8vIG5ldmVyIGJlZW4gZmlsbGVkLlxuICAgICAgaWYgKHRoaXMub3B0aW9uc18uZmlsbEFsd2F5cyB8fCAhdGhpcy5oYXNCZWVuT3BlbmVkXyAmJiAhdGhpcy5oYXNCZWVuRmlsbGVkXykge1xuICAgICAgICB0aGlzLmZpbGwoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHBsYXllciB3YXMgcGxheWluZywgcGF1c2UgaXQgYW5kIHRha2Ugbm90ZSBvZiBpdHMgcHJldmlvdXNseVxuICAgICAgLy8gcGxheWluZyBzdGF0ZS5cbiAgICAgIHRoaXMud2FzUGxheWluZ18gPSAhcGxheWVyLnBhdXNlZCgpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zXy5wYXVzZU9uT3BlbiAmJiB0aGlzLndhc1BsYXlpbmdfKSB7XG4gICAgICAgIHBsYXllci5wYXVzZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jbG9zZWFibGUoKSkge1xuICAgICAgICB0aGlzLm9uKHRoaXMuZWxfLm93bmVyRG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhpZGUgY29udHJvbHMgYW5kIG5vdGUgaWYgdGhleSB3ZXJlIGVuYWJsZWQuXG4gICAgICB0aGlzLmhhZENvbnRyb2xzXyA9IHBsYXllci5jb250cm9scygpO1xuICAgICAgcGxheWVyLmNvbnRyb2xzKGZhbHNlKTtcblxuICAgICAgdGhpcy5zaG93KCk7XG4gICAgICB0aGlzLmNvbmRpdGlvbmFsRm9jdXNfKCk7XG4gICAgICB0aGlzLmVsKCkuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXG4gICAgICAvKipcbiAgICAgICAgKiBGaXJlZCBqdXN0IGFmdGVyIGEgYE1vZGFsRGlhbG9nYCBpcyBvcGVuZWQuXG4gICAgICAgICpcbiAgICAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjbW9kYWxvcGVuXG4gICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdtb2RhbG9wZW4nKTtcbiAgICAgIHRoaXMuaGFzQmVlbk9wZW5lZF8gPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSWYgdGhlIGBNb2RhbERpYWxvZ2AgaXMgY3VycmVudGx5IG9wZW4gb3IgY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbdmFsdWVdXG4gICAqICAgICAgICAgSWYgZ2l2ZW4sIGl0IHdpbGwgb3BlbiAoYHRydWVgKSBvciBjbG9zZSAoYGZhbHNlYCkgdGhlIG1vZGFsLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIHRoZSBjdXJyZW50IG9wZW4gc3RhdGUgb2YgdGhlIG1vZGFsZGlhbG9nXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLm9wZW5lZCA9IGZ1bmN0aW9uIG9wZW5lZCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgdGhpc1t2YWx1ZSA/ICdvcGVuJyA6ICdjbG9zZSddKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9wZW5lZF87XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbW9kYWwsIGRvZXMgbm90aGluZyBpZiB0aGUgYE1vZGFsRGlhbG9nYCBpc1xuICAgKiBub3Qgb3Blbi5cbiAgICpcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsY2xvc2VcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI21vZGFsY2xvc2VcbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMub3BlbmVkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGxheWVyID0gdGhpcy5wbGF5ZXIoKTtcblxuICAgIC8qKlxuICAgICAgKiBGaXJlZCBqdXN0IGJlZm9yZSBhIGBNb2RhbERpYWxvZ2AgaXMgY2xvc2VkLlxuICAgICAgKlxuICAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxjbG9zZVxuICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignYmVmb3JlbW9kYWxjbG9zZScpO1xuICAgIHRoaXMub3BlbmVkXyA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMud2FzUGxheWluZ18gJiYgdGhpcy5vcHRpb25zXy5wYXVzZU9uT3Blbikge1xuICAgICAgcGxheWVyLnBsYXkoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbG9zZWFibGUoKSkge1xuICAgICAgdGhpcy5vZmYodGhpcy5lbF8ub3duZXJEb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYWRDb250cm9sc18pIHtcbiAgICAgIHBsYXllci5jb250cm9scyh0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLmhpZGUoKTtcbiAgICB0aGlzLmVsKCkuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICAvKipcbiAgICAgICogRmlyZWQganVzdCBhZnRlciBhIGBNb2RhbERpYWxvZ2AgaXMgY2xvc2VkLlxuICAgICAgKlxuICAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjbW9kYWxjbG9zZVxuICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignbW9kYWxjbG9zZScpO1xuICAgIHRoaXMuY29uZGl0aW9uYWxCbHVyXygpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9uc18udGVtcG9yYXJ5KSB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHRvIHNlZSBpZiB0aGUgYE1vZGFsRGlhbG9nYCBpcyBjbG9zZWFibGUgdmlhIHRoZSBVSS5cbiAgICpcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW3ZhbHVlXVxuICAgKiAgICAgICAgIElmIGdpdmVuIGFzIGEgYm9vbGVhbiwgaXQgd2lsbCBzZXQgdGhlIGBjbG9zZWFibGVgIG9wdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBSZXR1cm5zIHRoZSBmaW5hbCB2YWx1ZSBvZiB0aGUgY2xvc2FibGUgb3B0aW9uLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jbG9zZWFibGUgPSBmdW5jdGlvbiBjbG9zZWFibGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHZhciBjbG9zZWFibGUgPSB0aGlzLmNsb3NlYWJsZV8gPSAhIXZhbHVlO1xuICAgICAgdmFyIGNsb3NlID0gdGhpcy5nZXRDaGlsZCgnY2xvc2VCdXR0b24nKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBiZWluZyBtYWRlIGNsb3NlYWJsZSBhbmQgaGFzIG5vIGNsb3NlIGJ1dHRvbiwgYWRkIG9uZS5cbiAgICAgIGlmIChjbG9zZWFibGUgJiYgIWNsb3NlKSB7XG5cbiAgICAgICAgLy8gVGhlIGNsb3NlIGJ1dHRvbiBzaG91bGQgYmUgYSBjaGlsZCBvZiB0aGUgbW9kYWwgLSBub3QgaXRzXG4gICAgICAgIC8vIGNvbnRlbnQgZWxlbWVudCwgc28gdGVtcG9yYXJpbHkgY2hhbmdlIHRoZSBjb250ZW50IGVsZW1lbnQuXG4gICAgICAgIHZhciB0ZW1wID0gdGhpcy5jb250ZW50RWxfO1xuXG4gICAgICAgIHRoaXMuY29udGVudEVsXyA9IHRoaXMuZWxfO1xuICAgICAgICBjbG9zZSA9IHRoaXMuYWRkQ2hpbGQoJ2Nsb3NlQnV0dG9uJywgeyBjb250cm9sVGV4dDogJ0Nsb3NlIE1vZGFsIERpYWxvZycgfSk7XG4gICAgICAgIHRoaXMuY29udGVudEVsXyA9IHRlbXA7XG4gICAgICAgIHRoaXMub24oY2xvc2UsICdjbG9zZScsIHRoaXMuY2xvc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIGJlaW5nIG1hZGUgdW5jbG9zZWFibGUgYW5kIGhhcyBhIGNsb3NlIGJ1dHRvbiwgcmVtb3ZlIGl0LlxuICAgICAgaWYgKCFjbG9zZWFibGUgJiYgY2xvc2UpIHtcbiAgICAgICAgdGhpcy5vZmYoY2xvc2UsICdjbG9zZScsIHRoaXMuY2xvc2UpO1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGNsb3NlKTtcbiAgICAgICAgY2xvc2UuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9zZWFibGVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaWxsIHRoZSBtb2RhbCdzIGNvbnRlbnQgZWxlbWVudCB3aXRoIHRoZSBtb2RhbCdzIFwiY29udGVudFwiIG9wdGlvbi5cbiAgICogVGhlIGNvbnRlbnQgZWxlbWVudCB3aWxsIGJlIGVtcHRpZWQgYmVmb3JlIHRoaXMgY2hhbmdlIHRha2VzIHBsYWNlLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCgpIHtcbiAgICB0aGlzLmZpbGxXaXRoKHRoaXMuY29udGVudCgpKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlsbCB0aGUgbW9kYWwncyBjb250ZW50IGVsZW1lbnQgd2l0aCBhcmJpdHJhcnkgY29udGVudC5cbiAgICogVGhlIGNvbnRlbnQgZWxlbWVudCB3aWxsIGJlIGVtcHRpZWQgYmVmb3JlIHRoaXMgY2hhbmdlIHRha2VzIHBsYWNlLlxuICAgKlxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxmaWxsXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNtb2RhbGZpbGxcbiAgICpcbiAgICogQHBhcmFtIHtNaXhlZH0gW2NvbnRlbnRdXG4gICAqICAgICAgICBUaGUgc2FtZSBydWxlcyBhcHBseSB0byB0aGlzIGFzIGFwcGx5IHRvIHRoZSBgY29udGVudGAgb3B0aW9uLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5maWxsV2l0aCA9IGZ1bmN0aW9uIGZpbGxXaXRoKGNvbnRlbnQpIHtcbiAgICB2YXIgY29udGVudEVsID0gdGhpcy5jb250ZW50RWwoKTtcbiAgICB2YXIgcGFyZW50RWwgPSBjb250ZW50RWwucGFyZW50Tm9kZTtcbiAgICB2YXIgbmV4dFNpYmxpbmdFbCA9IGNvbnRlbnRFbC5uZXh0U2libGluZztcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGp1c3QgYmVmb3JlIGEgYE1vZGFsRGlhbG9nYCBpcyBmaWxsZWQgd2l0aCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsZmlsbFxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZW1vZGFsZmlsbCcpO1xuICAgIHRoaXMuaGFzQmVlbkZpbGxlZF8gPSB0cnVlO1xuXG4gICAgLy8gRGV0YWNoIHRoZSBjb250ZW50IGVsZW1lbnQgZnJvbSB0aGUgRE9NIGJlZm9yZSBwZXJmb3JtaW5nXG4gICAgLy8gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG1vZGlmeWluZyB0aGUgbGl2ZSBET00gbXVsdGlwbGUgdGltZXMuXG4gICAgcGFyZW50RWwucmVtb3ZlQ2hpbGQoY29udGVudEVsKTtcbiAgICB0aGlzLmVtcHR5KCk7XG4gICAgaW5zZXJ0Q29udGVudChjb250ZW50RWwsIGNvbnRlbnQpO1xuICAgIC8qKlxuICAgICAqIEZpcmVkIGp1c3QgYWZ0ZXIgYSBgTW9kYWxEaWFsb2dgIGlzIGZpbGxlZCB3aXRoIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjbW9kYWxmaWxsXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignbW9kYWxmaWxsJyk7XG5cbiAgICAvLyBSZS1pbmplY3QgdGhlIHJlLWZpbGxlZCBjb250ZW50IGVsZW1lbnQuXG4gICAgaWYgKG5leHRTaWJsaW5nRWwpIHtcbiAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZShjb250ZW50RWwsIG5leHRTaWJsaW5nRWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChjb250ZW50RWwpO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBjbG9zZSBidXR0b24gaXMgbGFzdCBpbiB0aGUgZGlhbG9nIERPTVxuICAgIHZhciBjbG9zZUJ1dHRvbiA9IHRoaXMuZ2V0Q2hpbGQoJ2Nsb3NlQnV0dG9uJyk7XG5cbiAgICBpZiAoY2xvc2VCdXR0b24pIHtcbiAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKGNsb3NlQnV0dG9uLmVsXyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbXB0aWVzIHRoZSBjb250ZW50IGVsZW1lbnQuIFRoaXMgaGFwcGVucyBhbnl0aW1lIHRoZSBtb2RhbCBpcyBmaWxsZWQuXG4gICAqXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbGVtcHR5XG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNtb2RhbGVtcHR5XG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgLyoqXG4gICAgICogRmlyZWQganVzdCBiZWZvcmUgYSBgTW9kYWxEaWFsb2dgIGlzIGVtcHRpZWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxlbXB0eVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZW1vZGFsZW1wdHknKTtcbiAgICBlbXB0eUVsKHRoaXMuY29udGVudEVsKCkpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQganVzdCBhZnRlciBhIGBNb2RhbERpYWxvZ2AgaXMgZW1wdGllZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNtb2RhbGVtcHR5XG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignbW9kYWxlbXB0eScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIG1vZGFsIGNvbnRlbnQsIHdoaWNoIGdldHMgbm9ybWFsaXplZCBiZWZvcmUgYmVpbmdcbiAgICogcmVuZGVyZWQgaW50byB0aGUgRE9NLlxuICAgKlxuICAgKiBUaGlzIGRvZXMgbm90IHVwZGF0ZSB0aGUgRE9NIG9yIGZpbGwgdGhlIG1vZGFsLCBidXQgaXQgaXMgY2FsbGVkIGR1cmluZ1xuICAgKiB0aGF0IHByb2Nlc3MuXG4gICAqXG4gICAqIEBwYXJhbSAge01peGVkfSBbdmFsdWVdXG4gICAqICAgICAgICAgSWYgZGVmaW5lZCwgc2V0cyB0aGUgaW50ZXJuYWwgY29udGVudCB2YWx1ZSB0byBiZSB1c2VkIG9uIHRoZVxuICAgKiAgICAgICAgIG5leHQgY2FsbChzKSB0byBgZmlsbGAuIFRoaXMgdmFsdWUgaXMgbm9ybWFsaXplZCBiZWZvcmUgYmVpbmdcbiAgICogICAgICAgICBpbnNlcnRlZC4gVG8gXCJjbGVhclwiIHRoZSBpbnRlcm5hbCBjb250ZW50IHZhbHVlLCBwYXNzIGBudWxsYC5cbiAgICpcbiAgICogQHJldHVybiB7TWl4ZWR9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgY29udGVudCBvZiB0aGUgbW9kYWwgZGlhbG9nXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiBjb250ZW50KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuY29udGVudF8gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGVudF87XG4gIH07XG5cbiAgLyoqXG4gICAqIGNvbmRpdGlvbmFsbHkgZm9jdXMgdGhlIG1vZGFsIGRpYWxvZyBpZiBmb2N1cyB3YXMgcHJldmlvdXNseSBvbiB0aGUgcGxheWVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jb25kaXRpb25hbEZvY3VzXyA9IGZ1bmN0aW9uIGNvbmRpdGlvbmFsRm9jdXNfKCkge1xuICAgIHZhciBhY3RpdmVFbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgdmFyIHBsYXllckVsID0gdGhpcy5wbGF5ZXJfLmVsXztcblxuICAgIHRoaXMucHJldmlvdXNseUFjdGl2ZUVsXyA9IG51bGw7XG5cbiAgICBpZiAocGxheWVyRWwuY29udGFpbnMoYWN0aXZlRWwpIHx8IHBsYXllckVsID09PSBhY3RpdmVFbCkge1xuICAgICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfID0gYWN0aXZlRWw7XG5cbiAgICAgIHRoaXMuZm9jdXMoKTtcblxuICAgICAgdGhpcy5vbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogY29uZGl0aW9uYWxseSBibHVyIHRoZSBlbGVtZW50IGFuZCByZWZvY3VzIHRoZSBsYXN0IGZvY3VzZWQgZWxlbWVudFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jb25kaXRpb25hbEJsdXJfID0gZnVuY3Rpb24gY29uZGl0aW9uYWxCbHVyXygpIHtcbiAgICBpZiAodGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfKSB7XG4gICAgICB0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8uZm9jdXMoKTtcbiAgICAgIHRoaXMucHJldmlvdXNseUFjdGl2ZUVsXyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5vZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duKTtcbiAgfTtcblxuICAvKipcbiAgICogS2V5ZG93biBoYW5kbGVyLiBBdHRhY2hlZCB3aGVuIG1vZGFsIGlzIGZvY3VzZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAvLyBleGl0IGVhcmx5IGlmIGl0IGlzbid0IGEgdGFiIGtleVxuICAgIGlmIChldmVudC53aGljaCAhPT0gOSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmb2N1c2FibGVFbHMgPSB0aGlzLmZvY3VzYWJsZUVsc18oKTtcbiAgICB2YXIgYWN0aXZlRWwgPSB0aGlzLmVsXy5xdWVyeVNlbGVjdG9yKCc6Zm9jdXMnKTtcbiAgICB2YXIgZm9jdXNJbmRleCA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9jdXNhYmxlRWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0aXZlRWwgPT09IGZvY3VzYWJsZUVsc1tpXSkge1xuICAgICAgICBmb2N1c0luZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuZWxfKSB7XG4gICAgICBmb2N1c0luZGV4ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgZm9jdXNJbmRleCA9PT0gMCkge1xuICAgICAgZm9jdXNhYmxlRWxzW2ZvY3VzYWJsZUVscy5sZW5ndGggLSAxXS5mb2N1cygpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2UgaWYgKCFldmVudC5zaGlmdEtleSAmJiBmb2N1c0luZGV4ID09PSBmb2N1c2FibGVFbHMubGVuZ3RoIC0gMSkge1xuICAgICAgZm9jdXNhYmxlRWxzWzBdLmZvY3VzKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogZ2V0IGFsbCBmb2N1c2FibGUgZWxlbWVudHNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuZm9jdXNhYmxlRWxzXyA9IGZ1bmN0aW9uIGZvY3VzYWJsZUVsc18oKSB7XG4gICAgdmFyIGFsbENoaWxkcmVuID0gdGhpcy5lbF8ucXVlcnlTZWxlY3RvckFsbCgnKicpO1xuXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChhbGxDaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gKGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxBbmNob3JFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxBcmVhRWxlbWVudCkgJiYgY2hpbGQuaGFzQXR0cmlidXRlKCdocmVmJykgfHwgKGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxJbnB1dEVsZW1lbnQgfHwgY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTFNlbGVjdEVsZW1lbnQgfHwgY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTFRleHRBcmVhRWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MQnV0dG9uRWxlbWVudCkgJiYgIWNoaWxkLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MT2JqZWN0RWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MRW1iZWRFbGVtZW50IHx8IGNoaWxkLmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSAmJiBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgIT09IC0xIHx8IGNoaWxkLmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1vZGFsRGlhbG9nO1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgYE1vZGFsRGlhbG9nYCBkZWZhdWx0IG9wdGlvbnMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Nb2RhbERpYWxvZy5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIHBhdXNlT25PcGVuOiB0cnVlLFxuICB0ZW1wb3Jhcnk6IHRydWVcbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTW9kYWxEaWFsb2cnLCBNb2RhbERpYWxvZyk7XG5cbi8qKlxuICogQGZpbGUgdHJhY2stbGlzdC5qc1xuICovXG4vKipcbiAqIENvbW1vbiBmdW5jdGlvbmFsaXkgYmV0d2VlbiB7QGxpbmsgVGV4dFRyYWNrTGlzdH0sIHtAbGluayBBdWRpb1RyYWNrTGlzdH0sIGFuZFxuICoge0BsaW5rIFZpZGVvVHJhY2tMaXN0fVxuICpcbiAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XG4gKi9cblxudmFyIFRyYWNrTGlzdCA9IGZ1bmN0aW9uIChfRXZlbnRUYXJnZXQpIHtcbiAgaW5oZXJpdHMoVHJhY2tMaXN0LCBfRXZlbnRUYXJnZXQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge1RyYWNrW119IHRyYWNrc1xuICAgKiAgICAgICAgQSBsaXN0IG9mIHRyYWNrcyB0byBpbml0aWFsaXplIHRoZSBsaXN0IHdpdGguXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbbGlzdF1cbiAgICogICAgICAgIFRoZSBjaGlsZCBvYmplY3Qgd2l0aCBpbmhlcml0YW5jZSBkb25lIG1hbnVhbGx5IGZvciBpZTguXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZnVuY3Rpb24gVHJhY2tMaXN0KCkge1xuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuXG4gICAgdmFyIF9yZXQ7XG5cbiAgICB2YXIgbGlzdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFja0xpc3QpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRUYXJnZXQuY2FsbCh0aGlzKSk7XG5cbiAgICBpZiAoIWxpc3QpIHtcbiAgICAgIGxpc3QgPSBfdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgaWYgKElTX0lFOCkge1xuICAgICAgICBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gVHJhY2tMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgICBsaXN0W3Byb3BdID0gVHJhY2tMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0LnRyYWNrc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUcmFja0xpc3RcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGxlbmd0aFxuICAgICAqICAgICAgICAgVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGBUcmFja2BzIGluIHRoZSB0aGlzIFRyYWNraXN0LlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnbGVuZ3RoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrc18ubGVuZ3RoO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3QuYWRkVHJhY2sodHJhY2tzW2ldKTtcbiAgICB9XG5cbiAgICAvLyBtdXN0IHJldHVybiB0aGUgb2JqZWN0LCBhcyBmb3IgaWU4IGl0IHdpbGwgbm90IGJlIHRoaXNcbiAgICAvLyBidXQgYSByZWZlcmVuY2UgdG8gYSBkb2N1bWVudCBvYmplY3RcbiAgICByZXR1cm4gX3JldCA9IGxpc3QsIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHtAbGluayBUcmFja30gdG8gdGhlIGBUcmFja0xpc3RgXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUaGUgYXVkaW8sIHZpZGVvLCBvciB0ZXh0IHRyYWNrIHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICpcbiAgICogQGZpcmVzIFRyYWNrTGlzdCNhZGR0cmFja1xuICAgKi9cblxuXG4gIFRyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaykge1xuICAgIHZhciBpbmRleCA9IHRoaXMudHJhY2tzXy5sZW5ndGg7XG5cbiAgICBpZiAoISgnJyArIGluZGV4IGluIHRoaXMpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzX1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERvIG5vdCBhZGQgZHVwbGljYXRlIHRyYWNrc1xuICAgIGlmICh0aGlzLnRyYWNrc18uaW5kZXhPZih0cmFjaykgPT09IC0xKSB7XG4gICAgICB0aGlzLnRyYWNrc18ucHVzaCh0cmFjayk7XG4gICAgICAvKipcbiAgICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgdHJhY2sgaXMgYWRkZWQgdG8gYSB0cmFjayBsaXN0LlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBUcmFja0xpc3QjYWRkdHJhY2tcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqIEBwcm9wZXJ0eSB7VHJhY2t9IHRyYWNrXG4gICAgICAgKiAgICAgICAgICAgQSByZWZlcmVuY2UgdG8gdHJhY2sgdGhhdCB3YXMgYWRkZWQuXG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcih7XG4gICAgICAgIHRyYWNrOiB0cmFjayxcbiAgICAgICAgdHlwZTogJ2FkZHRyYWNrJ1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB7QGxpbmsgVHJhY2t9IGZyb20gdGhlIGBUcmFja0xpc3RgXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhY2t9IHJ0cmFja1xuICAgKiAgICAgICAgVGhlIGF1ZGlvLCB2aWRlbywgb3IgdGV4dCB0cmFjayB0byByZW1vdmUgZnJvbSB0aGUgbGlzdC5cbiAgICpcbiAgICogQGZpcmVzIFRyYWNrTGlzdCNyZW1vdmV0cmFja1xuICAgKi9cblxuXG4gIFRyYWNrTGlzdC5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhydHJhY2spIHtcbiAgICB2YXIgdHJhY2sgPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGhpc1tpXSA9PT0gcnRyYWNrKSB7XG4gICAgICAgIHRyYWNrID0gdGhpc1tpXTtcbiAgICAgICAgaWYgKHRyYWNrLm9mZikge1xuICAgICAgICAgIHRyYWNrLm9mZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmFja3NfLnNwbGljZShpLCAxKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYSB0cmFjayBpcyByZW1vdmVkIGZyb20gdHJhY2sgbGlzdC5cbiAgICAgKlxuICAgICAqIEBldmVudCBUcmFja0xpc3QjcmVtb3ZldHJhY2tcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICogQHByb3BlcnR5IHtUcmFja30gdHJhY2tcbiAgICAgKiAgICAgICAgICAgQSByZWZlcmVuY2UgdG8gdHJhY2sgdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoe1xuICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgdHlwZTogJ3JlbW92ZXRyYWNrJ1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBUcmFjayBmcm9tIHRoZSBUcmFja0xpc3QgYnkgYSB0cmFja3MgaWRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gdGhlIGlkIG9mIHRoZSB0cmFjayB0byBnZXRcbiAgICogQG1ldGhvZCBnZXRUcmFja0J5SWRcbiAgICogQHJldHVybiB7VHJhY2t9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVHJhY2tMaXN0LnByb3RvdHlwZS5nZXRUcmFja0J5SWQgPSBmdW5jdGlvbiBnZXRUcmFja0J5SWQoaWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRoaXNbaV07XG5cbiAgICAgIGlmICh0cmFjay5pZCA9PT0gaWQpIHtcbiAgICAgICAgcmVzdWx0ID0gdHJhY2s7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFRyYWNrTGlzdDtcbn0oRXZlbnRUYXJnZXQpO1xuXG4vKipcbiAqIFRyaWdnZXJlZCB3aGVuIGEgZGlmZmVyZW50IHRyYWNrIGlzIHNlbGVjdGVkL2VuYWJsZWQuXG4gKlxuICogQGV2ZW50IFRyYWNrTGlzdCNjaGFuZ2VcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuXG4vKipcbiAqIEV2ZW50cyB0aGF0IGNhbiBiZSBjYWxsZWQgd2l0aCBvbiArIGV2ZW50TmFtZS4gU2VlIHtAbGluayBFdmVudEhhbmRsZXJ9LlxuICpcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBUcmFja0xpc3QjYWxsb3dlZEV2ZW50c19cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5UcmFja0xpc3QucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge1xuICBjaGFuZ2U6ICdjaGFuZ2UnLFxuICBhZGR0cmFjazogJ2FkZHRyYWNrJyxcbiAgcmVtb3ZldHJhY2s6ICdyZW1vdmV0cmFjaydcbn07XG5cbi8vIGVtdWxhdGUgYXR0cmlidXRlIEV2ZW50SGFuZGxlciBzdXBwb3J0IHRvIGFsbG93IGZvciBmZWF0dXJlIGRldGVjdGlvblxuZm9yICh2YXIgZXZlbnQgaW4gVHJhY2tMaXN0LnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzXykge1xuICBUcmFja0xpc3QucHJvdG90eXBlWydvbicgKyBldmVudF0gPSBudWxsO1xufVxuXG4vKipcbiAqIEBmaWxlIGF1ZGlvLXRyYWNrLWxpc3QuanNcbiAqL1xuLyoqXG4gKiBBbnl3aGVyZSB3ZSBjYWxsIHRoaXMgZnVuY3Rpb24gd2UgZGl2ZXJnZSBmcm9tIHRoZSBzcGVjXG4gKiBhcyB3ZSBvbmx5IHN1cHBvcnQgb25lIGVuYWJsZWQgYXVkaW90cmFjayBhdCBhIHRpbWVcbiAqXG4gKiBAcGFyYW0ge0F1ZGlvVHJhY2tMaXN0fSBsaXN0XG4gKiAgICAgICAgbGlzdCB0byB3b3JrIG9uXG4gKlxuICogQHBhcmFtIHtBdWRpb1RyYWNrfSB0cmFja1xuICogICAgICAgIFRoZSB0cmFjayB0byBza2lwXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGRpc2FibGVPdGhlcnMgPSBmdW5jdGlvbiBkaXNhYmxlT3RoZXJzKGxpc3QsIHRyYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LmtleXMobGlzdFtpXSkubGVuZ3RoIHx8IHRyYWNrLmlkID09PSBsaXN0W2ldLmlkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gYW5vdGhlciBhdWRpbyB0cmFjayBpcyBlbmFibGVkLCBkaXNhYmxlIGl0XG4gICAgbGlzdFtpXS5lbmFibGVkID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgbGlzdCBvZiB7QGxpbmsgQXVkaW9UcmFja30gZm9yIGEgbWVkaWEgZmlsZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjYXVkaW90cmFja2xpc3R9XG4gKiBAZXh0ZW5kcyBUcmFja0xpc3RcbiAqL1xuXG52YXIgQXVkaW9UcmFja0xpc3QgPSBmdW5jdGlvbiAoX1RyYWNrTGlzdCkge1xuICBpbmhlcml0cyhBdWRpb1RyYWNrTGlzdCwgX1RyYWNrTGlzdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2tbXX0gW3RyYWNrcz1bXV1cbiAgICogICAgICAgIEEgbGlzdCBvZiBgQXVkaW9UcmFja2AgdG8gaW5zdGFudGlhdGUgdGhlIGxpc3Qgd2l0aC5cbiAgICovXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2tMaXN0KCkge1xuICAgIHZhciBfdGhpcywgX3JldDtcblxuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvVHJhY2tMaXN0KTtcblxuICAgIHZhciBsaXN0ID0gdm9pZCAwO1xuXG4gICAgLy8gbWFrZSBzdXJlIG9ubHkgMSB0cmFjayBpcyBlbmFibGVkXG4gICAgLy8gc29ydGVkIGZyb20gbGFzdCBpbmRleCB0byBmaXJzdCBpbmRleFxuICAgIGZvciAodmFyIGkgPSB0cmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0cmFja3NbaV0uZW5hYmxlZCkge1xuICAgICAgICBkaXNhYmxlT3RoZXJzKHRyYWNrcywgdHJhY2tzW2ldKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSUU4IGZvcmNlcyB1cyB0byBpbXBsZW1lbnQgaW5oZXJpdGFuY2Ugb3Vyc2VsdmVzXG4gICAgLy8gYXMgaXQgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QuZGVmaW5lUHJvcGVydHkgcHJvcGVybHlcbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W3Byb3BdID0gVHJhY2tMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gQXVkaW9UcmFja0xpc3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChfcHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbX3Byb3BdID0gQXVkaW9UcmFja0xpc3QucHJvdG90eXBlW19wcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpc3QgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0xpc3QuY2FsbCh0aGlzLCB0cmFja3MsIGxpc3QpKSwgX3RoaXMpO1xuICAgIGxpc3QuY2hhbmdpbmdfID0gZmFsc2U7XG5cbiAgICByZXR1cm4gX3JldCA9IGxpc3QsIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiB7QGxpbmsgQXVkaW9UcmFja30gdG8gdGhlIGBBdWRpb1RyYWNrTGlzdGAuXG4gICAqXG4gICAqIEBwYXJhbSB7QXVkaW9UcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSBBdWRpb1RyYWNrIHRvIGFkZCB0byB0aGUgbGlzdFxuICAgKlxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I2FkZHRyYWNrXG4gICAqL1xuXG5cbiAgQXVkaW9UcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2spIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmICh0cmFjay5lbmFibGVkKSB7XG4gICAgICBkaXNhYmxlT3RoZXJzKHRoaXMsIHRyYWNrKTtcbiAgICB9XG5cbiAgICBfVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrKTtcbiAgICAvLyBuYXRpdmUgdHJhY2tzIGRvbid0IGhhdmUgdGhpc1xuICAgIGlmICghdHJhY2suYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaXN0ZW5zIEF1ZGlvVHJhY2sjZW5hYmxlZGNoYW5nZVxuICAgICAqIEBmaXJlcyBUcmFja0xpc3QjY2hhbmdlXG4gICAgICovXG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5hYmxlZGNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHdoZW4gd2UgYXJlIGRpc2FibGluZyBvdGhlciB0cmFja3MgKHNpbmNlIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1vcmUgdGhhbiBvbmUgdHJhY2sgYXQgYSB0aW1lKSB3ZSB3aWxsIHNldCBjaGFuZ2luZ19cbiAgICAgIC8vIHRvIHRydWUgc28gdGhhdCB3ZSBkb24ndCB0cmlnZ2VyIGFkZGl0aW9uYWwgY2hhbmdlIGV2ZW50c1xuICAgICAgaWYgKF90aGlzMi5jaGFuZ2luZ18pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3RoaXMyLmNoYW5naW5nXyA9IHRydWU7XG4gICAgICBkaXNhYmxlT3RoZXJzKF90aGlzMiwgdHJhY2spO1xuICAgICAgX3RoaXMyLmNoYW5naW5nXyA9IGZhbHNlO1xuICAgICAgX3RoaXMyLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBBdWRpb1RyYWNrTGlzdDtcbn0oVHJhY2tMaXN0KTtcblxuLyoqXG4gKiBAZmlsZSB2aWRlby10cmFjay1saXN0LmpzXG4gKi9cbi8qKlxuICogVW4tc2VsZWN0IGFsbCBvdGhlciB7QGxpbmsgVmlkZW9UcmFja31zIHRoYXQgYXJlIHNlbGVjdGVkLlxuICpcbiAqIEBwYXJhbSB7VmlkZW9UcmFja0xpc3R9IGxpc3RcbiAqICAgICAgICBsaXN0IHRvIHdvcmsgb25cbiAqXG4gKiBAcGFyYW0ge1ZpZGVvVHJhY2t9IHRyYWNrXG4gKiAgICAgICAgVGhlIHRyYWNrIHRvIHNraXBcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZGlzYWJsZU90aGVycyQxID0gZnVuY3Rpb24gZGlzYWJsZU90aGVycyhsaXN0LCB0cmFjaykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIU9iamVjdC5rZXlzKGxpc3RbaV0pLmxlbmd0aCB8fCB0cmFjay5pZCA9PT0gbGlzdFtpXS5pZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIGFub3RoZXIgdmlkZW8gdHJhY2sgaXMgZW5hYmxlZCwgZGlzYWJsZSBpdFxuICAgIGxpc3RbaV0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgY3VycmVudCBsaXN0IG9mIHtAbGluayBWaWRlb1RyYWNrfSBmb3IgYSB2aWRlby5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdmlkZW90cmFja2xpc3R9XG4gKiBAZXh0ZW5kcyBUcmFja0xpc3RcbiAqL1xuXG52YXIgVmlkZW9UcmFja0xpc3QgPSBmdW5jdGlvbiAoX1RyYWNrTGlzdCkge1xuICBpbmhlcml0cyhWaWRlb1RyYWNrTGlzdCwgX1RyYWNrTGlzdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1ZpZGVvVHJhY2tbXX0gW3RyYWNrcz1bXV1cbiAgICogICAgICAgIEEgbGlzdCBvZiBgVmlkZW9UcmFja2AgdG8gaW5zdGFudGlhdGUgdGhlIGxpc3Qgd2l0aC5cbiAgICovXG4gIGZ1bmN0aW9uIFZpZGVvVHJhY2tMaXN0KCkge1xuICAgIHZhciBfdGhpcywgX3JldDtcblxuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZGVvVHJhY2tMaXN0KTtcblxuICAgIHZhciBsaXN0ID0gdm9pZCAwO1xuXG4gICAgLy8gbWFrZSBzdXJlIG9ubHkgMSB0cmFjayBpcyBlbmFibGVkXG4gICAgLy8gc29ydGVkIGZyb20gbGFzdCBpbmRleCB0byBmaXJzdCBpbmRleFxuICAgIGZvciAodmFyIGkgPSB0cmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0cmFja3NbaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgZGlzYWJsZU90aGVycyQxKHRyYWNrcywgdHJhY2tzW2ldKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSUU4IGZvcmNlcyB1cyB0byBpbXBsZW1lbnQgaW5oZXJpdGFuY2Ugb3Vyc2VsdmVzXG4gICAgLy8gYXMgaXQgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QuZGVmaW5lUHJvcGVydHkgcHJvcGVybHlcbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W3Byb3BdID0gVHJhY2tMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gVmlkZW9UcmFja0xpc3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChfcHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbX3Byb3BdID0gVmlkZW9UcmFja0xpc3QucHJvdG90eXBlW19wcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpc3QgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0xpc3QuY2FsbCh0aGlzLCB0cmFja3MsIGxpc3QpKSwgX3RoaXMpO1xuICAgIGxpc3QuY2hhbmdpbmdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFZpZGVvVHJhY2tMaXN0I3NlbGVjdGVkSW5kZXhcbiAgICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBzZWxlY3RlZCB7QGxpbmsgVmlkZW9UcmFja2B9LlxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnc2VsZWN0ZWRJbmRleCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBpZiAodGhpc1tfaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKCkge31cbiAgICB9KTtcblxuICAgIHJldHVybiBfcmV0ID0gbGlzdCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEge0BsaW5rIFZpZGVvVHJhY2t9IHRvIHRoZSBgVmlkZW9UcmFja0xpc3RgLlxuICAgKlxuICAgKiBAcGFyYW0ge1ZpZGVvVHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUaGUgVmlkZW9UcmFjayB0byBhZGQgdG8gdGhlIGxpc3RcbiAgICpcbiAgICogQGZpcmVzIFRyYWNrTGlzdCNhZGR0cmFja1xuICAgKi9cblxuXG4gIFZpZGVvVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAodHJhY2suc2VsZWN0ZWQpIHtcbiAgICAgIGRpc2FibGVPdGhlcnMkMSh0aGlzLCB0cmFjayk7XG4gICAgfVxuXG4gICAgX1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjayk7XG4gICAgLy8gbmF0aXZlIHRyYWNrcyBkb24ndCBoYXZlIHRoaXNcbiAgICBpZiAoIXRyYWNrLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGlzdGVucyBWaWRlb1RyYWNrI3NlbGVjdGVkY2hhbmdlXG4gICAgICogQGZpcmVzIFRyYWNrTGlzdCNjaGFuZ2VcbiAgICAgKi9cbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RlZGNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpczIuY2hhbmdpbmdfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF90aGlzMi5jaGFuZ2luZ18gPSB0cnVlO1xuICAgICAgZGlzYWJsZU90aGVycyQxKF90aGlzMiwgdHJhY2spO1xuICAgICAgX3RoaXMyLmNoYW5naW5nXyA9IGZhbHNlO1xuICAgICAgX3RoaXMyLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBWaWRlb1RyYWNrTGlzdDtcbn0oVHJhY2tMaXN0KTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWxpc3QuanNcbiAqL1xuLyoqXG4gKiBUaGUgY3VycmVudCBsaXN0IG9mIHtAbGluayBUZXh0VHJhY2t9IGZvciBhIG1lZGlhIGZpbGUuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3RleHR0cmFja2xpc3R9XG4gKiBAZXh0ZW5kcyBUcmFja0xpc3RcbiAqL1xuXG52YXIgVGV4dFRyYWNrTGlzdCA9IGZ1bmN0aW9uIChfVHJhY2tMaXN0KSB7XG4gIGluaGVyaXRzKFRleHRUcmFja0xpc3QsIF9UcmFja0xpc3QpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2tbXX0gW3RyYWNrcz1bXV1cbiAgICogICAgICAgIEEgbGlzdCBvZiBgVGV4dFRyYWNrYCB0byBpbnN0YW50aWF0ZSB0aGUgbGlzdCB3aXRoLlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrTGlzdCgpIHtcbiAgICB2YXIgX3RoaXMsIF9yZXQ7XG5cbiAgICB2YXIgdHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tMaXN0KTtcblxuICAgIHZhciBsaXN0ID0gdm9pZCAwO1xuXG4gICAgLy8gSUU4IGZvcmNlcyB1cyB0byBpbXBsZW1lbnQgaW5oZXJpdGFuY2Ugb3Vyc2VsdmVzXG4gICAgLy8gYXMgaXQgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QuZGVmaW5lUHJvcGVydHkgcHJvcGVybHlcbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W3Byb3BdID0gVHJhY2tMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gVGV4dFRyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKF9wcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtfcHJvcF0gPSBUZXh0VHJhY2tMaXN0LnByb3RvdHlwZVtfcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0ID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhY2tMaXN0LmNhbGwodGhpcywgdHJhY2tzLCBsaXN0KSksIF90aGlzKTtcbiAgICByZXR1cm4gX3JldCA9IGxpc3QsIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHtAbGluayBUZXh0VHJhY2t9IHRvIHRoZSBgVGV4dFRyYWNrTGlzdGBcbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUaGUgdGV4dCB0cmFjayB0byBhZGQgdG8gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBmaXJlcyBUcmFja0xpc3QjYWRkdHJhY2tcbiAgICovXG5cblxuICBUZXh0VHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgX1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjayk7XG5cbiAgICAvKipcbiAgICAgKiBAbGlzdGVucyBUZXh0VHJhY2sjbW9kZWNoYW5nZVxuICAgICAqIEBmaXJlcyBUcmFja0xpc3QjY2hhbmdlXG4gICAgICovXG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIGJpbmQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICB9KSk7XG5cbiAgICB2YXIgbm9uTGFuZ3VhZ2VUZXh0VHJhY2tLaW5kID0gWydtZXRhZGF0YScsICdjaGFwdGVycyddO1xuXG4gICAgaWYgKG5vbkxhbmd1YWdlVGV4dFRyYWNrS2luZC5pbmRleE9mKHRyYWNrLmtpbmQpID09PSAtMSkge1xuICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIGJpbmQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3NlbGVjdGVkbGFuZ3VhZ2VjaGFuZ2UnKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFja0xpc3Q7XG59KFRyYWNrTGlzdCk7XG5cbi8qKlxuICogQGZpbGUgaHRtbC10cmFjay1lbGVtZW50LWxpc3QuanNcbiAqL1xuXG4vKipcbiAqIFRoZSBjdXJyZW50IGxpc3Qgb2Yge0BsaW5rIEh0bWxUcmFja0VsZW1lbnR9cy5cbiAqL1xuXG52YXIgSHRtbFRyYWNrRWxlbWVudExpc3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0h0bWxUcmFja0VsZW1lbnRbXX0gW3RyYWNrcz1bXV1cbiAgICogICAgICAgIEEgbGlzdCBvZiBgSHRtbFRyYWNrRWxlbWVudGAgdG8gaW5zdGFudGlhdGUgdGhlIGxpc3Qgd2l0aC5cbiAgICovXG4gIGZ1bmN0aW9uIEh0bWxUcmFja0VsZW1lbnRMaXN0KCkge1xuICAgIHZhciB0cmFja0VsZW1lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBIdG1sVHJhY2tFbGVtZW50TGlzdCk7XG5cbiAgICB2YXIgbGlzdCA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBIdG1sVHJhY2tFbGVtZW50TGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W3Byb3BdID0gSHRtbFRyYWNrRWxlbWVudExpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGlzdC50cmFja0VsZW1lbnRzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIEh0bWxUcmFja0VsZW1lbnRMaXN0XG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBsZW5ndGhcbiAgICAgKiAgICAgICAgIFRoZSBjdXJyZW50IG51bWJlciBvZiBgVHJhY2tgcyBpbiB0aGUgdGhpcyBUcmFja2lzdC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGlzdCwgJ2xlbmd0aCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFja0VsZW1lbnRzXy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdHJhY2tFbGVtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgbGlzdC5hZGRUcmFja0VsZW1lbnRfKHRyYWNrRWxlbWVudHNbaV0pO1xuICAgIH1cblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4ge0BsaW5rIEh0bWxUcmFja0VsZW1lbnR9IHRvIHRoZSBgSHRtbFRyYWNrRWxlbWVudExpc3RgXG4gICAqXG4gICAqIEBwYXJhbSB7SHRtbFRyYWNrRWxlbWVudH0gdHJhY2tFbGVtZW50XG4gICAqICAgICAgICBUaGUgdHJhY2sgZWxlbWVudCB0byBhZGQgdG8gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgSHRtbFRyYWNrRWxlbWVudExpc3QucHJvdG90eXBlLmFkZFRyYWNrRWxlbWVudF8gPSBmdW5jdGlvbiBhZGRUcmFja0VsZW1lbnRfKHRyYWNrRWxlbWVudCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudHJhY2tFbGVtZW50c18ubGVuZ3RoO1xuXG4gICAgaWYgKCEoJycgKyBpbmRleCBpbiB0aGlzKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYWNrRWxlbWVudHNfW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IGFkZCBkdXBsaWNhdGUgZWxlbWVudHNcbiAgICBpZiAodGhpcy50cmFja0VsZW1lbnRzXy5pbmRleE9mKHRyYWNrRWxlbWVudCkgPT09IC0xKSB7XG4gICAgICB0aGlzLnRyYWNrRWxlbWVudHNfLnB1c2godHJhY2tFbGVtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudH0gZnJvbSB0aGUgYEh0bWxUcmFja0VsZW1lbnRMaXN0YCBnaXZlbiBhblxuICAgKiB7QGxpbmsgVGV4dFRyYWNrfS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUaGUgdHJhY2sgYXNzb2NpYXRlZCB3aXRoIGEgdHJhY2sgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7SHRtbFRyYWNrRWxlbWVudHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgVGhlIHRyYWNrIGVsZW1lbnQgdGhhdCB3YXMgZm91bmQgb3IgdW5kZWZpbmVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIEh0bWxUcmFja0VsZW1lbnRMaXN0LnByb3RvdHlwZS5nZXRUcmFja0VsZW1lbnRCeVRyYWNrXyA9IGZ1bmN0aW9uIGdldFRyYWNrRWxlbWVudEJ5VHJhY2tfKHRyYWNrKSB7XG4gICAgdmFyIHRyYWNrRWxlbWVudF8gPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy50cmFja0VsZW1lbnRzXy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyYWNrID09PSB0aGlzLnRyYWNrRWxlbWVudHNfW2ldLnRyYWNrKSB7XG4gICAgICAgIHRyYWNrRWxlbWVudF8gPSB0aGlzLnRyYWNrRWxlbWVudHNfW2ldO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cmFja0VsZW1lbnRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudH0gZnJvbSB0aGUgYEh0bWxUcmFja0VsZW1lbnRMaXN0YFxuICAgKlxuICAgKiBAcGFyYW0ge0h0bWxUcmFja0VsZW1lbnR9IHRyYWNrRWxlbWVudFxuICAgKiAgICAgICAgVGhlIHRyYWNrIGVsZW1lbnQgdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgSHRtbFRyYWNrRWxlbWVudExpc3QucHJvdG90eXBlLnJlbW92ZVRyYWNrRWxlbWVudF8gPSBmdW5jdGlvbiByZW1vdmVUcmFja0VsZW1lbnRfKHRyYWNrRWxlbWVudCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnRyYWNrRWxlbWVudHNfLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJhY2tFbGVtZW50ID09PSB0aGlzLnRyYWNrRWxlbWVudHNfW2ldKSB7XG4gICAgICAgIHRoaXMudHJhY2tFbGVtZW50c18uc3BsaWNlKGksIDEpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gSHRtbFRyYWNrRWxlbWVudExpc3Q7XG59KCk7XG5cbi8qKlxuICogQGZpbGUgdGV4dC10cmFjay1jdWUtbGlzdC5qc1xuICovXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHRUcmFja0N1ZUxpc3R+VGV4dFRyYWNrQ3VlXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkXG4gKiAgICAgICAgICAgVGhlIHVuaXF1ZSBpZCBmb3IgdGhpcyB0ZXh0IHRyYWNrIGN1ZVxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGFydFRpbWVcbiAqICAgICAgICAgICBUaGUgc3RhcnQgdGltZSBmb3IgdGhpcyB0ZXh0IHRyYWNrIGN1ZVxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbmRUaW1lXG4gKiAgICAgICAgICAgVGhlIGVuZCB0aW1lIGZvciB0aGlzIHRleHQgdHJhY2sgY3VlXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBwYXVzZU9uRXhpdFxuICogICAgICAgICAgIFBhdXNlIHdoZW4gdGhlIGVuZCB0aW1lIGlzIHJlYWNoZWQgaWYgdHJ1ZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrY3VlfVxuICovXG5cbi8qKlxuICogQSBMaXN0IG9mIFRleHRUcmFja0N1ZXMuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3RleHR0cmFja2N1ZWxpc3R9XG4gKi9cblxudmFyIFRleHRUcmFja0N1ZUxpc3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY3Vlc1xuICAgKiAgICAgICAgQSBsaXN0IG9mIGN1ZXMgdG8gYmUgaW5pdGlhbGl6ZWQgd2l0aFxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrQ3VlTGlzdChjdWVzKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrQ3VlTGlzdCk7XG5cbiAgICB2YXIgbGlzdCA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbcHJvcF0gPSBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlLnNldEN1ZXNfLmNhbGwobGlzdCwgY3Vlcyk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVGV4dFRyYWNrQ3VlTGlzdFxuICAgICAqIEBtZW1iZXIge251bWJlcn0gbGVuZ3RoXG4gICAgICogICAgICAgICBUaGUgY3VycmVudCBudW1iZXIgb2YgYFRleHRUcmFja0N1ZWBzIGluIHRoZSBUZXh0VHJhY2tDdWVMaXN0LlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnbGVuZ3RoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aF87XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBzZXR0ZXIgZm9yIGN1ZXMgaW4gdGhpcyBsaXN0LiBDcmVhdGVzIGdldHRlcnNcbiAgICogYW4gYW4gaW5kZXggZm9yIHRoZSBjdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjdWVzXG4gICAqICAgICAgICBBbiBhcnJheSBvZiBjdWVzIHRvIHNldFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlLnNldEN1ZXNfID0gZnVuY3Rpb24gc2V0Q3Vlc18oY3Vlcykge1xuICAgIHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbCA9IGN1ZXMubGVuZ3RoO1xuXG4gICAgdGhpcy5jdWVzXyA9IGN1ZXM7XG4gICAgdGhpcy5sZW5ndGhfID0gY3Vlcy5sZW5ndGg7XG5cbiAgICB2YXIgZGVmaW5lUHJvcCA9IGZ1bmN0aW9uIGRlZmluZVByb3AoaW5kZXgpIHtcbiAgICAgIGlmICghKCcnICsgaW5kZXggaW4gdGhpcykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICcnICsgaW5kZXgsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1ZXNfW2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAob2xkTGVuZ3RoIDwgbCkge1xuICAgICAgaSA9IG9sZExlbmd0aDtcblxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgZGVmaW5lUHJvcC5jYWxsKHRoaXMsIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgYFRleHRUcmFja0N1ZWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gdGhlIGBUZXh0VHJhY2tDdWVMaXN0YCBieSBpZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAqICAgICAgICBUaGUgaWQgb2YgdGhlIGN1ZSB0aGF0IHNob3VsZCBiZSBzZWFyY2hlZCBmb3IuXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja0N1ZUxpc3R+VGV4dFRyYWNrQ3VlfG51bGx9XG4gICAqICAgICAgICAgQSBzaW5nbGUgY3VlIG9yIG51bGwgaWYgbm9uZSB3YXMgZm91bmQuXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUuZ2V0Q3VlQnlJZCA9IGZ1bmN0aW9uIGdldEN1ZUJ5SWQoaWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjdWUgPSB0aGlzW2ldO1xuXG4gICAgICBpZiAoY3VlLmlkID09PSBpZCkge1xuICAgICAgICByZXN1bHQgPSBjdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFja0N1ZUxpc3Q7XG59KCk7XG5cbi8qKlxuICogQGZpbGUgdHJhY2sta2luZHMuanNcbiAqL1xuXG4vKipcbiAqIEFsbCBwb3NzaWJsZSBgVmlkZW9UcmFja0tpbmRgc1xuICpcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS12aWRlb3RyYWNrLWtpbmRcbiAqIEB0eXBlZGVmIFZpZGVvVHJhY2t+S2luZFxuICogQGVudW1cbiAqL1xudmFyIFZpZGVvVHJhY2tLaW5kID0ge1xuICBhbHRlcm5hdGl2ZTogJ2FsdGVybmF0aXZlJyxcbiAgY2FwdGlvbnM6ICdjYXB0aW9ucycsXG4gIG1haW46ICdtYWluJyxcbiAgc2lnbjogJ3NpZ24nLFxuICBzdWJ0aXRsZXM6ICdzdWJ0aXRsZXMnLFxuICBjb21tZW50YXJ5OiAnY29tbWVudGFyeSdcbn07XG5cbi8qKlxuICogQWxsIHBvc3NpYmxlIGBBdWRpb1RyYWNrS2luZGBzXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLWF1ZGlvdHJhY2sta2luZFxuICogQHR5cGVkZWYgQXVkaW9UcmFja35LaW5kXG4gKiBAZW51bVxuICovXG52YXIgQXVkaW9UcmFja0tpbmQgPSB7XG4gICdhbHRlcm5hdGl2ZSc6ICdhbHRlcm5hdGl2ZScsXG4gICdkZXNjcmlwdGlvbnMnOiAnZGVzY3JpcHRpb25zJyxcbiAgJ21haW4nOiAnbWFpbicsXG4gICdtYWluLWRlc2MnOiAnbWFpbi1kZXNjJyxcbiAgJ3RyYW5zbGF0aW9uJzogJ3RyYW5zbGF0aW9uJyxcbiAgJ2NvbW1lbnRhcnknOiAnY29tbWVudGFyeSdcbn07XG5cbi8qKlxuICogQWxsIHBvc3NpYmxlIGBUZXh0VHJhY2tLaW5kYHNcbiAqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tdGV4dHRyYWNrLWtpbmRcbiAqIEB0eXBlZGVmIFRleHRUcmFja35LaW5kXG4gKiBAZW51bVxuICovXG52YXIgVGV4dFRyYWNrS2luZCA9IHtcbiAgc3VidGl0bGVzOiAnc3VidGl0bGVzJyxcbiAgY2FwdGlvbnM6ICdjYXB0aW9ucycsXG4gIGRlc2NyaXB0aW9uczogJ2Rlc2NyaXB0aW9ucycsXG4gIGNoYXB0ZXJzOiAnY2hhcHRlcnMnLFxuICBtZXRhZGF0YTogJ21ldGFkYXRhJ1xufTtcblxuLyoqXG4gKiBBbGwgcG9zc2libGUgYFRleHRUcmFja01vZGVgc1xuICpcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3RleHR0cmFja21vZGVcbiAqIEB0eXBlZGVmIFRleHRUcmFja35Nb2RlXG4gKiBAZW51bVxuICovXG52YXIgVGV4dFRyYWNrTW9kZSA9IHtcbiAgZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGhpZGRlbjogJ2hpZGRlbicsXG4gIHNob3dpbmc6ICdzaG93aW5nJ1xufTtcblxuLyoqXG4gKiBAZmlsZSB0cmFjay5qc1xuICovXG4vKipcbiAqIEEgVHJhY2sgY2xhc3MgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciB7QGxpbmsgQXVkaW9UcmFja30sXG4gKiB7QGxpbmsgVmlkZW9UcmFja30sIGFuZCB7QGxpbmsgVGV4dFRyYWNrfS5cbiAqXG4gKiA+IE5vdGU6IFRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5XG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sfVxuICogQGV4dGVuZHMgRXZlbnRUYXJnZXRcbiAqIEBhYnN0cmFjdFxuICovXG5cbnZhciBUcmFjayA9IGZ1bmN0aW9uIChfRXZlbnRUYXJnZXQpIHtcbiAgaW5oZXJpdHMoVHJhY2ssIF9FdmVudFRhcmdldCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmtpbmQ9JyddXG4gICAqICAgICAgICBBIHZhbGlkIGtpbmQgZm9yIHRoZSB0cmFjayB0eXBlIHlvdSBhcmUgY3JlYXRpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZD0ndmpzX3RyYWNrXycgKyBHdWlkLm5ld0dVSUQoKV1cbiAgICogICAgICAgIEEgdW5pcXVlIGlkIGZvciB0aGlzIEF1ZGlvVHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbD0nJ11cbiAgICogICAgICAgIFRoZSBtZW51IGxhYmVsIGZvciB0aGlzIHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2U9JyddXG4gICAqICAgICAgICBBIHZhbGlkIHR3byBjaGFyYWN0ZXIgbGFuZ3VhZ2UgY29kZS5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBmdW5jdGlvbiBUcmFjaygpIHtcbiAgICB2YXIgX3JldDtcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFjayk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudFRhcmdldC5jYWxsKHRoaXMpKTtcblxuICAgIHZhciB0cmFjayA9IF90aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICB0cmFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBUcmFjay5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0cmFja1twcm9wXSA9IFRyYWNrLnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmFja1Byb3BzID0ge1xuICAgICAgaWQ6IG9wdGlvbnMuaWQgfHwgJ3Zqc190cmFja18nICsgbmV3R1VJRCgpLFxuICAgICAga2luZDogb3B0aW9ucy5raW5kIHx8ICcnLFxuICAgICAgbGFiZWw6IG9wdGlvbnMubGFiZWwgfHwgJycsXG4gICAgICBsYW5ndWFnZTogb3B0aW9ucy5sYW5ndWFnZSB8fCAnJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVHJhY2tcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGlkXG4gICAgICogICAgICAgICBUaGUgaWQgb2YgdGhpcyB0cmFjay4gQ2Fubm90IGJlIGNoYW5nZWQgYWZ0ZXIgY3JlYXRpb24uXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUcmFja1xuICAgICAqIEBtZW1iZXIge3N0cmluZ30ga2luZFxuICAgICAqICAgICAgICAgVGhlIGtpbmQgb2YgdHJhY2sgdGhhdCB0aGlzIGlzLiBDYW5ub3QgYmUgY2hhbmdlZCBhZnRlciBjcmVhdGlvbi5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRyYWNrXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBsYWJlbFxuICAgICAqICAgICAgICAgVGhlIGxhYmVsIG9mIHRoaXMgdHJhY2suIENhbm5vdCBiZSBjaGFuZ2VkIGFmdGVyIGNyZWF0aW9uLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVHJhY2tcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGxhbmd1YWdlXG4gICAgICogICAgICAgICBUaGUgdHdvIGxldHRlciBsYW5ndWFnZSBjb2RlIGZvciB0aGlzIHRyYWNrLiBDYW5ub3QgYmUgY2hhbmdlZCBhZnRlclxuICAgICAqICAgICAgICAgY3JlYXRpb24uXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRyYWNrLCBrZXksIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWNrUHJvcHNba2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoKSB7fVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGtleSBpbiB0cmFja1Byb3BzKSB7XG4gICAgICBfbG9vcChrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gdHJhY2ssIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgcmV0dXJuIFRyYWNrO1xufShFdmVudFRhcmdldCk7XG5cbi8qKlxuICogQGZpbGUgdXJsLmpzXG4gKiBAbW9kdWxlIHVybFxuICovXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHVybDpVUkxPYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcHJvdG9jb2xcbiAqICAgICAgICAgICBUaGUgcHJvdG9jb2wgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhvc3RuYW1lXG4gKiAgICAgICAgICAgVGhlIGhvc3RuYW1lIG9mIHRoZSB1cmwgdGhhdCB3YXMgcGFyc2VkLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwb3J0XG4gKiAgICAgICAgICAgVGhlIHBvcnQgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBhdGhuYW1lXG4gKiAgICAgICAgICAgVGhlIHBhdGhuYW1lIG9mIHRoZSB1cmwgdGhhdCB3YXMgcGFyc2VkLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWFyY2hcbiAqICAgICAgICAgICBUaGUgc2VhcmNoIHF1ZXJ5IG9mIHRoZSB1cmwgdGhhdCB3YXMgcGFyc2VkLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBoYXNoXG4gKiAgICAgICAgICAgVGhlIGhhc2ggb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhvc3RcbiAqICAgICAgICAgICBUaGUgaG9zdCBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cbiAqL1xuXG4vKipcbiAqIFJlc29sdmUgYW5kIHBhcnNlIHRoZSBlbGVtZW50cyBvZiBhIFVSTC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHVybFxuICogICAgICAgICBUaGUgdXJsIHRvIHBhcnNlXG4gKlxuICogQHJldHVybiB7dXJsOlVSTE9iamVjdH1cbiAqICAgICAgICAgQW4gb2JqZWN0IG9mIHVybCBkZXRhaWxzXG4gKi9cbnZhciBwYXJzZVVybCA9IGZ1bmN0aW9uIHBhcnNlVXJsKHVybCkge1xuICB2YXIgcHJvcHMgPSBbJ3Byb3RvY29sJywgJ2hvc3RuYW1lJywgJ3BvcnQnLCAncGF0aG5hbWUnLCAnc2VhcmNoJywgJ2hhc2gnLCAnaG9zdCddO1xuXG4gIC8vIGFkZCB0aGUgdXJsIHRvIGFuIGFuY2hvciBhbmQgbGV0IHRoZSBicm93c2VyIHBhcnNlIHRoZSBVUkxcbiAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cbiAgYS5ocmVmID0gdXJsO1xuXG4gIC8vIElFOCAoYW5kIDk/KSBGaXhcbiAgLy8gaWU4IGRvZXNuJ3QgcGFyc2UgdGhlIFVSTCBjb3JyZWN0bHkgdW50aWwgdGhlIGFuY2hvciBpcyBhY3R1YWxseVxuICAvLyBhZGRlZCB0byB0aGUgYm9keSwgYW5kIGFuIGlubmVySFRNTCBpcyBuZWVkZWQgdG8gdHJpZ2dlciB0aGUgcGFyc2luZ1xuICB2YXIgYWRkVG9Cb2R5ID0gYS5ob3N0ID09PSAnJyAmJiBhLnByb3RvY29sICE9PSAnZmlsZTonO1xuICB2YXIgZGl2ID0gdm9pZCAwO1xuXG4gIGlmIChhZGRUb0JvZHkpIHtcbiAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gJzxhIGhyZWY9XCInICsgdXJsICsgJ1wiPjwvYT4nO1xuICAgIGEgPSBkaXYuZmlyc3RDaGlsZDtcbiAgICAvLyBwcmV2ZW50IHRoZSBkaXYgZnJvbSBhZmZlY3RpbmcgbGF5b3V0XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTpub25lOyBwb3NpdGlvbjphYnNvbHV0ZTsnKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gIH1cblxuICAvLyBDb3B5IHRoZSBzcGVjaWZpYyBVUkwgcHJvcGVydGllcyB0byBhIG5ldyBvYmplY3RcbiAgLy8gVGhpcyBpcyBhbHNvIG5lZWRlZCBmb3IgSUU4IGJlY2F1c2UgdGhlIGFuY2hvciBsb3NlcyBpdHNcbiAgLy8gcHJvcGVydGllcyB3aGVuIGl0J3MgcmVtb3ZlZCBmcm9tIHRoZSBkb21cbiAgdmFyIGRldGFpbHMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGV0YWlsc1twcm9wc1tpXV0gPSBhW3Byb3BzW2ldXTtcbiAgfVxuXG4gIC8vIElFOSBhZGRzIHRoZSBwb3J0IHRvIHRoZSBob3N0IHByb3BlcnR5IHVubGlrZSBldmVyeW9uZSBlbHNlLiBJZlxuICAvLyBhIHBvcnQgaWRlbnRpZmllciBpcyBhZGRlZCBmb3Igc3RhbmRhcmQgcG9ydHMsIHN0cmlwIGl0LlxuICBpZiAoZGV0YWlscy5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgIGRldGFpbHMuaG9zdCA9IGRldGFpbHMuaG9zdC5yZXBsYWNlKC86ODAkLywgJycpO1xuICB9XG5cbiAgaWYgKGRldGFpbHMucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgZGV0YWlscy5ob3N0ID0gZGV0YWlscy5ob3N0LnJlcGxhY2UoLzo0NDMkLywgJycpO1xuICB9XG5cbiAgaWYgKCFkZXRhaWxzLnByb3RvY29sKSB7XG4gICAgZGV0YWlscy5wcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbiAgfVxuXG4gIGlmIChhZGRUb0JvZHkpIHtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gIH1cblxuICByZXR1cm4gZGV0YWlscztcbn07XG5cbi8qKlxuICogR2V0IGFic29sdXRlIHZlcnNpb24gb2YgcmVsYXRpdmUgVVJMLiBVc2VkIHRvIHRlbGwgZmxhc2ggY29ycmVjdCBVUkwuXG4gKlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdXJsXG4gKiAgICAgICAgIFVSTCB0byBtYWtlIGFic29sdXRlXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBBYnNvbHV0ZSBVUkxcbiAqXG4gKiBAc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDcwODMyL2dldHRpbmctYW4tYWJzb2x1dGUtdXJsLWZyb20tYS1yZWxhdGl2ZS1vbmUtaWU2LWlzc3VlXG4gKi9cbnZhciBnZXRBYnNvbHV0ZVVSTCA9IGZ1bmN0aW9uIGdldEFic29sdXRlVVJMKHVybCkge1xuICAvLyBDaGVjayBpZiBhYnNvbHV0ZSBVUkxcbiAgaWYgKCF1cmwubWF0Y2goL15odHRwcz86XFwvXFwvLykpIHtcbiAgICAvLyBDb252ZXJ0IHRvIGFic29sdXRlIFVSTC4gRmxhc2ggaG9zdGVkIG9mZi1zaXRlIG5lZWRzIGFuIGFic29sdXRlIFVSTC5cbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBkaXYuaW5uZXJIVE1MID0gJzxhIGhyZWY9XCInICsgdXJsICsgJ1wiPng8L2E+JztcbiAgICB1cmwgPSBkaXYuZmlyc3RDaGlsZC5ocmVmO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXh0ZW5zaW9uIG9mIHRoZSBwYXNzZWQgZmlsZSBuYW1lLiBJdCB3aWxsIHJldHVybiBhbiBlbXB0eSBzdHJpbmdcbiAqIGlmIHBhc3NlZCBhbiBpbnZhbGlkIHBhdGguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqICAgICAgICBUaGUgZmlsZU5hbWUgcGF0aCBsaWtlICcvcGF0aC90by9maWxlLm1wNCdcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogICAgICAgICAgVGhlIGV4dGVuc2lvbiBpbiBsb3dlciBjYXNlIG9yIGFuIGVtcHR5IHN0cmluZyBpZiBub1xuICogICAgICAgICAgZXh0ZW5zaW9uIGNvdWxkIGJlIGZvdW5kLlxuICovXG52YXIgZ2V0RmlsZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24ocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNwbGl0UGF0aFJlID0gL14oXFwvPykoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz8pKFxcLihbXlxcLlxcL1xcP10rKSkpKD86W1xcL10qfFtcXD9dLiopJC9pO1xuICAgIHZhciBwYXRoUGFydHMgPSBzcGxpdFBhdGhSZS5leGVjKHBhdGgpO1xuXG4gICAgaWYgKHBhdGhQYXJ0cykge1xuICAgICAgcmV0dXJuIHBhdGhQYXJ0cy5wb3AoKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSB1cmwgcGFzc2VkIGlzIGEgY3Jvc3MgZG9tYWluIHJlcXVlc3Qgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqICAgICAgICBUaGUgdXJsIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgaXQgaXMgYSBjcm9zcyBkb21haW4gcmVxdWVzdCBvciBub3QuXG4gKi9cbnZhciBpc0Nyb3NzT3JpZ2luID0gZnVuY3Rpb24gaXNDcm9zc09yaWdpbih1cmwpIHtcbiAgdmFyIHdpbkxvYyA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgdmFyIHVybEluZm8gPSBwYXJzZVVybCh1cmwpO1xuXG4gIC8vIElFOCBwcm90b2NvbCByZWxhdGl2ZSB1cmxzIHdpbGwgcmV0dXJuICc6JyBmb3IgcHJvdG9jb2xcbiAgdmFyIHNyY1Byb3RvY29sID0gdXJsSW5mby5wcm90b2NvbCA9PT0gJzonID8gd2luTG9jLnByb3RvY29sIDogdXJsSW5mby5wcm90b2NvbDtcblxuICAvLyBDaGVjayBpZiB1cmwgaXMgZm9yIGFub3RoZXIgZG9tYWluL29yaWdpblxuICAvLyBJRTggZG9lc24ndCBrbm93IGxvY2F0aW9uLm9yaWdpbiwgc28gd2Ugd29uJ3QgcmVseSBvbiBpdCBoZXJlXG4gIHZhciBjcm9zc09yaWdpbiA9IHNyY1Byb3RvY29sICsgdXJsSW5mby5ob3N0ICE9PSB3aW5Mb2MucHJvdG9jb2wgKyB3aW5Mb2MuaG9zdDtcblxuICByZXR1cm4gY3Jvc3NPcmlnaW47XG59O1xuXG52YXIgVXJsID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7XG5cdHBhcnNlVXJsOiBwYXJzZVVybCxcblx0Z2V0QWJzb2x1dGVVUkw6IGdldEFic29sdXRlVVJMLFxuXHRnZXRGaWxlRXh0ZW5zaW9uOiBnZXRGaWxlRXh0ZW5zaW9uLFxuXHRpc0Nyb3NzT3JpZ2luOiBpc0Nyb3NzT3JpZ2luXG59KTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLmpzXG4gKi9cbi8qKlxuICogVGFrZXMgYSB3ZWJ2dHQgZmlsZSBjb250ZW50cyBhbmQgcGFyc2VzIGl0IGludG8gY3Vlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNDb250ZW50XG4gKiAgICAgICAgd2ViVlRUIGZpbGUgY29udGVudHNcbiAqXG4gKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAqICAgICAgICBUZXh0VHJhY2sgdG8gYWRkIGN1ZXMgdG8uIEN1ZXMgY29tZSBmcm9tIHRoZSBzcmNDb250ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBwYXJzZUN1ZXMgPSBmdW5jdGlvbiBwYXJzZUN1ZXMoc3JjQ29udGVudCwgdHJhY2spIHtcbiAgdmFyIHBhcnNlciA9IG5ldyB3aW5kb3cuV2ViVlRULlBhcnNlcih3aW5kb3csIHdpbmRvdy52dHRqcywgd2luZG93LldlYlZUVC5TdHJpbmdEZWNvZGVyKCkpO1xuICB2YXIgZXJyb3JzID0gW107XG5cbiAgcGFyc2VyLm9uY3VlID0gZnVuY3Rpb24gKGN1ZSkge1xuICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuICB9O1xuXG4gIHBhcnNlci5vbnBhcnNpbmdlcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgfTtcblxuICBwYXJzZXIub25mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cmFjay50cmlnZ2VyKHtcbiAgICAgIHR5cGU6ICdsb2FkZWRkYXRhJyxcbiAgICAgIHRhcmdldDogdHJhY2tcbiAgICB9KTtcbiAgfTtcblxuICBwYXJzZXIucGFyc2Uoc3JjQ29udGVudCk7XG4gIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5ncm91cENvbGxhcHNlZCkge1xuICAgICAgd2luZG93LmNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoJ1RleHQgVHJhY2sgcGFyc2luZyBlcnJvcnMgZm9yICcgKyB0cmFjay5zcmMpO1xuICAgIH1cbiAgICBlcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBsb2ckMS5lcnJvcihlcnJvcik7XG4gICAgfSk7XG4gICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmdyb3VwRW5kKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlci5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBMb2FkIGEgYFRleHRUcmFja2AgZnJvbSBhIHNwZWNpZmVkIHVybC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjXG4gKiAgICAgICAgVXJsIHRvIGxvYWQgdHJhY2sgZnJvbS5cbiAqXG4gKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAqICAgICAgICBUcmFjayB0byBhZGQgY3VlcyB0by4gQ29tZXMgZnJvbSB0aGUgY29udGVudCBhdCB0aGUgZW5kIG9mIGB1cmxgLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBsb2FkVHJhY2sgPSBmdW5jdGlvbiBsb2FkVHJhY2soc3JjLCB0cmFjaykge1xuICB2YXIgb3B0cyA9IHtcbiAgICB1cmk6IHNyY1xuICB9O1xuICB2YXIgY3Jvc3NPcmlnaW4gPSBpc0Nyb3NzT3JpZ2luKHNyYyk7XG5cbiAgaWYgKGNyb3NzT3JpZ2luKSB7XG4gICAgb3B0cy5jb3JzID0gY3Jvc3NPcmlnaW47XG4gIH1cblxuICB4aHIob3B0cywgYmluZCh0aGlzLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSwgcmVzcG9uc2VCb2R5KSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGxvZyQxLmVycm9yKGVyciwgcmVzcG9uc2UpO1xuICAgIH1cblxuICAgIHRyYWNrLmxvYWRlZF8gPSB0cnVlO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgdnR0anMgaGFzIGxvYWRlZCwgb3RoZXJ3aXNlLCB3YWl0IHRpbGwgaXQgZmluaXNoZWQgbG9hZGluZ1xuICAgIC8vIE5PVEU6IHRoaXMgaXMgb25seSB1c2VkIGZvciB0aGUgYWx0L3ZpZGVvLm5vdnR0LmpzIGJ1aWxkXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuV2ViVlRUICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodHJhY2sudGVjaF8pIHtcbiAgICAgICAgdmFyIGxvYWRIYW5kbGVyID0gZnVuY3Rpb24gbG9hZEhhbmRsZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlQ3VlcyhyZXNwb25zZUJvZHksIHRyYWNrKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0cmFjay50ZWNoXy5vbigndnR0anNsb2FkZWQnLCBsb2FkSGFuZGxlcik7XG4gICAgICAgIHRyYWNrLnRlY2hfLm9uKCd2dHRqc2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxvZyQxLmVycm9yKCd2dHRqcyBmYWlsZWQgdG8gbG9hZCwgc3RvcHBpbmcgdHJ5aW5nIHRvIHByb2Nlc3MgJyArIHRyYWNrLnNyYyk7XG4gICAgICAgICAgdHJhY2sudGVjaF8ub2ZmKCd2dHRqc2xvYWRlZCcsIGxvYWRIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlQ3VlcyhyZXNwb25zZUJvZHksIHRyYWNrKTtcbiAgICB9XG4gIH0pKTtcbn07XG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBgVGV4dFRyYWNrYC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrfVxuICogQGV4dGVuZHMgVHJhY2tcbiAqL1xuXG52YXIgVGV4dFRyYWNrID0gZnVuY3Rpb24gKF9UcmFjaykge1xuICBpbmhlcml0cyhUZXh0VHJhY2ssIF9UcmFjayk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucz17fVxuICAgKiAgICAgICAgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzXG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH0gb3B0aW9ucy50ZWNoXG4gICAqICAgICAgICBBIHJlZmVyZW5jZSB0byB0aGUgdGVjaCB0aGF0IG93bnMgdGhpcyBUZXh0VHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfktpbmR9IFtvcHRpb25zLmtpbmQ9J3N1YnRpdGxlcyddXG4gICAqICAgICAgICBBIHZhbGlkIHRleHQgdHJhY2sga2luZC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t+TW9kZX0gW29wdGlvbnMubW9kZT0nZGlzYWJsZWQnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0ZXh0IHRyYWNrIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZD0ndmpzX3RyYWNrXycgKyBHdWlkLm5ld0dVSUQoKV1cbiAgICogICAgICAgIEEgdW5pcXVlIGlkIGZvciB0aGlzIFRleHRUcmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsPScnXVxuICAgKiAgICAgICAgVGhlIG1lbnUgbGFiZWwgZm9yIHRoaXMgdHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZT0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3JjbGFuZz0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLiBBbiBhbHRlcm5hdGl2ZSwgYnV0IGRlcHJpb3JpdGl6ZWRcbiAgICogICAgICAgIHZlc2lvbiBvZiBgb3B0aW9ucy5sYW5ndWFnZWBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY11cbiAgICogICAgICAgIEEgdXJsIHRvIFRleHRUcmFjayBjdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlZmF1bHRdXG4gICAqICAgICAgICBJZiB0aGlzIHRyYWNrIHNob3VsZCBkZWZhdWx0IHRvIG9uIG9yIG9mZi5cbiAgICovXG4gIGZ1bmN0aW9uIFRleHRUcmFjaygpIHtcbiAgICB2YXIgX3RoaXMsIF9yZXQ7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrKTtcblxuICAgIGlmICghb3B0aW9ucy50ZWNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdGVjaCB3YXMgbm90IHByb3ZpZGVkLicpO1xuICAgIH1cblxuICAgIHZhciBzZXR0aW5ncyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICBraW5kOiBUZXh0VHJhY2tLaW5kW29wdGlvbnMua2luZF0gfHwgJ3N1YnRpdGxlcycsXG4gICAgICBsYW5ndWFnZTogb3B0aW9ucy5sYW5ndWFnZSB8fCBvcHRpb25zLnNyY2xhbmcgfHwgJydcbiAgICB9KTtcbiAgICB2YXIgbW9kZSA9IFRleHRUcmFja01vZGVbc2V0dGluZ3MubW9kZV0gfHwgJ2Rpc2FibGVkJztcbiAgICB2YXIgZGVmYXVsdF8gPSBzZXR0aW5nc1snZGVmYXVsdCddO1xuXG4gICAgaWYgKHNldHRpbmdzLmtpbmQgPT09ICdtZXRhZGF0YScgfHwgc2V0dGluZ3Mua2luZCA9PT0gJ2NoYXB0ZXJzJykge1xuICAgICAgbW9kZSA9ICdoaWRkZW4nO1xuICAgIH1cbiAgICAvLyBvbiBJRTggdGhpcyB3aWxsIGJlIGEgZG9jdW1lbnQgZWxlbWVudFxuICAgIC8vIGZvciBldmVyeSBvdGhlciBicm93c2VyIHRoaXMgd2lsbCBiZSBhIG5vcm1hbCBvYmplY3RcbiAgICB2YXIgdHQgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFjay5jYWxsKHRoaXMsIHNldHRpbmdzKSksIF90aGlzKTtcblxuICAgIHR0LnRlY2hfID0gc2V0dGluZ3MudGVjaDtcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVGV4dFRyYWNrLnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHR0W3Byb3BdID0gVGV4dFRyYWNrLnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHR0LmN1ZXNfID0gW107XG4gICAgdHQuYWN0aXZlQ3Vlc18gPSBbXTtcblxuICAgIHZhciBjdWVzID0gbmV3IFRleHRUcmFja0N1ZUxpc3QodHQuY3Vlc18pO1xuICAgIHZhciBhY3RpdmVDdWVzID0gbmV3IFRleHRUcmFja0N1ZUxpc3QodHQuYWN0aXZlQ3Vlc18pO1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIHRpbWV1cGRhdGVIYW5kbGVyID0gYmluZCh0dCwgZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBBY2Nlc3NpbmcgdGhpcy5hY3RpdmVDdWVzIGZvciB0aGUgc2lkZS1lZmZlY3RzIG9mIHVwZGF0aW5nIGl0c2VsZlxuICAgICAgLy8gZHVlIHRvIGl0J3MgbmF0dXJlIGFzIGEgZ2V0dGVyIGZ1bmN0aW9uLiBEbyBub3QgcmVtb3ZlIG9yIGN1ZXMgd2lsbFxuICAgICAgLy8gc3RvcCB1cGRhdGluZyFcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgICAgdGhpcy5hY3RpdmVDdWVzO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY3VlY2hhbmdlJyk7XG4gICAgICAgIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChtb2RlICE9PSAnZGlzYWJsZWQnKSB7XG4gICAgICB0dC50ZWNoXy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHR0LnRlY2hfLm9uKCd0aW1ldXBkYXRlJywgdGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRleHRUcmFja1xuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IGRlZmF1bHRcbiAgICAgKiAgICAgICAgIElmIHRoaXMgdHJhY2sgd2FzIHNldCB0byBiZSBvbiBvciBvZmYgYnkgZGVmYXVsdC4gQ2Fubm90IGJlIGNoYW5nZWQgYWZ0ZXJcbiAgICAgKiAgICAgICAgIGNyZWF0aW9uLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnZGVmYXVsdCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdF87XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoKSB7fVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRleHRUcmFja1xuICAgICAqIEBtZW1iZXIge3N0cmluZ30gbW9kZVxuICAgICAqICAgICAgICAgU2V0IHRoZSBtb2RlIG9mIHRoaXMgVGV4dFRyYWNrIHRvIGEgdmFsaWQge0BsaW5rIFRleHRUcmFja35Nb2RlfS4gV2lsbFxuICAgICAqICAgICAgICAgbm90IGJlIHNldCBpZiBzZXR0aW5nIHRvIGFuIGludmFsaWQgbW9kZS5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBmaXJlcyBUZXh0VHJhY2sjbW9kZWNoYW5nZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ21vZGUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIG1vZGU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEobmV3TW9kZSkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAoIVRleHRUcmFja01vZGVbbmV3TW9kZV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbW9kZSA9IG5ld01vZGU7XG4gICAgICAgIGlmIChtb2RlID09PSAnc2hvd2luZycpIHtcblxuICAgICAgICAgIHRoaXMudGVjaF8ucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMyLnRlY2hfLm9uKCd0aW1ldXBkYXRlJywgdGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBldmVudCB0aGF0IGZpcmVzIHdoZW4gbW9kZSBjaGFuZ2VzIG9uIHRoaXMgdHJhY2suIFRoaXMgYWxsb3dzXG4gICAgICAgICAqIHRoZSBUZXh0VHJhY2tMaXN0IHRoYXQgaG9sZHMgdGhpcyB0cmFjayB0byBhY3QgYWNjb3JkaW5nbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gTm90ZTogVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgc3BlYyFcbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFRleHRUcmFjayNtb2RlY2hhbmdlXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpZ2dlcignbW9kZWNoYW5nZScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRleHRUcmFja1xuICAgICAqIEBtZW1iZXIge1RleHRUcmFja0N1ZUxpc3R9IGN1ZXNcbiAgICAgKiAgICAgICAgIFRoZSB0ZXh0IHRyYWNrIGN1ZSBsaXN0IGZvciB0aGlzIFRleHRUcmFjay5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHQsICdjdWVzJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2FkZWRfKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3VlcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSgpIHt9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVGV4dFRyYWNrXG4gICAgICogQG1lbWJlciB7VGV4dFRyYWNrQ3VlTGlzdH0gYWN0aXZlQ3Vlc1xuICAgICAqICAgICAgICAgVGhlIGxpc3QgdGV4dCB0cmFjayBjdWVzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUgZm9yIHRoaXMgVGV4dFRyYWNrLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ2FjdGl2ZUN1ZXMnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRlZF8pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgaWYgKHRoaXMuY3Vlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlQ3VlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdCA9IHRoaXMudGVjaF8uY3VycmVudFRpbWUoKTtcbiAgICAgICAgdmFyIGFjdGl2ZSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5jdWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBjdWUgPSB0aGlzLmN1ZXNbaV07XG5cbiAgICAgICAgICBpZiAoY3VlLnN0YXJ0VGltZSA8PSBjdCAmJiBjdWUuZW5kVGltZSA+PSBjdCkge1xuICAgICAgICAgICAgYWN0aXZlLnB1c2goY3VlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1ZS5zdGFydFRpbWUgPT09IGN1ZS5lbmRUaW1lICYmIGN1ZS5zdGFydFRpbWUgPD0gY3QgJiYgY3VlLnN0YXJ0VGltZSArIDAuNSA+PSBjdCkge1xuICAgICAgICAgICAgYWN0aXZlLnB1c2goY3VlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGFjdGl2ZS5sZW5ndGggIT09IHRoaXMuYWN0aXZlQ3Vlc18ubGVuZ3RoKSB7XG4gICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFjdGl2ZS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZUN1ZXNfLmluZGV4T2YoYWN0aXZlW19pXSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWN0aXZlQ3Vlc18gPSBhY3RpdmU7XG4gICAgICAgIGFjdGl2ZUN1ZXMuc2V0Q3Vlc18odGhpcy5hY3RpdmVDdWVzXyk7XG5cbiAgICAgICAgcmV0dXJuIGFjdGl2ZUN1ZXM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoKSB7fVxuICAgIH0pO1xuXG4gICAgaWYgKHNldHRpbmdzLnNyYykge1xuICAgICAgdHQuc3JjID0gc2V0dGluZ3Muc3JjO1xuICAgICAgbG9hZFRyYWNrKHNldHRpbmdzLnNyYywgdHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0dC5sb2FkZWRfID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IHR0LCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBjdWUgdG8gdGhlIGludGVybmFsIGxpc3Qgb2YgY3Vlcy5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t+Q3VlfSBjdWVcbiAgICogICAgICAgIFRoZSBjdWUgdG8gYWRkIHRvIG91ciBpbnRlcm5hbCBsaXN0XG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrLnByb3RvdHlwZS5hZGRDdWUgPSBmdW5jdGlvbiBhZGRDdWUob3JpZ2luYWxDdWUpIHtcbiAgICB2YXIgY3VlID0gb3JpZ2luYWxDdWU7XG5cbiAgICBpZiAod2luZG93LnZ0dGpzICYmICEob3JpZ2luYWxDdWUgaW5zdGFuY2VvZiB3aW5kb3cudnR0anMuVlRUQ3VlKSkge1xuICAgICAgY3VlID0gbmV3IHdpbmRvdy52dHRqcy5WVFRDdWUob3JpZ2luYWxDdWUuc3RhcnRUaW1lLCBvcmlnaW5hbEN1ZS5lbmRUaW1lLCBvcmlnaW5hbEN1ZS50ZXh0KTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcmlnaW5hbEN1ZSkge1xuICAgICAgICBpZiAoIShwcm9wIGluIGN1ZSkpIHtcbiAgICAgICAgICBjdWVbcHJvcF0gPSBvcmlnaW5hbEN1ZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBtYWtlIHN1cmUgdGhhdCBgaWRgIGlzIGNvcGllZCBvdmVyXG4gICAgICBjdWUuaWQgPSBvcmlnaW5hbEN1ZS5pZDtcbiAgICAgIGN1ZS5vcmlnaW5hbEN1ZV8gPSBvcmlnaW5hbEN1ZTtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2tzID0gdGhpcy50ZWNoXy50ZXh0VHJhY2tzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyYWNrc1tpXSAhPT0gdGhpcykge1xuICAgICAgICB0cmFja3NbaV0ucmVtb3ZlQ3VlKGN1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jdWVzXy5wdXNoKGN1ZSk7XG4gICAgdGhpcy5jdWVzLnNldEN1ZXNfKHRoaXMuY3Vlc18pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjdWUgZnJvbSBvdXIgaW50ZXJuYWwgbGlzdFxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja35DdWV9IHJlbW92ZUN1ZVxuICAgKiAgICAgICAgVGhlIGN1ZSB0byByZW1vdmUgZnJvbSBvdXIgaW50ZXJuYWwgbGlzdFxuICAgKi9cblxuXG4gIFRleHRUcmFjay5wcm90b3R5cGUucmVtb3ZlQ3VlID0gZnVuY3Rpb24gcmVtb3ZlQ3VlKF9yZW1vdmVDdWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuY3Vlc18ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGN1ZSA9IHRoaXMuY3Vlc19baV07XG5cbiAgICAgIGlmIChjdWUgPT09IF9yZW1vdmVDdWUgfHwgY3VlLm9yaWdpbmFsQ3VlXyAmJiBjdWUub3JpZ2luYWxDdWVfID09PSBfcmVtb3ZlQ3VlKSB7XG4gICAgICAgIHRoaXMuY3Vlc18uc3BsaWNlKGksIDEpO1xuICAgICAgICB0aGlzLmN1ZXMuc2V0Q3Vlc18odGhpcy5jdWVzXyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrO1xufShUcmFjayk7XG5cbi8qKlxuICogY3VlY2hhbmdlIC0gT25lIG9yIG1vcmUgY3VlcyBpbiB0aGUgdHJhY2sgaGF2ZSBiZWNvbWUgYWN0aXZlIG9yIHN0b3BwZWQgYmVpbmcgYWN0aXZlLlxuICovXG5cblxuVGV4dFRyYWNrLnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzXyA9IHtcbiAgY3VlY2hhbmdlOiAnY3VlY2hhbmdlJ1xufTtcblxuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGBBdWRpb1RyYWNrYC4gSWYgaXQgaXMgcGFydCBvZiBhbiB7QGxpbmsgQXVkaW9UcmFja0xpc3R9XG4gKiBvbmx5IG9uZSBgQXVkaW9UcmFja2AgaW4gdGhlIGxpc3Qgd2lsbCBiZSBlbmFibGVkIGF0IGEgdGltZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjYXVkaW90cmFja31cbiAqIEBleHRlbmRzIFRyYWNrXG4gKi9cblxudmFyIEF1ZGlvVHJhY2sgPSBmdW5jdGlvbiAoX1RyYWNrKSB7XG4gIGluaGVyaXRzKEF1ZGlvVHJhY2ssIF9UcmFjayk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtBdWRpb1RyYWNrfktpbmR9IFtvcHRpb25zLmtpbmQ9JyddXG4gICAqICAgICAgICBBIHZhbGlkIGF1ZGlvIHRyYWNrIGtpbmRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkPSd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpXVxuICAgKiAgICAgICAgQSB1bmlxdWUgaWQgZm9yIHRoaXMgQXVkaW9UcmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsPScnXVxuICAgKiAgICAgICAgVGhlIG1lbnUgbGFiZWwgZm9yIHRoaXMgdHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZT0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZWRdXG4gICAqICAgICAgICBJZiB0aGlzIHRyYWNrIGlzIHRoZSBvbmUgdGhhdCBpcyBjdXJyZW50bHkgcGxheWluZy4gSWYgdGhpcyB0cmFjayBpcyBwYXJ0IG9mXG4gICAqICAgICAgICBhbiB7QGxpbmsgQXVkaW9UcmFja0xpc3R9LCBvbmx5IG9uZSB7QGxpbmsgQXVkaW9UcmFja30gd2lsbCBiZSBlbmFibGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gQXVkaW9UcmFjaygpIHtcbiAgICB2YXIgX3RoaXMsIF9yZXQ7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9UcmFjayk7XG5cbiAgICB2YXIgc2V0dGluZ3MgPSBtZXJnZU9wdGlvbnMob3B0aW9ucywge1xuICAgICAga2luZDogQXVkaW9UcmFja0tpbmRbb3B0aW9ucy5raW5kXSB8fCAnJ1xuICAgIH0pO1xuICAgIC8vIG9uIElFOCB0aGlzIHdpbGwgYmUgYSBkb2N1bWVudCBlbGVtZW50XG4gICAgLy8gZm9yIGV2ZXJ5IG90aGVyIGJyb3dzZXIgdGhpcyB3aWxsIGJlIGEgbm9ybWFsIG9iamVjdFxuICAgIHZhciB0cmFjayA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrLmNhbGwodGhpcywgc2V0dGluZ3MpKSwgX3RoaXMpO1xuICAgIHZhciBlbmFibGVkID0gZmFsc2U7XG5cbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIEF1ZGlvVHJhY2sucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdHJhY2tbcHJvcF0gPSBBdWRpb1RyYWNrLnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9UcmFja1xuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiAgICAgICAgIElmIHRoaXMgYEF1ZGlvVHJhY2tgIGlzIGVuYWJsZWQgb3Igbm90LiBXaGVuIHNldHRpbmcgdGhpcyB3aWxsXG4gICAgICogICAgICAgICBmaXJlIHtAbGluayBBdWRpb1RyYWNrI2VuYWJsZWRjaGFuZ2V9IGlmIHRoZSBzdGF0ZSBvZiBlbmFibGVkIGlzIGNoYW5nZWQuXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAZmlyZXMgVmlkZW9UcmFjayNzZWxlY3RlZGNoYW5nZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cmFjaywgJ2VuYWJsZWQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIGVuYWJsZWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEobmV3RW5hYmxlZCkge1xuICAgICAgICAvLyBhbiBpbnZhbGlkIG9yIHVuY2hhbmdlZCB2YWx1ZVxuICAgICAgICBpZiAodHlwZW9mIG5ld0VuYWJsZWQgIT09ICdib29sZWFuJyB8fCBuZXdFbmFibGVkID09PSBlbmFibGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVuYWJsZWQgPSBuZXdFbmFibGVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBldmVudCB0aGF0IGZpcmVzIHdoZW4gZW5hYmxlZCBjaGFuZ2VzIG9uIHRoaXMgdHJhY2suIFRoaXMgYWxsb3dzXG4gICAgICAgICAqIHRoZSBBdWRpb1RyYWNrTGlzdCB0aGF0IGhvbGRzIHRoaXMgdHJhY2sgdG8gYWN0IGFjY29yZGluZ2x5LlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IE5vdGU6IFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHNwZWMhIE5hdGl2ZSB0cmFja3Mgd2lsbCBkb1xuICAgICAgICAgKiAgICAgICAgIHRoaXMgaW50ZXJuYWxseSB3aXRob3V0IGFuIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgQXVkaW9UcmFjayNlbmFibGVkY2hhbmdlXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpZ2dlcignZW5hYmxlZGNoYW5nZScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gaWYgdGhlIHVzZXIgc2V0cyB0aGlzIHRyYWNrIHRvIHNlbGVjdGVkIHRoZW5cbiAgICAvLyBzZXQgc2VsZWN0ZWQgdG8gdGhhdCB0cnVlIHZhbHVlIG90aGVyd2lzZVxuICAgIC8vIHdlIGtlZXAgaXQgZmFsc2VcbiAgICBpZiAoc2V0dGluZ3MuZW5hYmxlZCkge1xuICAgICAgdHJhY2suZW5hYmxlZCA9IHNldHRpbmdzLmVuYWJsZWQ7XG4gICAgfVxuICAgIHRyYWNrLmxvYWRlZF8gPSB0cnVlO1xuXG4gICAgcmV0dXJuIF9yZXQgPSB0cmFjaywgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICByZXR1cm4gQXVkaW9UcmFjaztcbn0oVHJhY2spO1xuXG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgYFZpZGVvVHJhY2tgLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN2aWRlb3RyYWNrfVxuICogQGV4dGVuZHMgVHJhY2tcbiAqL1xuXG52YXIgVmlkZW9UcmFjayA9IGZ1bmN0aW9uIChfVHJhY2spIHtcbiAgaW5oZXJpdHMoVmlkZW9UcmFjaywgX1RyYWNrKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMua2luZD0nJ11cbiAgICogICAgICAgIEEgdmFsaWQge0BsaW5rIFZpZGVvVHJhY2t+S2luZH1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkPSd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpXVxuICAgKiAgICAgICAgQSB1bmlxdWUgaWQgZm9yIHRoaXMgQXVkaW9UcmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsPScnXVxuICAgKiAgICAgICAgVGhlIG1lbnUgbGFiZWwgZm9yIHRoaXMgdHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZT0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbGVjdGVkXVxuICAgKiAgICAgICAgSWYgdGhpcyB0cmFjayBpcyB0aGUgb25lIHRoYXQgaXMgY3VycmVudGx5IHBsYXlpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBWaWRlb1RyYWNrKCkge1xuICAgIHZhciBfdGhpcywgX3JldDtcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWaWRlb1RyYWNrKTtcblxuICAgIHZhciBzZXR0aW5ncyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICBraW5kOiBWaWRlb1RyYWNrS2luZFtvcHRpb25zLmtpbmRdIHx8ICcnXG4gICAgfSk7XG5cbiAgICAvLyBvbiBJRTggdGhpcyB3aWxsIGJlIGEgZG9jdW1lbnQgZWxlbWVudFxuICAgIC8vIGZvciBldmVyeSBvdGhlciBicm93c2VyIHRoaXMgd2lsbCBiZSBhIG5vcm1hbCBvYmplY3RcbiAgICB2YXIgdHJhY2sgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFjay5jYWxsKHRoaXMsIHNldHRpbmdzKSksIF90aGlzKTtcbiAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVmlkZW9UcmFjay5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0cmFja1twcm9wXSA9IFZpZGVvVHJhY2sucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFZpZGVvVHJhY2tcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqICAgICAgICAgSWYgdGhpcyBgVmlkZW9UcmFja2AgaXMgc2VsZWN0ZWQgb3Igbm90LiBXaGVuIHNldHRpbmcgdGhpcyB3aWxsXG4gICAgICogICAgICAgICBmaXJlIHtAbGluayBWaWRlb1RyYWNrI3NlbGVjdGVkY2hhbmdlfSBpZiB0aGUgc3RhdGUgb2Ygc2VsZWN0ZWQgY2hhbmdlZC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBmaXJlcyBWaWRlb1RyYWNrI3NlbGVjdGVkY2hhbmdlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRyYWNrLCAnc2VsZWN0ZWQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKG5ld1NlbGVjdGVkKSB7XG4gICAgICAgIC8vIGFuIGludmFsaWQgb3IgdW5jaGFuZ2VkIHZhbHVlXG4gICAgICAgIGlmICh0eXBlb2YgbmV3U2VsZWN0ZWQgIT09ICdib29sZWFuJyB8fCBuZXdTZWxlY3RlZCA9PT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0ZWQgPSBuZXdTZWxlY3RlZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gZXZlbnQgdGhhdCBmaXJlcyB3aGVuIHNlbGVjdGVkIGNoYW5nZXMgb24gdGhpcyB0cmFjay4gVGhpcyBhbGxvd3NcbiAgICAgICAgICogdGhlIFZpZGVvVHJhY2tMaXN0IHRoYXQgaG9sZHMgdGhpcyB0cmFjayB0byBhY3QgYWNjb3JkaW5nbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gTm90ZTogVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgc3BlYyEgTmF0aXZlIHRyYWNrcyB3aWxsIGRvXG4gICAgICAgICAqICAgICAgICAgdGhpcyBpbnRlcm5hbGx5IHdpdGhvdXQgYW4gZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBWaWRlb1RyYWNrI3NlbGVjdGVkY2hhbmdlXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpZ2dlcignc2VsZWN0ZWRjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGlmIHRoZSB1c2VyIHNldHMgdGhpcyB0cmFjayB0byBzZWxlY3RlZCB0aGVuXG4gICAgLy8gc2V0IHNlbGVjdGVkIHRvIHRoYXQgdHJ1ZSB2YWx1ZSBvdGhlcndpc2VcbiAgICAvLyB3ZSBrZWVwIGl0IGZhbHNlXG4gICAgaWYgKHNldHRpbmdzLnNlbGVjdGVkKSB7XG4gICAgICB0cmFjay5zZWxlY3RlZCA9IHNldHRpbmdzLnNlbGVjdGVkO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gdHJhY2ssIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgcmV0dXJuIFZpZGVvVHJhY2s7XG59KFRyYWNrKTtcblxuLyoqXG4gKiBAZmlsZSBodG1sLXRyYWNrLWVsZW1lbnQuanNcbiAqL1xuXG4vKipcbiAqIEBtZW1iZXJvZiBIVE1MVHJhY2tFbGVtZW50XG4gKiBAdHlwZWRlZiB7SFRNTFRyYWNrRWxlbWVudH5SZWFkeVN0YXRlfVxuICogQGVudW0ge251bWJlcn1cbiAqL1xudmFyIE5PTkUgPSAwO1xudmFyIExPQURJTkcgPSAxO1xudmFyIExPQURFRCA9IDI7XG52YXIgRVJST1IgPSAzO1xuXG4vKipcbiAqIEEgc2luZ2xlIHRyYWNrIHJlcHJlc2VudGVkIGluIHRoZSBET00uXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2h0bWx0cmFja2VsZW1lbnR9XG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICovXG5cbnZhciBIVE1MVHJhY2tFbGVtZW50ID0gZnVuY3Rpb24gKF9FdmVudFRhcmdldCkge1xuICBpbmhlcml0cyhIVE1MVHJhY2tFbGVtZW50LCBfRXZlbnRUYXJnZXQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnM9e31cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICAgKlxuICAgKiBAcGFyYW0ge1RlY2h9IG9wdGlvbnMudGVjaFxuICAgKiAgICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRlY2ggdGhhdCBvd25zIHRoaXMgSFRNTFRyYWNrRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t+S2luZH0gW29wdGlvbnMua2luZD0nc3VidGl0bGVzJ11cbiAgICogICAgICAgIEEgdmFsaWQgdGV4dCB0cmFjayBraW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja35Nb2RlfSBbb3B0aW9ucy5tb2RlPSdkaXNhYmxlZCddXG4gICAqICAgICAgICBBIHZhbGlkIHRleHQgdHJhY2sgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkPSd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpXVxuICAgKiAgICAgICAgQSB1bmlxdWUgaWQgZm9yIHRoaXMgVGV4dFRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWw9JyddXG4gICAqICAgICAgICBUaGUgbWVudSBsYWJlbCBmb3IgdGhpcyB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zcmNsYW5nPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuIEFuIGFsdGVybmF0aXZlLCBidXQgZGVwcmlvcml0aXplZFxuICAgKiAgICAgICAgdmVzaW9uIG9mIGBvcHRpb25zLmxhbmd1YWdlYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3JjXVxuICAgKiAgICAgICAgQSB1cmwgdG8gVGV4dFRyYWNrIGN1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVmYXVsdF1cbiAgICogICAgICAgIElmIHRoaXMgdHJhY2sgc2hvdWxkIGRlZmF1bHQgdG8gb24gb3Igb2ZmLlxuICAgKi9cbiAgZnVuY3Rpb24gSFRNTFRyYWNrRWxlbWVudCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgSFRNTFRyYWNrRWxlbWVudCk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudFRhcmdldC5jYWxsKHRoaXMpKTtcblxuICAgIHZhciByZWFkeVN0YXRlID0gdm9pZCAwO1xuICAgIHZhciB0cmFja0VsZW1lbnQgPSBfdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgdHJhY2tFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gSFRNTFRyYWNrRWxlbWVudC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0cmFja0VsZW1lbnRbcHJvcF0gPSBIVE1MVHJhY2tFbGVtZW50LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmFjayA9IG5ldyBUZXh0VHJhY2sob3B0aW9ucyk7XG5cbiAgICB0cmFja0VsZW1lbnQua2luZCA9IHRyYWNrLmtpbmQ7XG4gICAgdHJhY2tFbGVtZW50LnNyYyA9IHRyYWNrLnNyYztcbiAgICB0cmFja0VsZW1lbnQuc3JjbGFuZyA9IHRyYWNrLmxhbmd1YWdlO1xuICAgIHRyYWNrRWxlbWVudC5sYWJlbCA9IHRyYWNrLmxhYmVsO1xuICAgIHRyYWNrRWxlbWVudFsnZGVmYXVsdCddID0gdHJhY2tbJ2RlZmF1bHQnXTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBIVE1MVHJhY2tFbGVtZW50XG4gICAgICogQG1lbWJlciB7SFRNTFRyYWNrRWxlbWVudH5SZWFkeVN0YXRlfSByZWFkeVN0YXRlXG4gICAgICogICAgICAgICBUaGUgY3VycmVudCByZWFkeSBzdGF0ZSBvZiB0aGUgdHJhY2sgZWxlbWVudC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2tFbGVtZW50LCAncmVhZHlTdGF0ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcmVhZHlTdGF0ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBIVE1MVHJhY2tFbGVtZW50XG4gICAgICogQG1lbWJlciB7VGV4dFRyYWNrfSB0cmFja1xuICAgICAqICAgICAgICAgVGhlIHVuZGVybHlpbmcgVGV4dFRyYWNrIG9iamVjdC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cmFja0VsZW1lbnQsICd0cmFjaycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFkeVN0YXRlID0gTk9ORTtcblxuICAgIC8qKlxuICAgICAqIEBsaXN0ZW5zIFRleHRUcmFjayNsb2FkZWRkYXRhXG4gICAgICogQGZpcmVzIEhUTUxUcmFja0VsZW1lbnQjbG9hZFxuICAgICAqL1xuICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZGRhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZWFkeVN0YXRlID0gTE9BREVEO1xuXG4gICAgICB0cmFja0VsZW1lbnQudHJpZ2dlcih7XG4gICAgICAgIHR5cGU6ICdsb2FkJyxcbiAgICAgICAgdGFyZ2V0OiB0cmFja0VsZW1lbnRcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgdmFyIF9yZXQ7XG5cbiAgICAgIHJldHVybiBfcmV0ID0gdHJhY2tFbGVtZW50LCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIEhUTUxUcmFja0VsZW1lbnQ7XG59KEV2ZW50VGFyZ2V0KTtcblxuSFRNTFRyYWNrRWxlbWVudC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7XG4gIGxvYWQ6ICdsb2FkJ1xufTtcblxuSFRNTFRyYWNrRWxlbWVudC5OT05FID0gTk9ORTtcbkhUTUxUcmFja0VsZW1lbnQuTE9BRElORyA9IExPQURJTkc7XG5IVE1MVHJhY2tFbGVtZW50LkxPQURFRCA9IExPQURFRDtcbkhUTUxUcmFja0VsZW1lbnQuRVJST1IgPSBFUlJPUjtcblxuLypcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhbGwgdHJhY2sgcHJvcGVydGllcyB0aGF0IGFyZSB1c2VkIGluXG4gKiBwbGF5ZXIuanMsIHRlY2guanMsIGh0bWw1LmpzIGFuZCBwb3NzaWJseSBvdGhlciB0ZWNocyBpbiB0aGUgZnV0dXJlLlxuICovXG5cbnZhciBOT1JNQUwgPSB7XG4gIGF1ZGlvOiB7XG4gICAgTGlzdENsYXNzOiBBdWRpb1RyYWNrTGlzdCxcbiAgICBUcmFja0NsYXNzOiBBdWRpb1RyYWNrLFxuICAgIGNhcGl0YWxOYW1lOiAnQXVkaW8nXG4gIH0sXG4gIHZpZGVvOiB7XG4gICAgTGlzdENsYXNzOiBWaWRlb1RyYWNrTGlzdCxcbiAgICBUcmFja0NsYXNzOiBWaWRlb1RyYWNrLFxuICAgIGNhcGl0YWxOYW1lOiAnVmlkZW8nXG4gIH0sXG4gIHRleHQ6IHtcbiAgICBMaXN0Q2xhc3M6IFRleHRUcmFja0xpc3QsXG4gICAgVHJhY2tDbGFzczogVGV4dFRyYWNrLFxuICAgIGNhcGl0YWxOYW1lOiAnVGV4dCdcbiAgfVxufTtcblxuT2JqZWN0LmtleXMoTk9STUFMKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIE5PUk1BTFt0eXBlXS5nZXR0ZXJOYW1lID0gdHlwZSArICdUcmFja3MnO1xuICBOT1JNQUxbdHlwZV0ucHJpdmF0ZU5hbWUgPSB0eXBlICsgJ1RyYWNrc18nO1xufSk7XG5cbnZhciBSRU1PVEUgPSB7XG4gIHJlbW90ZVRleHQ6IHtcbiAgICBMaXN0Q2xhc3M6IFRleHRUcmFja0xpc3QsXG4gICAgVHJhY2tDbGFzczogVGV4dFRyYWNrLFxuICAgIGNhcGl0YWxOYW1lOiAnUmVtb3RlVGV4dCcsXG4gICAgZ2V0dGVyTmFtZTogJ3JlbW90ZVRleHRUcmFja3MnLFxuICAgIHByaXZhdGVOYW1lOiAncmVtb3RlVGV4dFRyYWNrc18nXG4gIH0sXG4gIHJlbW90ZVRleHRFbDoge1xuICAgIExpc3RDbGFzczogSHRtbFRyYWNrRWxlbWVudExpc3QsXG4gICAgVHJhY2tDbGFzczogSFRNTFRyYWNrRWxlbWVudCxcbiAgICBjYXBpdGFsTmFtZTogJ1JlbW90ZVRleHRUcmFja0VscycsXG4gICAgZ2V0dGVyTmFtZTogJ3JlbW90ZVRleHRUcmFja0VscycsXG4gICAgcHJpdmF0ZU5hbWU6ICdyZW1vdGVUZXh0VHJhY2tFbHNfJ1xuICB9XG59O1xuXG52YXIgQUxMID0gbWVyZ2VPcHRpb25zKE5PUk1BTCwgUkVNT1RFKTtcblxuUkVNT1RFLm5hbWVzID0gT2JqZWN0LmtleXMoUkVNT1RFKTtcbk5PUk1BTC5uYW1lcyA9IE9iamVjdC5rZXlzKE5PUk1BTCk7XG5BTEwubmFtZXMgPSBbXS5jb25jYXQoUkVNT1RFLm5hbWVzKS5jb25jYXQoTk9STUFMLm5hbWVzKTtcblxuLyoqXG4gKiBAZmlsZSB0ZWNoLmpzXG4gKi9cblxuLyoqXG4gKiBBbiBPYmplY3QgY29udGFpbmluZyBhIHN0cnVjdHVyZSBsaWtlOiBge3NyYzogJ3VybCcsIHR5cGU6ICdtaW1ldHlwZSd9YCBvciBzdHJpbmdcbiAqIHRoYXQganVzdCBjb250YWlucyB0aGUgc3JjIHVybCBhbG9uZS5cbiAqICogYHZhciBTb3VyY2VPYmplY3QgPSB7c3JjOiAnaHR0cDovL2V4LmNvbS92aWRlby5tcDQnLCB0eXBlOiAndmlkZW8vbXA0J307YFxuICAgKiBgdmFyIFNvdXJjZVN0cmluZyA9ICdodHRwOi8vZXhhbXBsZS5jb20vc29tZS12aWRlby5tcDQnO2BcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fHN0cmluZ30gVGVjaH5Tb3VyY2VPYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3JjXG4gKiAgICAgICAgICAgVGhlIHVybCB0byB0aGUgc291cmNlXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICAgICBUaGUgbWltZSB0eXBlIG9mIHRoZSBzb3VyY2VcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdXNlZCBieSB7QGxpbmsgVGVjaH0gdG8gY3JlYXRlIGEgbmV3IHtAbGluayBUZXh0VHJhY2t9LlxuICpcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtUZWNofSBzZWxmXG4gKiAgICAgICAgQW4gaW5zdGFuY2Ugb2YgdGhlIFRlY2ggY2xhc3MuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAqICAgICAgICBgVGV4dFRyYWNrYCBraW5kIChzdWJ0aXRsZXMsIGNhcHRpb25zLCBkZXNjcmlwdGlvbnMsIGNoYXB0ZXJzLCBvciBtZXRhZGF0YSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXVxuICogICAgICAgIExhYmVsIHRvIGlkZW50aWZ5IHRoZSB0ZXh0IHRyYWNrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV1cbiAqICAgICAgICBUd28gbGV0dGVyIGxhbmd1YWdlIGFiYnJldmlhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAqICAgICAgICBBbiBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsIHRleHQgdHJhY2sgb3B0aW9uc1xuICpcbiAqIEByZXR1cm4ge1RleHRUcmFja31cbiAqICAgICAgICAgIFRoZSB0ZXh0IHRyYWNrIHRoYXQgd2FzIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRyYWNrSGVscGVyKHNlbGYsIGtpbmQsIGxhYmVsLCBsYW5ndWFnZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG5cbiAgdmFyIHRyYWNrcyA9IHNlbGYudGV4dFRyYWNrcygpO1xuXG4gIG9wdGlvbnMua2luZCA9IGtpbmQ7XG5cbiAgaWYgKGxhYmVsKSB7XG4gICAgb3B0aW9ucy5sYWJlbCA9IGxhYmVsO1xuICB9XG4gIGlmIChsYW5ndWFnZSkge1xuICAgIG9wdGlvbnMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgfVxuICBvcHRpb25zLnRlY2ggPSBzZWxmO1xuXG4gIHZhciB0cmFjayA9IG5ldyBBTEwudGV4dC5UcmFja0NsYXNzKG9wdGlvbnMpO1xuXG4gIHRyYWNrcy5hZGRUcmFjayh0cmFjayk7XG5cbiAgcmV0dXJuIHRyYWNrO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIG1lZGlhIHBsYXliYWNrIHRlY2hub2xvZ3kgY29udHJvbGxlcnMsIHN1Y2ggYXNcbiAqIHtAbGluayBGbGFzaH0gYW5kIHtAbGluayBIVE1MNX1cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgVGVjaCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFRlY2gsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBUZWNoLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSByZWFkeVxuICAgKiAgICAgICAgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBgSFRNTDVgIFRlY2ggaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBUZWNoKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgcmVhZHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZ1bmN0aW9uICgpIHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRlY2gpO1xuXG4gICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgdGVjaCB0byByZXBvcnQgdXNlciBhY3Rpdml0eSBhdXRvbWF0aWNhbGx5LlxuICAgIC8vIFRoaXMgaXMgZG9uZSBtYW51YWxseSBpbiBhZGRDb250cm9sc0xpc3RlbmVyc1xuICAgIG9wdGlvbnMucmVwb3J0VG91Y2hBY3Rpdml0eSA9IGZhbHNlO1xuXG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZSBjdXJyZW50IHNvdXJjZSBoYXMgcGxheWVkIGF0IGFsbCB0b1xuICAgIC8vIGltcGxlbWVudCBhIHZlcnkgbGltaXRlZCBwbGF5ZWQoKVxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIG51bGwsIG9wdGlvbnMsIHJlYWR5KSk7XG5cbiAgICBfdGhpcy5oYXNTdGFydGVkXyA9IGZhbHNlO1xuICAgIF90aGlzLm9uKCdwbGF5aW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5oYXNTdGFydGVkXyA9IHRydWU7XG4gICAgfSk7XG4gICAgX3RoaXMub24oJ2xvYWRzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaGFzU3RhcnRlZF8gPSBmYWxzZTtcbiAgICB9KTtcblxuICAgIEFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgcHJvcHMgPSBBTExbbmFtZV07XG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnNbcHJvcHMuZ2V0dGVyTmFtZV0pIHtcbiAgICAgICAgX3RoaXNbcHJvcHMucHJpdmF0ZU5hbWVdID0gb3B0aW9uc1twcm9wcy5nZXR0ZXJOYW1lXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIE1hbnVhbGx5IHRyYWNrIHByb2dyZXNzIGluIGNhc2VzIHdoZXJlIHRoZSBicm93c2VyL2ZsYXNoIHBsYXllciBkb2Vzbid0IHJlcG9ydCBpdC5cbiAgICBpZiAoIV90aGlzLmZlYXR1cmVzUHJvZ3Jlc3NFdmVudHMpIHtcbiAgICAgIF90aGlzLm1hbnVhbFByb2dyZXNzT24oKTtcbiAgICB9XG5cbiAgICAvLyBNYW51YWxseSB0cmFjayB0aW1ldXBkYXRlcyBpbiBjYXNlcyB3aGVyZSB0aGUgYnJvd3Nlci9mbGFzaCBwbGF5ZXIgZG9lc24ndCByZXBvcnQgaXQuXG4gICAgaWYgKCFfdGhpcy5mZWF0dXJlc1RpbWV1cGRhdGVFdmVudHMpIHtcbiAgICAgIF90aGlzLm1hbnVhbFRpbWVVcGRhdGVzT24oKTtcbiAgICB9XG5cbiAgICBbJ1RleHQnLCAnQXVkaW8nLCAnVmlkZW8nXS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgaWYgKG9wdGlvbnNbJ25hdGl2ZScgKyB0cmFjayArICdUcmFja3MnXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgX3RoaXNbJ2ZlYXR1cmVzTmF0aXZlJyArIHRyYWNrICsgJ1RyYWNrcyddID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5uYXRpdmVDYXB0aW9ucyA9PT0gZmFsc2UgfHwgb3B0aW9ucy5uYXRpdmVUZXh0VHJhY2tzID09PSBmYWxzZSkge1xuICAgICAgX3RoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm5hdGl2ZUNhcHRpb25zID09PSB0cnVlIHx8IG9wdGlvbnMubmF0aXZlVGV4dFRyYWNrcyA9PT0gdHJ1ZSkge1xuICAgICAgX3RoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIV90aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgX3RoaXMuZW11bGF0ZVRleHRUcmFja3MoKTtcbiAgICB9XG5cbiAgICBfdGhpcy5hdXRvUmVtb3RlVGV4dFRyYWNrc18gPSBuZXcgQUxMLnRleHQuTGlzdENsYXNzKCk7XG5cbiAgICBfdGhpcy5pbml0VHJhY2tMaXN0ZW5lcnMoKTtcblxuICAgIC8vIFR1cm4gb24gY29tcG9uZW50IHRhcCBldmVudHMgb25seSBpZiBub3QgdXNpbmcgbmF0aXZlIGNvbnRyb2xzXG4gICAgaWYgKCFvcHRpb25zLm5hdGl2ZUNvbnRyb2xzRm9yVG91Y2gpIHtcbiAgICAgIF90aGlzLmVtaXRUYXBFdmVudHMoKTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuY29uc3RydWN0b3IpIHtcbiAgICAgIF90aGlzLm5hbWVfID0gX3RoaXMuY29uc3RydWN0b3IubmFtZSB8fCAnVW5rbm93biBUZWNoJztcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyogRmFsbGJhY2tzIGZvciB1bnN1cHBvcnRlZCBldmVudCB0eXBlc1xuICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gIC8qKlxuICAgKiBQb2x5ZmlsbCB0aGUgYHByb2dyZXNzYCBldmVudCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGl0IG5hdGl2ZWx5LlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBUZWNoI3RyYWNrUHJvZ3Jlc3N9XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUubWFudWFsUHJvZ3Jlc3NPbiA9IGZ1bmN0aW9uIG1hbnVhbFByb2dyZXNzT24oKSB7XG4gICAgdGhpcy5vbignZHVyYXRpb25jaGFuZ2UnLCB0aGlzLm9uRHVyYXRpb25DaGFuZ2UpO1xuXG4gICAgdGhpcy5tYW51YWxQcm9ncmVzcyA9IHRydWU7XG5cbiAgICAvLyBUcmlnZ2VyIHByb2dyZXNzIHdhdGNoaW5nIHdoZW4gYSBzb3VyY2UgYmVnaW5zIGxvYWRpbmdcbiAgICB0aGlzLm9uZSgncmVhZHknLCB0aGlzLnRyYWNrUHJvZ3Jlc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUdXJuIG9mZiB0aGUgcG9seWZpbGwgZm9yIGBwcm9ncmVzc2AgZXZlbnRzIHRoYXQgd2FzIGNyZWF0ZWQgaW5cbiAgICoge0BsaW5rIFRlY2gjbWFudWFsUHJvZ3Jlc3NPbn1cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5tYW51YWxQcm9ncmVzc09mZiA9IGZ1bmN0aW9uIG1hbnVhbFByb2dyZXNzT2ZmKCkge1xuICAgIHRoaXMubWFudWFsUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB0aGlzLnN0b3BUcmFja2luZ1Byb2dyZXNzKCk7XG5cbiAgICB0aGlzLm9mZignZHVyYXRpb25jaGFuZ2UnLCB0aGlzLm9uRHVyYXRpb25DaGFuZ2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gdHJpZ2dlciBhIGBwcm9ncmVzc2AgZXZlbnQgd2hlbiB0aGUgYnVmZmVyZWQgcGVyY2VudCBjaGFuZ2VzLiBJdFxuICAgKiBzZXRzIGFuIGludGVydmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgZXZlcnkgNTAwIG1pbGxpc2Vjb25kcyB0byBjaGVjayBpZiB0aGVcbiAgICogYnVmZmVyIGVuZCBwZXJjZW50IGhhcyBjaGFuZ2VkLlxuICAgKlxuICAgKiA+IFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IHtAbGluayBUZWNoI21hbnVhbFByb2dyZXNzT259XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYHJlYWR5YCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCNyZWFkeVxuICAgKiBAZmlyZXMgVGVjaCNwcm9ncmVzc1xuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnRyYWNrUHJvZ3Jlc3MgPSBmdW5jdGlvbiB0cmFja1Byb2dyZXNzKGV2ZW50KSB7XG4gICAgdGhpcy5zdG9wVHJhY2tpbmdQcm9ncmVzcygpO1xuICAgIHRoaXMucHJvZ3Jlc3NJbnRlcnZhbCA9IHRoaXMuc2V0SW50ZXJ2YWwoYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBEb24ndCB0cmlnZ2VyIHVubGVzcyBidWZmZXJlZCBhbW91bnQgaXMgZ3JlYXRlciB0aGFuIGxhc3QgdGltZVxuXG4gICAgICB2YXIgbnVtQnVmZmVyZWRQZXJjZW50ID0gdGhpcy5idWZmZXJlZFBlcmNlbnQoKTtcblxuICAgICAgaWYgKHRoaXMuYnVmZmVyZWRQZXJjZW50XyAhPT0gbnVtQnVmZmVyZWRQZXJjZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUge0BsaW5rIFBsYXllciNwcm9ncmVzc31cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFRlY2gjcHJvZ3Jlc3NcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdwcm9ncmVzcycpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJ1ZmZlcmVkUGVyY2VudF8gPSBudW1CdWZmZXJlZFBlcmNlbnQ7XG5cbiAgICAgIGlmIChudW1CdWZmZXJlZFBlcmNlbnQgPT09IDEpIHtcbiAgICAgICAgdGhpcy5zdG9wVHJhY2tpbmdQcm9ncmVzcygpO1xuICAgICAgfVxuICAgIH0pLCA1MDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgb3VyIGludGVybmFsIGR1cmF0aW9uIG9uIGEgYGR1cmF0aW9uY2hhbmdlYCBldmVudCBieSBjYWxsaW5nXG4gICAqIHtAbGluayBUZWNoI2R1cmF0aW9ufS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgZHVyYXRpb25jaGFuZ2VgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI2R1cmF0aW9uY2hhbmdlXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUub25EdXJhdGlvbkNoYW5nZSA9IGZ1bmN0aW9uIG9uRHVyYXRpb25DaGFuZ2UoZXZlbnQpIHtcbiAgICB0aGlzLmR1cmF0aW9uXyA9IHRoaXMuZHVyYXRpb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuZCBjcmVhdGUgYSBgVGltZVJhbmdlYCBvYmplY3QgZm9yIGJ1ZmZlcmluZy5cbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgKiAgICAgICAgIFRoZSB0aW1lIHJhbmdlIG9iamVjdCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmJ1ZmZlcmVkID0gZnVuY3Rpb24gYnVmZmVyZWQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGVyY2VudGFnZSBvZiB0aGUgY3VycmVudCB2aWRlbyB0aGF0IGlzIGN1cnJlbnRseSBidWZmZXJlZC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIEEgbnVtYmVyIGZyb20gMCB0byAxIHRoYXQgcmVwcmVzZW50cyB0aGUgZGVjaW1hbCBwZXJjZW50YWdlIG9mIHRoZVxuICAgKiAgICAgICAgIHZpZGVvIHRoYXQgaXMgYnVmZmVyZWQuXG4gICAqXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuYnVmZmVyZWRQZXJjZW50ID0gZnVuY3Rpb24gYnVmZmVyZWRQZXJjZW50JCQxKCkge1xuICAgIHJldHVybiBidWZmZXJlZFBlcmNlbnQodGhpcy5idWZmZXJlZCgpLCB0aGlzLmR1cmF0aW9uXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gb2ZmIHRoZSBwb2x5ZmlsbCBmb3IgYHByb2dyZXNzYCBldmVudHMgdGhhdCB3YXMgY3JlYXRlZCBpblxuICAgKiB7QGxpbmsgVGVjaCNtYW51YWxQcm9ncmVzc09ufVxuICAgKiBTdG9wIG1hbnVhbGx5IHRyYWNraW5nIHByb2dyZXNzIGV2ZW50cyBieSBjbGVhcmluZyB0aGUgaW50ZXJ2YWwgdGhhdCB3YXMgc2V0IGluXG4gICAqIHtAbGluayBUZWNoI3RyYWNrUHJvZ3Jlc3N9LlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnN0b3BUcmFja2luZ1Byb2dyZXNzID0gZnVuY3Rpb24gc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKSB7XG4gICAgdGhpcy5jbGVhckludGVydmFsKHRoaXMucHJvZ3Jlc3NJbnRlcnZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBvbHlmaWxsIHRoZSBgdGltZXVwZGF0ZWAgZXZlbnQgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBpdC5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgVGVjaCN0cmFja0N1cnJlbnRUaW1lfVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLm1hbnVhbFRpbWVVcGRhdGVzT24gPSBmdW5jdGlvbiBtYW51YWxUaW1lVXBkYXRlc09uKCkge1xuICAgIHRoaXMubWFudWFsVGltZVVwZGF0ZXMgPSB0cnVlO1xuXG4gICAgdGhpcy5vbigncGxheScsIHRoaXMudHJhY2tDdXJyZW50VGltZSk7XG4gICAgdGhpcy5vbigncGF1c2UnLCB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogVHVybiBvZmYgdGhlIHBvbHlmaWxsIGZvciBgdGltZXVwZGF0ZWAgZXZlbnRzIHRoYXQgd2FzIGNyZWF0ZWQgaW5cbiAgICoge0BsaW5rIFRlY2gjbWFudWFsVGltZVVwZGF0ZXNPbn1cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5tYW51YWxUaW1lVXBkYXRlc09mZiA9IGZ1bmN0aW9uIG1hbnVhbFRpbWVVcGRhdGVzT2ZmKCkge1xuICAgIHRoaXMubWFudWFsVGltZVVwZGF0ZXMgPSBmYWxzZTtcbiAgICB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKCk7XG4gICAgdGhpcy5vZmYoJ3BsYXknLCB0aGlzLnRyYWNrQ3VycmVudFRpbWUpO1xuICAgIHRoaXMub2ZmKCdwYXVzZScsIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHVwIGFuIGludGVydmFsIGZ1bmN0aW9uIHRvIHRyYWNrIGN1cnJlbnQgdGltZSBhbmQgdHJpZ2dlciBgdGltZXVwZGF0ZWAgZXZlcnlcbiAgICogMjUwIG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCNwbGF5XG4gICAqIEB0cmlnZ2VycyBUZWNoI3RpbWV1cGRhdGVcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS50cmFja0N1cnJlbnRUaW1lID0gZnVuY3Rpb24gdHJhY2tDdXJyZW50VGltZSgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50VGltZUludGVydmFsKSB7XG4gICAgICB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFRpbWVJbnRlcnZhbCA9IHRoaXMuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBUcmlnZ2VyZWQgYXQgYW4gaW50ZXJ2YWwgb2YgMjUwbXMgdG8gaW5kaWNhdGVkIHRoYXQgdGltZSBpcyBwYXNzaW5nIGluIHRoZSB2aWRlby5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgVGVjaCN0aW1ldXBkYXRlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICd0aW1ldXBkYXRlJywgdGFyZ2V0OiB0aGlzLCBtYW51YWxseVRyaWdnZXJlZDogdHJ1ZSB9KTtcblxuICAgICAgLy8gNDIgPSAyNCBmcHMgLy8gMjUwIGlzIHdoYXQgV2Via2l0IHVzZXMgLy8gRkYgdXNlcyAxNVxuICAgIH0sIDI1MCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIGludGVydmFsIGZ1bmN0aW9uIGNyZWF0ZWQgaW4ge0BsaW5rIFRlY2gjdHJhY2tDdXJyZW50VGltZX0gc28gdGhhdCB0aGVcbiAgICogYHRpbWV1cGRhdGVgIGV2ZW50IGlzIG5vIGxvbmdlciB0cmlnZ2VyZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHtUZWNoI3BhdXNlfVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lID0gZnVuY3Rpb24gc3RvcFRyYWNraW5nQ3VycmVudFRpbWUoKSB7XG4gICAgdGhpcy5jbGVhckludGVydmFsKHRoaXMuY3VycmVudFRpbWVJbnRlcnZhbCk7XG5cbiAgICAvLyAjMTAwMiAtIGlmIHRoZSB2aWRlbyBlbmRzIHJpZ2h0IGJlZm9yZSB0aGUgbmV4dCB0aW1ldXBkYXRlIHdvdWxkIGhhcHBlbixcbiAgICAvLyB0aGUgcHJvZ3Jlc3MgYmFyIHdvbid0IG1ha2UgaXQgYWxsIHRoZSB3YXkgdG8gdGhlIGVuZFxuICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICd0aW1ldXBkYXRlJywgdGFyZ2V0OiB0aGlzLCBtYW51YWxseVRyaWdnZXJlZDogdHJ1ZSB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVHVybiBvZmYgYWxsIGV2ZW50IHBvbHlmaWxscywgY2xlYXIgdGhlIGBUZWNoYHMge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fSxcbiAgICoge0BsaW5rIFZpZGVvVHJhY2tMaXN0fSwgYW5kIHtAbGluayBUZXh0VHJhY2tMaXN0fSwgYW5kIGRpc3Bvc2Ugb2YgdGhpcyBUZWNoLlxuICAgKlxuICAgKiBAZmlyZXMgQ29tcG9uZW50I2Rpc3Bvc2VcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcblxuICAgIC8vIGNsZWFyIG91dCBhbGwgdHJhY2tzIGJlY2F1c2Ugd2UgY2FuJ3QgcmV1c2UgdGhlbSBiZXR3ZWVuIHRlY2hzXG4gICAgdGhpcy5jbGVhclRyYWNrcyhOT1JNQUwubmFtZXMpO1xuXG4gICAgLy8gVHVybiBvZmYgYW55IG1hbnVhbCBwcm9ncmVzcyBvciB0aW1ldXBkYXRlIHRyYWNraW5nXG4gICAgaWYgKHRoaXMubWFudWFsUHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMubWFudWFsUHJvZ3Jlc3NPZmYoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYW51YWxUaW1lVXBkYXRlcykge1xuICAgICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlc09mZigpO1xuICAgIH1cblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgb3V0IGEgc2luZ2xlIGBUcmFja0xpc3RgIG9yIGFuIGFycmF5IG9mIGBUcmFja0xpc3RzYCBnaXZlbiB0aGVpciBuYW1lcy5cbiAgICpcbiAgICogPiBOb3RlOiBUZWNocyB3aXRob3V0IHNvdXJjZSBoYW5kbGVycyBzaG91bGQgY2FsbCB0aGlzIGJldHdlZW4gc291cmNlcyBmb3IgYHZpZGVvYFxuICAgKiAgICAgICAgICYgYGF1ZGlvYCB0cmFja3MuIFlvdSBkb24ndCB3YW50IHRvIHVzZSB0aGVtIGJldHdlZW4gdHJhY2tzIVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfHN0cmluZ30gdHlwZXNcbiAgICogICAgICAgIFRyYWNrTGlzdCBuYW1lcyB0byBjbGVhciwgdmFsaWQgbmFtZXMgYXJlIGB2aWRlb2AsIGBhdWRpb2AsIGFuZFxuICAgKiAgICAgICAgYHRleHRgLlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmNsZWFyVHJhY2tzID0gZnVuY3Rpb24gY2xlYXJUcmFja3ModHlwZXMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHR5cGVzID0gW10uY29uY2F0KHR5cGVzKTtcbiAgICAvLyBjbGVhciBvdXQgYWxsIHRyYWNrcyBiZWNhdXNlIHdlIGNhbid0IHJldXNlIHRoZW0gYmV0d2VlbiB0ZWNoc1xuICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ID0gX3RoaXMyW3R5cGUgKyAnVHJhY2tzJ10oKSB8fCBbXTtcbiAgICAgIHZhciBpID0gbGlzdC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIHRyYWNrID0gbGlzdFtpXTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgX3RoaXMyLnJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbnkgVGV4dFRyYWNrcyBhZGRlZCB2aWEgYWRkUmVtb3RlVGV4dFRyYWNrIHRoYXQgYXJlXG4gICAqIGZsYWdnZWQgZm9yIGF1dG9tYXRpYyBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5jbGVhbnVwQXV0b1RleHRUcmFja3MgPSBmdW5jdGlvbiBjbGVhbnVwQXV0b1RleHRUcmFja3MoKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLmF1dG9SZW1vdGVUZXh0VHJhY2tzXyB8fCBbXTtcbiAgICB2YXIgaSA9IGxpc3QubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHRyYWNrID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy5yZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVzZXQgdGhlIHRlY2gsIHdoaWNoIHdpbGwgcmVtb3ZlcyBhbGwgc291cmNlcyBhbmQgcmVzZXQgdGhlIGludGVybmFsIHJlYWR5U3RhdGUuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7fTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCBhbiBlcnJvciBvbiB0aGUgVGVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtNZWRpYUVycm9yfSBbZXJyXVxuICAgKiAgICAgICAgRXJyb3IgdG8gc2V0IG9uIHRoZSBUZWNoXG4gICAqXG4gICAqIEByZXR1cm4ge01lZGlhRXJyb3J8bnVsbH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBlcnJvciBvYmplY3Qgb24gdGhlIHRlY2gsIG9yIG51bGwgaWYgdGhlcmUgaXNuJ3Qgb25lLlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmVycm9yXyA9IG5ldyBNZWRpYUVycm9yKGVycik7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVycm9yXztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYFRpbWVSYW5nZWBzIHRoYXQgaGF2ZSBiZWVuIHBsYXllZCB0aHJvdWdoIGZvciB0aGUgY3VycmVudCBzb3VyY2UuXG4gICAqXG4gICAqID4gTk9URTogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBpbmNvbXBsZXRlLiBJdCBkb2VzIG5vdCB0cmFjayB0aGUgcGxheWVkIGBUaW1lUmFuZ2VgLlxuICAgKiAgICAgICAgIEl0IG9ubHkgY2hlY2tzIHdldGhlciB0aGUgc291cmNlIGhhcyBwbGF5ZWQgYXQgYWxsIG9yIG5vdC5cbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgKiAgICAgICAgIC0gQSBzaW5nbGUgdGltZSByYW5nZSBpZiB0aGlzIHZpZGVvIGhhcyBwbGF5ZWRcbiAgICogICAgICAgICAtIEFuIGVtcHR5IHNldCBvZiByYW5nZXMgaWYgbm90LlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnBsYXllZCA9IGZ1bmN0aW9uIHBsYXllZCgpIHtcbiAgICBpZiAodGhpcy5oYXNTdGFydGVkXykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhdXNlcyBhIG1hbnVhbCB0aW1lIHVwZGF0ZSB0byBvY2N1ciBpZiB7QGxpbmsgVGVjaCNtYW51YWxUaW1lVXBkYXRlc09ufSB3YXNcbiAgICogcHJldmlvdXNseSBjYWxsZWQuXG4gICAqXG4gICAqIEBmaXJlcyBUZWNoI3RpbWV1cGRhdGVcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uIHNldEN1cnJlbnRUaW1lKCkge1xuICAgIC8vIGltcHJvdmUgdGhlIGFjY3VyYWN5IG9mIG1hbnVhbCB0aW1ldXBkYXRlc1xuICAgIGlmICh0aGlzLm1hbnVhbFRpbWVVcGRhdGVzKSB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbWFudWFsIGB0aW1ldXBkYXRlYCBldmVudC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgVGVjaCN0aW1ldXBkYXRlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICd0aW1ldXBkYXRlJywgdGFyZ2V0OiB0aGlzLCBtYW51YWxseVRyaWdnZXJlZDogdHJ1ZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gb24gbGlzdGVuZXJzIGZvciB7QGxpbmsgVmlkZW9UcmFja0xpc3R9LCB7QGxpbmsge0F1ZGlvVHJhY2tMaXN0fSwgYW5kXG4gICAqIHtAbGluayBUZXh0VHJhY2tMaXN0fSBldmVudHMuXG4gICAqXG4gICAqIFRoaXMgYWRkcyB7QGxpbmsgRXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcnN9IGZvciBgYWRkdHJhY2tgLCBhbmQgIGByZW1vdmV0cmFja2AuXG4gICAqXG4gICAqIEBmaXJlcyBUZWNoI2F1ZGlvdHJhY2tjaGFuZ2VcbiAgICogQGZpcmVzIFRlY2gjdmlkZW90cmFja2NoYW5nZVxuICAgKiBAZmlyZXMgVGVjaCN0ZXh0dHJhY2tjaGFuZ2VcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5pbml0VHJhY2tMaXN0ZW5lcnMgPSBmdW5jdGlvbiBpbml0VHJhY2tMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0cmFja3MgYXJlIGFkZGVkIG9yIHJlbW92ZWQgb24gdGhlIFRlY2gge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fVxuICAgICAqXG4gICAgICogQGV2ZW50IFRlY2gjYXVkaW90cmFja2NoYW5nZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRyYWNrcyBhcmUgYWRkZWQgb3IgcmVtb3ZlZCBvbiB0aGUgVGVjaCB7QGxpbmsgVmlkZW9UcmFja0xpc3R9XG4gICAgICpcbiAgICAgKiBAZXZlbnQgVGVjaCN2aWRlb3RyYWNrY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdHJhY2tzIGFyZSBhZGRlZCBvciByZW1vdmVkIG9uIHRoZSBUZWNoIHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICAgICAqXG4gICAgICogQGV2ZW50IFRlY2gjdGV4dHRyYWNrY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIE5PUk1BTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgcHJvcHMgPSBOT1JNQUxbbmFtZV07XG4gICAgICB2YXIgdHJhY2tMaXN0Q2hhbmdlcyA9IGZ1bmN0aW9uIHRyYWNrTGlzdENoYW5nZXMoKSB7XG4gICAgICAgIF90aGlzMy50cmlnZ2VyKG5hbWUgKyAndHJhY2tjaGFuZ2UnKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciB0cmFja3MgPSBfdGhpczNbcHJvcHMuZ2V0dGVyTmFtZV0oKTtcblxuICAgICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdHJhY2tMaXN0Q2hhbmdlcyk7XG4gICAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0cmFja0xpc3RDaGFuZ2VzKTtcblxuICAgICAgX3RoaXMzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB0cmFja0xpc3RDaGFuZ2VzKTtcbiAgICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdHJhY2tMaXN0Q2hhbmdlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogRW11bGF0ZSBUZXh0VHJhY2tzIHVzaW5nIHZ0dC5qcyBpZiBuZWNlc3NhcnlcbiAgICpcbiAgICogQGZpcmVzIFRlY2gjdnR0anNsb2FkZWRcbiAgICogQGZpcmVzIFRlY2gjdnR0anNlcnJvclxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmFkZFdlYlZ0dFNjcmlwdF8gPSBmdW5jdGlvbiBhZGRXZWJWdHRTY3JpcHRfKCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgaWYgKHdpbmRvdy5XZWJWVFQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsbHksIFRlY2guZWxfIGlzIGEgY2hpbGQgb2YgYSBkdW1teS1kaXYgd2FpdCB1bnRpbCB0aGUgQ29tcG9uZW50IHN5c3RlbVxuICAgIC8vIHNpZ25hbHMgdGhhdCB0aGUgVGVjaCBpcyByZWFkeSBhdCB3aGljaCBwb2ludCBUZWNoLmVsXyBpcyBwYXJ0IG9mIHRoZSBET01cbiAgICAvLyBiZWZvcmUgaW5zZXJ0aW5nIHRoZSBXZWJWVFQgc2NyaXB0XG4gICAgaWYgKGRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy5lbCgpKSkge1xuXG4gICAgICAvLyBsb2FkIHZpYSByZXF1aXJlIGlmIGF2YWlsYWJsZSBhbmQgdnR0LmpzIHNjcmlwdCBsb2NhdGlvbiB3YXMgbm90IHBhc3NlZCBpblxuICAgICAgLy8gYXMgYW4gb3B0aW9uLiBub3Z0dCBidWlsZHMgd2lsbCB0dXJuIHRoZSBhYm92ZSByZXF1aXJlIGNhbGwgaW50byBhbiBlbXB0eSBvYmplY3RcbiAgICAgIC8vIHdoaWNoIHdpbGwgY2F1c2UgdGhpcyBpZiBjaGVjayB0byBhbHdheXMgZmFpbC5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zX1sndnR0LmpzJ10gJiYgaXNQbGFpbih2dHQpICYmIE9iamVjdC5rZXlzKHZ0dCkubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Z0dGpzbG9hZGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbG9hZCB2dHQuanMgdmlhIHRoZSBzY3JpcHQgbG9jYXRpb24gb3B0aW9uIG9yIHRoZSBjZG4gb2Ygbm8gbG9jYXRpb24gd2FzXG4gICAgICAvLyBwYXNzZWQgaW5cbiAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICAgICAgc2NyaXB0LnNyYyA9IHRoaXMub3B0aW9uc19bJ3Z0dC5qcyddIHx8ICdodHRwczovL3Zqcy56ZW5jZG4ubmV0L3Z0dGpzLzAuMTIuNC92dHQubWluLmpzJztcbiAgICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIHZ0dC5qcyBpcyBsb2FkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBUZWNoI3Z0dGpzbG9hZGVkXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzNC50cmlnZ2VyKCd2dHRqc2xvYWRlZCcpO1xuICAgICAgfTtcbiAgICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiB2dHQuanMgd2FzIG5vdCBsb2FkZWQgZHVlIHRvIGFuIGVycm9yXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBUZWNoI3Z0dGpzbG9hZGVkXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzNC50cmlnZ2VyKCd2dHRqc2Vycm9yJyk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IG51bGw7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgLy8gYnV0IGhhdmUgbm90IGxvYWRlZCB5ZXQgYW5kIHdlIHNldCBpdCB0byB0cnVlIGJlZm9yZSB0aGUgaW5qZWN0IHNvIHRoYXRcbiAgICAgIC8vIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGUgaW5qZWN0ZWQgd2luZG93LldlYlZUVCBpZiBpdCBsb2FkcyByaWdodCBhd2F5XG4gICAgICB3aW5kb3cuV2ViVlRUID0gdHJ1ZTtcbiAgICAgIHRoaXMuZWwoKS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVhZHkodGhpcy5hZGRXZWJWdHRTY3JpcHRfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEVtdWxhdGUgdGV4dHRyYWNrc1xuICAgKlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmVtdWxhdGVUZXh0VHJhY2tzID0gZnVuY3Rpb24gZW11bGF0ZVRleHRUcmFja3MoKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICB2YXIgdHJhY2tzID0gdGhpcy50ZXh0VHJhY2tzKCk7XG4gICAgdmFyIHJlbW90ZVRyYWNrcyA9IHRoaXMucmVtb3RlVGV4dFRyYWNrcygpO1xuICAgIHZhciBoYW5kbGVBZGRUcmFjayA9IGZ1bmN0aW9uIGhhbmRsZUFkZFRyYWNrKGUpIHtcbiAgICAgIHJldHVybiB0cmFja3MuYWRkVHJhY2soZS50cmFjayk7XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlUmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiBoYW5kbGVSZW1vdmVUcmFjayhlKSB7XG4gICAgICByZXR1cm4gdHJhY2tzLnJlbW92ZVRyYWNrKGUudHJhY2spO1xuICAgIH07XG5cbiAgICByZW1vdGVUcmFja3Mub24oJ2FkZHRyYWNrJywgaGFuZGxlQWRkVHJhY2spO1xuICAgIHJlbW90ZVRyYWNrcy5vbigncmVtb3ZldHJhY2snLCBoYW5kbGVSZW1vdmVUcmFjayk7XG5cbiAgICB0aGlzLmFkZFdlYlZ0dFNjcmlwdF8oKTtcblxuICAgIHZhciB1cGRhdGVEaXNwbGF5ID0gZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIHJldHVybiBfdGhpczUudHJpZ2dlcigndGV4dHRyYWNrY2hhbmdlJyk7XG4gICAgfTtcblxuICAgIHZhciB0ZXh0VHJhY2tzQ2hhbmdlcyA9IGZ1bmN0aW9uIHRleHRUcmFja3NDaGFuZ2VzKCkge1xuICAgICAgdXBkYXRlRGlzcGxheSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgICAgdHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgdXBkYXRlRGlzcGxheSk7XG4gICAgICAgIGlmICh0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdjdWVjaGFuZ2UnLCB1cGRhdGVEaXNwbGF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0ZXh0VHJhY2tzQ2hhbmdlcygpO1xuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0ZXh0VHJhY2tzQ2hhbmdlcyk7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHRleHRUcmFja3NDaGFuZ2VzKTtcblxuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdGVUcmFja3Mub2ZmKCdhZGR0cmFjaycsIGhhbmRsZUFkZFRyYWNrKTtcbiAgICAgIHJlbW90ZVRyYWNrcy5vZmYoJ3JlbW92ZXRyYWNrJywgaGFuZGxlUmVtb3ZlVHJhY2spO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRleHRUcmFja3NDaGFuZ2VzKTtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRleHRUcmFja3NDaGFuZ2VzKTtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHRleHRUcmFja3NDaGFuZ2VzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICAgIHRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2N1ZWNoYW5nZScsIHVwZGF0ZURpc3BsYXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJldHVybnMgYSByZW1vdGUge0BsaW5rIFRleHRUcmFja30gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2luZFxuICAgKiAgICAgICAgYFRleHRUcmFja2Aga2luZCAoc3VidGl0bGVzLCBjYXB0aW9ucywgZGVzY3JpcHRpb25zLCBjaGFwdGVycywgb3IgbWV0YWRhdGEpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdXG4gICAqICAgICAgICBMYWJlbCB0byBpZGVudGlmeSB0aGUgdGV4dCB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlXVxuICAgKiAgICAgICAgVHdvIGxldHRlciBsYW5ndWFnZSBhYmJyZXZpYXRpb25cbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrfVxuICAgKiAgICAgICAgIFRoZSBUZXh0VHJhY2sgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuYWRkVGV4dFRyYWNrID0gZnVuY3Rpb24gYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5ndWFnZSkge1xuICAgIGlmICgha2luZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0VHJhY2sga2luZCBpcyByZXF1aXJlZCBidXQgd2FzIG5vdCBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVUcmFja0hlbHBlcih0aGlzLCBraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZW11bGF0ZWQgVGV4dFRyYWNrIGZvciB1c2UgYnkgYWRkUmVtb3RlVGV4dFRyYWNrXG4gICAqXG4gICAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieSBjbGFzc2VzIHRoYXQgaW5oZXJpdCBmcm9tXG4gICAqIFRlY2ggaW4gb3JkZXIgdG8gY3JlYXRlIG5hdGl2ZSBvciBjdXN0b20gVGV4dFRyYWNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gdGhlIG9wdGlvbnMgdG8gaW5pdGlhbGl6ZSB0aGUgVGV4dFRyYWNrIHdpdGguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5raW5kXVxuICAgKiAgICAgICAgYFRleHRUcmFja2Aga2luZCAoc3VidGl0bGVzLCBjYXB0aW9ucywgZGVzY3JpcHRpb25zLCBjaGFwdGVycywgb3IgbWV0YWRhdGEpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWxdLlxuICAgKiAgICAgICAgTGFiZWwgdG8gaWRlbnRpZnkgdGhlIHRleHQgdHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlXVxuICAgKiAgICAgICAgVHdvIGxldHRlciBsYW5ndWFnZSBhYmJyZXZpYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge0hUTUxUcmFja0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIHRyYWNrIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuY3JlYXRlUmVtb3RlVGV4dFRyYWNrID0gZnVuY3Rpb24gY3JlYXRlUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMpIHtcbiAgICB2YXIgdHJhY2sgPSBtZXJnZU9wdGlvbnMob3B0aW9ucywge1xuICAgICAgdGVjaDogdGhpc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBSRU1PVEUucmVtb3RlVGV4dEVsLlRyYWNrQ2xhc3ModHJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVtb3RlIHRleHQgdHJhY2sgb2JqZWN0IGFuZCByZXR1cm5zIGFuIGh0bWwgdHJhY2sgZWxlbWVudC5cbiAgICpcbiAgICogPiBOb3RlOiBUaGlzIGNhbiBiZSBhbiBlbXVsYXRlZCB7QGxpbmsgSFRNTFRyYWNrRWxlbWVudH0gb3IgYSBuYXRpdmUgb25lLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgU2VlIHtAbGluayBUZWNoI2NyZWF0ZVJlbW90ZVRleHRUcmFja30gZm9yIG1vcmUgZGV0YWlsZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbbWFudWFsQ2xlYW51cD10cnVlXVxuICAgKiAgICAgICAgLSBXaGVuIGZhbHNlOiB0aGUgVGV4dFRyYWNrIHdpbGwgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIGZyb20gdGhlIHZpZGVvXG4gICAqICAgICAgICAgIGVsZW1lbnQgd2hlbmV2ZXIgdGhlIHNvdXJjZSBjaGFuZ2VzXG4gICAqICAgICAgICAtIFdoZW4gVHJ1ZTogVGhlIFRleHRUcmFjayB3aWxsIGhhdmUgdG8gYmUgY2xlYW5lZCB1cCBtYW51YWxseVxuICAgKlxuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50fVxuICAgKiAgICAgICAgIEFuIEh0bWwgVHJhY2sgRWxlbWVudC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVGhlIGRlZmF1bHQgZnVuY3Rpb25hbGl0eSBmb3IgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGVxdWl2YWxlbnRcbiAgICogICAgICAgICAgICAgdG8gXCJtYW51YWxDbGVhbnVwPWZhbHNlXCIgaW4gdGhlIGZ1dHVyZS4gVGhlIG1hbnVhbENsZWFudXAgcGFyYW1ldGVyIHdpbGxcbiAgICogICAgICAgICAgICAgYWxzbyBiZSByZW1vdmVkLlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmFkZFJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFJlbW90ZVRleHRUcmFjaygpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgbWFudWFsQ2xlYW51cCA9IGFyZ3VtZW50c1sxXTtcblxuICAgIHZhciBodG1sVHJhY2tFbGVtZW50ID0gdGhpcy5jcmVhdGVSZW1vdGVUZXh0VHJhY2sob3B0aW9ucyk7XG5cbiAgICBpZiAobWFudWFsQ2xlYW51cCAhPT0gdHJ1ZSAmJiBtYW51YWxDbGVhbnVwICE9PSBmYWxzZSkge1xuICAgICAgLy8gZGVwcmVjYXRpb24gd2FybmluZ1xuICAgICAgbG9nJDEud2FybignQ2FsbGluZyBhZGRSZW1vdGVUZXh0VHJhY2sgd2l0aG91dCBleHBsaWNpdGx5IHNldHRpbmcgdGhlIFwibWFudWFsQ2xlYW51cFwiIHBhcmFtZXRlciB0byBgdHJ1ZWAgaXMgZGVwcmVjYXRlZCBhbmQgZGVmYXVsdCB0byBgZmFsc2VgIGluIGZ1dHVyZSB2ZXJzaW9uIG9mIHZpZGVvLmpzJyk7XG4gICAgICBtYW51YWxDbGVhbnVwID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBzdG9yZSBIVE1MVHJhY2tFbGVtZW50IGFuZCBUZXh0VHJhY2sgdG8gcmVtb3RlIGxpc3RcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja0VscygpLmFkZFRyYWNrRWxlbWVudF8oaHRtbFRyYWNrRWxlbWVudCk7XG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkuYWRkVHJhY2soaHRtbFRyYWNrRWxlbWVudC50cmFjayk7XG5cbiAgICBpZiAobWFudWFsQ2xlYW51cCAhPT0gdHJ1ZSkge1xuICAgICAgLy8gY3JlYXRlIHRoZSBUZXh0VHJhY2tMaXN0IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM2LmF1dG9SZW1vdGVUZXh0VHJhY2tzXy5hZGRUcmFjayhodG1sVHJhY2tFbGVtZW50LnRyYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBodG1sVHJhY2tFbGVtZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSByZW1vdGUgdGV4dCB0cmFjayBmcm9tIHRoZSByZW1vdGUgYFRleHRUcmFja0xpc3RgLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAgICogICAgICAgIGBUZXh0VHJhY2tgIHRvIHJlbW92ZSBmcm9tIHRoZSBgVGV4dFRyYWNrTGlzdGBcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5yZW1vdmVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiByZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spIHtcbiAgICB2YXIgdHJhY2tFbGVtZW50ID0gdGhpcy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5nZXRUcmFja0VsZW1lbnRCeVRyYWNrXyh0cmFjayk7XG5cbiAgICAvLyByZW1vdmUgSFRNTFRyYWNrRWxlbWVudCBhbmQgVGV4dFRyYWNrIGZyb20gcmVtb3RlIGxpc3RcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja0VscygpLnJlbW92ZVRyYWNrRWxlbWVudF8odHJhY2tFbGVtZW50KTtcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja3MoKS5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgdGhpcy5hdXRvUmVtb3RlVGV4dFRyYWNrc18ucmVtb3ZlVHJhY2sodHJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGF2YWlsYWJsZSBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBXM0MncyBNZWRpYVxuICAgKiBQbGF5YmFjayBRdWFsaXR5IEFQSS5cbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9tZWRpYS1wbGF5YmFjay1xdWFsaXR5fVxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgQW4gb2JqZWN0IHdpdGggc3VwcG9ydGVkIG1lZGlhIHBsYXliYWNrIHF1YWxpdHkgbWV0cmljc1xuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9IGZ1bmN0aW9uIGdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCkge1xuICAgIHJldHVybiB7fTtcbiAgfTtcblxuICAvKipcbiAgICogQSBtZXRob2QgdG8gc2V0IGEgcG9zdGVyIGZyb20gYSBgVGVjaGAuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnNldFBvc3RlciA9IGZ1bmN0aW9uIHNldFBvc3RlcigpIHt9O1xuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0byBjaGVjayBmb3IgdGhlIHByZXNlbmNlIG9mIHRoZSAncGxheXNpbmluZScgPHZpZGVvPiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnBsYXlzaW5saW5lID0gZnVuY3Rpb24gcGxheXNpbmxpbmUoKSB7fTtcblxuICAvKipcbiAgICogQSBtZXRob2QgdG8gc2V0IG9yIHVuc2V0IHRoZSAncGxheXNpbmluZScgPHZpZGVvPiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnNldFBsYXlzaW5saW5lID0gZnVuY3Rpb24gc2V0UGxheXNpbmxpbmUoKSB7fTtcblxuICAvKlxuICAgKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gbWltZS10eXBlLlxuICAgKlxuICAgKiBUaGUgYmFzZSB0ZWNoIGRvZXMgbm90IHN1cHBvcnQgYW55IHR5cGUsIGJ1dCBzb3VyY2UgaGFuZGxlcnMgbWlnaHRcbiAgICogb3ZlcndyaXRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgIFRoZSBtaW1ldHlwZSB0byBjaGVjayBmb3Igc3VwcG9ydFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgZW1wdHkgc3RyaW5nXG4gICAqXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L2NhblBsYXlUeXBlfVxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uIGNhblBsYXlUeXBlKCkge1xuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHR5cGUgaXMgc3VwcG9ydGVkIGJ5IHRoaXMgdGVjaC5cbiAgICpcbiAgICogVGhlIGJhc2UgdGVjaCBkb2VzIG5vdCBzdXBwb3J0IGFueSB0eXBlLCBidXQgc291cmNlIGhhbmRsZXJzIG1pZ2h0XG4gICAqIG92ZXJ3cml0ZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgVGhlIG1lZGlhIHR5cGUgdG8gY2hlY2tcbiAgICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIHRoZSBuYXRpdmUgdmlkZW8gZWxlbWVudCdzIHJlc3BvbnNlXG4gICAqL1xuXG5cbiAgVGVjaC5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uIGNhblBsYXlUeXBlKCkge1xuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHNvdXJjZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjT2JqXG4gICAqICAgICAgICBUaGUgc291cmNlIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSB0ZWNoXG4gICAqIEByZXR1cm4ge3N0cmluZ30gJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAgICovXG5cblxuICBUZWNoLmNhblBsYXlTb3VyY2UgPSBmdW5jdGlvbiBjYW5QbGF5U291cmNlKHNyY09iaiwgb3B0aW9ucykge1xuICAgIHJldHVybiBUZWNoLmNhblBsYXlUeXBlKHNyY09iai50eXBlKTtcbiAgfTtcblxuICAvKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgYXJndW1lbnQgaXMgYSBUZWNoIG9yIG5vdC5cbiAgICogQ2FuIGJlIHBhc3NlZCBlaXRoZXIgYSBDbGFzcyBsaWtlIGBIdG1sNWAgb3IgYSBpbnN0YW5jZSBsaWtlIGBwbGF5ZXIudGVjaF9gXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnRcbiAgICogICAgICAgIFRoZSBpdGVtIHRvIGNoZWNrXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgV2hldGhlciBpdCBpcyBhIHRlY2ggb3Igbm90XG4gICAqICAgICAgICAgLSBUcnVlIGlmIGl0IGlzIGEgdGVjaFxuICAgKiAgICAgICAgIC0gRmFsc2UgaWYgaXQgaXMgbm90XG4gICAqL1xuXG5cbiAgVGVjaC5pc1RlY2ggPSBmdW5jdGlvbiBpc1RlY2goY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5wcm90b3R5cGUgaW5zdGFuY2VvZiBUZWNoIHx8IGNvbXBvbmVudCBpbnN0YW5jZW9mIFRlY2ggfHwgY29tcG9uZW50ID09PSBUZWNoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBgVGVjaGAgaW50byBhIHNoYXJlZCBsaXN0IGZvciB2aWRlb2pzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgTmFtZSBvZiB0aGUgYFRlY2hgIHRvIHJlZ2lzdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGVjaFxuICAgKiAgICAgICAgVGhlIGBUZWNoYCBjbGFzcyB0byByZWdpc3Rlci5cbiAgICovXG5cblxuICBUZWNoLnJlZ2lzdGVyVGVjaCA9IGZ1bmN0aW9uIHJlZ2lzdGVyVGVjaChuYW1lLCB0ZWNoKSB7XG4gICAgaWYgKCFUZWNoLnRlY2hzXykge1xuICAgICAgVGVjaC50ZWNoc18gPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIVRlY2guaXNUZWNoKHRlY2gpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlY2ggJyArIG5hbWUgKyAnIG11c3QgYmUgYSBUZWNoJyk7XG4gICAgfVxuXG4gICAgaWYgKCFUZWNoLmNhblBsYXlUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlY2hzIG11c3QgaGF2ZSBhIHN0YXRpYyBjYW5QbGF5VHlwZSBtZXRob2Qgb24gdGhlbScpO1xuICAgIH1cbiAgICBpZiAoIVRlY2guY2FuUGxheVNvdXJjZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZWNocyBtdXN0IGhhdmUgYSBzdGF0aWMgY2FuUGxheVNvdXJjZSBtZXRob2Qgb24gdGhlbScpO1xuICAgIH1cblxuICAgIG5hbWUgPSB0b1RpdGxlQ2FzZShuYW1lKTtcblxuICAgIFRlY2gudGVjaHNfW25hbWVdID0gdGVjaDtcbiAgICBpZiAobmFtZSAhPT0gJ1RlY2gnKSB7XG4gICAgICAvLyBjYW1lbCBjYXNlIHRoZSB0ZWNoTmFtZSBmb3IgdXNlIGluIHRlY2hPcmRlclxuICAgICAgVGVjaC5kZWZhdWx0VGVjaE9yZGVyXy5wdXNoKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGVjaDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgYFRlY2hgIGZyb20gdGhlIHNoYXJlZCBsaXN0IGJ5IG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICBgY2FtZWxDYXNlYCBvciBgVGl0bGVDYXNlYCBuYW1lIG9mIHRoZSBUZWNoIHRvIGdldFxuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNofHVuZGVmaW5lZH1cbiAgICogICAgICAgICBUaGUgYFRlY2hgIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSB3YXMgbm8gdGVjaCB3aXRoIHRoZSBuYW1lIHJlcXVzdGVkLlxuICAgKi9cblxuXG4gIFRlY2guZ2V0VGVjaCA9IGZ1bmN0aW9uIGdldFRlY2gobmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5hbWUgPSB0b1RpdGxlQ2FzZShuYW1lKTtcblxuICAgIGlmIChUZWNoLnRlY2hzXyAmJiBUZWNoLnRlY2hzX1tuYW1lXSkge1xuICAgICAgcmV0dXJuIFRlY2gudGVjaHNfW25hbWVdO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cgJiYgd2luZG93LnZpZGVvanMgJiYgd2luZG93LnZpZGVvanNbbmFtZV0pIHtcbiAgICAgIGxvZyQxLndhcm4oJ1RoZSAnICsgbmFtZSArICcgdGVjaCB3YXMgYWRkZWQgdG8gdGhlIHZpZGVvanMgb2JqZWN0IHdoZW4gaXQgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgdXNpbmcgdmlkZW9qcy5yZWdpc3RlclRlY2gobmFtZSwgdGVjaCknKTtcbiAgICAgIHJldHVybiB3aW5kb3cudmlkZW9qc1tuYW1lXTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRlY2g7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogR2V0IHRoZSB7QGxpbmsgVmlkZW9UcmFja0xpc3R9XG4gKlxuICogQHJldHVybnMge1ZpZGVvVHJhY2tMaXN0fVxuICogQG1ldGhvZCBUZWNoLnByb3RvdHlwZS52aWRlb1RyYWNrc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSB7QGxpbmsgQXVkaW9UcmFja0xpc3R9XG4gKlxuICogQHJldHVybnMge0F1ZGlvVHJhY2tMaXN0fVxuICogQG1ldGhvZCBUZWNoLnByb3RvdHlwZS5hdWRpb1RyYWNrc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSB7QGxpbmsgVGV4dFRyYWNrTGlzdH1cbiAqXG4gKiBAcmV0dXJucyB7VGV4dFRyYWNrTGlzdH1cbiAqIEBtZXRob2QgVGVjaC5wcm90b3R5cGUudGV4dFRyYWNrc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSByZW1vdGUgZWxlbWVudCB7QGxpbmsgVGV4dFRyYWNrTGlzdH1cbiAqXG4gKiBAcmV0dXJucyB7VGV4dFRyYWNrTGlzdH1cbiAqIEBtZXRob2QgVGVjaC5wcm90b3R5cGUucmVtb3RlVGV4dFRyYWNrc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSByZW1vdGUgZWxlbWVudCB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudExpc3R9XG4gKlxuICogQHJldHVybnMge0h0bWxUcmFja0VsZW1lbnRMaXN0fVxuICogQG1ldGhvZCBUZWNoLnByb3RvdHlwZS5yZW1vdGVUZXh0VHJhY2tFbHNcbiAqL1xuXG5BTEwubmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcHJvcHMgPSBBTExbbmFtZV07XG5cbiAgVGVjaC5wcm90b3R5cGVbcHJvcHMuZ2V0dGVyTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpc1twcm9wcy5wcml2YXRlTmFtZV0gPSB0aGlzW3Byb3BzLnByaXZhdGVOYW1lXSB8fCBuZXcgcHJvcHMuTGlzdENsYXNzKCk7XG4gICAgcmV0dXJuIHRoaXNbcHJvcHMucHJpdmF0ZU5hbWVdO1xuICB9O1xufSk7XG5cbi8qKlxuICogTGlzdCBvZiBhc3NvY2lhdGVkIHRleHQgdHJhY2tzXG4gKlxuICogQHR5cGUge1RleHRUcmFja0xpc3R9XG4gKiBAcHJpdmF0ZVxuICogQHByb3BlcnR5IFRlY2gjdGV4dFRyYWNrc19cbiAqL1xuXG4vKipcbiAqIExpc3Qgb2YgYXNzb2NpYXRlZCBhdWRpbyB0cmFja3MuXG4gKlxuICogQHR5cGUge0F1ZGlvVHJhY2tMaXN0fVxuICogQHByaXZhdGVcbiAqIEBwcm9wZXJ0eSBUZWNoI2F1ZGlvVHJhY2tzX1xuICovXG5cbi8qKlxuICogTGlzdCBvZiBhc3NvY2lhdGVkIHZpZGVvIHRyYWNrcy5cbiAqXG4gKiBAdHlwZSB7VmlkZW9UcmFja0xpc3R9XG4gKiBAcHJpdmF0ZVxuICogQHByb3BlcnR5IFRlY2gjdmlkZW9UcmFja3NfXG4gKi9cblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2V0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgdm9sdW1lIGNvbnRyb2wuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wgPSB0cnVlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0IGZ1bGxzY3JlZW4gcmVzaXplIGNvbnRyb2wuXG4gKiBSZXNpemluZyBwbHVnaW5zIHVzaW5nIHJlcXVlc3QgZnVsbHNjcmVlbiByZWxvYWRzIHRoZSBwbHVnaW5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzRnVsbHNjcmVlblJlc2l6ZSA9IGZhbHNlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyBjaGFuZ2luZyB0aGUgc3BlZWQgYXQgd2hpY2ggdGhlIHZpZGVvXG4gKiBwbGF5cy4gRXhhbXBsZXM6XG4gKiAgIC0gU2V0IHBsYXllciB0byBwbGF5IDJ4ICh0d2ljZSkgYXMgZmFzdFxuICogICAtIFNldCBwbGF5ZXIgdG8gcGxheSAwLjV4IChoYWxmKSBhcyBmYXN0XG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1BsYXliYWNrUmF0ZSA9IGZhbHNlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB0aGUgYHByb2dyZXNzYCBldmVudC4gVGhpcyBpcyBjdXJyZW50bHlcbiAqIG5vdCB0cmlnZ2VyZWQgYnkgdmlkZW8tanMtc3dmLiBUaGlzIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWZcbiAqIHtAbGluayBUZWNoI21hbnVhbFByb2dyZXNzT259IHNob3VsZCBiZSBjYWxsZWQuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1Byb2dyZXNzRXZlbnRzID0gZmFsc2U7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIHRoZSBgdGltZXVwZGF0ZWAgZXZlbnQuIFRoaXMgaXMgY3VycmVudGx5XG4gKiBub3QgdHJpZ2dlcmVkIGJ5IHZpZGVvLWpzLXN3Zi4gVGhpcyB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmXG4gKiB7QGxpbmsgVGVjaCNtYW51YWxUaW1lVXBkYXRlc30gc2hvdWxkIGJlIGNhbGxlZC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzVGltZXVwZGF0ZUV2ZW50cyA9IGZhbHNlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB0aGUgbmF0aXZlIGBUZXh0VHJhY2tgcy5cbiAqIFRoaXMgd2lsbCBoZWxwIHVzIGludGVncmF0ZSB3aXRoIG5hdGl2ZSBgVGV4dFRyYWNrYHMgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlbS5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyA9IGZhbHNlO1xuXG4vKipcbiAqIEEgZnVuY3Rpb25hbCBtaXhpbiBmb3IgdGVjaHMgdGhhdCB3YW50IHRvIHVzZSB0aGUgU291cmNlIEhhbmRsZXIgcGF0dGVybi5cbiAqIFNvdXJjZSBoYW5kbGVycyBhcmUgc2NyaXB0cyBmb3IgaGFuZGxpbmcgc3BlY2lmaWMgZm9ybWF0cy5cbiAqIFRoZSBzb3VyY2UgaGFuZGxlciBwYXR0ZXJuIGlzIHVzZWQgZm9yIGFkYXB0aXZlIGZvcm1hdHMgKEhMUywgREFTSCkgdGhhdFxuICogbWFudWFsbHkgbG9hZCB2aWRlbyBkYXRhIGFuZCBmZWVkIGl0IGludG8gYSBTb3VyY2UgQnVmZmVyIChNZWRpYSBTb3VyY2UgRXh0ZW5zaW9ucylcbiAqIEV4YW1wbGU6IGBUZWNoLndpdGhTb3VyY2VIYW5kbGVycy5jYWxsKE15VGVjaCk7YFxuICpcbiAqIEBwYXJhbSB7VGVjaH0gX1RlY2hcbiAqICAgICAgICBUaGUgdGVjaCB0byBhZGQgc291cmNlIGhhbmRsZXIgZnVuY3Rpb25zIHRvLlxuICpcbiAqIEBtaXhlcyBUZWNoflNvdXJjZUhhbmRsZXJBZGRpdGlvbnNcbiAqL1xuVGVjaC53aXRoU291cmNlSGFuZGxlcnMgPSBmdW5jdGlvbiAoX1RlY2gpIHtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBzb3VyY2UgaGFuZGxlclxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqICAgICAgICBUaGUgc291cmNlIGhhbmRsZXIgY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cbiAgICogICAgICAgIFJlZ2lzdGVyIGl0IGF0IHRoZSBmb2xsb3dpbmcgaW5kZXhcbiAgICovXG4gIF9UZWNoLnJlZ2lzdGVyU291cmNlSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyLCBpbmRleCkge1xuICAgIHZhciBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzO1xuXG4gICAgaWYgKCFoYW5kbGVycykge1xuICAgICAgaGFuZGxlcnMgPSBfVGVjaC5zb3VyY2VIYW5kbGVycyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgICAgaW5kZXggPSBoYW5kbGVycy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaGFuZGxlcnMuc3BsaWNlKGluZGV4LCAwLCBoYW5kbGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHR5cGUuIEFsc28gY2hlY2tzIHRoZVxuICAgKiBUZWNocyBzb3VyY2VIYW5kbGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogICAgICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKi9cbiAgX1RlY2guY2FuUGxheVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzIHx8IFtdO1xuICAgIHZhciBjYW4gPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYW4gPSBoYW5kbGVyc1tpXS5jYW5QbGF5VHlwZSh0eXBlKTtcblxuICAgICAgaWYgKGNhbikge1xuICAgICAgICByZXR1cm4gY2FuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3Qgc291cmNlIGhhbmRsZXIgdGhhdCBzdXBwb3J0cyB0aGUgc291cmNlLlxuICAgKlxuICAgKiBUT0RPOiBBbnN3ZXIgcXVlc3Rpb246IHNob3VsZCAncHJvYmFibHknIGJlIHByaW9yaXRpemVkIG92ZXIgJ21heWJlJ1xuICAgKlxuICAgKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzb3VyY2VcbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIHRlY2hcbiAgICpcbiAgICogQHJldHVybiB7U291cmNlSGFuZGxlcnxudWxsfVxuICAgKiAgICAgICAgICBUaGUgZmlyc3Qgc291cmNlIGhhbmRsZXIgdGhhdCBzdXBwb3J0cyB0aGUgc291cmNlIG9yIG51bGwgaWZcbiAgICogICAgICAgICAgbm8gU291cmNlSGFuZGxlciBzdXBwb3J0cyB0aGUgc291cmNlXG4gICAqL1xuICBfVGVjaC5zZWxlY3RTb3VyY2VIYW5kbGVyID0gZnVuY3Rpb24gKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHZhciBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzIHx8IFtdO1xuICAgIHZhciBjYW4gPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYW4gPSBoYW5kbGVyc1tpXS5jYW5IYW5kbGVTb3VyY2Uoc291cmNlLCBvcHRpb25zKTtcblxuICAgICAgaWYgKGNhbikge1xuICAgICAgICByZXR1cm4gaGFuZGxlcnNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNyY09ialxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgdGVjaFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAgICovXG4gIF9UZWNoLmNhblBsYXlTb3VyY2UgPSBmdW5jdGlvbiAoc3JjT2JqLCBvcHRpb25zKSB7XG4gICAgdmFyIHNoID0gX1RlY2guc2VsZWN0U291cmNlSGFuZGxlcihzcmNPYmosIG9wdGlvbnMpO1xuXG4gICAgaWYgKHNoKSB7XG4gICAgICByZXR1cm4gc2guY2FuSGFuZGxlU291cmNlKHNyY09iaiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHVzaW5nIGEgc291cmNlIGhhbmRsZXIsIHByZWZlciBpdHMgaW1wbGVtZW50YXRpb24gb2ZcbiAgICogYW55IGZ1bmN0aW9uIG5vcm1hbGx5IHByb3ZpZGVkIGJ5IHRoZSB0ZWNoLlxuICAgKi9cbiAgdmFyIGRlZmVycmFibGUgPSBbJ3NlZWthYmxlJywgJ2R1cmF0aW9uJ107XG5cbiAgLyoqXG4gICAqIEEgd3JhcHBlciBhcm91bmQge0BsaW5rIFRlY2gjc2Vla2FibGV9IHRoYXQgd2lsbCBjYWxsIGEgYFNvdXJjZUhhbmRsZXJgcyBzZWVrYWJsZVxuICAgKiBmdW5jdGlvbiBpZiBpdCBleGlzdHMsIHdpdGggYSBmYWxsYmFjayB0byB0aGUgVGVjaHMgc2Vla2FibGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBtZXRob2QgX1RlY2guc2Vla2FibGVcbiAgICovXG5cbiAgLyoqXG4gICAqIEEgd3JhcHBlciBhcm91bmQge0BsaW5rIFRlY2gjZHVyYXRpb259IHRoYXQgd2lsbCBjYWxsIGEgYFNvdXJjZUhhbmRsZXJgcyBkdXJhdGlvblxuICAgKiBmdW5jdGlvbiBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSBpdCB3aWxsIGZhbGxiYWNrIHRvIHRoZSB0ZWNocyBkdXJhdGlvbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQG1ldGhvZCBfVGVjaC5kdXJhdGlvblxuICAgKi9cblxuICBkZWZlcnJhYmxlLmZvckVhY2goZnVuY3Rpb24gKGZuTmFtZSkge1xuICAgIHZhciBvcmlnaW5hbEZuID0gdGhpc1tmbk5hbWVdO1xuXG4gICAgaWYgKHR5cGVvZiBvcmlnaW5hbEZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpc1tmbk5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuc291cmNlSGFuZGxlcl8gJiYgdGhpcy5zb3VyY2VIYW5kbGVyX1tmbk5hbWVdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZUhhbmRsZXJfW2ZuTmFtZV0uYXBwbHkodGhpcy5zb3VyY2VIYW5kbGVyXywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW5hbEZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSwgX1RlY2gucHJvdG90eXBlKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgZnVuY3Rpb24gZm9yIHNldHRpbmcgdGhlIHNvdXJjZSB1c2luZyBhIHNvdXJjZSBvYmplY3RcbiAgICogYW5kIHNvdXJjZSBoYW5kbGVycy5cbiAgICogU2hvdWxkIG5ldmVyIGJlIGNhbGxlZCB1bmxlc3MgYSBzb3VyY2UgaGFuZGxlciB3YXMgZm91bmQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNvdXJjZVxuICAgKiAgICAgICAgQSBzb3VyY2Ugb2JqZWN0IHdpdGggc3JjIGFuZCB0eXBlIGtleXNcbiAgICovXG4gIF9UZWNoLnByb3RvdHlwZS5zZXRTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgdmFyIHNoID0gX1RlY2guc2VsZWN0U291cmNlSGFuZGxlcihzb3VyY2UsIHRoaXMub3B0aW9uc18pO1xuXG4gICAgaWYgKCFzaCkge1xuICAgICAgLy8gRmFsbCBiYWNrIHRvIGEgbmF0aXZlIHNvdXJjZSBoYW5kZXIgd2hlbiB1bnN1cHBvcnRlZCBzb3VyY2VzIGFyZVxuICAgICAgLy8gZGVsaWJlcmF0ZWx5IHNldFxuICAgICAgaWYgKF9UZWNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIpIHtcbiAgICAgICAgc2ggPSBfVGVjaC5uYXRpdmVTb3VyY2VIYW5kbGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nJDEuZXJyb3IoJ05vIHNvdXJjZSBoYW5kZXIgZm91bmQgZm9yIHRoZSBjdXJyZW50IHNvdXJjZS4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNwb3NlIGFueSBleGlzdGluZyBzb3VyY2UgaGFuZGxlclxuICAgIHRoaXMuZGlzcG9zZVNvdXJjZUhhbmRsZXIoKTtcbiAgICB0aGlzLm9mZignZGlzcG9zZScsIHRoaXMuZGlzcG9zZVNvdXJjZUhhbmRsZXIpO1xuXG4gICAgaWYgKHNoICE9PSBfVGVjaC5uYXRpdmVTb3VyY2VIYW5kbGVyKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTb3VyY2VfID0gc291cmNlO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlSGFuZGxlcl8gPSBzaC5oYW5kbGVTb3VyY2Uoc291cmNlLCB0aGlzLCB0aGlzLm9wdGlvbnNfKTtcbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgdGhpcy5kaXNwb3NlU291cmNlSGFuZGxlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGFueSBleGlzdGluZyBTb3VyY2VIYW5kbGVycyBhbmQgbGlzdGVuZXJzIHdoZW4gdGhlIFRlY2ggaXMgZGlzcG9zZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjZGlzcG9zZVxuICAgKi9cbiAgX1RlY2gucHJvdG90eXBlLmRpc3Bvc2VTb3VyY2VIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGlmIHdlIGhhdmUgYSBzb3VyY2UgYW5kIGdldCBhbm90aGVyIG9uZVxuICAgIC8vIHRoZW4gd2UgYXJlIGxvYWRpbmcgc29tZXRoaW5nIG5ld1xuICAgIC8vIHRoYW4gY2xlYXIgYWxsIG9mIG91ciBjdXJyZW50IHRyYWNrc1xuICAgIGlmICh0aGlzLmN1cnJlbnRTb3VyY2VfKSB7XG4gICAgICB0aGlzLmNsZWFyVHJhY2tzKFsnYXVkaW8nLCAndmlkZW8nXSk7XG4gICAgICB0aGlzLmN1cnJlbnRTb3VyY2VfID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBhbHdheXMgY2xlYW4gdXAgYXV0by10ZXh0IHRyYWNrc1xuICAgIHRoaXMuY2xlYW51cEF1dG9UZXh0VHJhY2tzKCk7XG5cbiAgICBpZiAodGhpcy5zb3VyY2VIYW5kbGVyXykge1xuXG4gICAgICBpZiAodGhpcy5zb3VyY2VIYW5kbGVyXy5kaXNwb3NlKSB7XG4gICAgICAgIHRoaXMuc291cmNlSGFuZGxlcl8uZGlzcG9zZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNvdXJjZUhhbmRsZXJfID0gbnVsbDtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBUaGUgYmFzZSBUZWNoIGNsYXNzIG5lZWRzIHRvIGJlIHJlZ2lzdGVyZWQgYXMgYSBDb21wb25lbnQuIEl0IGlzIHRoZSBvbmx5XG4vLyBUZWNoIHRoYXQgY2FuIGJlIHJlZ2lzdGVyZWQgYXMgYSBDb21wb25lbnQuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RlY2gnLCBUZWNoKTtcblRlY2gucmVnaXN0ZXJUZWNoKCdUZWNoJywgVGVjaCk7XG5cbi8qKlxuICogQSBsaXN0IG9mIHRlY2hzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRlY2hPcmRlciBvbiBQbGF5ZXJzXG4gKlxuICogQHByaXZhdGVcbiAqL1xuVGVjaC5kZWZhdWx0VGVjaE9yZGVyXyA9IFtdO1xuXG52YXIgbWlkZGxld2FyZXMgPSB7fTtcblxuZnVuY3Rpb24gdXNlKHR5cGUsIG1pZGRsZXdhcmUpIHtcbiAgbWlkZGxld2FyZXNbdHlwZV0gPSBtaWRkbGV3YXJlc1t0eXBlXSB8fCBbXTtcbiAgbWlkZGxld2FyZXNbdHlwZV0ucHVzaChtaWRkbGV3YXJlKTtcbn1cblxuXG5cbmZ1bmN0aW9uIHNldFNvdXJjZShwbGF5ZXIsIHNyYywgbmV4dCkge1xuICBwbGF5ZXIuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNldFNvdXJjZUhlbHBlcihzcmMsIG1pZGRsZXdhcmVzW3NyYy50eXBlXSwgbmV4dCwgcGxheWVyKTtcbiAgfSwgMSk7XG59XG5cbmZ1bmN0aW9uIHNldFRlY2gobWlkZGxld2FyZSwgdGVjaCkge1xuICBtaWRkbGV3YXJlLmZvckVhY2goZnVuY3Rpb24gKG13KSB7XG4gICAgcmV0dXJuIG13LnNldFRlY2ggJiYgbXcuc2V0VGVjaCh0ZWNoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldCQxKG1pZGRsZXdhcmUsIHRlY2gsIG1ldGhvZCkge1xuICByZXR1cm4gbWlkZGxld2FyZS5yZWR1Y2VSaWdodChtaWRkbGV3YXJlSXRlcmF0b3IobWV0aG9kKSwgdGVjaFttZXRob2RdKCkpO1xufVxuXG5mdW5jdGlvbiBzZXQkMShtaWRkbGV3YXJlLCB0ZWNoLCBtZXRob2QsIGFyZykge1xuICByZXR1cm4gdGVjaFttZXRob2RdKG1pZGRsZXdhcmUucmVkdWNlKG1pZGRsZXdhcmVJdGVyYXRvcihtZXRob2QpLCBhcmcpKTtcbn1cblxudmFyIGFsbG93ZWRHZXR0ZXJzID0ge1xuICBidWZmZXJlZDogMSxcbiAgY3VycmVudFRpbWU6IDEsXG4gIGR1cmF0aW9uOiAxLFxuICBzZWVrYWJsZTogMSxcbiAgcGxheWVkOiAxXG59O1xuXG52YXIgYWxsb3dlZFNldHRlcnMgPSB7XG4gIHNldEN1cnJlbnRUaW1lOiAxXG59O1xuXG5mdW5jdGlvbiBtaWRkbGV3YXJlSXRlcmF0b3IobWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIG13KSB7XG4gICAgaWYgKG13W21ldGhvZF0pIHtcbiAgICAgIHJldHVybiBtd1ttZXRob2RdKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNldFNvdXJjZUhlbHBlcigpIHtcbiAgdmFyIHNyYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBtaWRkbGV3YXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgdmFyIG5leHQgPSBhcmd1bWVudHNbMl07XG4gIHZhciBwbGF5ZXIgPSBhcmd1bWVudHNbM107XG4gIHZhciBhY2MgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFtdO1xuICB2YXIgbGFzdFJ1biA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogZmFsc2U7XG4gIHZhciBtd0ZhY3RvcnkgPSBtaWRkbGV3YXJlWzBdLFxuICAgICAgbXdyZXN0ID0gbWlkZGxld2FyZS5zbGljZSgxKTtcblxuICAvLyBpZiBtd0ZhY3RvcnkgaXMgYSBzdHJpbmcsIHRoZW4gd2UncmUgYXQgYSBmb3JrIGluIHRoZSByb2FkXG5cbiAgaWYgKHR5cGVvZiBtd0ZhY3RvcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgc2V0U291cmNlSGVscGVyKHNyYywgbWlkZGxld2FyZXNbbXdGYWN0b3J5XSwgbmV4dCwgcGxheWVyLCBhY2MsIGxhc3RSdW4pO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBhbiBtd0ZhY3RvcnksIGNhbGwgaXQgd2l0aCB0aGUgcGxheWVyIHRvIGdldCB0aGUgbXcsXG4gICAgLy8gdGhlbiBjYWxsIHRoZSBtdydzIHNldFNvdXJjZSBtZXRob2RcbiAgfSBlbHNlIGlmIChtd0ZhY3RvcnkpIHtcbiAgICB2YXIgbXcgPSBtd0ZhY3RvcnkocGxheWVyKTtcblxuICAgIG13LnNldFNvdXJjZShhc3NpZ24oe30sIHNyYyksIGZ1bmN0aW9uIChlcnIsIF9zcmMpIHtcblxuICAgICAgLy8gc29tZXRoaW5nIGhhcHBlbmVkLCB0cnkgdGhlIG5leHQgbWlkZGxld2FyZSBvbiB0aGUgY3VycmVudCBsZXZlbFxuICAgICAgLy8gbWFrZSBzdXJlIHRvIHVzZSB0aGUgb2xkIHNyY1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gc2V0U291cmNlSGVscGVyKHNyYywgbXdyZXN0LCBuZXh0LCBwbGF5ZXIsIGFjYywgbGFzdFJ1bik7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlJ3ZlIHN1Y2NlZWRlZCwgbm93IHdlIG5lZWQgdG8gZ28gZGVlcGVyXG4gICAgICBhY2MucHVzaChtdyk7XG5cbiAgICAgIC8vIGlmIGl0J3MgdGhlIHNhbWUgdHlwZSwgY29udGludWUgZG93biB0aGUgY3VycmVudCBjaGFpblxuICAgICAgLy8gb3RoZXJ3aXNlLCB3ZSB3YW50IHRvIGdvIGRvd24gdGhlIG5ldyBjaGFpblxuICAgICAgc2V0U291cmNlSGVscGVyKF9zcmMsIHNyYy50eXBlID09PSBfc3JjLnR5cGUgPyBtd3Jlc3QgOiBtaWRkbGV3YXJlc1tfc3JjLnR5cGVdLCBuZXh0LCBwbGF5ZXIsIGFjYywgbGFzdFJ1bik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAobXdyZXN0Lmxlbmd0aCkge1xuICAgIHNldFNvdXJjZUhlbHBlcihzcmMsIG13cmVzdCwgbmV4dCwgcGxheWVyLCBhY2MsIGxhc3RSdW4pO1xuICB9IGVsc2UgaWYgKGxhc3RSdW4pIHtcbiAgICBuZXh0KHNyYywgYWNjKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtaWRkbGV3YXJlc1snKiddLCBuZXh0LCBwbGF5ZXIsIGFjYywgdHJ1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAbW9kdWxlIGZpbHRlci1zb3VyY2VcbiAqL1xuLyoqXG4gKiBGaWx0ZXIgb3V0IHNpbmdsZSBiYWQgc291cmNlIG9iamVjdHMgb3IgbXVsdGlwbGUgc291cmNlIG9iamVjdHMgaW4gYW5cbiAqIGFycmF5LiBBbHNvIGZsYXR0ZW5zIG5lc3RlZCBzb3VyY2Ugb2JqZWN0IGFycmF5cyBpbnRvIGEgMSBkaW1lbnNpb25hbFxuICogYXJyYXkgb2Ygc291cmNlIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdHxUZWNoflNvdXJjZU9iamVjdFtdfSBzcmNcbiAqICAgICAgICBUaGUgc3JjIG9iamVjdCB0byBmaWx0ZXJcbiAqXG4gKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdFtdfVxuICogICAgICAgICBBbiBhcnJheSBvZiBzb3VyY2VvYmplY3RzIGNvbnRhaW5pbmcgb25seSB2YWxpZCBzb3VyY2VzXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGZpbHRlclNvdXJjZSA9IGZ1bmN0aW9uIGZpbHRlclNvdXJjZShzcmMpIHtcbiAgLy8gdHJhdmVyc2UgYXJyYXlcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgIHZhciBuZXdzcmMgPSBbXTtcblxuICAgIHNyYy5mb3JFYWNoKGZ1bmN0aW9uIChzcmNvYmopIHtcbiAgICAgIHNyY29iaiA9IGZpbHRlclNvdXJjZShzcmNvYmopO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzcmNvYmopKSB7XG4gICAgICAgIG5ld3NyYyA9IG5ld3NyYy5jb25jYXQoc3Jjb2JqKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qoc3Jjb2JqKSkge1xuICAgICAgICBuZXdzcmMucHVzaChzcmNvYmopO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc3JjID0gbmV3c3JjO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnICYmIHNyYy50cmltKCkpIHtcbiAgICAvLyBjb252ZXJ0IHN0cmluZyBpbnRvIG9iamVjdFxuICAgIHNyYyA9IFt7IHNyYzogc3JjIH1dO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNyYykgJiYgdHlwZW9mIHNyYy5zcmMgPT09ICdzdHJpbmcnICYmIHNyYy5zcmMgJiYgc3JjLnNyYy50cmltKCkpIHtcbiAgICAvLyBzcmMgaXMgYWxyZWFkeSB2YWxpZFxuICAgIHNyYyA9IFtzcmNdO1xuICB9IGVsc2Uge1xuICAgIC8vIGludmFsaWQgc291cmNlLCB0dXJuIGl0IGludG8gYW4gZW1wdHkgYXJyYXlcbiAgICBzcmMgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBzcmM7XG59O1xuXG4vKipcbiAqIEBmaWxlIGxvYWRlci5qc1xuICovXG4vKipcbiAqIFRoZSBgTWVkaWFMb2FkZXJgIGlzIHRoZSBgQ29tcG9uZW50YCB0aGF0IGRlY2lkZXMgd2hpY2ggcGxheWJhY2sgdGVjaG5vbG9neSB0byBsb2FkXG4gKiB3aGVuIGEgcGxheWVyIGlzIGluaXRpYWxpemVkLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBNZWRpYUxvYWRlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1lZGlhTG9hZGVyLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGF0dGFjaCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdHJvZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgcnVuIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBNZWRpYUxvYWRlcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVkaWFMb2FkZXIpO1xuXG4gICAgLy8gTWVkaWFMb2FkZXIgaGFzIG5vIGVsZW1lbnRcbiAgICB2YXIgb3B0aW9uc18gPSBtZXJnZU9wdGlvbnMoeyBjcmVhdGVFbDogZmFsc2UgfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gc291cmNlcyB3aGVuIHRoZSBwbGF5ZXIgaXMgaW5pdGlhbGl6ZWQsXG4gICAgLy8gbG9hZCB0aGUgZmlyc3Qgc3VwcG9ydGVkIHBsYXliYWNrIHRlY2hub2xvZ3kuXG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnNfLCByZWFkeSkpO1xuXG4gICAgaWYgKCFvcHRpb25zLnBsYXllck9wdGlvbnMuc291cmNlcyB8fCBvcHRpb25zLnBsYXllck9wdGlvbnMuc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gb3B0aW9ucy5wbGF5ZXJPcHRpb25zLnRlY2hPcmRlcjsgaSA8IGoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRlY2hOYW1lID0gdG9UaXRsZUNhc2UoaltpXSk7XG4gICAgICAgIHZhciB0ZWNoID0gVGVjaC5nZXRUZWNoKHRlY2hOYW1lKTtcblxuICAgICAgICAvLyBTdXBwb3J0IG9sZCBiZWhhdmlvciBvZiB0ZWNocyBiZWluZyByZWdpc3RlcmVkIGFzIGNvbXBvbmVudHMuXG4gICAgICAgIC8vIFJlbW92ZSBvbmNlIHRoYXQgZGVwcmVjYXRlZCBiZWhhdmlvciBpcyByZW1vdmVkLlxuICAgICAgICBpZiAoIXRlY2hOYW1lKSB7XG4gICAgICAgICAgdGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQodGVjaE5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyB0ZWNobm9sb2d5XG4gICAgICAgIGlmICh0ZWNoICYmIHRlY2guaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgIHBsYXllci5sb2FkVGVjaF8odGVjaE5hbWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExvb3AgdGhyb3VnaCBwbGF5YmFjayB0ZWNobm9sb2dpZXMgKEhUTUw1LCBGbGFzaCkgYW5kIGNoZWNrIGZvciBzdXBwb3J0LlxuICAgICAgLy8gVGhlbiBsb2FkIHRoZSBiZXN0IHNvdXJjZS5cbiAgICAgIC8vIEEgZmV3IGFzc3VtcHRpb25zIGhlcmU6XG4gICAgICAvLyAgIEFsbCBwbGF5YmFjayB0ZWNobm9sb2dpZXMgcmVzcGVjdCBwcmVsb2FkIGZhbHNlLlxuICAgICAgcGxheWVyLnNyYyhvcHRpb25zLnBsYXllck9wdGlvbnMuc291cmNlcyk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBNZWRpYUxvYWRlcjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNZWRpYUxvYWRlcicsIE1lZGlhTG9hZGVyKTtcblxuLyoqXG4gKiBAZmlsZSBidXR0b24uanNcbiAqL1xuLyoqXG4gKiBDbGlja2FibGUgQ29tcG9uZW50IHdoaWNoIGlzIGNsaWNrYWJsZSBvciBrZXlib2FyZCBhY3Rpb25hYmxlLFxuICogYnV0IGlzIG5vdCBhIG5hdGl2ZSBIVE1MIGJ1dHRvbi5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgQ2xpY2thYmxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoQ2xpY2thYmxlQ29tcG9uZW50LCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBDbGlja2FibGVDb21wb25lbnQocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuZW1pdFRhcEV2ZW50cygpO1xuXG4gICAgX3RoaXMuZW5hYmxlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGBzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhZz1kaXZdXG4gICAqICAgICAgICBUaGUgZWxlbWVudCdzIG5vZGUgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcz17fV1cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzPXt9XVxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICB2YXIgdGFnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnZGl2JztcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIHByb3BzID0gYXNzaWduKHtcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwidmpzLWljb24tcGxhY2Vob2xkZXJcIj48L3NwYW4+JyxcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKCksXG4gICAgICB0YWJJbmRleDogMFxuICAgIH0sIHByb3BzKTtcblxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBsb2ckMS5lcnJvcignQ3JlYXRpbmcgYSBDbGlja2FibGVDb21wb25lbnQgd2l0aCBhbiBIVE1MIGVsZW1lbnQgb2YgJyArIHRhZyArICcgaXMgbm90IHN1cHBvcnRlZDsgdXNlIGEgQnV0dG9uIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIEFSSUEgYXR0cmlidXRlcyBmb3IgY2xpY2thYmxlIGVsZW1lbnQgd2hpY2ggaXMgbm90IGEgbmF0aXZlIEhUTUwgYnV0dG9uXG4gICAgYXR0cmlidXRlcyA9IGFzc2lnbih7XG4gICAgICAncm9sZSc6ICdidXR0b24nLFxuXG4gICAgICAvLyBsZXQgdGhlIHNjcmVlbiByZWFkZXIgdXNlciBrbm93IHRoYXQgdGhlIHRleHQgb2YgdGhlIGVsZW1lbnQgbWF5IGNoYW5nZVxuICAgICAgJ2FyaWEtbGl2ZSc6ICdwb2xpdGUnXG4gICAgfSwgYXR0cmlidXRlcyk7XG5cbiAgICB0aGlzLnRhYkluZGV4XyA9IHByb3BzLnRhYkluZGV4O1xuXG4gICAgdmFyIGVsID0gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB0YWcsIHByb3BzLCBhdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMuY3JlYXRlQ29udHJvbFRleHRFbChlbCk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAvLyByZW1vdmUgY29udHJvbFRleHRFbF8gb24gZGlwb3NlXG4gICAgdGhpcy5jb250cm9sVGV4dEVsXyA9IG51bGw7XG5cbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNvbnRyb2wgdGV4dCBlbGVtZW50IG9uIHRoaXMgYENvbXBvbmVudGBcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBbZWxdXG4gICAqICAgICAgICBQYXJlbnQgZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgdGV4dC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgY29udHJvbCB0ZXh0IGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVDb250cm9sVGV4dEVsID0gZnVuY3Rpb24gY3JlYXRlQ29udHJvbFRleHRFbChlbCkge1xuICAgIHRoaXMuY29udHJvbFRleHRFbF8gPSBjcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jb250cm9sLXRleHQnXG4gICAgfSk7XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udHJvbFRleHRFbF8pO1xuICAgIH1cblxuICAgIHRoaXMuY29udHJvbFRleHQodGhpcy5jb250cm9sVGV4dF8sIGVsKTtcblxuICAgIHJldHVybiB0aGlzLmNvbnRyb2xUZXh0RWxfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBsb2NhbGl6ZSB0ZXh0IHRvIHVzZSBmb3IgdGhlIGNvbnRyb2xzIG9uIHRoZSBgQ29tcG9uZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0XVxuICAgKiAgICAgICAgQ29udHJvbCB0ZXh0IGZvciBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtlbD10aGlzLmVsKCldXG4gICAqICAgICAgICBFbGVtZW50IHRvIHNldCB0aGUgdGl0bGUgb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAtIFRoZSBjb250cm9sIHRleHQgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5jb250cm9sVGV4dCA9IGZ1bmN0aW9uIGNvbnRyb2xUZXh0KHRleHQpIHtcbiAgICB2YXIgZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuZWwoKTtcblxuICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xUZXh0XyB8fCAnTmVlZCBUZXh0JztcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxpemVkVGV4dCA9IHRoaXMubG9jYWxpemUodGV4dCk7XG5cbiAgICB0aGlzLmNvbnRyb2xUZXh0XyA9IHRleHQ7XG4gICAgdGV4dENvbnRlbnQodGhpcy5jb250cm9sVGV4dEVsXywgbG9jYWxpemVkVGV4dCk7XG4gICAgaWYgKCF0aGlzLm5vbkljb25Db250cm9sKSB7XG4gICAgICAvLyBTZXQgdGl0bGUgYXR0cmlidXRlIGlmIG9ubHkgYW4gaWNvbiBpcyBzaG93blxuICAgICAgZWwuc2V0QXR0cmlidXRlKCd0aXRsZScsIGxvY2FsaXplZFRleHQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY29udHJvbCB2anMtYnV0dG9uICcgKyBfQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGlzIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkXykge1xuICAgICAgdGhpcy5lbmFibGVkXyA9IHRydWU7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZGlzYWJsZWQnKTtcbiAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnRhYkluZGV4XyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsIHRoaXMudGFiSW5kZXhfKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub24oWyd0YXAnLCAnY2xpY2snXSwgdGhpcy5oYW5kbGVDbGljayk7XG4gICAgICB0aGlzLm9uKCdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXMpO1xuICAgICAgdGhpcy5vbignYmx1cicsIHRoaXMuaGFuZGxlQmx1cik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoaXMgYENvbXBvbmVudGBzIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWRpc2FibGVkJyk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgICBpZiAodHlwZW9mIHRoaXMudGFiSW5kZXhfICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5lbF8ucmVtb3ZlQXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgIH1cbiAgICB0aGlzLm9mZihbJ3RhcCcsICdjbGljayddLCB0aGlzLmhhbmRsZUNsaWNrKTtcbiAgICB0aGlzLm9mZignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzKTtcbiAgICB0aGlzLm9mZignYmx1cicsIHRoaXMuaGFuZGxlQmx1cik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhIGBDbGlja2FibGVDb21wb25lbnRgIGdldHM6XG4gICAqIC0gQ2xpY2tlZCAodmlhIHRoZSBgY2xpY2tgIGV2ZW50LCBsaXN0ZW5pbmcgc3RhcnRzIGluIHRoZSBjb25zdHJ1Y3RvcilcbiAgICogLSBUYXBwZWQgKHZpYSB0aGUgYHRhcGAgZXZlbnQsIGxpc3RlbmluZyBzdGFydHMgaW4gdGhlIGNvbnN0cnVjdG9yKVxuICAgKiAtIFRoZSBmb2xsb3dpbmcgdGhpbmdzIGhhcHBlbiBpbiBvcmRlcjpcbiAgICogICAxLiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUZvY3VzfSBpcyBjYWxsZWQgdmlhIGEgYGZvY3VzYCBldmVudCBvbiB0aGVcbiAgICogICAgICBgQ2xpY2thYmxlQ29tcG9uZW50YC5cbiAgICogICAyLiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUZvY3VzfSBhZGRzIGEgbGlzdGVuZXIgZm9yIGBrZXlkb3duYCBvbiB1c2luZ1xuICAgKiAgICAgIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlS2V5UHJlc3N9LlxuICAgKiAgIDMuIGBDbGlja2FibGVDb21wb25lbnRgIGhhcyBub3QgaGFkIGEgYGJsdXJgIGV2ZW50IChgYmx1cmAgbWVhbnMgdGhhdCBmb2N1cyB3YXMgbG9zdCkuIFRoZSB1c2VyIHByZXNzZXNcbiAgICogICAgICB0aGUgc3BhY2Ugb3IgZW50ZXIga2V5LlxuICAgKiAgIDQuIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlS2V5UHJlc3N9IGNhbGxzIHRoaXMgZnVuY3Rpb24gd2l0aCB0aGUgYGtleWRvd25gXG4gICAqICAgICAgZXZlbnQgYXMgYSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHt9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQ2xpY2thYmxlQ29tcG9uZW50YCBnYWlucyBmb2N1cyB2aWEgYSBgZm9jdXNgIGV2ZW50LlxuICAgKiBUdXJucyBvbiBsaXN0ZW5pbmcgZm9yIGBrZXlkb3duYCBldmVudHMuIFdoZW4gdGhleSBoYXBwZW4gaXRcbiAgICogY2FsbHMgYHRoaXMuaGFuZGxlS2V5UHJlc3NgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBmb2N1c2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGZvY3VzXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIGhhbmRsZUZvY3VzKGV2ZW50KSB7XG4gICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoaXMgQ2xpY2thYmxlQ29tcG9uZW50IGhhcyBmb2N1cyBhbmQgYSBrZXkgZ2V0cyBwcmVzc2VkIGRvd24uIEJ5XG4gICAqIGRlZmF1bHQgaXQgd2lsbCBjYWxsIGB0aGlzLmhhbmRsZUNsaWNrYCB3aGVuIHRoZSBrZXkgaXMgc3BhY2Ugb3IgZW50ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG5cbiAgICAvLyBTdXBwb3J0IFNwYWNlICgzMikgb3IgRW50ZXIgKDEzKSBrZXkgb3BlcmF0aW9uIHRvIGZpcmUgYSBjbGljayBldmVudFxuICAgIGlmIChldmVudC53aGljaCA9PT0gMzIgfHwgZXZlbnQud2hpY2ggPT09IDEzKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdjbGljaycpO1xuICAgIH0gZWxzZSBpZiAoX0NvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MpIHtcblxuICAgICAgLy8gUGFzcyBrZXlwcmVzcyBoYW5kbGluZyB1cCBmb3IgdW5zdXBwb3J0ZWQga2V5c1xuICAgICAgX0NvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGBDbGlja2FibGVDb21wb25lbnRgIGxvc2VzIGZvY3VzLiBUdXJucyBvZmYgdGhlIGxpc3RlbmVyIGZvclxuICAgKiBga2V5ZG93bmAgZXZlbnRzLiBXaGljaCBTdG9wcyBgdGhpcy5oYW5kbGVLZXlQcmVzc2AgZnJvbSBnZXR0aW5nIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgYmx1cmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGJsdXJcbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKGV2ZW50KSB7XG4gICAgb2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIGJpbmQodGhpcywgdGhpcy5oYW5kbGVLZXlQcmVzcykpO1xuICB9O1xuXG4gIHJldHVybiBDbGlja2FibGVDb21wb25lbnQ7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2xpY2thYmxlQ29tcG9uZW50JywgQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAZmlsZSBwb3N0ZXItaW1hZ2UuanNcbiAqL1xuLyoqXG4gKiBBIGBDbGlja2FibGVDb21wb25lbnRgIHRoYXQgaGFuZGxlcyBzaG93aW5nIHRoZSBwb3N0ZXIgaW1hZ2UgZm9yIHRoZSBwbGF5ZXIuXG4gKlxuICogQGV4dGVuZHMgQ2xpY2thYmxlQ29tcG9uZW50XG4gKi9cblxudmFyIFBvc3RlckltYWdlID0gZnVuY3Rpb24gKF9DbGlja2FibGVDb21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUG9zdGVySW1hZ2UsIF9DbGlja2FibGVDb21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYXR0YWNoIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUG9zdGVySW1hZ2UocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9zdGVySW1hZ2UpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ2xpY2thYmxlQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGUoKTtcbiAgICBwbGF5ZXIub24oJ3Bvc3RlcmNoYW5nZScsIGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZSkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCBhbmQgZGlzcG9zZSBvZiB0aGUgYFBvc3RlckltYWdlYC5cbiAgICovXG5cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5wbGF5ZXIoKS5vZmYoJ3Bvc3RlcmNoYW5nZScsIHRoaXMudXBkYXRlKTtcbiAgICBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYFBvc3RlckltYWdlYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgUG9zdGVySW1hZ2UucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIGVsID0gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wb3N0ZXInLFxuXG4gICAgICAvLyBEb24ndCB3YW50IHBvc3RlciB0byBiZSB0YWJiYWJsZS5cbiAgICAgIHRhYkluZGV4OiAtMVxuICAgIH0pO1xuXG4gICAgLy8gVG8gZW5zdXJlIHRoZSBwb3N0ZXIgaW1hZ2UgcmVzaXplcyB3aGlsZSBtYWludGFpbmluZyBpdHMgb3JpZ2luYWwgYXNwZWN0XG4gICAgLy8gcmF0aW8sIHVzZSBhIGRpdiB3aXRoIGBiYWNrZ3JvdW5kLXNpemVgIHdoZW4gYXZhaWxhYmxlLiBGb3IgYnJvd3NlcnMgdGhhdFxuICAgIC8vIGRvIG5vdCBzdXBwb3J0IGBiYWNrZ3JvdW5kLXNpemVgIChlLmcuIElFOCksIGZhbGwgYmFjayBvbiB1c2luZyBhIHJlZ3VsYXJcbiAgICAvLyBpbWcgZWxlbWVudC5cbiAgICBpZiAoIUJBQ0tHUk9VTkRfU0laRV9TVVBQT1JURUQpIHtcbiAgICAgIHRoaXMuZmFsbGJhY2tJbWdfID0gY3JlYXRlRWwoJ2ltZycpO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5mYWxsYmFja0ltZ18pO1xuICAgIH1cblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogQW4ge0BsaW5rIEV2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZvciB7QGxpbmsgUGxheWVyI3Bvc3RlcmNoYW5nZX0gZXZlbnRzLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjcG9zdGVyY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgUGxheWVyI3Bvc3RlcmNoYW5nZWAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvbi5cbiAgICovXG5cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XG4gICAgdmFyIHVybCA9IHRoaXMucGxheWVyKCkucG9zdGVyKCk7XG5cbiAgICB0aGlzLnNldFNyYyh1cmwpO1xuXG4gICAgLy8gSWYgdGhlcmUncyBubyBwb3N0ZXIgc291cmNlIHdlIHNob3VsZCBkaXNwbGF5Om5vbmUgb24gdGhpcyBjb21wb25lbnRcbiAgICAvLyBzbyBpdCdzIG5vdCBzdGlsbCBjbGlja2FibGUgb3IgcmlnaHQtY2xpY2thYmxlXG4gICAgaWYgKHVybCkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2Ugb2YgdGhlIGBQb3N0ZXJJbWFnZWAgZGVwZW5kaW5nIG9uIHRoZSBkaXNwbGF5IG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiAgICAgICAgVGhlIFVSTCB0byB0aGUgc291cmNlIGZvciB0aGUgYFBvc3RlckltYWdlYC5cbiAgICovXG5cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUuc2V0U3JjID0gZnVuY3Rpb24gc2V0U3JjKHVybCkge1xuICAgIGlmICh0aGlzLmZhbGxiYWNrSW1nXykge1xuICAgICAgdGhpcy5mYWxsYmFja0ltZ18uc3JjID0gdXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYmFja2dyb3VuZEltYWdlID0gJyc7XG5cbiAgICAgIC8vIEFueSBmYWxzZXkgdmFsdWVzIHNob3VsZCBzdGF5IGFzIGFuIGVtcHR5IHN0cmluZywgb3RoZXJ3aXNlXG4gICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgYW4gZXh0cmEgZXJyb3JcbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlID0gJ3VybChcIicgKyB1cmwgKyAnXCIpJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbF8uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYmFja2dyb3VuZEltYWdlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQW4ge0BsaW5rIEV2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZvciBjbGlja3Mgb24gdGhlIGBQb3N0ZXJJbWFnZWAuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUNsaWNrfSBmb3IgaW5zdGFuY2VzIHdoZXJlIHRoaXMgd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICArICAgICAgICBUaGUgYGNsaWNrYCwgYHRhcGAgb3IgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKi9cblxuXG4gIFBvc3RlckltYWdlLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBhIGNsaWNrIHRvIHRyaWdnZXIgcGxheWJhY2sgd2hlbiBjb250cm9scyBhcmUgZGlzYWJsZWRcbiAgICBpZiAoIXRoaXMucGxheWVyXy5jb250cm9scygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGxheWVyXy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQb3N0ZXJJbWFnZTtcbn0oQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQb3N0ZXJJbWFnZScsIFBvc3RlckltYWdlKTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWRpc3BsYXkuanNcbiAqL1xudmFyIGRhcmtHcmF5ID0gJyMyMjInO1xudmFyIGxpZ2h0R3JheSA9ICcjY2NjJztcbnZhciBmb250TWFwID0ge1xuICBtb25vc3BhY2U6ICdtb25vc3BhY2UnLFxuICBzYW5zU2VyaWY6ICdzYW5zLXNlcmlmJyxcbiAgc2VyaWY6ICdzZXJpZicsXG4gIG1vbm9zcGFjZVNhbnNTZXJpZjogJ1wiQW5kYWxlIE1vbm9cIiwgXCJMdWNpZGEgQ29uc29sZVwiLCBtb25vc3BhY2UnLFxuICBtb25vc3BhY2VTZXJpZjogJ1wiQ291cmllciBOZXdcIiwgbW9ub3NwYWNlJyxcbiAgcHJvcG9ydGlvbmFsU2Fuc1NlcmlmOiAnc2Fucy1zZXJpZicsXG4gIHByb3BvcnRpb25hbFNlcmlmOiAnc2VyaWYnLFxuICBjYXN1YWw6ICdcIkNvbWljIFNhbnMgTVNcIiwgSW1wYWN0LCBmYW50YXN5JyxcbiAgc2NyaXB0OiAnXCJNb25vdHlwZSBDb3JzaXZhXCIsIGN1cnNpdmUnLFxuICBzbWFsbGNhcHM6ICdcIkFuZGFsZSBNb25vXCIsIFwiTHVjaWRhIENvbnNvbGVcIiwgbW9ub3NwYWNlLCBzYW5zLXNlcmlmJ1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3QgYW4gcmdiYSBjb2xvciBmcm9tIGEgZ2l2ZW4gaGV4IGNvbG9yIGNvZGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvbG9yXG4gKiAgICAgICAgSGV4IG51bWJlciBmb3IgY29sb3IsIGxpa2UgI2YwZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eVxuICogICAgICAgIFZhbHVlIGZvciBvcGFjaXR5LCAwLjAgLSAxLjAuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgcmdiYSBjb2xvciB0aGF0IHdhcyBjcmVhdGVkLCBsaWtlICdyZ2JhKDI1NSwgMCwgMCwgMC4zKScuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0Q29sb3IoY29sb3IsIG9wYWNpdHkpIHtcbiAgcmV0dXJuICdyZ2JhKCcgK1xuICAvLyBjb2xvciBsb29rcyBsaWtlIFwiI2YwZVwiXG4gIHBhcnNlSW50KGNvbG9yWzFdICsgY29sb3JbMV0sIDE2KSArICcsJyArIHBhcnNlSW50KGNvbG9yWzJdICsgY29sb3JbMl0sIDE2KSArICcsJyArIHBhcnNlSW50KGNvbG9yWzNdICsgY29sb3JbM10sIDE2KSArICcsJyArIG9wYWNpdHkgKyAnKSc7XG59XG5cbi8qKlxuICogVHJ5IHRvIHVwZGF0ZSB0aGUgc3R5bGUgb2YgYSBET00gZWxlbWVudC4gU29tZSBzdHlsZSBjaGFuZ2VzIHdpbGwgdGhyb3cgYW4gZXJyb3IsXG4gKiBwYXJ0aWN1bGFybHkgaW4gSUU4LiBUaG9zZSBzaG91bGQgYmUgbm9vcHMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFRoZSBET00gZWxlbWVudCB0byBiZSBzdHlsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlXG4gKiAgICAgICAgVGhlIENTUyBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBzdHlsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqICAgICAgICBUaGUgc3R5bGUgcnVsZSB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSBwcm9wZXJ0eS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0cnlVcGRhdGVTdHlsZShlbCwgc3R5bGUsIHJ1bGUpIHtcbiAgdHJ5IHtcbiAgICBlbC5zdHlsZVtzdHlsZV0gPSBydWxlO1xuICB9IGNhdGNoIChlKSB7XG5cbiAgICAvLyBTYXRpc2ZpZXMgbGludGVyLlxuICAgIHJldHVybjtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBjb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgdGV4dCB0cmFjayBjdWVzLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBUZXh0VHJhY2tEaXNwbGF5ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVGV4dFRyYWNrRGlzcGxheSwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYFRleHRUcmFja0Rpc3BsYXlgIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSk7XG5cbiAgICBwbGF5ZXIub24oJ2xvYWRzdGFydCcsIGJpbmQoX3RoaXMsIF90aGlzLnRvZ2dsZURpc3BsYXkpKTtcbiAgICBwbGF5ZXIub24oJ3RleHR0cmFja2NoYW5nZScsIGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZURpc3BsYXkpKTtcbiAgICBwbGF5ZXIub24oJ2xvYWRzdGFydCcsIGJpbmQoX3RoaXMsIF90aGlzLnByZXNlbGVjdFRyYWNrKSk7XG5cbiAgICAvLyBUaGlzIHVzZWQgdG8gYmUgY2FsbGVkIGR1cmluZyBwbGF5ZXIgaW5pdCwgYnV0IHdhcyBjYXVzaW5nIGFuIGVycm9yXG4gICAgLy8gaWYgYSB0cmFjayBzaG91bGQgc2hvdyBieSBkZWZhdWx0IGFuZCB0aGUgZGlzcGxheSBoYWRuJ3QgbG9hZGVkIHlldC5cbiAgICAvLyBTaG91bGQgcHJvYmFibHkgYmUgbW92ZWQgdG8gYW4gZXh0ZXJuYWwgdHJhY2sgbG9hZGVyIHdoZW4gd2Ugc3VwcG9ydFxuICAgIC8vIHRyYWNrcyB0aGF0IGRvbid0IG5lZWQgYSBkaXNwbGF5LlxuICAgIHBsYXllci5yZWFkeShiaW5kKF90aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocGxheWVyLnRlY2hfICYmIHBsYXllci50ZWNoXy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGxheWVyLm9uKCdmdWxsc2NyZWVuY2hhbmdlJywgYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcblxuICAgICAgdmFyIHRyYWNrcyA9IHRoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucy50cmFja3MgfHwgW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucGxheWVyXy5hZGRSZW1vdGVUZXh0VHJhY2sodHJhY2tzW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcmVzZWxlY3RUcmFjaygpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgKiBQcmVzZWxlY3QgYSB0cmFjayBmb2xsb3dpbmcgdGhpcyBwcmVjZWRlbmNlOlxuICAqIC0gbWF0Y2hlcyB0aGUgcHJldmlvdXNseSBzZWxlY3RlZCB7QGxpbmsgVGV4dFRyYWNrfSdzIGxhbmd1YWdlIGFuZCBraW5kXG4gICogLSBtYXRjaGVzIHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIHtAbGluayBUZXh0VHJhY2t9J3MgbGFuZ3VhZ2Ugb25seVxuICAqIC0gaXMgdGhlIGZpcnN0IGRlZmF1bHQgY2FwdGlvbnMgdHJhY2tcbiAgKiAtIGlzIHRoZSBmaXJzdCBkZWZhdWx0IGRlc2NyaXB0aW9ucyB0cmFja1xuICAqXG4gICogQGxpc3RlbnMgUGxheWVyI2xvYWRzdGFydFxuICAqL1xuXG5cbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUucHJlc2VsZWN0VHJhY2sgPSBmdW5jdGlvbiBwcmVzZWxlY3RUcmFjaygpIHtcbiAgICB2YXIgbW9kZXMgPSB7IGNhcHRpb25zOiAxLCBzdWJ0aXRsZXM6IDEgfTtcbiAgICB2YXIgdHJhY2tMaXN0ID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcbiAgICB2YXIgdXNlclByZWYgPSB0aGlzLnBsYXllcl8uY2FjaGVfLnNlbGVjdGVkTGFuZ3VhZ2U7XG4gICAgdmFyIGZpcnN0RGVzYyA9IHZvaWQgMDtcbiAgICB2YXIgZmlyc3RDYXB0aW9ucyA9IHZvaWQgMDtcbiAgICB2YXIgcHJlZmVycmVkVHJhY2sgPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tMaXN0W2ldO1xuXG4gICAgICBpZiAodXNlclByZWYgJiYgdXNlclByZWYuZW5hYmxlZCAmJiB1c2VyUHJlZi5sYW5ndWFnZSA9PT0gdHJhY2subGFuZ3VhZ2UpIHtcbiAgICAgICAgLy8gQWx3YXlzIGNob29zZSB0aGUgdHJhY2sgdGhhdCBtYXRjaGVzIGJvdGggbGFuZ3VhZ2UgYW5kIGtpbmRcbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09IHVzZXJQcmVmLmtpbmQpIHtcbiAgICAgICAgICBwcmVmZXJyZWRUcmFjayA9IHRyYWNrO1xuICAgICAgICAgIC8vIG9yIGNob29zZSB0aGUgZmlyc3QgdHJhY2sgdGhhdCBtYXRjaGVzIGxhbmd1YWdlXG4gICAgICAgIH0gZWxzZSBpZiAoIXByZWZlcnJlZFRyYWNrKSB7XG4gICAgICAgICAgcHJlZmVycmVkVHJhY2sgPSB0cmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIGV2ZXJ5dGhpbmcgaWYgb2ZmVGV4dFRyYWNrTWVudUl0ZW0gd2FzIGNsaWNrZWRcbiAgICAgIH0gZWxzZSBpZiAodXNlclByZWYgJiYgIXVzZXJQcmVmLmVuYWJsZWQpIHtcbiAgICAgICAgcHJlZmVycmVkVHJhY2sgPSBudWxsO1xuICAgICAgICBmaXJzdERlc2MgPSBudWxsO1xuICAgICAgICBmaXJzdENhcHRpb25zID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tbJ2RlZmF1bHQnXSkge1xuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ2Rlc2NyaXB0aW9ucycgJiYgIWZpcnN0RGVzYykge1xuICAgICAgICAgIGZpcnN0RGVzYyA9IHRyYWNrO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgaW4gbW9kZXMgJiYgIWZpcnN0Q2FwdGlvbnMpIHtcbiAgICAgICAgICBmaXJzdENhcHRpb25zID0gdHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgcHJlZmVycmVkVHJhY2sgbWF0Y2hlcyB0aGUgdXNlciBwcmVmZXJlbmNlIGFuZCB0YWtlc1xuICAgIC8vIHByZWNlbmRlbmNlIG92ZXIgYWxsIHRoZSBvdGhlciB0cmFja3MuXG4gICAgLy8gU28sIGRpc3BsYXkgdGhlIHByZWZlcnJlZFRyYWNrIGJlZm9yZSB0aGUgZmlyc3QgZGVmYXVsdCB0cmFja1xuICAgIC8vIGFuZCB0aGUgc3VidGl0bGVzL2NhcHRpb25zIHRyYWNrIGJlZm9yZSB0aGUgZGVzY3JpcHRpb25zIHRyYWNrXG4gICAgaWYgKHByZWZlcnJlZFRyYWNrKSB7XG4gICAgICBwcmVmZXJyZWRUcmFjay5tb2RlID0gJ3Nob3dpbmcnO1xuICAgIH0gZWxzZSBpZiAoZmlyc3RDYXB0aW9ucykge1xuICAgICAgZmlyc3RDYXB0aW9ucy5tb2RlID0gJ3Nob3dpbmcnO1xuICAgIH0gZWxzZSBpZiAoZmlyc3REZXNjKSB7XG4gICAgICBmaXJzdERlc2MubW9kZSA9ICdzaG93aW5nJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gZGlzcGxheSBvZiB7QGxpbmsgVGV4dFRyYWNrfSdzIGZyb20gdGhlIGN1cnJlbnQgc3RhdGUgaW50byB0aGUgb3RoZXIgc3RhdGUuXG4gICAqIFRoZXJlIGFyZSBvbmx5IHR3byBzdGF0ZXM6XG4gICAqIC0gJ3Nob3duJ1xuICAgKiAtICdoaWRkZW4nXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNsb2Fkc3RhcnRcbiAgICovXG5cblxuICBUZXh0VHJhY2tEaXNwbGF5LnByb3RvdHlwZS50b2dnbGVEaXNwbGF5ID0gZnVuY3Rpb24gdG9nZ2xlRGlzcGxheSgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLnRlY2hfICYmIHRoaXMucGxheWVyXy50ZWNoXy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUge0BsaW5rIENvbXBvbmVudH0ncyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10ZXh0LXRyYWNrLWRpc3BsYXknXG4gICAgfSwge1xuICAgICAgJ2FyaWEtbGl2ZSc6ICdvZmYnLFxuICAgICAgJ2FyaWEtYXRvbWljJzogJ3RydWUnXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBkaXNwbGF5ZWQge0BsaW5rIFRleHRUcmFja31zLlxuICAgKi9cblxuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLmNsZWFyRGlzcGxheSA9IGZ1bmN0aW9uIGNsZWFyRGlzcGxheSgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5XZWJWVFQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdpbmRvdy5XZWJWVFQucHJvY2Vzc0N1ZXMod2luZG93LCBbXSwgdGhpcy5lbF8pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBkaXNwbGF5ZWQgVGV4dFRyYWNrIHdoZW4gYSBlaXRoZXIgYSB7QGxpbmsgUGxheWVyI3RleHR0cmFja2NoYW5nZX0gb3JcbiAgICogYSB7QGxpbmsgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2V9IGlzIGZpcmVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGV4dHRyYWNrY2hhbmdlXG4gICAqIEBsaXN0ZW5zIFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUudXBkYXRlRGlzcGxheSA9IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCk7XG5cbiAgICB0aGlzLmNsZWFyRGlzcGxheSgpO1xuXG4gICAgLy8gVHJhY2sgZGlzcGxheSBwcmlvcml0aXphdGlvbiBtb2RlbDogaWYgbXVsdGlwbGUgdHJhY2tzIGFyZSAnc2hvd2luZycsXG4gICAgLy8gIGRpc3BsYXkgdGhlIGZpcnN0ICdzdWJ0aXRsZXMnIG9yICdjYXB0aW9ucycgdHJhY2sgd2hpY2ggaXMgJ3Nob3dpbmcnLFxuICAgIC8vICBvdGhlcndpc2UgZGlzcGxheSB0aGUgZmlyc3QgJ2Rlc2NyaXB0aW9ucycgdHJhY2sgd2hpY2ggaXMgJ3Nob3dpbmcnXG5cbiAgICB2YXIgZGVzY3JpcHRpb25zVHJhY2sgPSBudWxsO1xuICAgIHZhciBjYXB0aW9uc1N1YnRpdGxlc1RyYWNrID0gbnVsbDtcbiAgICB2YXIgaSA9IHRyYWNrcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmICh0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdkZXNjcmlwdGlvbnMnKSB7XG4gICAgICAgICAgZGVzY3JpcHRpb25zVHJhY2sgPSB0cmFjaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0aW9uc1N1YnRpdGxlc1RyYWNrID0gdHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2FwdGlvbnNTdWJ0aXRsZXNUcmFjaykge1xuICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnKSAhPT0gJ29mZicpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdvZmYnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlRm9yVHJhY2soY2FwdGlvbnNTdWJ0aXRsZXNUcmFjayk7XG4gICAgfSBlbHNlIGlmIChkZXNjcmlwdGlvbnNUcmFjaykge1xuICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnKSAhPT0gJ2Fzc2VydGl2ZScpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdhc3NlcnRpdmUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlRm9yVHJhY2soZGVzY3JpcHRpb25zVHJhY2spO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIGFuIHtAbGluayBUZXh0dHJhY2t9IHRvIHRvIHRoZSB7QGxpbmsgVGVjaH1zIHtAbGluayBUZXh0VHJhY2tMaXN0fS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUZXh0IHRyYWNrIG9iamVjdCB0byBiZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICovXG5cblxuICBUZXh0VHJhY2tEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVGb3JUcmFjayA9IGZ1bmN0aW9uIHVwZGF0ZUZvclRyYWNrKHRyYWNrKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuV2ViVlRUICE9PSAnZnVuY3Rpb24nIHx8ICF0cmFjay5hY3RpdmVDdWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG92ZXJyaWRlcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tTZXR0aW5ncy5nZXRWYWx1ZXMoKTtcbiAgICB2YXIgY3VlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRyYWNrLmFjdGl2ZUN1ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBjdWVzLnB1c2godHJhY2suYWN0aXZlQ3Vlc1tfaV0pO1xuICAgIH1cblxuICAgIHdpbmRvdy5XZWJWVFQucHJvY2Vzc0N1ZXMod2luZG93LCBjdWVzLCB0aGlzLmVsXyk7XG5cbiAgICB2YXIgaSA9IGN1ZXMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGN1ZSA9IGN1ZXNbaV07XG5cbiAgICAgIGlmICghY3VlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VlRGl2ID0gY3VlLmRpc3BsYXlTdGF0ZTtcblxuICAgICAgaWYgKG92ZXJyaWRlcy5jb2xvcikge1xuICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS5jb2xvciA9IG92ZXJyaWRlcy5jb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMudGV4dE9wYWNpdHkpIHtcbiAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LmZpcnN0Q2hpbGQsICdjb2xvcicsIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy5jb2xvciB8fCAnI2ZmZicsIG92ZXJyaWRlcy50ZXh0T3BhY2l0eSkpO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3ZlcnJpZGVzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuYmFja2dyb3VuZE9wYWNpdHkpIHtcbiAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LmZpcnN0Q2hpbGQsICdiYWNrZ3JvdW5kQ29sb3InLCBjb25zdHJ1Y3RDb2xvcihvdmVycmlkZXMuYmFja2dyb3VuZENvbG9yIHx8ICcjMDAwJywgb3ZlcnJpZGVzLmJhY2tncm91bmRPcGFjaXR5KSk7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLndpbmRvd0NvbG9yKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMud2luZG93T3BhY2l0eSkge1xuICAgICAgICAgIHRyeVVwZGF0ZVN0eWxlKGN1ZURpdiwgJ2JhY2tncm91bmRDb2xvcicsIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy53aW5kb3dDb2xvciwgb3ZlcnJpZGVzLndpbmRvd09wYWNpdHkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdWVEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3ZlcnJpZGVzLndpbmRvd0NvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSkge1xuICAgICAgICBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ2Ryb3BzaGFkb3cnKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUudGV4dFNoYWRvdyA9ICcycHggMnB4IDNweCAnICsgZGFya0dyYXkgKyAnLCAycHggMnB4IDRweCAnICsgZGFya0dyYXkgKyAnLCAycHggMnB4IDVweCAnICsgZGFya0dyYXk7XG4gICAgICAgIH0gZWxzZSBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ3JhaXNlZCcpIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS50ZXh0U2hhZG93ID0gJzFweCAxcHggJyArIGRhcmtHcmF5ICsgJywgMnB4IDJweCAnICsgZGFya0dyYXkgKyAnLCAzcHggM3B4ICcgKyBkYXJrR3JheTtcbiAgICAgICAgfSBlbHNlIGlmIChvdmVycmlkZXMuZWRnZVN0eWxlID09PSAnZGVwcmVzc2VkJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMXB4IDFweCAnICsgbGlnaHRHcmF5ICsgJywgMCAxcHggJyArIGxpZ2h0R3JheSArICcsIC0xcHggLTFweCAnICsgZGFya0dyYXkgKyAnLCAwIC0xcHggJyArIGRhcmtHcmF5O1xuICAgICAgICB9IGVsc2UgaWYgKG92ZXJyaWRlcy5lZGdlU3R5bGUgPT09ICd1bmlmb3JtJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMCAwIDRweCAnICsgZGFya0dyYXkgKyAnLCAwIDAgNHB4ICcgKyBkYXJrR3JheSArICcsIDAgMCA0cHggJyArIGRhcmtHcmF5ICsgJywgMCAwIDRweCAnICsgZGFya0dyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuZm9udFBlcmNlbnQgJiYgb3ZlcnJpZGVzLmZvbnRQZXJjZW50ICE9PSAxKSB7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IHdpbmRvdy5wYXJzZUZsb2F0KGN1ZURpdi5zdHlsZS5mb250U2l6ZSk7XG5cbiAgICAgICAgY3VlRGl2LnN0eWxlLmZvbnRTaXplID0gZm9udFNpemUgKiBvdmVycmlkZXMuZm9udFBlcmNlbnQgKyAncHgnO1xuICAgICAgICBjdWVEaXYuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICBjdWVEaXYuc3R5bGUudG9wID0gJ2F1dG8nO1xuICAgICAgICBjdWVEaXYuc3R5bGUuYm90dG9tID0gJzJweCc7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmZvbnRGYW1pbHkgJiYgb3ZlcnJpZGVzLmZvbnRGYW1pbHkgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICBpZiAob3ZlcnJpZGVzLmZvbnRGYW1pbHkgPT09ICdzbWFsbC1jYXBzJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLmZvbnRWYXJpYW50ID0gJ3NtYWxsLWNhcHMnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLmZvbnRGYW1pbHkgPSBmb250TWFwW292ZXJyaWRlcy5mb250RmFtaWx5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrRGlzcGxheTtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tEaXNwbGF5JywgVGV4dFRyYWNrRGlzcGxheSk7XG5cbi8qKlxuICogQGZpbGUgbG9hZGluZy1zcGlubmVyLmpzXG4gKi9cbi8qKlxuICogQSBsb2FkaW5nIHNwaW5uZXIgZm9yIHVzZSBkdXJpbmcgd2FpdGluZy9sb2FkaW5nIGV2ZW50cy5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTG9hZGluZ1NwaW5uZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhMb2FkaW5nU3Bpbm5lciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTG9hZGluZ1NwaW5uZXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9hZGluZ1NwaW5uZXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgTG9hZGluZ1NwaW5uZXJgcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZG9tIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuICBMb2FkaW5nU3Bpbm5lci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxvYWRpbmctc3Bpbm5lcicsXG4gICAgICBkaXI6ICdsdHInXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIExvYWRpbmdTcGlubmVyO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0xvYWRpbmdTcGlubmVyJywgTG9hZGluZ1NwaW5uZXIpO1xuXG4vKipcbiAqIEBmaWxlIGJ1dHRvbi5qc1xuICovXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBidXR0b25zLlxuICpcbiAqIEBleHRlbmRzIENsaWNrYWJsZUNvbXBvbmVudFxuICovXG5cbnZhciBCdXR0b24gPSBmdW5jdGlvbiAoX0NsaWNrYWJsZUNvbXBvbmVudCkge1xuICBpbmhlcml0cyhCdXR0b24sIF9DbGlja2FibGVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEJ1dHRvbigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBCdXR0b24pO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9DbGlja2FibGVDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQnV0dG9uYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFnPVwiYnV0dG9uXCJdXG4gICAqICAgICAgICBUaGUgZWxlbWVudCdzIG5vZGUgdHlwZS4gVGhpcyBhcmd1bWVudCBpcyBJR05PUkVEOiBubyBtYXR0ZXIgd2hhdFxuICAgKiAgICAgICAgaXMgcGFzc2VkLCBpdCB3aWxsIGFsd2F5cyBjcmVhdGUgYSBgYnV0dG9uYCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzPXt9XVxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXM9e31dXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuICBCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwodGFnKSB7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICB0YWcgPSAnYnV0dG9uJztcblxuICAgIHByb3BzID0gYXNzaWduKHtcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwidmpzLWljb24tcGxhY2Vob2xkZXJcIj48L3NwYW4+JyxcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKClcbiAgICB9LCBwcm9wcyk7XG5cbiAgICAvLyBBZGQgYXR0cmlidXRlcyBmb3IgYnV0dG9uIGVsZW1lbnRcbiAgICBhdHRyaWJ1dGVzID0gYXNzaWduKHtcblxuICAgICAgLy8gTmVjZXNzYXJ5IHNpbmNlIHRoZSBkZWZhdWx0IGJ1dHRvbiB0eXBlIGlzIFwic3VibWl0XCJcbiAgICAgICd0eXBlJzogJ2J1dHRvbicsXG5cbiAgICAgIC8vIGxldCB0aGUgc2NyZWVuIHJlYWRlciB1c2VyIGtub3cgdGhhdCB0aGUgdGV4dCBvZiB0aGUgYnV0dG9uIG1heSBjaGFuZ2VcbiAgICAgICdhcmlhLWxpdmUnOiAncG9saXRlJ1xuICAgIH0sIGF0dHJpYnV0ZXMpO1xuXG4gICAgdmFyIGVsID0gQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsIHRhZywgcHJvcHMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgdGhpcy5jcmVhdGVDb250cm9sVGV4dEVsKGVsKTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2hpbGQgYENvbXBvbmVudGAgaW5zaWRlIG9mIHRoaXMgYEJ1dHRvbmAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfENvbXBvbmVudH0gY2hpbGRcbiAgICogICAgICAgIFRoZSBuYW1lIG9yIGluc3RhbmNlIG9mIGEgY2hpbGQgdG8gYWRkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIG9wdGlvbnMgdGhhdCB3aWxsIGdldCBwYXNzZWQgdG8gY2hpbGRyZW4gb2ZcbiAgICogICAgICAgIHRoZSBjaGlsZC5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiAgICAgICAgIFRoZSBgQ29tcG9uZW50YCB0aGF0IGdldHMgYWRkZWQgYXMgYSBjaGlsZC4gV2hlbiB1c2luZyBhIHN0cmluZyB0aGVcbiAgICogICAgICAgICBgQ29tcG9uZW50YCB3aWxsIGdldCBjcmVhdGVkIGJ5IHRoaXMgcHJvY2Vzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1XG4gICAqL1xuXG5cbiAgQnV0dG9uLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIGFkZENoaWxkKGNoaWxkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcblxuICAgIGxvZyQxLndhcm4oJ0FkZGluZyBhbiBhY3Rpb25hYmxlICh1c2VyIGNvbnRyb2xsYWJsZSkgY2hpbGQgdG8gYSBCdXR0b24gKCcgKyBjbGFzc05hbWUgKyAnKSBpcyBub3Qgc3VwcG9ydGVkOyB1c2UgYSBDbGlja2FibGVDb21wb25lbnQgaW5zdGVhZC4nKTtcblxuICAgIC8vIEF2b2lkIHRoZSBlcnJvciBtZXNzYWdlIGdlbmVyYXRlZCBieSBDbGlja2FibGVDb21wb25lbnQncyBhZGRDaGlsZCBtZXRob2RcbiAgICByZXR1cm4gQ29tcG9uZW50LnByb3RvdHlwZS5hZGRDaGlsZC5jYWxsKHRoaXMsIGNoaWxkLCBvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIHRoZSBgQnV0dG9uYCBlbGVtZW50IHNvIHRoYXQgaXQgY2FuIGJlIGFjdGl2YXRlZCBvciBjbGlja2VkLiBVc2UgdGhpcyB3aXRoXG4gICAqIHtAbGluayBCdXR0b24jZGlzYWJsZX0uXG4gICAqL1xuXG5cbiAgQnV0dG9uLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuZW5hYmxlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5lbF8ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSBgQnV0dG9uYCBlbGVtZW50IHNvIHRoYXQgaXQgY2Fubm90IGJlIGFjdGl2YXRlZCBvciBjbGlja2VkLiBVc2UgdGhpcyB3aXRoXG4gICAqIHtAbGluayBCdXR0b24jZW5hYmxlfS5cbiAgICovXG5cblxuICBCdXR0b24ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIF9DbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmRpc2FibGUuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhIGBCdXR0b25gIGhhcyBmb2N1cyBhbmQgYGtleWRvd25gIGlzIHRyaWdnZXJlZCB2aWEgYSBrZXlcbiAgICogcHJlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBnZXQgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgQnV0dG9uLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG5cbiAgICAvLyBJZ25vcmUgU3BhY2UgKDMyKSBvciBFbnRlciAoMTMpIGtleSBvcGVyYXRpb24sIHdoaWNoIGlzIGhhbmRsZWQgYnkgdGhlIGJyb3dzZXIgZm9yIGEgYnV0dG9uLlxuICAgIGlmIChldmVudC53aGljaCA9PT0gMzIgfHwgZXZlbnQud2hpY2ggPT09IDEzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUGFzcyBrZXlwcmVzcyBoYW5kbGluZyB1cCBmb3IgdW5zdXBwb3J0ZWQga2V5c1xuICAgIF9DbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUtleVByZXNzLmNhbGwodGhpcywgZXZlbnQpO1xuICB9O1xuXG4gIHJldHVybiBCdXR0b247XG59KENsaWNrYWJsZUNvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQnV0dG9uJywgQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBiaWctcGxheS1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgaW5pdGlhbCBwbGF5IGJ1dHRvbiB0aGF0IHNob3dzIGJlZm9yZSB0aGUgdmlkZW8gaGFzIHBsYXllZC4gVGhlIGhpZGluZyBvZiB0aGVcbiAqIGBCaWdQbGF5QnV0dG9uYCBnZXQgZG9uZSB2aWEgQ1NTIGFuZCBgUGxheWVyYCBzdGF0ZXMuXG4gKlxuICogQGV4dGVuZHMgQnV0dG9uXG4gKi9cblxudmFyIEJpZ1BsYXlCdXR0b24gPSBmdW5jdGlvbiAoX0J1dHRvbikge1xuICBpbmhlcml0cyhCaWdQbGF5QnV0dG9uLCBfQnV0dG9uKTtcblxuICBmdW5jdGlvbiBCaWdQbGF5QnV0dG9uKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJpZ1BsYXlCdXR0b24pO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5tb3VzZXVzZWRfID0gZmFsc2U7XG5cbiAgICBfdGhpcy5vbignbW91c2Vkb3duJywgX3RoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LiBBbHdheXMgcmV0dXJucyAndmpzLWJpZy1wbGF5LWJ1dHRvbicuXG4gICAqL1xuXG5cbiAgQmlnUGxheUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtYmlnLXBsYXktYnV0dG9uJztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGEgYEJpZ1BsYXlCdXR0b25gIFwiY2xpY2tlZFwiLiBTZWUge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH1cbiAgICogZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgQmlnUGxheUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIHZhciBwbGF5UHJvbWlzZSA9IHRoaXMucGxheWVyXy5wbGF5KCk7XG5cbiAgICAvLyBleGl0IGVhcmx5IGlmIGNsaWNrZWQgdmlhIHRoZSBtb3VzZVxuICAgIGlmICh0aGlzLm1vdXNldXNlZF8gJiYgZXZlbnQuY2xpZW50WCAmJiBldmVudC5jbGllbnRZKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNiID0gdGhpcy5wbGF5ZXJfLmdldENoaWxkKCdjb250cm9sQmFyJyk7XG4gICAgdmFyIHBsYXlUb2dnbGUgPSBjYiAmJiBjYi5nZXRDaGlsZCgncGxheVRvZ2dsZScpO1xuXG4gICAgaWYgKCFwbGF5VG9nZ2xlKSB7XG4gICAgICB0aGlzLnBsYXllcl8uZm9jdXMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGxheUZvY3VzID0gZnVuY3Rpb24gcGxheUZvY3VzKCkge1xuICAgICAgcmV0dXJuIHBsYXlUb2dnbGUuZm9jdXMoKTtcbiAgICB9O1xuXG4gICAgaWYgKGlzUHJvbWlzZShwbGF5UHJvbWlzZSkpIHtcbiAgICAgIHBsYXlQcm9taXNlLnRoZW4ocGxheUZvY3VzLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0VGltZW91dChwbGF5Rm9jdXMsIDEpO1xuICAgIH1cbiAgfTtcblxuICBCaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG4gICAgdGhpcy5tb3VzZXVzZWRfID0gZmFsc2U7XG5cbiAgICBfQnV0dG9uLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcy5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfTtcblxuICBCaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICB0aGlzLm1vdXNldXNlZF8gPSB0cnVlO1xuICB9O1xuXG4gIHJldHVybiBCaWdQbGF5QnV0dG9uO1xufShCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYEJpZ1BsYXlCdXR0b25gcyBjb250cm9scy4gQWRkZWQgdG8gZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkJpZ1BsYXlCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdQbGF5IFZpZGVvJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdCaWdQbGF5QnV0dG9uJywgQmlnUGxheUJ1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgY2xvc2UtYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGBDbG9zZUJ1dHRvbmAgaXMgYSBge0BsaW5rIEJ1dHRvbn1gIHRoYXQgZmlyZXMgYSBgY2xvc2VgIGV2ZW50IHdoZW5cbiAqIGl0IGdldHMgY2xpY2tlZC5cbiAqXG4gKiBAZXh0ZW5kcyBCdXR0b25cbiAqL1xuXG52YXIgQ2xvc2VCdXR0b24gPSBmdW5jdGlvbiAoX0J1dHRvbikge1xuICBpbmhlcml0cyhDbG9zZUJ1dHRvbiwgX0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSAge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIENsb3NlQnV0dG9uKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENsb3NlQnV0dG9uKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuY29udHJvbFRleHQob3B0aW9ucyAmJiBvcHRpb25zLmNvbnRyb2xUZXh0IHx8IF90aGlzLmxvY2FsaXplKCdDbG9zZScpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIENsb3NlQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jbG9zZS1idXR0b24gJyArIF9CdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGEgYENsb3NlQnV0dG9uYCBnZXRzIGNsaWNrZWQuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUNsaWNrfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB3aGVuIHRoaXMgd2lsbCBiZVxuICAgKiB0cmlnZ2VyZWRcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqIEBmaXJlcyBDbG9zZUJ1dHRvbiNjbG9zZVxuICAgKi9cblxuXG4gIENsb3NlQnV0dG9uLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgYSBgQ2xvc2VCdXR0b25gIGlzIGNsaWNrZWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgQ2xvc2VCdXR0b24jY2xvc2VcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtidWJibGVzPWZhbHNlXVxuICAgICAqICAgICAgICAgICBzZXQgdG8gZmFsc2Ugc28gdGhhdCB0aGUgY2xvc2UgZXZlbnQgZG9lcyBub3RcbiAgICAgKiAgICAgICAgICAgYnViYmxlIHVwIHRvIHBhcmVudHMgaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXJcbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoeyB0eXBlOiAnY2xvc2UnLCBidWJibGVzOiBmYWxzZSB9KTtcbiAgfTtcblxuICByZXR1cm4gQ2xvc2VCdXR0b247XG59KEJ1dHRvbik7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2xvc2VCdXR0b24nLCBDbG9zZUJ1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgcGxheS10b2dnbGUuanNcbiAqL1xuLyoqXG4gKiBCdXR0b24gdG8gdG9nZ2xlIGJldHdlZW4gcGxheSBhbmQgcGF1c2UuXG4gKlxuICogQGV4dGVuZHMgQnV0dG9uXG4gKi9cblxudmFyIFBsYXlUb2dnbGUgPSBmdW5jdGlvbiAoX0J1dHRvbikge1xuICBpbmhlcml0cyhQbGF5VG9nZ2xlLCBfQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFBsYXlUb2dnbGUocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxheVRvZ2dsZSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgJ3BsYXknLCBfdGhpcy5oYW5kbGVQbGF5KTtcbiAgICBfdGhpcy5vbihwbGF5ZXIsICdwYXVzZScsIF90aGlzLmhhbmRsZVBhdXNlKTtcbiAgICBfdGhpcy5vbihwbGF5ZXIsICdlbmRlZCcsIF90aGlzLmhhbmRsZUVuZGVkKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXBsYXktY29udHJvbCAnICsgX0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYFBsYXlUb2dnbGVgIGlzIFwiY2xpY2tlZFwiLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBQbGF5VG9nZ2xlLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIG9uY2UgYWZ0ZXIgdGhlIHZpZGVvIGhhcyBlbmRlZCBhbmQgdGhlIHVzZXIgc2Vla3Mgc28gdGhhdFxuICAgKiB3ZSBjYW4gY2hhbmdlIHRoZSByZXBsYXkgYnV0dG9uIGJhY2sgdG8gYSBwbGF5IGJ1dHRvbi5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjc2Vla2VkXG4gICAqL1xuXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlU2Vla2VkID0gZnVuY3Rpb24gaGFuZGxlU2Vla2VkKGV2ZW50KSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVuZGVkJyk7XG5cbiAgICBpZiAodGhpcy5wbGF5ZXJfLnBhdXNlZCgpKSB7XG4gICAgICB0aGlzLmhhbmRsZVBhdXNlKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVQbGF5KGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgdmpzLXBsYXlpbmcgY2xhc3MgdG8gdGhlIGVsZW1lbnQgc28gaXQgY2FuIGNoYW5nZSBhcHBlYXJhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNwbGF5XG4gICAqL1xuXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlUGxheSA9IGZ1bmN0aW9uIGhhbmRsZVBsYXkoZXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZW5kZWQnKTtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGF1c2VkJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBsYXlpbmcnKTtcbiAgICAvLyBjaGFuZ2UgdGhlIGJ1dHRvbiB0ZXh0IHRvIFwiUGF1c2VcIlxuICAgIHRoaXMuY29udHJvbFRleHQoJ1BhdXNlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgdmpzLXBhdXNlZCBjbGFzcyB0byB0aGUgZWxlbWVudCBzbyBpdCBjYW4gY2hhbmdlIGFwcGVhcmFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3BhdXNlXG4gICAqL1xuXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlUGF1c2UgPSBmdW5jdGlvbiBoYW5kbGVQYXVzZShldmVudCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIC8vIGNoYW5nZSB0aGUgYnV0dG9uIHRleHQgdG8gXCJQbGF5XCJcbiAgICB0aGlzLmNvbnRyb2xUZXh0KCdQbGF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgdmpzLWVuZGVkIGNsYXNzIHRvIHRoZSBlbGVtZW50IHNvIGl0IGNhbiBjaGFuZ2UgYXBwZWFyYW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNlbmRlZFxuICAgKi9cblxuXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmhhbmRsZUVuZGVkID0gZnVuY3Rpb24gaGFuZGxlRW5kZWQoZXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGxheWluZycpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuICAgIC8vIGNoYW5nZSB0aGUgYnV0dG9uIHRleHQgdG8gXCJSZXBsYXlcIlxuICAgIHRoaXMuY29udHJvbFRleHQoJ1JlcGxheScpO1xuXG4gICAgLy8gb24gdGhlIG5leHQgc2VlayByZW1vdmUgdGhlIHJlcGxheSBidXR0b25cbiAgICB0aGlzLm9uZSh0aGlzLnBsYXllcl8sICdzZWVrZWQnLCB0aGlzLmhhbmRsZVNlZWtlZCk7XG4gIH07XG5cbiAgcmV0dXJuIFBsYXlUb2dnbGU7XG59KEJ1dHRvbik7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgUGxheVRvZ2dsZWBzIGNvbnRyb2xzLiBBZGRlZCBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuUGxheVRvZ2dsZS5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ1BsYXknO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXlUb2dnbGUnLCBQbGF5VG9nZ2xlKTtcblxuLyoqXG4gKiBAZmlsZSBmb3JtYXQtdGltZS5qc1xuICogQG1vZHVsZSBGb3JtYXQtdGltZVxuICovXG5cbi8qKlxuICogRm9ybWF0IHNlY29uZHMgYXMgYSB0aW1lIHN0cmluZywgSDpNTTpTUyBvciBNOlNTLiBTdXBwbHlpbmcgYSBndWlkZSAoaW4gc2Vjb25kcylcbiAqIHdpbGwgZm9yY2UgYSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyB0byBjb3ZlciB0aGUgbGVuZ3RoIG9mIHRoZSBndWlkZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gc2Vjb25kc1xuICogICAgICAgIE51bWJlciBvZiBzZWNvbmRzIHRvIGJlIHR1cm5lZCBpbnRvIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGd1aWRlXG4gKiAgICAgICAgTnVtYmVyIChpbiBzZWNvbmRzKSB0byBtb2RlbCB0aGUgc3RyaW5nIGFmdGVyXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaW1lIGZvcm1hdHRlZCBhcyBIOk1NOlNTIG9yIE06U1NcbiAqL1xuZnVuY3Rpb24gZm9ybWF0VGltZShzZWNvbmRzKSB7XG4gIHZhciBndWlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogc2Vjb25kcztcblxuICBzZWNvbmRzID0gc2Vjb25kcyA8IDAgPyAwIDogc2Vjb25kcztcbiAgdmFyIHMgPSBNYXRoLmZsb29yKHNlY29uZHMgJSA2MCk7XG4gIHZhciBtID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gNjAgJSA2MCk7XG4gIHZhciBoID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gMzYwMCk7XG4gIHZhciBnbSA9IE1hdGguZmxvb3IoZ3VpZGUgLyA2MCAlIDYwKTtcbiAgdmFyIGdoID0gTWF0aC5mbG9vcihndWlkZSAvIDM2MDApO1xuXG4gIC8vIGhhbmRsZSBpbnZhbGlkIHRpbWVzXG4gIGlmIChpc05hTihzZWNvbmRzKSB8fCBzZWNvbmRzID09PSBJbmZpbml0eSkge1xuICAgIC8vICctJyBpcyBmYWxzZSBmb3IgYWxsIHJlbGF0aW9uYWwgb3BlcmF0b3JzIChlLmcuIDwsID49KSBzbyB0aGlzIHNldHRpbmdcbiAgICAvLyB3aWxsIGFkZCB0aGUgbWluaW11bSBudW1iZXIgb2YgZmllbGRzIHNwZWNpZmllZCBieSB0aGUgZ3VpZGVcbiAgICBoID0gbSA9IHMgPSAnLSc7XG4gIH1cblxuICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHNob3cgaG91cnNcbiAgaCA9IGggPiAwIHx8IGdoID4gMCA/IGggKyAnOicgOiAnJztcblxuICAvLyBJZiBob3VycyBhcmUgc2hvd2luZywgd2UgbWF5IG5lZWQgdG8gYWRkIGEgbGVhZGluZyB6ZXJvLlxuICAvLyBBbHdheXMgc2hvdyBhdCBsZWFzdCBvbmUgZGlnaXQgb2YgbWludXRlcy5cbiAgbSA9ICgoaCB8fCBnbSA+PSAxMCkgJiYgbSA8IDEwID8gJzAnICsgbSA6IG0pICsgJzonO1xuXG4gIC8vIENoZWNrIGlmIGxlYWRpbmcgemVybyBpcyBuZWVkIGZvciBzZWNvbmRzXG4gIHMgPSBzIDwgMTAgPyAnMCcgKyBzIDogcztcblxuICByZXR1cm4gaCArIG0gKyBzO1xufVxuXG4vKipcbiAqIEBmaWxlIHRpbWUtZGlzcGxheS5qc1xuICovXG4vKipcbiAqIERpc3BsYXlzIHRoZSB0aW1lIGxlZnQgaW4gdGhlIHZpZGVvXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFRpbWVEaXNwbGF5ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVGltZURpc3BsYXksIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVGltZURpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltZURpc3BsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy50aHJvdHRsZWRVcGRhdGVDb250ZW50ID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMudXBkYXRlQ29udGVudCksIDI1KTtcbiAgICBfdGhpcy5vbihwbGF5ZXIsICd0aW1ldXBkYXRlJywgX3RoaXMudGhyb3R0bGVkVXBkYXRlQ29udGVudCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVGltZURpc3BsYXkucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEocGxhaW5OYW1lKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuYnVpbGRDU1NDbGFzcygpO1xuICAgIHZhciBlbCA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lICsgJyB2anMtdGltZS1jb250cm9sIHZqcy1jb250cm9sJ1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250ZW50RWxfID0gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lICsgJy1kaXNwbGF5J1xuICAgIH0sIHtcbiAgICAgIC8vIHRlbGwgc2NyZWVuIHJlYWRlcnMgbm90IHRvIGF1dG9tYXRpY2FsbHkgcmVhZCB0aGUgdGltZSBhcyBpdCBjaGFuZ2VzXG4gICAgICAnYXJpYS1saXZlJzogJ29mZidcbiAgICB9LCBjcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jb250cm9sLXRleHQnLFxuICAgICAgdGV4dENvbnRlbnQ6IHRoaXMubG9jYWxpemUodGhpcy5jb250cm9sVGV4dF8pXG4gICAgfSkpO1xuXG4gICAgdGhpcy51cGRhdGVUZXh0Tm9kZV8oKTtcbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICBUaW1lRGlzcGxheS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5jb250ZW50RWxfID0gbnVsbDtcbiAgICB0aGlzLnRleHROb2RlXyA9IG51bGw7XG5cbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIFwicmVtYWluaW5nIHRpbWVcIiB0ZXh0IG5vZGUgd2l0aCBuZXcgY29udGVudCB1c2luZyB0aGVcbiAgICogY29udGVudHMgb2YgdGhlIGBmb3JtYXR0ZWRUaW1lX2AgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZVRleHROb2RlXyA9IGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlXygpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudEVsXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlICh0aGlzLmNvbnRlbnRFbF8uZmlyc3RDaGlsZCkge1xuICAgICAgdGhpcy5jb250ZW50RWxfLnJlbW92ZUNoaWxkKHRoaXMuY29udGVudEVsXy5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICB0aGlzLnRleHROb2RlXyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuZm9ybWF0dGVkVGltZV8gfHwgJzA6MDAnKTtcbiAgICB0aGlzLmNvbnRlbnRFbF8uYXBwZW5kQ2hpbGQodGhpcy50ZXh0Tm9kZV8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBmb3JtYXR0ZWQgdGltZSBmb3IgdGhpcyBjb21wb25lbnQgdG8gdXNlIGluIGRpc3BsYXkuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gdGltZVxuICAgKiAgICAgICAgIEEgbnVtZXJpYyB0aW1lLCBpbiBzZWNvbmRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgQSBmb3JtYXR0ZWQgdGltZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRpbWVEaXNwbGF5LnByb3RvdHlwZS5mb3JtYXRUaW1lXyA9IGZ1bmN0aW9uIGZvcm1hdFRpbWVfKHRpbWUpIHtcbiAgICByZXR1cm4gZm9ybWF0VGltZSh0aW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdGltZSBkaXNwbGF5IHRleHQgbm9kZSBpZiBpdCBoYXMgd2hhdCB3YXMgcGFzc2VkIGluIGNoYW5nZWRcbiAgICogdGhlIGZvcm1hdHRlZCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVxuICAgKiAgICAgICAgVGhlIHRpbWUgdG8gdXBkYXRlIHRvXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUZvcm1hdHRlZFRpbWVfID0gZnVuY3Rpb24gdXBkYXRlRm9ybWF0dGVkVGltZV8odGltZSkge1xuICAgIHZhciBmb3JtYXR0ZWRUaW1lID0gdGhpcy5mb3JtYXRUaW1lXyh0aW1lKTtcblxuICAgIGlmIChmb3JtYXR0ZWRUaW1lID09PSB0aGlzLmZvcm1hdHRlZFRpbWVfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5mb3JtYXR0ZWRUaW1lXyA9IGZvcm1hdHRlZFRpbWU7XG4gICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVUZXh0Tm9kZV8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUbyBiZSBmaWxsZWQgb3V0IGluIHRoZSBjaGlsZCBjbGFzcywgc2hvdWxkIHVwZGF0ZSB0aGUgZGlzcGxheWVkIHRpbWVcbiAgICogaW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBmYWN0IHRoYXQgdGhlIGN1cnJlbnQgdGltZSBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGB0aW1ldXBkYXRlYCAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciN0aW1ldXBkYXRlXG4gICAqL1xuXG5cbiAgVGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiB1cGRhdGVDb250ZW50KGV2ZW50KSB7fTtcblxuICByZXR1cm4gVGltZURpc3BsYXk7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgVGltZURpc3BsYXlgcyBjb250cm9scy4gQWRkZWQgdG8gZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cblRpbWVEaXNwbGF5LnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnVGltZSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGltZURpc3BsYXknLCBUaW1lRGlzcGxheSk7XG5cbi8qKlxuICogQGZpbGUgY3VycmVudC10aW1lLWRpc3BsYXkuanNcbiAqL1xuLyoqXG4gKiBEaXNwbGF5cyB0aGUgY3VycmVudCB0aW1lXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIEN1cnJlbnRUaW1lRGlzcGxheSA9IGZ1bmN0aW9uIChfVGltZURpc3BsYXkpIHtcbiAgaW5oZXJpdHMoQ3VycmVudFRpbWVEaXNwbGF5LCBfVGltZURpc3BsYXkpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gQ3VycmVudFRpbWVEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEN1cnJlbnRUaW1lRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UaW1lRGlzcGxheS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAnZW5kZWQnLCBfdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBDdXJyZW50VGltZURpc3BsYXkucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWN1cnJlbnQtdGltZSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjdXJyZW50IHRpbWUgZGlzcGxheVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYHRpbWV1cGRhdGVgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGltZXVwZGF0ZVxuICAgKi9cblxuXG4gIEN1cnJlbnRUaW1lRGlzcGxheS5wcm90b3R5cGUudXBkYXRlQ29udGVudCA9IGZ1bmN0aW9uIHVwZGF0ZUNvbnRlbnQoZXZlbnQpIHtcbiAgICAvLyBBbGxvd3MgZm9yIHNtb290aCBzY3J1YmJpbmcsIHdoZW4gcGxheWVyIGNhbid0IGtlZXAgdXAuXG4gICAgdmFyIHRpbWUgPSB0aGlzLnBsYXllcl8uc2NydWJiaW5nKCkgPyB0aGlzLnBsYXllcl8uZ2V0Q2FjaGUoKS5jdXJyZW50VGltZSA6IHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpO1xuXG4gICAgdGhpcy51cGRhdGVGb3JtYXR0ZWRUaW1lXyh0aW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgcGxheWVyIGZpcmVzIGVuZGVkIHRoZXJlIHNob3VsZCBiZSBubyB0aW1lIGxlZnQuIFNhZGx5XG4gICAqIHRoaXMgaXMgbm90IGFsd2F5cyB0aGUgY2FzZSwgbGV0cyBtYWtlIGl0IHNlZW0gbGlrZSB0aGF0IGlzIHRoZSBjYXNlXG4gICAqIGZvciB1c2Vycy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBlbmRlZGAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNlbmRlZFxuICAgKi9cblxuXG4gIEN1cnJlbnRUaW1lRGlzcGxheS5wcm90b3R5cGUuaGFuZGxlRW5kZWQgPSBmdW5jdGlvbiBoYW5kbGVFbmRlZChldmVudCkge1xuICAgIGlmICghdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVGb3JtYXR0ZWRUaW1lXyh0aGlzLnBsYXllcl8uZHVyYXRpb24oKSk7XG4gIH07XG5cbiAgcmV0dXJuIEN1cnJlbnRUaW1lRGlzcGxheTtcbn0oVGltZURpc3BsYXkpO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYEN1cnJlbnRUaW1lRGlzcGxheWBzIGNvbnRyb2xzLiBBZGRlZCB0byBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuQ3VycmVudFRpbWVEaXNwbGF5LnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnQ3VycmVudCBUaW1lJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDdXJyZW50VGltZURpc3BsYXknLCBDdXJyZW50VGltZURpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIGR1cmF0aW9uLWRpc3BsYXkuanNcbiAqL1xuLyoqXG4gKiBEaXNwbGF5cyB0aGUgZHVyYXRpb25cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgRHVyYXRpb25EaXNwbGF5ID0gZnVuY3Rpb24gKF9UaW1lRGlzcGxheSkge1xuICBpbmhlcml0cyhEdXJhdGlvbkRpc3BsYXksIF9UaW1lRGlzcGxheSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBEdXJhdGlvbkRpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRHVyYXRpb25EaXNwbGF5KTtcblxuICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvL25lZWQgdG8gdGhyb3R0bGUgZHVyYXRpb24gY2hhbmdlcyxcbiAgICAvLyBhcyB0aGV5IHNob3VsZCBhbHdheXMgZGlzcGxheSB0aGUgY2hhbmdlZCBkdXJhdGlvbiBhc1xuICAgIC8vIGl0IGhhcyBjaGFuZ2VkXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGltZURpc3BsYXkuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgJ2R1cmF0aW9uY2hhbmdlJywgX3RoaXMudXBkYXRlQ29udGVudCk7XG5cbiAgICAvLyBBbHNvIGxpc3RlbiBmb3IgdGltZXVwZGF0ZSAoaW4gdGhlIHBhcmVudCkgYW5kIGxvYWRlZG1ldGFkYXRhIGJlY2F1c2UgcmVtb3ZpbmcgdGhvc2VcbiAgICAvLyBsaXN0ZW5lcnMgY291bGQgaGF2ZSBicm9rZW4gZGVwZW5kZW50IGFwcGxpY2F0aW9ucy9saWJyYXJpZXMuIFRoZXNlXG4gICAgLy8gY2FuIGxpa2VseSBiZSByZW1vdmVkIGZvciA3LjAuXG4gICAgX3RoaXMub24ocGxheWVyLCAnbG9hZGVkbWV0YWRhdGEnLCBfdGhpcy50aHJvdHRsZWRVcGRhdGVDb250ZW50KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIER1cmF0aW9uRGlzcGxheS5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtZHVyYXRpb24nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgZHVyYXRpb24gdGltZSBkaXNwbGF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGR1cmF0aW9uY2hhbmdlYCwgYHRpbWV1cGRhdGVgLCBvciBgbG9hZGVkbWV0YWRhdGFgIGV2ZW50IHRoYXQgY2F1c2VkXG4gICAqICAgICAgICB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2R1cmF0aW9uY2hhbmdlXG4gICAqIEBsaXN0ZW5zIFBsYXllciN0aW1ldXBkYXRlXG4gICAqIEBsaXN0ZW5zIFBsYXllciNsb2FkZWRtZXRhZGF0YVxuICAgKi9cblxuXG4gIER1cmF0aW9uRGlzcGxheS5wcm90b3R5cGUudXBkYXRlQ29udGVudCA9IGZ1bmN0aW9uIHVwZGF0ZUNvbnRlbnQoZXZlbnQpIHtcbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcblxuICAgIGlmIChkdXJhdGlvbiAmJiB0aGlzLmR1cmF0aW9uXyAhPT0gZHVyYXRpb24pIHtcbiAgICAgIHRoaXMuZHVyYXRpb25fID0gZHVyYXRpb247XG4gICAgICB0aGlzLnVwZGF0ZUZvcm1hdHRlZFRpbWVfKGR1cmF0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIER1cmF0aW9uRGlzcGxheTtcbn0oVGltZURpc3BsYXkpO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYER1cmF0aW9uRGlzcGxheWBzIGNvbnRyb2xzLiBBZGRlZCB0byBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuRHVyYXRpb25EaXNwbGF5LnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnRHVyYXRpb24gVGltZSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnRHVyYXRpb25EaXNwbGF5JywgRHVyYXRpb25EaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSB0aW1lLWRpdmlkZXIuanNcbiAqL1xuLyoqXG4gKiBUaGUgc2VwYXJhdG9yIGJldHdlZW4gdGhlIGN1cnJlbnQgdGltZSBhbmQgZHVyYXRpb24uXG4gKiBDYW4gYmUgaGlkZGVuIGlmIGl0J3Mgbm90IG5lZWRlZCBpbiB0aGUgZGVzaWduLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBUaW1lRGl2aWRlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFRpbWVEaXZpZGVyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUaW1lRGl2aWRlcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lRGl2aWRlcik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIFRpbWVEaXZpZGVyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdGltZS1jb250cm9sIHZqcy10aW1lLWRpdmlkZXInLFxuICAgICAgaW5uZXJIVE1MOiAnPGRpdj48c3Bhbj4vPC9zcGFuPjwvZGl2PidcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVGltZURpdmlkZXI7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGltZURpdmlkZXInLCBUaW1lRGl2aWRlcik7XG5cbi8qKlxuICogQGZpbGUgcmVtYWluaW5nLXRpbWUtZGlzcGxheS5qc1xuICovXG4vKipcbiAqIERpc3BsYXlzIHRoZSB0aW1lIGxlZnQgaW4gdGhlIHZpZGVvXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFJlbWFpbmluZ1RpbWVEaXNwbGF5ID0gZnVuY3Rpb24gKF9UaW1lRGlzcGxheSkge1xuICBpbmhlcml0cyhSZW1haW5pbmdUaW1lRGlzcGxheSwgX1RpbWVEaXNwbGF5KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFJlbWFpbmluZ1RpbWVEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbWFpbmluZ1RpbWVEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RpbWVEaXNwbGF5LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdkdXJhdGlvbmNoYW5nZScsIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQpO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ2VuZGVkJywgX3RoaXMuaGFuZGxlRW5kZWQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgUmVtYWluaW5nVGltZURpc3BsYXkucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXJlbWFpbmluZy10aW1lJztcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHJlbWFpbmluZyB0aW1lIGRpc3BsYXkgcHJlZml4ZXMgbnVtYmVycyB3aXRoIGEgXCJtaW51c1wiIGNoYXJhY3Rlci5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lXG4gICAqICAgICAgICAgQSBudW1lcmljIHRpbWUsIGluIHNlY29uZHMuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBBIGZvcm1hdHRlZCB0aW1lXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUmVtYWluaW5nVGltZURpc3BsYXkucHJvdG90eXBlLmZvcm1hdFRpbWVfID0gZnVuY3Rpb24gZm9ybWF0VGltZV8odGltZSkge1xuICAgIHJldHVybiAnLScgKyBfVGltZURpc3BsYXkucHJvdG90eXBlLmZvcm1hdFRpbWVfLmNhbGwodGhpcywgdGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSByZW1haW5pbmcgdGltZSBkaXNwbGF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYHRpbWV1cGRhdGVgIG9yIGBkdXJhdGlvbmNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciN0aW1ldXBkYXRlXG4gICAqIEBsaXN0ZW5zIFBsYXllciNkdXJhdGlvbmNoYW5nZVxuICAgKi9cblxuXG4gIFJlbWFpbmluZ1RpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gdXBkYXRlQ29udGVudChldmVudCkge1xuICAgIGlmICghdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBAZGVwcmVjYXRlZCBXZSBzaG91bGQgb25seSB1c2UgcmVtYWluaW5nVGltZURpc3BsYXlcbiAgICAvLyBhcyBvZiB2aWRlby5qcyA3XG4gICAgaWYgKHRoaXMucGxheWVyXy5yZW1haW5pbmdUaW1lRGlzcGxheSkge1xuICAgICAgdGhpcy51cGRhdGVGb3JtYXR0ZWRUaW1lXyh0aGlzLnBsYXllcl8ucmVtYWluaW5nVGltZURpc3BsYXkoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlRm9ybWF0dGVkVGltZV8odGhpcy5wbGF5ZXJfLnJlbWFpbmluZ1RpbWUoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwbGF5ZXIgZmlyZXMgZW5kZWQgdGhlcmUgc2hvdWxkIGJlIG5vIHRpbWUgbGVmdC4gU2FkbHlcbiAgICogdGhpcyBpcyBub3QgYWx3YXlzIHRoZSBjYXNlLCBsZXRzIG1ha2UgaXQgc2VlbSBsaWtlIHRoYXQgaXMgdGhlIGNhc2VcbiAgICogZm9yIHVzZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGVuZGVkYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2VuZGVkXG4gICAqL1xuXG5cbiAgUmVtYWluaW5nVGltZURpc3BsYXkucHJvdG90eXBlLmhhbmRsZUVuZGVkID0gZnVuY3Rpb24gaGFuZGxlRW5kZWQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMucGxheWVyXy5kdXJhdGlvbigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRm9ybWF0dGVkVGltZV8oMCk7XG4gIH07XG5cbiAgcmV0dXJuIFJlbWFpbmluZ1RpbWVEaXNwbGF5O1xufShUaW1lRGlzcGxheSk7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgUmVtYWluaW5nVGltZURpc3BsYXlgcyBjb250cm9scy4gQWRkZWQgdG8gZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cblJlbWFpbmluZ1RpbWVEaXNwbGF5LnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnUmVtYWluaW5nIFRpbWUnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1JlbWFpbmluZ1RpbWVEaXNwbGF5JywgUmVtYWluaW5nVGltZURpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIGxpdmUtZGlzcGxheS5qc1xuICovXG4vLyBUT0RPIC0gRnV0dXJlIG1ha2UgaXQgY2xpY2sgdG8gc25hcCB0byBsaXZlXG5cbi8qKlxuICogRGlzcGxheXMgdGhlIGxpdmUgaW5kaWNhdG9yIHdoZW4gZHVyYXRpb24gaXMgSW5maW5pdHkuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIExpdmVEaXNwbGF5ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTGl2ZURpc3BsYXksIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTGl2ZURpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTGl2ZURpc3BsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGVTaG93aW5nKCk7XG4gICAgX3RoaXMub24oX3RoaXMucGxheWVyKCksICdkdXJhdGlvbmNoYW5nZScsIF90aGlzLnVwZGF0ZVNob3dpbmcpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIExpdmVEaXNwbGF5LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBlbCA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1saXZlLWNvbnRyb2wgdmpzLWNvbnRyb2wnXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxpdmUtZGlzcGxheScsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4nICsgdGhpcy5sb2NhbGl6ZSgnU3RyZWFtIFR5cGUnKSArICc8L3NwYW4+JyArIHRoaXMubG9jYWxpemUoJ0xJVkUnKVxuICAgIH0sIHtcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgTGl2ZURpc3BsYXkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHRoaXMuY29udGVudEVsXyA9IG51bGw7XG5cbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBkdXJhdGlvbiB0byBzZWUgaWYgdGhlIExpdmVEaXNwbGF5IHNob3VsZCBiZSBzaG93aW5nIG9yIG5vdC4gVGhlbiBzaG93L2hpZGVcbiAgICogaXQgYWNjb3JkaW5nbHlcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIHtAbGluayBQbGF5ZXIjZHVyYXRpb25jaGFuZ2V9IGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcbiAgICovXG5cblxuICBMaXZlRGlzcGxheS5wcm90b3R5cGUudXBkYXRlU2hvd2luZyA9IGZ1bmN0aW9uIHVwZGF0ZVNob3dpbmcoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXIoKS5kdXJhdGlvbigpID09PSBJbmZpbml0eSkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTGl2ZURpc3BsYXk7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTGl2ZURpc3BsYXknLCBMaXZlRGlzcGxheSk7XG5cbi8qKlxuICogQGZpbGUgc2xpZGVyLmpzXG4gKi9cbi8qKlxuICogVGhlIGJhc2UgZnVuY3Rpb25hbGl0eSBmb3IgYSBzbGlkZXIuIENhbiBiZSB2ZXJ0aWNhbCBvciBob3Jpem9udGFsLlxuICogRm9yIGluc3RhbmNlIHRoZSB2b2x1bWUgYmFyIG9yIHRoZSBzZWVrIGJhciBvbiBhIHZpZGVvIGlzIGEgc2xpZGVyLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBTbGlkZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhTbGlkZXIsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFNsaWRlcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTbGlkZXIpO1xuXG4gICAgLy8gU2V0IHByb3BlcnR5IG5hbWVzIHRvIGJhciB0byBtYXRjaCB3aXRoIHRoZSBjaGlsZCBTbGlkZXIgY2xhc3MgaXMgbG9va2luZyBmb3JcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmJhciA9IF90aGlzLmdldENoaWxkKF90aGlzLm9wdGlvbnNfLmJhck5hbWUpO1xuXG4gICAgLy8gU2V0IGEgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjbGFzcyBvbiB0aGUgc2xpZGVyIGRlcGVuZGluZyBvbiB0aGUgc2xpZGVyIHR5cGVcbiAgICBfdGhpcy52ZXJ0aWNhbCghIV90aGlzLm9wdGlvbnNfLnZlcnRpY2FsKTtcblxuICAgIF90aGlzLmVuYWJsZSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBcmUgY29udHJvbHMgYXJlIGN1cnJlbnRseSBlbmFibGVkIGZvciB0aGlzIHNsaWRlciBvciBub3QuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgdHJ1ZSBpZiBjb250cm9scyBhcmUgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5lbmFibGVkID0gZnVuY3Rpb24gZW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmFibGVkXztcbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIGNvbnRyb2xzIGZvciB0aGlzIHNsaWRlciBpZiB0aGV5IGFyZSBkaXNhYmxlZFxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIGlmICh0aGlzLmVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMub24oJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICB0aGlzLm9uKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIHRoaXMub24oJ2ZvY3VzJywgdGhpcy5oYW5kbGVGb2N1cyk7XG4gICAgdGhpcy5vbignYmx1cicsIHRoaXMuaGFuZGxlQmx1cik7XG4gICAgdGhpcy5vbignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrKTtcblxuICAgIHRoaXMub24odGhpcy5wbGF5ZXJfLCAnY29udHJvbHN2aXNpYmxlJywgdGhpcy51cGRhdGUpO1xuXG4gICAgaWYgKHRoaXMucGxheWVyRXZlbnQpIHtcbiAgICAgIHRoaXMub24odGhpcy5wbGF5ZXJfLCB0aGlzLnBsYXllckV2ZW50LCB0aGlzLnVwZGF0ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcblxuICAgIHRoaXMuZW5hYmxlZF8gPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIGNvbnRyb2xzIGZvciB0aGlzIHNsaWRlciBpZiB0aGV5IGFyZSBlbmFibGVkXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkb2MgPSB0aGlzLmJhci5lbF8ub3duZXJEb2N1bWVudDtcblxuICAgIHRoaXMub2ZmKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vZmYoJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vZmYoJ2ZvY3VzJywgdGhpcy5oYW5kbGVGb2N1cyk7XG4gICAgdGhpcy5vZmYoJ2JsdXInLCB0aGlzLmhhbmRsZUJsdXIpO1xuICAgIHRoaXMub2ZmKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2spO1xuICAgIHRoaXMub2ZmKHRoaXMucGxheWVyXywgJ2NvbnRyb2xzdmlzaWJsZScsIHRoaXMudXBkYXRlKTtcbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5vZmYoZG9jLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcblxuICAgIHRoaXMuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cbiAgICBpZiAodGhpcy5wbGF5ZXJFdmVudCkge1xuICAgICAgdGhpcy5vZmYodGhpcy5wbGF5ZXJfLCB0aGlzLnBsYXllckV2ZW50LCB0aGlzLnVwZGF0ZSk7XG4gICAgfVxuICAgIHRoaXMuZW5hYmxlZF8gPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQnV0dG9uYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBUeXBlIG9mIGVsZW1lbnQgdG8gY3JlYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzPXt9XVxuICAgKiAgICAgICAgTGlzdCBvZiBwcm9wZXJ0aWVzIGluIE9iamVjdCBmb3JtLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXM9e31dXG4gICAqICAgICAgICBsaXN0IG9mIGF0dHJpYnV0ZXMgaW4gT2JqZWN0IGZvcm0uXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKHR5cGUpIHtcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIC8vIEFkZCB0aGUgc2xpZGVyIGVsZW1lbnQgY2xhc3MgdG8gYWxsIHN1YiBjbGFzc2VzXG4gICAgcHJvcHMuY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lICsgJyB2anMtc2xpZGVyJztcbiAgICBwcm9wcyA9IGFzc2lnbih7XG4gICAgICB0YWJJbmRleDogMFxuICAgIH0sIHByb3BzKTtcblxuICAgIGF0dHJpYnV0ZXMgPSBhc3NpZ24oe1xuICAgICAgJ3JvbGUnOiAnc2xpZGVyJyxcbiAgICAgICdhcmlhLXZhbHVlbm93JzogMCxcbiAgICAgICdhcmlhLXZhbHVlbWluJzogMCxcbiAgICAgICdhcmlhLXZhbHVlbWF4JzogMTAwLFxuICAgICAgJ3RhYkluZGV4JzogMFxuICAgIH0sIGF0dHJpYnV0ZXMpO1xuXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgdHlwZSwgcHJvcHMsIGF0dHJpYnV0ZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50cyBvbiB0aGUgYFNsaWRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cbiAgICogQGxpc3RlbnMgdG91Y2hzdGFydFxuICAgKiBAZmlyZXMgU2xpZGVyI3NsaWRlcmFjdGl2ZVxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG4gICAgdmFyIGRvYyA9IHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBibG9ja1RleHRTZWxlY3Rpb24oKTtcblxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkaW5nJyk7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHNsaWRlciBpcyBpbiBhbiBhY3RpdmUgc3RhdGVcbiAgICAgKlxuICAgICAqIEBldmVudCBTbGlkZXIjc2xpZGVyYWN0aXZlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignc2xpZGVyYWN0aXZlJyk7XG5cbiAgICB0aGlzLm9uKGRvYywgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKGRvYywgJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIHRoaXMub24oZG9jLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub24oZG9jLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuXG4gICAgdGhpcy5oYW5kbGVNb3VzZU1vdmUoZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGhlIGBtb3VzZW1vdmVgLCBgdG91Y2htb3ZlYCwgYW5kIGBtb3VzZWRvd25gIGV2ZW50cyBvbiB0aGlzIGBTbGlkZXJgLlxuICAgKiBUaGUgYG1vdXNlbW92ZWAgYW5kIGB0b3VjaG1vdmVgIGV2ZW50cyB3aWxsIG9ubHkgb25seSB0cmlnZ2VyIHRoaXMgZnVuY3Rpb24gZHVyaW5nXG4gICAqIGBtb3VzZWRvd25gIGFuZCBgdG91Y2hzdGFydGAuIFRoaXMgaXMgZHVlIHRvIHtAbGluayBTbGlkZXIjaGFuZGxlTW91c2VEb3dufSBhbmRcbiAgICoge0BsaW5rIFNsaWRlciNoYW5kbGVNb3VzZVVwfS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZWRvd25gLCBgbW91c2Vtb3ZlYCwgYHRvdWNoc3RhcnRgLCBvciBgdG91Y2htb3ZlYCBldmVudCB0aGF0IHRyaWdnZXJlZFxuICAgKiAgICAgICAgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZW1vdmVcbiAgICogQGxpc3RlbnMgdG91Y2htb3ZlXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHt9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNldXBgIG9yIGB0b3VjaGVuZGAgZXZlbnRzIG9uIHRoZSBgU2xpZGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRvdWNoZW5kXG4gICAqIEBsaXN0ZW5zIG1vdXNldXBcbiAgICogQGZpcmVzIFNsaWRlciNzbGlkZXJpbmFjdGl2ZVxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoKSB7XG4gICAgdmFyIGRvYyA9IHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdW5ibG9ja1RleHRTZWxlY3Rpb24oKTtcblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zbGlkaW5nJyk7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHNsaWRlciBpcyBubyBsb25nZXIgaW4gYW4gYWN0aXZlIHN0YXRlLlxuICAgICAqXG4gICAgICogQGV2ZW50IFNsaWRlciNzbGlkZXJpbmFjdGl2ZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3NsaWRlcmluYWN0aXZlJyk7XG5cbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5vZmYoZG9jLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MgYmFyIG9mIHRoZSBgU2xpZGVyYC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogICAgICAgICAgVGhlIHBlcmNlbnRhZ2Ugb2YgcHJvZ3Jlc3MgdGhlIHByb2dyZXNzIGJhciByZXByZXNlbnRzIGFzIGFcbiAgICogICAgICAgICAgbnVtYmVyIGZyb20gMCB0byAxLlxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG4gICAgLy8gSW4gVm9sdW1lQmFyIGluaXQgd2UgaGF2ZSBhIHNldFRpbWVvdXQgZm9yIHVwZGF0ZSB0aGF0IHBvcHMgYW5kIHVwZGF0ZVxuICAgIC8vIHRvIHRoZSBlbmQgb2YgdGhlIGV4ZWN1dGlvbiBzdGFjay4gVGhlIHBsYXllciBpcyBkZXN0cm95ZWQgYmVmb3JlIHRoZW5cbiAgICAvLyB1cGRhdGUgd2lsbCBjYXVzZSBhbiBlcnJvclxuICAgIGlmICghdGhpcy5lbF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBzY3J1YmJpbmcsIHdlIGNvdWxkIHVzZSBhIGNhY2hlZCB2YWx1ZSB0byBtYWtlIHRoZSBoYW5kbGUga2VlcCB1cFxuICAgIC8vIHdpdGggdGhlIHVzZXIncyBtb3VzZS4gT24gSFRNTDUgYnJvd3NlcnMgc2NydWJiaW5nIGlzIHJlYWxseSBzbW9vdGgsIGJ1dFxuICAgIC8vIHNvbWUgZmxhc2ggcGxheWVycyBhcmUgc2xvdywgc28gd2UgbWlnaHQgd2FudCB0byB1dGlsaXplIHRoaXMgbGF0ZXIuXG4gICAgLy8gdmFyIHByb2dyZXNzID0gICh0aGlzLnBsYXllcl8uc2NydWJiaW5nKCkpID8gdGhpcy5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgLyB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSA6IHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpIC8gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG4gICAgdmFyIHByb2dyZXNzID0gdGhpcy5nZXRQZXJjZW50KCk7XG4gICAgdmFyIGJhciA9IHRoaXMuYmFyO1xuXG4gICAgLy8gSWYgdGhlcmUncyBubyBiYXIuLi5cbiAgICBpZiAoIWJhcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByb3RlY3QgYWdhaW5zdCBubyBkdXJhdGlvbiBhbmQgb3RoZXIgZGl2aXNpb24gaXNzdWVzXG4gICAgaWYgKHR5cGVvZiBwcm9ncmVzcyAhPT0gJ251bWJlcicgfHwgcHJvZ3Jlc3MgIT09IHByb2dyZXNzIHx8IHByb2dyZXNzIDwgMCB8fCBwcm9ncmVzcyA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHByb2dyZXNzID0gMDtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IHRvIGEgcGVyY2VudGFnZSBmb3Igc2V0dGluZ1xuICAgIHZhciBwZXJjZW50YWdlID0gKHByb2dyZXNzICogMTAwKS50b0ZpeGVkKDIpICsgJyUnO1xuICAgIHZhciBzdHlsZSA9IGJhci5lbCgpLnN0eWxlO1xuXG4gICAgLy8gU2V0IHRoZSBuZXcgYmFyIHdpZHRoIG9yIGhlaWdodFxuICAgIGlmICh0aGlzLnZlcnRpY2FsKCkpIHtcbiAgICAgIHN0eWxlLmhlaWdodCA9IHBlcmNlbnRhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLndpZHRoID0gcGVyY2VudGFnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBkaXN0YW5jZSBmb3Igc2xpZGVyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgU2xpZGVyLlxuICAgKiAgICAgICAgIC0gcG9zdGl0aW9uLnggZm9yIHZlcnRpY2FsIGBTbGlkZXJgc1xuICAgKiAgICAgICAgIC0gcG9zdGl0aW9uLnkgZm9yIGhvcml6b250YWwgYFNsaWRlcmBzXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5jYWxjdWxhdGVEaXN0YW5jZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSB7XG4gICAgdmFyIHBvc2l0aW9uID0gZ2V0UG9pbnRlclBvc2l0aW9uKHRoaXMuZWxfLCBldmVudCk7XG5cbiAgICBpZiAodGhpcy52ZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb24ueTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uLng7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBmb2N1c2AgZXZlbnQgb24gdGhpcyBgU2xpZGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgZm9jdXNgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBmb2N1c1xuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlRm9jdXMgPSBmdW5jdGlvbiBoYW5kbGVGb2N1cygpIHtcbiAgICB0aGlzLm9uKHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5UHJlc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBga2V5ZG93bmAgZXZlbnQgb24gdGhlIGBTbGlkZXJgLiBXYXRjaGVzIGZvciBsZWZ0LCByaWd0aCwgdXAsIGFuZCBkb3duXG4gICAqIGFycm93IGtleXMuIFRoaXMgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIGNhbGxlZCB3aGVuIHRoZSBzbGlkZXIgaGFzIGZvY3VzLiBTZWVcbiAgICoge0BsaW5rIFNsaWRlciNoYW5kbGVGb2N1c30gYW5kIHtAbGluayBTbGlkZXIjaGFuZGxlQmx1cn0uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICB0aGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG4gICAgLy8gTGVmdCBhbmQgRG93biBBcnJvd3NcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDM3IHx8IGV2ZW50LndoaWNoID09PSA0MCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc3RlcEJhY2soKTtcblxuICAgICAgLy8gVXAgYW5kIFJpZ2h0IEFycm93c1xuICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDM4IHx8IGV2ZW50LndoaWNoID09PSAzOSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc3RlcEZvcndhcmQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBibHVyYCBldmVudCBvbiB0aGlzIGBTbGlkZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBibHVyYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgYmx1clxuICAgKi9cblxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuICAgIHRoaXMub2ZmKHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5UHJlc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0ZW5lciBmb3IgY2xpY2sgZXZlbnRzIG9uIHNsaWRlciwgdXNlZCB0byBwcmV2ZW50IGNsaWNrc1xuICAgKiAgIGZyb20gYnViYmxpbmcgdXAgdG8gcGFyZW50IGVsZW1lbnRzIGxpa2UgYnV0dG9uIG1lbnVzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICAgICAgIEV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgb2JqZWN0IHRvIHJ1blxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldC9zZXQgaWYgc2xpZGVyIGlzIGhvcml6b250YWwgZm9yIHZlcnRpY2FsXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb2xdXG4gICAqICAgICAgICAtIHRydWUgaWYgc2xpZGVyIGlzIHZlcnRpY2FsLFxuICAgKiAgICAgICAgLSBmYWxzZSBpcyBob3Jpem9udGFsXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSB0cnVlIGlmIHNsaWRlciBpcyB2ZXJ0aWNhbCwgYW5kIGdldHRpbmdcbiAgICogICAgICAgICAtIGZhbHNlIGlmIHRoZSBzbGlkZXIgaXMgaG9yaXpvbnRhbCwgYW5kIGdldHRpbmdcbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLnZlcnRpY2FsID0gZnVuY3Rpb24gdmVydGljYWwoYm9vbCkge1xuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnZlcnRpY2FsXyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnZlcnRpY2FsXyA9ICEhYm9vbDtcblxuICAgIGlmICh0aGlzLnZlcnRpY2FsXykge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNsaWRlci12ZXJ0aWNhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLWhvcml6b250YWwnKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNsaWRlcjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTbGlkZXInLCBTbGlkZXIpO1xuXG4vKipcbiAqIEBmaWxlIGxvYWQtcHJvZ3Jlc3MtYmFyLmpzXG4gKi9cbi8qKlxuICogU2hvd3MgbG9hZGluZyBwcm9ncmVzc1xuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBMb2FkUHJvZ3Jlc3NCYXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhMb2FkUHJvZ3Jlc3NCYXIsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTG9hZFByb2dyZXNzQmFyKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIExvYWRQcm9ncmVzc0Jhcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnBhcnRFbHNfID0gW107XG4gICAgX3RoaXMub24ocGxheWVyLCAncHJvZ3Jlc3MnLCBfdGhpcy51cGRhdGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIExvYWRQcm9ncmVzc0Jhci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxvYWQtcHJvZ3Jlc3MnLFxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PHNwYW4+JyArIHRoaXMubG9jYWxpemUoJ0xvYWRlZCcpICsgJzwvc3Bhbj46IDAlPC9zcGFuPidcbiAgICB9KTtcbiAgfTtcblxuICBMb2FkUHJvZ3Jlc3NCYXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHRoaXMucGFydEVsc18gPSBudWxsO1xuXG4gICAgX0NvbXBvbmVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgcHJvZ3Jlc3MgYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgcHJvZ3Jlc3NgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjcHJvZ3Jlc3NcbiAgICovXG5cblxuICBMb2FkUHJvZ3Jlc3NCYXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIHZhciBidWZmZXJlZCA9IHRoaXMucGxheWVyXy5idWZmZXJlZCgpO1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuICAgIHZhciBidWZmZXJlZEVuZCA9IHRoaXMucGxheWVyXy5idWZmZXJlZEVuZCgpO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucGFydEVsc187XG5cbiAgICAvLyBnZXQgdGhlIHBlcmNlbnQgd2lkdGggb2YgYSB0aW1lIGNvbXBhcmVkIHRvIHRoZSB0b3RhbCBlbmRcbiAgICB2YXIgcGVyY2VudGlmeSA9IGZ1bmN0aW9uIHBlcmNlbnRpZnkodGltZSwgZW5kKSB7XG4gICAgICAvLyBubyBOYU5cbiAgICAgIHZhciBwZXJjZW50ID0gdGltZSAvIGVuZCB8fCAwO1xuXG4gICAgICByZXR1cm4gKHBlcmNlbnQgPj0gMSA/IDEgOiBwZXJjZW50KSAqIDEwMCArICclJztcbiAgICB9O1xuXG4gICAgLy8gdXBkYXRlIHRoZSB3aWR0aCBvZiB0aGUgcHJvZ3Jlc3MgYmFyXG4gICAgdGhpcy5lbF8uc3R5bGUud2lkdGggPSBwZXJjZW50aWZ5KGJ1ZmZlcmVkRW5kLCBkdXJhdGlvbik7XG5cbiAgICAvLyBhZGQgY2hpbGQgZWxlbWVudHMgdG8gcmVwcmVzZW50IHRoZSBpbmRpdmlkdWFsIGJ1ZmZlcmVkIHRpbWUgcmFuZ2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0YXJ0ID0gYnVmZmVyZWQuc3RhcnQoaSk7XG4gICAgICB2YXIgZW5kID0gYnVmZmVyZWQuZW5kKGkpO1xuICAgICAgdmFyIHBhcnQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgaWYgKCFwYXJ0KSB7XG4gICAgICAgIHBhcnQgPSB0aGlzLmVsXy5hcHBlbmRDaGlsZChjcmVhdGVFbCgpKTtcbiAgICAgICAgY2hpbGRyZW5baV0gPSBwYXJ0O1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdGhlIHBlcmNlbnQgYmFzZWQgb24gdGhlIHdpZHRoIG9mIHRoZSBwcm9ncmVzcyBiYXIgKGJ1ZmZlcmVkRW5kKVxuICAgICAgcGFydC5zdHlsZS5sZWZ0ID0gcGVyY2VudGlmeShzdGFydCwgYnVmZmVyZWRFbmQpO1xuICAgICAgcGFydC5zdHlsZS53aWR0aCA9IHBlcmNlbnRpZnkoZW5kIC0gc3RhcnQsIGJ1ZmZlcmVkRW5kKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgdW51c2VkIGJ1ZmZlcmVkIHJhbmdlIGVsZW1lbnRzXG4gICAgZm9yICh2YXIgX2kgPSBjaGlsZHJlbi5sZW5ndGg7IF9pID4gYnVmZmVyZWQubGVuZ3RoOyBfaS0tKSB7XG4gICAgICB0aGlzLmVsXy5yZW1vdmVDaGlsZChjaGlsZHJlbltfaSAtIDFdKTtcbiAgICB9XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gYnVmZmVyZWQubGVuZ3RoO1xuICB9O1xuXG4gIHJldHVybiBMb2FkUHJvZ3Jlc3NCYXI7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTG9hZFByb2dyZXNzQmFyJywgTG9hZFByb2dyZXNzQmFyKTtcblxuLyoqXG4gKiBAZmlsZSB0aW1lLXRvb2x0aXAuanNcbiAqL1xuLyoqXG4gKiBUaW1lIHRvb2x0aXBzIGRpc3BsYXkgYSB0aW1lIGFib3ZlIHRoZSBwcm9ncmVzcyBiYXIuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFRpbWVUb29sdGlwID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVGltZVRvb2x0aXAsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRpbWVUb29sdGlwKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVUb29sdGlwKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgdGltZSB0b29sdGlwIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIFRpbWVUb29sdGlwLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdGltZS10b29sdGlwJ1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgdGltZSB0b29sdGlwIHJlbGF0aXZlIHRvIHRoZSBgU2Vla0JhcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZWVrQmFyUmVjdFxuICAgKiAgICAgICAgVGhlIGBDbGllbnRSZWN0YCBmb3IgdGhlIHtAbGluayBTZWVrQmFyfSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vla0JhclBvaW50XG4gICAqICAgICAgICBBIG51bWJlciBmcm9tIDAgdG8gMSwgcmVwcmVzZW50aW5nIGEgaG9yaXpvbnRhbCByZWZlcmVuY2UgcG9pbnRcbiAgICogICAgICAgIGZyb20gdGhlIGxlZnQgZWRnZSBvZiB0aGUge0BsaW5rIFNlZWtCYXJ9XG4gICAqL1xuXG5cbiAgVGltZVRvb2x0aXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVrQmFyUmVjdCwgc2Vla0JhclBvaW50LCBjb250ZW50KSB7XG4gICAgdmFyIHRvb2x0aXBSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMuZWxfKTtcbiAgICB2YXIgcGxheWVyUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLnBsYXllcl8uZWwoKSk7XG4gICAgdmFyIHNlZWtCYXJQb2ludFB4ID0gc2Vla0JhclJlY3Qud2lkdGggKiBzZWVrQmFyUG9pbnQ7XG5cbiAgICAvLyBkbyBub3RoaW5nIGlmIGVpdGhlciByZWN0IGlzbid0IGF2YWlsYWJsZVxuICAgIC8vIGZvciBleGFtcGxlLCBpZiB0aGUgcGxheWVyIGlzbid0IGluIHRoZSBET00gZm9yIHRlc3RpbmdcbiAgICBpZiAoIXBsYXllclJlY3QgfHwgIXRvb2x0aXBSZWN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyB0aGUgc3BhY2UgbGVmdCBvZiB0aGUgYHNlZWtCYXJQb2ludGAgYXZhaWxhYmxlIHdpdGhpbiB0aGUgYm91bmRzXG4gICAgLy8gb2YgdGhlIHBsYXllci4gV2UgY2FsY3VsYXRlIGFueSBnYXAgYmV0d2VlbiB0aGUgbGVmdCBlZGdlIG9mIHRoZSBwbGF5ZXJcbiAgICAvLyBhbmQgdGhlIGxlZnQgZWRnZSBvZiB0aGUgYFNlZWtCYXJgIGFuZCBhZGQgdGhlIG51bWJlciBvZiBwaXhlbHMgaW4gdGhlXG4gICAgLy8gYFNlZWtCYXJgIGJlZm9yZSBoaXR0aW5nIHRoZSBgc2Vla0JhclBvaW50YFxuICAgIHZhciBzcGFjZUxlZnRPZlBvaW50ID0gc2Vla0JhclJlY3QubGVmdCAtIHBsYXllclJlY3QubGVmdCArIHNlZWtCYXJQb2ludFB4O1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgc3BhY2UgcmlnaHQgb2YgdGhlIGBzZWVrQmFyUG9pbnRgIGF2YWlsYWJsZSB3aXRoaW4gdGhlIGJvdW5kc1xuICAgIC8vIG9mIHRoZSBwbGF5ZXIuIFdlIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHBpeGVscyBmcm9tIHRoZSBgc2Vla0JhclBvaW50YFxuICAgIC8vIHRvIHRoZSByaWdodCBlZGdlIG9mIHRoZSBgU2Vla0JhcmAgYW5kIGFkZCB0byB0aGF0IGFueSBnYXAgYmV0d2VlbiB0aGVcbiAgICAvLyByaWdodCBlZGdlIG9mIHRoZSBgU2Vla0JhcmAgYW5kIHRoZSBwbGF5ZXIuXG4gICAgdmFyIHNwYWNlUmlnaHRPZlBvaW50ID0gc2Vla0JhclJlY3Qud2lkdGggLSBzZWVrQmFyUG9pbnRQeCArIChwbGF5ZXJSZWN0LnJpZ2h0IC0gc2Vla0JhclJlY3QucmlnaHQpO1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgbnVtYmVyIG9mIHBpeGVscyBieSB3aGljaCB0aGUgdG9vbHRpcCB3aWxsIG5lZWQgdG8gYmUgcHVsbGVkXG4gICAgLy8gZnVydGhlciB0byB0aGUgcmlnaHQgdG8gY2VudGVyIGl0IG92ZXIgdGhlIGBzZWVrQmFyUG9pbnRgLlxuICAgIHZhciBwdWxsVG9vbHRpcEJ5ID0gdG9vbHRpcFJlY3Qud2lkdGggLyAyO1xuXG4gICAgLy8gQWRqdXN0IHRoZSBgcHVsbFRvb2x0aXBCeWAgZGlzdGFuY2UgdG8gdGhlIGxlZnQgb3IgcmlnaHQgZGVwZW5kaW5nIG9uXG4gICAgLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHNwYWNlIGNhbGN1bGF0aW9ucyBhYm92ZS5cbiAgICBpZiAoc3BhY2VMZWZ0T2ZQb2ludCA8IHB1bGxUb29sdGlwQnkpIHtcbiAgICAgIHB1bGxUb29sdGlwQnkgKz0gcHVsbFRvb2x0aXBCeSAtIHNwYWNlTGVmdE9mUG9pbnQ7XG4gICAgfSBlbHNlIGlmIChzcGFjZVJpZ2h0T2ZQb2ludCA8IHB1bGxUb29sdGlwQnkpIHtcbiAgICAgIHB1bGxUb29sdGlwQnkgPSBzcGFjZVJpZ2h0T2ZQb2ludDtcbiAgICB9XG5cbiAgICAvLyBEdWUgdG8gdGhlIGltcHJlY2lzaW9uIG9mIGRlY2ltYWwvcmF0aW8gYmFzZWQgY2FsY3VsYXRpb25zIGFuZCB2YXJ5aW5nXG4gICAgLy8gcm91bmRpbmcgYmVoYXZpb3JzLCB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgdGhlIHNwYWNpbmcgYWRqdXN0bWVudCBpcyBvZmZcbiAgICAvLyBieSBhIHBpeGVsIG9yIHR3by4gVGhpcyBhZGRzIGluc3VyYW5jZSB0byB0aGVzZSBjYWxjdWxhdGlvbnMuXG4gICAgaWYgKHB1bGxUb29sdGlwQnkgPCAwKSB7XG4gICAgICBwdWxsVG9vbHRpcEJ5ID0gMDtcbiAgICB9IGVsc2UgaWYgKHB1bGxUb29sdGlwQnkgPiB0b29sdGlwUmVjdC53aWR0aCkge1xuICAgICAgcHVsbFRvb2x0aXBCeSA9IHRvb2x0aXBSZWN0LndpZHRoO1xuICAgIH1cblxuICAgIHRoaXMuZWxfLnN0eWxlLnJpZ2h0ID0gJy0nICsgcHVsbFRvb2x0aXBCeSArICdweCc7XG4gICAgdGV4dENvbnRlbnQodGhpcy5lbF8sIGNvbnRlbnQpO1xuICB9O1xuXG4gIHJldHVybiBUaW1lVG9vbHRpcDtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUaW1lVG9vbHRpcCcsIFRpbWVUb29sdGlwKTtcblxuLyoqXG4gKiBAZmlsZSBwbGF5LXByb2dyZXNzLWJhci5qc1xuICovXG4vKipcbiAqIFVzZWQgYnkge0BsaW5rIFNlZWtCYXJ9IHRvIGRpc3BsYXkgbWVkaWEgcGxheWJhY2sgcHJvZ3Jlc3MgYXMgcGFydCBvZiB0aGVcbiAqIHtAbGluayBQcm9ncmVzc0NvbnRyb2x9LlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBQbGF5UHJvZ3Jlc3NCYXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhQbGF5UHJvZ3Jlc3NCYXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFBsYXlQcm9ncmVzc0JhcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5UHJvZ3Jlc3NCYXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSB0aGUgRE9NIGVsZW1lbnQgZm9yIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIFBsYXlQcm9ncmVzc0Jhci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXBsYXktcHJvZ3Jlc3MgdmpzLXNsaWRlci1iYXInLFxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PHNwYW4+JyArIHRoaXMubG9jYWxpemUoJ1Byb2dyZXNzJykgKyAnPC9zcGFuPjogMCU8L3NwYW4+J1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyB1cGRhdGVzIHRvIGl0cyBvd24gRE9NIGFzIHdlbGwgYXMgdGhlIERPTSBvZiBpdHNcbiAgICoge0BsaW5rIFRpbWVUb29sdGlwfSBjaGlsZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlZWtCYXJSZWN0XG4gICAqICAgICAgICBUaGUgYENsaWVudFJlY3RgIGZvciB0aGUge0BsaW5rIFNlZWtCYXJ9IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWVrQmFyUG9pbnRcbiAgICogICAgICAgIEEgbnVtYmVyIGZyb20gMCB0byAxLCByZXByZXNlbnRpbmcgYSBob3Jpem9udGFsIHJlZmVyZW5jZSBwb2ludFxuICAgKiAgICAgICAgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZSB7QGxpbmsgU2Vla0Jhcn1cbiAgICovXG5cblxuICBQbGF5UHJvZ3Jlc3NCYXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVrQmFyUmVjdCwgc2Vla0JhclBvaW50KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBleGlzdGluZyByQUYgSUQsIGNhbmNlbCBpdCBzbyB3ZSBkb24ndCBvdmVyLXF1ZXVlLlxuICAgIGlmICh0aGlzLnJhZklkXykge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkXyk7XG4gICAgfVxuXG4gICAgdGhpcy5yYWZJZF8gPSB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGltZSA9IF90aGlzMi5wbGF5ZXJfLnNjcnViYmluZygpID8gX3RoaXMyLnBsYXllcl8uZ2V0Q2FjaGUoKS5jdXJyZW50VGltZSA6IF90aGlzMi5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG5cbiAgICAgIHZhciBjb250ZW50ID0gZm9ybWF0VGltZSh0aW1lLCBfdGhpczIucGxheWVyXy5kdXJhdGlvbigpKTtcbiAgICAgIHZhciB0aW1lVG9vbHRpcCA9IF90aGlzMi5nZXRDaGlsZCgndGltZVRvb2x0aXAnKTtcblxuICAgICAgaWYgKHRpbWVUb29sdGlwKSB7XG4gICAgICAgIHRpbWVUb29sdGlwLnVwZGF0ZShzZWVrQmFyUmVjdCwgc2Vla0JhclBvaW50LCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gUGxheVByb2dyZXNzQmFyO1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3Ige0BsaW5rIFBsYXlQcm9ncmVzc0Jhcn0uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5QbGF5UHJvZ3Jlc3NCYXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogW11cbn07XG5cbi8vIFRpbWUgdG9vbHRpcHMgc2hvdWxkIG5vdCBiZSBhZGRlZCB0byBhIHBsYXllciBvbiBtb2JpbGUgZGV2aWNlcyBvciBJRThcbmlmICgoIUlFX1ZFUlNJT04gfHwgSUVfVkVSU0lPTiA+IDgpICYmICFJU19JT1MgJiYgIUlTX0FORFJPSUQpIHtcbiAgUGxheVByb2dyZXNzQmFyLnByb3RvdHlwZS5vcHRpb25zXy5jaGlsZHJlbi5wdXNoKCd0aW1lVG9vbHRpcCcpO1xufVxuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXlQcm9ncmVzc0JhcicsIFBsYXlQcm9ncmVzc0Jhcik7XG5cbi8qKlxuICogQGZpbGUgbW91c2UtdGltZS1kaXNwbGF5LmpzXG4gKi9cbi8qKlxuICogVGhlIHtAbGluayBNb3VzZVRpbWVEaXNwbGF5fSBjb21wb25lbnQgdHJhY2tzIG1vdXNlIG1vdmVtZW50IG92ZXIgdGhlXG4gKiB7QGxpbmsgUHJvZ3Jlc3NDb250cm9sfS4gSXQgZGlzcGxheXMgYW4gaW5kaWNhdG9yIGFuZCBhIHtAbGluayBUaW1lVG9vbHRpcH1cbiAqIGluZGljYXRpbmcgdGhlIHRpbWUgd2hpY2ggaXMgcmVwcmVzZW50ZWQgYnkgYSBnaXZlbiBwb2ludCBpbiB0aGVcbiAqIHtAbGluayBQcm9ncmVzc0NvbnRyb2x9LlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBNb3VzZVRpbWVEaXNwbGF5ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTW91c2VUaW1lRGlzcGxheSwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIHtAbGluayBQbGF5ZXJ9IHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBNb3VzZVRpbWVEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1vdXNlVGltZURpc3BsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGUgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy51cGRhdGUpLCAyNSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgRE9NIGVsZW1lbnQgZm9yIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBNb3VzZVRpbWVEaXNwbGF5LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbW91c2UtZGlzcGxheSdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogRW5xdWV1ZXMgdXBkYXRlcyB0byBpdHMgb3duIERPTSBhcyB3ZWxsIGFzIHRoZSBET00gb2YgaXRzXG4gICAqIHtAbGluayBUaW1lVG9vbHRpcH0gY2hpbGQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZWVrQmFyUmVjdFxuICAgKiAgICAgICAgVGhlIGBDbGllbnRSZWN0YCBmb3IgdGhlIHtAbGluayBTZWVrQmFyfSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vla0JhclBvaW50XG4gICAqICAgICAgICBBIG51bWJlciBmcm9tIDAgdG8gMSwgcmVwcmVzZW50aW5nIGEgaG9yaXpvbnRhbCByZWZlcmVuY2UgcG9pbnRcbiAgICogICAgICAgIGZyb20gdGhlIGxlZnQgZWRnZSBvZiB0aGUge0BsaW5rIFNlZWtCYXJ9XG4gICAqL1xuXG5cbiAgTW91c2VUaW1lRGlzcGxheS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNlZWtCYXJSZWN0LCBzZWVrQmFyUG9pbnQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHJBRiBJRCwgY2FuY2VsIGl0IHNvIHdlIGRvbid0IG92ZXItcXVldWUuXG4gICAgaWYgKHRoaXMucmFmSWRfKSB7XG4gICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWRfKTtcbiAgICB9XG5cbiAgICB0aGlzLnJhZklkXyA9IHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkdXJhdGlvbiA9IF90aGlzMi5wbGF5ZXJfLmR1cmF0aW9uKCk7XG4gICAgICB2YXIgY29udGVudCA9IGZvcm1hdFRpbWUoc2Vla0JhclBvaW50ICogZHVyYXRpb24sIGR1cmF0aW9uKTtcblxuICAgICAgX3RoaXMyLmVsXy5zdHlsZS5sZWZ0ID0gc2Vla0JhclJlY3Qud2lkdGggKiBzZWVrQmFyUG9pbnQgKyAncHgnO1xuICAgICAgX3RoaXMyLmdldENoaWxkKCd0aW1lVG9vbHRpcCcpLnVwZGF0ZShzZWVrQmFyUmVjdCwgc2Vla0JhclBvaW50LCBjb250ZW50KTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTW91c2VUaW1lRGlzcGxheTtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGBNb3VzZVRpbWVEaXNwbGF5YFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuTW91c2VUaW1lRGlzcGxheS5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ3RpbWVUb29sdGlwJ11cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTW91c2VUaW1lRGlzcGxheScsIE1vdXNlVGltZURpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIHNlZWstYmFyLmpzXG4gKi9cbi8vIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB0aGUgYHN0ZXAqYCBmdW5jdGlvbnMgbW92ZSB0aGUgdGltZWxpbmUuXG52YXIgU1RFUF9TRUNPTkRTID0gNTtcblxuLy8gVGhlIGludGVydmFsIGF0IHdoaWNoIHRoZSBiYXIgc2hvdWxkIHVwZGF0ZSBhcyBpdCBwcm9ncmVzc2VzLlxudmFyIFVQREFURV9SRUZSRVNIX0lOVEVSVkFMID0gMzA7XG5cbi8qKlxuICogU2VlayBiYXIgYW5kIGNvbnRhaW5lciBmb3IgdGhlIHByb2dyZXNzIGJhcnMuIFVzZXMge0BsaW5rIFBsYXlQcm9ncmVzc0Jhcn1cbiAqIGFzIGl0cyBgYmFyYC5cbiAqXG4gKiBAZXh0ZW5kcyBTbGlkZXJcbiAqL1xuXG52YXIgU2Vla0JhciA9IGZ1bmN0aW9uIChfU2xpZGVyKSB7XG4gIGluaGVyaXRzKFNlZWtCYXIsIF9TbGlkZXIpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gU2Vla0JhcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTZWVrQmFyKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1NsaWRlci5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudXBkYXRlID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMudXBkYXRlKSwgVVBEQVRFX1JFRlJFU0hfSU5URVJWQUwpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAndGltZXVwZGF0ZScsIF90aGlzLnVwZGF0ZSk7XG4gICAgX3RoaXMub24ocGxheWVyLCAnZW5kZWQnLCBfdGhpcy5oYW5kbGVFbmRlZCk7XG5cbiAgICAvLyB3aGVuIHBsYXlpbmcsIGxldCdzIGVuc3VyZSB3ZSBzbW9vdGhseSB1cGRhdGUgdGhlIHBsYXkgcHJvZ3Jlc3MgYmFyXG4gICAgLy8gdmlhIGFuIGludGVydmFsXG4gICAgX3RoaXMudXBkYXRlSW50ZXJ2YWwgPSBudWxsO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCBbJ3BsYXlpbmcnXSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuY2xlYXJJbnRlcnZhbChfdGhpcy51cGRhdGVJbnRlcnZhbCk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZUludGVydmFsID0gX3RoaXMuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIFVQREFURV9SRUZSRVNIX0lOVEVSVkFMKTtcbiAgICB9KTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgWydlbmRlZCcsICdwYXVzZScsICd3YWl0aW5nJ10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmNsZWFySW50ZXJ2YWwoX3RoaXMudXBkYXRlSW50ZXJ2YWwpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCBbJ3RpbWV1cGRhdGUnLCAnZW5kZWQnXSwgX3RoaXMudXBkYXRlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHJldHVybiBfU2xpZGVyLnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcHJvZ3Jlc3MtaG9sZGVyJ1xuICAgIH0sIHtcbiAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5sb2NhbGl6ZSgnUHJvZ3Jlc3MgQmFyJylcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB1cGRhdGVzIHRoZSBwbGF5IHByb2dyZXNzIGJhciBhbmQgYWNjZXNzaWJsaXR5XG4gICAqIGF0dHJpYnV0ZXMgdG8gd2hhdGV2ZXIgaXMgcGFzc2VkIGluLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFRpbWVcbiAgICogICAgICAgIFRoZSBjdXJyZW50VGltZSB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciBhY2Nlc3NpYmxpdHlcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBlcmNlbnRcbiAgICogICAgICAgIFRoZSBwZXJjZW50YWdlIGFzIGEgZGVjaW1hbCB0aGF0IHRoZSBiYXIgc2hvdWxkIGJlIGZpbGxlZCBmcm9tIDAtMS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS51cGRhdGVfID0gZnVuY3Rpb24gdXBkYXRlXyhjdXJyZW50VGltZSwgcGVyY2VudCkge1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuXG4gICAgLy8gbWFjaGluZSByZWFkYWJsZSB2YWx1ZSBvZiBwcm9ncmVzcyBiYXIgKHBlcmNlbnRhZ2UgY29tcGxldGUpXG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVlbm93JywgKHBlcmNlbnQgKiAxMDApLnRvRml4ZWQoMikpO1xuXG4gICAgLy8gaHVtYW4gcmVhZGFibGUgdmFsdWUgb2YgcHJvZ3Jlc3MgYmFyICh0aW1lIGNvbXBsZXRlKVxuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZXRleHQnLCB0aGlzLmxvY2FsaXplKCdwcm9ncmVzcyBiYXIgdGltaW5nOiBjdXJyZW50VGltZT17MX0gZHVyYXRpb249ezJ9JywgW2Zvcm1hdFRpbWUoY3VycmVudFRpbWUsIGR1cmF0aW9uKSwgZm9ybWF0VGltZShkdXJhdGlvbiwgZHVyYXRpb24pXSwgJ3sxfSBvZiB7Mn0nKSk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIGBQbGF5UHJvZ3Jlc3NCYXJgLlxuICAgIHRoaXMuYmFyLnVwZGF0ZShnZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy5lbF8pLCBwZXJjZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBzZWVrIGJhcidzIFVJLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYHRpbWV1cGRhdGVgIG9yIGBlbmRlZGAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciN0aW1ldXBkYXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqICAgICAgICAgIFRoZSBjdXJyZW50IHBlcmNlbnQgYXQgYSBudW1iZXIgZnJvbSAwLTFcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICB2YXIgcGVyY2VudCA9IF9TbGlkZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy51cGRhdGVfKHRoaXMuZ2V0Q3VycmVudFRpbWVfKCksIHBlcmNlbnQpO1xuICAgIHJldHVybiBwZXJjZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIGN1cnJlbnQgdGltZSBidXQgYWxsb3dzIGZvciBzbW9vdGggc2NydWJiaW5nLFxuICAgKiB3aGVuIHBsYXllciBjYW4ndCBrZWVwIHVwLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdGltZSB2YWx1ZSB0byBkaXNwbGF5XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuZ2V0Q3VycmVudFRpbWVfID0gZnVuY3Rpb24gZ2V0Q3VycmVudFRpbWVfKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXllcl8uc2NydWJiaW5nKCkgPyB0aGlzLnBsYXllcl8uZ2V0Q2FjaGUoKS5jdXJyZW50VGltZSA6IHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXZSB3YW50IHRoZSBzZWVrIGJhciB0byBiZSBmdWxsIG9uIGVuZGVkXG4gICAqIG5vIG1hdHRlciB3aGF0IHRoZSBhY3R1YWwgaW50ZXJuYWwgdmFsdWVzIGFyZS4gc28gd2UgZm9yY2UgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgdGltZXVwZGF0ZWAgb3IgYGVuZGVkYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2VuZGVkXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlRW5kZWQgPSBmdW5jdGlvbiBoYW5kbGVFbmRlZChldmVudCkge1xuICAgIHRoaXMudXBkYXRlXyh0aGlzLnBsYXllcl8uZHVyYXRpb24oKSwgMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGVyY2VudGFnZSBvZiBtZWRpYSBwbGF5ZWQgc28gZmFyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHBlcmNlbnRhZ2Ugb2YgbWVkaWEgcGxheWVkIHNvIGZhciAoMCB0byAxKS5cbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5nZXRQZXJjZW50ID0gZnVuY3Rpb24gZ2V0UGVyY2VudCgpIHtcbiAgICB2YXIgcGVyY2VudCA9IHRoaXMuZ2V0Q3VycmVudFRpbWVfKCkgLyB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcblxuICAgIHJldHVybiBwZXJjZW50ID49IDEgPyAxIDogcGVyY2VudDtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIGRvd24gb24gc2VlayBiYXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgbW91c2Vkb3duYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vkb3duXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG4gICAgaWYgKCFpc1NpbmdsZUxlZnRDbGljayhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnBsYXllcl8uc2NydWJiaW5nKHRydWUpO1xuXG4gICAgdGhpcy52aWRlb1dhc1BsYXlpbmcgPSAhdGhpcy5wbGF5ZXJfLnBhdXNlZCgpO1xuICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xuXG4gICAgX1NsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duLmNhbGwodGhpcywgZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgbW92ZSBvbiBzZWVrIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZW1vdmVgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZW1vdmVcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICBpZiAoIWlzU2luZ2xlTGVmdENsaWNrKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXdUaW1lID0gdGhpcy5jYWxjdWxhdGVEaXN0YW5jZShldmVudCkgKiB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcblxuICAgIC8vIERvbid0IGxldCB2aWRlbyBlbmQgd2hpbGUgc2NydWJiaW5nLlxuICAgIGlmIChuZXdUaW1lID09PSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSkge1xuICAgICAgbmV3VGltZSA9IG5ld1RpbWUgLSAwLjE7XG4gICAgfVxuXG4gICAgLy8gU2V0IG5ldyB0aW1lICh0ZWxsIHBsYXllciB0byBzZWVrIHRvIG5ldyB0aW1lKVxuICAgIHRoaXMucGxheWVyXy5jdXJyZW50VGltZShuZXdUaW1lKTtcbiAgfTtcblxuICBTZWVrQmFyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgX1NsaWRlci5wcm90b3R5cGUuZW5hYmxlLmNhbGwodGhpcyk7XG4gICAgdmFyIG1vdXNlVGltZURpc3BsYXkgPSB0aGlzLmdldENoaWxkKCdtb3VzZVRpbWVEaXNwbGF5Jyk7XG5cbiAgICBpZiAoIW1vdXNlVGltZURpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtb3VzZVRpbWVEaXNwbGF5LnNob3coKTtcbiAgfTtcblxuICBTZWVrQmFyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBfU2xpZGVyLnByb3RvdHlwZS5kaXNhYmxlLmNhbGwodGhpcyk7XG4gICAgdmFyIG1vdXNlVGltZURpc3BsYXkgPSB0aGlzLmdldENoaWxkKCdtb3VzZVRpbWVEaXNwbGF5Jyk7XG5cbiAgICBpZiAoIW1vdXNlVGltZURpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtb3VzZVRpbWVEaXNwbGF5LmhpZGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIHVwIG9uIHNlZWsgYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYG1vdXNldXBgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZXVwXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoZXZlbnQpIHtcbiAgICBfU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgdGhpcy5wbGF5ZXJfLnNjcnViYmluZyhmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIHRpbWV1cGRhdGUgYmVjYXVzZSB3ZSdyZSBkb25lIHNlZWtpbmcgYW5kIHRoZSB0aW1lIGhhcyBjaGFuZ2VkLlxuICAgICAqIFRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgaWYgdGhlIHBsYXllciBpcyBwYXVzZWQgdG8gdGltZSB0aGUgdGltZSBkaXNwbGF5cy5cbiAgICAgKlxuICAgICAqIEBldmVudCBUZWNoI3RpbWV1cGRhdGVcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy5wbGF5ZXJfLnRyaWdnZXIoeyB0eXBlOiAndGltZXVwZGF0ZScsIHRhcmdldDogdGhpcywgbWFudWFsbHlUcmlnZ2VyZWQ6IHRydWUgfSk7XG4gICAgaWYgKHRoaXMudmlkZW9XYXNQbGF5aW5nKSB7XG4gICAgICBzaWxlbmNlUHJvbWlzZSh0aGlzLnBsYXllcl8ucGxheSgpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgbW9yZSBxdWlja2x5IGZhc3QgZm9yd2FyZCBmb3Iga2V5Ym9hcmQtb25seSB1c2Vyc1xuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLnN0ZXBGb3J3YXJkID0gZnVuY3Rpb24gc3RlcEZvcndhcmQoKSB7XG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpICsgU1RFUF9TRUNPTkRTKTtcbiAgfTtcblxuICAvKipcbiAgICogTW92ZSBtb3JlIHF1aWNrbHkgcmV3aW5kIGZvciBrZXlib2FyZC1vbmx5IHVzZXJzXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuc3RlcEJhY2sgPSBmdW5jdGlvbiBzdGVwQmFjaygpIHtcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUodGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCkgLSBTVEVQX1NFQ09ORFMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgcGxheWVyXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBlbnRlciBvciBzcGFjZSBpcyB1c2VkIG9uIHRoZSBzZWVrYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAqXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlQWN0aW9uID0gZnVuY3Rpb24gaGFuZGxlQWN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGlzIFNlZWtCYXIgaGFzIGZvY3VzIGFuZCBhIGtleSBnZXRzIHByZXNzZWQgZG93bi4gQnlcbiAgICogZGVmYXVsdCBpdCB3aWxsIGNhbGwgYHRoaXMuaGFuZGxlQWN0aW9uYCB3aGVuIHRoZSBrZXkgaXMgc3BhY2Ugb3IgZW50ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuXG4gICAgLy8gU3VwcG9ydCBTcGFjZSAoMzIpIG9yIEVudGVyICgxMykga2V5IG9wZXJhdGlvbiB0byBmaXJlIGEgY2xpY2sgZXZlbnRcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDMyIHx8IGV2ZW50LndoaWNoID09PSAxMykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuaGFuZGxlQWN0aW9uKGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKF9TbGlkZXIucHJvdG90eXBlLmhhbmRsZUtleVByZXNzKSB7XG5cbiAgICAgIC8vIFBhc3Mga2V5cHJlc3MgaGFuZGxpbmcgdXAgZm9yIHVuc3VwcG9ydGVkIGtleXNcbiAgICAgIF9TbGlkZXIucHJvdG90eXBlLmhhbmRsZUtleVByZXNzLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU2Vla0Jhcjtcbn0oU2xpZGVyKTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBgU2Vla0JhcmBcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cblNlZWtCYXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWydsb2FkUHJvZ3Jlc3NCYXInLCAncGxheVByb2dyZXNzQmFyJ10sXG4gIGJhck5hbWU6ICdwbGF5UHJvZ3Jlc3NCYXInXG59O1xuXG4vLyBNb3VzZVRpbWVEaXNwbGF5IHRvb2x0aXBzIHNob3VsZCBub3QgYmUgYWRkZWQgdG8gYSBwbGF5ZXIgb24gbW9iaWxlIGRldmljZXMgb3IgSUU4XG5pZiAoKCFJRV9WRVJTSU9OIHx8IElFX1ZFUlNJT04gPiA4KSAmJiAhSVNfSU9TICYmICFJU19BTkRST0lEKSB7XG4gIFNlZWtCYXIucHJvdG90eXBlLm9wdGlvbnNfLmNoaWxkcmVuLnNwbGljZSgxLCAwLCAnbW91c2VUaW1lRGlzcGxheScpO1xufVxuXG4vKipcbiAqIENhbGwgdGhlIHVwZGF0ZSBldmVudCBmb3IgdGhpcyBTbGlkZXIgd2hlbiB0aGlzIGV2ZW50IGhhcHBlbnMgb24gdGhlIHBsYXllci5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5TZWVrQmFyLnByb3RvdHlwZS5wbGF5ZXJFdmVudCA9ICd0aW1ldXBkYXRlJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTZWVrQmFyJywgU2Vla0Jhcik7XG5cbi8qKlxuICogQGZpbGUgcHJvZ3Jlc3MtY29udHJvbC5qc1xuICovXG4vKipcbiAqIFRoZSBQcm9ncmVzcyBDb250cm9sIGNvbXBvbmVudCBjb250YWlucyB0aGUgc2VlayBiYXIsIGxvYWQgcHJvZ3Jlc3MsXG4gKiBhbmQgcGxheSBwcm9ncmVzcy5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgUHJvZ3Jlc3NDb250cm9sID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUHJvZ3Jlc3NDb250cm9sLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFByb2dyZXNzQ29udHJvbChwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9ncmVzc0NvbnRyb2wpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5oYW5kbGVNb3VzZU1vdmUgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVNb3VzZU1vdmUpLCAyNSk7XG4gICAgX3RoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VTZWVrID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMuaGFuZGxlTW91c2VTZWVrKSwgMjUpO1xuXG4gICAgX3RoaXMuZW5hYmxlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcHJvZ3Jlc3MtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgYFByb2dyZXNzQ29udHJvbGAsIHRoZSBwb2ludGVyIHBvc2l0aW9uXG4gICAqIGdldHMgcGFzc2VkIGRvd24gdG8gdGhlIGBNb3VzZVRpbWVEaXNwbGF5YCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYG1vdXNlbW92ZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW4gbW91c2Vtb3ZlXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB2YXIgc2Vla0JhciA9IHRoaXMuZ2V0Q2hpbGQoJ3NlZWtCYXInKTtcbiAgICB2YXIgbW91c2VUaW1lRGlzcGxheSA9IHNlZWtCYXIuZ2V0Q2hpbGQoJ21vdXNlVGltZURpc3BsYXknKTtcbiAgICB2YXIgc2Vla0JhckVsID0gc2Vla0Jhci5lbCgpO1xuICAgIHZhciBzZWVrQmFyUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzZWVrQmFyRWwpO1xuICAgIHZhciBzZWVrQmFyUG9pbnQgPSBnZXRQb2ludGVyUG9zaXRpb24oc2Vla0JhckVsLCBldmVudCkueDtcblxuICAgIC8vIFRoZSBkZWZhdWx0IHNraW4gaGFzIGEgZ2FwIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBgU2Vla0JhcmAuIFRoaXMgbWVhbnNcbiAgICAvLyB0aGF0IGl0J3MgcG9zc2libGUgdG8gdHJpZ2dlciB0aGlzIGJlaGF2aW9yIG91dHNpZGUgdGhlIGJvdW5kYXJpZXMgb2ZcbiAgICAvLyB0aGUgYFNlZWtCYXJgLiBUaGlzIGVuc3VyZXMgd2Ugc3RheSB3aXRoaW4gaXQgYXQgYWxsIHRpbWVzLlxuICAgIGlmIChzZWVrQmFyUG9pbnQgPiAxKSB7XG4gICAgICBzZWVrQmFyUG9pbnQgPSAxO1xuICAgIH0gZWxzZSBpZiAoc2Vla0JhclBvaW50IDwgMCkge1xuICAgICAgc2Vla0JhclBvaW50ID0gMDtcbiAgICB9XG5cbiAgICBpZiAobW91c2VUaW1lRGlzcGxheSkge1xuICAgICAgbW91c2VUaW1lRGlzcGxheS51cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBIHRocm90dGxlZCB2ZXJzaW9uIG9mIHRoZSB7QGxpbmsgUHJvZ3Jlc3NDb250cm9sI2hhbmRsZU1vdXNlU2Vla30gbGlzdGVuZXIuXG4gICAqXG4gICAqIEBtZXRob2QgUHJvZ3Jlc3NDb250cm9sI3Rocm90dGxlZEhhbmRsZU1vdXNlU2Vla1xuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZW1vdmVgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVuIG1vdXNlbW92ZVxuICAgKiBAbGlzdGVuIHRvdWNobW92ZVxuICAgKi9cblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZW1vdmVgIG9yIGB0b3VjaG1vdmVgIGV2ZW50cyBvbiB0aGUgYFByb2dyZXNzQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZW1vdmVcbiAgICogQGxpc3RlbnMgdG91Y2htb3ZlXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZVNlZWsgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVNlZWsoZXZlbnQpIHtcbiAgICB2YXIgc2Vla0JhciA9IHRoaXMuZ2V0Q2hpbGQoJ3NlZWtCYXInKTtcblxuICAgIHNlZWtCYXIuaGFuZGxlTW91c2VNb3ZlKGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogQXJlIGNvbnRyb2xzIGFyZSBjdXJyZW50bHkgZW5hYmxlZCBmb3IgdGhpcyBwcm9ncmVzcyBjb250cm9sLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIHRydWUgaWYgY29udHJvbHMgYXJlIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cblxuXG4gIFByb2dyZXNzQ29udHJvbC5wcm90b3R5cGUuZW5hYmxlZCA9IGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlZF87XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc2FibGUgYWxsIGNvbnRyb2xzIG9uIHRoZSBwcm9ncmVzcyBjb250cm9sIGFuZCBpdHMgY2hpbGRyZW5cbiAgICovXG5cblxuICBQcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIHRoaXMuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLmRpc2FibGUgJiYgY2hpbGQuZGlzYWJsZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLmVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMub2ZmKFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXSwgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIHRoaXMub2ZmKHRoaXMuZWxfLCAnbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMuaGFuZGxlTW91c2VVcCgpO1xuXG4gICAgdGhpcy5hZGRDbGFzcygnZGlzYWJsZWQnKTtcblxuICAgIHRoaXMuZW5hYmxlZF8gPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIGFsbCBjb250cm9scyBvbiB0aGUgcHJvZ3Jlc3MgY29udHJvbCBhbmQgaXRzIGNoaWxkcmVuXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgdGhpcy5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQuZW5hYmxlICYmIGNoaWxkLmVuYWJsZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuZW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5vbihbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICB0aGlzLm9uKHRoaXMuZWxfLCAnbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cbiAgICB0aGlzLmVuYWJsZWRfID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudHMgb24gdGhlIGBQcm9ncmVzc0NvbnRyb2xgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vkb3duXG4gICAqIEBsaXN0ZW5zIHRvdWNoc3RhcnRcbiAgICovXG5cblxuICBQcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdGhpcy5vbihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2Vlayk7XG4gICAgdGhpcy5vbihkb2MsICd0b3VjaG1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2Vlayk7XG4gICAgdGhpcy5vbihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50cyBvbiB0aGUgYFByb2dyZXNzQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbGlzdGVucyB0b3VjaGVuZFxuICAgKiBAbGlzdGVucyBtb3VzZXVwXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gaGFuZGxlTW91c2VVcChldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZVNlZWspO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNobW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VTZWVrKTtcbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gIH07XG5cbiAgcmV0dXJuIFByb2dyZXNzQ29udHJvbDtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGBQcm9ncmVzc0NvbnRyb2xgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Qcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWydzZWVrQmFyJ11cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUHJvZ3Jlc3NDb250cm9sJywgUHJvZ3Jlc3NDb250cm9sKTtcblxuLyoqXG4gKiBAZmlsZSBmdWxsc2NyZWVuLXRvZ2dsZS5qc1xuICovXG4vKipcbiAqIFRvZ2dsZSBmdWxsc2NyZWVuIHZpZGVvXG4gKlxuICogQGV4dGVuZHMgQnV0dG9uXG4gKi9cblxudmFyIEZ1bGxzY3JlZW5Ub2dnbGUgPSBmdW5jdGlvbiAoX0J1dHRvbikge1xuICBpbmhlcml0cyhGdWxsc2NyZWVuVG9nZ2xlLCBfQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIEZ1bGxzY3JlZW5Ub2dnbGUocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRnVsbHNjcmVlblRvZ2dsZSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBfdGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIEZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWZ1bGxzY3JlZW4tY29udHJvbCAnICsgX0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGZ1bGxzY3JlZW5jaGFuZ2Ugb24gdGhlIHBsYXllciBhbmQgY2hhbmdlIGNvbnRyb2wgdGV4dCBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIHtAbGluayBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZX0gZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgKi9cblxuXG4gIEZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5pc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgdGhpcy5jb250cm9sVGV4dCgnTm9uLUZ1bGxzY3JlZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250cm9sVGV4dCgnRnVsbHNjcmVlbicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBGdWxsc2NyZWVuVG9nZ2xlYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgRnVsbHNjcmVlblRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGlmICghdGhpcy5wbGF5ZXJfLmlzRnVsbHNjcmVlbigpKSB7XG4gICAgICB0aGlzLnBsYXllcl8ucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBGdWxsc2NyZWVuVG9nZ2xlO1xufShCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYEZ1bGxzY3JlZW5Ub2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdGdWxsc2NyZWVuJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdGdWxsc2NyZWVuVG9nZ2xlJywgRnVsbHNjcmVlblRvZ2dsZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgdm9sdW1lIGNvbnRyb2wgaXMgc3VwcG9ydGVkIGFuZCBpZiBpdCBpc24ndCBoaWRlIHRoZVxuICogYENvbXBvbmVudGAgdGhhdCB3YXMgcGFzc2VkICB1c2luZyB0aGUgYHZqcy1oaWRkZW5gIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBzZWxmXG4gKiAgICAgICAgVGhlIGNvbXBvbmVudCB0aGF0IHNob3VsZCBiZSBoaWRkZW4gaWYgdm9sdW1lIGlzIHVuc3VwcG9ydGVkXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICogICAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSBwbGF5ZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY2hlY2tWb2x1bWVTdXBwb3J0ID0gZnVuY3Rpb24gY2hlY2tWb2x1bWVTdXBwb3J0KHNlbGYsIHBsYXllcikge1xuICAvLyBoaWRlIHZvbHVtZSBjb250cm9scyB3aGVuIHRoZXkncmUgbm90IHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCB0ZWNoXG4gIGlmIChwbGF5ZXIudGVjaF8gJiYgIXBsYXllci50ZWNoXy5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wpIHtcbiAgICBzZWxmLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gIH1cblxuICBzZWxmLm9uKHBsYXllciwgJ2xvYWRzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBsYXllci50ZWNoXy5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wpIHtcbiAgICAgIHNlbGYuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBmaWxlIHZvbHVtZS1sZXZlbC5qc1xuICovXG4vKipcbiAqIFNob3dzIHZvbHVtZSBsZXZlbFxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBWb2x1bWVMZXZlbCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFZvbHVtZUxldmVsLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBWb2x1bWVMZXZlbCgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWb2x1bWVMZXZlbCk7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgVm9sdW1lTGV2ZWwucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtbGV2ZWwnLFxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PC9zcGFuPidcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVm9sdW1lTGV2ZWw7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lTGV2ZWwnLCBWb2x1bWVMZXZlbCk7XG5cbi8qKlxuICogQGZpbGUgdm9sdW1lLWJhci5qc1xuICovXG4vLyBSZXF1aXJlZCBjaGlsZHJlblxuLyoqXG4gKiBUaGUgYmFyIHRoYXQgY29udGFpbnMgdGhlIHZvbHVtZSBsZXZlbCBhbmQgY2FuIGJlIGNsaWNrZWQgb24gdG8gYWRqdXN0IHRoZSBsZXZlbFxuICpcbiAqIEBleHRlbmRzIFNsaWRlclxuICovXG5cbnZhciBWb2x1bWVCYXIgPSBmdW5jdGlvbiAoX1NsaWRlcikge1xuICBpbmhlcml0cyhWb2x1bWVCYXIsIF9TbGlkZXIpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVm9sdW1lQmFyKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZvbHVtZUJhcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9TbGlkZXIuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9uKCdzbGlkZXJhY3RpdmUnLCBfdGhpcy51cGRhdGVMYXN0Vm9sdW1lXyk7XG4gICAgX3RoaXMub24ocGxheWVyLCAndm9sdW1lY2hhbmdlJywgX3RoaXMudXBkYXRlQVJJQUF0dHJpYnV0ZXMpO1xuICAgIHBsYXllci5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMudXBkYXRlQVJJQUF0dHJpYnV0ZXMoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgcmV0dXJuIF9TbGlkZXIucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtYmFyIHZqcy1zbGlkZXItYmFyJ1xuICAgIH0sIHtcbiAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5sb2NhbGl6ZSgnVm9sdW1lIExldmVsJyksXG4gICAgICAnYXJpYS1saXZlJzogJ3BvbGl0ZSdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIGRvd24gb24gdm9sdW1lIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIGlmICghaXNTaW5nbGVMZWZ0Q2xpY2soZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX1NsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duLmNhbGwodGhpcywgZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgbW92ZW1lbnQgZXZlbnRzIG9uIHRoZSB7QGxpbmsgVm9sdW1lTWVudUJ1dHRvbn0uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlbW92ZVxuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgaWYgKCFpc1NpbmdsZUxlZnRDbGljayhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNoZWNrTXV0ZWQoKTtcbiAgICB0aGlzLnBsYXllcl8udm9sdW1lKHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpKTtcbiAgfTtcblxuICAvKipcbiAgICogSWYgdGhlIHBsYXllciBpcyBtdXRlZCB1bm11dGUgaXQuXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5jaGVja011dGVkID0gZnVuY3Rpb24gY2hlY2tNdXRlZCgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLm11dGVkKCkpIHtcbiAgICAgIHRoaXMucGxheWVyXy5tdXRlZChmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgcGVyY2VudCBvZiB2b2x1bWUgbGV2ZWxcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFZvbHVtZSBsZXZlbCBwZXJjZW50IGFzIGEgZGVjaW1hbCBudW1iZXIuXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5nZXRQZXJjZW50ID0gZnVuY3Rpb24gZ2V0UGVyY2VudCgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLm11dGVkKCkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJfLnZvbHVtZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbmNyZWFzZSB2b2x1bWUgbGV2ZWwgZm9yIGtleWJvYXJkIHVzZXJzXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5zdGVwRm9yd2FyZCA9IGZ1bmN0aW9uIHN0ZXBGb3J3YXJkKCkge1xuICAgIHRoaXMuY2hlY2tNdXRlZCgpO1xuICAgIHRoaXMucGxheWVyXy52b2x1bWUodGhpcy5wbGF5ZXJfLnZvbHVtZSgpICsgMC4xKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVjcmVhc2Ugdm9sdW1lIGxldmVsIGZvciBrZXlib2FyZCB1c2Vyc1xuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUuc3RlcEJhY2sgPSBmdW5jdGlvbiBzdGVwQmFjaygpIHtcbiAgICB0aGlzLmNoZWNrTXV0ZWQoKTtcbiAgICB0aGlzLnBsYXllcl8udm9sdW1lKHRoaXMucGxheWVyXy52b2x1bWUoKSAtIDAuMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBBUklBIGFjY2Vzc2liaWxpdHkgYXR0cmlidXRlc1xuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYHZvbHVtZWNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciN2b2x1bWVjaGFuZ2VcbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLnVwZGF0ZUFSSUFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gdXBkYXRlQVJJQUF0dHJpYnV0ZXMoZXZlbnQpIHtcbiAgICB2YXIgYXJpYVZhbHVlID0gdGhpcy5wbGF5ZXJfLm11dGVkKCkgPyAwIDogdGhpcy52b2x1bWVBc1BlcmNlbnRhZ2VfKCk7XG5cbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCBhcmlhVmFsdWUpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZXRleHQnLCBhcmlhVmFsdWUgKyAnJScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBwbGF5ZXIgdm9sdW1lIGFzIGEgcGVyY2VudGFnZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUudm9sdW1lQXNQZXJjZW50YWdlXyA9IGZ1bmN0aW9uIHZvbHVtZUFzUGVyY2VudGFnZV8oKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5wbGF5ZXJfLnZvbHVtZSgpICogMTAwKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgVm9sdW1lQmFyLCBzdG9yZSB0aGUgdm9sdW1lIGFuZCBsaXN0ZW4gZm9yXG4gICAqIHRoZSBlbmQgb2YgdGhlIGRyYWcuIFdoZW4gdGhlIGRyYWcgZW5kcywgaWYgdGhlIHZvbHVtZSB3YXMgc2V0IHRvIHplcm8sXG4gICAqIHNldCBsYXN0Vm9sdW1lIHRvIHRoZSBzdG9yZWQgdm9sdW1lLlxuICAgKlxuICAgKiBAbGlzdGVucyBzbGlkZXJhY3RpdmVcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLnVwZGF0ZUxhc3RWb2x1bWVfID0gZnVuY3Rpb24gdXBkYXRlTGFzdFZvbHVtZV8oKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgdm9sdW1lQmVmb3JlRHJhZyA9IHRoaXMucGxheWVyXy52b2x1bWUoKTtcblxuICAgIHRoaXMub25lKCdzbGlkZXJpbmFjdGl2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpczIucGxheWVyXy52b2x1bWUoKSA9PT0gMCkge1xuICAgICAgICBfdGhpczIucGxheWVyXy5sYXN0Vm9sdW1lXyh2b2x1bWVCZWZvcmVEcmFnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVm9sdW1lQmFyO1xufShTbGlkZXIpO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIGBWb2x1bWVCYXJgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Wb2x1bWVCYXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWyd2b2x1bWVMZXZlbCddLFxuICBiYXJOYW1lOiAndm9sdW1lTGV2ZWwnXG59O1xuXG4vKipcbiAqIENhbGwgdGhlIHVwZGF0ZSBldmVudCBmb3IgdGhpcyBTbGlkZXIgd2hlbiB0aGlzIGV2ZW50IGhhcHBlbnMgb24gdGhlIHBsYXllci5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5Wb2x1bWVCYXIucHJvdG90eXBlLnBsYXllckV2ZW50ID0gJ3ZvbHVtZWNoYW5nZSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lQmFyJywgVm9sdW1lQmFyKTtcblxuLyoqXG4gKiBAZmlsZSB2b2x1bWUtY29udHJvbC5qc1xuICovXG4vLyBSZXF1aXJlZCBjaGlsZHJlblxuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBjb250cm9sbGluZyB0aGUgdm9sdW1lIGxldmVsXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFZvbHVtZUNvbnRyb2wgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhWb2x1bWVDb250cm9sLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFZvbHVtZUNvbnRyb2wocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZvbHVtZUNvbnRyb2wpO1xuXG4gICAgb3B0aW9ucy52ZXJ0aWNhbCA9IG9wdGlvbnMudmVydGljYWwgfHwgZmFsc2U7XG5cbiAgICAvLyBQYXNzIHRoZSB2ZXJ0aWNhbCBvcHRpb24gZG93biB0byB0aGUgVm9sdW1lQmFyIGlmXG4gICAgLy8gdGhlIFZvbHVtZUJhciBpcyB0dXJuZWQgb24uXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnZvbHVtZUJhciA9PT0gJ3VuZGVmaW5lZCcgfHwgaXNQbGFpbihvcHRpb25zLnZvbHVtZUJhcikpIHtcbiAgICAgIG9wdGlvbnMudm9sdW1lQmFyID0gb3B0aW9ucy52b2x1bWVCYXIgfHwge307XG4gICAgICBvcHRpb25zLnZvbHVtZUJhci52ZXJ0aWNhbCA9IG9wdGlvbnMudmVydGljYWw7XG4gICAgfVxuXG4gICAgLy8gaGlkZSB0aGlzIGNvbnRyb2wgaWYgdm9sdW1lIHN1cHBvcnQgaXMgbWlzc2luZ1xuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgY2hlY2tWb2x1bWVTdXBwb3J0KF90aGlzLCBwbGF5ZXIpO1xuXG4gICAgX3RoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VNb3ZlID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMuaGFuZGxlTW91c2VNb3ZlKSwgMjUpO1xuXG4gICAgX3RoaXMub24oJ21vdXNlZG93bicsIF90aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgX3RoaXMub24oJ3RvdWNoc3RhcnQnLCBfdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuXG4gICAgLy8gd2hpbGUgdGhlIHNsaWRlciBpcyBhY3RpdmUgKHRoZSBtb3VzZSBoYXMgYmVlbiBwcmVzc2VkIGRvd24gYW5kXG4gICAgLy8gaXMgZHJhZ2dpbmcpIG9yIGluIGZvY3VzIHdlIGRvIG5vdCB3YW50IHRvIGhpZGUgdGhlIFZvbHVtZUJhclxuICAgIF90aGlzLm9uKF90aGlzLnZvbHVtZUJhciwgWydmb2N1cycsICdzbGlkZXJhY3RpdmUnXSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMudm9sdW1lQmFyLmFkZENsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xuICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XG4gICAgICBfdGhpcy50cmlnZ2VyKCdzbGlkZXJhY3RpdmUnKTtcbiAgICB9KTtcblxuICAgIF90aGlzLm9uKF90aGlzLnZvbHVtZUJhciwgWydibHVyJywgJ3NsaWRlcmluYWN0aXZlJ10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnZvbHVtZUJhci5yZW1vdmVDbGFzcygndmpzLXNsaWRlci1hY3RpdmUnKTtcbiAgICAgIF90aGlzLnJlbW92ZUNsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xuICAgICAgX3RoaXMudHJpZ2dlcignc2xpZGVyaW5hY3RpdmUnKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBWb2x1bWVDb250cm9sLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHZhciBvcmllbnRhdGlvbkNsYXNzID0gJ3Zqcy12b2x1bWUtaG9yaXpvbnRhbCc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zXy52ZXJ0aWNhbCkge1xuICAgICAgb3JpZW50YXRpb25DbGFzcyA9ICd2anMtdm9sdW1lLXZlcnRpY2FsJztcbiAgICB9XG5cbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1jb250cm9sIHZqcy1jb250cm9sICcgKyBvcmllbnRhdGlvbkNsYXNzXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnRzIG9uIHRoZSBgVm9sdW1lQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cbiAgICogQGxpc3RlbnMgdG91Y2hzdGFydFxuICAgKi9cblxuXG4gIFZvbHVtZUNvbnRyb2wucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdGhpcy5vbihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vbihkb2MsICd0b3VjaG1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vbihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50cyBvbiB0aGUgYFZvbHVtZUNvbnRyb2xgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNldXBgIG9yIGB0b3VjaGVuZGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvbi5cbiAgICpcbiAgICogQGxpc3RlbnMgdG91Y2hlbmRcbiAgICogQGxpc3RlbnMgbW91c2V1cFxuICAgKi9cblxuXG4gIFZvbHVtZUNvbnRyb2wucHJvdG90eXBlLmhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGV2ZW50KSB7XG4gICAgdmFyIGRvYyA9IHRoaXMuZWxfLm93bmVyRG9jdW1lbnQ7XG5cbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vZmYoZG9jLCAndG91Y2htb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvYywgJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudHMgb24gdGhlIGBWb2x1bWVDb250cm9sYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlZG93blxuICAgKiBAbGlzdGVucyB0b3VjaHN0YXJ0XG4gICAqL1xuXG5cbiAgVm9sdW1lQ29udHJvbC5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgdGhpcy52b2x1bWVCYXIuaGFuZGxlTW91c2VNb3ZlKGV2ZW50KTtcbiAgfTtcblxuICByZXR1cm4gVm9sdW1lQ29udHJvbDtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBgVm9sdW1lQ29udHJvbGBcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cblZvbHVtZUNvbnRyb2wucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWyd2b2x1bWVCYXInXVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdWb2x1bWVDb250cm9sJywgVm9sdW1lQ29udHJvbCk7XG5cbi8qKlxuICogQGZpbGUgbXV0ZS10b2dnbGUuanNcbiAqL1xuLyoqXG4gKiBBIGJ1dHRvbiBjb21wb25lbnQgZm9yIG11dGluZyB0aGUgYXVkaW8uXG4gKlxuICogQGV4dGVuZHMgQnV0dG9uXG4gKi9cblxudmFyIE11dGVUb2dnbGUgPSBmdW5jdGlvbiAoX0J1dHRvbikge1xuICBpbmhlcml0cyhNdXRlVG9nZ2xlLCBfQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIE11dGVUb2dnbGUocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTXV0ZVRvZ2dsZSk7XG5cbiAgICAvLyBoaWRlIHRoaXMgY29udHJvbCBpZiB2b2x1bWUgc3VwcG9ydCBpcyBtaXNzaW5nXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBjaGVja1ZvbHVtZVN1cHBvcnQoX3RoaXMsIHBsYXllcik7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsIFsnbG9hZHN0YXJ0JywgJ3ZvbHVtZWNoYW5nZSddLCBfdGhpcy51cGRhdGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgTXV0ZVRvZ2dsZS5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtbXV0ZS1jb250cm9sICcgKyBfQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgTXV0ZVRvZ2dsZWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIE11dGVUb2dnbGUucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICB2YXIgdm9sID0gdGhpcy5wbGF5ZXJfLnZvbHVtZSgpO1xuICAgIHZhciBsYXN0Vm9sdW1lID0gdGhpcy5wbGF5ZXJfLmxhc3RWb2x1bWVfKCk7XG5cbiAgICBpZiAodm9sID09PSAwKSB7XG4gICAgICB2YXIgdm9sdW1lVG9TZXQgPSBsYXN0Vm9sdW1lIDwgMC4xID8gMC4xIDogbGFzdFZvbHVtZTtcblxuICAgICAgdGhpcy5wbGF5ZXJfLnZvbHVtZSh2b2x1bWVUb1NldCk7XG4gICAgICB0aGlzLnBsYXllcl8ubXV0ZWQoZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBsYXllcl8ubXV0ZWQodGhpcy5wbGF5ZXJfLm11dGVkKCkgPyBmYWxzZSA6IHRydWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBgTXV0ZVRvZ2dsZWAgYnV0dG9uIGJhc2VkIG9uIHRoZSBzdGF0ZSBvZiBgdm9sdW1lYCBhbmQgYG11dGVkYFxuICAgKiBvbiB0aGUgcGxheWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUge0BsaW5rIFBsYXllciNsb2Fkc3RhcnR9IGV2ZW50IGlmIHRoaXMgZnVuY3Rpb24gd2FzIGNhbGxlZFxuICAgKiAgICAgICAgdGhyb3VnaCBhbiBldmVudC5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2xvYWRzdGFydFxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdm9sdW1lY2hhbmdlXG4gICAqL1xuXG5cbiAgTXV0ZVRvZ2dsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XG4gICAgdGhpcy51cGRhdGVJY29uXygpO1xuICAgIHRoaXMudXBkYXRlQ29udHJvbFRleHRfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgYE11dGVUb2dnbGVgIGljb24uXG4gICAqXG4gICAqIFBvc3NpYmxlIHN0YXRlcyAoZ2l2ZW4gYGxldmVsYCB2YXJpYWJsZSBiZWxvdyk6XG4gICAqIC0gMDogY3Jvc3NlZCBvdXRcbiAgICogLSAxOiB6ZXJvIGJhcnMgb2Ygdm9sdW1lXG4gICAqIC0gMjogb25lIGJhciBvZiB2b2x1bWVcbiAgICogLSAzOiB0d28gYmFycyBvZiB2b2x1bWVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBNdXRlVG9nZ2xlLnByb3RvdHlwZS51cGRhdGVJY29uXyA9IGZ1bmN0aW9uIHVwZGF0ZUljb25fKCkge1xuICAgIHZhciB2b2wgPSB0aGlzLnBsYXllcl8udm9sdW1lKCk7XG4gICAgdmFyIGxldmVsID0gMztcblxuICAgIGlmICh2b2wgPT09IDAgfHwgdGhpcy5wbGF5ZXJfLm11dGVkKCkpIHtcbiAgICAgIGxldmVsID0gMDtcbiAgICB9IGVsc2UgaWYgKHZvbCA8IDAuMzMpIHtcbiAgICAgIGxldmVsID0gMTtcbiAgICB9IGVsc2UgaWYgKHZvbCA8IDAuNjcpIHtcbiAgICAgIGxldmVsID0gMjtcbiAgICB9XG5cbiAgICAvLyBUT0RPIGltcHJvdmUgbXV0ZWQgaWNvbiBjbGFzc2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxfLCAndmpzLXZvbC0nICsgaSk7XG4gICAgfVxuICAgIGFkZENsYXNzKHRoaXMuZWxfLCAndmpzLXZvbC0nICsgbGV2ZWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJZiBgbXV0ZWRgIGhhcyBjaGFuZ2VkIG9uIHRoZSBwbGF5ZXIsIHVwZGF0ZSB0aGUgY29udHJvbCB0ZXh0XG4gICAqIChgdGl0bGVgIGF0dHJpYnV0ZSBvbiBgdmpzLW11dGUtY29udHJvbGAgZWxlbWVudCBhbmQgY29udGVudCBvZlxuICAgKiBgdmpzLWNvbnRyb2wtdGV4dGAgZWxlbWVudCkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgTXV0ZVRvZ2dsZS5wcm90b3R5cGUudXBkYXRlQ29udHJvbFRleHRfID0gZnVuY3Rpb24gdXBkYXRlQ29udHJvbFRleHRfKCkge1xuICAgIHZhciBzb3VuZE9mZiA9IHRoaXMucGxheWVyXy5tdXRlZCgpIHx8IHRoaXMucGxheWVyXy52b2x1bWUoKSA9PT0gMDtcbiAgICB2YXIgdGV4dCA9IHNvdW5kT2ZmID8gJ1VubXV0ZScgOiAnTXV0ZSc7XG5cbiAgICBpZiAodGhpcy5jb250cm9sVGV4dCgpICE9PSB0ZXh0KSB7XG4gICAgICB0aGlzLmNvbnRyb2xUZXh0KHRleHQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTXV0ZVRvZ2dsZTtcbn0oQnV0dG9uKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBNdXRlVG9nZ2xlYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5NdXRlVG9nZ2xlLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnTXV0ZSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTXV0ZVRvZ2dsZScsIE11dGVUb2dnbGUpO1xuXG4vKipcbiAqIEBmaWxlIHZvbHVtZS1jb250cm9sLmpzXG4gKi9cbi8vIFJlcXVpcmVkIGNoaWxkcmVuXG4vKipcbiAqIEEgQ29tcG9uZW50IHRvIGNvbnRhaW4gdGhlIE11dGVUb2dnbGUgYW5kIFZvbHVtZUNvbnRyb2wgc28gdGhhdFxuICogdGhleSBjYW4gd29yayB0b2dldGhlci5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgVm9sdW1lUGFuZWwgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhWb2x1bWVQYW5lbCwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBWb2x1bWVQYW5lbChwbGF5ZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVm9sdW1lUGFuZWwpO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmlubGluZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMuaW5saW5lID0gb3B0aW9ucy5pbmxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuaW5saW5lID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBwYXNzIHRoZSBpbmxpbmUgb3B0aW9uIGRvd24gdG8gdGhlIFZvbHVtZUNvbnRyb2wgYXMgdmVydGljYWwgaWZcbiAgICAvLyB0aGUgVm9sdW1lQ29udHJvbCBpcyBvbi5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudm9sdW1lQ29udHJvbCA9PT0gJ3VuZGVmaW5lZCcgfHwgaXNQbGFpbihvcHRpb25zLnZvbHVtZUNvbnRyb2wpKSB7XG4gICAgICBvcHRpb25zLnZvbHVtZUNvbnRyb2wgPSBvcHRpb25zLnZvbHVtZUNvbnRyb2wgfHwge307XG4gICAgICBvcHRpb25zLnZvbHVtZUNvbnRyb2wudmVydGljYWwgPSAhb3B0aW9ucy5pbmxpbmU7XG4gICAgfVxuXG4gICAgLy8gaGlkZSB0aGlzIGNvbnRyb2wgaWYgdm9sdW1lIHN1cHBvcnQgaXMgbWlzc2luZ1xuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgY2hlY2tWb2x1bWVTdXBwb3J0KF90aGlzLCBwbGF5ZXIpO1xuXG4gICAgLy8gd2hpbGUgdGhlIHNsaWRlciBpcyBhY3RpdmUgKHRoZSBtb3VzZSBoYXMgYmVlbiBwcmVzc2VkIGRvd24gYW5kXG4gICAgLy8gaXMgZHJhZ2dpbmcpIHdlIGRvIG5vdCB3YW50IHRvIGhpZGUgdGhlIFZvbHVtZUJhclxuICAgIF90aGlzLm9uKF90aGlzLnZvbHVtZUNvbnRyb2wsIFsnc2xpZGVyYWN0aXZlJ10sIF90aGlzLnNsaWRlckFjdGl2ZV8pO1xuXG4gICAgX3RoaXMub24oX3RoaXMudm9sdW1lQ29udHJvbCwgWydzbGlkZXJpbmFjdGl2ZSddLCBfdGhpcy5zbGlkZXJJbmFjdGl2ZV8pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdmpzLXNsaWRlci1hY3RpdmUgY2xhc3MgdG8gdGhlIFZvbHVtZVBhbmVsXG4gICAqXG4gICAqIEBsaXN0ZW5zIFZvbHVtZUNvbnRyb2wjc2xpZGVyYWN0aXZlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVm9sdW1lUGFuZWwucHJvdG90eXBlLnNsaWRlckFjdGl2ZV8gPSBmdW5jdGlvbiBzbGlkZXJBY3RpdmVfKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdmpzLXNsaWRlci1hY3RpdmUgY2xhc3MgdG8gdGhlIFZvbHVtZVBhbmVsXG4gICAqXG4gICAqIEBsaXN0ZW5zIFZvbHVtZUNvbnRyb2wjc2xpZGVyaW5hY3RpdmVcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBWb2x1bWVQYW5lbC5wcm90b3R5cGUuc2xpZGVySW5hY3RpdmVfID0gZnVuY3Rpb24gc2xpZGVySW5hY3RpdmVfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVm9sdW1lUGFuZWwucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS1wYW5lbC1ob3Jpem9udGFsJztcblxuICAgIGlmICghdGhpcy5vcHRpb25zXy5pbmxpbmUpIHtcbiAgICAgIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS1wYW5lbC12ZXJ0aWNhbCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtcGFuZWwgdmpzLWNvbnRyb2wgJyArIG9yaWVudGF0aW9uQ2xhc3NcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVm9sdW1lUGFuZWw7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgYFZvbHVtZUNvbnRyb2xgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Wb2x1bWVQYW5lbC5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ211dGVUb2dnbGUnLCAndm9sdW1lQ29udHJvbCddXG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZVBhbmVsJywgVm9sdW1lUGFuZWwpO1xuXG4vKipcbiAqIEBmaWxlIG1lbnUuanNcbiAqL1xuLyoqXG4gKiBUaGUgTWVudSBjb21wb25lbnQgaXMgdXNlZCB0byBidWlsZCBwb3B1cCBtZW51cywgaW5jbHVkaW5nIHN1YnRpdGxlIGFuZFxuICogY2FwdGlvbnMgc2VsZWN0aW9uIG1lbnVzLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBNZW51ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTWVudSwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICB0aGUgcGxheWVyIHRoYXQgdGhpcyBjb21wb25lbnQgc2hvdWxkIGF0dGFjaCB0b1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIE1lbnUocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVudSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBfdGhpcy5tZW51QnV0dG9uXyA9IG9wdGlvbnMubWVudUJ1dHRvbjtcbiAgICB9XG5cbiAgICBfdGhpcy5mb2N1c2VkQ2hpbGRfID0gLTE7XG5cbiAgICBfdGhpcy5vbigna2V5ZG93bicsIF90aGlzLmhhbmRsZUtleVByZXNzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEge0BsaW5rIE1lbnVJdGVtfSB0byB0aGUgbWVudS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBjb21wb25lbnRcbiAgICogICAgICAgIFRoZSBuYW1lIG9yIGluc3RhbmNlIG9mIHRoZSBgTWVudUl0ZW1gIHRvIGFkZC5cbiAgICpcbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24gYWRkSXRlbShjb21wb25lbnQpIHtcbiAgICB0aGlzLmFkZENoaWxkKGNvbXBvbmVudCk7XG4gICAgY29tcG9uZW50Lm9uKCdjbGljaycsIGJpbmQodGhpcywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAvLyBVbnByZXNzIHRoZSBhc3NvY2lhdGVkIE1lbnVCdXR0b24sIGFuZCBtb3ZlIGZvY3VzIGJhY2sgdG8gaXRcbiAgICAgIGlmICh0aGlzLm1lbnVCdXR0b25fKSB7XG4gICAgICAgIHRoaXMubWVudUJ1dHRvbl8udW5wcmVzc0J1dHRvbigpO1xuXG4gICAgICAgIC8vIGRvbid0IGZvY3VzIG1lbnUgYnV0dG9uIGlmIGl0ZW0gaXMgYSBjYXB0aW9uIHNldHRpbmdzIGl0ZW1cbiAgICAgICAgLy8gYmVjYXVzZSBmb2N1cyB3aWxsIG1vdmUgZWxzZXdoZXJlIGFuZCBpdCBsb2dzIGFuIGVycm9yIG9uIElFOFxuICAgICAgICBpZiAoY29tcG9uZW50Lm5hbWUoKSAhPT0gJ0NhcHRpb25TZXR0aW5nc01lbnVJdGVtJykge1xuICAgICAgICAgIHRoaXMubWVudUJ1dHRvbl8uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgTWVudWBzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIHRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWRcbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBjb250ZW50RWxUeXBlID0gdGhpcy5vcHRpb25zXy5jb250ZW50RWxUeXBlIHx8ICd1bCc7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBjcmVhdGVFbChjb250ZW50RWxUeXBlLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbWVudS1jb250ZW50J1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250ZW50RWxfLnNldEF0dHJpYnV0ZSgncm9sZScsICdtZW51Jyk7XG5cbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBhcHBlbmQ6IHRoaXMuY29udGVudEVsXyxcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51J1xuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcblxuICAgIC8vIFByZXZlbnQgY2xpY2tzIGZyb20gYnViYmxpbmcgdXAuIE5lZWRlZCBmb3IgTWVudSBCdXR0b25zLFxuICAgIC8vIHdoZXJlIGEgY2xpY2sgb24gdGhlIHBhcmVudCBpcyBzaWduaWZpY2FudFxuICAgIG9uKGVsLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICBNZW51LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBudWxsO1xuXG4gICAgX0NvbXBvbmVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBga2V5ZG93bmAgZXZlbnQgb24gdGhpcyBtZW51LiBUaGlzIGxpc3RlbmVyIGlzIGFkZGVkIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIEEgYGtleWRvd25gIGV2ZW50IHRoYXQgaGFwcGVuZWQgb24gdGhlIG1lbnUuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG4gICAgLy8gTGVmdCBhbmQgRG93biBBcnJvd3NcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDM3IHx8IGV2ZW50LndoaWNoID09PSA0MCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc3RlcEZvcndhcmQoKTtcblxuICAgICAgLy8gVXAgYW5kIFJpZ2h0IEFycm93c1xuICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDM4IHx8IGV2ZW50LndoaWNoID09PSAzOSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc3RlcEJhY2soKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgdG8gbmV4dCAobG93ZXIpIG1lbnUgaXRlbSBmb3Iga2V5Ym9hcmQgdXNlcnMuXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuc3RlcEZvcndhcmQgPSBmdW5jdGlvbiBzdGVwRm9yd2FyZCgpIHtcbiAgICB2YXIgc3RlcENoaWxkID0gMDtcblxuICAgIGlmICh0aGlzLmZvY3VzZWRDaGlsZF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RlcENoaWxkID0gdGhpcy5mb2N1c2VkQ2hpbGRfICsgMTtcbiAgICB9XG4gICAgdGhpcy5mb2N1cyhzdGVwQ2hpbGQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIHRvIHByZXZpb3VzIChoaWdoZXIpIG1lbnUgaXRlbSBmb3Iga2V5Ym9hcmQgdXNlcnMuXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuc3RlcEJhY2sgPSBmdW5jdGlvbiBzdGVwQmFjaygpIHtcbiAgICB2YXIgc3RlcENoaWxkID0gMDtcblxuICAgIGlmICh0aGlzLmZvY3VzZWRDaGlsZF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RlcENoaWxkID0gdGhpcy5mb2N1c2VkQ2hpbGRfIC0gMTtcbiAgICB9XG4gICAgdGhpcy5mb2N1cyhzdGVwQ2hpbGQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgZm9jdXMgb24gYSB7QGxpbmsgTWVudUl0ZW19IGluIHRoZSBgTWVudWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW2l0ZW09MF1cbiAgICogICAgICAgIEluZGV4IG9mIGNoaWxkIGl0ZW0gc2V0IGZvY3VzIG9uLlxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgdmFyIGl0ZW0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCkuc2xpY2UoKTtcbiAgICB2YXIgaGF2ZVRpdGxlID0gY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkcmVuWzBdLmNsYXNzTmFtZSAmJiAvdmpzLW1lbnUtdGl0bGUvLnRlc3QoY2hpbGRyZW5bMF0uY2xhc3NOYW1lKTtcblxuICAgIGlmIChoYXZlVGl0bGUpIHtcbiAgICAgIGNoaWxkcmVuLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChpdGVtIDwgMCkge1xuICAgICAgICBpdGVtID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbSA+PSBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgaXRlbSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZm9jdXNlZENoaWxkXyA9IGl0ZW07XG5cbiAgICAgIGNoaWxkcmVuW2l0ZW1dLmVsXy5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTWVudTtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNZW51JywgTWVudSk7XG5cbi8qKlxuICogQGZpbGUgbWVudS1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBBIGBNZW51QnV0dG9uYCBjbGFzcyBmb3IgYW55IHBvcHVwIHtAbGluayBNZW51fS5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTWVudUJ1dHRvbiA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1lbnVCdXR0b24sIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTWVudUJ1dHRvbihwbGF5ZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVudUJ1dHRvbik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm1lbnVCdXR0b25fID0gbmV3IEJ1dHRvbihwbGF5ZXIsIG9wdGlvbnMpO1xuXG4gICAgX3RoaXMubWVudUJ1dHRvbl8uY29udHJvbFRleHQoX3RoaXMuY29udHJvbFRleHRfKTtcbiAgICBfdGhpcy5tZW51QnV0dG9uXy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgJ3RydWUnKTtcblxuICAgIC8vIEFkZCBidWlsZENTU0NsYXNzIHZhbHVlcyB0byB0aGUgYnV0dG9uLCBub3QgdGhlIHdyYXBwZXJcbiAgICB2YXIgYnV0dG9uQ2xhc3MgPSBCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MoKTtcblxuICAgIF90aGlzLm1lbnVCdXR0b25fLmVsXy5jbGFzc05hbWUgPSBfdGhpcy5idWlsZENTU0NsYXNzKCkgKyAnICcgKyBidXR0b25DbGFzcztcbiAgICBfdGhpcy5tZW51QnV0dG9uXy5yZW1vdmVDbGFzcygndmpzLWNvbnRyb2wnKTtcblxuICAgIF90aGlzLmFkZENoaWxkKF90aGlzLm1lbnVCdXR0b25fKTtcblxuICAgIF90aGlzLnVwZGF0ZSgpO1xuXG4gICAgX3RoaXMuZW5hYmxlZF8gPSB0cnVlO1xuXG4gICAgX3RoaXMub24oX3RoaXMubWVudUJ1dHRvbl8sICd0YXAnLCBfdGhpcy5oYW5kbGVDbGljayk7XG4gICAgX3RoaXMub24oX3RoaXMubWVudUJ1dHRvbl8sICdjbGljaycsIF90aGlzLmhhbmRsZUNsaWNrKTtcbiAgICBfdGhpcy5vbihfdGhpcy5tZW51QnV0dG9uXywgJ2ZvY3VzJywgX3RoaXMuaGFuZGxlRm9jdXMpO1xuICAgIF90aGlzLm9uKF90aGlzLm1lbnVCdXR0b25fLCAnYmx1cicsIF90aGlzLmhhbmRsZUJsdXIpO1xuXG4gICAgX3RoaXMub24oJ2tleWRvd24nLCBfdGhpcy5oYW5kbGVTdWJtZW51S2V5UHJlc3MpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIG1lbnUgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgaXRzIGl0ZW1zLlxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgbWVudSA9IHRoaXMuY3JlYXRlTWVudSgpO1xuXG4gICAgaWYgKHRoaXMubWVudSkge1xuICAgICAgdGhpcy5tZW51LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5tZW51KTtcbiAgICB9XG5cbiAgICB0aGlzLm1lbnUgPSBtZW51O1xuICAgIHRoaXMuYWRkQ2hpbGQobWVudSk7XG5cbiAgICAvKipcbiAgICAgKiBUcmFjayB0aGUgc3RhdGUgb2YgdGhlIG1lbnUgYnV0dG9uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYnV0dG9uUHJlc3NlZF8gPSBmYWxzZTtcbiAgICB0aGlzLm1lbnVCdXR0b25fLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcblxuICAgIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXMubGVuZ3RoIDw9IHRoaXMuaGlkZVRocmVzaG9sZF8pIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbWVudSBhbmQgYWRkIGFsbCBpdGVtcyB0byBpdC5cbiAgICpcbiAgICogQHJldHVybiB7TWVudX1cbiAgICogICAgICAgICBUaGUgY29uc3RydWN0ZWQgbWVudVxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmNyZWF0ZU1lbnUgPSBmdW5jdGlvbiBjcmVhdGVNZW51KCkge1xuICAgIHZhciBtZW51ID0gbmV3IE1lbnUodGhpcy5wbGF5ZXJfLCB7IG1lbnVCdXR0b246IHRoaXMgfSk7XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBtZW51IGlmIHRoZSBudW1iZXIgb2YgaXRlbXMgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoaXMgdGhyZXNob2xkLiBUaGlzIGRlZmF1bHRzXG4gICAgICogdG8gMCBhbmQgd2hlbmV2ZXIgd2UgYWRkIGl0ZW1zIHdoaWNoIGNhbiBiZSBoaWRkZW4gdG8gdGhlIG1lbnUgd2UnbGwgaW5jcmVtZW50IGl0LiBXZSBsaXN0XG4gICAgICogaXQgaGVyZSBiZWNhdXNlIGV2ZXJ5IHRpbWUgd2UgcnVuIGBjcmVhdGVNZW51YCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gPSAwO1xuXG4gICAgLy8gQWRkIGEgdGl0bGUgbGlzdCBpdGVtIHRvIHRoZSB0b3BcbiAgICBpZiAodGhpcy5vcHRpb25zXy50aXRsZSkge1xuICAgICAgdmFyIHRpdGxlID0gY3JlYXRlRWwoJ2xpJywge1xuICAgICAgICBjbGFzc05hbWU6ICd2anMtbWVudS10aXRsZScsXG4gICAgICAgIGlubmVySFRNTDogdG9UaXRsZUNhc2UodGhpcy5vcHRpb25zXy50aXRsZSksXG4gICAgICAgIHRhYkluZGV4OiAtMVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gKz0gMTtcblxuICAgICAgbWVudS5jaGlsZHJlbl8udW5zaGlmdCh0aXRsZSk7XG4gICAgICBwcmVwZW5kVG8odGl0bGUsIG1lbnUuY29udGVudEVsKCkpO1xuICAgIH1cblxuICAgIHRoaXMuaXRlbXMgPSB0aGlzLmNyZWF0ZUl0ZW1zKCk7XG5cbiAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgLy8gQWRkIG1lbnUgaXRlbXMgdG8gdGhlIG1lbnVcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtZW51LmFkZEl0ZW0odGhpcy5pdGVtc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbnU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbGlzdCBvZiBtZW51IGl0ZW1zLiBTcGVjaWZpYyB0byBlYWNoIHN1YmNsYXNzLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge307XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYE1lbnVCdXR0b25zYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkV3JhcHBlckNTU0NsYXNzKClcbiAgICB9LCB7fSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsbG93IHN1YiBjb21wb25lbnRzIHRvIHN0YWNrIENTUyBjbGFzcyBuYW1lcyBmb3IgdGhlIHdyYXBwZXIgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGNvbnN0cnVjdGVkIHdyYXBwZXIgRE9NIGBjbGFzc05hbWVgXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICB2YXIgbWVudUJ1dHRvbkNsYXNzID0gJ3Zqcy1tZW51LWJ1dHRvbic7XG5cbiAgICAvLyBJZiB0aGUgaW5saW5lIG9wdGlvbiBpcyBwYXNzZWQsIHdlIHdhbnQgdG8gdXNlIGRpZmZlcmVudCBzdHlsZXMgYWx0b2dldGhlci5cbiAgICBpZiAodGhpcy5vcHRpb25zXy5pbmxpbmUgPT09IHRydWUpIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLWlubGluZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLXBvcHVwJztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBGaXggdGhlIENTUyBzbyB0aGF0IHRoaXMgaXNuJ3QgbmVjZXNzYXJ5XG4gICAgdmFyIGJ1dHRvbkNsYXNzID0gQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzKCk7XG5cbiAgICByZXR1cm4gJ3Zqcy1tZW51LWJ1dHRvbiAnICsgbWVudUJ1dHRvbkNsYXNzICsgJyAnICsgYnV0dG9uQ2xhc3MgKyAnICcgKyBfQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICB2YXIgbWVudUJ1dHRvbkNsYXNzID0gJ3Zqcy1tZW51LWJ1dHRvbic7XG5cbiAgICAvLyBJZiB0aGUgaW5saW5lIG9wdGlvbiBpcyBwYXNzZWQsIHdlIHdhbnQgdG8gdXNlIGRpZmZlcmVudCBzdHlsZXMgYWx0b2dldGhlci5cbiAgICBpZiAodGhpcy5vcHRpb25zXy5pbmxpbmUgPT09IHRydWUpIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLWlubGluZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLXBvcHVwJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ3Zqcy1tZW51LWJ1dHRvbiAnICsgbWVudUJ1dHRvbkNsYXNzICsgJyAnICsgX0NvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBsb2NhbGl6ZWQgY29udHJvbCB0ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhY2Nlc3NpYmlsaXR5LlxuICAgKlxuICAgKiA+IE5PVEU6IFRoaXMgd2lsbCBjb21lIGZyb20gdGhlIGludGVybmFsIGBtZW51QnV0dG9uX2AgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0XVxuICAgKiAgICAgICAgQ29udHJvbCB0ZXh0IGZvciBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtlbD10aGlzLm1lbnVCdXR0b25fLmVsKCldXG4gICAqICAgICAgICBFbGVtZW50IHRvIHNldCB0aGUgdGl0bGUgb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAtIFRoZSBjb250cm9sIHRleHQgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHQgPSBmdW5jdGlvbiBjb250cm9sVGV4dCh0ZXh0KSB7XG4gICAgdmFyIGVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLm1lbnVCdXR0b25fLmVsKCk7XG5cbiAgICByZXR1cm4gdGhpcy5tZW51QnV0dG9uXy5jb250cm9sVGV4dCh0ZXh0LCBlbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGNsaWNrIG9uIGEgYE1lbnVCdXR0b25gLlxuICAgKiBTZWUge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVDbGlja30gZm9yIGluc3RhbmNlcyB3aGVyZSB0aGlzIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIC8vIFdoZW4geW91IGNsaWNrIHRoZSBidXR0b24gaXQgYWRkcyBmb2N1cywgd2hpY2ggd2lsbCBzaG93IHRoZSBtZW51LlxuICAgIC8vIFNvIHdlJ2xsIHJlbW92ZSBmb2N1cyB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGJ1dHRvbi4gRm9jdXMgaXMgbmVlZGVkXG4gICAgLy8gZm9yIHRhYiBuYXZpZ2F0aW9uLlxuXG4gICAgdGhpcy5vbmUodGhpcy5tZW51LmNvbnRlbnRFbCgpLCAnbW91c2VsZWF2ZScsIGJpbmQodGhpcywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuICAgICAgdGhpcy5lbF8uYmx1cigpO1xuICAgIH0pKTtcbiAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXykge1xuICAgICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJlc3NCdXR0b24oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZm9jdXMgdG8gdGhlIGFjdHVhbCBidXR0b24sIG5vdCB0byB0aGlzIGVsZW1lbnRcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIHRoaXMubWVudUJ1dHRvbl8uZm9jdXMoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBmb2N1cyBmcm9tIHRoZSBhY3R1YWwgYnV0dG9uLCBub3QgdGhpcyBlbGVtZW50XG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgdGhpcy5tZW51QnV0dG9uXy5ibHVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhIGBNZW51QnV0dG9uYCBnYWlucyBmb2N1cyB2aWEgYSBgZm9jdXNgIGV2ZW50LlxuICAgKiBUdXJucyBvbiBsaXN0ZW5pbmcgZm9yIGBrZXlkb3duYCBldmVudHMuIFdoZW4gdGhleSBoYXBwZW4gaXRcbiAgICogY2FsbHMgYHRoaXMuaGFuZGxlS2V5UHJlc3NgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBmb2N1c2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGZvY3VzXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlRm9jdXMgPSBmdW5jdGlvbiBoYW5kbGVGb2N1cygpIHtcbiAgICBvbihkb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBgTWVudUJ1dHRvbmAgbG9zZXMgZm9jdXMuIFR1cm5zIG9mZiB0aGUgbGlzdGVuZXIgZm9yXG4gICAqIGBrZXlkb3duYCBldmVudHMuIFdoaWNoIFN0b3BzIGB0aGlzLmhhbmRsZUtleVByZXNzYCBmcm9tIGdldHRpbmcgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBibHVyYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgYmx1clxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuICAgIG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRhYiwgZXNjYXBlLCBkb3duIGFycm93LCBhbmQgdXAgYXJyb3cga2V5cyBmb3IgYE1lbnVCdXR0b25gLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVLZXlQcmVzc30gZm9yIGluc3RhbmNlcyB3aGVyZSB0aGlzIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG5cbiAgICAvLyBFc2NhcGUgKDI3KSBrZXkgb3IgVGFiICg5KSBrZXkgdW5wcmVzcyB0aGUgJ2J1dHRvbidcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDI3IHx8IGV2ZW50LndoaWNoID09PSA5KSB7XG4gICAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXykge1xuICAgICAgICB0aGlzLnVucHJlc3NCdXR0b24oKTtcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IHByZXZlbnREZWZhdWx0IGZvciBUYWIga2V5IC0gd2Ugc3RpbGwgd2FudCB0byBsb3NlIGZvY3VzXG4gICAgICBpZiAoZXZlbnQud2hpY2ggIT09IDkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gU2V0IGZvY3VzIGJhY2sgdG8gdGhlIG1lbnUgYnV0dG9uJ3MgYnV0dG9uXG4gICAgICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLmZvY3VzKCk7XG4gICAgICB9XG4gICAgICAvLyBVcCAoMzgpIGtleSBvciBEb3duICg0MCkga2V5IHByZXNzIHRoZSAnYnV0dG9uJ1xuICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDM4IHx8IGV2ZW50LndoaWNoID09PSA0MCkge1xuICAgICAgaWYgKCF0aGlzLmJ1dHRvblByZXNzZWRfKSB7XG4gICAgICAgIHRoaXMucHJlc3NCdXR0b24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBrZXlkb3duYCBldmVudCBvbiBhIHN1Yi1tZW51LiBUaGUgbGlzdGVuZXIgZm9yIHRoaXMgaXMgYWRkZWQgaW5cbiAgICogdGhlIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgS2V5IHByZXNzIGV2ZW50XG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVTdWJtZW51S2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVTdWJtZW51S2V5UHJlc3MoZXZlbnQpIHtcblxuICAgIC8vIEVzY2FwZSAoMjcpIGtleSBvciBUYWIgKDkpIGtleSB1bnByZXNzIHRoZSAnYnV0dG9uJ1xuICAgIGlmIChldmVudC53aGljaCA9PT0gMjcgfHwgZXZlbnQud2hpY2ggPT09IDkpIHtcbiAgICAgIGlmICh0aGlzLmJ1dHRvblByZXNzZWRfKSB7XG4gICAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgcHJldmVudERlZmF1bHQgZm9yIFRhYiBrZXkgLSB3ZSBzdGlsbCB3YW50IHRvIGxvc2UgZm9jdXNcbiAgICAgIGlmIChldmVudC53aGljaCAhPT0gOSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBTZXQgZm9jdXMgYmFjayB0byB0aGUgbWVudSBidXR0b24ncyBidXR0b25cbiAgICAgICAgdGhpcy5tZW51QnV0dG9uXy5lbF8uZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1dCB0aGUgY3VycmVudCBgTWVudUJ1dHRvbmAgaW50byBhIHByZXNzZWQgc3RhdGUuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUucHJlc3NCdXR0b24gPSBmdW5jdGlvbiBwcmVzc0J1dHRvbigpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkXykge1xuICAgICAgdGhpcy5idXR0b25QcmVzc2VkXyA9IHRydWU7XG4gICAgICB0aGlzLm1lbnUubG9ja1Nob3dpbmcoKTtcbiAgICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG5cbiAgICAgIC8vIHNldCB0aGUgZm9jdXMgaW50byB0aGUgc3VibWVudSwgZXhjZXB0IG9uIGlPUyB3aGVyZSBpdCBpcyByZXN1bHRpbmcgaW5cbiAgICAgIC8vIHVuZGVzaXJlZCBzY3JvbGxpbmcgYmVoYXZpb3Igd2hlbiB0aGUgcGxheWVyIGlzIGluIGFuIGlmcmFtZVxuICAgICAgaWYgKElTX0lPUyAmJiBpc0luRnJhbWUoKSkge1xuICAgICAgICAvLyBSZXR1cm4gZWFybHkgc28gdGhhdCB0aGUgbWVudSBpc24ndCBmb2N1c2VkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tZW51LmZvY3VzKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUYWtlIHRoZSBjdXJyZW50IGBNZW51QnV0dG9uYCBvdXQgb2YgYSBwcmVzc2VkIHN0YXRlLlxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLnVucHJlc3NCdXR0b24gPSBmdW5jdGlvbiB1bnByZXNzQnV0dG9uKCkge1xuICAgIGlmICh0aGlzLmVuYWJsZWRfKSB7XG4gICAgICB0aGlzLmJ1dHRvblByZXNzZWRfID0gZmFsc2U7XG4gICAgICB0aGlzLm1lbnUudW5sb2NrU2hvd2luZygpO1xuICAgICAgdGhpcy5tZW51QnV0dG9uXy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSBgTWVudUJ1dHRvbmAuIERvbid0IGFsbG93IGl0IHRvIGJlIGNsaWNrZWQuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XG5cbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWRpc2FibGVkJyk7XG5cbiAgICB0aGlzLm1lbnVCdXR0b25fLmRpc2FibGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIHRoZSBgTWVudUJ1dHRvbmAuIEFsbG93IGl0IHRvIGJlIGNsaWNrZWQuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIHRoaXMuZW5hYmxlZF8gPSB0cnVlO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1kaXNhYmxlZCcpO1xuXG4gICAgdGhpcy5tZW51QnV0dG9uXy5lbmFibGUoKTtcbiAgfTtcblxuICByZXR1cm4gTWVudUJ1dHRvbjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNZW51QnV0dG9uJywgTWVudUJ1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgdHJhY2stYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGJ1dHRvbnMgdGhhdCB0b2dnbGUgc3BlY2lmaWMgIHRyYWNrIHR5cGVzIChlLmcuIHN1YnRpdGxlcykuXG4gKlxuICogQGV4dGVuZHMgTWVudUJ1dHRvblxuICovXG5cbnZhciBUcmFja0J1dHRvbiA9IGZ1bmN0aW9uIChfTWVudUJ1dHRvbikge1xuICBpbmhlcml0cyhUcmFja0J1dHRvbiwgX01lbnVCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVHJhY2tCdXR0b24ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhY2tCdXR0b24pO1xuXG4gICAgdmFyIHRyYWNrcyA9IG9wdGlvbnMudHJhY2tzO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVudUJ1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgaWYgKF90aGlzLml0ZW1zLmxlbmd0aCA8PSAxKSB7XG4gICAgICBfdGhpcy5oaWRlKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0cmFja3MpIHtcbiAgICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSGFuZGxlciA9IGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZSk7XG5cbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB1cGRhdGVIYW5kbGVyKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB1cGRhdGVIYW5kbGVyKTtcbiAgICBfdGhpcy5wbGF5ZXJfLm9uKCdyZWFkeScsIHVwZGF0ZUhhbmRsZXIpO1xuXG4gICAgX3RoaXMucGxheWVyXy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHVwZGF0ZUhhbmRsZXIpO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFRyYWNrQnV0dG9uO1xufShNZW51QnV0dG9uKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUcmFja0J1dHRvbicsIFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBtZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBhIG1lbnUgaXRlbS4gYDxsaT5gXG4gKlxuICogQGV4dGVuZHMgQ2xpY2thYmxlQ29tcG9uZW50XG4gKi9cblxudmFyIE1lbnVJdGVtID0gZnVuY3Rpb24gKF9DbGlja2FibGVDb21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTWVudUl0ZW0sIF9DbGlja2FibGVDb21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIE1lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1lbnVJdGVtKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NsaWNrYWJsZUNvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuc2VsZWN0YWJsZSA9IG9wdGlvbnMuc2VsZWN0YWJsZTtcblxuICAgIF90aGlzLnNlbGVjdGVkKG9wdGlvbnMuc2VsZWN0ZWQpO1xuXG4gICAgaWYgKF90aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgIC8vIFRPRE86IE1heSBuZWVkIHRvIGJlIGVpdGhlciBtZW51aXRlbWNoZWNrYm94IG9yIG1lbnVpdGVtcmFkaW8sXG4gICAgICAvLyAgICAgICBhbmQgbWF5IG5lZWQgbG9naWNhbCBncm91cGluZyBvZiBtZW51IGl0ZW1zLlxuICAgICAgX3RoaXMuZWxfLnNldEF0dHJpYnV0ZSgncm9sZScsICdtZW51aXRlbWNoZWNrYm94Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbWVudWl0ZW0nKTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYE1lbnVJdGVtJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlPWxpXVxuICAgKiAgICAgICAgRWxlbWVudCdzIG5vZGUgdHlwZSwgbm90IGFjdHVhbGx5IHVzZWQsIGFsd2F5cyBzZXQgdG8gYGxpYC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcz17fV1cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJzPXt9XVxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgTWVudUl0ZW0ucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwodHlwZSwgcHJvcHMsIGF0dHJzKSB7XG4gICAgLy8gVGhlIGNvbnRyb2wgaXMgdGV4dHVhbCwgbm90IGp1c3QgYW4gaWNvblxuICAgIHRoaXMubm9uSWNvbkNvbnRyb2wgPSB0cnVlO1xuXG4gICAgcmV0dXJuIF9DbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2xpJywgYXNzaWduKHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51LWl0ZW0nLFxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtbWVudS1pdGVtLXRleHRcIj4nICsgdGhpcy5sb2NhbGl6ZSh0aGlzLm9wdGlvbnNfLmxhYmVsKSArICc8L3NwYW4+JyxcbiAgICAgIHRhYkluZGV4OiAtMVxuICAgIH0sIHByb3BzKSwgYXR0cnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbnkgY2xpY2sgb24gYSBgTWVudUl0ZW1gIHB1dHMgaW50IGludG8gdGhlIHNlbGVjdGVkIHN0YXRlLlxuICAgKiBTZWUge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVDbGlja30gZm9yIGluc3RhbmNlcyB3aGVyZSB0aGlzIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICB0aGlzLnNlbGVjdGVkKHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0YXRlIGZvciB0aGlzIG1lbnUgaXRlbSBhcyBzZWxlY3RlZCBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogICAgICAgIGlmIHRoZSBtZW51IGl0ZW0gaXMgc2VsZWN0ZWQgb3Igbm90XG4gICAqL1xuXG5cbiAgTWVudUl0ZW0ucHJvdG90eXBlLnNlbGVjdGVkID0gZnVuY3Rpb24gc2VsZWN0ZWQoX3NlbGVjdGVkKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgaWYgKF9zZWxlY3RlZCkge1xuICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2VsZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnLCAndHJ1ZScpO1xuICAgICAgICAvLyBhcmlhLWNoZWNrZWQgaXNuJ3QgZnVsbHkgc3VwcG9ydGVkIGJ5IGJyb3dzZXJzL3NjcmVlbiByZWFkZXJzLFxuICAgICAgICAvLyBzbyBpbmRpY2F0ZSBzZWxlY3RlZCBzdGF0ZSB0byBzY3JlZW4gcmVhZGVyIGluIHRoZSBjb250cm9sIHRleHQuXG4gICAgICAgIHRoaXMuY29udHJvbFRleHQoJywgc2VsZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zZWxlY3RlZCcpO1xuICAgICAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcsICdmYWxzZScpO1xuICAgICAgICAvLyBJbmRpY2F0ZSB1bi1zZWxlY3RlZCBzdGF0ZSB0byBzY3JlZW4gcmVhZGVyXG4gICAgICAgIHRoaXMuY29udHJvbFRleHQoJycpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTWVudUl0ZW07XG59KENsaWNrYWJsZUNvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTWVudUl0ZW0nLCBNZW51SXRlbSk7XG5cbi8qKlxuICogQGZpbGUgdGV4dC10cmFjay1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBUaGUgc3BlY2lmaWMgbWVudSBpdGVtIHR5cGUgZm9yIHNlbGVjdGluZyBhIGxhbmd1YWdlIHdpdGhpbiBhIHRleHQgdHJhY2sga2luZFxuICpcbiAqIEBleHRlbmRzIE1lbnVJdGVtXG4gKi9cblxudmFyIFRleHRUcmFja01lbnVJdGVtID0gZnVuY3Rpb24gKF9NZW51SXRlbSkge1xuICBpbmhlcml0cyhUZXh0VHJhY2tNZW51SXRlbSwgX01lbnVJdGVtKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFRleHRUcmFja01lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRUcmFja01lbnVJdGVtKTtcblxuICAgIHZhciB0cmFjayA9IG9wdGlvbnMudHJhY2s7XG4gICAgdmFyIHRyYWNrcyA9IHBsYXllci50ZXh0VHJhY2tzKCk7XG5cbiAgICAvLyBNb2RpZnkgb3B0aW9ucyBmb3IgcGFyZW50IE1lbnVJdGVtIGNsYXNzJ3MgaW5pdC5cbiAgICBvcHRpb25zLmxhYmVsID0gdHJhY2subGFiZWwgfHwgdHJhY2subGFuZ3VhZ2UgfHwgJ1Vua25vd24nO1xuICAgIG9wdGlvbnMuc2VsZWN0ZWQgPSB0cmFjay5tb2RlID09PSAnc2hvd2luZyc7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9NZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudHJhY2sgPSB0cmFjaztcbiAgICB2YXIgY2hhbmdlSGFuZGxlciA9IGZ1bmN0aW9uIGNoYW5nZUhhbmRsZXIoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgdmFyIHNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2VIYW5kbGVyID0gZnVuY3Rpb24gc2VsZWN0ZWRMYW5ndWFnZUNoYW5nZUhhbmRsZXIoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBwbGF5ZXIub24oWydsb2Fkc3RhcnQnLCAndGV4dHRyYWNrY2hhbmdlJ10sIGNoYW5nZUhhbmRsZXIpO1xuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0ZWRsYW5ndWFnZWNoYW5nZScsIHNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2VIYW5kbGVyKTtcbiAgICBfdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHBsYXllci5vZmYoWydsb2Fkc3RhcnQnLCAndGV4dHRyYWNrY2hhbmdlJ10sIGNoYW5nZUhhbmRsZXIpO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdGVkbGFuZ3VhZ2VjaGFuZ2UnLCBzZWxlY3RlZExhbmd1YWdlQ2hhbmdlSGFuZGxlcik7XG4gICAgfSk7XG5cbiAgICAvLyBpT1M3IGRvZXNuJ3QgZGlzcGF0Y2ggY2hhbmdlIGV2ZW50cyB0byBUZXh0VHJhY2tMaXN0cyB3aGVuIGFuXG4gICAgLy8gYXNzb2NpYXRlZCB0cmFjaydzIG1vZGUgY2hhbmdlcy4gV2l0aG91dCBzb21ldGhpbmcgbGlrZVxuICAgIC8vIE9iamVjdC5vYnNlcnZlKCkgKGFsc28gbm90IHByZXNlbnQgb24gaU9TNyksIGl0J3Mgbm90XG4gICAgLy8gcG9zc2libGUgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gdGhlIG1vZGUgYXR0cmlidXRlIGFuZCBwb2x5ZmlsbFxuICAgIC8vIHRoZSBjaGFuZ2UgZXZlbnQuIEFzIGEgcG9vciBzdWJzdGl0dXRlLCB3ZSBtYW51YWxseSBkaXNwYXRjaFxuICAgIC8vIGNoYW5nZSBldmVudHMgd2hlbmV2ZXIgdGhlIGNvbnRyb2xzIG1vZGlmeSB0aGUgbW9kZS5cbiAgICBpZiAodHJhY2tzLm9uY2hhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBldmVudCA9IHZvaWQgMDtcblxuICAgICAgX3RoaXMub24oWyd0YXAnLCAnY2xpY2snXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3R5cGVvZih3aW5kb3cuRXZlbnQpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIC8vIEFuZHJvaWQgMi4zIHRocm93cyBhbiBJbGxlZ2FsIENvbnN0cnVjdG9yIGVycm9yIGZvciB3aW5kb3cuRXZlbnRcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXZlbnQgPSBuZXcgd2luZG93LkV2ZW50KCdjaGFuZ2UnKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGNvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgICBldmVudC5pbml0RXZlbnQoJ2NoYW5nZScsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhY2tzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBkZWZhdWx0IHN0YXRlIGJhc2VkIG9uIGN1cnJlbnQgdHJhY2tzXG4gICAgX3RoaXMuaGFuZGxlVHJhY2tzQ2hhbmdlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgVGV4dFRyYWNrTWVudUl0ZW1gIGlzIFwiY2xpY2tlZFwiLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICB2YXIga2luZCA9IHRoaXMudHJhY2sua2luZDtcbiAgICB2YXIga2luZHMgPSB0aGlzLnRyYWNrLmtpbmRzO1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKCFraW5kcykge1xuICAgICAga2luZHMgPSBba2luZF07XG4gICAgfVxuXG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgIGlmICghdHJhY2tzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaWYgKHRyYWNrID09PSB0aGlzLnRyYWNrICYmIGtpbmRzLmluZGV4T2YodHJhY2sua2luZCkgPiAtMSkge1xuICAgICAgICBpZiAodHJhY2subW9kZSAhPT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgICAgdHJhY2subW9kZSA9ICdzaG93aW5nJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFjay5tb2RlICE9PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgIHRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRleHQgdHJhY2sgbGlzdCBjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgY2hhbmdlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgVGV4dFRyYWNrTGlzdCNjaGFuZ2VcbiAgICovXG5cblxuICBUZXh0VHJhY2tNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlVHJhY2tzQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlVHJhY2tzQ2hhbmdlKGV2ZW50KSB7XG4gICAgdGhpcy5zZWxlY3RlZCh0aGlzLnRyYWNrLm1vZGUgPT09ICdzaG93aW5nJyk7XG4gIH07XG5cbiAgVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVTZWxlY3RlZExhbmd1YWdlQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMudHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICB2YXIgc2VsZWN0ZWRMYW5ndWFnZSA9IHRoaXMucGxheWVyXy5jYWNoZV8uc2VsZWN0ZWRMYW5ndWFnZTtcblxuICAgICAgLy8gRG9uJ3QgcmVwbGFjZSB0aGUga2luZCBvZiB0cmFjayBhY3Jvc3MgdGhlIHNhbWUgbGFuZ3VhZ2VcbiAgICAgIGlmIChzZWxlY3RlZExhbmd1YWdlICYmIHNlbGVjdGVkTGFuZ3VhZ2UuZW5hYmxlZCAmJiBzZWxlY3RlZExhbmd1YWdlLmxhbmd1YWdlID09PSB0aGlzLnRyYWNrLmxhbmd1YWdlICYmIHNlbGVjdGVkTGFuZ3VhZ2Uua2luZCAhPT0gdGhpcy50cmFjay5raW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wbGF5ZXJfLmNhY2hlXy5zZWxlY3RlZExhbmd1YWdlID0ge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBsYW5ndWFnZTogdGhpcy50cmFjay5sYW5ndWFnZSxcbiAgICAgICAga2luZDogdGhpcy50cmFjay5raW5kXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBUZXh0VHJhY2tNZW51SXRlbS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byB0cmFjayBvYmplY3Qgb24gZGlzcG9zZVxuICAgIHRoaXMudHJhY2sgPSBudWxsO1xuXG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFja01lbnVJdGVtO1xufShNZW51SXRlbSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGV4dFRyYWNrTWVudUl0ZW0nLCBUZXh0VHJhY2tNZW51SXRlbSk7XG5cbi8qKlxuICogQGZpbGUgb2ZmLXRleHQtdHJhY2stbWVudS1pdGVtLmpzXG4gKi9cbi8qKlxuICogQSBzcGVjaWFsIG1lbnUgaXRlbSBmb3IgdHVybmluZyBvZiBhIHNwZWNpZmljIHR5cGUgb2YgdGV4dCB0cmFja1xuICpcbiAqIEBleHRlbmRzIFRleHRUcmFja01lbnVJdGVtXG4gKi9cblxudmFyIE9mZlRleHRUcmFja01lbnVJdGVtID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tNZW51SXRlbSkge1xuICBpbmhlcml0cyhPZmZUZXh0VHJhY2tNZW51SXRlbSwgX1RleHRUcmFja01lbnVJdGVtKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIE9mZlRleHRUcmFja01lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE9mZlRleHRUcmFja01lbnVJdGVtKTtcblxuICAgIC8vIENyZWF0ZSBwc2V1ZG8gdHJhY2sgaW5mb1xuICAgIC8vIFJlcXVpcmVzIG9wdGlvbnNbJ2tpbmQnXVxuICAgIG9wdGlvbnMudHJhY2sgPSB7XG4gICAgICBwbGF5ZXI6IHBsYXllcixcbiAgICAgIGtpbmQ6IG9wdGlvbnMua2luZCxcbiAgICAgIGtpbmRzOiBvcHRpb25zLmtpbmRzLFxuICAgICAgJ2RlZmF1bHQnOiBmYWxzZSxcbiAgICAgIG1vZGU6ICdkaXNhYmxlZCdcbiAgICB9O1xuXG4gICAgaWYgKCFvcHRpb25zLmtpbmRzKSB7XG4gICAgICBvcHRpb25zLmtpbmRzID0gW29wdGlvbnMua2luZF07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubGFiZWwpIHtcbiAgICAgIG9wdGlvbnMudHJhY2subGFiZWwgPSBvcHRpb25zLmxhYmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnRyYWNrLmxhYmVsID0gb3B0aW9ucy5raW5kcy5qb2luKCcgYW5kICcpICsgJyBvZmYnO1xuICAgIH1cblxuICAgIC8vIE1lbnVJdGVtIGlzIHNlbGVjdGFibGVcbiAgICBvcHRpb25zLnNlbGVjdGFibGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja01lbnVJdGVtLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHRleHQgdHJhY2sgY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW5cbiAgICovXG5cblxuICBPZmZUZXh0VHJhY2tNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlVHJhY2tzQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlVHJhY2tzQ2hhbmdlKGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyKCkudGV4dFRyYWNrcygpO1xuICAgIHZhciBzZWxlY3RlZCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRyYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9uc18ua2luZHMuaW5kZXhPZih0cmFjay5raW5kKSA+IC0xICYmIHRyYWNrLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICBzZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNlbGVjdGVkKHNlbGVjdGVkKTtcbiAgfTtcblxuICBPZmZUZXh0VHJhY2tNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlU2VsZWN0ZWRMYW5ndWFnZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UoZXZlbnQpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXIoKS50ZXh0VHJhY2tzKCk7XG4gICAgdmFyIGFsbEhpZGRlbiA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRyYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaWYgKFsnY2FwdGlvbnMnLCAnZGVzY3JpcHRpb25zJywgJ3N1YnRpdGxlcyddLmluZGV4T2YodHJhY2sua2luZCkgPiAtMSAmJiB0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgYWxsSGlkZGVuID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbGxIaWRkZW4pIHtcbiAgICAgIHRoaXMucGxheWVyXy5jYWNoZV8uc2VsZWN0ZWRMYW5ndWFnZSA9IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBPZmZUZXh0VHJhY2tNZW51SXRlbTtcbn0oVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ09mZlRleHRUcmFja01lbnVJdGVtJywgT2ZmVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGJ1dHRvbnMgdGhhdCB0b2dnbGUgc3BlY2lmaWMgdGV4dCB0cmFjayB0eXBlcyAoZS5nLiBzdWJ0aXRsZXMpXG4gKlxuICogQGV4dGVuZHMgTWVudUJ1dHRvblxuICovXG5cbnZhciBUZXh0VHJhY2tCdXR0b24gPSBmdW5jdGlvbiAoX1RyYWNrQnV0dG9uKSB7XG4gIGluaGVyaXRzKFRleHRUcmFja0J1dHRvbiwgX1RyYWNrQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFRleHRUcmFja0J1dHRvbihwbGF5ZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrQnV0dG9uKTtcblxuICAgIG9wdGlvbnMudHJhY2tzID0gcGxheWVyLnRleHRUcmFja3MoKTtcblxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1lbnUgaXRlbSBmb3IgZWFjaCB0ZXh0IHRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrTWVudUl0ZW1bXX0gW2l0ZW1zPVtdXVxuICAgKiAgICAgICAgRXhpc3RpbmcgYXJyYXkgb2YgaXRlbXMgdG8gdXNlIGR1cmluZyBjcmVhdGlvblxuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2tNZW51SXRlbVtdfVxuICAgKiAgICAgICAgIEFycmF5IG9mIG1lbnUgaXRlbXMgdGhhdCB3ZXJlIGNyZWF0ZWRcbiAgICovXG5cblxuICBUZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zID0gZnVuY3Rpb24gY3JlYXRlSXRlbXMoKSB7XG4gICAgdmFyIGl0ZW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICB2YXIgVHJhY2tNZW51SXRlbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogVGV4dFRyYWNrTWVudUl0ZW07XG5cblxuICAgIC8vIExhYmVsIGlzIGFuIG92ZXJpZGUgZm9yIHRoZSBbdHJhY2tdIG9mZiBsYWJlbFxuICAgIC8vIFVTZWQgdG8gbG9jYWxpc2UgY2FwdGlvbnMvc3VidGl0bGVzXG4gICAgdmFyIGxhYmVsID0gdm9pZCAwO1xuXG4gICAgaWYgKHRoaXMubGFiZWxfKSB7XG4gICAgICBsYWJlbCA9IHRoaXMubGFiZWxfICsgJyBvZmYnO1xuICAgIH1cbiAgICAvLyBBZGQgYW4gT0ZGIG1lbnUgaXRlbSB0byB0dXJuIGFsbCB0cmFja3Mgb2ZmXG4gICAgaXRlbXMucHVzaChuZXcgT2ZmVGV4dFRyYWNrTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7XG4gICAgICBraW5kczogdGhpcy5raW5kc18sXG4gICAgICBraW5kOiB0aGlzLmtpbmRfLFxuICAgICAgbGFiZWw6IGxhYmVsXG4gICAgfSkpO1xuXG4gICAgdGhpcy5oaWRlVGhyZXNob2xkXyArPSAxO1xuXG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCk7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5raW5kc18pKSB7XG4gICAgICB0aGlzLmtpbmRzXyA9IFt0aGlzLmtpbmRfXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICAvLyBvbmx5IGFkZCB0cmFja3MgdGhhdCBhcmUgb2YgYW4gYXBwcm9wcmlhdGUga2luZCBhbmQgaGF2ZSBhIGxhYmVsXG4gICAgICBpZiAodGhpcy5raW5kc18uaW5kZXhPZih0cmFjay5raW5kKSA+IC0xKSB7XG5cbiAgICAgICAgdmFyIGl0ZW0gPSBuZXcgVHJhY2tNZW51SXRlbSh0aGlzLnBsYXllcl8sIHtcbiAgICAgICAgICB0cmFjazogdHJhY2ssXG4gICAgICAgICAgLy8gTWVudUl0ZW0gaXMgc2VsZWN0YWJsZVxuICAgICAgICAgIHNlbGVjdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5hZGRDbGFzcygndmpzLScgKyB0cmFjay5raW5kICsgJy1tZW51LWl0ZW0nKTtcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFja0J1dHRvbjtcbn0oVHJhY2tCdXR0b24pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RleHRUcmFja0J1dHRvbicsIFRleHRUcmFja0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgY2hhcHRlcnMtdHJhY2stbWVudS1pdGVtLmpzXG4gKi9cbi8qKlxuICogVGhlIGNoYXB0ZXIgdHJhY2sgbWVudSBpdGVtXG4gKlxuICogQGV4dGVuZHMgTWVudUl0ZW1cbiAqL1xuXG52YXIgQ2hhcHRlcnNUcmFja01lbnVJdGVtID0gZnVuY3Rpb24gKF9NZW51SXRlbSkge1xuICBpbmhlcml0cyhDaGFwdGVyc1RyYWNrTWVudUl0ZW0sIF9NZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBDaGFwdGVyc1RyYWNrTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hhcHRlcnNUcmFja01lbnVJdGVtKTtcblxuICAgIHZhciB0cmFjayA9IG9wdGlvbnMudHJhY2s7XG4gICAgdmFyIGN1ZSA9IG9wdGlvbnMuY3VlO1xuICAgIHZhciBjdXJyZW50VGltZSA9IHBsYXllci5jdXJyZW50VGltZSgpO1xuXG4gICAgLy8gTW9kaWZ5IG9wdGlvbnMgZm9yIHBhcmVudCBNZW51SXRlbSBjbGFzcydzIGluaXQuXG4gICAgb3B0aW9ucy5zZWxlY3RhYmxlID0gdHJ1ZTtcbiAgICBvcHRpb25zLmxhYmVsID0gY3VlLnRleHQ7XG4gICAgb3B0aW9ucy5zZWxlY3RlZCA9IGN1ZS5zdGFydFRpbWUgPD0gY3VycmVudFRpbWUgJiYgY3VycmVudFRpbWUgPCBjdWUuZW5kVGltZTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVJdGVtLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy50cmFjayA9IHRyYWNrO1xuICAgIF90aGlzLmN1ZSA9IGN1ZTtcbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdjdWVjaGFuZ2UnLCBiaW5kKF90aGlzLCBfdGhpcy51cGRhdGUpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBDaGFwdGVyc1RyYWNrTWVudUl0ZW1gIGlzIFwiY2xpY2tlZFwiLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBDaGFwdGVyc1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBfTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcyk7XG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKHRoaXMuY3VlLnN0YXJ0VGltZSk7XG4gICAgdGhpcy51cGRhdGUodGhpcy5jdWUuc3RhcnRUaW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGNoYXB0ZXIgbWVudSBpdGVtXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgY3VlY2hhbmdlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgVGV4dFRyYWNrI2N1ZWNoYW5nZVxuICAgKi9cblxuXG4gIENoYXB0ZXJzVHJhY2tNZW51SXRlbS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XG4gICAgdmFyIGN1ZSA9IHRoaXMuY3VlO1xuICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpO1xuXG4gICAgLy8gdmpzLmxvZyhjdXJyZW50VGltZSwgY3VlLnN0YXJ0VGltZSk7XG4gICAgdGhpcy5zZWxlY3RlZChjdWUuc3RhcnRUaW1lIDw9IGN1cnJlbnRUaW1lICYmIGN1cnJlbnRUaW1lIDwgY3VlLmVuZFRpbWUpO1xuICB9O1xuXG4gIHJldHVybiBDaGFwdGVyc1RyYWNrTWVudUl0ZW07XG59KE1lbnVJdGVtKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDaGFwdGVyc1RyYWNrTWVudUl0ZW0nLCBDaGFwdGVyc1RyYWNrTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIGNoYXB0ZXJzLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIGNoYXB0ZXJzXG4gKiBDaGFwdGVycyBhY3QgbXVjaCBkaWZmZXJlbnRseSB0aGFuIG90aGVyIHRleHQgdHJhY2tzXG4gKiBDdWVzIGFyZSBuYXZpZ2F0aW9uIHZzLiBvdGhlciB0cmFja3Mgb2YgYWx0ZXJuYXRpdmUgbGFuZ3VhZ2VzXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXG4gKi9cblxudmFyIENoYXB0ZXJzQnV0dG9uID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoQ2hhcHRlcnNCdXR0b24sIF9UZXh0VHJhY2tCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoaXMgZnVuY3Rpb24gaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBDaGFwdGVyc0J1dHRvbihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hhcHRlcnNCdXR0b24pO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jaGFwdGVycy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jaGFwdGVycy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgbWVudSBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBvZiBpdHMgaXRlbXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIEFuIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZXh0VHJhY2tMaXN0I2FkZHRyYWNrXG4gICAqIEBsaXN0ZW5zIFRleHRUcmFja0xpc3QjcmVtb3ZldHJhY2tcbiAgICogQGxpc3RlbnMgVGV4dFRyYWNrTGlzdCNjaGFuZ2VcbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnRyYWNrXyB8fCBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2FkZHRyYWNrJyB8fCBldmVudC50eXBlID09PSAncmVtb3ZldHJhY2snKSkge1xuICAgICAgdGhpcy5zZXRUcmFjayh0aGlzLmZpbmRDaGFwdGVyc1RyYWNrKCkpO1xuICAgIH1cbiAgICBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdHJhY2sgZm9yIHRoZSBjaGFwdGVycyBidXR0b24uXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICAgKiAgICAgICAgVGhlIG5ldyB0cmFjayB0byBzZWxlY3QuIE5vdGhpbmcgd2lsbCBjaGFuZ2UgaWYgdGhpcyBpcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkXG4gICAqICAgICAgICB0cmFjay5cbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuc2V0VHJhY2sgPSBmdW5jdGlvbiBzZXRUcmFjayh0cmFjaykge1xuICAgIGlmICh0aGlzLnRyYWNrXyA9PT0gdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudXBkYXRlSGFuZGxlcl8pIHtcbiAgICAgIHRoaXMudXBkYXRlSGFuZGxlcl8gPSB0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIGhlcmUgdGhpcy50cmFja18gcmVmZXJzIHRvIHRoZSBvbGQgdHJhY2sgaW5zdGFuY2VcbiAgICBpZiAodGhpcy50cmFja18pIHtcbiAgICAgIHZhciByZW1vdGVUZXh0VHJhY2tFbCA9IHRoaXMucGxheWVyXy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5nZXRUcmFja0VsZW1lbnRCeVRyYWNrXyh0aGlzLnRyYWNrXyk7XG5cbiAgICAgIGlmIChyZW1vdGVUZXh0VHJhY2tFbCkge1xuICAgICAgICByZW1vdGVUZXh0VHJhY2tFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy51cGRhdGVIYW5kbGVyXyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJhY2tfID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLnRyYWNrXyA9IHRyYWNrO1xuXG4gICAgLy8gaGVyZSB0aGlzLnRyYWNrXyByZWZlcnMgdG8gdGhlIG5ldyB0cmFjayBpbnN0YW5jZVxuICAgIGlmICh0aGlzLnRyYWNrXykge1xuICAgICAgdGhpcy50cmFja18ubW9kZSA9ICdoaWRkZW4nO1xuXG4gICAgICB2YXIgX3JlbW90ZVRleHRUcmFja0VsID0gdGhpcy5wbGF5ZXJfLnJlbW90ZVRleHRUcmFja0VscygpLmdldFRyYWNrRWxlbWVudEJ5VHJhY2tfKHRoaXMudHJhY2tfKTtcblxuICAgICAgaWYgKF9yZW1vdGVUZXh0VHJhY2tFbCkge1xuICAgICAgICBfcmVtb3RlVGV4dFRyYWNrRWwuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMudXBkYXRlSGFuZGxlcl8pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRmluZCB0aGUgdHJhY2sgb2JqZWN0IHRoYXQgaXMgY3VycmVudGx5IGluIHVzZSBieSB0aGlzIENoYXB0ZXJzQnV0dG9uXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja3x1bmRlZmluZWR9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdHJhY2sgb3IgdW5kZWZpbmVkIGlmIG5vbmUgd2FzIGZvdW5kLlxuICAgKi9cblxuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5maW5kQ2hhcHRlcnNUcmFjayA9IGZ1bmN0aW9uIGZpbmRDaGFwdGVyc1RyYWNrKCkge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpIHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IHRyYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgLy8gV2Ugd2lsbCBhbHdheXMgY2hvb3NlIHRoZSBsYXN0IHRyYWNrIGFzIG91ciBjaGFwdGVyc1RyYWNrXG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmICh0cmFjay5raW5kID09PSB0aGlzLmtpbmRfKSB7XG4gICAgICAgIHJldHVybiB0cmFjaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY2FwdGlvbiBmb3IgdGhlIENoYXB0ZXJzQnV0dG9uIGJhc2VkIG9uIHRoZSB0cmFjayBsYWJlbC4gVGhpcyB3aWxsIGFsc29cbiAgICogdXNlIHRoZSBjdXJyZW50IHRyYWNrcyBsb2NhbGl6ZWQga2luZCBhcyBhIGZhbGxiYWNrIGlmIGEgbGFiZWwgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgdHJhY2tzIGN1cnJlbnQgbGFiZWwgb3IgdGhlIGxvY2FsaXplZCB0cmFjayBraW5kLlxuICAgKi9cblxuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5nZXRNZW51Q2FwdGlvbiA9IGZ1bmN0aW9uIGdldE1lbnVDYXB0aW9uKCkge1xuICAgIGlmICh0aGlzLnRyYWNrXyAmJiB0aGlzLnRyYWNrXy5sYWJlbCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2tfLmxhYmVsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sb2NhbGl6ZSh0b1RpdGxlQ2FzZSh0aGlzLmtpbmRfKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBtZW51IGZyb20gY2hhcHRlciB0cmFja1xuICAgKlxuICAgKiBAcmV0dXJuIHtNZW51fVxuICAgKiAgICAgICAgIE5ldyBtZW51IGZvciB0aGUgY2hhcHRlciBidXR0b25zXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmNyZWF0ZU1lbnUgPSBmdW5jdGlvbiBjcmVhdGVNZW51KCkge1xuICAgIHRoaXMub3B0aW9uc18udGl0bGUgPSB0aGlzLmdldE1lbnVDYXB0aW9uKCk7XG4gICAgcmV0dXJuIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZU1lbnUuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbWVudSBpdGVtIGZvciBlYWNoIHRleHQgdHJhY2tcbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrTWVudUl0ZW1bXX1cbiAgICogICAgICAgICBBcnJheSBvZiBtZW51IGl0ZW1zXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zID0gZnVuY3Rpb24gY3JlYXRlSXRlbXMoKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG5cbiAgICBpZiAoIXRoaXMudHJhY2tfKSB7XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuXG4gICAgdmFyIGN1ZXMgPSB0aGlzLnRyYWNrXy5jdWVzO1xuXG4gICAgaWYgKCFjdWVzKSB7XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjdWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGN1ZSA9IGN1ZXNbaV07XG4gICAgICB2YXIgbWkgPSBuZXcgQ2hhcHRlcnNUcmFja01lbnVJdGVtKHRoaXMucGxheWVyXywgeyB0cmFjazogdGhpcy50cmFja18sIGN1ZTogY3VlIH0pO1xuXG4gICAgICBpdGVtcy5wdXNoKG1pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH07XG5cbiAgcmV0dXJuIENoYXB0ZXJzQnV0dG9uO1xufShUZXh0VHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIGBraW5kYCBvZiBUZXh0VHJhY2sgdG8gbG9vayBmb3IgdG8gYXNzb2NpYXRlIGl0IHdpdGggdGhpcyBtZW51LlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmtpbmRfID0gJ2NoYXB0ZXJzJztcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBDaGFwdGVyc0J1dHRvbmBzIGNvbnRyb2xzLiBBZGRlZCBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5DaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ0NoYXB0ZXJzJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDaGFwdGVyc0J1dHRvbicsIENoYXB0ZXJzQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBkZXNjcmlwdGlvbnMtYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHRvZ2dsaW5nIGFuZCBzZWxlY3RpbmcgZGVzY3JpcHRpb25zXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXG4gKi9cblxudmFyIERlc2NyaXB0aW9uc0J1dHRvbiA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrQnV0dG9uKSB7XG4gIGluaGVyaXRzKERlc2NyaXB0aW9uc0J1dHRvbiwgX1RleHRUcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBEZXNjcmlwdGlvbnNCdXR0b24ocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIERlc2NyaXB0aW9uc0J1dHRvbik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSk7XG5cbiAgICB2YXIgdHJhY2tzID0gcGxheWVyLnRleHRUcmFja3MoKTtcbiAgICB2YXIgY2hhbmdlSGFuZGxlciA9IGJpbmQoX3RoaXMsIF90aGlzLmhhbmRsZVRyYWNrc0NoYW5nZSk7XG5cbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XG4gICAgX3RoaXMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0ZXh0IHRyYWNrIGNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRleHRUcmFja0xpc3QjY2hhbmdlXG4gICAqL1xuXG5cbiAgRGVzY3JpcHRpb25zQnV0dG9uLnByb3RvdHlwZS5oYW5kbGVUcmFja3NDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVUcmFja3NDaGFuZ2UoZXZlbnQpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXIoKS50ZXh0VHJhY2tzKCk7XG4gICAgdmFyIGRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAvLyBDaGVjayB3aGV0aGVyIGEgdHJhY2sgb2YgYSBkaWZmZXJlbnQga2luZCBpcyBzaG93aW5nXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0cmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmICh0cmFjay5raW5kICE9PSB0aGlzLmtpbmRfICYmIHRyYWNrLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGFub3RoZXIgdHJhY2sgaXMgc2hvd2luZywgZGlzYWJsZSB0aGlzIG1lbnUgYnV0dG9uXG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBEZXNjcmlwdGlvbnNCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWRlc2NyaXB0aW9ucy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBEZXNjcmlwdGlvbnNCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtZGVzY3JpcHRpb25zLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gRGVzY3JpcHRpb25zQnV0dG9uO1xufShUZXh0VHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIGBraW5kYCBvZiBUZXh0VHJhY2sgdG8gbG9vayBmb3IgdG8gYXNzb2NpYXRlIGl0IHdpdGggdGhpcyBtZW51LlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuRGVzY3JpcHRpb25zQnV0dG9uLnByb3RvdHlwZS5raW5kXyA9ICdkZXNjcmlwdGlvbnMnO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYERlc2NyaXB0aW9uc0J1dHRvbmBzIGNvbnRyb2xzLiBBZGRlZCBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5EZXNjcmlwdGlvbnNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdEZXNjcmlwdGlvbnMnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0Rlc2NyaXB0aW9uc0J1dHRvbicsIERlc2NyaXB0aW9uc0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgc3VidGl0bGVzLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIHN1YnRpdGxlc1xuICpcbiAqIEBleHRlbmRzIFRleHRUcmFja0J1dHRvblxuICovXG5cbnZhciBTdWJ0aXRsZXNCdXR0b24gPSBmdW5jdGlvbiAoX1RleHRUcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhTdWJ0aXRsZXNCdXR0b24sIF9UZXh0VHJhY2tCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gU3VidGl0bGVzQnV0dG9uKHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJ0aXRsZXNCdXR0b24pO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIFN1YnRpdGxlc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtc3VidGl0bGVzLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIFN1YnRpdGxlc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1zdWJ0aXRsZXMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBTdWJ0aXRsZXNCdXR0b247XG59KFRleHRUcmFja0J1dHRvbik7XG5cbi8qKlxuICogYGtpbmRgIG9mIFRleHRUcmFjayB0byBsb29rIGZvciB0byBhc3NvY2lhdGUgaXQgd2l0aCB0aGlzIG1lbnUuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5TdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmtpbmRfID0gJ3N1YnRpdGxlcyc7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgU3VidGl0bGVzQnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblN1YnRpdGxlc0J1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ1N1YnRpdGxlcyc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU3VidGl0bGVzQnV0dG9uJywgU3VidGl0bGVzQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBjYXB0aW9uLXNldHRpbmdzLW1lbnUtaXRlbS5qc1xuICovXG4vKipcbiAqIFRoZSBtZW51IGl0ZW0gZm9yIGNhcHRpb24gdHJhY2sgc2V0dGluZ3MgbWVudVxuICpcbiAqIEBleHRlbmRzIFRleHRUcmFja01lbnVJdGVtXG4gKi9cblxudmFyIENhcHRpb25TZXR0aW5nc01lbnVJdGVtID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tNZW51SXRlbSkge1xuICBpbmhlcml0cyhDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSwgX1RleHRUcmFja01lbnVJdGVtKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIENhcHRpb25TZXR0aW5nc01lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENhcHRpb25TZXR0aW5nc01lbnVJdGVtKTtcblxuICAgIG9wdGlvbnMudHJhY2sgPSB7XG4gICAgICBwbGF5ZXI6IHBsYXllcixcbiAgICAgIGtpbmQ6IG9wdGlvbnMua2luZCxcbiAgICAgIGxhYmVsOiBvcHRpb25zLmtpbmQgKyAnIHNldHRpbmdzJyxcbiAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgJ2RlZmF1bHQnOiBmYWxzZSxcbiAgICAgIG1vZGU6ICdkaXNhYmxlZCdcbiAgICB9O1xuXG4gICAgLy8gQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0gaGFzIG5vIGNvbmNlcHQgb2YgJ3NlbGVjdGVkJ1xuICAgIG9wdGlvbnMuc2VsZWN0YWJsZSA9IGZhbHNlO1xuXG4gICAgb3B0aW9ucy5uYW1lID0gJ0NhcHRpb25TZXR0aW5nc01lbnVJdGVtJztcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja01lbnVJdGVtLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5hZGRDbGFzcygndmpzLXRleHR0cmFjay1zZXR0aW5ncycpO1xuICAgIF90aGlzLmNvbnRyb2xUZXh0KCcsIG9wZW5zICcgKyBvcHRpb25zLmtpbmQgKyAnIHNldHRpbmdzIGRpYWxvZycpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYENhcHRpb25TZXR0aW5nc01lbnVJdGVtYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICB0aGlzLnBsYXllcigpLmdldENoaWxkKCd0ZXh0VHJhY2tTZXR0aW5ncycpLm9wZW4oKTtcbiAgfTtcblxuICByZXR1cm4gQ2FwdGlvblNldHRpbmdzTWVudUl0ZW07XG59KFRleHRUcmFja01lbnVJdGVtKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDYXB0aW9uU2V0dGluZ3NNZW51SXRlbScsIENhcHRpb25TZXR0aW5nc01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBjYXB0aW9ucy1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBjYXB0aW9uc1xuICpcbiAqIEBleHRlbmRzIFRleHRUcmFja0J1dHRvblxuICovXG5cbnZhciBDYXB0aW9uc0J1dHRvbiA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrQnV0dG9uKSB7XG4gIGluaGVyaXRzKENhcHRpb25zQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyByZWFkeS5cbiAgICovXG4gIGZ1bmN0aW9uIENhcHRpb25zQnV0dG9uKHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDYXB0aW9uc0J1dHRvbik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucywgcmVhZHkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgQ2FwdGlvbnNCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWNhcHRpb25zLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIENhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkV3JhcHBlckNTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWNhcHRpb25zLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGNhcHRpb24gbWVudSBpdGVtc1xuICAgKlxuICAgKiBAcmV0dXJuIHtDYXB0aW9uU2V0dGluZ3NNZW51SXRlbVtdfVxuICAgKiAgICAgICAgIFRoZSBhcnJheSBvZiBjdXJyZW50IG1lbnUgaXRlbXMuXG4gICAqL1xuXG5cbiAgQ2FwdGlvbnNCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zID0gZnVuY3Rpb24gY3JlYXRlSXRlbXMoKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG5cbiAgICBpZiAoISh0aGlzLnBsYXllcigpLnRlY2hfICYmIHRoaXMucGxheWVyKCkudGVjaF8uZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSkge1xuICAgICAgaXRlbXMucHVzaChuZXcgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7IGtpbmQ6IHRoaXMua2luZF8gfSkpO1xuXG4gICAgICB0aGlzLmhpZGVUaHJlc2hvbGRfICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zLmNhbGwodGhpcywgaXRlbXMpO1xuICB9O1xuXG4gIHJldHVybiBDYXB0aW9uc0J1dHRvbjtcbn0oVGV4dFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBga2luZGAgb2YgVGV4dFRyYWNrIHRvIGxvb2sgZm9yIHRvIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMgbWVudS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkNhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5raW5kXyA9ICdjYXB0aW9ucyc7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgQ2FwdGlvbnNCdXR0b25gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuQ2FwdGlvbnNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdDYXB0aW9ucyc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2FwdGlvbnNCdXR0b24nLCBDYXB0aW9uc0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgc3Vicy1jYXBzLW1lbnUtaXRlbS5qc1xuICovXG4vKipcbiAqIFN1YnNDYXBzTWVudUl0ZW0gaGFzIGFuIFtjY10gaWNvbiB0byBkaXN0aW5ndWlzaCBjYXB0aW9ucyBmcm9tIHN1YnRpdGxlc1xuICogaW4gdGhlIFN1YnNDYXBzTWVudS5cbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tNZW51SXRlbVxuICovXG5cbnZhciBTdWJzQ2Fwc01lbnVJdGVtID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tNZW51SXRlbSkge1xuICBpbmhlcml0cyhTdWJzQ2Fwc01lbnVJdGVtLCBfVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG4gIGZ1bmN0aW9uIFN1YnNDYXBzTWVudUl0ZW0oKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Vic0NhcHNNZW51SXRlbSk7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja01lbnVJdGVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgU3Vic0NhcHNNZW51SXRlbS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCh0eXBlLCBwcm9wcywgYXR0cnMpIHtcbiAgICB2YXIgaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwidmpzLW1lbnUtaXRlbS10ZXh0XCI+JyArIHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zXy5sYWJlbCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zXy50cmFjay5raW5kID09PSAnY2FwdGlvbnMnKSB7XG4gICAgICBpbm5lckhUTUwgKz0gJ1xcbiAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3M9XCJ2anMtaWNvbi1wbGFjZWhvbGRlclwiPjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPiAnICsgdGhpcy5sb2NhbGl6ZSgnQ2FwdGlvbnMnKSArICc8L3NwYW4+XFxuICAgICAgJztcbiAgICB9XG5cbiAgICBpbm5lckhUTUwgKz0gJzwvc3Bhbj4nO1xuXG4gICAgdmFyIGVsID0gX1RleHRUcmFja01lbnVJdGVtLnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsIHR5cGUsIGFzc2lnbih7XG4gICAgICBpbm5lckhUTUw6IGlubmVySFRNTFxuICAgIH0sIHByb3BzKSwgYXR0cnMpO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIHJldHVybiBTdWJzQ2Fwc01lbnVJdGVtO1xufShUZXh0VHJhY2tNZW51SXRlbSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU3Vic0NhcHNNZW51SXRlbScsIFN1YnNDYXBzTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIHN1Yi1jYXBzLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIGNhcHRpb25zIGFuZC9vciBzdWJ0aXRsZXNcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tCdXR0b25cbiAqL1xuXG52YXIgU3Vic0NhcHNCdXR0b24gPSBmdW5jdGlvbiAoX1RleHRUcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhTdWJzQ2Fwc0J1dHRvbiwgX1RleHRUcmFja0J1dHRvbik7XG5cbiAgZnVuY3Rpb24gU3Vic0NhcHNCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnNDYXBzQnV0dG9uKTtcblxuICAgIC8vIEFsdGhvdWdoIE5vcnRoIEFtZXJpY2EgdXNlcyBcImNhcHRpb25zXCIgaW4gbW9zdCBjYXNlcyBmb3JcbiAgICAvLyBcImNhcHRpb25zIGFuZCBzdWJ0aXRsZXNcIiBvdGhlciBsb2NhbGVzIHVzZSBcInN1YnRpdGxlc1wiXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5sYWJlbF8gPSAnc3VidGl0bGVzJztcbiAgICBpZiAoWydlbicsICdlbi11cycsICdlbi1jYScsICdmci1jYSddLmluZGV4T2YoX3RoaXMucGxheWVyXy5sYW5ndWFnZV8pID4gLTEpIHtcbiAgICAgIF90aGlzLmxhYmVsXyA9ICdjYXB0aW9ucyc7XG4gICAgfVxuICAgIF90aGlzLm1lbnVCdXR0b25fLmNvbnRyb2xUZXh0KHRvVGl0bGVDYXNlKF90aGlzLmxhYmVsXykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgU3Vic0NhcHNCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXN1YnMtY2Fwcy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBTdWJzQ2Fwc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1zdWJzLWNhcHMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgY2FwdGlvbi9zdWJ0aXRsZXMgbWVudSBpdGVtc1xuICAgKlxuICAgKiBAcmV0dXJuIHtDYXB0aW9uU2V0dGluZ3NNZW51SXRlbVtdfVxuICAgKiAgICAgICAgIFRoZSBhcnJheSBvZiBjdXJyZW50IG1lbnUgaXRlbXMuXG4gICAqL1xuXG5cbiAgU3Vic0NhcHNCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zID0gZnVuY3Rpb24gY3JlYXRlSXRlbXMoKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG5cbiAgICBpZiAoISh0aGlzLnBsYXllcigpLnRlY2hfICYmIHRoaXMucGxheWVyKCkudGVjaF8uZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSkge1xuICAgICAgaXRlbXMucHVzaChuZXcgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7IGtpbmQ6IHRoaXMubGFiZWxfIH0pKTtcblxuICAgICAgdGhpcy5oaWRlVGhyZXNob2xkXyArPSAxO1xuICAgIH1cblxuICAgIGl0ZW1zID0gX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMuY2FsbCh0aGlzLCBpdGVtcywgU3Vic0NhcHNNZW51SXRlbSk7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIHJldHVybiBTdWJzQ2Fwc0J1dHRvbjtcbn0oVGV4dFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBga2luZGBzIG9mIFRleHRUcmFjayB0byBsb29rIGZvciB0byBhc3NvY2lhdGUgaXQgd2l0aCB0aGlzIG1lbnUuXG4gKlxuICogQHR5cGUge2FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuXG5cblN1YnNDYXBzQnV0dG9uLnByb3RvdHlwZS5raW5kc18gPSBbJ2NhcHRpb25zJywgJ3N1YnRpdGxlcyddO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFN1YnNDYXBzQnV0dG9uYHMgY29udHJvbHMuXG4gKlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5TdWJzQ2Fwc0J1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ1N1YnRpdGxlcyc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU3Vic0NhcHNCdXR0b24nLCBTdWJzQ2Fwc0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgYXVkaW8tdHJhY2stbWVudS1pdGVtLmpzXG4gKi9cbi8qKlxuICogQW4ge0BsaW5rIEF1ZGlvVHJhY2t9IHtAbGluayBNZW51SXRlbX1cbiAqXG4gKiBAZXh0ZW5kcyBNZW51SXRlbVxuICovXG5cbnZhciBBdWRpb1RyYWNrTWVudUl0ZW0gPSBmdW5jdGlvbiAoX01lbnVJdGVtKSB7XG4gIGluaGVyaXRzKEF1ZGlvVHJhY2tNZW51SXRlbSwgX01lbnVJdGVtKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2tNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb1RyYWNrTWVudUl0ZW0pO1xuXG4gICAgdmFyIHRyYWNrID0gb3B0aW9ucy50cmFjaztcbiAgICB2YXIgdHJhY2tzID0gcGxheWVyLmF1ZGlvVHJhY2tzKCk7XG5cbiAgICAvLyBNb2RpZnkgb3B0aW9ucyBmb3IgcGFyZW50IE1lbnVJdGVtIGNsYXNzJ3MgaW5pdC5cbiAgICBvcHRpb25zLmxhYmVsID0gdHJhY2subGFiZWwgfHwgdHJhY2subGFuZ3VhZ2UgfHwgJ1Vua25vd24nO1xuICAgIG9wdGlvbnMuc2VsZWN0ZWQgPSB0cmFjay5lbmFibGVkO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnRyYWNrID0gdHJhY2s7XG5cbiAgICB2YXIgY2hhbmdlSGFuZGxlciA9IGZ1bmN0aW9uIGNoYW5nZUhhbmRsZXIoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XG4gICAgX3RoaXMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgQXVkaW9UcmFja01lbnVJdGVtIGlzIFwiY2xpY2tlZFwiLiBTZWUge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH1cbiAgICogZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBBdWRpb1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzKCk7XG5cbiAgICBfTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgdHJhY2suZW5hYmxlZCA9IHRyYWNrID09PSB0aGlzLnRyYWNrO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGFueSB7QGxpbmsgQXVkaW9UcmFja30gY2hhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUge0BsaW5rIEF1ZGlvVHJhY2tMaXN0I2NoYW5nZX0gZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIEF1ZGlvVHJhY2tMaXN0I2NoYW5nZVxuICAgKi9cblxuXG4gIEF1ZGlvVHJhY2tNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlVHJhY2tzQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlVHJhY2tzQ2hhbmdlKGV2ZW50KSB7XG4gICAgdGhpcy5zZWxlY3RlZCh0aGlzLnRyYWNrLmVuYWJsZWQpO1xuICB9O1xuXG4gIHJldHVybiBBdWRpb1RyYWNrTWVudUl0ZW07XG59KE1lbnVJdGVtKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdBdWRpb1RyYWNrTWVudUl0ZW0nLCBBdWRpb1RyYWNrTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIGF1ZGlvLXRyYWNrLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBidXR0b25zIHRoYXQgdG9nZ2xlIHNwZWNpZmljIHtAbGluayBBdWRpb1RyYWNrfSB0eXBlcy5cbiAqXG4gKiBAZXh0ZW5kcyBUcmFja0J1dHRvblxuICovXG5cbnZhciBBdWRpb1RyYWNrQnV0dG9uID0gZnVuY3Rpb24gKF9UcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhBdWRpb1RyYWNrQnV0dG9uLCBfVHJhY2tCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gQXVkaW9UcmFja0J1dHRvbihwbGF5ZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9UcmFja0J1dHRvbik7XG5cbiAgICBvcHRpb25zLnRyYWNrcyA9IHBsYXllci5hdWRpb1RyYWNrcygpO1xuXG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIEF1ZGlvVHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWF1ZGlvLWJ1dHRvbiAnICsgX1RyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgQXVkaW9UcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1hdWRpby1idXR0b24gJyArIF9UcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbWVudSBpdGVtIGZvciBlYWNoIGF1ZGlvIHRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7QXVkaW9UcmFja01lbnVJdGVtW119IFtpdGVtcz1bXV1cbiAgICogICAgICAgIEFuIGFycmF5IG9mIGV4aXN0aW5nIG1lbnUgaXRlbXMgdG8gdXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBdWRpb1RyYWNrTWVudUl0ZW1bXX1cbiAgICogICAgICAgICBBbiBhcnJheSBvZiBtZW51IGl0ZW1zXG4gICAqL1xuXG5cbiAgQXVkaW9UcmFja0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMgPSBmdW5jdGlvbiBjcmVhdGVJdGVtcygpIHtcbiAgICB2YXIgaXRlbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuXG4gICAgLy8gaWYgdGhlcmUncyBvbmx5IG9uZSBhdWRpbyB0cmFjaywgdGhlcmUgbm8gcG9pbnQgaW4gc2hvd2luZyBpdFxuICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gPSAxO1xuXG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaXRlbXMucHVzaChuZXcgQXVkaW9UcmFja01lbnVJdGVtKHRoaXMucGxheWVyXywge1xuICAgICAgICB0cmFjazogdHJhY2ssXG4gICAgICAgIC8vIE1lbnVJdGVtIGlzIHNlbGVjdGFibGVcbiAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfTtcblxuICByZXR1cm4gQXVkaW9UcmFja0J1dHRvbjtcbn0oVHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYEF1ZGlvVHJhY2tCdXR0b25gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkF1ZGlvVHJhY2tCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdBdWRpbyBUcmFjayc7XG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0F1ZGlvVHJhY2tCdXR0b24nLCBBdWRpb1RyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBwbGF5YmFjay1yYXRlLW1lbnUtaXRlbS5qc1xuICovXG4vKipcbiAqIFRoZSBzcGVjaWZpYyBtZW51IGl0ZW0gdHlwZSBmb3Igc2VsZWN0aW5nIGEgcGxheWJhY2sgcmF0ZS5cbiAqXG4gKiBAZXh0ZW5kcyBNZW51SXRlbVxuICovXG5cbnZhciBQbGF5YmFja1JhdGVNZW51SXRlbSA9IGZ1bmN0aW9uIChfTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoUGxheWJhY2tSYXRlTWVudUl0ZW0sIF9NZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBQbGF5YmFja1JhdGVNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5YmFja1JhdGVNZW51SXRlbSk7XG5cbiAgICB2YXIgbGFiZWwgPSBvcHRpb25zLnJhdGU7XG4gICAgdmFyIHJhdGUgPSBwYXJzZUZsb2F0KGxhYmVsLCAxMCk7XG5cbiAgICAvLyBNb2RpZnkgb3B0aW9ucyBmb3IgcGFyZW50IE1lbnVJdGVtIGNsYXNzJ3MgaW5pdC5cbiAgICBvcHRpb25zLmxhYmVsID0gbGFiZWw7XG4gICAgb3B0aW9ucy5zZWxlY3RlZCA9IHJhdGUgPT09IDE7XG4gICAgb3B0aW9ucy5zZWxlY3RhYmxlID0gdHJ1ZTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVJdGVtLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIF90aGlzLnJhdGUgPSByYXRlO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAncmF0ZWNoYW5nZScsIF90aGlzLnVwZGF0ZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgUGxheWJhY2tSYXRlTWVudUl0ZW1gIGlzIFwiY2xpY2tlZFwiLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIF9NZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2suY2FsbCh0aGlzKTtcbiAgICB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSh0aGlzLnJhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIFBsYXliYWNrUmF0ZU1lbnVJdGVtIHdoZW4gdGhlIHBsYXliYWNrcmF0ZSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYHJhdGVjaGFuZ2VgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjcmF0ZWNoYW5nZVxuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVJdGVtLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICB0aGlzLnNlbGVjdGVkKHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKCkgPT09IHRoaXMucmF0ZSk7XG4gIH07XG5cbiAgcmV0dXJuIFBsYXliYWNrUmF0ZU1lbnVJdGVtO1xufShNZW51SXRlbSk7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgUGxheWJhY2tSYXRlTWVudUl0ZW1gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cblBsYXliYWNrUmF0ZU1lbnVJdGVtLnByb3RvdHlwZS5jb250ZW50RWxUeXBlID0gJ2J1dHRvbic7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUGxheWJhY2tSYXRlTWVudUl0ZW0nLCBQbGF5YmFja1JhdGVNZW51SXRlbSk7XG5cbi8qKlxuICogQGZpbGUgcGxheWJhY2stcmF0ZS1tZW51LWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNvbnRyb2xsaW5nIHRoZSBwbGF5YmFjayByYXRlLlxuICpcbiAqIEBleHRlbmRzIE1lbnVCdXR0b25cbiAqL1xuXG52YXIgUGxheWJhY2tSYXRlTWVudUJ1dHRvbiA9IGZ1bmN0aW9uIChfTWVudUJ1dHRvbikge1xuICBpbmhlcml0cyhQbGF5YmFja1JhdGVNZW51QnV0dG9uLCBfTWVudUJ1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBQbGF5YmFja1JhdGVNZW51QnV0dG9uKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24pO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVudUJ1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIF90aGlzLnVwZGF0ZUxhYmVsKCk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdsb2Fkc3RhcnQnLCBfdGhpcy51cGRhdGVWaXNpYmlsaXR5KTtcbiAgICBfdGhpcy5vbihwbGF5ZXIsICdyYXRlY2hhbmdlJywgX3RoaXMudXBkYXRlTGFiZWwpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIGVsID0gX01lbnVCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLmxhYmVsRWxfID0gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wbGF5YmFjay1yYXRlLXZhbHVlJyxcbiAgICAgIGlubmVySFRNTDogJzF4J1xuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5sYWJlbEVsXyk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5sYWJlbEVsXyA9IG51bGw7XG5cbiAgICBfTWVudUJ1dHRvbi5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtcGxheWJhY2stcmF0ZSAnICsgX01lbnVCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkV3JhcHBlckNTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXBsYXliYWNrLXJhdGUgJyArIF9NZW51QnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIHBsYXliYWNrIHJhdGUgbWVudVxuICAgKlxuICAgKiBAcmV0dXJuIHtNZW51fVxuICAgKiAgICAgICAgIE1lbnUgb2JqZWN0IHBvcHVsYXRlZCB3aXRoIHtAbGluayBQbGF5YmFja1JhdGVNZW51SXRlbX1zXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlTWVudSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbnUoKSB7XG4gICAgdmFyIG1lbnUgPSBuZXcgTWVudSh0aGlzLnBsYXllcigpKTtcbiAgICB2YXIgcmF0ZXMgPSB0aGlzLnBsYXliYWNrUmF0ZXMoKTtcblxuICAgIGlmIChyYXRlcykge1xuICAgICAgZm9yICh2YXIgaSA9IHJhdGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIG1lbnUuYWRkQ2hpbGQobmV3IFBsYXliYWNrUmF0ZU1lbnVJdGVtKHRoaXMucGxheWVyKCksIHsgcmF0ZTogcmF0ZXNbaV0gKyAneCcgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZW51O1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIEFSSUEgYWNjZXNzaWJpbGl0eSBhdHRyaWJ1dGVzXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUudXBkYXRlQVJJQUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiB1cGRhdGVBUklBQXR0cmlidXRlcygpIHtcbiAgICAvLyBDdXJyZW50IHBsYXliYWNrIHJhdGVcbiAgICB0aGlzLmVsKCkuc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVlbm93JywgdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgUGxheWJhY2tSYXRlTWVudUJ1dHRvbmAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICAvLyBzZWxlY3QgbmV4dCByYXRlIG9wdGlvblxuICAgIHZhciBjdXJyZW50UmF0ZSA9IHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKCk7XG4gICAgdmFyIHJhdGVzID0gdGhpcy5wbGF5YmFja1JhdGVzKCk7XG5cbiAgICAvLyB0aGlzIHdpbGwgc2VsZWN0IGZpcnN0IG9uZSBpZiB0aGUgbGFzdCBvbmUgY3VycmVudGx5IHNlbGVjdGVkXG4gICAgdmFyIG5ld1JhdGUgPSByYXRlc1swXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyYXRlc1tpXSA+IGN1cnJlbnRSYXRlKSB7XG4gICAgICAgIG5ld1JhdGUgPSByYXRlc1tpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKG5ld1JhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgcG9zc2libGUgcGxheWJhY2sgcmF0ZXNcbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqICAgICAgICAgQWxsIHBvc3NpYmxlIHBsYXliYWNrIHJhdGVzXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUucGxheWJhY2tSYXRlcyA9IGZ1bmN0aW9uIHBsYXliYWNrUmF0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uc18ucGxheWJhY2tSYXRlcyB8fCB0aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnMgJiYgdGhpcy5vcHRpb25zXy5wbGF5ZXJPcHRpb25zLnBsYXliYWNrUmF0ZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIHBsYXliYWNrIHJhdGVzIGlzIHN1cHBvcnRlZCBieSB0aGUgdGVjaFxuICAgKiBhbmQgYW4gYXJyYXkgb2YgcGxheWJhY2sgcmF0ZXMgZXhpc3RzXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgV2hldGhlciBjaGFuZ2luZyBwbGF5YmFjayByYXRlIGlzIHN1cHBvcnRlZFxuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLnBsYXliYWNrUmF0ZVN1cHBvcnRlZCA9IGZ1bmN0aW9uIHBsYXliYWNrUmF0ZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXIoKS50ZWNoXyAmJiB0aGlzLnBsYXllcigpLnRlY2hfLmZlYXR1cmVzUGxheWJhY2tSYXRlICYmIHRoaXMucGxheWJhY2tSYXRlcygpICYmIHRoaXMucGxheWJhY2tSYXRlcygpLmxlbmd0aCA+IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgcGxheWJhY2sgcmF0ZSBjb250cm9scyB3aGVuIHRoZXkncmUgbm8gcGxheWJhY2sgcmF0ZSBvcHRpb25zIHRvIHNlbGVjdFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNsb2Fkc3RhcnRcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS51cGRhdGVWaXNpYmlsaXR5ID0gZnVuY3Rpb24gdXBkYXRlVmlzaWJpbGl0eShldmVudCkge1xuICAgIGlmICh0aGlzLnBsYXliYWNrUmF0ZVN1cHBvcnRlZCgpKSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBidXR0b24gbGFiZWwgd2hlbiByYXRlIGNoYW5nZWRcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjcmF0ZWNoYW5nZVxuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLnVwZGF0ZUxhYmVsID0gZnVuY3Rpb24gdXBkYXRlTGFiZWwoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wbGF5YmFja1JhdGVTdXBwb3J0ZWQoKSkge1xuICAgICAgdGhpcy5sYWJlbEVsXy5pbm5lckhUTUwgPSB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpICsgJ3gnO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUGxheWJhY2tSYXRlTWVudUJ1dHRvbjtcbn0oTWVudUJ1dHRvbik7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgRnVsbHNjcmVlblRvZ2dsZWBzIGNvbnRyb2xzLiBBZGRlZCBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ1BsYXliYWNrIFJhdGUnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXliYWNrUmF0ZU1lbnVCdXR0b24nLCBQbGF5YmFja1JhdGVNZW51QnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBzcGFjZXIuanNcbiAqL1xuLyoqXG4gKiBKdXN0IGFuIGVtcHR5IHNwYWNlciBlbGVtZW50IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gYXBwZW5kIHBvaW50IGZvciBwbHVnaW5zLCBldGMuXG4gKiBBbHNvIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBzcGFjZSBiZXR3ZWVuIGVsZW1lbnRzIHdoZW4gbmVjZXNzYXJ5LlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBTcGFjZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhTcGFjZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFNwYWNlcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTcGFjZXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cbiAgU3BhY2VyLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1zcGFjZXIgJyArIF9Db21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBTcGFjZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKClcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gU3BhY2VyO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1NwYWNlcicsIFNwYWNlcik7XG5cbi8qKlxuICogQGZpbGUgY3VzdG9tLWNvbnRyb2wtc3BhY2VyLmpzXG4gKi9cbi8qKlxuICogU3BhY2VyIHNwZWNpZmljYWxseSBtZWFudCB0byBiZSB1c2VkIGFzIGFuIGluc2VydGlvbiBwb2ludCBmb3IgbmV3IHBsdWdpbnMsIGV0Yy5cbiAqXG4gKiBAZXh0ZW5kcyBTcGFjZXJcbiAqL1xuXG52YXIgQ3VzdG9tQ29udHJvbFNwYWNlciA9IGZ1bmN0aW9uIChfU3BhY2VyKSB7XG4gIGluaGVyaXRzKEN1c3RvbUNvbnRyb2xTcGFjZXIsIF9TcGFjZXIpO1xuXG4gIGZ1bmN0aW9uIEN1c3RvbUNvbnRyb2xTcGFjZXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3VzdG9tQ29udHJvbFNwYWNlcik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1NwYWNlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuICBDdXN0b21Db250cm9sU3BhY2VyLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jdXN0b20tY29udHJvbC1zcGFjZXIgJyArIF9TcGFjZXIucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBDdXN0b21Db250cm9sU3BhY2VyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHZhciBlbCA9IF9TcGFjZXIucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKVxuICAgIH0pO1xuXG4gICAgLy8gTm8tZmxleC90YWJsZS1jZWxsIG1vZGUgcmVxdWlyZXMgdGhlcmUgYmUgc29tZSBjb250ZW50XG4gICAgLy8gaW4gdGhlIGNlbGwgdG8gZmlsbCB0aGUgcmVtYWluaW5nIHNwYWNlIG9mIHRoZSB0YWJsZS5cbiAgICBlbC5pbm5lckhUTUwgPSAnXFx4QTAnO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICByZXR1cm4gQ3VzdG9tQ29udHJvbFNwYWNlcjtcbn0oU3BhY2VyKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDdXN0b21Db250cm9sU3BhY2VyJywgQ3VzdG9tQ29udHJvbFNwYWNlcik7XG5cbi8qKlxuICogQGZpbGUgY29udHJvbC1iYXIuanNcbiAqL1xuLy8gUmVxdWlyZWQgY2hpbGRyZW5cbi8qKlxuICogQ29udGFpbmVyIG9mIG1haW4gY29udHJvbHMuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIENvbnRyb2xCYXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhDb250cm9sQmFyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBDb250cm9sQmFyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRyb2xCYXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIENvbnRyb2xCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jb250cm9sLWJhcicsXG4gICAgICBkaXI6ICdsdHInXG4gICAgfSwge1xuICAgICAgLy8gVGhlIGNvbnRyb2wgYmFyIGlzIGEgZ3JvdXAsIGJ1dCB3ZSBkb24ndCBhcmlhLWxhYmVsIGl0IHRvIGF2b2lkXG4gICAgICAvLyAgb3Zlci1hbm5vdW5jaW5nIGJ5IEpBV1NcbiAgICAgIHJvbGU6ICdncm91cCdcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQ29udHJvbEJhcjtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGBDb250cm9sQmFyYFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuQ29udHJvbEJhci5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ3BsYXlUb2dnbGUnLCAndm9sdW1lUGFuZWwnLCAnY3VycmVudFRpbWVEaXNwbGF5JywgJ3RpbWVEaXZpZGVyJywgJ2R1cmF0aW9uRGlzcGxheScsICdwcm9ncmVzc0NvbnRyb2wnLCAnbGl2ZURpc3BsYXknLCAncmVtYWluaW5nVGltZURpc3BsYXknLCAnY3VzdG9tQ29udHJvbFNwYWNlcicsICdwbGF5YmFja1JhdGVNZW51QnV0dG9uJywgJ2NoYXB0ZXJzQnV0dG9uJywgJ2Rlc2NyaXB0aW9uc0J1dHRvbicsICdzdWJzQ2Fwc0J1dHRvbicsICdhdWRpb1RyYWNrQnV0dG9uJywgJ2Z1bGxzY3JlZW5Ub2dnbGUnXVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDb250cm9sQmFyJywgQ29udHJvbEJhcik7XG5cbi8qKlxuICogQGZpbGUgZXJyb3ItZGlzcGxheS5qc1xuICovXG4vKipcbiAqIEEgZGlzcGxheSB0aGF0IGluZGljYXRlcyBhbiBlcnJvciBoYXMgb2NjdXJyZWQuIFRoaXMgbWVhbnMgdGhhdCB0aGUgdmlkZW9cbiAqIGlzIHVucGxheWFibGUuXG4gKlxuICogQGV4dGVuZHMgTW9kYWxEaWFsb2dcbiAqL1xuXG52YXIgRXJyb3JEaXNwbGF5ID0gZnVuY3Rpb24gKF9Nb2RhbERpYWxvZykge1xuICBpbmhlcml0cyhFcnJvckRpc3BsYXksIF9Nb2RhbERpYWxvZyk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gRXJyb3JEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEVycm9yRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Nb2RhbERpYWxvZy5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAnZXJyb3InLCBfdGhpcy5vcGVuKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBTaW5jZSB2ZXJzaW9uIDUuXG4gICAqL1xuXG5cbiAgRXJyb3JEaXNwbGF5LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1lcnJvci1kaXNwbGF5ICcgKyBfTW9kYWxEaWFsb2cucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbG9jYWxpemVkIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gdGhlIGBQbGF5ZXJgcyBlcnJvci5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBgUGxheWVyYHMgZXJyb3IgbWVzc2FnZSBsb2NhbGl6ZWQgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICAgKi9cblxuXG4gIEVycm9yRGlzcGxheS5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5wbGF5ZXIoKS5lcnJvcigpO1xuXG4gICAgcmV0dXJuIGVycm9yID8gdGhpcy5sb2NhbGl6ZShlcnJvci5tZXNzYWdlKSA6ICcnO1xuICB9O1xuXG4gIHJldHVybiBFcnJvckRpc3BsYXk7XG59KE1vZGFsRGlhbG9nKTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciBhbiBgRXJyb3JEaXNwbGF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuRXJyb3JEaXNwbGF5LnByb3RvdHlwZS5vcHRpb25zXyA9IG1lcmdlT3B0aW9ucyhNb2RhbERpYWxvZy5wcm90b3R5cGUub3B0aW9uc18sIHtcbiAgcGF1c2VPbk9wZW46IGZhbHNlLFxuICBmaWxsQWx3YXlzOiB0cnVlLFxuICB0ZW1wb3Jhcnk6IGZhbHNlLFxuICB1bmNsb3NlYWJsZTogdHJ1ZVxufSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnRXJyb3JEaXNwbGF5JywgRXJyb3JEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLXNldHRpbmdzLmpzXG4gKi9cbnZhciBMT0NBTF9TVE9SQUdFX0tFWSA9ICd2anMtdGV4dC10cmFjay1zZXR0aW5ncyc7XG5cbnZhciBDT0xPUl9CTEFDSyA9IFsnIzAwMCcsICdCbGFjayddO1xudmFyIENPTE9SX0JMVUUgPSBbJyMwMEYnLCAnQmx1ZSddO1xudmFyIENPTE9SX0NZQU4gPSBbJyMwRkYnLCAnQ3lhbiddO1xudmFyIENPTE9SX0dSRUVOID0gWycjMEYwJywgJ0dyZWVuJ107XG52YXIgQ09MT1JfTUFHRU5UQSA9IFsnI0YwRicsICdNYWdlbnRhJ107XG52YXIgQ09MT1JfUkVEID0gWycjRjAwJywgJ1JlZCddO1xudmFyIENPTE9SX1dISVRFID0gWycjRkZGJywgJ1doaXRlJ107XG52YXIgQ09MT1JfWUVMTE9XID0gWycjRkYwJywgJ1llbGxvdyddO1xuXG52YXIgT1BBQ0lUWV9PUEFRVUUgPSBbJzEnLCAnT3BhcXVlJ107XG52YXIgT1BBQ0lUWV9TRU1JID0gWycwLjUnLCAnU2VtaS1UcmFuc3BhcmVudCddO1xudmFyIE9QQUNJVFlfVFJBTlMgPSBbJzAnLCAnVHJhbnNwYXJlbnQnXTtcblxuLy8gQ29uZmlndXJhdGlvbiBmb3IgdGhlIHZhcmlvdXMgPHNlbGVjdD4gZWxlbWVudHMgaW4gdGhlIERPTSBvZiB0aGlzIGNvbXBvbmVudC5cbi8vXG4vLyBQb3NzaWJsZSBrZXlzIGluY2x1ZGU6XG4vL1xuLy8gYGRlZmF1bHRgOlxuLy8gICBUaGUgZGVmYXVsdCBvcHRpb24gaW5kZXguIE9ubHkgbmVlZHMgdG8gYmUgcHJvdmlkZWQgaWYgbm90IHplcm8uXG4vLyBgcGFyc2VyYDpcbi8vICAgQSBmdW5jdGlvbiB3aGljaCBpcyB1c2VkIHRvIHBhcnNlIHRoZSB2YWx1ZSBmcm9tIHRoZSBzZWxlY3RlZCBvcHRpb24gaW5cbi8vICAgYSBjdXN0b21pemVkIHdheS5cbi8vIGBzZWxlY3RvcmA6XG4vLyAgIFRoZSBzZWxlY3RvciB1c2VkIHRvIGZpbmQgdGhlIGFzc29jaWF0ZWQgPHNlbGVjdD4gZWxlbWVudC5cbnZhciBzZWxlY3RDb25maWdzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICBzZWxlY3RvcjogJy52anMtYmctY29sb3IgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtYmFja2dyb3VuZC1jb2xvci0lcycsXG4gICAgbGFiZWw6ICdDb2xvcicsXG4gICAgb3B0aW9uczogW0NPTE9SX0JMQUNLLCBDT0xPUl9XSElURSwgQ09MT1JfUkVELCBDT0xPUl9HUkVFTiwgQ09MT1JfQkxVRSwgQ09MT1JfWUVMTE9XLCBDT0xPUl9NQUdFTlRBLCBDT0xPUl9DWUFOXVxuICB9LFxuXG4gIGJhY2tncm91bmRPcGFjaXR5OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLWJnLW9wYWNpdHkgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtYmFja2dyb3VuZC1vcGFjaXR5LSVzJyxcbiAgICBsYWJlbDogJ1RyYW5zcGFyZW5jeScsXG4gICAgb3B0aW9uczogW09QQUNJVFlfT1BBUVVFLCBPUEFDSVRZX1NFTUksIE9QQUNJVFlfVFJBTlNdXG4gIH0sXG5cbiAgY29sb3I6IHtcbiAgICBzZWxlY3RvcjogJy52anMtZmctY29sb3IgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtZm9yZWdyb3VuZC1jb2xvci0lcycsXG4gICAgbGFiZWw6ICdDb2xvcicsXG4gICAgb3B0aW9uczogW0NPTE9SX1dISVRFLCBDT0xPUl9CTEFDSywgQ09MT1JfUkVELCBDT0xPUl9HUkVFTiwgQ09MT1JfQkxVRSwgQ09MT1JfWUVMTE9XLCBDT0xPUl9NQUdFTlRBLCBDT0xPUl9DWUFOXVxuICB9LFxuXG4gIGVkZ2VTdHlsZToge1xuICAgIHNlbGVjdG9yOiAnLnZqcy1lZGdlLXN0eWxlID4gc2VsZWN0JyxcbiAgICBpZDogJyVzJyxcbiAgICBsYWJlbDogJ1RleHQgRWRnZSBTdHlsZScsXG4gICAgb3B0aW9uczogW1snbm9uZScsICdOb25lJ10sIFsncmFpc2VkJywgJ1JhaXNlZCddLCBbJ2RlcHJlc3NlZCcsICdEZXByZXNzZWQnXSwgWyd1bmlmb3JtJywgJ1VuaWZvcm0nXSwgWydkcm9wc2hhZG93JywgJ0Ryb3BzaGFkb3cnXV1cbiAgfSxcblxuICBmb250RmFtaWx5OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLWZvbnQtZmFtaWx5ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLWZvbnQtZmFtaWx5LSVzJyxcbiAgICBsYWJlbDogJ0ZvbnQgRmFtaWx5JyxcbiAgICBvcHRpb25zOiBbWydwcm9wb3J0aW9uYWxTYW5zU2VyaWYnLCAnUHJvcG9ydGlvbmFsIFNhbnMtU2VyaWYnXSwgWydtb25vc3BhY2VTYW5zU2VyaWYnLCAnTW9ub3NwYWNlIFNhbnMtU2VyaWYnXSwgWydwcm9wb3J0aW9uYWxTZXJpZicsICdQcm9wb3J0aW9uYWwgU2VyaWYnXSwgWydtb25vc3BhY2VTZXJpZicsICdNb25vc3BhY2UgU2VyaWYnXSwgWydjYXN1YWwnLCAnQ2FzdWFsJ10sIFsnc2NyaXB0JywgJ1NjcmlwdCddLCBbJ3NtYWxsLWNhcHMnLCAnU21hbGwgQ2FwcyddXVxuICB9LFxuXG4gIGZvbnRQZXJjZW50OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLWZvbnQtcGVyY2VudCA+IHNlbGVjdCcsXG4gICAgaWQ6ICdjYXB0aW9ucy1mb250LXNpemUtJXMnLFxuICAgIGxhYmVsOiAnRm9udCBTaXplJyxcbiAgICBvcHRpb25zOiBbWycwLjUwJywgJzUwJSddLCBbJzAuNzUnLCAnNzUlJ10sIFsnMS4wMCcsICcxMDAlJ10sIFsnMS4yNScsICcxMjUlJ10sIFsnMS41MCcsICcxNTAlJ10sIFsnMS43NScsICcxNzUlJ10sIFsnMi4wMCcsICcyMDAlJ10sIFsnMy4wMCcsICczMDAlJ10sIFsnNC4wMCcsICc0MDAlJ11dLFxuICAgICdkZWZhdWx0JzogMixcbiAgICBwYXJzZXI6IGZ1bmN0aW9uIHBhcnNlcih2KSB7XG4gICAgICByZXR1cm4gdiA9PT0gJzEuMDAnID8gbnVsbCA6IE51bWJlcih2KTtcbiAgICB9XG4gIH0sXG5cbiAgdGV4dE9wYWNpdHk6IHtcbiAgICBzZWxlY3RvcjogJy52anMtdGV4dC1vcGFjaXR5ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLWZvcmVncm91bmQtb3BhY2l0eS0lcycsXG4gICAgbGFiZWw6ICdUcmFuc3BhcmVuY3knLFxuICAgIG9wdGlvbnM6IFtPUEFDSVRZX09QQVFVRSwgT1BBQ0lUWV9TRU1JXVxuICB9LFxuXG4gIC8vIE9wdGlvbnMgZm9yIHRoaXMgb2JqZWN0IGFyZSBkZWZpbmVkIGJlbG93LlxuICB3aW5kb3dDb2xvcjoge1xuICAgIHNlbGVjdG9yOiAnLnZqcy13aW5kb3ctY29sb3IgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtd2luZG93LWNvbG9yLSVzJyxcbiAgICBsYWJlbDogJ0NvbG9yJ1xuICB9LFxuXG4gIC8vIE9wdGlvbnMgZm9yIHRoaXMgb2JqZWN0IGFyZSBkZWZpbmVkIGJlbG93LlxuICB3aW5kb3dPcGFjaXR5OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLXdpbmRvdy1vcGFjaXR5ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLXdpbmRvdy1vcGFjaXR5LSVzJyxcbiAgICBsYWJlbDogJ1RyYW5zcGFyZW5jeScsXG4gICAgb3B0aW9uczogW09QQUNJVFlfVFJBTlMsIE9QQUNJVFlfU0VNSSwgT1BBQ0lUWV9PUEFRVUVdXG4gIH1cbn07XG5cbnNlbGVjdENvbmZpZ3Mud2luZG93Q29sb3Iub3B0aW9ucyA9IHNlbGVjdENvbmZpZ3MuYmFja2dyb3VuZENvbG9yLm9wdGlvbnM7XG5cbi8qKlxuICogR2V0IHRoZSBhY3R1YWwgdmFsdWUgb2YgYW4gb3B0aW9uLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWVcbiAqICAgICAgICAgVGhlIHZhbHVlIHRvIGdldFxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbcGFyc2VyXVxuICogICAgICAgICBPcHRpb25hbCBmdW5jdGlvbiB0byBhZGp1c3QgdGhlIHZhbHVlLlxuICpcbiAqIEByZXR1cm4ge01peGVkfVxuICogICAgICAgICAtIFdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgbm8gdmFsdWUgZXhpc3RzXG4gKiAgICAgICAgIC0gV2lsbCBiZSBgdW5kZWZpbmVkYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgXCJub25lXCIuXG4gKiAgICAgICAgIC0gV2lsbCBiZSB0aGUgYWN0dWFsIHZhbHVlIG90aGVyd2lzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZU9wdGlvblZhbHVlKHZhbHVlLCBwYXJzZXIpIHtcbiAgaWYgKHBhcnNlcikge1xuICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNlbGVjdGVkIDxvcHRpb24+IGVsZW1lbnQgd2l0aGluIGEgPHNlbGVjdD4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogICAgICAgICB0aGUgZWxlbWVudCB0byBsb29rIGluXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IFtwYXJzZXJdXG4gKiAgICAgICAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFkanVzdCB0aGUgdmFsdWUuXG4gKlxuICogQHJldHVybiB7TWl4ZWR9XG4gKiAgICAgICAgIC0gV2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBubyB2YWx1ZSBleGlzdHNcbiAqICAgICAgICAgLSBXaWxsIGJlIGB1bmRlZmluZWRgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBcIm5vbmVcIi5cbiAqICAgICAgICAgLSBXaWxsIGJlIHRoZSBhY3R1YWwgdmFsdWUgb3RoZXJ3aXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoZWwsIHBhcnNlcikge1xuICB2YXIgdmFsdWUgPSBlbC5vcHRpb25zW2VsLm9wdGlvbnMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG5cbiAgcmV0dXJuIHBhcnNlT3B0aW9uVmFsdWUodmFsdWUsIHBhcnNlcik7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc2VsZWN0ZWQgPG9wdGlvbj4gZWxlbWVudCB3aXRoaW4gYSA8c2VsZWN0PiBlbGVtZW50IGJhc2VkIG9uIGFcbiAqIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgZWxlbWVudCB0byBsb29rIGluLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogICAgICAgIHRoZSBwcm9wZXJ0eSB0byBsb29rIG9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJzZXJdXG4gKiAgICAgICAgT3B0aW9uYWwgZnVuY3Rpb24gdG8gYWRqdXN0IHRoZSB2YWx1ZSBiZWZvcmUgY29tcGFyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldFNlbGVjdGVkT3B0aW9uKGVsLCB2YWx1ZSwgcGFyc2VyKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsLm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGFyc2VPcHRpb25WYWx1ZShlbC5vcHRpb25zW2ldLnZhbHVlLCBwYXJzZXIpID09PSB2YWx1ZSkge1xuICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYW5pcHVsYXRlIFRleHQgVHJhY2tzIHNldHRpbmdzLlxuICpcbiAqIEBleHRlbmRzIE1vZGFsRGlhbG9nXG4gKi9cblxudmFyIFRleHRUcmFja1NldHRpbmdzID0gZnVuY3Rpb24gKF9Nb2RhbERpYWxvZykge1xuICBpbmhlcml0cyhUZXh0VHJhY2tTZXR0aW5ncywgX01vZGFsRGlhbG9nKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrU2V0dGluZ3MocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrU2V0dGluZ3MpO1xuXG4gICAgb3B0aW9ucy50ZW1wb3JhcnkgPSBmYWxzZTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01vZGFsRGlhbG9nLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGVEaXNwbGF5ID0gYmluZChfdGhpcywgX3RoaXMudXBkYXRlRGlzcGxheSk7XG5cbiAgICAvLyBmaWxsIHRoZSBtb2RhbCBhbmQgcHJldGVuZCB3ZSBoYXZlIG9wZW5lZCBpdFxuICAgIF90aGlzLmZpbGwoKTtcbiAgICBfdGhpcy5oYXNCZWVuT3BlbmVkXyA9IF90aGlzLmhhc0JlZW5GaWxsZWRfID0gdHJ1ZTtcblxuICAgIF90aGlzLmVuZERpYWxvZyA9IGNyZWF0ZUVsKCdwJywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtdGV4dCcsXG4gICAgICB0ZXh0Q29udGVudDogX3RoaXMubG9jYWxpemUoJ0VuZCBvZiBkaWFsb2cgd2luZG93LicpXG4gICAgfSk7XG4gICAgX3RoaXMuZWwoKS5hcHBlbmRDaGlsZChfdGhpcy5lbmREaWFsb2cpO1xuXG4gICAgX3RoaXMuc2V0RGVmYXVsdHMoKTtcblxuICAgIC8vIEdyYWIgYHBlcnNpc3RUZXh0VHJhY2tTZXR0aW5nc2AgZnJvbSB0aGUgcGxheWVyIG9wdGlvbnMgaWYgbm90IHBhc3NlZCBpbiBjaGlsZCBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMucGVyc2lzdFRleHRUcmFja1NldHRpbmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIF90aGlzLm9wdGlvbnNfLnBlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncyA9IF90aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnMucGVyc2lzdFRleHRUcmFja1NldHRpbmdzO1xuICAgIH1cblxuICAgIF90aGlzLm9uKF90aGlzLiQoJy52anMtZG9uZS1idXR0b24nKSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2F2ZVNldHRpbmdzKCk7XG4gICAgICBfdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMub24oX3RoaXMuJCgnLnZqcy1kZWZhdWx0LWJ1dHRvbicpLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXREZWZhdWx0cygpO1xuICAgICAgX3RoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuXG4gICAgZWFjaChzZWxlY3RDb25maWdzLCBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICBfdGhpcy5vbihfdGhpcy4kKGNvbmZpZy5zZWxlY3RvciksICdjaGFuZ2UnLCBfdGhpcy51cGRhdGVEaXNwbGF5KTtcbiAgICB9KTtcblxuICAgIGlmIChfdGhpcy5vcHRpb25zXy5wZXJzaXN0VGV4dFRyYWNrU2V0dGluZ3MpIHtcbiAgICAgIF90aGlzLnJlc3RvcmVTZXR0aW5ncygpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5lbmREaWFsb2cgPSBudWxsO1xuXG4gICAgX01vZGFsRGlhbG9nLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIDxzZWxlY3Q+IGVsZW1lbnQgd2l0aCBjb25maWd1cmVkIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogICAgICAgIENvbmZpZ3VyYXRpb24ga2V5IHRvIHVzZSBkdXJpbmcgY3JlYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBBbiBIVE1MIHN0cmluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxTZWxlY3RfID0gZnVuY3Rpb24gY3JlYXRlRWxTZWxlY3RfKGtleSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGxlZ2VuZElkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2xhYmVsJztcblxuICAgIHZhciBjb25maWcgPSBzZWxlY3RDb25maWdzW2tleV07XG4gICAgdmFyIGlkID0gY29uZmlnLmlkLnJlcGxhY2UoJyVzJywgdGhpcy5pZF8pO1xuXG4gICAgcmV0dXJuIFsnPCcgKyB0eXBlICsgJyBpZD1cIicgKyBpZCArICdcIiBjbGFzcz1cIicgKyAodHlwZSA9PT0gJ2xhYmVsJyA/ICd2anMtbGFiZWwnIDogJycpICsgJ1wiPicsIHRoaXMubG9jYWxpemUoY29uZmlnLmxhYmVsKSwgJzwvJyArIHR5cGUgKyAnPicsICc8c2VsZWN0IGFyaWEtbGFiZWxsZWRieT1cIicgKyAobGVnZW5kSWQgIT09ICcnID8gbGVnZW5kSWQgKyAnICcgOiAnJykgKyBpZCArICdcIj4nXS5jb25jYXQoY29uZmlnLm9wdGlvbnMubWFwKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgb3B0aW9uSWQgPSBpZCArICctJyArIG9bMV07XG5cbiAgICAgIHJldHVybiBbJzxvcHRpb24gaWQ9XCInICsgb3B0aW9uSWQgKyAnXCIgdmFsdWU9XCInICsgb1swXSArICdcIiAnLCAnYXJpYS1sYWJlbGxlZGJ5PVwiJyArIChsZWdlbmRJZCAhPT0gJycgPyBsZWdlbmRJZCArICcgJyA6ICcnKSArIGlkICsgJyAnICsgb3B0aW9uSWQgKyAnXCI+JywgX3RoaXMyLmxvY2FsaXplKG9bMV0pLCAnPC9vcHRpb24+J10uam9pbignJyk7XG4gICAgfSkpLmNvbmNhdCgnPC9zZWxlY3Q+Jykuam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBmb3JlZ3JvdW5kIGNvbG9yIGVsZW1lbnQgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEFuIEhUTUwgc3RyaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbEZnQ29sb3JfID0gZnVuY3Rpb24gY3JlYXRlRWxGZ0NvbG9yXygpIHtcbiAgICB2YXIgbGVnZW5kSWQgPSAnY2FwdGlvbnMtdGV4dC1sZWdlbmQtJyArIHRoaXMuaWRfO1xuXG4gICAgcmV0dXJuIFsnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWZnLWNvbG9yIHZqcy10cmFjay1zZXR0aW5nXCI+JywgJzxsZWdlbmQgaWQ9XCInICsgbGVnZW5kSWQgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnVGV4dCcpLCAnPC9sZWdlbmQ+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2NvbG9yJywgbGVnZW5kSWQpLCAnPHNwYW4gY2xhc3M9XCJ2anMtdGV4dC1vcGFjaXR5IHZqcy1vcGFjaXR5XCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ3RleHRPcGFjaXR5JywgbGVnZW5kSWQpLCAnPC9zcGFuPicsICc8L2ZpZWxkc2V0PiddLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYmFja2dyb3VuZCBjb2xvciBlbGVtZW50IGZvciB0aGUgY29tcG9uZW50XG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBBbiBIVE1MIHN0cmluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxCZ0NvbG9yXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsQmdDb2xvcl8oKSB7XG4gICAgdmFyIGxlZ2VuZElkID0gJ2NhcHRpb25zLWJhY2tncm91bmQtJyArIHRoaXMuaWRfO1xuXG4gICAgcmV0dXJuIFsnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWJnLWNvbG9yIHZqcy10cmFjay1zZXR0aW5nXCI+JywgJzxsZWdlbmQgaWQ9XCInICsgbGVnZW5kSWQgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnQmFja2dyb3VuZCcpLCAnPC9sZWdlbmQ+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2JhY2tncm91bmRDb2xvcicsIGxlZ2VuZElkKSwgJzxzcGFuIGNsYXNzPVwidmpzLWJnLW9wYWNpdHkgdmpzLW9wYWNpdHlcIj4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0XygnYmFja2dyb3VuZE9wYWNpdHknLCBsZWdlbmRJZCksICc8L3NwYW4+JywgJzwvZmllbGRzZXQ+J10uam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB3aW5kb3cgY29sb3IgZWxlbWVudCBmb3IgdGhlIGNvbXBvbmVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgQW4gSFRNTCBzdHJpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNyZWF0ZUVsV2luQ29sb3JfID0gZnVuY3Rpb24gY3JlYXRlRWxXaW5Db2xvcl8oKSB7XG4gICAgdmFyIGxlZ2VuZElkID0gJ2NhcHRpb25zLXdpbmRvdy0nICsgdGhpcy5pZF87XG5cbiAgICByZXR1cm4gWyc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtd2luZG93LWNvbG9yIHZqcy10cmFjay1zZXR0aW5nXCI+JywgJzxsZWdlbmQgaWQ9XCInICsgbGVnZW5kSWQgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnV2luZG93JyksICc8L2xlZ2VuZD4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0Xygnd2luZG93Q29sb3InLCBsZWdlbmRJZCksICc8c3BhbiBjbGFzcz1cInZqcy13aW5kb3ctb3BhY2l0eSB2anMtb3BhY2l0eVwiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCd3aW5kb3dPcGFjaXR5JywgbGVnZW5kSWQpLCAnPC9zcGFuPicsICc8L2ZpZWxkc2V0PiddLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgY29sb3IgZWxlbWVudHMgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNyZWF0ZUVsQ29sb3JzXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsQ29sb3JzXygpIHtcbiAgICByZXR1cm4gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10cmFjay1zZXR0aW5ncy1jb2xvcnMnLFxuICAgICAgaW5uZXJIVE1MOiBbdGhpcy5jcmVhdGVFbEZnQ29sb3JfKCksIHRoaXMuY3JlYXRlRWxCZ0NvbG9yXygpLCB0aGlzLmNyZWF0ZUVsV2luQ29sb3JfKCldLmpvaW4oJycpXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBmb250IGVsZW1lbnRzIGZvciB0aGUgY29tcG9uZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxGb250XyA9IGZ1bmN0aW9uIGNyZWF0ZUVsRm9udF8oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdHJhY2stc2V0dGluZ3MtZm9udFwiPicsXG4gICAgICBpbm5lckhUTUw6IFsnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWZvbnQtcGVyY2VudCB2anMtdHJhY2stc2V0dGluZ1wiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCdmb250UGVyY2VudCcsICcnLCAnbGVnZW5kJyksICc8L2ZpZWxkc2V0PicsICc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtZWRnZS1zdHlsZSB2anMtdHJhY2stc2V0dGluZ1wiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCdlZGdlU3R5bGUnLCAnJywgJ2xlZ2VuZCcpLCAnPC9maWVsZHNldD4nLCAnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWZvbnQtZmFtaWx5IHZqcy10cmFjay1zZXR0aW5nXCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2ZvbnRGYW1pbHknLCAnJywgJ2xlZ2VuZCcpLCAnPC9maWVsZHNldD4nXS5qb2luKCcnKVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgY29udHJvbHMgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbENvbnRyb2xzXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsQ29udHJvbHNfKCkge1xuICAgIHZhciBkZWZhdWx0c0Rlc2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6ZSgncmVzdG9yZSBhbGwgc2V0dGluZ3MgdG8gdGhlIGRlZmF1bHQgdmFsdWVzJyk7XG5cbiAgICByZXR1cm4gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10cmFjay1zZXR0aW5ncy1jb250cm9scycsXG4gICAgICBpbm5lckhUTUw6IFsnPGJ1dHRvbiBjbGFzcz1cInZqcy1kZWZhdWx0LWJ1dHRvblwiIHRpdGxlPVwiJyArIGRlZmF1bHRzRGVzY3JpcHRpb24gKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnUmVzZXQnKSwgJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPiAnICsgZGVmYXVsdHNEZXNjcmlwdGlvbiArICc8L3NwYW4+JywgJzwvYnV0dG9uPicsICc8YnV0dG9uIGNsYXNzPVwidmpzLWRvbmUtYnV0dG9uXCI+JyArIHRoaXMubG9jYWxpemUoJ0RvbmUnKSArICc8L2J1dHRvbj4nXS5qb2luKCcnKVxuICAgIH0pO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICByZXR1cm4gW3RoaXMuY3JlYXRlRWxDb2xvcnNfKCksIHRoaXMuY3JlYXRlRWxGb250XygpLCB0aGlzLmNyZWF0ZUVsQ29udHJvbHNfKCldO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uIGxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKCdDYXB0aW9uIFNldHRpbmdzIERpYWxvZycpO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5kZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKCdCZWdpbm5pbmcgb2YgZGlhbG9nIHdpbmRvdy4gRXNjYXBlIHdpbGwgY2FuY2VsIGFuZCBjbG9zZSB0aGUgd2luZG93LicpO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gX01vZGFsRGlhbG9nLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcykgKyAnIHZqcy10ZXh0LXRyYWNrLXNldHRpbmdzJztcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3Qgb2YgdGV4dCB0cmFjayBzZXR0aW5ncyAob3IgbnVsbCkuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBBbiBvYmplY3Qgd2l0aCBjb25maWcgdmFsdWVzIHBhcnNlZCBmcm9tIHRoZSBET00gb3IgbG9jYWxTdG9yYWdlLlxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiBnZXRWYWx1ZXMoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICByZXR1cm4gcmVkdWNlKHNlbGVjdENvbmZpZ3MsIGZ1bmN0aW9uIChhY2N1bSwgY29uZmlnLCBrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoX3RoaXMzLiQoY29uZmlnLnNlbGVjdG9yKSwgY29uZmlnLnBhcnNlcik7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFjY3VtW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0ZXh0IHRyYWNrIHNldHRpbmdzIGZyb20gYW4gb2JqZWN0IG9mIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlc1xuICAgKiAgICAgICAgQW4gb2JqZWN0IHdpdGggY29uZmlnIHZhbHVlcyBwYXJzZWQgZnJvbSB0aGUgRE9NIG9yIGxvY2FsU3RvcmFnZS5cbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24gc2V0VmFsdWVzKHZhbHVlcykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgZWFjaChzZWxlY3RDb25maWdzLCBmdW5jdGlvbiAoY29uZmlnLCBrZXkpIHtcbiAgICAgIHNldFNlbGVjdGVkT3B0aW9uKF90aGlzNC4kKGNvbmZpZy5zZWxlY3RvciksIHZhbHVlc1trZXldLCBjb25maWcucGFyc2VyKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhbGwgYDxzZWxlY3Q+YCBlbGVtZW50cyB0byB0aGVpciBkZWZhdWx0IHZhbHVlcy5cbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiBzZXREZWZhdWx0cygpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIGVhY2goc2VsZWN0Q29uZmlncywgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgdmFyIGluZGV4ID0gY29uZmlnLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBjb25maWdbJ2RlZmF1bHQnXSA6IDA7XG5cbiAgICAgIF90aGlzNS4kKGNvbmZpZy5zZWxlY3Rvcikuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXN0b3JlIHRleHR0cmFjayBzZXR0aW5ncyBmcm9tIGxvY2FsU3RvcmFnZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5yZXN0b3JlU2V0dGluZ3MgPSBmdW5jdGlvbiByZXN0b3JlU2V0dGluZ3MoKSB7XG4gICAgdmFyIHZhbHVlcyA9IHZvaWQgMDtcblxuICAgIHRyeSB7XG4gICAgICB2YWx1ZXMgPSBKU09OLnBhcnNlKHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nJDEud2FybihlcnIpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgIHRoaXMuc2V0VmFsdWVzKHZhbHVlcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTYXZlIHRleHQgdHJhY2sgc2V0dGluZ3MgdG8gbG9jYWxTdG9yYWdlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLnNhdmVTZXR0aW5ncyA9IGZ1bmN0aW9uIHNhdmVTZXR0aW5ncygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9uc18ucGVyc2lzdFRleHRUcmFja1NldHRpbmdzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCk7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkodmFsdWVzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oTE9DQUxfU1RPUkFHRV9LRVkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nJDEud2FybihlcnIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGRpc3BsYXkgb2YgdGV4dCB0cmFjayBzZXR0aW5nc1xuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5ID0gZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICB2YXIgdHREaXNwbGF5ID0gdGhpcy5wbGF5ZXJfLmdldENoaWxkKCd0ZXh0VHJhY2tEaXNwbGF5Jyk7XG5cbiAgICBpZiAodHREaXNwbGF5KSB7XG4gICAgICB0dERpc3BsYXkudXBkYXRlRGlzcGxheSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogY29uZGl0aW9uYWxseSBibHVyIHRoZSBlbGVtZW50IGFuZCByZWZvY3VzIHRoZSBjYXB0aW9ucyBidXR0b25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY29uZGl0aW9uYWxCbHVyXyA9IGZ1bmN0aW9uIGNvbmRpdGlvbmFsQmx1cl8oKSB7XG4gICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfID0gbnVsbDtcbiAgICB0aGlzLm9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuXG4gICAgdmFyIGNiID0gdGhpcy5wbGF5ZXJfLmNvbnRyb2xCYXI7XG4gICAgdmFyIHN1YnNDYXBzQnRuID0gY2IgJiYgY2Iuc3Vic0NhcHNCdXR0b247XG4gICAgdmFyIGNjQnRuID0gY2IgJiYgY2IuY2FwdGlvbnNCdXR0b247XG5cbiAgICBpZiAoc3Vic0NhcHNCdG4pIHtcbiAgICAgIHN1YnNDYXBzQnRuLmZvY3VzKCk7XG4gICAgfSBlbHNlIGlmIChjY0J0bikge1xuICAgICAgY2NCdG4uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFja1NldHRpbmdzO1xufShNb2RhbERpYWxvZyk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGV4dFRyYWNrU2V0dGluZ3MnLCBUZXh0VHJhY2tTZXR0aW5ncyk7XG5cbnZhciBfdGVtcGxhdGVPYmplY3QkMiA9IHRhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFsnVGV4dCBUcmFja3MgYXJlIGJlaW5nIGxvYWRlZCBmcm9tIGFub3RoZXIgb3JpZ2luIGJ1dCB0aGUgY3Jvc3NvcmlnaW4gYXR0cmlidXRlIGlzblxcJ3QgdXNlZC5cXG4gICAgICAgICAgICBUaGlzIG1heSBwcmV2ZW50IHRleHQgdHJhY2tzIGZyb20gbG9hZGluZy4nXSwgWydUZXh0IFRyYWNrcyBhcmUgYmVpbmcgbG9hZGVkIGZyb20gYW5vdGhlciBvcmlnaW4gYnV0IHRoZSBjcm9zc29yaWdpbiBhdHRyaWJ1dGUgaXNuXFwndCB1c2VkLlxcbiAgICAgICAgICAgIFRoaXMgbWF5IHByZXZlbnQgdGV4dCB0cmFja3MgZnJvbSBsb2FkaW5nLiddKTtcblxuLyoqXG4gKiBAZmlsZSBodG1sNS5qc1xuICovXG4vKipcbiAqIEhUTUw1IE1lZGlhIENvbnRyb2xsZXIgLSBXcmFwcGVyIGZvciBIVE1MNSBNZWRpYSBBUElcbiAqXG4gKiBAbWl4ZXMgVGVjaH5Tb3VjZUhhbmRsZXJBZGRpdGlvbnNcbiAqIEBleHRlbmRzIFRlY2hcbiAqL1xuXG52YXIgSHRtbDUgPSBmdW5jdGlvbiAoX1RlY2gpIHtcbiAgaW5oZXJpdHMoSHRtbDUsIF9UZWNoKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgVGVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gcmVhZHlcbiAgICogICAgICAgIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgYEhUTUw1YCBUZWNoIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gSHRtbDUob3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBIdG1sNSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZWNoLmNhbGwodGhpcywgb3B0aW9ucywgcmVhZHkpKTtcblxuICAgIHZhciBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcbiAgICB2YXIgY3Jvc3NvcmlnaW5UcmFja3MgPSBmYWxzZTtcblxuICAgIC8vIFNldCB0aGUgc291cmNlIGlmIG9uZSBpcyBwcm92aWRlZFxuICAgIC8vIDEpIENoZWNrIGlmIHRoZSBzb3VyY2UgaXMgbmV3IChpZiBub3QsIHdlIHdhbnQgdG8ga2VlcCB0aGUgb3JpZ2luYWwgc28gcGxheWJhY2sgaXNuJ3QgaW50ZXJydXB0ZWQpXG4gICAgLy8gMikgQ2hlY2sgdG8gc2VlIGlmIHRoZSBuZXR3b3JrIHN0YXRlIG9mIHRoZSB0YWcgd2FzIGZhaWxlZCBhdCBpbml0LCBhbmQgaWYgc28sIHJlc2V0IHRoZSBzb3VyY2VcbiAgICAvLyBhbnl3YXkgc28gdGhlIGVycm9yIGdldHMgZmlyZWQuXG4gICAgaWYgKHNvdXJjZSAmJiAoX3RoaXMuZWxfLmN1cnJlbnRTcmMgIT09IHNvdXJjZS5zcmMgfHwgb3B0aW9ucy50YWcgJiYgb3B0aW9ucy50YWcuaW5pdE5ldHdvcmtTdGF0ZV8gPT09IDMpKSB7XG4gICAgICBfdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuaGFuZGxlTGF0ZUluaXRfKF90aGlzLmVsXyk7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLmVsXy5oYXNDaGlsZE5vZGVzKCkpIHtcblxuICAgICAgdmFyIG5vZGVzID0gX3RoaXMuZWxfLmNoaWxkTm9kZXM7XG4gICAgICB2YXIgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgcmVtb3ZlTm9kZXMgPSBbXTtcblxuICAgICAgd2hpbGUgKG5vZGVzTGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tub2Rlc0xlbmd0aF07XG4gICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICd0cmFjaycpIHtcbiAgICAgICAgICBpZiAoIV90aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgICAgICAgLy8gRW1wdHkgdmlkZW8gdGFnIHRyYWNrcyBzbyB0aGUgYnVpbHQtaW4gcGxheWVyIGRvZXNuJ3QgdXNlIHRoZW0gYWxzby5cbiAgICAgICAgICAgIC8vIFRoaXMgbWF5IG5vdCBiZSBmYXN0IGVub3VnaCB0byBzdG9wIEhUTUw1IGJyb3dzZXJzIGZyb20gcmVhZGluZyB0aGUgdGFnc1xuICAgICAgICAgICAgLy8gc28gd2UnbGwgbmVlZCB0byB0dXJuIG9mZiBhbnkgZGVmYXVsdCB0cmFja3MgaWYgd2UncmUgbWFudWFsbHkgZG9pbmdcbiAgICAgICAgICAgIC8vIGNhcHRpb25zIGFuZCBzdWJ0aXRsZXMuIHZpZGVvRWxlbWVudC50ZXh0VHJhY2tzXG4gICAgICAgICAgICByZW1vdmVOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzdG9yZSBIVE1MVHJhY2tFbGVtZW50IGFuZCBUZXh0VHJhY2sgdG8gcmVtb3RlIGxpc3RcbiAgICAgICAgICAgIF90aGlzLnJlbW90ZVRleHRUcmFja0VscygpLmFkZFRyYWNrRWxlbWVudF8obm9kZSk7XG4gICAgICAgICAgICBfdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkuYWRkVHJhY2sobm9kZS50cmFjayk7XG4gICAgICAgICAgICBfdGhpcy50ZXh0VHJhY2tzKCkuYWRkVHJhY2sobm9kZS50cmFjayk7XG4gICAgICAgICAgICBpZiAoIWNyb3Nzb3JpZ2luVHJhY2tzICYmICFfdGhpcy5lbF8uaGFzQXR0cmlidXRlKCdjcm9zc29yaWdpbicpICYmIGlzQ3Jvc3NPcmlnaW4obm9kZS5zcmMpKSB7XG4gICAgICAgICAgICAgIGNyb3Nzb3JpZ2luVHJhY2tzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdmVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfdGhpcy5lbF8ucmVtb3ZlQ2hpbGQocmVtb3ZlTm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aGlzLnByb3h5TmF0aXZlVHJhY2tzXygpO1xuICAgIGlmIChfdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MgJiYgY3Jvc3NvcmlnaW5UcmFja3MpIHtcbiAgICAgIGxvZyQxLndhcm4odHNtbChfdGVtcGxhdGVPYmplY3QkMikpO1xuICAgIH1cblxuICAgIC8vIHByZXZlbnQgaU9TIFNhZmFyaSBmcm9tIGRpc2FibGluZyBtZXRhZGF0YSB0ZXh0IHRyYWNrcyBkdXJpbmcgbmF0aXZlIHBsYXliYWNrXG4gICAgX3RoaXMucmVzdG9yZU1ldGFkYXRhVHJhY2tzSW5JT1NOYXRpdmVQbGF5ZXJfKCk7XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgbmF0aXZlIGNvbnRyb2xzIHNob3VsZCBiZSB1c2VkXG4gICAgLy8gT3VyIGdvYWwgc2hvdWxkIGJlIHRvIGdldCB0aGUgY3VzdG9tIGNvbnRyb2xzIG9uIG1vYmlsZSBzb2xpZCBldmVyeXdoZXJlXG4gICAgLy8gc28gd2UgY2FuIHJlbW92ZSB0aGlzIGFsbCB0b2dldGhlci4gUmlnaHQgbm93IHRoaXMgd2lsbCBibG9jayBjdXN0b21cbiAgICAvLyBjb250cm9scyBvbiB0b3VjaCBlbmFibGVkIGxhcHRvcHMgbGlrZSB0aGUgQ2hyb21lIFBpeGVsXG4gICAgaWYgKChUT1VDSF9FTkFCTEVEIHx8IElTX0lQSE9ORSB8fCBJU19OQVRJVkVfQU5EUk9JRCkgJiYgb3B0aW9ucy5uYXRpdmVDb250cm9sc0ZvclRvdWNoID09PSB0cnVlKSB7XG4gICAgICBfdGhpcy5zZXRDb250cm9scyh0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBvbiBpT1MsIHdlIHdhbnQgdG8gcHJveHkgYHdlYmtpdGJlZ2luZnVsbHNjcmVlbmAgYW5kIGB3ZWJraXRlbmRmdWxsc2NyZWVuYFxuICAgIC8vIGludG8gYSBgZnVsbHNjcmVlbmNoYW5nZWAgZXZlbnRcbiAgICBfdGhpcy5wcm94eVdlYmtpdEZ1bGxzY3JlZW5fKCk7XG5cbiAgICBfdGhpcy50cmlnZ2VyUmVhZHkoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZSBvZiBgSFRNTDVgIG1lZGlhIGVsZW1lbnQgYW5kIHJlbW92ZSBhbGwgdHJhY2tzLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBIdG1sNS5kaXNwb3NlTWVkaWFFbGVtZW50KHRoaXMuZWxfKTtcbiAgICB0aGlzLm9wdGlvbnNfID0gbnVsbDtcblxuICAgIC8vIHRlY2ggd2lsbCBoYW5kbGUgY2xlYXJpbmcgb2YgdGhlIGVtdWxhdGVkIHRyYWNrIGxpc3RcbiAgICBfVGVjaC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIGEgY2FwdGlvbnMgdHJhY2sgaXMgZW5hYmxlZCBpbiB0aGUgaU9TIFNhZmFyaSBuYXRpdmUgcGxheWVyLCBhbGwgb3RoZXJcbiAgICogdHJhY2tzIGFyZSBkaXNhYmxlZCAoaW5jbHVkaW5nIG1ldGFkYXRhIHRyYWNrcyksIHdoaWNoIG51bGxzIGFsbCBvZiB0aGVpclxuICAgKiBhc3NvY2lhdGVkIGN1ZSBwb2ludHMuIFRoaXMgd2lsbCByZXN0b3JlIG1ldGFkYXRhIHRyYWNrcyB0byB0aGVpciBwcmUtZnVsbHNjcmVlblxuICAgKiBzdGF0ZSBpbiB0aG9zZSBjYXNlcyBzbyB0aGF0IGN1ZSBwb2ludHMgYXJlIG5vdCBuZWVkbGVzc2x5IGxvc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnJlc3RvcmVNZXRhZGF0YVRyYWNrc0luSU9TTmF0aXZlUGxheWVyXyA9IGZ1bmN0aW9uIHJlc3RvcmVNZXRhZGF0YVRyYWNrc0luSU9TTmF0aXZlUGxheWVyXygpIHtcbiAgICB2YXIgdGV4dFRyYWNrcyA9IHRoaXMudGV4dFRyYWNrcygpO1xuICAgIHZhciBtZXRhZGF0YVRyYWNrc1ByZUZ1bGxzY3JlZW5TdGF0ZSA9IHZvaWQgMDtcblxuICAgIC8vIGNhcHR1cmVzIGEgc25hcHNob3Qgb2YgZXZlcnkgbWV0YWRhdGEgdHJhY2sncyBjdXJyZW50IHN0YXRlXG4gICAgdmFyIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QgPSBmdW5jdGlvbiB0YWtlTWV0YWRhdGFUcmFja1NuYXBzaG90KCkge1xuICAgICAgbWV0YWRhdGFUcmFja3NQcmVGdWxsc2NyZWVuU3RhdGUgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRleHRUcmFja3NbaV07XG5cbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdtZXRhZGF0YScpIHtcbiAgICAgICAgICBtZXRhZGF0YVRyYWNrc1ByZUZ1bGxzY3JlZW5TdGF0ZS5wdXNoKHtcbiAgICAgICAgICAgIHRyYWNrOiB0cmFjayxcbiAgICAgICAgICAgIHN0b3JlZE1vZGU6IHRyYWNrLm1vZGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBzbmFwc2hvdCBlYWNoIG1ldGFkYXRhIHRyYWNrJ3MgaW5pdGlhbCBzdGF0ZSwgYW5kIHVwZGF0ZSB0aGUgc25hcHNob3RcbiAgICAvLyBlYWNoIHRpbWUgdGhlcmUgaXMgYSB0cmFjayAnY2hhbmdlJyBldmVudFxuICAgIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QoKTtcbiAgICB0ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QpO1xuXG4gICAgdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QpO1xuICAgIH0pO1xuXG4gICAgdmFyIHJlc3RvcmVUcmFja01vZGUgPSBmdW5jdGlvbiByZXN0b3JlVHJhY2tNb2RlKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhZGF0YVRyYWNrc1ByZUZ1bGxzY3JlZW5TdGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3RvcmVkVHJhY2sgPSBtZXRhZGF0YVRyYWNrc1ByZUZ1bGxzY3JlZW5TdGF0ZVtpXTtcblxuICAgICAgICBpZiAoc3RvcmVkVHJhY2sudHJhY2subW9kZSA9PT0gJ2Rpc2FibGVkJyAmJiBzdG9yZWRUcmFjay50cmFjay5tb2RlICE9PSBzdG9yZWRUcmFjay5zdG9yZWRNb2RlKSB7XG4gICAgICAgICAgc3RvcmVkVHJhY2sudHJhY2subW9kZSA9IHN0b3JlZFRyYWNrLnN0b3JlZE1vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHdlIG9ubHkgd2FudCB0aGlzIGhhbmRsZXIgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIGZpcnN0ICdjaGFuZ2UnIGV2ZW50XG4gICAgICB0ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHJlc3RvcmVUcmFja01vZGUpO1xuICAgIH07XG5cbiAgICAvLyB3aGVuIHdlIGVudGVyIGZ1bGxzY3JlZW4gcGxheWJhY2ssIHN0b3AgdXBkYXRpbmcgdGhlIHNuYXBzaG90IGFuZFxuICAgIC8vIHJlc3RvcmUgYWxsIHRyYWNrIG1vZGVzIHRvIHRoZWlyIHByZS1mdWxsc2NyZWVuIHN0YXRlXG4gICAgdGhpcy5vbignd2Via2l0YmVnaW5mdWxsc2NyZWVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgdGV4dFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0YWtlTWV0YWRhdGFUcmFja1NuYXBzaG90KTtcblxuICAgICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBiZWZvcmUgYWRkaW5nIGl0IGp1c3QgaW4gY2FzZSBpdCB3YXNuJ3QgcHJldmlvdXNseSByZW1vdmVkXG4gICAgICB0ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHJlc3RvcmVUcmFja01vZGUpO1xuICAgICAgdGV4dFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCByZXN0b3JlVHJhY2tNb2RlKTtcbiAgICB9KTtcblxuICAgIC8vIHN0YXJ0IHVwZGF0aW5nIHRoZSBzbmFwc2hvdCBhZ2FpbiBhZnRlciBsZWF2aW5nIGZ1bGxzY3JlZW5cbiAgICB0aGlzLm9uKCd3ZWJraXRlbmRmdWxsc2NyZWVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBiZWZvcmUgYWRkaW5nIGl0IGp1c3QgaW4gY2FzZSBpdCB3YXNuJ3QgcHJldmlvdXNseSByZW1vdmVkXG4gICAgICB0ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QpO1xuICAgICAgdGV4dFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0YWtlTWV0YWRhdGFUcmFja1NuYXBzaG90KTtcblxuICAgICAgLy8gcmVtb3ZlIHRoZSByZXN0b3JlVHJhY2tNb2RlIGhhbmRsZXIgaW4gY2FzZSBpdCB3YXNuJ3QgdHJpZ2dlcmVkIGR1cmluZyBmdWxsc2NyZWVuIHBsYXliYWNrXG4gICAgICB0ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHJlc3RvcmVUcmFja01vZGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm94eSBhbGwgbmF0aXZlIHRyYWNrIGxpc3QgZXZlbnRzIHRvIG91ciB0cmFjayBsaXN0cyBpZiB0aGUgYnJvd3NlciB3ZSBhcmUgcGxheWluZ1xuICAgKiBpbiBzdXBwb3J0cyB0aGF0IHR5cGUgb2YgdHJhY2sgbGlzdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUucHJveHlOYXRpdmVUcmFja3NfID0gZnVuY3Rpb24gcHJveHlOYXRpdmVUcmFja3NfKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgTk9STUFMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBwcm9wcyA9IE5PUk1BTFtuYW1lXTtcbiAgICAgIHZhciBlbFRyYWNrcyA9IF90aGlzMi5lbCgpW3Byb3BzLmdldHRlck5hbWVdO1xuICAgICAgdmFyIHRlY2hUcmFja3MgPSBfdGhpczJbcHJvcHMuZ2V0dGVyTmFtZV0oKTtcblxuICAgICAgaWYgKCFfdGhpczJbJ2ZlYXR1cmVzTmF0aXZlJyArIHByb3BzLmNhcGl0YWxOYW1lICsgJ1RyYWNrcyddIHx8ICFlbFRyYWNrcyB8fCAhZWxUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbGlzdGVuZXJzID0ge1xuICAgICAgICBjaGFuZ2U6IGZ1bmN0aW9uIGNoYW5nZShlKSB7XG4gICAgICAgICAgdGVjaFRyYWNrcy50cmlnZ2VyKHtcbiAgICAgICAgICAgIHR5cGU6ICdjaGFuZ2UnLFxuICAgICAgICAgICAgdGFyZ2V0OiB0ZWNoVHJhY2tzLFxuICAgICAgICAgICAgY3VycmVudFRhcmdldDogdGVjaFRyYWNrcyxcbiAgICAgICAgICAgIHNyY0VsZW1lbnQ6IHRlY2hUcmFja3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkdHJhY2s6IGZ1bmN0aW9uIGFkZHRyYWNrKGUpIHtcbiAgICAgICAgICB0ZWNoVHJhY2tzLmFkZFRyYWNrKGUudHJhY2spO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmV0cmFjazogZnVuY3Rpb24gcmVtb3ZldHJhY2soZSkge1xuICAgICAgICAgIHRlY2hUcmFja3MucmVtb3ZlVHJhY2soZS50cmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgcmVtb3ZlT2xkVHJhY2tzID0gZnVuY3Rpb24gcmVtb3ZlT2xkVHJhY2tzKCkge1xuICAgICAgICB2YXIgcmVtb3ZlVHJhY2tzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZWNoVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsVHJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoZWxUcmFja3Nbal0gPT09IHRlY2hUcmFja3NbaV0pIHtcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICByZW1vdmVUcmFja3MucHVzaCh0ZWNoVHJhY2tzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAocmVtb3ZlVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIHRlY2hUcmFja3MucmVtb3ZlVHJhY2socmVtb3ZlVHJhY2tzLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBPYmplY3Qua2V5cyhsaXN0ZW5lcnMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbZXZlbnROYW1lXTtcblxuICAgICAgICBlbFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICBfdGhpczIub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlbFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZW1vdmUgKG5hdGl2ZSkgdHJhY2tzIHRoYXQgYXJlIG5vdCB1c2VkIGFueW1vcmVcbiAgICAgIF90aGlzMi5vbignbG9hZHN0YXJ0JywgcmVtb3ZlT2xkVHJhY2tzKTtcbiAgICAgIF90aGlzMi5vbignZGlzcG9zZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIub2ZmKCdsb2Fkc3RhcnQnLCByZW1vdmVPbGRUcmFja3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYEh0bWw1YCBUZWNoJ3MgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5vcHRpb25zXy50YWc7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgbW92aW5nIHRoZSBlbGVtZW50IGludG8gdGhlIGJveC5cbiAgICAvLyBPbiB0aGUgaVBob25lIHZpZGVvIHdpbGwgYnJlYWsgaWYgeW91IG1vdmUgdGhlIGVsZW1lbnQsXG4gICAgLy8gU28gd2UgaGF2ZSB0byBjcmVhdGUgYSBicmFuZCBuZXcgZWxlbWVudC5cbiAgICAvLyBJZiB3ZSBpbmdlc3RlZCB0aGUgcGxheWVyIGRpdiwgd2UgZG8gbm90IG5lZWQgdG8gbW92ZSB0aGUgbWVkaWEgZWxlbWVudC5cbiAgICBpZiAoIWVsIHx8ICEodGhpcy5vcHRpb25zXy5wbGF5ZXJFbEluZ2VzdCB8fCB0aGlzLm1vdmluZ01lZGlhRWxlbWVudEluRE9NKSkge1xuXG4gICAgICAvLyBJZiB0aGUgb3JpZ2luYWwgdGFnIGlzIHN0aWxsIHRoZXJlLCBjbG9uZSBhbmQgcmVtb3ZlIGl0LlxuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNsb25lLCBlbCk7XG4gICAgICAgIH1cbiAgICAgICAgSHRtbDUuZGlzcG9zZU1lZGlhRWxlbWVudChlbCk7XG4gICAgICAgIGVsID0gY2xvbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIG5hdGl2ZSBjb250cm9scyBzaG91bGQgYmUgdXNlZFxuICAgICAgICB2YXIgdGFnQXR0cmlidXRlcyA9IHRoaXMub3B0aW9uc18udGFnICYmIGdldEF0dHJpYnV0ZXModGhpcy5vcHRpb25zXy50YWcpO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IG1lcmdlT3B0aW9ucyh7fSwgdGFnQXR0cmlidXRlcyk7XG5cbiAgICAgICAgaWYgKCFUT1VDSF9FTkFCTEVEIHx8IHRoaXMub3B0aW9uc18ubmF0aXZlQ29udHJvbHNGb3JUb3VjaCAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLmNvbnRyb2xzO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0QXR0cmlidXRlcyhlbCwgYXNzaWduKGF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICBpZDogdGhpcy5vcHRpb25zXy50ZWNoSWQsXG4gICAgICAgICAgJ2NsYXNzJzogJ3Zqcy10ZWNoJ1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGVsLnBsYXllcklkID0gdGhpcy5vcHRpb25zXy5wbGF5ZXJJZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc18ucHJlbG9hZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHNldEF0dHJpYnV0ZShlbCwgJ3ByZWxvYWQnLCB0aGlzLm9wdGlvbnNfLnByZWxvYWQpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzcGVjaWZpYyB0YWcgc2V0dGluZ3MsIGluIGNhc2UgdGhleSB3ZXJlIG92ZXJyaWRkZW5cbiAgICAvLyBgYXV0b3BsYXlgIGhhcyB0byBiZSAqbGFzdCogc28gdGhhdCBgbXV0ZWRgIGFuZCBgcGxheXNpbmxpbmVgIGFyZSBwcmVzZW50XG4gICAgLy8gd2hlbiBpT1MvU2FmYXJpIG9yIG90aGVyIGJyb3dzZXJzIGF0dGVtcHQgdG8gYXV0b3BsYXkuXG4gICAgdmFyIHNldHRpbmdzQXR0cnMgPSBbJ2xvb3AnLCAnbXV0ZWQnLCAncGxheXNpbmxpbmUnLCAnYXV0b3BsYXknXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0dGluZ3NBdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF0dHIgPSBzZXR0aW5nc0F0dHJzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5vcHRpb25zX1thdHRyXTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgc2V0QXR0cmlidXRlKGVsLCBhdHRyLCBhdHRyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVBdHRyaWJ1dGUoZWwsIGF0dHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsW2F0dHJdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIHdpbGwgYmUgdHJpZ2dlcmVkIGlmIHRoZSBsb2Fkc3RhcnQgZXZlbnQgaGFzIGFscmVhZHkgZmlyZWQsIGJlZm9yZSB2aWRlb2pzIHdhc1xuICAgKiByZWFkeS4gVHdvIGtub3duIGV4YW1wbGVzIG9mIHdoZW4gdGhpcyBjYW4gaGFwcGVuIGFyZTpcbiAgICogMS4gSWYgd2UncmUgbG9hZGluZyB0aGUgcGxheWJhY2sgb2JqZWN0IGFmdGVyIGl0IGhhcyBzdGFydGVkIGxvYWRpbmdcbiAgICogMi4gVGhlIG1lZGlhIGlzIGFscmVhZHkgcGxheWluZyB0aGUgKG9mdGVuIHdpdGggYXV0b3BsYXkgb24pIHRoZW5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGZpcmUgYW5vdGhlciBsb2Fkc3RhcnQgc28gdGhhdCB2aWRlb2pzIGNhbiBjYXRjaHVwLlxuICAgKlxuICAgKiBAZmlyZXMgVGVjaCNsb2Fkc3RhcnRcbiAgICpcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIHJldHVybnMgbm90aGluZy5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuaGFuZGxlTGF0ZUluaXRfID0gZnVuY3Rpb24gaGFuZGxlTGF0ZUluaXRfKGVsKSB7XG4gICAgaWYgKGVsLm5ldHdvcmtTdGF0ZSA9PT0gMCB8fCBlbC5uZXR3b3JrU3RhdGUgPT09IDMpIHtcbiAgICAgIC8vIFRoZSB2aWRlbyBlbGVtZW50IGhhc24ndCBzdGFydGVkIGxvYWRpbmcgdGhlIHNvdXJjZSB5ZXRcbiAgICAgIC8vIG9yIGRpZG4ndCBmaW5kIGEgc291cmNlXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPT09IDApIHtcbiAgICAgIC8vIE5ldHdvcmtTdGF0ZSBpcyBzZXQgc3luY2hyb25vdXNseSBCVVQgbG9hZHN0YXJ0IGlzIGZpcmVkIGF0IHRoZVxuICAgICAgLy8gZW5kIG9mIHRoZSBjdXJyZW50IHN0YWNrLCB1c3VhbGx5IGJlZm9yZSBzZXRJbnRlcnZhbChmbiwgMCkuXG4gICAgICAvLyBTbyBhdCB0aGlzIHBvaW50IHdlIGtub3cgbG9hZHN0YXJ0IG1heSBoYXZlIGFscmVhZHkgZmlyZWQgb3IgaXNcbiAgICAgIC8vIGFib3V0IHRvIGZpcmUsIGFuZCBlaXRoZXIgd2F5IHRoZSBwbGF5ZXIgaGFzbid0IHNlZW4gaXQgeWV0LlxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBmaXJlIGxvYWRzdGFydCBwcmVtYXR1cmVseSBoZXJlIGFuZCBjYXVzZSBhXG4gICAgICAvLyBkb3VibGUgbG9hZHN0YXJ0IHNvIHdlJ2xsIHdhaXQgYW5kIHNlZSBpZiBpdCBoYXBwZW5zIGJldHdlZW4gbm93XG4gICAgICAvLyBhbmQgdGhlIG5leHQgbG9vcCwgYW5kIGZpcmUgaXQgaWYgbm90LlxuICAgICAgLy8gSE9XRVZFUiwgd2UgYWxzbyB3YW50IHRvIG1ha2Ugc3VyZSBpdCBmaXJlcyBiZWZvcmUgbG9hZGVkbWV0YWRhdGFcbiAgICAgIC8vIHdoaWNoIGNvdWxkIGFsc28gaGFwcGVuIGJldHdlZW4gbm93IGFuZCB0aGUgbmV4dCBsb29wLCBzbyB3ZSdsbFxuICAgICAgLy8gd2F0Y2ggZm9yIHRoYXQgYWxzby5cbiAgICAgIHZhciBsb2Fkc3RhcnRGaXJlZCA9IGZhbHNlO1xuICAgICAgdmFyIHNldExvYWRzdGFydEZpcmVkID0gZnVuY3Rpb24gc2V0TG9hZHN0YXJ0RmlyZWQoKSB7XG4gICAgICAgIGxvYWRzdGFydEZpcmVkID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMub24oJ2xvYWRzdGFydCcsIHNldExvYWRzdGFydEZpcmVkKTtcblxuICAgICAgdmFyIHRyaWdnZXJMb2Fkc3RhcnQgPSBmdW5jdGlvbiB0cmlnZ2VyTG9hZHN0YXJ0KCkge1xuICAgICAgICAvLyBXZSBkaWQgbWlzcyB0aGUgb3JpZ2luYWwgbG9hZHN0YXJ0LiBNYWtlIHN1cmUgdGhlIHBsYXllclxuICAgICAgICAvLyBzZWVzIGxvYWRzdGFydCBiZWZvcmUgbG9hZGVkbWV0YWRhdGFcbiAgICAgICAgaWYgKCFsb2Fkc3RhcnRGaXJlZCkge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignbG9hZHN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMub24oJ2xvYWRlZG1ldGFkYXRhJywgdHJpZ2dlckxvYWRzdGFydCk7XG5cbiAgICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9mZignbG9hZHN0YXJ0Jywgc2V0TG9hZHN0YXJ0RmlyZWQpO1xuICAgICAgICB0aGlzLm9mZignbG9hZGVkbWV0YWRhdGEnLCB0cmlnZ2VyTG9hZHN0YXJ0KTtcblxuICAgICAgICBpZiAoIWxvYWRzdGFydEZpcmVkKSB7XG4gICAgICAgICAgLy8gV2UgZGlkIG1pc3MgdGhlIG9yaWdpbmFsIG5hdGl2ZSBsb2Fkc3RhcnQuIEZpcmUgaXQgbm93LlxuICAgICAgICAgIHRoaXMudHJpZ2dlcignbG9hZHN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRnJvbSBoZXJlIG9uIHdlIGtub3cgdGhhdCBsb2Fkc3RhcnQgYWxyZWFkeSBmaXJlZCBhbmQgd2UgbWlzc2VkIGl0LlxuICAgIC8vIFRoZSBvdGhlciByZWFkeVN0YXRlIGV2ZW50cyBhcmVuJ3QgYXMgbXVjaCBvZiBhIHByb2JsZW0gaWYgd2UgZG91YmxlXG4gICAgLy8gdGhlbSwgc28gbm90IGdvaW5nIHRvIGdvIHRvIGFzIG11Y2ggdHJvdWJsZSBhcyBsb2Fkc3RhcnQgdG8gcHJldmVudFxuICAgIC8vIHRoYXQgdW5sZXNzIHdlIGZpbmQgcmVhc29uIHRvLlxuICAgIHZhciBldmVudHNUb1RyaWdnZXIgPSBbJ2xvYWRzdGFydCddO1xuXG4gICAgLy8gbG9hZGVkbWV0YWRhdGE6IG5ld2x5IGVxdWFsIHRvIEhBVkVfTUVUQURBVEEgKDEpIG9yIGdyZWF0ZXJcbiAgICBldmVudHNUb1RyaWdnZXIucHVzaCgnbG9hZGVkbWV0YWRhdGEnKTtcblxuICAgIC8vIGxvYWRlZGRhdGE6IG5ld2x5IGluY3JlYXNlZCB0byBIQVZFX0NVUlJFTlRfREFUQSAoMikgb3IgZ3JlYXRlclxuICAgIGlmIChlbC5yZWFkeVN0YXRlID49IDIpIHtcbiAgICAgIGV2ZW50c1RvVHJpZ2dlci5wdXNoKCdsb2FkZWRkYXRhJyk7XG4gICAgfVxuXG4gICAgLy8gY2FucGxheTogbmV3bHkgaW5jcmVhc2VkIHRvIEhBVkVfRlVUVVJFX0RBVEEgKDMpIG9yIGdyZWF0ZXJcbiAgICBpZiAoZWwucmVhZHlTdGF0ZSA+PSAzKSB7XG4gICAgICBldmVudHNUb1RyaWdnZXIucHVzaCgnY2FucGxheScpO1xuICAgIH1cblxuICAgIC8vIGNhbnBsYXl0aHJvdWdoOiBuZXdseSBlcXVhbCB0byBIQVZFX0VOT1VHSF9EQVRBICg0KVxuICAgIGlmIChlbC5yZWFkeVN0YXRlID49IDQpIHtcbiAgICAgIGV2ZW50c1RvVHJpZ2dlci5wdXNoKCdjYW5wbGF5dGhyb3VnaCcpO1xuICAgIH1cblxuICAgIC8vIFdlIHN0aWxsIG5lZWQgdG8gZ2l2ZSB0aGUgcGxheWVyIHRpbWUgdG8gYWRkIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgZXZlbnRzVG9UcmlnZ2VyLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKHR5cGUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBjdXJyZW50IHRpbWUgZm9yIHRoZSBgSFRNTDVgIHRlY2guXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWNvbmRzXG4gICAqICAgICAgICBTZXQgdGhlIGN1cnJlbnQgdGltZSBvZiB0aGUgbWVkaWEgdG8gdGhpcy5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuc2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbiBzZXRDdXJyZW50VGltZShzZWNvbmRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZWxfLmN1cnJlbnRUaW1lID0gc2Vjb25kcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2ckMShlLCAnVmlkZW8gaXMgbm90IHJlYWR5LiAoVmlkZW8uanMpJyk7XG4gICAgICAvLyB0aGlzLndhcm5pbmcoVmlkZW9KUy53YXJuaW5ncy52aWRlb05vdFJlYWR5KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBkdXJhdGlvbiBvZiB0aGUgSFRNTDUgbWVkaWEgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkdXJhdGlvbiBvZiB0aGUgbWVkaWEgb3IgMCBpZiB0aGVyZSBpcyBubyBkdXJhdGlvbi5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8vIEFuZHJvaWQgQ2hyb21lIHdpbGwgcmVwb3J0IGR1cmF0aW9uIGFzIEluZmluaXR5IGZvciBWT0QgSExTIHVudGlsIGFmdGVyXG4gICAgLy8gcGxheWJhY2sgaGFzIHN0YXJ0ZWQsIHdoaWNoIHRyaWdnZXJzIHRoZSBsaXZlIGRpc3BsYXkgZXJyb25lb3VzbHkuXG4gICAgLy8gUmV0dXJuIE5hTiBpZiBwbGF5YmFjayBoYXMgbm90IHN0YXJ0ZWQgYW5kIHRyaWdnZXIgYSBkdXJhdGlvbnVwZGF0ZSBvbmNlXG4gICAgLy8gdGhlIGR1cmF0aW9uIGNhbiBiZSByZWxpYWJseSBrbm93bi5cbiAgICBpZiAodGhpcy5lbF8uZHVyYXRpb24gPT09IEluZmluaXR5ICYmIElTX0FORFJPSUQgJiYgSVNfQ0hST01FICYmIHRoaXMuZWxfLmN1cnJlbnRUaW1lID09PSAwKSB7XG4gICAgICAvLyBXYWl0IGZvciB0aGUgZmlyc3QgYHRpbWV1cGRhdGVgIHdpdGggY3VycmVudFRpbWUgPiAwIC0gdGhlcmUgbWF5IGJlXG4gICAgICAvLyBzZXZlcmFsIHdpdGggMFxuICAgICAgdmFyIGNoZWNrUHJvZ3Jlc3MgPSBmdW5jdGlvbiBjaGVja1Byb2dyZXNzKCkge1xuICAgICAgICBpZiAoX3RoaXMzLmVsXy5jdXJyZW50VGltZSA+IDApIHtcbiAgICAgICAgICAvLyBUcmlnZ2VyIGR1cmF0aW9uY2hhbmdlIGZvciBnZW51aW5lbHkgbGl2ZSB2aWRlb1xuICAgICAgICAgIGlmIChfdGhpczMuZWxfLmR1cmF0aW9uID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgX3RoaXMzLnRyaWdnZXIoJ2R1cmF0aW9uY2hhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzMy5vZmYoJ3RpbWV1cGRhdGUnLCBjaGVja1Byb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vbigndGltZXVwZGF0ZScsIGNoZWNrUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWxfLmR1cmF0aW9uIHx8IE5hTjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHdpZHRoIG9mIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uIHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5vZmZzZXRXaWR0aDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgSFRNTDUgbWVkaWEgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBoZWlndGggb2YgdGhlIEhUTUw1IG1lZGlhIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uIGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF8ub2Zmc2V0SGVpZ2h0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm94eSBpT1MgYHdlYmtpdGJlZ2luZnVsbHNjcmVlbmAgYW5kIGB3ZWJraXRlbmRmdWxsc2NyZWVuYCBpbnRvXG4gICAqIGBmdWxsc2NyZWVuY2hhbmdlYCBldmVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZpcmVzIGZ1bGxzY3JlZW5jaGFuZ2VcbiAgICogQGxpc3RlbnMgd2Via2l0ZW5kZnVsbHNjcmVlblxuICAgKiBAbGlzdGVucyB3ZWJraXRiZWdpbmZ1bGxzY3JlZW5cbiAgICogQGxpc3RlbnMgd2Via2l0YmVnaW5mdWxsc2NyZWVuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnByb3h5V2Via2l0RnVsbHNjcmVlbl8gPSBmdW5jdGlvbiBwcm94eVdlYmtpdEZ1bGxzY3JlZW5fKCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgaWYgKCEoJ3dlYmtpdERpc3BsYXlpbmdGdWxsc2NyZWVuJyBpbiB0aGlzLmVsXykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZW5kRm4gPSBmdW5jdGlvbiBlbmRGbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScsIHsgaXNGdWxsc2NyZWVuOiBmYWxzZSB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGJlZ2luRm4gPSBmdW5jdGlvbiBiZWdpbkZuKCkge1xuICAgICAgaWYgKCd3ZWJraXRQcmVzZW50YXRpb25Nb2RlJyBpbiB0aGlzLmVsXyAmJiB0aGlzLmVsXy53ZWJraXRQcmVzZW50YXRpb25Nb2RlICE9PSAncGljdHVyZS1pbi1waWN0dXJlJykge1xuICAgICAgICB0aGlzLm9uZSgnd2Via2l0ZW5kZnVsbHNjcmVlbicsIGVuZEZuKTtcblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCB7IGlzRnVsbHNjcmVlbjogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vbignd2Via2l0YmVnaW5mdWxsc2NyZWVuJywgYmVnaW5Gbik7XG4gICAgdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzNC5vZmYoJ3dlYmtpdGJlZ2luZnVsbHNjcmVlbicsIGJlZ2luRm4pO1xuICAgICAgX3RoaXM0Lm9mZignd2Via2l0ZW5kZnVsbHNjcmVlbicsIGVuZEZuKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgZnVsbHNjcmVlbiBpcyBzdXBwb3J0ZWQgb24gdGhlIGN1cnJlbnQgcGxheWJhY2sgZGV2aWNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIC0gVHJ1ZSBpZiBmdWxsc2NyZWVuIGlzIHN1cHBvcnRlZC5cbiAgICogICAgICAgICAtIEZhbHNlIGlmIGZ1bGxzY3JlZW4gaXMgbm90IHN1cHBvcnRlZC5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuc3VwcG9ydHNGdWxsU2NyZWVuID0gZnVuY3Rpb24gc3VwcG9ydHNGdWxsU2NyZWVuKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5lbF8ud2Via2l0RW50ZXJGdWxsU2NyZWVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdXNlckFnZW50ID0gd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcblxuICAgICAgLy8gU2VlbXMgdG8gYmUgYnJva2VuIGluIENocm9taXVtL0Nocm9tZSAmJiBTYWZhcmkgaW4gTGVvcGFyZFxuICAgICAgaWYgKC9BbmRyb2lkLy50ZXN0KHVzZXJBZ2VudCkgfHwgIS9DaHJvbWV8TWFjIE9TIFggMTAuNS8udGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdGhhdCB0aGUgYEhUTUw1YCBUZWNoIGVudGVyIGZ1bGxzY3JlZW4uXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmVudGVyRnVsbFNjcmVlbiA9IGZ1bmN0aW9uIGVudGVyRnVsbFNjcmVlbigpIHtcbiAgICB2YXIgdmlkZW8gPSB0aGlzLmVsXztcblxuICAgIGlmICh2aWRlby5wYXVzZWQgJiYgdmlkZW8ubmV0d29ya1N0YXRlIDw9IHZpZGVvLkhBVkVfTUVUQURBVEEpIHtcbiAgICAgIC8vIGF0dGVtcHQgdG8gcHJpbWUgdGhlIHZpZGVvIGVsZW1lbnQgZm9yIHByb2dyYW1tYXRpYyBhY2Nlc3NcbiAgICAgIC8vIHRoaXMgaXNuJ3QgbmVjZXNzYXJ5IG9uIHRoZSBkZXNrdG9wIGJ1dCBzaG91bGRuJ3QgaHVydFxuICAgICAgdGhpcy5lbF8ucGxheSgpO1xuXG4gICAgICAvLyBwbGF5aW5nIGFuZCBwYXVzaW5nIHN5bmNocm9ub3VzbHkgZHVyaW5nIHRoZSB0cmFuc2l0aW9uIHRvIGZ1bGxzY3JlZW5cbiAgICAgIC8vIGNhbiBnZXQgaU9TIH42LjEgZGV2aWNlcyBpbnRvIGEgcGxheS9wYXVzZSBsb29wXG4gICAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2aWRlby5wYXVzZSgpO1xuICAgICAgICB2aWRlby53ZWJraXRFbnRlckZ1bGxTY3JlZW4oKTtcbiAgICAgIH0sIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlby53ZWJraXRFbnRlckZ1bGxTY3JlZW4oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdGhhdCB0aGUgYEhUTUw1YCBUZWNoIGV4aXQgZnVsbHNjcmVlbi5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuZXhpdEZ1bGxTY3JlZW4gPSBmdW5jdGlvbiBleGl0RnVsbFNjcmVlbigpIHtcbiAgICB0aGlzLmVsXy53ZWJraXRFeGl0RnVsbFNjcmVlbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgSHRtbDVgIFRlY2gncyBzb3VyY2Ugb2JqZWN0LlxuICAgKiA+IE5vdGU6IFBsZWFzZSB1c2Uge0BsaW5rIEh0bWw1I3NldFNvdXJjZX1cbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gW3NyY11cbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0IHlvdSB3YW50IHRvIHNldCBvbiB0aGUgYEhUTUw1YCB0ZWNocyBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgLSBUaGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0IHdoZW4gYSBzb3VyY2UgaXMgbm90IHBhc3NlZCBpbi5cbiAgICogICAgICAgICAtIHVuZGVmaW5lZCB3aGVuIHNldHRpbmdcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgU2luY2UgdmVyc2lvbiA1LlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5zcmMgPSBmdW5jdGlvbiBzcmMoX3NyYykge1xuICAgIGlmIChfc3JjID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsXy5zcmM7XG4gICAgfVxuXG4gICAgLy8gU2V0dGluZyBzcmMgdGhyb3VnaCBgc3JjYCBpbnN0ZWFkIG9mIGBzZXRTcmNgIHdpbGwgYmUgZGVwcmVjYXRlZFxuICAgIHRoaXMuc2V0U3JjKF9zcmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgdGVjaCBieSByZW1vdmluZyBhbGwgc291cmNlcyBhbmQgdGhlbiBjYWxsaW5nXG4gICAqIHtAbGluayBIdG1sNS5yZXNldE1lZGlhRWxlbWVudH0uXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgSHRtbDUucmVzZXRNZWRpYUVsZW1lbnQodGhpcy5lbF8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc291cmNlIG9uIHRoZSBgSFRNTDVgIFRlY2guIEZhbGxzIGJhY2sgdG8gcmV0dXJuaW5nIHRoZSBzb3VyY2UgZnJvbVxuICAgKiB0aGUgSFRNTDUgbWVkaWEgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7VGVjaH5Tb3VyY2VPYmplY3R9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgc291cmNlIG9iamVjdCBmcm9tIHRoZSBIVE1MNSB0ZWNoLiBXaXRoIGEgZmFsbGJhY2sgdG8gdGhlXG4gICAqICAgICAgICAgZWxlbWVudHMgc291cmNlLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5jdXJyZW50U3JjID0gZnVuY3Rpb24gY3VycmVudFNyYygpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50U291cmNlXykge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNvdXJjZV8uc3JjO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbF8uY3VycmVudFNyYztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGNvbnRyb2xzIGF0dHJpYnV0ZSBmb3IgdGhlIEhUTUw1IG1lZGlhIEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcbiAgICogICAgICAgIFZhbHVlIHRvIHNldCB0aGUgY29udHJvbHMgYXR0cmlidXRlIHRvXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnNldENvbnRyb2xzID0gZnVuY3Rpb24gc2V0Q29udHJvbHModmFsKSB7XG4gICAgdGhpcy5lbF8uY29udHJvbHMgPSAhIXZhbDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZXR1cm5zIGEgcmVtb3RlIHtAbGluayBUZXh0VHJhY2t9IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAgICogICAgICAgIGBUZXh0VHJhY2tgIGtpbmQgKHN1YnRpdGxlcywgY2FwdGlvbnMsIGRlc2NyaXB0aW9ucywgY2hhcHRlcnMsIG9yIG1ldGFkYXRhKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXVxuICAgKiAgICAgICAgTGFiZWwgdG8gaWRlbnRpZnkgdGhlIHRleHQgdHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV1cbiAgICogICAgICAgIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja31cbiAgICogICAgICAgICBUaGUgVGV4dFRyYWNrIHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5hZGRUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgcmV0dXJuIF9UZWNoLnByb3RvdHlwZS5hZGRUZXh0VHJhY2suY2FsbCh0aGlzLCBraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVsXy5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBlaXRoZXIgbmF0aXZlIFRleHRUcmFjayBvciBhbiBlbXVsYXRlZCBUZXh0VHJhY2sgZGVwZW5kaW5nXG4gICAqIG9uIHRoZSB2YWx1ZSBvZiBgZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzYFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiB0aGUgb3B0aW9ucyB0byBpbnRpYWxpemUgdGhlIFRleHRUcmFjayB3aXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMua2luZF1cbiAgICogICAgICAgIGBUZXh0VHJhY2tgIGtpbmQgKHN1YnRpdGxlcywgY2FwdGlvbnMsIGRlc2NyaXB0aW9ucywgY2hhcHRlcnMsIG9yIG1ldGFkYXRhKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsXS5cbiAgICogICAgICAgIExhYmVsIHRvIGlkZW50aWZ5IHRoZSB0ZXh0IHRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZV1cbiAgICogICAgICAgIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlZmF1bHRdXG4gICAqICAgICAgICBEZWZhdWx0IHRoaXMgdHJhY2sgdG8gb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAgICogICAgICAgIFRoZSBpbnRlcm5hbCBpZCB0byBhc3NpZ24gdGhpcyB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY11cbiAgICogICAgICAgIEEgc291cmNlIHVybCBmb3IgdGhlIHRyYWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSB0cmFjayBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5jcmVhdGVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVSZW1vdGVUZXh0VHJhY2sob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgIHJldHVybiBfVGVjaC5wcm90b3R5cGUuY3JlYXRlUmVtb3RlVGV4dFRyYWNrLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHZhciBodG1sVHJhY2tFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHJhY2snKTtcblxuICAgIGlmIChvcHRpb25zLmtpbmQpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQua2luZCA9IG9wdGlvbnMua2luZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGFiZWwpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQubGFiZWwgPSBvcHRpb25zLmxhYmVsO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sYW5ndWFnZSB8fCBvcHRpb25zLnNyY2xhbmcpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQuc3JjbGFuZyA9IG9wdGlvbnMubGFuZ3VhZ2UgfHwgb3B0aW9ucy5zcmNsYW5nO1xuICAgIH1cbiAgICBpZiAob3B0aW9uc1snZGVmYXVsdCddKSB7XG4gICAgICBodG1sVHJhY2tFbGVtZW50WydkZWZhdWx0J10gPSBvcHRpb25zWydkZWZhdWx0J107XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmlkKSB7XG4gICAgICBodG1sVHJhY2tFbGVtZW50LmlkID0gb3B0aW9ucy5pZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3JjKSB7XG4gICAgICBodG1sVHJhY2tFbGVtZW50LnNyYyA9IG9wdGlvbnMuc3JjO1xuICAgIH1cblxuICAgIHJldHVybiBodG1sVHJhY2tFbGVtZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVtb3RlIHRleHQgdHJhY2sgb2JqZWN0IGFuZCByZXR1cm5zIGFuIGh0bWwgdHJhY2sgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiB2YWx1ZXMgZm9yXG4gICAqIGtpbmQsIGxhbmd1YWdlLCBsYWJlbCwgYW5kIHNyYyAobG9jYXRpb24gb2YgdGhlIFdlYlZUVCBmaWxlKVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYW51YWxDbGVhbnVwPXRydWVdIGlmIHNldCB0byBmYWxzZSwgdGhlIFRleHRUcmFjayB3aWxsIGJlXG4gICAqIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50IHdoZW5ldmVyIHRoZSBzb3VyY2UgY2hhbmdlc1xuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50fSBBbiBIdG1sIFRyYWNrIEVsZW1lbnQuXG4gICAqIFRoaXMgY2FuIGJlIGFuIGVtdWxhdGVkIHtAbGluayBIVE1MVHJhY2tFbGVtZW50fSBvciBhIG5hdGl2ZSBvbmUuXG4gICAqIEBkZXByZWNhdGVkIFRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBcIm1hbnVhbENsZWFudXBcIiBwYXJhbWV0ZXIgd2lsbCBkZWZhdWx0XG4gICAqIHRvIFwiZmFsc2VcIiBpbiB1cGNvbWluZyB2ZXJzaW9ucyBvZiBWaWRlby5qc1xuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5hZGRSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRSZW1vdGVUZXh0VHJhY2sob3B0aW9ucywgbWFudWFsQ2xlYW51cCkge1xuICAgIHZhciBodG1sVHJhY2tFbGVtZW50ID0gX1RlY2gucHJvdG90eXBlLmFkZFJlbW90ZVRleHRUcmFjay5jYWxsKHRoaXMsIG9wdGlvbnMsIG1hbnVhbENsZWFudXApO1xuXG4gICAgaWYgKHRoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICB0aGlzLmVsKCkuYXBwZW5kQ2hpbGQoaHRtbFRyYWNrRWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWxUcmFja0VsZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSByZW1vdGUgYFRleHRUcmFja2AgZnJvbSBgVGV4dFRyYWNrTGlzdGAgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICAgKiAgICAgICAgYFRleHRUcmFja2Agb2JqZWN0IHRvIHJlbW92ZVxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5yZW1vdmVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiByZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spIHtcbiAgICBfVGVjaC5wcm90b3R5cGUucmVtb3ZlUmVtb3RlVGV4dFRyYWNrLmNhbGwodGhpcywgdHJhY2spO1xuXG4gICAgaWYgKHRoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICB2YXIgdHJhY2tzID0gdGhpcy4kJCgndHJhY2snKTtcblxuICAgICAgdmFyIGkgPSB0cmFja3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmICh0cmFjayA9PT0gdHJhY2tzW2ldIHx8IHRyYWNrID09PSB0cmFja3NbaV0udHJhY2spIHtcbiAgICAgICAgICB0aGlzLmVsKCkucmVtb3ZlQ2hpbGQodHJhY2tzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhdmFpbGFibGUgbWVkaWEgcGxheWJhY2sgcXVhbGl0eSBtZXRyaWNzIGFzIHNwZWNpZmllZCBieSB0aGUgVzNDJ3MgTWVkaWFcbiAgICogUGxheWJhY2sgUXVhbGl0eSBBUEkuXG4gICAqXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vbWVkaWEtcGxheWJhY2stcXVhbGl0eX1cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIEFuIG9iamVjdCB3aXRoIHN1cHBvcnRlZCBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3NcbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPSBmdW5jdGlvbiBnZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZWwoKS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuZWwoKS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xuICAgIH1cblxuICAgIHZhciB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHt9O1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmVsKCkud2Via2l0RHJvcHBlZEZyYW1lQ291bnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aGlzLmVsKCkud2Via2l0RGVjb2RlZEZyYW1lQ291bnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2aWRlb1BsYXliYWNrUXVhbGl0eS5kcm9wcGVkVmlkZW9GcmFtZXMgPSB0aGlzLmVsKCkud2Via2l0RHJvcHBlZEZyYW1lQ291bnQ7XG4gICAgICB2aWRlb1BsYXliYWNrUXVhbGl0eS50b3RhbFZpZGVvRnJhbWVzID0gdGhpcy5lbCgpLndlYmtpdERlY29kZWRGcmFtZUNvdW50O1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cucGVyZm9ybWFuY2UgJiYgdHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5LmNyZWF0aW9uVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2UudGltaW5nICYmIHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5LmNyZWF0aW9uVGltZSA9IHdpbmRvdy5EYXRlLm5vdygpIC0gd2luZG93LnBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZGVvUGxheWJhY2tRdWFsaXR5O1xuICB9O1xuXG4gIHJldHVybiBIdG1sNTtcbn0oVGVjaCk7XG5cbi8qIEhUTUw1IFN1cHBvcnQgVGVzdGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbmlmIChpc1JlYWwoKSkge1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IGZvciB0ZXN0aW5nIGJyb3dzZXIgSFRNTDUgbWVkaWEgY2FwYWJpbGl0aWVzXG4gICAqXG4gICAqIEB0eXBlIHtFbGVtZW50fVxuICAgKiBAY29uc3RhbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEh0bWw1LlRFU1RfVklEID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgdmFyIHRyYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHJhY2snKTtcblxuICB0cmFjay5raW5kID0gJ2NhcHRpb25zJztcbiAgdHJhY2suc3JjbGFuZyA9ICdlbic7XG4gIHRyYWNrLmxhYmVsID0gJ0VuZ2xpc2gnO1xuICBIdG1sNS5URVNUX1ZJRC5hcHBlbmRDaGlsZCh0cmFjayk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgSFRNTDUgbWVkaWEgaXMgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIEhUTUw1IG1lZGlhIGlzIHN1cHBvcnRlZC5cbiAqICAgICAgICAgLSBGYWxzZSBpZiBIVE1MNSBtZWRpYSBpcyBub3Qgc3VwcG9ydGVkLlxuICovXG5IdG1sNS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gSUU5IHdpdGggbm8gTWVkaWEgUGxheWVyIGlzIGEgTElBUiEgKCM5ODQpXG4gIHRyeSB7XG4gICAgSHRtbDUuVEVTVF9WSUQudm9sdW1lID0gMC41O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhKEh0bWw1LlRFU1RfVklEICYmIEh0bWw1LlRFU1RfVklELmNhblBsYXlUeXBlKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHR5cGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIFRoZSBtaW1ldHlwZSB0byBjaGVja1xuICogQHJldHVybiB7c3RyaW5nfSAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICovXG5IdG1sNS5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHJldHVybiBIdG1sNS5URVNUX1ZJRC5jYW5QbGF5VHlwZSh0eXBlKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IHNyY09ialxuICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgdGVjaFxuICogQHJldHVybiB7c3RyaW5nfSAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICovXG5IdG1sNS5jYW5QbGF5U291cmNlID0gZnVuY3Rpb24gKHNyY09iaiwgb3B0aW9ucykge1xuICByZXR1cm4gSHRtbDUuY2FuUGxheVR5cGUoc3JjT2JqLnR5cGUpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdm9sdW1lIGNhbiBiZSBjaGFuZ2VkIGluIHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKiBWb2x1bWUgY2Fubm90IGJlIGNoYW5nZWQgaW4gYSBsb3Qgb2YgbW9iaWxlIGRldmljZXMuXG4gKiBTcGVjaWZpY2FsbHksIGl0IGNhbid0IGJlIGNoYW5nZWQgZnJvbSAxIG9uIGlPUy5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgdm9sdW1lIGNhbiBiZSBjb250cm9sbGVkXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkh0bWw1LmNhbkNvbnRyb2xWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIElFIHdpbGwgZXJyb3IgaWYgV2luZG93cyBNZWRpYSBQbGF5ZXIgbm90IGluc3RhbGxlZCAjMzMxNVxuICB0cnkge1xuICAgIHZhciB2b2x1bWUgPSBIdG1sNS5URVNUX1ZJRC52b2x1bWU7XG5cbiAgICBIdG1sNS5URVNUX1ZJRC52b2x1bWUgPSB2b2x1bWUgLyAyICsgMC4xO1xuICAgIHJldHVybiB2b2x1bWUgIT09IEh0bWw1LlRFU1RfVklELnZvbHVtZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcGxheWJhY2sgcmF0ZSBjYW4gYmUgY2hhbmdlZCBpbiB0aGlzIGJyb3dzZXIvZGV2aWNlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiBwbGF5YmFjayByYXRlIGNhbiBiZSBjb250cm9sbGVkXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkh0bWw1LmNhbkNvbnRyb2xQbGF5YmFja1JhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFBsYXliYWNrIHJhdGUgQVBJIGlzIGltcGxlbWVudGVkIGluIEFuZHJvaWQgQ2hyb21lLCBidXQgZG9lc24ndCBkbyBhbnl0aGluZ1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvMzE4MFxuICBpZiAoSVNfQU5EUk9JRCAmJiBJU19DSFJPTUUgJiYgQ0hST01FX1ZFUlNJT04gPCA1OCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBJRSB3aWxsIGVycm9yIGlmIFdpbmRvd3MgTWVkaWEgUGxheWVyIG5vdCBpbnN0YWxsZWQgIzMzMTVcbiAgdHJ5IHtcbiAgICB2YXIgcGxheWJhY2tSYXRlID0gSHRtbDUuVEVTVF9WSUQucGxheWJhY2tSYXRlO1xuXG4gICAgSHRtbDUuVEVTVF9WSUQucGxheWJhY2tSYXRlID0gcGxheWJhY2tSYXRlIC8gMiArIDAuMTtcbiAgICByZXR1cm4gcGxheWJhY2tSYXRlICE9PSBIdG1sNS5URVNUX1ZJRC5wbGF5YmFja1JhdGU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIG5hdGl2ZSBgVGV4dFRyYWNrYHMgYXJlIHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIvZGV2aWNlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiBuYXRpdmUgYFRleHRUcmFja2BzIGFyZSBzdXBwb3J0ZWQuXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkh0bWw1LnN1cHBvcnRzTmF0aXZlVGV4dFRyYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIElTX0FOWV9TQUZBUkk7XG59O1xuXG4vKipcbiAqIENoZWNrIHRvIHNlZSBpZiBuYXRpdmUgYFZpZGVvVHJhY2tgcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2VcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgIC0gVHJ1ZSBpZiBuYXRpdmUgYFZpZGVvVHJhY2tgcyBhcmUgc3VwcG9ydGVkLlxuICogICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkh0bWw1LnN1cHBvcnRzTmF0aXZlVmlkZW9UcmFja3MgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIShIdG1sNS5URVNUX1ZJRCAmJiBIdG1sNS5URVNUX1ZJRC52aWRlb1RyYWNrcyk7XG59O1xuXG4vKipcbiAqIENoZWNrIHRvIHNlZSBpZiBuYXRpdmUgYEF1ZGlvVHJhY2tgcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2VcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgIC0gVHJ1ZSBpZiBuYXRpdmUgYEF1ZGlvVHJhY2tgcyBhcmUgc3VwcG9ydGVkLlxuICogICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkh0bWw1LnN1cHBvcnRzTmF0aXZlQXVkaW9UcmFja3MgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIShIdG1sNS5URVNUX1ZJRCAmJiBIdG1sNS5URVNUX1ZJRC5hdWRpb1RyYWNrcyk7XG59O1xuXG4vKipcbiAqIEFuIGFycmF5IG9mIGV2ZW50cyBhdmFpbGFibGUgb24gdGhlIEh0bWw1IHRlY2guXG4gKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuSHRtbDUuRXZlbnRzID0gWydsb2Fkc3RhcnQnLCAnc3VzcGVuZCcsICdhYm9ydCcsICdlcnJvcicsICdlbXB0aWVkJywgJ3N0YWxsZWQnLCAnbG9hZGVkbWV0YWRhdGEnLCAnbG9hZGVkZGF0YScsICdjYW5wbGF5JywgJ2NhbnBsYXl0aHJvdWdoJywgJ3BsYXlpbmcnLCAnd2FpdGluZycsICdzZWVraW5nJywgJ3NlZWtlZCcsICdlbmRlZCcsICdkdXJhdGlvbmNoYW5nZScsICd0aW1ldXBkYXRlJywgJ3Byb2dyZXNzJywgJ3BsYXknLCAncGF1c2UnLCAncmF0ZWNoYW5nZScsICdyZXNpemUnLCAndm9sdW1lY2hhbmdlJ107XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB2b2x1bWUgY29udHJvbC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0IHtAbGluayBIdG1sNS5jYW5Db250cm9sVm9sdW1lfVxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNWb2x1bWVDb250cm9sID0gSHRtbDUuY2FuQ29udHJvbFZvbHVtZSgpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgY2hhbmdpbmcgdGhlIHNwZWVkIGF0IHdoaWNoIHRoZSBtZWRpYVxuICogcGxheXMuIEV4YW1wbGVzOlxuICogICAtIFNldCBwbGF5ZXIgdG8gcGxheSAyeCAodHdpY2UpIGFzIGZhc3RcbiAqICAgLSBTZXQgcGxheWVyIHRvIHBsYXkgMC41eCAoaGFsZikgYXMgZmFzdFxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LmNhbkNvbnRyb2xQbGF5YmFja1JhdGV9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc1BsYXliYWNrUmF0ZSA9IEh0bWw1LmNhbkNvbnRyb2xQbGF5YmFja1JhdGUoKTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyB0aGUgbWVkaWEgZWxlbWVudFxuICogbW92aW5nIGluIHRoZSBET00uIGlPUyBicmVha3MgaWYgeW91IG1vdmUgdGhlIG1lZGlhIGVsZW1lbnQsIHNvIHRoaXMgaXMgc2V0IHRoaXMgdG9cbiAqIGZhbHNlIHRoZXJlLiBFdmVyeXdoZXJlIGVsc2UgdGhpcyBzaG91bGQgYmUgdHJ1ZS5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5tb3ZpbmdNZWRpYUVsZW1lbnRJbkRPTSA9ICFJU19JT1M7XG5cbi8vIFRPRE86IFByZXZpb3VzIGNvbW1lbnQ6IE5vIGxvbmdlciBhcHBlYXJzIHRvIGJlIHVzZWQuIENhbiBwcm9iYWJseSBiZSByZW1vdmVkLlxuLy8gICAgICAgSXMgdGhpcyB0cnVlP1xuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyBhdXRvbWF0aWMgbWVkaWEgcmVzaXplXG4gKiB3aGVuIGdvaW5nIGludG8gZnVsbHNjcmVlbi5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc0Z1bGxzY3JlZW5SZXNpemUgPSB0cnVlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIHRoZSBwcm9ncmVzcyBldmVudC5cbiAqIElmIHRoaXMgaXMgZmFsc2UsIG1hbnVhbCBgcHJvZ3Jlc3NgIGV2ZW50cyB3aWxsIGJlIHRyaWdncmVkIGluc3RlYWQuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNQcm9ncmVzc0V2ZW50cyA9IHRydWU7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBIVE1MNWAgdGVjaCBjdXJyZW50bHkgc3VwcG9ydHMgdGhlIHRpbWV1cGRhdGUgZXZlbnQuXG4gKiBJZiB0aGlzIGlzIGZhbHNlLCBtYW51YWwgYHRpbWV1cGRhdGVgIGV2ZW50cyB3aWxsIGJlIHRyaWdncmVkIGluc3RlYWQuXG4gKlxuICogQGRlZmF1bHRcbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzVGltZXVwZGF0ZUV2ZW50cyA9IHRydWU7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBIVE1MNWAgdGVjaCBjdXJyZW50bHkgc3VwcG9ydHMgbmF0aXZlIGBUZXh0VHJhY2tgcy5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0IHtAbGluayBIdG1sNS5zdXBwb3J0c05hdGl2ZVRleHRUcmFja3N9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MgPSBIdG1sNS5zdXBwb3J0c05hdGl2ZVRleHRUcmFja3MoKTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyBuYXRpdmUgYFZpZGVvVHJhY2tgcy5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0IHtAbGluayBIdG1sNS5zdXBwb3J0c05hdGl2ZVZpZGVvVHJhY2tzfVxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNOYXRpdmVWaWRlb1RyYWNrcyA9IEh0bWw1LnN1cHBvcnRzTmF0aXZlVmlkZW9UcmFja3MoKTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyBuYXRpdmUgYEF1ZGlvVHJhY2tgcy5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0IHtAbGluayBIdG1sNS5zdXBwb3J0c05hdGl2ZUF1ZGlvVHJhY2tzfVxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNOYXRpdmVBdWRpb1RyYWNrcyA9IEh0bWw1LnN1cHBvcnRzTmF0aXZlQXVkaW9UcmFja3MoKTtcblxuLy8gSFRNTDUgRmVhdHVyZSBkZXRlY3Rpb24gYW5kIERldmljZSBGaXhlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbnZhciBjYW5QbGF5VHlwZSA9IEh0bWw1LlRFU1RfVklEICYmIEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZTtcbnZhciBtcGVndXJsUkUgPSAvXmFwcGxpY2F0aW9uXFwvKD86eC18dm5kXFwuYXBwbGVcXC4pbXBlZ3VybC9pO1xudmFyIG1wNFJFID0gL152aWRlb1xcL21wNC9pO1xuXG5IdG1sNS5wYXRjaENhblBsYXlUeXBlID0gZnVuY3Rpb24gKCkge1xuXG4gIC8vIEFuZHJvaWQgNC4wIGFuZCBhYm92ZSBjYW4gcGxheSBITFMgdG8gc29tZSBleHRlbnQgYnV0IGl0IHJlcG9ydHMgYmVpbmcgdW5hYmxlIHRvIGRvIHNvXG4gIGlmIChBTkRST0lEX1ZFUlNJT04gPj0gNC4wICYmICFJU19GSVJFRk9YKSB7XG4gICAgSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlICYmIG1wZWd1cmxSRS50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiAnbWF5YmUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhblBsYXlUeXBlLmNhbGwodGhpcywgdHlwZSk7XG4gICAgfTtcblxuICAgIC8vIE92ZXJyaWRlIEFuZHJvaWQgMi4yIGFuZCBsZXNzIGNhblBsYXlUeXBlIG1ldGhvZCB3aGljaCBpcyBicm9rZW5cbiAgfSBlbHNlIGlmIChJU19PTERfQU5EUk9JRCkge1xuICAgIEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBpZiAodHlwZSAmJiBtcDRSRS50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiAnbWF5YmUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhblBsYXlUeXBlLmNhbGwodGhpcywgdHlwZSk7XG4gICAgfTtcbiAgfVxufTtcblxuSHRtbDUudW5wYXRjaENhblBsYXlUeXBlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZTtcblxuICBIdG1sNS5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBjYW5QbGF5VHlwZTtcbiAgcmV0dXJuIHI7XG59O1xuXG4vLyBieSBkZWZhdWx0LCBwYXRjaCB0aGUgbWVkaWEgZWxlbWVudFxuSHRtbDUucGF0Y2hDYW5QbGF5VHlwZSgpO1xuXG5IdG1sNS5kaXNwb3NlTWVkaWFFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gIGlmICghZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFueSBjaGlsZCB0cmFjayBvciBzb3VyY2Ugbm9kZXMgdG8gcHJldmVudCB0aGVpciBsb2FkaW5nXG4gIHdoaWxlIChlbC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBhbnkgc3JjIHJlZmVyZW5jZS4gbm90IHNldHRpbmcgYHNyYz0nJ2AgYmVjYXVzZSB0aGF0IGNhdXNlcyBhIHdhcm5pbmdcbiAgLy8gaW4gZmlyZWZveFxuICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gIC8vIGZvcmNlIHRoZSBtZWRpYSBlbGVtZW50IHRvIHVwZGF0ZSBpdHMgbG9hZGluZyBzdGF0ZSBieSBjYWxsaW5nIGxvYWQoKVxuICAvLyBob3dldmVyIElFIG9uIFdpbmRvd3MgN04gaGFzIGEgYnVnIHRoYXQgdGhyb3dzIGFuIGVycm9yIHNvIG5lZWQgYSB0cnkvY2F0Y2ggKCM3OTMpXG4gIGlmICh0eXBlb2YgZWwubG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIHdyYXBwaW5nIGluIGFuIGlpZmUgc28gaXQncyBub3QgZGVvcHRpbWl6ZWQgKCMxMDYwI2Rpc2N1c3Npb25fcjEwMzI0NDczKVxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBlbC5sb2FkKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWRcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG59O1xuXG5IdG1sNS5yZXNldE1lZGlhRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNvdXJjZXMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCdzb3VyY2UnKTtcbiAgdmFyIGkgPSBzb3VyY2VzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgZWwucmVtb3ZlQ2hpbGQoc291cmNlc1tpXSk7XG4gIH1cblxuICAvLyByZW1vdmUgYW55IHNyYyByZWZlcmVuY2UuXG4gIC8vIG5vdCBzZXR0aW5nIGBzcmM9JydgIGJlY2F1c2UgdGhhdCB0aHJvd3MgYW4gZXJyb3JcbiAgZWwucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcblxuICBpZiAodHlwZW9mIGVsLmxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyB3cmFwcGluZyBpbiBhbiBpaWZlIHNvIGl0J3Mgbm90IGRlb3B0aW1pemVkICgjMTA2MCNkaXNjdXNzaW9uX3IxMDMyNDQ3MylcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWwubG9hZCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBzYXRpc2Z5IGxpbnRlclxuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cbn07XG5cbi8qIE5hdGl2ZSBIVE1MNSBlbGVtZW50IHByb3BlcnR5IHdyYXBwaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4vLyBXcmFwIG5hdGl2ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2l0aCBnZXR0ZXJzIHRoYXQgY2hlY2sgYm90aCBwcm9wZXJ0eSBhbmQgYXR0cmlidXRlXG4vLyBUaGUgbGlzdCBpcyBhcyBmb2xsb3dlZDpcbi8vIG11dGVkLCBkZWZhdWx0TXV0ZWQsIGF1dG9wbGF5LCBjb250cm9scywgbG9vcCwgcGxheXNpbmxpbmVcbltcbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgbXV0ZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBtdXRlZGAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSB2b2x1bWUgZm9yIHRoZSBtZWRpYSBzaG91bGQgYmUgc2V0IHRvIHNpbGVudC4gVGhpcyBkb2VzIG5vdCBhY3R1YWxseSBjaGFuZ2VcbiAqIHRoZSBgdm9sdW1lYCBhdHRyaWJ1dGUuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNtdXRlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIHRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBzaG91bGQgYmUgaWdub3JlZCBhbmQgdGhlIGF1ZGlvIHNldCB0byBzaWxlbnQuXG4gKiAgICAgICAgIC0gRmFsc2UgaWYgdGhlIHZhbHVlIG9mIGB2b2x1bWVgIHNob3VsZCBiZSB1c2VkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtbXV0ZWR9XG4gKi9cbidtdXRlZCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgZGVmYXVsdE11dGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgZGVmYXVsdE11dGVkYCBpbmRpY2F0ZXNcbiAqIHdoZXRoZXIgdGhlIG1lZGlhIHNob3VsZCBzdGFydCBtdXRlZCBvciBub3QuIE9ubHkgY2hhbmdlcyB0aGUgZGVmYXVsdCBzdGF0ZSBvZiB0aGVcbiAqIG1lZGlhLiBgbXV0ZWRgIGFuZCBgZGVmYXVsdE11dGVkYCBjYW4gaGF2ZSBkaWZmZXJlbnQgdmFsdWVzLiB7QGxpbmsgSHRtbDUjbXV0ZWR9IGluZGljYXRlcyB0aGVcbiAqIGN1cnJlbnQgc3RhdGUuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNkZWZhdWx0TXV0ZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBkZWZhdWx0TXV0ZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IG11dGVkLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgbm90IHN0YXJ0IG11dGVkXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1kZWZhdWx0bXV0ZWR9XG4gKi9cbidkZWZhdWx0TXV0ZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGF1dG9wbGF5YCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgYXV0b3BsYXlgIGluZGljYXRlc1xuICogdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IHRvIHBsYXkgYXMgc29vbiBhcyB0aGUgcGFnZSBpcyByZWFkeS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I2F1dG9wbGF5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgYXV0b3BsYXlgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IGFzIHNvb24gYXMgdGhlIHBhZ2UgbG9hZHMuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBub3Qgc3RhcnQgYXMgc29vbiBhcyB0aGUgcGFnZSBsb2Fkcy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1hdXRvcGxheX1cbiAqL1xuJ2F1dG9wbGF5JyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBjb250cm9sc2AgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGNvbnRyb2xzYCBpbmRpY2F0ZXNcbiAqIHdoZXRoZXIgdGhlIG5hdGl2ZSBtZWRpYSBjb250cm9scyBzaG91bGQgYmUgc2hvd24gb3IgaGlkZGVuLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjY29udHJvbHNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBjb250cm9sc2AgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IG5hdGl2ZSBjb250cm9scyBzaG91bGQgYmUgc2hvd2luZy5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCBuYXRpdmUgY29udHJvbHMgc2hvdWxkIGJlIGhpZGRlbi5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1jb250cm9sc31cbiAqL1xuJ2NvbnRyb2xzJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBsb29wYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgbG9vcGAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSBtZWRpYSBzaG91bGQgcmV0dXJuIHRvIHRoZSBzdGFydCBvZiB0aGUgbWVkaWEgYW5kIGNvbnRpbnVlIHBsYXlpbmcgb25jZVxuICogaXQgcmVhY2hlcyB0aGUgZW5kLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjbG9vcFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGxvb3BgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCBwbGF5YmFjayBzaG91bGQgc2VlayBiYWNrIHRvIHN0YXJ0IG9uY2VcbiAqICAgICAgICAgICB0aGUgZW5kIG9mIGEgbWVkaWEgaXMgcmVhY2hlZC5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCBwbGF5YmFjayBzaG91bGQgbm90IGxvb3AgYmFjayB0byB0aGUgc3RhcnQgd2hlbiB0aGVcbiAqICAgICAgICAgICBlbmQgb2YgdGhlIG1lZGlhIGlzIHJlYWNoZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2F0dHItbWVkaWEtbG9vcH1cbiAqL1xuJ2xvb3AnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHBsYXlzaW5saW5lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheXNpbmxpbmVgIGluZGljYXRlc1xuICogdG8gdGhlIGJyb3dzZXIgdGhhdCBub24tZnVsbHNjcmVlbiBwbGF5YmFjayBpcyBwcmVmZXJyZWQgd2hlbiBmdWxsc2NyZWVuXG4gKiBwbGF5YmFjayBpcyB0aGUgbmF0aXZlIGRlZmF1bHQsIHN1Y2ggYXMgaW4gaU9TIFNhZmFyaS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3BsYXlzaW5saW5lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgcGxheXNpbmxpbmVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHBsYXkgaW5saW5lLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgbm90IHBsYXkgaW5saW5lLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2F0dHItdmlkZW8tcGxheXNpbmxpbmV9XG4gKi9cbidwbGF5c2lubGluZSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgSHRtbDUucHJvdG90eXBlW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVsX1twcm9wXSB8fCB0aGlzLmVsXy5oYXNBdHRyaWJ1dGUocHJvcCk7XG4gIH07XG59KTtcblxuLy8gV3JhcCBuYXRpdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdpdGggc2V0dGVycyB0aGF0IHNldCBib3RoIHByb3BlcnR5IGFuZCBhdHRyaWJ1dGVcbi8vIFRoZSBsaXN0IGlzIGFzIGZvbGxvd2VkOlxuLy8gc2V0TXV0ZWQsIHNldERlZmF1bHRNdXRlZCwgc2V0QXV0b3BsYXksIHNldExvb3AsIHNldFBsYXlzaW5saW5lXG4vLyBzZXRDb250cm9scyBpcyBzcGVjaWFsLWNhc2VkIGFib3ZlXG5bXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYG11dGVkYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYG11dGVkYCBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudFxuICogYXVkaW8gbGV2ZWwgc2hvdWxkIGJlIHNpbGVudC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldE11dGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG11dGVkXG4gKiAgICAgICAgLSBUcnVlIGlmIHRoZSBhdWRpbyBzaG91bGQgYmUgc2V0IHRvIHNpbGVudFxuICogICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1tdXRlZH1cbiAqL1xuJ211dGVkJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBkZWZhdWx0TXV0ZWRgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgZGVmYXVsdE11dGVkYCBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudFxuICogYXVkaW8gbGV2ZWwgc2hvdWxkIGJlIHNpbGVudCwgYnV0IHdpbGwgb25seSBlZmZlY3QgdGhlIG11dGVkIGxldmVsIG9uIGludGlhbCBwbGF5YmFjay4uXG4gKlxuICogQG1ldGhvZCBIdG1sNS5wcm90b3R5cGUuc2V0RGVmYXVsdE11dGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRlZmF1bHRNdXRlZFxuICogICAgICAgIC0gVHJ1ZSBpZiB0aGUgYXVkaW8gc2hvdWxkIGJlIHNldCB0byBzaWxlbnRcbiAqICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtZGVmYXVsdG11dGVkfVxuICovXG4nZGVmYXVsdE11dGVkJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBhdXRvcGxheWAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBhdXRvcGxheWAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgdG8gcGxheSBhcyBzb29uIGFzIHRoZSBwYWdlIGlzIHJlYWR5LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0QXV0b3BsYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b3BsYXlcbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgYXMgc29vbiBhcyB0aGUgcGFnZSBsb2Fkcy5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBzdGFydCBhcyBzb29uIGFzIHRoZSBwYWdlIGxvYWRzLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLWF1dG9wbGF5fVxuICovXG4nYXV0b3BsYXknLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYGxvb3BgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgbG9vcGAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSBtZWRpYSBzaG91bGQgcmV0dXJuIHRvIHRoZSBzdGFydCBvZiB0aGUgbWVkaWEgYW5kIGNvbnRpbnVlIHBsYXlpbmcgb25jZVxuICogaXQgcmVhY2hlcyB0aGUgZW5kLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0TG9vcFxuICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCBwbGF5YmFjayBzaG91bGQgc2VlayBiYWNrIHRvIHN0YXJ0IG9uY2VcbiAqICAgICAgICAgICB0aGUgZW5kIG9mIGEgbWVkaWEgaXMgcmVhY2hlZC5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCBwbGF5YmFjayBzaG91bGQgbm90IGxvb3AgYmFjayB0byB0aGUgc3RhcnQgd2hlbiB0aGVcbiAqICAgICAgICAgICBlbmQgb2YgdGhlIG1lZGlhIGlzIHJlYWNoZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2F0dHItbWVkaWEtbG9vcH1cbiAqL1xuJ2xvb3AnLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYHBsYXlzaW5saW5lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheXNpbmxpbmVgIGluZGljYXRlc1xuICogdG8gdGhlIGJyb3dzZXIgdGhhdCBub24tZnVsbHNjcmVlbiBwbGF5YmFjayBpcyBwcmVmZXJyZWQgd2hlbiBmdWxsc2NyZWVuXG4gKiBwbGF5YmFjayBpcyB0aGUgbmF0aXZlIGRlZmF1bHQsIHN1Y2ggYXMgaW4gaU9TIFNhZmFyaS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldFBsYXlzaW5saW5lXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBsYXlzaW5saW5lXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHBsYXkgaW5saW5lLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgbm90IHBsYXkgaW5saW5lLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2F0dHItdmlkZW8tcGxheXNpbmxpbmV9XG4gKi9cbidwbGF5c2lubGluZSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgSHRtbDUucHJvdG90eXBlWydzZXQnICsgdG9UaXRsZUNhc2UocHJvcCldID0gZnVuY3Rpb24gKHYpIHtcbiAgICB0aGlzLmVsX1twcm9wXSA9IHY7XG5cbiAgICBpZiAodikge1xuICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKHByb3AsIHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsXy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgfVxuICB9O1xufSk7XG5cbi8vIFdyYXAgbmF0aXZlIHByb3BlcnRpZXMgd2l0aCBhIGdldHRlclxuLy8gVGhlIGxpc3QgaXMgYXMgZm9sbG93ZWRcbi8vIHBhdXNlZCwgY3VycmVudFRpbWUsIGJ1ZmZlcmVkLCB2b2x1bWUsIHBvc3RlciwgcHJlbG9hZCwgZXJyb3IsIHNlZWtpbmdcbi8vIHNlZWthYmxlLCBlbmRlZCwgcGxheWJhY2tSYXRlLCBkZWZhdWx0UGxheWJhY2tSYXRlLCBwbGF5ZWQsIG5ldHdvcmtTdGF0ZVxuLy8gcmVhZHlTdGF0ZSwgdmlkZW9XaWR0aCwgdmlkZW9IZWlnaHRcbltcbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcGF1c2VkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcGF1c2VkYCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgbWVkaWEgZWxlbWVudFxuICogaXMgY3VycmVudGx5IHBhdXNlZCBvciBub3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwYXVzZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcGF1c2VkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtcGF1c2VkfVxuICovXG4ncGF1c2VkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBjdXJyZW50VGltZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGN1cnJlbnRUaW1lYCBpbmRpY2F0ZXNcbiAqIHRoZSBjdXJyZW50IHNlY29uZCB0aGF0IHRoZSBtZWRpYSBpcyBhdCBpbiBwbGF5YmFjay5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I2N1cnJlbnRUaW1lXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgY3VycmVudFRpbWVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1jdXJyZW50dGltZX1cbiAqL1xuJ2N1cnJlbnRUaW1lJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBidWZmZXJlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGJ1ZmZlcmVkYCBpcyBhIGBUaW1lUmFuZ2VgXG4gKiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXJ0cyBvZiB0aGUgbWVkaWEgdGhhdCBhcmUgYWxyZWFkeSBkb3dubG9hZGVkIGFuZFxuICogYXZhaWxhYmxlIGZvciBwbGF5YmFjay5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I2J1ZmZlcmVkXG4gKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgYnVmZmVyZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1idWZmZXJlZH1cbiAqL1xuJ2J1ZmZlcmVkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGB2b2x1bWVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGB2b2x1bWVgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgcGxheWJhY2sgdm9sdW1lIG9mIGF1ZGlvIGZvciBhIG1lZGlhLiBgdm9sdW1lYCB3aWxsIGJlIGEgdmFsdWUgZnJvbSAwXG4gKiAoc2lsZW50KSB0byAxIChsb3VkZXN0IGFuZCBkZWZhdWx0KS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3ZvbHVtZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHZvbHVtZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gVmFsdWUgd2lsbCBiZSBiZXR3ZWVuIDAtMS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLWEtdm9sdW1lfVxuICovXG4ndm9sdW1lJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwb3N0ZXJgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwb3N0ZXJgIGluZGljYXRlc1xuICogdGhhdCB0aGUgdXJsIG9mIGFuIGltYWdlIGZpbGUgdGhhdCBjYW4vd2lsbCBiZSBzaG93biB3aGVuIG5vIG1lZGlhIGRhdGEgaXMgYXZhaWxhYmxlLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjcG9zdGVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcG9zdGVyYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBWYWx1ZSB3aWxsIGJlIGEgdXJsIHRvIGFuXG4gKiAgICAgICAgIGltYWdlLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLXZpZGVvLXBvc3Rlcn1cbiAqL1xuJ3Bvc3RlcicsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcHJlbG9hZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHByZWxvYWRgIGluZGljYXRlc1xuICogd2hhdCBzaG91bGQgZG93bmxvYWQgYmVmb3JlIHRoZSBtZWRpYSBpcyBpbnRlcmFjdGVkIHdpdGguIEl0IGNhbiBoYXZlIHRoZSBmb2xsb3dpbmdcbiAqIHZhbHVlczpcbiAqIC0gbm9uZTogbm90aGluZyBzaG91bGQgYmUgZG93bmxvYWRlZFxuICogLSBtZXRhZGF0YTogcG9zdGVyIGFuZCB0aGUgZmlyc3QgZmV3IGZyYW1lcyBvZiB0aGUgbWVkaWEgbWF5IGJlIGRvd25sb2FkZWQgdG8gZ2V0XG4gKiAgIG1lZGlhIGRpbWVuc2lvbnMgYW5kIG90aGVyIG1ldGFkYXRhXG4gKiAtIGF1dG86IGFsbG93IHRoZSBtZWRpYSBhbmQgbWV0YWRhdGEgZm9yIHRoZSBtZWRpYSB0byBiZSBkb3dubG9hZGVkIGJlZm9yZVxuICogICAgaW50ZXJhY3Rpb25cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3ByZWxvYWRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwcmVsb2FkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBXaWxsIGJlICdub25lJywgJ21ldGFkYXRhJyxcbiAqICAgICAgICAgb3IgJ2F1dG8nLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLXByZWxvYWR9XG4gKi9cbidwcmVsb2FkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBgZXJyb3JgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBlcnJvcmAgaW5kaWNhdGVzIGFueVxuICogTWVkaWFFcnJvciB0aGF0IG1heSBoYXZlIG9jY3VyZWQgZHVyaW5nIHBsYXliYWNrLiBJZiBlcnJvciByZXR1cm5zIG51bGwgdGhlcmUgaXMgbm9cbiAqIGN1cnJlbnQgZXJyb3IuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNlcnJvclxuICogQHJldHVybiB7TWVkaWFFcnJvcnxudWxsfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYGVycm9yYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBXaWxsIGJlIGBNZWRpYUVycm9yYCBpZiB0aGVyZVxuICogICAgICAgICBpcyBhIGN1cnJlbnQgZXJyb3IgYW5kIG51bGwgb3RoZXJ3aXNlLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtZXJyb3J9XG4gKi9cbidlcnJvcicsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgc2Vla2luZ2AgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHNlZWtpbmdgIGluZGljYXRlcyB3aGV0aGVyIHRoZVxuICogbWVkaWEgaXMgY3VycmVudGx5IHNlZWtpbmcgdG8gYSBuZXcgcG9zaXRpb24gb3Igbm90LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2Vla2luZ1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYHNlZWtpbmdgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgaXMgY3VycmVudGx5IHNlZWtpbmcgdG8gYSBuZXcgcG9zaXRpb24uXG4gKiAgICAgICAgIC0gRmxhc2UgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIGlzIG5vdCBzZWVraW5nIHRvIGEgbmV3IHBvc2l0aW9uIGF0IHRoaXMgdGltZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXNlZWtpbmd9XG4gKi9cbidzZWVraW5nJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBzZWVrYWJsZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHNlZWthYmxlYCByZXR1cm5zIGFcbiAqIGBUaW1lUmFuZ2VgIG9iamVjdCBpbmRpY2F0aW5nIHJhbmdlcyBvZiB0aW1lIHRoYXQgY2FuIGN1cnJlbnRseSBiZSBgc2Vla2VkYCB0by5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NlZWthYmxlXG4gKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgc2Vla2FibGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIEEgYFRpbWVSYW5nZWAgb2JqZWN0XG4gKiAgICAgICAgIGluZGljYXRpbmcgdGhlIGN1cnJlbnQgcmFuZ2VzIG9mIHRpbWUgdGhhdCBjYW4gYmUgc2Vla2VkIHRvLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtc2Vla2FibGV9XG4gKi9cbidzZWVrYWJsZScsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgZW5kZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBlbmRlZGAgaW5kaWNhdGVzIHdoZXRoZXJcbiAqIHRoZSBtZWRpYSBoYXMgcmVhY2hlZCB0aGUgZW5kIG9yIG5vdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I2VuZGVkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgZW5kZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgaGFzIGVuZGVkLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBoYXMgbm90IGVuZGVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtZW5kZWR9XG4gKi9cbidlbmRlZCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheWJhY2tSYXRlYCBpbmRpY2F0ZXNcbiAqIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBtZWRpYSBpcyBjdXJyZW50bHkgcGxheWluZyBiYWNrLiBFeGFtcGxlczpcbiAqICAgLSBpZiBwbGF5YmFja1JhdGUgaXMgc2V0IHRvIDIsIG1lZGlhIHdpbGwgcGxheSB0d2ljZSBhcyBmYXN0LlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMC41LCBtZWRpYSB3aWxsIHBsYXkgaGFsZiBhcyBmYXN0LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjcGxheWJhY2tSYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIG51bWJlciBpbmRpY2F0aW5nXG4gKiAgICAgICAgIHRoZSBjdXJyZW50IHBsYXliYWNrIHNwZWVkIG9mIHRoZSBtZWRpYSwgd2hlcmUgMSBpcyBub3JtYWwgc3BlZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5YmFja3JhdGV9XG4gKi9cbidwbGF5YmFja1JhdGUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRQbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBpbmRpY2F0ZXNcbiAqIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBtZWRpYSBpcyBjdXJyZW50bHkgcGxheWluZyBiYWNrLiBUaGlzIHZhbHVlIHdpbGwgbm90IGluZGljYXRlIHRoZSBjdXJyZW50XG4gKiBgcGxheWJhY2tSYXRlYCBhZnRlciBwbGF5YmFjayBoYXMgc3RhcnRlZCwgdXNlIHtAbGluayBIdG1sNSNwbGF5YmFja1JhdGV9IGZvciB0aGF0LlxuICpcbiAqIEV4YW1wbGVzOlxuICogICAtIGlmIGRlZmF1bHRQbGF5YmFja1JhdGUgaXMgc2V0IHRvIDIsIG1lZGlhIHdpbGwgcGxheSB0d2ljZSBhcyBmYXN0LlxuICogICAtIGlmIGRlZmF1bHRQbGF5YmFja1JhdGUgaXMgc2V0IHRvIDAuNSwgbWVkaWEgd2lsbCBwbGF5IGhhbGYgYXMgZmFzdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1LnByb3RvdHlwZS5kZWZhdWx0UGxheWJhY2tSYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgZGVmYXVsdFBsYXliYWNrUmF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gQSBudW1iZXIgaW5kaWNhdGluZ1xuICogICAgICAgICB0aGUgY3VycmVudCBwbGF5YmFjayBzcGVlZCBvZiB0aGUgbWVkaWEsIHdoZXJlIDEgaXMgbm9ybWFsIHNwZWVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtcGxheWJhY2tyYXRlfVxuICovXG4nZGVmYXVsdFBsYXliYWNrUmF0ZScsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcGxheWVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheWVkYCByZXR1cm5zIGEgYFRpbWVSYW5nZWBcbiAqIG9iamVjdCByZXByZXNlbnRpbmcgcG9pbnRzIGluIHRoZSBtZWRpYSB0aW1lbGluZSB0aGF0IGhhdmUgYmVlbiBwbGF5ZWQuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwbGF5ZWRcbiAqIEByZXR1cm4ge1RpbWVSYW5nZX1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwbGF5ZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIEEgYFRpbWVSYW5nZWAgb2JqZWN0IGluZGljYXRpbmdcbiAqICAgICAgICAgdGhlIHJhbmdlcyBvZiB0aW1lIHRoYXQgaGF2ZSBiZWVuIHBsYXllZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXBsYXllZH1cbiAqL1xuJ3BsYXllZCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgbmV0d29ya1N0YXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgbmV0d29ya1N0YXRlYCBpbmRpY2F0ZXNcbiAqIHRoZSBjdXJyZW50IG5ldHdvcmsgc3RhdGUuIEl0IHJldHVybnMgYW4gZW51bWVyYXRpb24gZnJvbSB0aGUgZm9sbG93aW5nIGxpc3Q6XG4gKiAtIDA6IE5FVFdPUktfRU1QVFlcbiAqIC0gMTogTkVXT1JLX0lETEVcbiAqIC0gMjogTkVUV09SS19MT0FESU5HXG4gKiAtIDM6IE5FVFdPUktfTk9fU09VUkNFXG4gKlxuICogQG1ldGhvZCBIdG1sNSNuZXR3b3JrU3RhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBuZXR3b3JrU3RhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIFRoaXMgd2lsbCBiZSBhIG51bWJlclxuICogICAgICAgICBmcm9tIHRoZSBsaXN0IGluIHRoZSBkZXNjcmlwdGlvbi5cbiAqXG4gKiBAc2VlIFtTcGVjXSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1uZXR3b3Jrc3RhdGV9XG4gKi9cbiduZXR3b3JrU3RhdGUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHJlYWR5U3RhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGByZWFkeVN0YXRlYCBpbmRpY2F0ZXNcbiAqIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBtZWRpYSBlbGVtZW50LiBJdCByZXR1cm5zIGFuIGVudW1lcmF0aW9uIGZyb20gdGhlXG4gKiBmb2xsb3dpbmcgbGlzdDpcbiAqIC0gMDogSEFWRV9OT1RISU5HXG4gKiAtIDE6IEhBVkVfTUVUQURBVEFcbiAqIC0gMjogSEFWRV9DVVJSRU5UX0RBVEFcbiAqIC0gMzogSEFWRV9GVVRVUkVfREFUQVxuICogLSA0OiBIQVZFX0VOT1VHSF9EQVRBXG4gKlxuICogQG1ldGhvZCBIdG1sNSNyZWFkeVN0YXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcmVhZHlTdGF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gVGhpcyB3aWxsIGJlIGEgbnVtYmVyXG4gKiAgICAgICAgIGZyb20gdGhlIGxpc3QgaW4gdGhlIGRlc2NyaXB0aW9uLlxuICpcbiAqIEBzZWUgW1NwZWNdIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjcmVhZHktc3RhdGVzfVxuICovXG4ncmVhZHlTdGF0ZScsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgdmlkZW9XaWR0aGAgZnJvbSB0aGUgdmlkZW8gZWxlbWVudC4gYHZpZGVvV2lkdGhgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIHZpZGVvIGluIGNzcyBwaXhlbHMuXG4gKlxuICogQG1ldGhvZCBIdG1sNSN2aWRlb1dpZHRoXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgdmlkZW9XaWR0aGAgZnJvbSB0aGUgdmlkZW8gZWxlbWVudC4gVGhpcyB3aWxsIGJlIGEgbnVtYmVyXG4gKiAgICAgICAgIGluIGNzcyBwaXhlbHMuXG4gKlxuICogQHNlZSBbU3BlY10ge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tdmlkZW8tdmlkZW93aWR0aH1cbiAqL1xuJ3ZpZGVvV2lkdGgnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHZpZGVvSGVpZ2h0YCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LiBgdmlkZW9IZWlndGhgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSB2aWRlbyBpbiBjc3MgcGl4ZWxzLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjdmlkZW9IZWlnaHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGB2aWRlb0hlaWdodGAgZnJvbSB0aGUgdmlkZW8gZWxlbWVudC4gVGhpcyB3aWxsIGJlIGEgbnVtYmVyXG4gKiAgICAgICAgIGluIGNzcyBwaXhlbHMuXG4gKlxuICogQHNlZSBbU3BlY10ge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tdmlkZW8tdmlkZW93aWR0aH1cbiAqL1xuJ3ZpZGVvSGVpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBIdG1sNS5wcm90b3R5cGVbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfW3Byb3BdO1xuICB9O1xufSk7XG5cbi8vIFdyYXAgbmF0aXZlIHByb3BlcnRpZXMgd2l0aCBhIHNldHRlciBpbiB0aGlzIGZvcm1hdDpcbi8vIHNldCArIHRvVGl0bGVDYXNlKG5hbWUpXG4vLyBUaGUgbGlzdCBpcyBhcyBmb2xsb3dzOlxuLy8gc2V0Vm9sdW1lLCBzZXRTcmMsIHNldFBvc3Rlciwgc2V0UHJlbG9hZCwgc2V0UGxheWJhY2tSYXRlLCBzZXREZWZhdWx0UGxheWJhY2tSYXRlXG5bXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYHZvbHVtZWAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGB2b2x1bWVgIGluZGljYXRlcyB0aGUgY3VycmVudFxuICogYXVkaW8gbGV2ZWwgYXMgYSBwZXJjZW50YWdlIGluIGRlY2ltYWwgZm9ybS4gVGhpcyBtZWFucyB0aGF0IDEgaXMgMTAwJSwgMC41IGlzIDUwJSwgYW5kXG4gKiBzbyBvbi5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldFZvbHVtZVxuICogQHBhcmFtIHtudW1iZXJ9IHBlcmNlbnRBc0RlY2ltYWxcbiAqICAgICAgICBUaGUgdm9sdW1lIHBlcmNlbnQgYXMgYSBkZWNpbWFsLiBWYWxpZCByYW5nZSBpcyBmcm9tIDAtMS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLWEtdm9sdW1lfVxuICovXG4ndm9sdW1lJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBzcmNgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgc3JjYCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnRcbiAqIHtAbGluayBUZWNoflNvdXJjZU9iamVjdH0gZm9yIHRoZSBtZWRpYS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldFNyY1xuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc3JjXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3QgdG8gc2V0IGFzIHRoZSBjdXJyZW50IHNvdXJjZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXNyY31cbiAqL1xuJ3NyYycsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgcG9zdGVyYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYHBvc3RlcmAgaXMgdGhlIHVybCB0b1xuICogYW4gaW1hZ2UgZmlsZSB0aGF0IGNhbi93aWxsIGJlIHNob3duIHdoZW4gbm8gbWVkaWEgZGF0YSBpcyBhdmFpbGFibGUuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZXRQb3N0ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3N0ZXJcbiAqICAgICAgICBUaGUgdXJsIHRvIGFuIGltYWdlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIGBwb3N0ZXJgIGZvciB0aGUgbWVkaWFcbiAqICAgICAgICBlbGVtZW50LlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLXBvc3Rlcn1cbiAqL1xuJ3Bvc3RlcicsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgcHJlbG9hZGAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBwcmVsb2FkYCBpbmRpY2F0ZXNcbiAqIHdoYXQgc2hvdWxkIGRvd25sb2FkIGJlZm9yZSB0aGUgbWVkaWEgaXMgaW50ZXJhY3RlZCB3aXRoLiBJdCBjYW4gaGF2ZSB0aGUgZm9sbG93aW5nXG4gKiB2YWx1ZXM6XG4gKiAtIG5vbmU6IG5vdGhpbmcgc2hvdWxkIGJlIGRvd25sb2FkZWRcbiAqIC0gbWV0YWRhdGE6IHBvc3RlciBhbmQgdGhlIGZpcnN0IGZldyBmcmFtZXMgb2YgdGhlIG1lZGlhIG1heSBiZSBkb3dubG9hZGVkIHRvIGdldFxuICogICBtZWRpYSBkaW1lbnNpb25zIGFuZCBvdGhlciBtZXRhZGF0YVxuICogLSBhdXRvOiBhbGxvdyB0aGUgbWVkaWEgYW5kIG1ldGFkYXRhIGZvciB0aGUgbWVkaWEgdG8gYmUgZG93bmxvYWRlZCBiZWZvcmVcbiAqICAgIGludGVyYWN0aW9uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZXRQcmVsb2FkXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlbG9hZFxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHByZWxvYWRgIHRvIHNldCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gTXVzdCBiZSAnbm9uZScsICdtZXRhZGF0YScsXG4gKiAgICAgICAgIG9yICdhdXRvJy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1wcmVsb2FkfVxuICovXG4ncHJlbG9hZCcsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgcGxheWJhY2tSYXRlYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYHBsYXliYWNrUmF0ZWAgaW5kaWNhdGVzXG4gKiB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgbWVkaWEgc2hvdWxkIHBsYXkgYmFjay4gRXhhbXBsZXM6XG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAyLCBtZWRpYSB3aWxsIHBsYXkgdHdpY2UgYXMgZmFzdC5cbiAqICAgLSBpZiBwbGF5YmFja1JhdGUgaXMgc2V0IHRvIDAuNSwgbWVkaWEgd2lsbCBwbGF5IGhhbGYgYXMgZmFzdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldFBsYXliYWNrUmF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHBsYXliYWNrUmF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gQSBudW1iZXIgaW5kaWNhdGluZ1xuICogICAgICAgICB0aGUgY3VycmVudCBwbGF5YmFjayBzcGVlZCBvZiB0aGUgbWVkaWEsIHdoZXJlIDEgaXMgbm9ybWFsIHNwZWVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtcGxheWJhY2tyYXRlfVxuICovXG4ncGxheWJhY2tSYXRlJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYGRlZmF1bHRQbGF5YmFja1JhdGVgIGluZGljYXRlc1xuICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIG1lZGlhIHNob3VsZCBwbGF5IGJhY2sgdXBvbiBpbml0aWFsIHN0YXJ0dXAuIENoYW5naW5nIHRoaXMgdmFsdWVcbiAqIGFmdGVyIGEgdmlkZW8gaGFzIHN0YXJ0ZWQgd2lsbCBkbyBub3RoaW5nLiBJbnN0ZWFkIHlvdSBzaG91bGQgdXNlZCB7QGxpbmsgSHRtbDUjc2V0UGxheWJhY2tSYXRlfS5cbiAqXG4gKiBFeGFtcGxlIFZhbHVlczpcbiAqICAgLSBpZiBwbGF5YmFja1JhdGUgaXMgc2V0IHRvIDIsIG1lZGlhIHdpbGwgcGxheSB0d2ljZSBhcyBmYXN0LlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMC41LCBtZWRpYSB3aWxsIHBsYXkgaGFsZiBhcyBmYXN0LlxuICpcbiAqIEBtZXRob2QgSHRtbDUucHJvdG90eXBlLnNldERlZmF1bHRQbGF5YmFja1JhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIG51bWJlciBpbmRpY2F0aW5nXG4gKiAgICAgICAgIHRoZSBjdXJyZW50IHBsYXliYWNrIHNwZWVkIG9mIHRoZSBtZWRpYSwgd2hlcmUgMSBpcyBub3JtYWwgc3BlZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1kZWZhdWx0cGxheWJhY2tyYXRlfVxuICovXG4nZGVmYXVsdFBsYXliYWNrUmF0ZSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgSHRtbDUucHJvdG90eXBlWydzZXQnICsgdG9UaXRsZUNhc2UocHJvcCldID0gZnVuY3Rpb24gKHYpIHtcbiAgICB0aGlzLmVsX1twcm9wXSA9IHY7XG4gIH07XG59KTtcblxuLy8gd3JhcCBuYXRpdmUgZnVuY3Rpb25zIHdpdGggYSBmdW5jdGlvblxuLy8gVGhlIGxpc3QgaXMgYXMgZm9sbG93czpcbi8vIHBhdXNlLCBsb2FkIHBsYXlcbltcbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgbWVkaWEgZWxlbWVudHMgYHBhdXNlYCBmdW5jdGlvbi4gVGhpcyB3aWxsIGNhbGwgdGhlIGBIVE1MNWBcbiAqIG1lZGlhIGVsZW1lbnRzIGBwYXVzZWAgZnVuY3Rpb24uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwYXVzZVxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wYXVzZX1cbiAqL1xuJ3BhdXNlJyxcblxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBtZWRpYSBlbGVtZW50cyBgbG9hZGAgZnVuY3Rpb24uIFRoaXMgd2lsbCBjYWxsIHRoZSBgSFRNTDVgc1xuICogbWVkaWEgZWxlbWVudCBgbG9hZGAgZnVuY3Rpb24uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNsb2FkXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWxvYWR9XG4gKi9cbidsb2FkJyxcblxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBtZWRpYSBlbGVtZW50cyBgcGxheWAgZnVuY3Rpb24uIFRoaXMgd2lsbCBjYWxsIHRoZSBgSFRNTDVgc1xuICogbWVkaWEgZWxlbWVudCBgcGxheWAgZnVuY3Rpb24uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwbGF5XG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXBsYXl9XG4gKi9cbidwbGF5J10uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBIdG1sNS5wcm90b3R5cGVbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfW3Byb3BdKCk7XG4gIH07XG59KTtcblxuVGVjaC53aXRoU291cmNlSGFuZGxlcnMoSHRtbDUpO1xuXG4vKipcbiAqIE5hdGl2ZSBzb3VyY2UgaGFuZGxlciBmb3IgSHRtbDUsIHNpbXBseSBwYXNzZXMgdGhlIHNvdXJjZSB0byB0aGUgbWVkaWEgZWxlbWVudC5cbiAqXG4gKiBAcHJvcHJldHkge1RlY2h+U291cmNlT2JqZWN0fSBzb3VyY2VcbiAqICAgICAgICBUaGUgc291cmNlIG9iamVjdFxuICpcbiAqIEBwcm9wcmV0eSB7SHRtbDV9IHRlY2hcbiAqICAgICAgICBUaGUgaW5zdGFuY2Ugb2YgdGhlIEhUTUw1IHRlY2guXG4gKi9cbkh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIgPSB7fTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgbWVkaWEgZWxlbWVudCBjYW4gcGxheSB0aGUgZ2l2ZW4gbWltZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgLy8gSUU5IG9uIFdpbmRvd3MgNyB3aXRob3V0IE1lZGlhUGxheWVyIHRocm93cyBhbiBlcnJvciBoZXJlXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy81MTlcbiAgdHJ5IHtcbiAgICByZXR1cm4gSHRtbDUuVEVTVF9WSUQuY2FuUGxheVR5cGUodHlwZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIG1lZGlhIGVsZW1lbnQgY2FuIGhhbmRsZSBhIHNvdXJjZSBuYXRpdmVseS5cbiAqXG4gKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzb3VyY2VcbiAqICAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgICAgICAgIE9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIHRoZSB0ZWNoLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZykuXG4gKi9cbkh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuY2FuSGFuZGxlU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSwgb3B0aW9ucykge1xuXG4gIC8vIElmIGEgdHlwZSB3YXMgcHJvdmlkZWQgd2Ugc2hvdWxkIHJlbHkgb24gdGhhdFxuICBpZiAoc291cmNlLnR5cGUpIHtcbiAgICByZXR1cm4gSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5jYW5QbGF5VHlwZShzb3VyY2UudHlwZSk7XG5cbiAgICAvLyBJZiBubyB0eXBlLCBmYWxsIGJhY2sgdG8gY2hlY2tpbmcgJ3ZpZGVvL1tFWFRFTlNJT05dJ1xuICB9IGVsc2UgaWYgKHNvdXJjZS5zcmMpIHtcbiAgICB2YXIgZXh0ID0gZ2V0RmlsZUV4dGVuc2lvbihzb3VyY2Uuc3JjKTtcblxuICAgIHJldHVybiBIdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmNhblBsYXlUeXBlKCd2aWRlby8nICsgZXh0KTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn07XG5cbi8qKlxuICogUGFzcyB0aGUgc291cmNlIHRvIHRoZSBuYXRpdmUgbWVkaWEgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzb3VyY2VcbiAqICAgICAgICBUaGUgc291cmNlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7SHRtbDV9IHRlY2hcbiAqICAgICAgICBUaGUgaW5zdGFuY2Ugb2YgdGhlIEh0bWw1IHRlY2hcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgICAgICAgVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgc291cmNlXG4gKi9cbkh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuaGFuZGxlU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSwgdGVjaCwgb3B0aW9ucykge1xuICB0ZWNoLnNldFNyYyhzb3VyY2Uuc3JjKTtcbn07XG5cbi8qKlxuICogQSBub29wIGZvciB0aGUgbmF0aXZlIGRpc3Bvc2UgZnVuY3Rpb24sIGFzIGNsZWFudXAgaXMgbm90IG5lZWRlZC5cbiAqL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XG5cbi8vIFJlZ2lzdGVyIHRoZSBuYXRpdmUgc291cmNlIGhhbmRsZXJcbkh0bWw1LnJlZ2lzdGVyU291cmNlSGFuZGxlcihIdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyKTtcblxuVGVjaC5yZWdpc3RlclRlY2goJ0h0bWw1JywgSHRtbDUpO1xuXG52YXIgX3RlbXBsYXRlT2JqZWN0JDEgPSB0YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZShbJ1xcbiAgICAgICAgVXNpbmcgdGhlIHRlY2ggZGlyZWN0bHkgY2FuIGJlIGRhbmdlcm91cy4gSSBob3BlIHlvdSBrbm93IHdoYXQgeW91XFwncmUgZG9pbmcuXFxuICAgICAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvaXNzdWVzLzI2MTcgZm9yIG1vcmUgaW5mby5cXG4gICAgICAnXSwgWydcXG4gICAgICAgIFVzaW5nIHRoZSB0ZWNoIGRpcmVjdGx5IGNhbiBiZSBkYW5nZXJvdXMuIEkgaG9wZSB5b3Uga25vdyB3aGF0IHlvdVxcJ3JlIGRvaW5nLlxcbiAgICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8yNjE3IGZvciBtb3JlIGluZm8uXFxuICAgICAgJ10pO1xuXG4vKipcbiAqIEBmaWxlIHBsYXllci5qc1xuICovXG4vLyBTdWJjbGFzc2VzIENvbXBvbmVudFxuLy8gVGhlIGZvbGxvd2luZyBpbXBvcnRzIGFyZSB1c2VkIG9ubHkgdG8gZW5zdXJlIHRoYXQgdGhlIGNvcnJlc3BvbmRpbmcgbW9kdWxlc1xuLy8gYXJlIGFsd2F5cyBpbmNsdWRlZCBpbiB0aGUgdmlkZW8uanMgcGFja2FnZS4gSW1wb3J0aW5nIHRoZSBtb2R1bGVzIHdpbGxcbi8vIGV4ZWN1dGUgdGhlbSBhbmQgdGhleSB3aWxsIHJlZ2lzdGVyIHRoZW1zZWx2ZXMgd2l0aCB2aWRlby5qcy5cbi8vIEltcG9ydCBIdG1sNSB0ZWNoLCBhdCBsZWFzdCBmb3IgZGlzcG9zaW5nIHRoZSBvcmlnaW5hbCB2aWRlbyB0YWcuXG4vLyBUaGUgZm9sbG93aW5nIHRlY2ggZXZlbnRzIGFyZSBzaW1wbHkgcmUtdHJpZ2dlcmVkXG4vLyBvbiB0aGUgcGxheWVyIHdoZW4gdGhleSBoYXBwZW5cbnZhciBURUNIX0VWRU5UU19SRVRSSUdHRVIgPSBbXG4vKipcbiAqIEZpcmVkIHdoaWxlIHRoZSB1c2VyIGFnZW50IGlzIGRvd25sb2FkaW5nIG1lZGlhIGRhdGEuXG4gKlxuICogQGV2ZW50IFBsYXllciNwcm9ncmVzc1xuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHByb2dyZXNzYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFByb2dyZXNzX1xuICogQGZpcmVzIFBsYXllciNwcm9ncmVzc1xuICogQGxpc3RlbnMgVGVjaCNwcm9ncmVzc1xuICovXG4ncHJvZ3Jlc3MnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIGxvYWRpbmcgb2YgYW4gYXVkaW8vdmlkZW8gaXMgYWJvcnRlZC5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI2Fib3J0XG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgYWJvcnRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoQWJvcnRfXG4gKiBAZmlyZXMgUGxheWVyI2Fib3J0XG4gKiBAbGlzdGVucyBUZWNoI2Fib3J0XG4gKi9cbidhYm9ydCcsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgYnJvd3NlciBpcyBpbnRlbnRpb25hbGx5IG5vdCBnZXR0aW5nIG1lZGlhIGRhdGEuXG4gKlxuICogQGV2ZW50IFBsYXllciNzdXNwZW5kXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgc3VzcGVuZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hTdXNwZW5kX1xuICogQGZpcmVzIFBsYXllciNzdXNwZW5kXG4gKiBAbGlzdGVucyBUZWNoI3N1c3BlbmRcbiAqL1xuJ3N1c3BlbmQnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIGN1cnJlbnQgcGxheWxpc3QgaXMgZW1wdHkuXG4gKlxuICogQGV2ZW50IFBsYXllciNlbXB0aWVkXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgZW1wdGllZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hFbXB0aWVkX1xuICogQGZpcmVzIFBsYXllciNlbXB0aWVkXG4gKiBAbGlzdGVucyBUZWNoI2VtcHRpZWRcbiAqL1xuJ2VtcHRpZWQnLFxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBicm93c2VyIGlzIHRyeWluZyB0byBnZXQgbWVkaWEgZGF0YSwgYnV0IGRhdGEgaXMgbm90IGF2YWlsYWJsZS5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI3N0YWxsZWRcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGBzdGFsbGVkYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFN0YWxsZWRfXG4gKiBAZmlyZXMgUGxheWVyI3N0YWxsZWRcbiAqIEBsaXN0ZW5zIFRlY2gjc3RhbGxlZFxuICovXG4nc3RhbGxlZCcsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgYnJvd3NlciBoYXMgbG9hZGVkIG1ldGEgZGF0YSBmb3IgdGhlIGF1ZGlvL3ZpZGVvLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjbG9hZGVkbWV0YWRhdGFcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGBzdGFsbGVkYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaExvYWRlZG1ldGFkYXRhX1xuICogQGZpcmVzIFBsYXllciNsb2FkZWRtZXRhZGF0YVxuICogQGxpc3RlbnMgVGVjaCNsb2FkZWRtZXRhZGF0YVxuICovXG4nbG9hZGVkbWV0YWRhdGEnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaGFzIGxvYWRlZCB0aGUgY3VycmVudCBmcmFtZSBvZiB0aGUgYXVkaW8vdmlkZW8uXG4gKlxuICogQGV2ZW50IFBsYXllciNsb2FkZWRkYXRhXG4gKiBAdHlwZSB7ZXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgbG9hZGVkZGF0YWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hMb2FkZGVkZGF0YV9cbiAqIEBmaXJlcyBQbGF5ZXIjbG9hZGVkZGF0YVxuICogQGxpc3RlbnMgVGVjaCNsb2FkZWRkYXRhXG4gKi9cbidsb2FkZWRkYXRhJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGhhcyBjaGFuZ2VkLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjdGltZXVwZGF0ZVxuICogQHR5cGUge2V2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHRpbWV1cGRhdGVgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoVGltZVVwZGF0ZV9cbiAqIEBmaXJlcyBQbGF5ZXIjdGltZXVwZGF0ZVxuICogQGxpc3RlbnMgVGVjaCN0aW1ldXBkYXRlXG4gKi9cbid0aW1ldXBkYXRlJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBwbGF5aW5nIHNwZWVkIG9mIHRoZSBhdWRpby92aWRlbyBpcyBjaGFuZ2VkXG4gKlxuICogQGV2ZW50IFBsYXllciNyYXRlY2hhbmdlXG4gKiBAdHlwZSB7ZXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgcmF0ZWNoYW5nZWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hSYXRlY2hhbmdlX1xuICogQGZpcmVzIFBsYXllciNyYXRlY2hhbmdlXG4gKiBAbGlzdGVucyBUZWNoI3JhdGVjaGFuZ2VcbiAqL1xuJ3JhdGVjaGFuZ2UnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIHZpZGVvJ3MgaW50cmluc2ljIGRpbWVuc2lvbnMgY2hhbmdlXG4gKlxuICogQGV2ZW50IFBsYXllciNyZXNpemVcbiAqIEB0eXBlIHtldmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGByZXNpemVgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoUmVzaXplX1xuICogQGZpcmVzIFBsYXllciNyZXNpemVcbiAqIEBsaXN0ZW5zIFRlY2gjcmVzaXplXG4gKi9cbidyZXNpemUnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIHZvbHVtZSBoYXMgYmVlbiBjaGFuZ2VkXG4gKlxuICogQGV2ZW50IFBsYXllciN2b2x1bWVjaGFuZ2VcbiAqIEB0eXBlIHtldmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGB2b2x1bWVjaGFuZ2VgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoVm9sdW1lY2hhbmdlX1xuICogQGZpcmVzIFBsYXllciN2b2x1bWVjaGFuZ2VcbiAqIEBsaXN0ZW5zIFRlY2gjdm9sdW1lY2hhbmdlXG4gKi9cbid2b2x1bWVjaGFuZ2UnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIHRleHQgdHJhY2sgaGFzIGJlZW4gY2hhbmdlZFxuICpcbiAqIEBldmVudCBQbGF5ZXIjdGV4dHRyYWNrY2hhbmdlXG4gKiBAdHlwZSB7ZXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgdGV4dHRyYWNrY2hhbmdlYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFRleHR0cmFja2NoYW5nZV9cbiAqIEBmaXJlcyBQbGF5ZXIjdGV4dHRyYWNrY2hhbmdlXG4gKiBAbGlzdGVucyBUZWNoI3RleHR0cmFja2NoYW5nZVxuICovXG4ndGV4dHRyYWNrY2hhbmdlJ107XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIGBQbGF5ZXJgIGNsYXNzIGlzIGNyZWF0ZWQgd2hlbiBhbnkgb2YgdGhlIFZpZGVvLmpzIHNldHVwIG1ldGhvZHNcbiAqIGFyZSB1c2VkIHRvIGluaXRpYWxpemUgYSB2aWRlby5cbiAqXG4gKiBBZnRlciBhbiBpbnN0YW5jZSBoYXMgYmVlbiBjcmVhdGVkIGl0IGNhbiBiZSBhY2Nlc3NlZCBnbG9iYWxseSBpbiB0d28gd2F5czpcbiAqIDEuIEJ5IGNhbGxpbmcgYHZpZGVvanMoJ2V4YW1wbGVfdmlkZW9fMScpO2BcbiAqIDIuIEJ5IHVzaW5nIGl0IGRpcmVjdGx5IHZpYSAgYHZpZGVvanMucGxheWVycy5leGFtcGxlX3ZpZGVvXzE7YFxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBQbGF5ZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhQbGF5ZXIsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YWdcbiAgICogICAgICAgIFRoZSBvcmlnaW5hbCB2aWRlbyBET00gZWxlbWVudCB1c2VkIGZvciBjb25maWd1cmluZyBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFJlYWR5IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gUGxheWVyKHRhZywgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5ZXIpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRhZyBJRCBleGlzdHNcbiAgICB0YWcuaWQgPSB0YWcuaWQgfHwgJ3Zqc192aWRlb18nICsgbmV3R1VJRCgpO1xuXG4gICAgLy8gU2V0IE9wdGlvbnNcbiAgICAvLyBUaGUgb3B0aW9ucyBhcmd1bWVudCBvdmVycmlkZXMgb3B0aW9ucyBzZXQgaW4gdGhlIHZpZGVvIHRhZ1xuICAgIC8vIHdoaWNoIG92ZXJyaWRlcyBnbG9iYWxseSBzZXQgb3B0aW9ucy5cbiAgICAvLyBUaGlzIGxhdHRlciBwYXJ0IGNvaW5jaWRlcyB3aXRoIHRoZSBsb2FkIG9yZGVyXG4gICAgLy8gKHRhZyBtdXN0IGV4aXN0IGJlZm9yZSBQbGF5ZXIpXG4gICAgb3B0aW9ucyA9IGFzc2lnbihQbGF5ZXIuZ2V0VGFnU2V0dGluZ3ModGFnKSwgb3B0aW9ucyk7XG5cbiAgICAvLyBEZWxheSB0aGUgaW5pdGlhbGl6YXRpb24gb2YgY2hpbGRyZW4gYmVjYXVzZSB3ZSBuZWVkIHRvIHNldCB1cFxuICAgIC8vIHBsYXllciBwcm9wZXJ0aWVzIGZpcnN0LCBhbmQgY2FuJ3QgdXNlIGB0aGlzYCBiZWZvcmUgYHN1cGVyKClgXG4gICAgb3B0aW9ucy5pbml0Q2hpbGRyZW4gPSBmYWxzZTtcblxuICAgIC8vIFNhbWUgd2l0aCBjcmVhdGluZyB0aGUgZWxlbWVudFxuICAgIG9wdGlvbnMuY3JlYXRlRWwgPSBmYWxzZTtcblxuICAgIC8vIGRvbid0IGF1dG8gbWl4aW4gdGhlIGV2ZW50ZWQgbWl4aW5cbiAgICBvcHRpb25zLmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIHBsYXllciB0byByZXBvcnQgdG91Y2ggYWN0aXZpdHkgb24gaXRzZWxmXG4gICAgLy8gc2VlIGVuYWJsZVRvdWNoQWN0aXZpdHkgaW4gQ29tcG9uZW50XG4gICAgb3B0aW9ucy5yZXBvcnRUb3VjaEFjdGl2aXR5ID0gZmFsc2U7XG5cbiAgICAvLyBJZiBsYW5ndWFnZSBpcyBub3Qgc2V0LCBnZXQgdGhlIGNsb3Nlc3QgbGFuZyBhdHRyaWJ1dGVcbiAgICBpZiAoIW9wdGlvbnMubGFuZ3VhZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnLmNsb3Nlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNsb3Nlc3QgPSB0YWcuY2xvc2VzdCgnW2xhbmddJyk7XG5cbiAgICAgICAgaWYgKGNsb3Nlc3QgJiYgY2xvc2VzdC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICBvcHRpb25zLmxhbmd1YWdlID0gY2xvc2VzdC5nZXRBdHRyaWJ1dGUoJ2xhbmcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0YWc7XG5cbiAgICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIGlmIChnZXRBdHRyaWJ1dGVzKGVsZW1lbnQpLmhhc093blByb3BlcnR5KCdsYW5nJykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubGFuZ3VhZ2UgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbGFuZycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSdW4gYmFzZSBjb21wb25lbnQgaW5pdGlhbGl6aW5nIHdpdGggbmV3IG9wdGlvbnNcblxuICAgIC8vIFR1cm4gb2ZmIEFQSSBhY2Nlc3MgYmVjYXVzZSB3ZSdyZSBsb2FkaW5nIGEgbmV3IHRlY2ggdGhhdCBtaWdodCBsb2FkIGFzeW5jaHJvbm91c2x5XG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgbnVsbCwgb3B0aW9ucywgcmVhZHkpKTtcblxuICAgIF90aGlzLmlzUmVhZHlfID0gZmFsc2U7XG5cbiAgICAvLyBJbml0IHN0YXRlIGhhc1N0YXJ0ZWRfXG4gICAgX3RoaXMuaGFzU3RhcnRlZF8gPSBmYWxzZTtcblxuICAgIC8vIEluaXQgc3RhdGUgdXNlckFjdGl2ZV9cbiAgICBfdGhpcy51c2VyQWN0aXZlXyA9IGZhbHNlO1xuXG4gICAgLy8gaWYgdGhlIGdsb2JhbCBvcHRpb24gb2JqZWN0IHdhcyBhY2NpZGVudGFsbHkgYmxvd24gYXdheSBieVxuICAgIC8vIHNvbWVvbmUsIGJhaWwgZWFybHkgd2l0aCBhbiBpbmZvcm1hdGl2ZSBlcnJvclxuICAgIGlmICghX3RoaXMub3B0aW9uc18gfHwgIV90aGlzLm9wdGlvbnNfLnRlY2hPcmRlciB8fCAhX3RoaXMub3B0aW9uc18udGVjaE9yZGVyLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0ZWNoT3JkZXIgc3BlY2lmaWVkLiBEaWQgeW91IG92ZXJ3cml0ZSAnICsgJ3ZpZGVvanMub3B0aW9ucyBpbnN0ZWFkIG9mIGp1c3QgY2hhbmdpbmcgdGhlICcgKyAncHJvcGVydGllcyB5b3Ugd2FudCB0byBvdmVycmlkZT8nKTtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgdGFnIHVzZWQgdG8gc2V0IG9wdGlvbnNcbiAgICBfdGhpcy50YWcgPSB0YWc7XG5cbiAgICAvLyBTdG9yZSB0aGUgdGFnIGF0dHJpYnV0ZXMgdXNlZCB0byByZXN0b3JlIGh0bWw1IGVsZW1lbnRcbiAgICBfdGhpcy50YWdBdHRyaWJ1dGVzID0gdGFnICYmIGdldEF0dHJpYnV0ZXModGFnKTtcblxuICAgIC8vIFVwZGF0ZSBjdXJyZW50IGxhbmd1YWdlXG4gICAgX3RoaXMubGFuZ3VhZ2UoX3RoaXMub3B0aW9uc18ubGFuZ3VhZ2UpO1xuXG4gICAgLy8gVXBkYXRlIFN1cHBvcnRlZCBMYW5ndWFnZXNcbiAgICBpZiAob3B0aW9ucy5sYW5ndWFnZXMpIHtcbiAgICAgIC8vIE5vcm1hbGlzZSBwbGF5ZXIgb3B0aW9uIGxhbmd1YWdlcyB0byBsb3dlcmNhc2VcbiAgICAgIHZhciBsYW5ndWFnZXNUb0xvd2VyID0ge307XG5cbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9wdGlvbnMubGFuZ3VhZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XG4gICAgICAgIGxhbmd1YWdlc1RvTG93ZXJbbmFtZSQkMS50b0xvd2VyQ2FzZSgpXSA9IG9wdGlvbnMubGFuZ3VhZ2VzW25hbWUkJDFdO1xuICAgICAgfSk7XG4gICAgICBfdGhpcy5sYW5ndWFnZXNfID0gbGFuZ3VhZ2VzVG9Mb3dlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMubGFuZ3VhZ2VzXyA9IFBsYXllci5wcm90b3R5cGUub3B0aW9uc18ubGFuZ3VhZ2VzO1xuICAgIH1cblxuICAgIC8vIENhY2hlIGZvciB2aWRlbyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgX3RoaXMuY2FjaGVfID0ge307XG5cbiAgICAvLyBTZXQgcG9zdGVyXG4gICAgX3RoaXMucG9zdGVyXyA9IG9wdGlvbnMucG9zdGVyIHx8ICcnO1xuXG4gICAgLy8gU2V0IGNvbnRyb2xzXG4gICAgX3RoaXMuY29udHJvbHNfID0gISFvcHRpb25zLmNvbnRyb2xzO1xuXG4gICAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIGZvciBsYXN0Vm9sdW1lXG4gICAgX3RoaXMuY2FjaGVfLmxhc3RWb2x1bWUgPSAxO1xuXG4gICAgLy8gT3JpZ2luYWwgdGFnIHNldHRpbmdzIHN0b3JlZCBpbiBvcHRpb25zXG4gICAgLy8gbm93IHJlbW92ZSBpbW1lZGlhdGVseSBzbyBuYXRpdmUgY29udHJvbHMgZG9uJ3QgZmxhc2guXG4gICAgLy8gTWF5IGJlIHR1cm5lZCBiYWNrIG9uIGJ5IEhUTUw1IHRlY2ggaWYgbmF0aXZlQ29udHJvbHNGb3JUb3VjaCBpcyB0cnVlXG4gICAgdGFnLmNvbnRyb2xzID0gZmFsc2U7XG4gICAgdGFnLnJlbW92ZUF0dHJpYnV0ZSgnY29udHJvbHMnKTtcblxuICAgIC8qXG4gICAgICogU3RvcmUgdGhlIGludGVybmFsIHN0YXRlIG9mIHNjcnViYmluZ1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSB1c2VyIGlzIHNjcnViYmluZ1xuICAgICAqL1xuICAgIF90aGlzLnNjcnViYmluZ18gPSBmYWxzZTtcblxuICAgIF90aGlzLmVsXyA9IF90aGlzLmNyZWF0ZUVsKCk7XG5cbiAgICAvLyBNYWtlIHRoaXMgYW4gZXZlbnRlZCBvYmplY3QgYW5kIHVzZSBgZWxfYCBhcyBpdHMgZXZlbnQgYnVzLlxuICAgIGV2ZW50ZWQoX3RoaXMsIHsgZXZlbnRCdXNLZXk6ICdlbF8nIH0pO1xuXG4gICAgLy8gV2UgYWxzbyB3YW50IHRvIHBhc3MgdGhlIG9yaWdpbmFsIHBsYXllciBvcHRpb25zIHRvIGVhY2ggY29tcG9uZW50IGFuZCBwbHVnaW5cbiAgICAvLyBhcyB3ZWxsIHNvIHRoZXkgZG9uJ3QgbmVlZCB0byByZWFjaCBiYWNrIGludG8gdGhlIHBsYXllciBmb3Igb3B0aW9ucyBsYXRlci5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gZG8gYW5vdGhlciBjb3B5IG9mIHRoaXMub3B0aW9uc18gc28gd2UgZG9uJ3QgZW5kIHVwIHdpdGhcbiAgICAvLyBhbiBpbmZpbml0ZSBsb29wLlxuICAgIHZhciBwbGF5ZXJPcHRpb25zQ29weSA9IG1lcmdlT3B0aW9ucyhfdGhpcy5vcHRpb25zXyk7XG5cbiAgICAvLyBMb2FkIHBsdWdpbnNcbiAgICBpZiAob3B0aW9ucy5wbHVnaW5zKSB7XG4gICAgICB2YXIgcGx1Z2lucyA9IG9wdGlvbnMucGx1Z2lucztcblxuICAgICAgT2JqZWN0LmtleXMocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSQkMSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXNbbmFtZSQkMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzW25hbWUkJDFdKHBsdWdpbnNbbmFtZSQkMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGx1Z2luIFwiJyArIG5hbWUkJDEgKyAnXCIgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgICAgfVxuICAgICAgfSwgX3RoaXMpO1xuICAgIH1cblxuICAgIF90aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnMgPSBwbGF5ZXJPcHRpb25zQ29weTtcblxuICAgIF90aGlzLm1pZGRsZXdhcmVfID0gW107XG5cbiAgICBfdGhpcy5pbml0Q2hpbGRyZW4oKTtcblxuICAgIC8vIFNldCBpc0F1ZGlvIGJhc2VkIG9uIHdoZXRoZXIgb3Igbm90IGFuIGF1ZGlvIHRhZyB3YXMgdXNlZFxuICAgIF90aGlzLmlzQXVkaW8odGFnLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhdWRpbycpO1xuXG4gICAgLy8gVXBkYXRlIGNvbnRyb2xzIGNsYXNzTmFtZS4gQ2FuJ3QgZG8gdGhpcyB3aGVuIHRoZSBjb250cm9scyBhcmUgaW5pdGlhbGx5XG4gICAgLy8gc2V0IGJlY2F1c2UgdGhlIGVsZW1lbnQgZG9lc24ndCBleGlzdCB5ZXQuXG4gICAgaWYgKF90aGlzLmNvbnRyb2xzKCkpIHtcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZW5hYmxlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5hZGRDbGFzcygndmpzLWNvbnRyb2xzLWRpc2FibGVkJyk7XG4gICAgfVxuXG4gICAgLy8gU2V0IEFSSUEgbGFiZWwgYW5kIHJlZ2lvbiByb2xlIGRlcGVuZGluZyBvbiBwbGF5ZXIgdHlwZVxuICAgIF90aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncmVnaW9uJyk7XG4gICAgaWYgKF90aGlzLmlzQXVkaW8oKSkge1xuICAgICAgX3RoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIF90aGlzLmxvY2FsaXplKCdBdWRpbyBQbGF5ZXInKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBfdGhpcy5sb2NhbGl6ZSgnVmlkZW8gUGxheWVyJykpO1xuICAgIH1cblxuICAgIGlmIChfdGhpcy5pc0F1ZGlvKCkpIHtcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtYXVkaW8nKTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuZmxleE5vdFN1cHBvcnRlZF8oKSkge1xuICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy1uby1mbGV4Jyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogTWFrZSB0aGlzIHNtYXJ0ZXIuIFRvZ2dsZSB1c2VyIHN0YXRlIGJldHdlZW4gdG91Y2hpbmcvbW91c2luZ1xuICAgIC8vIHVzaW5nIGV2ZW50cywgc2luY2UgZGV2aWNlcyBjYW4gaGF2ZSBib3RoIHRvdWNoIGFuZCBtb3VzZSBldmVudHMuXG4gICAgLy8gaWYgKGJyb3dzZXIuVE9VQ0hfRU5BQkxFRCkge1xuICAgIC8vICAgdGhpcy5hZGRDbGFzcygndmpzLXRvdWNoLWVuYWJsZWQnKTtcbiAgICAvLyB9XG5cbiAgICAvLyBpT1MgU2FmYXJpIGhhcyBicm9rZW4gaG92ZXIgaGFuZGxpbmdcbiAgICBpZiAoIUlTX0lPUykge1xuICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy13b3JraW5naG92ZXInKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHBsYXllciBlYXNpbHkgZmluZGFibGUgYnkgSURcbiAgICBQbGF5ZXIucGxheWVyc1tfdGhpcy5pZF9dID0gX3RoaXM7XG5cbiAgICAvLyBBZGQgYSBtYWpvciB2ZXJzaW9uIGNsYXNzIHRvIGFpZCBjc3MgaW4gcGx1Z2luc1xuICAgIHZhciBtYWpvclZlcnNpb24gPSB2ZXJzaW9uLnNwbGl0KCcuJylbMF07XG5cbiAgICBfdGhpcy5hZGRDbGFzcygndmpzLXYnICsgbWFqb3JWZXJzaW9uKTtcblxuICAgIC8vIFdoZW4gdGhlIHBsYXllciBpcyBmaXJzdCBpbml0aWFsaXplZCwgdHJpZ2dlciBhY3Rpdml0eSBzbyBjb21wb25lbnRzXG4gICAgLy8gbGlrZSB0aGUgY29udHJvbCBiYXIgc2hvdyB0aGVtc2VsdmVzIGlmIG5lZWRlZFxuICAgIF90aGlzLnVzZXJBY3RpdmUodHJ1ZSk7XG4gICAgX3RoaXMucmVwb3J0VXNlckFjdGl2aXR5KCk7XG4gICAgX3RoaXMubGlzdGVuRm9yVXNlckFjdGl2aXR5XygpO1xuXG4gICAgX3RoaXMub24oJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBfdGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlXyk7XG4gICAgX3RoaXMub24oJ3N0YWdlY2xpY2snLCBfdGhpcy5oYW5kbGVTdGFnZUNsaWNrXyk7XG5cbiAgICBfdGhpcy5jaGFuZ2luZ1NyY18gPSBmYWxzZTtcbiAgICBfdGhpcy5wbGF5V2FpdGluZ0ZvclJlYWR5XyA9IGZhbHNlO1xuICAgIF90aGlzLnBsYXlPbkxvYWRzdGFydF8gPSBudWxsO1xuXG4gICAgX3RoaXMuZm9yY2VBdXRvcGxheUluQ2hyb21lXygpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgdmlkZW8gcGxheWVyIGFuZCBkb2VzIGFueSBuZWNlc3NhcnkgY2xlYW51cC5cbiAgICpcbiAgICogVGhpcyBpcyBlc3BlY2lhbGx5IGhlbHBmdWwgaWYgeW91IGFyZSBkeW5hbWljYWxseSBhZGRpbmcgYW5kIHJlbW92aW5nIHZpZGVvc1xuICAgKiB0by9mcm9tIHRoZSBET00uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZGlzcG9zZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHBsYXllciBpcyBiZWluZyBkaXNwb3NlZCBvZi5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjZGlzcG9zZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2Rpc3Bvc2UnKTtcbiAgICAvLyBwcmV2ZW50IGRpc3Bvc2UgZnJvbSBiZWluZyBjYWxsZWQgdHdpY2VcbiAgICB0aGlzLm9mZignZGlzcG9zZScpO1xuXG4gICAgaWYgKHRoaXMuc3R5bGVFbF8gJiYgdGhpcy5zdHlsZUVsXy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLnN0eWxlRWxfLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zdHlsZUVsXyk7XG4gICAgICB0aGlzLnN0eWxlRWxfID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBLaWxsIHJlZmVyZW5jZSB0byB0aGlzIHBsYXllclxuICAgIFBsYXllci5wbGF5ZXJzW3RoaXMuaWRfXSA9IG51bGw7XG5cbiAgICBpZiAodGhpcy50YWcgJiYgdGhpcy50YWcucGxheWVyKSB7XG4gICAgICB0aGlzLnRhZy5wbGF5ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVsXyAmJiB0aGlzLmVsXy5wbGF5ZXIpIHtcbiAgICAgIHRoaXMuZWxfLnBsYXllciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHRoaXMudGVjaF8uZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBsYXllckVsSW5nZXN0Xykge1xuICAgICAgdGhpcy5wbGF5ZXJFbEluZ2VzdF8gPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRhZykge1xuICAgICAgdGhpcy50YWcgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIHRoZSBhY3R1YWwgLmVsXyBpcyByZW1vdmVkIGhlcmVcbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYFBsYXllcmAncyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgRE9NIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZztcbiAgICB2YXIgZWwgPSB2b2lkIDA7XG4gICAgdmFyIHBsYXllckVsSW5nZXN0ID0gdGhpcy5wbGF5ZXJFbEluZ2VzdF8gPSB0YWcucGFyZW50Tm9kZSAmJiB0YWcucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUgJiYgdGFnLnBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXZqcy1wbGF5ZXInKTtcbiAgICB2YXIgZGl2RW1iZWQgPSB0aGlzLnRhZy50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby1qcyc7XG5cbiAgICBpZiAocGxheWVyRWxJbmdlc3QpIHtcbiAgICAgIGVsID0gdGhpcy5lbF8gPSB0YWcucGFyZW50Tm9kZTtcbiAgICB9IGVsc2UgaWYgKCFkaXZFbWJlZCkge1xuICAgICAgZWwgPSB0aGlzLmVsXyA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicpO1xuICAgIH1cblxuICAgIC8vIENvcHkgb3ZlciBhbGwgdGhlIGF0dHJpYnV0ZXMgZnJvbSB0aGUgdGFnLCBpbmNsdWRpbmcgSUQgYW5kIGNsYXNzXG4gICAgLy8gSUQgd2lsbCBub3cgcmVmZXJlbmNlIHBsYXllciBib3gsIG5vdCB0aGUgdmlkZW8gdGFnXG4gICAgdmFyIGF0dHJzID0gZ2V0QXR0cmlidXRlcyh0YWcpO1xuXG4gICAgaWYgKGRpdkVtYmVkKSB7XG4gICAgICBlbCA9IHRoaXMuZWxfID0gdGFnO1xuICAgICAgdGFnID0gdGhpcy50YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgd2hpbGUgKGVsLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB0YWcuYXBwZW5kQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzQ2xhc3MoZWwsICd2aWRlby1qcycpKSB7XG4gICAgICAgIGFkZENsYXNzKGVsLCAndmlkZW8tanMnKTtcbiAgICAgIH1cblxuICAgICAgZWwuYXBwZW5kQ2hpbGQodGFnKTtcblxuICAgICAgcGxheWVyRWxJbmdlc3QgPSB0aGlzLnBsYXllckVsSW5nZXN0XyA9IGVsO1xuICAgIH1cblxuICAgIC8vIHNldCB0YWJpbmRleCB0byAtMSBzbyB3ZSBjb3VsZCBmb2N1cyBvbiB0aGUgcGxheWVyIGVsZW1lbnRcbiAgICB0YWcuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuXG4gICAgLy8gUmVtb3ZlIHdpZHRoL2hlaWdodCBhdHRycyBmcm9tIHRhZyBzbyBDU1MgY2FuIG1ha2UgaXQgMTAwJSB3aWR0aC9oZWlnaHRcbiAgICB0YWcucmVtb3ZlQXR0cmlidXRlKCd3aWR0aCcpO1xuICAgIHRhZy5yZW1vdmVBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgc28gd2UgZG9uJ3QgdG90YWxseSBicmVhayBJRTdcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzY1MzQ0NC9jc3Mtc3R5bGVzLW5vdC1hcHBsaWVkLW9uLWR5bmFtaWMtZWxlbWVudHMtaW4taW50ZXJuZXQtZXhwbG9yZXItN1xuICAgICAgaWYgKGF0dHIgPT09ICdjbGFzcycpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lICs9ICcgJyArIGF0dHJzW2F0dHJdO1xuXG4gICAgICAgIGlmIChkaXZFbWJlZCkge1xuICAgICAgICAgIHRhZy5jbGFzc05hbWUgKz0gJyAnICsgYXR0cnNbYXR0cl07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSk7XG5cbiAgICAgICAgaWYgKGRpdkVtYmVkKSB7XG4gICAgICAgICAgdGFnLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSB0YWcgaWQvY2xhc3MgZm9yIHVzZSBhcyBIVE1MNSBwbGF5YmFjayB0ZWNoXG4gICAgLy8gTWlnaHQgdGhpbmsgd2Ugc2hvdWxkIGRvIHRoaXMgYWZ0ZXIgZW1iZWRkaW5nIGluIGNvbnRhaW5lciBzbyAudmpzLXRlY2ggY2xhc3NcbiAgICAvLyBkb2Vzbid0IGZsYXNoIDEwMCUgd2lkdGgvaGVpZ2h0LCBidXQgY2xhc3Mgb25seSBhcHBsaWVzIHdpdGggLnZpZGVvLWpzIHBhcmVudFxuICAgIHRhZy5wbGF5ZXJJZCA9IHRhZy5pZDtcbiAgICB0YWcuaWQgKz0gJ19odG1sNV9hcGknO1xuICAgIHRhZy5jbGFzc05hbWUgPSAndmpzLXRlY2gnO1xuXG4gICAgLy8gTWFrZSBwbGF5ZXIgZmluZGFibGUgb24gZWxlbWVudHNcbiAgICB0YWcucGxheWVyID0gZWwucGxheWVyID0gdGhpcztcbiAgICAvLyBEZWZhdWx0IHN0YXRlIG9mIHZpZGVvIGlzIHBhdXNlZFxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcblxuICAgIC8vIEFkZCBhIHN0eWxlIGVsZW1lbnQgaW4gdGhlIHBsYXllciB0aGF0IHdlJ2xsIHVzZSB0byBzZXQgdGhlIHdpZHRoL2hlaWdodFxuICAgIC8vIG9mIHRoZSBwbGF5ZXIgaW4gYSB3YXkgdGhhdCdzIHN0aWxsIG92ZXJyaWRlYWJsZSBieSBDU1MsIGp1c3QgbGlrZSB0aGVcbiAgICAvLyB2aWRlbyBlbGVtZW50XG4gICAgaWYgKHdpbmRvdy5WSURFT0pTX05PX0RZTkFNSUNfU1RZTEUgIT09IHRydWUpIHtcbiAgICAgIHRoaXMuc3R5bGVFbF8gPSBjcmVhdGVTdHlsZUVsZW1lbnQoJ3Zqcy1zdHlsZXMtZGltZW5zaW9ucycpO1xuICAgICAgdmFyIGRlZmF1bHRzU3R5bGVFbCA9ICQoJy52anMtc3R5bGVzLWRlZmF1bHRzJyk7XG4gICAgICB2YXIgaGVhZCA9ICQoJ2hlYWQnKTtcblxuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUodGhpcy5zdHlsZUVsXywgZGVmYXVsdHNTdHlsZUVsID8gZGVmYXVsdHNTdHlsZUVsLm5leHRTaWJsaW5nIDogaGVhZC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICAvLyBQYXNzIGluIHRoZSB3aWR0aC9oZWlnaHQvYXNwZWN0UmF0aW8gb3B0aW9ucyB3aGljaCB3aWxsIHVwZGF0ZSB0aGUgc3R5bGUgZWxcbiAgICB0aGlzLndpZHRoKHRoaXMub3B0aW9uc18ud2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0KHRoaXMub3B0aW9uc18uaGVpZ2h0KTtcbiAgICB0aGlzLmZsdWlkKHRoaXMub3B0aW9uc18uZmx1aWQpO1xuICAgIHRoaXMuYXNwZWN0UmF0aW8odGhpcy5vcHRpb25zXy5hc3BlY3RSYXRpbyk7XG5cbiAgICAvLyBIaWRlIGFueSBsaW5rcyB3aXRoaW4gdGhlIHZpZGVvL2F1ZGlvIHRhZywgYmVjYXVzZSBJRSBkb2Vzbid0IGhpZGUgdGhlbSBjb21wbGV0ZWx5LlxuICAgIHZhciBsaW5rcyA9IHRhZy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmtFbCA9IGxpbmtzLml0ZW0oaSk7XG5cbiAgICAgIGFkZENsYXNzKGxpbmtFbCwgJ3Zqcy1oaWRkZW4nKTtcbiAgICAgIGxpbmtFbC5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICdoaWRkZW4nKTtcbiAgICB9XG5cbiAgICAvLyBpbnNlcnRFbEZpcnN0IHNlZW1zIHRvIGNhdXNlIHRoZSBuZXR3b3JrU3RhdGUgdG8gZmxpY2tlciBmcm9tIDMgdG8gMiwgc29cbiAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBvcmlnaW5hbCBmb3IgbGF0ZXIgc28gd2UgY2FuIGtub3cgaWYgdGhlIHNvdXJjZSBvcmlnaW5hbGx5IGZhaWxlZFxuICAgIHRhZy5pbml0TmV0d29ya1N0YXRlXyA9IHRhZy5uZXR3b3JrU3RhdGU7XG5cbiAgICAvLyBXcmFwIHZpZGVvIHRhZyBpbiBkaXYgKGVsL2JveCkgY29udGFpbmVyXG4gICAgaWYgKHRhZy5wYXJlbnROb2RlICYmICFwbGF5ZXJFbEluZ2VzdCkge1xuICAgICAgdGFnLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCB0YWcpO1xuICAgIH1cblxuICAgIC8vIGluc2VydCB0aGUgdGFnIGFzIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgcGxheWVyIGVsZW1lbnRcbiAgICAvLyB0aGVuIG1hbnVhbGx5IGFkZCBpdCB0byB0aGUgY2hpbGRyZW4gYXJyYXkgc28gdGhhdCB0aGlzLmFkZENoaWxkXG4gICAgLy8gd2lsbCB3b3JrIHByb3Blcmx5IGZvciBvdGhlciBjb21wb25lbnRzXG4gICAgLy9cbiAgICAvLyBCcmVha3MgaVBob25lLCBmaXhlZCBpbiBIVE1MNSBzZXR1cC5cbiAgICBwcmVwZW5kVG8odGFnLCBlbCk7XG4gICAgdGhpcy5jaGlsZHJlbl8udW5zaGlmdCh0YWcpO1xuXG4gICAgLy8gU2V0IGxhbmcgYXR0ciBvbiBwbGF5ZXIgdG8gZW5zdXJlIENTUyA6bGFuZygpIGluIGNvbnNpc3RlbnQgd2l0aCBwbGF5ZXJcbiAgICAvLyBpZiBpdCdzIGJlZW4gc2V0IHRvIHNvbWV0aGluZyBkaWZmZXJlbnQgdG8gdGhlIGRvY1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnbGFuZycsIHRoaXMubGFuZ3VhZ2VfKTtcblxuICAgIHRoaXMuZWxfID0gZWw7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBQbGF5ZXJgJ3Mgd2lkdGguIFJldHVybnMgdGhlIHBsYXllcidzIGNvbmZpZ3VyZWQgdmFsdWUuXG4gICAqIFRvIGdldCB0aGUgY3VycmVudCB3aWR0aCB1c2UgYGN1cnJlbnRXaWR0aCgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt2YWx1ZV1cbiAgICogICAgICAgIFRoZSB2YWx1ZSB0byBzZXQgdGhlIGBQbGF5ZXJgJ3Mgd2lkdGggdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBMaXN0ZW5lcnNdXG4gICAqICAgICAgICBTa2lwIHRoZSBwbGF5ZXJyZXNpemUgZXZlbnQgdHJpZ2dlclxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIGBQbGF5ZXJgIHdoZW4gZ2V0dGluZy5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gd2lkdGgodmFsdWUsIHNraXBMaXN0ZW5lcnMpIHtcbiAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24oJ3dpZHRoJywgdmFsdWUsIHNraXBMaXN0ZW5lcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgUGxheWVyYCdzIGhlaWdodC4gUmV0dXJucyB0aGUgcGxheWVyJ3MgY29uZmlndXJlZCB2YWx1ZS5cbiAgICogVG8gZ2V0IHRoZSBjdXJyZW50IGhlaWdodCB1c2UgYGN1cnJlbnRoZWlnaHQoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWVdXG4gICAqICAgICAgICBUaGUgdmFsdWUgdG8gc2V0IHRoZSBgUGxheWVyYCdzIGhlaWd0aCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcExpc3RlbmVyc11cbiAgICogICAgICAgIFNraXAgdGhlIHBsYXllcnJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIGBQbGF5ZXJgIHdoZW4gZ2V0dGluZy5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uIGhlaWdodCh2YWx1ZSwgc2tpcExpc3RlbmVycykge1xuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbignaGVpZ2h0JywgdmFsdWUsIHNraXBMaXN0ZW5lcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgUGxheWVyYCdzIHdpZHRoICYgaGVpZ2h0LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3BsYXllcnJlc2l6ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGltZW5zaW9uXG4gICAqICAgICAgICBUaGlzIHN0cmluZyBjYW4gYmU6XG4gICAqICAgICAgICAtICd3aWR0aCdcbiAgICogICAgICAgIC0gJ2hlaWdodCdcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt2YWx1ZV1cbiAgICogICAgICAgIFZhbHVlIGZvciBkaW1lbnNpb24gc3BlY2lmaWVkIGluIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcExpc3RlbmVyc11cbiAgICogICAgICAgIFNraXAgdGhlIHBsYXllcnJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZGltZW5zaW9uIGFyZ3VtZW50cyB2YWx1ZSB3aGVuIGdldHRpbmcgKHdpZHRoL2hlaWdodCkuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5kaW1lbnNpb24gPSBmdW5jdGlvbiBkaW1lbnNpb24oX2RpbWVuc2lvbiwgdmFsdWUsIHNraXBMaXN0ZW5lcnMpIHtcbiAgICB2YXIgcHJpdkRpbWVuc2lvbiA9IF9kaW1lbnNpb24gKyAnXyc7XG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXNbcHJpdkRpbWVuc2lvbl0gfHwgMDtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAvLyBJZiBhbiBlbXB0eSBzdHJpbmcgaXMgZ2l2ZW4sIHJlc2V0IHRoZSBkaW1lbnNpb24gdG8gYmUgYXV0b21hdGljXG4gICAgICB0aGlzW3ByaXZEaW1lbnNpb25dID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy51cGRhdGVTdHlsZUVsXygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXJzZWRWYWwgPSBwYXJzZUZsb2F0KHZhbHVlKTtcblxuICAgIGlmIChpc05hTihwYXJzZWRWYWwpKSB7XG4gICAgICBsb2ckMS5lcnJvcignSW1wcm9wZXIgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgc3VwcGxpZWQgZm9yIGZvciAnICsgX2RpbWVuc2lvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpc1twcml2RGltZW5zaW9uXSA9IHBhcnNlZFZhbDtcbiAgICB0aGlzLnVwZGF0ZVN0eWxlRWxfKCk7XG5cbiAgICAvLyBza2lwTGlzdGVuZXJzIGFsbG93cyB1cyB0byBhdm9pZCB0cmlnZ2VyaW5nIHRoZSByZXNpemUgZXZlbnQgd2hlbiBzZXR0aW5nIGJvdGggd2lkdGggYW5kIGhlaWdodFxuICAgIGlmICh0aGlzLmlzUmVhZHlfICYmICFza2lwTGlzdGVuZXJzKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBwbGF5ZXIgaXMgcmVzaXplZC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI3BsYXllcnJlc2l6ZVxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ3BsYXllcnJlc2l6ZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQSBnZXR0ZXIvc2V0dGVyL3RvZ2dsZXIgZm9yIHRoZSB2anMtZmx1aWQgYGNsYXNzTmFtZWAgb24gdGhlIGBQbGF5ZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib29sXVxuICAgKiAgICAgICAgLSBBIHZhbHVlIG9mIHRydWUgYWRkcyB0aGUgY2xhc3MuXG4gICAqICAgICAgICAtIEEgdmFsdWUgb2YgZmFsc2UgcmVtb3ZlcyB0aGUgY2xhc3MuXG4gICAqICAgICAgICAtIE5vIHZhbHVlIHdpbGwgdG9nZ2xlIHRoZSBmbHVpZCBjbGFzcy5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgZmx1aWQgd2hlbiBnZXR0aW5nLlxuICAgKiAgICAgICAgIC0gYHVuZGVmaW5lZGAgd2hlbiBzZXR0aW5nLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZmx1aWQgPSBmdW5jdGlvbiBmbHVpZChib29sKSB7XG4gICAgaWYgKGJvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5mbHVpZF87XG4gICAgfVxuXG4gICAgdGhpcy5mbHVpZF8gPSAhIWJvb2w7XG5cbiAgICBpZiAoYm9vbCkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWZsdWlkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1mbHVpZCcpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU3R5bGVFbF8oKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L1NldCB0aGUgYXNwZWN0IHJhdGlvXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmF0aW9dXG4gICAqICAgICAgICBBc3BlY3QgcmF0aW8gZm9yIHBsYXllclxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIHJldHVybnMgdGhlIGN1cnJlbnQgYXNwZWN0IHJhdGlvIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuICAvKipcbiAgICogQSBnZXR0ZXIvc2V0dGVyIGZvciB0aGUgYFBsYXllcmAncyBhc3BlY3QgcmF0aW8uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmF0aW9dXG4gICAqICAgICAgICBUaGUgdmFsdWUgdG8gc2V0IHRoZSBgUGxheWVyJ3MgYXNwZWN0IHJhdGlvIHRvLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIC0gVGhlIGN1cnJlbnQgYXNwZWN0IHJhdGlvIG9mIHRoZSBgUGxheWVyYCB3aGVuIGdldHRpbmcuXG4gICAqICAgICAgICAgLSB1bmRlZmluZWQgd2hlbiBzZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5hc3BlY3RSYXRpbyA9IGZ1bmN0aW9uIGFzcGVjdFJhdGlvKHJhdGlvKSB7XG4gICAgaWYgKHJhdGlvID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzcGVjdFJhdGlvXztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3Igd2lkdGg6aGVpZ2h0IGZvcm1hdFxuICAgIGlmICghL15cXGQrXFw6XFxkKyQvLnRlc3QocmF0aW8pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltcHJvcGVyIHZhbHVlIHN1cHBsaWVkIGZvciBhc3BlY3QgcmF0aW8uIFRoZSBmb3JtYXQgc2hvdWxkIGJlIHdpZHRoOmhlaWdodCwgZm9yIGV4YW1wbGUgMTY6OS4nKTtcbiAgICB9XG4gICAgdGhpcy5hc3BlY3RSYXRpb18gPSByYXRpbztcblxuICAgIC8vIFdlJ3JlIGFzc3VtaW5nIGlmIHlvdSBzZXQgYW4gYXNwZWN0IHJhdGlvIHlvdSB3YW50IGZsdWlkIG1vZGUsXG4gICAgLy8gYmVjYXVzZSBpbiBmaXhlZCBtb2RlIHlvdSBjb3VsZCBjYWxjdWxhdGUgd2lkdGggYW5kIGhlaWdodCB5b3Vyc2VsZi5cbiAgICB0aGlzLmZsdWlkKHRydWUpO1xuXG4gICAgdGhpcy51cGRhdGVTdHlsZUVsXygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgc3R5bGVzIG9mIHRoZSBgUGxheWVyYCBlbGVtZW50IChoZWlnaHQsIHdpZHRoIGFuZCBhc3BlY3QgcmF0aW8pLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbGlzdGVucyBUZWNoI2xvYWRlZG1ldGFkYXRhXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS51cGRhdGVTdHlsZUVsXyA9IGZ1bmN0aW9uIHVwZGF0ZVN0eWxlRWxfKCkge1xuICAgIGlmICh3aW5kb3cuVklERU9KU19OT19EWU5BTUlDX1NUWUxFID09PSB0cnVlKSB7XG4gICAgICB2YXIgX3dpZHRoID0gdHlwZW9mIHRoaXMud2lkdGhfID09PSAnbnVtYmVyJyA/IHRoaXMud2lkdGhfIDogdGhpcy5vcHRpb25zXy53aWR0aDtcbiAgICAgIHZhciBfaGVpZ2h0ID0gdHlwZW9mIHRoaXMuaGVpZ2h0XyA9PT0gJ251bWJlcicgPyB0aGlzLmhlaWdodF8gOiB0aGlzLm9wdGlvbnNfLmhlaWdodDtcbiAgICAgIHZhciB0ZWNoRWwgPSB0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8uZWwoKTtcblxuICAgICAgaWYgKHRlY2hFbCkge1xuICAgICAgICBpZiAoX3dpZHRoID49IDApIHtcbiAgICAgICAgICB0ZWNoRWwud2lkdGggPSBfd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9oZWlnaHQgPj0gMCkge1xuICAgICAgICAgIHRlY2hFbC5oZWlnaHQgPSBfaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSB2b2lkIDA7XG4gICAgdmFyIGhlaWdodCA9IHZvaWQgMDtcbiAgICB2YXIgYXNwZWN0UmF0aW8gPSB2b2lkIDA7XG4gICAgdmFyIGlkQ2xhc3MgPSB2b2lkIDA7XG5cbiAgICAvLyBUaGUgYXNwZWN0IHJhdGlvIGlzIGVpdGhlciB1c2VkIGRpcmVjdGx5IG9yIHRvIGNhbGN1bGF0ZSB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgIGlmICh0aGlzLmFzcGVjdFJhdGlvXyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYXNwZWN0UmF0aW9fICE9PSAnYXV0bycpIHtcbiAgICAgIC8vIFVzZSBhbnkgYXNwZWN0UmF0aW8gdGhhdCdzIGJlZW4gc3BlY2lmaWNhbGx5IHNldFxuICAgICAgYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvXztcbiAgICB9IGVsc2UgaWYgKHRoaXMudmlkZW9XaWR0aCgpID4gMCkge1xuICAgICAgLy8gT3RoZXJ3aXNlIHRyeSB0byBnZXQgdGhlIGFzcGVjdCByYXRpbyBmcm9tIHRoZSB2aWRlbyBtZXRhZGF0YVxuICAgICAgYXNwZWN0UmF0aW8gPSB0aGlzLnZpZGVvV2lkdGgoKSArICc6JyArIHRoaXMudmlkZW9IZWlnaHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3IgdXNlIGEgZGVmYXVsdC4gVGhlIHZpZGVvIGVsZW1lbnQncyBpcyAyOjEsIGJ1dCAxNjo5IGlzIG1vcmUgY29tbW9uLlxuICAgICAgYXNwZWN0UmF0aW8gPSAnMTY6OSc7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSByYXRpbyBhcyBhIGRlY2ltYWwgd2UgY2FuIHVzZSB0byBjYWxjdWxhdGUgZGltZW5zaW9uc1xuICAgIHZhciByYXRpb1BhcnRzID0gYXNwZWN0UmF0aW8uc3BsaXQoJzonKTtcbiAgICB2YXIgcmF0aW9NdWx0aXBsaWVyID0gcmF0aW9QYXJ0c1sxXSAvIHJhdGlvUGFydHNbMF07XG5cbiAgICBpZiAodGhpcy53aWR0aF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gVXNlIGFueSB3aWR0aCB0aGF0J3MgYmVlbiBzcGVjaWZpY2FsbHkgc2V0XG4gICAgICB3aWR0aCA9IHRoaXMud2lkdGhfO1xuICAgIH0gZWxzZSBpZiAodGhpcy5oZWlnaHRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE9yIGNhbHVsYXRlIHRoZSB3aWR0aCBmcm9tIHRoZSBhc3BlY3QgcmF0aW8gaWYgYSBoZWlnaHQgaGFzIGJlZW4gc2V0XG4gICAgICB3aWR0aCA9IHRoaXMuaGVpZ2h0XyAvIHJhdGlvTXVsdGlwbGllcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3IgdXNlIHRoZSB2aWRlbydzIG1ldGFkYXRhLCBvciB1c2UgdGhlIHZpZGVvIGVsJ3MgZGVmYXVsdCBvZiAzMDBcbiAgICAgIHdpZHRoID0gdGhpcy52aWRlb1dpZHRoKCkgfHwgMzAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhlaWdodF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gVXNlIGFueSBoZWlnaHQgdGhhdCdzIGJlZW4gc3BlY2lmaWNhbGx5IHNldFxuICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHRfO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgY2FsY3VsYXRlIHRoZSBoZWlnaHQgZnJvbSB0aGUgcmF0aW8gYW5kIHRoZSB3aWR0aFxuICAgICAgaGVpZ2h0ID0gd2lkdGggKiByYXRpb011bHRpcGxpZXI7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoZSBDU1MgY2xhc3MgaXMgdmFsaWQgYnkgc3RhcnRpbmcgd2l0aCBhbiBhbHBoYSBjaGFyYWN0ZXJcbiAgICBpZiAoL15bXmEtekEtWl0vLnRlc3QodGhpcy5pZCgpKSkge1xuICAgICAgaWRDbGFzcyA9ICdkaW1lbnNpb25zLScgKyB0aGlzLmlkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkQ2xhc3MgPSB0aGlzLmlkKCkgKyAnLWRpbWVuc2lvbnMnO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGUgcmlnaHQgY2xhc3MgaXMgc3RpbGwgb24gdGhlIHBsYXllciBmb3IgdGhlIHN0eWxlIGVsZW1lbnRcbiAgICB0aGlzLmFkZENsYXNzKGlkQ2xhc3MpO1xuXG4gICAgc2V0VGV4dENvbnRlbnQodGhpcy5zdHlsZUVsXywgJ1xcbiAgICAgIC4nICsgaWRDbGFzcyArICcge1xcbiAgICAgICAgd2lkdGg6ICcgKyB3aWR0aCArICdweDtcXG4gICAgICAgIGhlaWdodDogJyArIGhlaWdodCArICdweDtcXG4gICAgICB9XFxuXFxuICAgICAgLicgKyBpZENsYXNzICsgJy52anMtZmx1aWQge1xcbiAgICAgICAgcGFkZGluZy10b3A6ICcgKyByYXRpb011bHRpcGxpZXIgKiAxMDAgKyAnJTtcXG4gICAgICB9XFxuICAgICcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2FkL0NyZWF0ZSBhbiBpbnN0YW5jZSBvZiBwbGF5YmFjayB7QGxpbmsgVGVjaH0gaW5jbHVkaW5nIGVsZW1lbnRcbiAgICogYW5kIEFQSSBtZXRob2RzLiBUaGVuIGFwcGVuZCB0aGUgYFRlY2hgIGVsZW1lbnQgaW4gYFBsYXllcmAgYXMgYSBjaGlsZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRlY2hOYW1lXG4gICAqICAgICAgICBuYW1lIG9mIHRoZSBwbGF5YmFjayB0ZWNobm9sb2d5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VcbiAgICogICAgICAgIHZpZGVvIHNvdXJjZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubG9hZFRlY2hfID0gZnVuY3Rpb24gbG9hZFRlY2hfKHRlY2hOYW1lLCBzb3VyY2UpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIC8vIFBhdXNlIGFuZCByZW1vdmUgY3VycmVudCBwbGF5YmFjayB0ZWNobm9sb2d5XG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHRoaXMudW5sb2FkVGVjaF8oKTtcbiAgICB9XG5cbiAgICB2YXIgdGl0bGVUZWNoTmFtZSA9IHRvVGl0bGVDYXNlKHRlY2hOYW1lKTtcbiAgICB2YXIgY2FtZWxUZWNoTmFtZSA9IHRlY2hOYW1lLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgdGVjaE5hbWUuc2xpY2UoMSk7XG5cbiAgICAvLyBnZXQgcmlkIG9mIHRoZSBIVE1MNSB2aWRlbyB0YWcgYXMgc29vbiBhcyB3ZSBhcmUgdXNpbmcgYW5vdGhlciB0ZWNoXG4gICAgaWYgKHRpdGxlVGVjaE5hbWUgIT09ICdIdG1sNScgJiYgdGhpcy50YWcpIHtcbiAgICAgIFRlY2guZ2V0VGVjaCgnSHRtbDUnKS5kaXNwb3NlTWVkaWFFbGVtZW50KHRoaXMudGFnKTtcbiAgICAgIHRoaXMudGFnLnBsYXllciA9IG51bGw7XG4gICAgICB0aGlzLnRhZyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy50ZWNoTmFtZV8gPSB0aXRsZVRlY2hOYW1lO1xuXG4gICAgLy8gVHVybiBvZmYgQVBJIGFjY2VzcyBiZWNhdXNlIHdlJ3JlIGxvYWRpbmcgYSBuZXcgdGVjaCB0aGF0IG1pZ2h0IGxvYWQgYXN5bmNocm9ub3VzbHlcbiAgICB0aGlzLmlzUmVhZHlfID0gZmFsc2U7XG5cbiAgICAvLyBHcmFiIHRlY2gtc3BlY2lmaWMgb3B0aW9ucyBmcm9tIHBsYXllciBvcHRpb25zIGFuZCBhZGQgc291cmNlIGFuZCBwYXJlbnQgZWxlbWVudCB0byB1c2UuXG4gICAgdmFyIHRlY2hPcHRpb25zID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAnbmF0aXZlQ29udHJvbHNGb3JUb3VjaCc6IHRoaXMub3B0aW9uc18ubmF0aXZlQ29udHJvbHNGb3JUb3VjaCxcbiAgICAgICdwbGF5ZXJJZCc6IHRoaXMuaWQoKSxcbiAgICAgICd0ZWNoSWQnOiB0aGlzLmlkKCkgKyAnXycgKyB0aXRsZVRlY2hOYW1lICsgJ19hcGknLFxuICAgICAgJ2F1dG9wbGF5JzogdGhpcy5vcHRpb25zXy5hdXRvcGxheSxcbiAgICAgICdwbGF5c2lubGluZSc6IHRoaXMub3B0aW9uc18ucGxheXNpbmxpbmUsXG4gICAgICAncHJlbG9hZCc6IHRoaXMub3B0aW9uc18ucHJlbG9hZCxcbiAgICAgICdsb29wJzogdGhpcy5vcHRpb25zXy5sb29wLFxuICAgICAgJ211dGVkJzogdGhpcy5vcHRpb25zXy5tdXRlZCxcbiAgICAgICdwb3N0ZXInOiB0aGlzLnBvc3RlcigpLFxuICAgICAgJ2xhbmd1YWdlJzogdGhpcy5sYW5ndWFnZSgpLFxuICAgICAgJ3BsYXllckVsSW5nZXN0JzogdGhpcy5wbGF5ZXJFbEluZ2VzdF8gfHwgZmFsc2UsXG4gICAgICAndnR0LmpzJzogdGhpcy5vcHRpb25zX1sndnR0LmpzJ11cbiAgICB9O1xuXG4gICAgQUxMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUkJDEpIHtcbiAgICAgIHZhciBwcm9wcyA9IEFMTFtuYW1lJCQxXTtcblxuICAgICAgdGVjaE9wdGlvbnNbcHJvcHMuZ2V0dGVyTmFtZV0gPSBfdGhpczJbcHJvcHMucHJpdmF0ZU5hbWVdO1xuICAgIH0pO1xuXG4gICAgYXNzaWduKHRlY2hPcHRpb25zLCB0aGlzLm9wdGlvbnNfW3RpdGxlVGVjaE5hbWVdKTtcbiAgICBhc3NpZ24odGVjaE9wdGlvbnMsIHRoaXMub3B0aW9uc19bY2FtZWxUZWNoTmFtZV0pO1xuICAgIGFzc2lnbih0ZWNoT3B0aW9ucywgdGhpcy5vcHRpb25zX1t0ZWNoTmFtZS50b0xvd2VyQ2FzZSgpXSk7XG5cbiAgICBpZiAodGhpcy50YWcpIHtcbiAgICAgIHRlY2hPcHRpb25zLnRhZyA9IHRoaXMudGFnO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UgJiYgc291cmNlLnNyYyA9PT0gdGhpcy5jYWNoZV8uc3JjICYmIHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lID4gMCkge1xuICAgICAgdGVjaE9wdGlvbnMuc3RhcnRUaW1lID0gdGhpcy5jYWNoZV8uY3VycmVudFRpbWU7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSB0ZWNoIGluc3RhbmNlXG4gICAgdmFyIFRlY2hDbGFzcyA9IFRlY2guZ2V0VGVjaCh0ZWNoTmFtZSk7XG5cbiAgICBpZiAoIVRlY2hDbGFzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBUZWNoIG5hbWVkIFxcJycgKyB0aXRsZVRlY2hOYW1lICsgJ1xcJyBleGlzdHMhIFxcJycgKyB0aXRsZVRlY2hOYW1lICsgJ1xcJyBzaG91bGQgYmUgcmVnaXN0ZXJlZCB1c2luZyB2aWRlb2pzLnJlZ2lzdGVyVGVjaCgpXFwnJyk7XG4gICAgfVxuXG4gICAgdGhpcy50ZWNoXyA9IG5ldyBUZWNoQ2xhc3ModGVjaE9wdGlvbnMpO1xuXG4gICAgLy8gcGxheWVyLnRyaWdnZXJSZWFkeSBpcyBhbHdheXMgYXN5bmMsIHNvIGRvbid0IG5lZWQgdGhpcyB0byBiZSBhc3luY1xuICAgIHRoaXMudGVjaF8ucmVhZHkoYmluZCh0aGlzLCB0aGlzLmhhbmRsZVRlY2hSZWFkeV8pLCB0cnVlKTtcblxuICAgIHRleHRUcmFja0NvbnZlcnRlci5qc29uVG9UZXh0VHJhY2tzKHRoaXMudGV4dFRyYWNrc0pzb25fIHx8IFtdLCB0aGlzLnRlY2hfKTtcblxuICAgIC8vIExpc3RlbiB0byBhbGwgSFRNTDUtZGVmaW5lZCBldmVudHMgYW5kIHRyaWdnZXIgdGhlbSBvbiB0aGUgcGxheWVyXG4gICAgVEVDSF9FVkVOVFNfUkVUUklHR0VSLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBfdGhpczIub24oX3RoaXMyLnRlY2hfLCBldmVudCwgX3RoaXMyWydoYW5kbGVUZWNoJyArIHRvVGl0bGVDYXNlKGV2ZW50KSArICdfJ10pO1xuICAgIH0pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2xvYWRzdGFydCcsIHRoaXMuaGFuZGxlVGVjaExvYWRTdGFydF8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3dhaXRpbmcnLCB0aGlzLmhhbmRsZVRlY2hXYWl0aW5nXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnY2FucGxheScsIHRoaXMuaGFuZGxlVGVjaENhblBsYXlfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdjYW5wbGF5dGhyb3VnaCcsIHRoaXMuaGFuZGxlVGVjaENhblBsYXlUaHJvdWdoXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAncGxheWluZycsIHRoaXMuaGFuZGxlVGVjaFBsYXlpbmdfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdlbmRlZCcsIHRoaXMuaGFuZGxlVGVjaEVuZGVkXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnc2Vla2luZycsIHRoaXMuaGFuZGxlVGVjaFNlZWtpbmdfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdzZWVrZWQnLCB0aGlzLmhhbmRsZVRlY2hTZWVrZWRfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdwbGF5JywgdGhpcy5oYW5kbGVUZWNoUGxheV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2ZpcnN0cGxheScsIHRoaXMuaGFuZGxlVGVjaEZpcnN0UGxheV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3BhdXNlJywgdGhpcy5oYW5kbGVUZWNoUGF1c2VfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdkdXJhdGlvbmNoYW5nZScsIHRoaXMuaGFuZGxlVGVjaER1cmF0aW9uQ2hhbmdlXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZnVsbHNjcmVlbmNoYW5nZScsIHRoaXMuaGFuZGxlVGVjaEZ1bGxzY3JlZW5DaGFuZ2VfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdlcnJvcicsIHRoaXMuaGFuZGxlVGVjaEVycm9yXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnbG9hZGVkbWV0YWRhdGEnLCB0aGlzLnVwZGF0ZVN0eWxlRWxfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdwb3N0ZXJjaGFuZ2UnLCB0aGlzLmhhbmRsZVRlY2hQb3N0ZXJDaGFuZ2VfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0ZXh0ZGF0YScsIHRoaXMuaGFuZGxlVGVjaFRleHREYXRhXyk7XG5cbiAgICB0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHModGhpcy50ZWNoR2V0XygnY29udHJvbHMnKSk7XG5cbiAgICBpZiAodGhpcy5jb250cm9scygpICYmICF0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHMoKSkge1xuICAgICAgdGhpcy5hZGRUZWNoQ29udHJvbHNMaXN0ZW5lcnNfKCk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSB0ZWNoIGVsZW1lbnQgaW4gdGhlIERPTSBpZiBpdCB3YXMgbm90IGFscmVhZHkgdGhlcmVcbiAgICAvLyBNYWtlIHN1cmUgdG8gbm90IGluc2VydCB0aGUgb3JpZ2luYWwgdmlkZW8gZWxlbWVudCBpZiB1c2luZyBIdG1sNVxuICAgIGlmICh0aGlzLnRlY2hfLmVsKCkucGFyZW50Tm9kZSAhPT0gdGhpcy5lbCgpICYmICh0aXRsZVRlY2hOYW1lICE9PSAnSHRtbDUnIHx8ICF0aGlzLnRhZykpIHtcbiAgICAgIHByZXBlbmRUbyh0aGlzLnRlY2hfLmVsKCksIHRoaXMuZWwoKSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHJpZCBvZiB0aGUgb3JpZ2luYWwgdmlkZW8gdGFnIHJlZmVyZW5jZSBhZnRlciB0aGUgZmlyc3QgdGVjaCBpcyBsb2FkZWRcbiAgICBpZiAodGhpcy50YWcpIHtcbiAgICAgIHRoaXMudGFnLnBsYXllciA9IG51bGw7XG4gICAgICB0aGlzLnRhZyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVbmxvYWQgYW5kIGRpc3Bvc2Ugb2YgdGhlIGN1cnJlbnQgcGxheWJhY2sge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudW5sb2FkVGVjaF8gPSBmdW5jdGlvbiB1bmxvYWRUZWNoXygpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgdGV4dCB0cmFja3Mgc28gdGhhdCB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdGV4dCB0cmFja3Mgd2l0aCB0aGUgbmV4dCB0ZWNoXG4gICAgQUxMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUkJDEpIHtcbiAgICAgIHZhciBwcm9wcyA9IEFMTFtuYW1lJCQxXTtcblxuICAgICAgX3RoaXMzW3Byb3BzLnByaXZhdGVOYW1lXSA9IF90aGlzM1twcm9wcy5nZXR0ZXJOYW1lXSgpO1xuICAgIH0pO1xuICAgIHRoaXMudGV4dFRyYWNrc0pzb25fID0gdGV4dFRyYWNrQ29udmVydGVyLnRleHRUcmFja3NUb0pzb24odGhpcy50ZWNoXyk7XG5cbiAgICB0aGlzLmlzUmVhZHlfID0gZmFsc2U7XG5cbiAgICB0aGlzLnRlY2hfLmRpc3Bvc2UoKTtcblxuICAgIHRoaXMudGVjaF8gPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHtAbGluayBUZWNofS5cbiAgICogSXQgd2lsbCBwcmludCBhIHdhcm5pbmcgYnkgZGVmYXVsdCBhYm91dCB0aGUgZGFuZ2VyIG9mIHVzaW5nIHRoZSB0ZWNoIGRpcmVjdGx5XG4gICAqIGJ1dCBhbnkgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgaW4gd2lsbCBzaWxlbmNlIHRoZSB3YXJuaW5nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtzYWZldHldXG4gICAqICAgICAgICBBbnl0aGluZyBwYXNzZWQgaW4gdG8gc2lsZW5jZSB0aGUgd2FybmluZ1xuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNofVxuICAgKiAgICAgICAgIFRoZSBUZWNoXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS50ZWNoID0gZnVuY3Rpb24gdGVjaChzYWZldHkpIHtcbiAgICBpZiAoc2FmZXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvZyQxLndhcm4odHNtbChfdGVtcGxhdGVPYmplY3QkMSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRlY2hfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdXAgY2xpY2sgYW5kIHRvdWNoIGxpc3RlbmVycyBmb3IgdGhlIHBsYXliYWNrIGVsZW1lbnRcbiAgICpcbiAgICogLSBPbiBkZXNrdG9wczogYSBjbGljayBvbiB0aGUgdmlkZW8gaXRzZWxmIHdpbGwgdG9nZ2xlIHBsYXliYWNrXG4gICAqIC0gT24gbW9iaWxlIGRldmljZXM6IGEgY2xpY2sgb24gdGhlIHZpZGVvIHRvZ2dsZXMgY29udHJvbHNcbiAgICogICB3aGljaCBpcyBkb25lIGJ5IHRvZ2dsaW5nIHRoZSB1c2VyIHN0YXRlIGJldHdlZW4gYWN0aXZlIGFuZFxuICAgKiAgIGluYWN0aXZlXG4gICAqIC0gQSB0YXAgY2FuIHNpZ25hbCB0aGF0IGEgdXNlciBoYXMgYmVjb21lIGFjdGl2ZSBvciBoYXMgYmVjb21lIGluYWN0aXZlXG4gICAqICAgZS5nLiBhIHF1aWNrIHRhcCBvbiBhbiBpUGhvbmUgbW92aWUgc2hvdWxkIHJldmVhbCB0aGUgY29udHJvbHMuIEFub3RoZXJcbiAgICogICBxdWljayB0YXAgc2hvdWxkIGhpZGUgdGhlbSBhZ2FpbiAoc2lnbmFsaW5nIHRoZSB1c2VyIGlzIGluIGFuIGluYWN0aXZlXG4gICAqICAgdmlld2luZyBzdGF0ZSlcbiAgICogLSBJbiBhZGRpdGlvbiB0byB0aGlzLCB3ZSBzdGlsbCB3YW50IHRoZSB1c2VyIHRvIGJlIGNvbnNpZGVyZWQgaW5hY3RpdmUgYWZ0ZXJcbiAgICogICBhIGZldyBzZWNvbmRzIG9mIGluYWN0aXZpdHkuXG4gICAqXG4gICAqID4gTm90ZTogdGhlIG9ubHkgcGFydCBvZiBpT1MgaW50ZXJhY3Rpb24gd2UgY2FuJ3QgbWltaWMgd2l0aCB0aGlzIHNldHVwXG4gICAqIGlzIGEgdG91Y2ggYW5kIGhvbGQgb24gdGhlIHZpZGVvIGVsZW1lbnQgY291bnRpbmcgYXMgYWN0aXZpdHkgaW4gb3JkZXIgdG9cbiAgICoga2VlcCB0aGUgY29udHJvbHMgc2hvd2luZywgYnV0IHRoYXQgc2hvdWxkbid0IGJlIGFuIGlzc3VlLiBBIHRvdWNoIGFuZCBob2xkXG4gICAqIG9uIGFueSBjb250cm9scyB3aWxsIHN0aWxsIGtlZXAgdGhlIHVzZXIgYWN0aXZlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5hZGRUZWNoQ29udHJvbHNMaXN0ZW5lcnNfID0gZnVuY3Rpb24gYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpIHtcbiAgICAvLyBNYWtlIHN1cmUgdG8gcmVtb3ZlIGFsbCB0aGUgcHJldmlvdXMgbGlzdGVuZXJzIGluIGNhc2Ugd2UgYXJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICB0aGlzLnJlbW92ZVRlY2hDb250cm9sc0xpc3RlbmVyc18oKTtcblxuICAgIC8vIFNvbWUgYnJvd3NlcnMgKENocm9tZSAmIElFKSBkb24ndCB0cmlnZ2VyIGEgY2xpY2sgb24gYSBmbGFzaCBzd2YsIGJ1dCBkb1xuICAgIC8vIHRyaWdnZXIgbW91c2Vkb3duL3VwLlxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQ0NDU2Mi9qYXZhc2NyaXB0LW9uY2xpY2stZXZlbnQtb3Zlci1mbGFzaC1vYmplY3RcbiAgICAvLyBBbnkgdG91Y2ggZXZlbnRzIGFyZSBzZXQgdG8gYmxvY2sgdGhlIG1vdXNlZG93biBldmVudCBmcm9tIGhhcHBlbmluZ1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlVGVjaENsaWNrXyk7XG5cbiAgICAvLyBJZiB0aGUgY29udHJvbHMgd2VyZSBoaWRkZW4gd2UgZG9uJ3Qgd2FudCB0aGF0IHRvIGNoYW5nZSB3aXRob3V0IGEgdGFwIGV2ZW50XG4gICAgLy8gc28gd2UnbGwgY2hlY2sgaWYgdGhlIGNvbnRyb2xzIHdlcmUgYWxyZWFkeSBzaG93aW5nIGJlZm9yZSByZXBvcnRpbmcgdXNlclxuICAgIC8vIGFjdGl2aXR5XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVGVjaFRvdWNoU3RhcnRfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaE1vdmVfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVGVjaFRvdWNoRW5kXyk7XG5cbiAgICAvLyBUaGUgdGFwIGxpc3RlbmVyIG5lZWRzIHRvIGNvbWUgYWZ0ZXIgdGhlIHRvdWNoZW5kIGxpc3RlbmVyIGJlY2F1c2UgdGhlIHRhcFxuICAgIC8vIGxpc3RlbmVyIGNhbmNlbHMgb3V0IGFueSByZXBvcnRlZFVzZXJBY3Rpdml0eSB3aGVuIHNldHRpbmcgdXNlckFjdGl2ZShmYWxzZSlcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0YXAnLCB0aGlzLmhhbmRsZVRlY2hUYXBfKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdXNlZCBmb3IgY2xpY2sgYW5kIHRhcCBjb250cm9scy4gVGhpcyBpcyBuZWVkZWQgZm9yXG4gICAqIHRvZ2dsaW5nIHRvIGNvbnRyb2xzIGRpc2FibGVkLCB3aGVyZSBhIHRhcC90b3VjaCBzaG91bGQgZG8gbm90aGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlbW92ZVRlY2hDb250cm9sc0xpc3RlbmVyc18gPSBmdW5jdGlvbiByZW1vdmVUZWNoQ29udHJvbHNMaXN0ZW5lcnNfKCkge1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8ganVzdCB1c2UgYHRoaXMub2ZmKClgIGJlY2F1c2UgdGhlcmUgbWlnaHQgYmUgb3RoZXIgbmVlZGVkXG4gICAgLy8gbGlzdGVuZXJzIGFkZGVkIGJ5IHRlY2hzIHRoYXQgZXh0ZW5kIHRoaXMuXG4gICAgdGhpcy5vZmYodGhpcy50ZWNoXywgJ3RhcCcsIHRoaXMuaGFuZGxlVGVjaFRhcF8pO1xuICAgIHRoaXMub2ZmKHRoaXMudGVjaF8sICd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUZWNoVG91Y2hTdGFydF8pO1xuICAgIHRoaXMub2ZmKHRoaXMudGVjaF8sICd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaE1vdmVfKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaEVuZF8pO1xuICAgIHRoaXMub2ZmKHRoaXMudGVjaF8sICdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZVRlY2hDbGlja18pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQbGF5ZXIgd2FpdHMgZm9yIHRoZSB0ZWNoIHRvIGJlIHJlYWR5XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoUmVhZHlfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFJlYWR5XygpIHtcbiAgICB0aGlzLnRyaWdnZXJSZWFkeSgpO1xuXG4gICAgLy8gS2VlcCB0aGUgc2FtZSB2b2x1bWUgYXMgYmVmb3JlXG4gICAgaWYgKHRoaXMuY2FjaGVfLnZvbHVtZSkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFZvbHVtZScsIHRoaXMuY2FjaGVfLnZvbHVtZSk7XG4gICAgfVxuXG4gICAgLy8gTG9vayBpZiB0aGUgdGVjaCBmb3VuZCBhIGhpZ2hlciByZXNvbHV0aW9uIHBvc3RlciB3aGlsZSBsb2FkaW5nXG4gICAgdGhpcy5oYW5kbGVUZWNoUG9zdGVyQ2hhbmdlXygpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBkdXJhdGlvbiBpZiBhdmFpbGFibGVcbiAgICB0aGlzLmhhbmRsZVRlY2hEdXJhdGlvbkNoYW5nZV8oKTtcblxuICAgIC8vIENocm9tZSBhbmQgU2FmYXJpIGJvdGggaGF2ZSBpc3N1ZXMgd2l0aCBhdXRvcGxheS5cbiAgICAvLyBJbiBTYWZhcmkgKDUuMS4xKSwgd2hlbiB3ZSBtb3ZlIHRoZSB2aWRlbyBlbGVtZW50IGludG8gdGhlIGNvbnRhaW5lciBkaXYsIGF1dG9wbGF5IGRvZXNuJ3Qgd29yay5cbiAgICAvLyBJbiBDaHJvbWUgKDE1KSwgaWYgeW91IGhhdmUgYXV0b3BsYXkgKyBhIHBvc3RlciArIG5vIGNvbnRyb2xzLCB0aGUgdmlkZW8gZ2V0cyBoaWRkZW4gKGJ1dCBhdWRpbyBwbGF5cylcbiAgICAvLyBUaGlzIGZpeGVzIGJvdGggaXNzdWVzLiBOZWVkIHRvIHdhaXQgZm9yIEFQSSwgc28gaXQgdXBkYXRlcyBkaXNwbGF5cyBjb3JyZWN0bHlcbiAgICBpZiAoKHRoaXMuc3JjKCkgfHwgdGhpcy5jdXJyZW50U3JjKCkpICYmIHRoaXMudGFnICYmIHRoaXMub3B0aW9uc18uYXV0b3BsYXkgJiYgdGhpcy5wYXVzZWQoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hyb21lIEZpeC4gRml4ZWQgaW4gQ2hyb21lIHYxNi5cbiAgICAgICAgZGVsZXRlIHRoaXMudGFnLnBvc3RlcjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nJDEoJ2RlbGV0aW5nIHRhZy5wb3N0ZXIgdGhyb3dzIGluIHNvbWUgYnJvd3NlcnMnLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYGxvYWRzdGFydGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uIFRoaXNcbiAgICogZnVuY3Rpb24gd2lsbCBhbHNvIHRyaWdnZXIge0BsaW5rIFBsYXllciNmaXJzdHBsYXl9IGlmIGl0IGlzIHRoZSBmaXJzdCBsb2Fkc3RhcnRcbiAgICogZm9yIGEgdmlkZW8uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjbG9hZHN0YXJ0XG4gICAqIEBmaXJlcyBQbGF5ZXIjZmlyc3RwbGF5XG4gICAqIEBsaXN0ZW5zIFRlY2gjbG9hZHN0YXJ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoTG9hZFN0YXJ0XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hMb2FkU3RhcnRfKCkge1xuICAgIC8vIFRPRE86IFVwZGF0ZSB0byB1c2UgYGVtcHRpZWRgIGV2ZW50IGluc3RlYWQuIFNlZSAjMTI3Ny5cblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zZWVraW5nJyk7XG5cbiAgICAvLyByZXNldCB0aGUgZXJyb3Igc3RhdGVcbiAgICB0aGlzLmVycm9yKG51bGwpO1xuXG4gICAgLy8gSWYgaXQncyBhbHJlYWR5IHBsYXlpbmcgd2Ugd2FudCB0byB0cmlnZ2VyIGEgZmlyc3RwbGF5IGV2ZW50IG5vdy5cbiAgICAvLyBUaGUgZmlyc3RwbGF5IGV2ZW50IHJlbGllcyBvbiBib3RoIHRoZSBwbGF5IGFuZCBsb2Fkc3RhcnQgZXZlbnRzXG4gICAgLy8gd2hpY2ggY2FuIGhhcHBlbiBpbiBhbnkgb3JkZXIgZm9yIGEgbmV3IHNvdXJjZVxuICAgIGlmICghdGhpcy5wYXVzZWQoKSkge1xuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGFnZW50IGJlZ2lucyBsb29raW5nIGZvciBtZWRpYSBkYXRhXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IFBsYXllciNsb2Fkc3RhcnRcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgIHRoaXMudHJpZ2dlcignZmlyc3RwbGF5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlc2V0IHRoZSBoYXNTdGFydGVkIHN0YXRlXG4gICAgICB0aGlzLmhhc1N0YXJ0ZWQoZmFsc2UpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZC9yZW1vdmUgdGhlIHZqcy1oYXMtc3RhcnRlZCBjbGFzc1xuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2ZpcnN0cGxheVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVlc3RcbiAgICogICAgICAgIC0gdHJ1ZTogYWRkcyB0aGUgY2xhc3NcbiAgICogICAgICAgIC0gZmFsc2U6IHJlbW92ZSB0aGUgY2xhc3NcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICB0aGUgYm9vbGVhbiB2YWx1ZSBvZiBoYXNTdGFydGVkX1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IGZ1bmN0aW9uIGhhc1N0YXJ0ZWQocmVxdWVzdCkge1xuICAgIGlmIChyZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGFjdCBhcyBnZXR0ZXIsIGlmIHdlIGhhdmUgbm8gcmVxdWVzdCB0byBjaGFuZ2VcbiAgICAgIHJldHVybiB0aGlzLmhhc1N0YXJ0ZWRfO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0ID09PSB0aGlzLmhhc1N0YXJ0ZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5oYXNTdGFydGVkXyA9IHJlcXVlc3Q7XG5cbiAgICBpZiAodGhpcy5oYXNTdGFydGVkXykge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhhcy1zdGFydGVkJyk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ZpcnN0cGxheScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBtZWRpYSBiZWdpbnMgb3IgcmVzdW1lcyBwbGF5YmFja1xuICAgKlxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLXBsYXl9XG4gICAqIEBmaXJlcyBQbGF5ZXIjcGxheVxuICAgKiBAbGlzdGVucyBUZWNoI3BsYXlcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hQbGF5XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hQbGF5XygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZW5kZWQnKTtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGF1c2VkJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBsYXlpbmcnKTtcblxuICAgIC8vIGhpZGUgdGhlIHBvc3RlciB3aGVuIHRoZSB1c2VyIGhpdHMgcGxheVxuICAgIHRoaXMuaGFzU3RhcnRlZCh0cnVlKTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbmV2ZXIgYW4ge0BsaW5rIFRlY2gjcGxheX0gZXZlbnQgaGFwcGVucy4gSW5kaWNhdGVzIHRoYXRcbiAgICAgKiBwbGF5YmFjayBoYXMgc3RhcnRlZCBvciByZXN1bWVkLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNwbGF5XG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcigncGxheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGB3YWl0aW5nYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciN3YWl0aW5nXG4gICAqIEBsaXN0ZW5zIFRlY2gjd2FpdGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFdhaXRpbmdfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFdhaXRpbmdfKCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICAvKipcbiAgICAgKiBBIHJlYWR5U3RhdGUgY2hhbmdlIG9uIHRoZSBET00gZWxlbWVudCBoYXMgY2F1c2VkIHBsYXliYWNrIHRvIHN0b3AuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3dhaXRpbmdcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCd3YWl0aW5nJyk7XG4gICAgdGhpcy5vbmUoJ3RpbWV1cGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXM0LnJlbW92ZUNsYXNzKCd2anMtd2FpdGluZycpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBjYW5wbGF5YCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICogPiBOb3RlOiBUaGlzIGlzIG5vdCBjb25zaXN0ZW50IGJldHdlZW4gYnJvd3NlcnMuIFNlZSAjMTM1MVxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2NhbnBsYXlcbiAgICogQGxpc3RlbnMgVGVjaCNjYW5wbGF5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoQ2FuUGxheV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoQ2FuUGxheV8oKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWVkaWEgaGFzIGEgcmVhZHlTdGF0ZSBvZiBIQVZFX0ZVVFVSRV9EQVRBIG9yIGdyZWF0ZXIuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI2NhbnBsYXlcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdjYW5wbGF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYGNhbnBsYXl0aHJvdWdoYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNjYW5wbGF5dGhyb3VnaFxuICAgKiBAbGlzdGVucyBUZWNoI2NhbnBsYXl0aHJvdWdoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoQ2FuUGxheVRocm91Z2hfID0gZnVuY3Rpb24gaGFuZGxlVGVjaENhblBsYXlUaHJvdWdoXygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtd2FpdGluZycpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtZWRpYSBoYXMgYSByZWFkeVN0YXRlIG9mIEhBVkVfRU5PVUdIX0RBVEEgb3IgZ3JlYXRlci4gVGhpcyBtZWFucyB0aGF0IHRoZVxuICAgICAqIGVudGlyZSBtZWRpYSBmaWxlIGNhbiBiZSBwbGF5ZWQgd2l0aG91dCBidWZmZXJpbmcuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI2NhbnBsYXl0aHJvdWdoXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignY2FucGxheXRocm91Z2gnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgcGxheWluZ2AgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjcGxheWluZ1xuICAgKiBAbGlzdGVucyBUZWNoI3BsYXlpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hQbGF5aW5nXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hQbGF5aW5nXygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtd2FpdGluZycpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtZWRpYSBpcyBubyBsb25nZXIgYmxvY2tlZCBmcm9tIHBsYXliYWNrLCBhbmQgaGFzIHN0YXJ0ZWQgcGxheWluZy5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjcGxheWluZ1xuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3BsYXlpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgc2Vla2luZ2AgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjc2Vla2luZ1xuICAgKiBAbGlzdGVucyBUZWNoI3NlZWtpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hTZWVraW5nXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hTZWVraW5nXygpIHtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtc2Vla2luZycpO1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBwbGF5ZXIgaXMganVtcGluZyB0byBhIG5ldyB0aW1lXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3NlZWtpbmdcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdzZWVraW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYHNlZWtlZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjc2Vla2VkXG4gICAqIEBsaXN0ZW5zIFRlY2gjc2Vla2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoU2Vla2VkXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hTZWVrZWRfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zZWVraW5nJyk7XG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIGhhcyBmaW5pc2hlZCBqdW1waW5nIHRvIGEgbmV3IHRpbWVcbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjc2Vla2VkXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignc2Vla2VkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYGZpcnN0cGxheWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZmlyc3RwbGF5XG4gICAqIEBsaXN0ZW5zIFRlY2gjZmlyc3RwbGF5XG4gICAqIEBkZXByZWNhdGVkIEFzIG9mIDYuMCBmaXJzdHBsYXkgZXZlbnQgaXMgZGVwcmVjYXRlZC5cbiAgICogQGRlcHJlY2F0ZWQgQXMgb2YgNi4wIHBhc3NpbmcgdGhlIGBzdGFydHRpbWVgIG9wdGlvbiB0byB0aGUgcGxheWVyIGFuZCB0aGUgZmlyc3RwbGF5IGV2ZW50IGFyZSBkZXByZWNhdGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaEZpcnN0UGxheV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoRmlyc3RQbGF5XygpIHtcbiAgICAvLyBJZiB0aGUgZmlyc3Qgc3RhcnR0aW1lIGF0dHJpYnV0ZSBpcyBzcGVjaWZpZWRcbiAgICAvLyB0aGVuIHdlIHdpbGwgc3RhcnQgYXQgdGhlIGdpdmVuIG9mZnNldCBpbiBzZWNvbmRzXG4gICAgaWYgKHRoaXMub3B0aW9uc18uc3RhcnR0aW1lKSB7XG4gICAgICBsb2ckMS53YXJuKCdQYXNzaW5nIHRoZSBgc3RhcnR0aW1lYCBvcHRpb24gdG8gdGhlIHBsYXllciB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gNi4wJyk7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lKHRoaXMub3B0aW9uc18uc3RhcnR0aW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZENsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB0aGUgZmlyc3QgdGltZSBhIHZpZGVvIGlzIHBsYXllZC4gTm90IHBhcnQgb2YgdGhlIEhMUyBzcGVjLCBhbmQgdGhpcyBpc1xuICAgICAqIHByb2JhYmx5IG5vdCB0aGUgYmVzdCBpbXBsZW1lbnRhdGlvbiB5ZXQsIHNvIHVzZSBzcGFyaW5nbHkuIElmIHlvdSBkb24ndCBoYXZlIGFcbiAgICAgKiByZWFzb24gdG8gcHJldmVudCBwbGF5YmFjaywgdXNlIGBteVBsYXllci5vbmUoJ3BsYXknKTtgIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI2ZpcnN0cGxheVxuICAgICAqIEBkZXByZWNhdGVkIEFzIG9mIDYuMCBmaXJzdHBsYXkgZXZlbnQgaXMgZGVwcmVjYXRlZC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdmaXJzdHBsYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgcGF1c2VgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3BhdXNlXG4gICAqIEBsaXN0ZW5zIFRlY2gjcGF1c2VcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hQYXVzZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoUGF1c2VfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBtZWRpYSBoYXMgYmVlbiBwYXVzZWRcbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjcGF1c2VcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdwYXVzZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBlbmRlZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZW5kZWRcbiAgICogQGxpc3RlbnMgVGVjaCNlbmRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaEVuZGVkXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hFbmRlZF8oKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgaWYgKHRoaXMub3B0aW9uc18ubG9vcCkge1xuICAgICAgdGhpcy5jdXJyZW50VGltZSgwKTtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIG1lZGlhIHJlc291cmNlIGlzIHJlYWNoZWQgKGN1cnJlbnRUaW1lID09IGR1cmF0aW9uKVxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNlbmRlZFxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2VuZGVkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIGR1cmF0aW9uIG9mIHRoZSBtZWRpYSByZXNvdXJjZSBpcyBmaXJzdCBrbm93biBvciBjaGFuZ2VkXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjZHVyYXRpb25jaGFuZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hEdXJhdGlvbkNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoRHVyYXRpb25DaGFuZ2VfKCkge1xuICAgIHRoaXMuZHVyYXRpb24odGhpcy50ZWNoR2V0XygnZHVyYXRpb24nKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGNsaWNrIG9uIHRoZSBtZWRpYSBlbGVtZW50IHRvIHBsYXkvcGF1c2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHRyaWdnZXJcbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCNtb3VzZWRvd25cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hDbGlja18gPSBmdW5jdGlvbiBoYW5kbGVUZWNoQ2xpY2tfKGV2ZW50KSB7XG4gICAgaWYgKCFpc1NpbmdsZUxlZnRDbGljayhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGNvbnRyb2xzIGFyZSBkaXNhYmxlZCBhIGNsaWNrIHNob3VsZCBub3QgdG9nZ2xlIHBsYXliYWNrIGJlY2F1c2VcbiAgICAvLyB0aGUgY2xpY2sgaXMgY29uc2lkZXJlZCBhIGNvbnRyb2xcbiAgICBpZiAoIXRoaXMuY29udHJvbHNfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSB0YXAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIEl0IHdpbGwgdG9nZ2xlIHRoZSB1c2VyXG4gICAqIGFjdGl2aXR5IHN0YXRlLCB3aGljaCBoaWRlcyBhbmQgc2hvd3MgdGhlIGNvbnRyb2xzLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI3RhcFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFRhcF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoVGFwXygpIHtcbiAgICB0aGlzLnVzZXJBY3RpdmUoIXRoaXMudXNlckFjdGl2ZSgpKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRvdWNoIHRvIHN0YXJ0XG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjdG91Y2hzdGFydFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFRvdWNoU3RhcnRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRvdWNoU3RhcnRfKCkge1xuICAgIHRoaXMudXNlcldhc0FjdGl2ZSA9IHRoaXMudXNlckFjdGl2ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdG91Y2ggdG8gbW92ZVxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI3RvdWNobW92ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFRvdWNoTW92ZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoVG91Y2hNb3ZlXygpIHtcbiAgICBpZiAodGhpcy51c2VyV2FzQWN0aXZlKSB7XG4gICAgICB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRvdWNoIHRvIGVuZFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgdGhlIHRvdWNoZW5kIGV2ZW50IHRoYXQgdHJpZ2dlcmVkXG4gICAqICAgICAgICB0aGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjdG91Y2hlbmRcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hUb3VjaEVuZF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoVG91Y2hFbmRfKGV2ZW50KSB7XG4gICAgLy8gU3RvcCB0aGUgbW91c2UgZXZlbnRzIGZyb20gYWxzbyBoYXBwZW5pbmdcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBwbGF5ZXIgc3dpdGNoZXMgaW4gb3Igb3V0IG9mIGZ1bGxzY3JlZW4gbW9kZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlRnVsbHNjcmVlbkNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlXygpIHtcbiAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWZ1bGxzY3JlZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWZ1bGxzY3JlZW4nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIG5hdGl2ZSBjbGljayBldmVudHMgb24gdGhlIFNXRiBhcmVuJ3QgdHJpZ2dlcmVkIG9uIElFMTEsIFdpbjguMVJUXG4gICAqIHVzZSBzdGFnZWNsaWNrIGV2ZW50cyB0cmlnZ2VyZWQgZnJvbSBpbnNpZGUgdGhlIFNXRiBpbnN0ZWFkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBsaXN0ZW5zIHN0YWdlY2xpY2tcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVN0YWdlQ2xpY2tfID0gZnVuY3Rpb24gaGFuZGxlU3RhZ2VDbGlja18oKSB7XG4gICAgdGhpcy5yZXBvcnRVc2VyQWN0aXZpdHkoKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIFRlY2ggRnVsbHNjcmVlbiBDaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIHRoZSBmdWxsc2NyZWVuY2hhbmdlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogICAgICAgIHRoZSBkYXRhIHRoYXQgd2FzIHNlbnQgd2l0aCB0aGUgZXZlbnRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGxpc3RlbnMgVGVjaCNmdWxsc2NyZWVuY2hhbmdlXG4gICAqIEBmaXJlcyBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaEZ1bGxzY3JlZW5DaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlVGVjaEZ1bGxzY3JlZW5DaGFuZ2VfKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuaXNGdWxsc2NyZWVuKGRhdGEuaXNGdWxsc2NyZWVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBnb2luZyBpbiBhbmQgb3V0IG9mIGZ1bGxzY3JlZW4uXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBsb2FkaW5nIG9mIGFuIGF1ZGlvL3ZpZGVvLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbGlzdGVucyBUZWNoI2Vycm9yXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoRXJyb3JfID0gZnVuY3Rpb24gaGFuZGxlVGVjaEVycm9yXygpIHtcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnRlY2hfLmVycm9yKCk7XG5cbiAgICB0aGlzLmVycm9yKGVycm9yKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgdGV4dGRhdGFgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3RleHRkYXRhXG4gICAqIEBsaXN0ZW5zIFRlY2gjdGV4dGRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hUZXh0RGF0YV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoVGV4dERhdGFfKCkge1xuICAgIHZhciBkYXRhID0gbnVsbDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgZGF0YSA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHdlIGdldCBhIHRleHRkYXRhIGV2ZW50IGZyb20gdGVjaFxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciN0ZXh0ZGF0YVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3RleHRkYXRhJywgZGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvYmplY3QgZm9yIGNhY2hlZCB2YWx1ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBnZXQgdGhlIGN1cnJlbnQgb2JqZWN0IGNhY2hlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5nZXRDYWNoZSA9IGZ1bmN0aW9uIGdldENhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlXztcbiAgfTtcblxuICAvKipcbiAgICogUGFzcyB2YWx1ZXMgdG8gdGhlIHBsYXliYWNrIHRlY2hcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRob2RdXG4gICAqICAgICAgICB0aGUgbWV0aG9kIHRvIGNhbGxcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ1xuICAgKiAgICAgICAgdGhlIGFyZ3VtZW50IHRvIHBhc3NcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnRlY2hDYWxsXyA9IGZ1bmN0aW9uIHRlY2hDYWxsXyhtZXRob2QsIGFyZykge1xuICAgIC8vIElmIGl0J3Mgbm90IHJlYWR5IHlldCwgY2FsbCBtZXRob2Qgd2hlbiBpdCBpc1xuXG4gICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobWV0aG9kIGluIGFsbG93ZWRTZXR0ZXJzKSB7XG4gICAgICAgIHJldHVybiBzZXQkMSh0aGlzLm1pZGRsZXdhcmVfLCB0aGlzLnRlY2hfLCBtZXRob2QsIGFyZyk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICAgICAgdGhpcy50ZWNoX1ttZXRob2RdKGFyZyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nJDEoZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSwgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBjYWxscyBjYW4ndCB3YWl0IGZvciB0aGUgdGVjaCwgYW5kIHNvbWV0aW1lcyBkb24ndCBuZWVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gICAqICAgICAgICBUZWNoIG1ldGhvZFxuICAgKlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAqICAgICAgICAgdGhlIG1ldGhvZCBvciB1bmRlZmluZWRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnRlY2hHZXRfID0gZnVuY3Rpb24gdGVjaEdldF8obWV0aG9kKSB7XG4gICAgaWYgKCF0aGlzLnRlY2hfIHx8ICF0aGlzLnRlY2hfLmlzUmVhZHlfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCBpbiBhbGxvd2VkR2V0dGVycykge1xuICAgICAgcmV0dXJuIGdldCQxKHRoaXMubWlkZGxld2FyZV8sIHRoaXMudGVjaF8sIG1ldGhvZCk7XG4gICAgfVxuXG4gICAgLy8gRmxhc2ggbGlrZXMgdG8gZGllIGFuZCByZWxvYWQgd2hlbiB5b3UgaGlkZSBvciByZXBvc2l0aW9uIGl0LlxuICAgIC8vIEluIHRoZXNlIGNhc2VzIHRoZSBvYmplY3QgbWV0aG9kcyBnbyBhd2F5IGFuZCB3ZSBnZXQgZXJyb3JzLlxuICAgIC8vIFdoZW4gdGhhdCBoYXBwZW5zIHdlJ2xsIGNhdGNoIHRoZSBlcnJvcnMgYW5kIGluZm9ybSB0ZWNoIHRoYXQgaXQncyBub3QgcmVhZHkgYW55IG1vcmUuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hfW21ldGhvZF0oKTtcbiAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgIC8vIFdoZW4gYnVpbGRpbmcgYWRkaXRpb25hbCB0ZWNoIGxpYnMsIGFuIGV4cGVjdGVkIG1ldGhvZCBtYXkgbm90IGJlIGRlZmluZWQgeWV0XG4gICAgICBpZiAodGhpcy50ZWNoX1ttZXRob2RdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9nJDEoJ1ZpZGVvLmpzOiAnICsgbWV0aG9kICsgJyBtZXRob2Qgbm90IGRlZmluZWQgZm9yICcgKyB0aGlzLnRlY2hOYW1lXyArICcgcGxheWJhY2sgdGVjaG5vbG9neS4nLCBlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2hlbiBhIG1ldGhvZCBpc24ndCBhdmFpbGFibGUgb24gdGhlIG9iamVjdCBpdCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAgICAgIGlmIChlLm5hbWUgPT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgIGxvZyQxKCdWaWRlby5qczogJyArIG1ldGhvZCArICcgdW5hdmFpbGFibGUgb24gJyArIHRoaXMudGVjaE5hbWVfICsgJyBwbGF5YmFjayB0ZWNobm9sb2d5IGVsZW1lbnQuJywgZSk7XG4gICAgICAgIHRoaXMudGVjaF8uaXNSZWFkeV8gPSBmYWxzZTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZXJyb3IgdW5rbm93biwganVzdCBsb2cgYW5kIHRocm93XG4gICAgICBsb2ckMShlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGJlZ2luIHBsYXliYWNrIGF0IHRoZSBmaXJzdCBvcHBvcnR1bml0eS5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9XG4gICAqICAgICAgICAgUmV0dXJucyBhIGBQcm9taXNlYCBvbmx5IGlmIHRoZSBicm93c2VyIHJldHVybnMgb25lIGFuZCB0aGUgcGxheWVyXG4gICAqICAgICAgICAgaXMgcmVhZHkgdG8gYmVnaW4gcGxheWJhY2suIEZvciBzb21lIGJyb3dzZXJzIGFuZCBhbGwgbm9uLXJlYWR5XG4gICAqICAgICAgICAgc2l0dWF0aW9ucywgdGhpcyB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiBwbGF5KCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBjYWxsZWQgd2hpbGUgd2UgaGF2ZSBhIHBsYXkgcXVldWVkIHVwIG9uIGEgbG9hZHN0YXJ0LCByZW1vdmVcbiAgICAvLyB0aGF0IGxpc3RlbmVyIHRvIGF2b2lkIGdldHRpbmcgaW4gYSBwb3RlbnRpYWxseSBiYWQgc3RhdGUuXG4gICAgaWYgKHRoaXMucGxheU9uTG9hZHN0YXJ0Xykge1xuICAgICAgdGhpcy5vZmYoJ2xvYWRzdGFydCcsIHRoaXMucGxheU9uTG9hZHN0YXJ0Xyk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHBsYXllci90ZWNoIGlzIG5vdCByZWFkeSwgcXVldWUgdXAgYW5vdGhlciBjYWxsIHRvIGBwbGF5KClgIGZvclxuICAgIC8vIHdoZW4gaXQgaXMuIFRoaXMgd2lsbCBsb29wIGJhY2sgaW50byB0aGlzIG1ldGhvZCBmb3IgYW5vdGhlciBhdHRlbXB0IGF0XG4gICAgLy8gcGxheWJhY2sgd2hlbiB0aGUgdGVjaCBpcyByZWFkeS5cbiAgICBpZiAoIXRoaXMuaXNSZWFkeV8pIHtcblxuICAgICAgLy8gQmFpbCBvdXQgaWYgd2UncmUgYWxyZWFkeSB3YWl0aW5nIGZvciBgcmVhZHlgIVxuICAgICAgaWYgKHRoaXMucGxheVdhaXRpbmdGb3JSZWFkeV8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBsYXlXYWl0aW5nRm9yUmVhZHlfID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczUucGxheVdhaXRpbmdGb3JSZWFkeV8gPSBmYWxzZTtcbiAgICAgICAgc2lsZW5jZVByb21pc2UoX3RoaXM1LnBsYXkoKSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgdGhlIHBsYXllci90ZWNoIGlzIHJlYWR5IGFuZCB3ZSBoYXZlIGEgc291cmNlLCB3ZSBjYW4gYXR0ZW1wdCBwbGF5YmFjay5cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmNoYW5naW5nU3JjXyAmJiAodGhpcy5zcmMoKSB8fCB0aGlzLmN1cnJlbnRTcmMoKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdwbGF5Jyk7XG5cbiAgICAgIC8vIElmIHRoZSB0ZWNoIGlzIHJlYWR5LCBidXQgd2UgZG8gbm90IGhhdmUgYSBzb3VyY2UsIHdlJ2xsIG5lZWQgdG8gd2FpdFxuICAgICAgLy8gZm9yIGJvdGggdGhlIGByZWFkeWAgYW5kIGEgYGxvYWRzdGFydGAgd2hlbiB0aGUgc291cmNlIGlzIGZpbmFsbHlcbiAgICAgIC8vIHJlc29sdmVkIGJ5IG1pZGRsZXdhcmUgYW5kIHNldCBvbiB0aGUgcGxheWVyLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBgcGxheSgpYCBpcyBjYWxsZWQgd2hpbGUgY2hhbmdpbmcgc291cmNlcyBvciBiZWZvcmVcbiAgICAgIC8vIG9uZSBoYXMgYmVlbiBzZXQgb24gdGhlIHBsYXllci5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLnBsYXlPbkxvYWRzdGFydF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNS5wbGF5T25Mb2Fkc3RhcnRfID0gbnVsbDtcbiAgICAgICAgc2lsZW5jZVByb21pc2UoX3RoaXM1LnBsYXkoKSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9uZSgnbG9hZHN0YXJ0JywgdGhpcy5wbGF5T25Mb2Fkc3RhcnRfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSB2aWRlbyBwbGF5YmFja1xuICAgKlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAqICAgICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHBsYXllciBvYmplY3QgdGhpcyBmdW5jdGlvbiB3YXMgY2FsbGVkIG9uXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIHRoaXMudGVjaENhbGxfKCdwYXVzZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcGxheWVyIGlzIHBhdXNlZCBvciBoYXMgeWV0IHRvIHBsYXlcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIGZhbHNlOiBpZiB0aGUgbWVkaWEgaXMgY3VycmVudGx5IHBsYXlpbmdcbiAgICogICAgICAgICAtIHRydWU6IGlmIG1lZGlhIGlzIG5vdCBjdXJyZW50bHkgcGxheWluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucGF1c2VkID0gZnVuY3Rpb24gcGF1c2VkKCkge1xuICAgIC8vIFRoZSBpbml0aWFsIHN0YXRlIG9mIHBhdXNlZCBzaG91bGQgYmUgdHJ1ZSAoaW4gU2FmYXJpIGl0J3MgYWN0dWFsbHkgZmFsc2UpXG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BhdXNlZCcpID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgVGltZVJhbmdlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcmFuZ2VzIG9mIHRpbWUgdGhhdCB0aGUgdXNlclxuICAgKiBoYXMgcGxheWVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gICAqICAgICAgICAgQSB0aW1lIHJhbmdlIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYWxsIHRoZSBpbmNyZW1lbnRzIG9mIHRpbWUgdGhhdCBoYXZlXG4gICAqICAgICAgICAgYmVlbiBwbGF5ZWQuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wbGF5ZWQgPSBmdW5jdGlvbiBwbGF5ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BsYXllZCcpIHx8IGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHVzZXIgaXMgXCJzY3J1YmJpbmdcIi4gU2NydWJiaW5nIGlzXG4gICAqIHdoZW4gdGhlIHVzZXIgaGFzIGNsaWNrZWQgdGhlIHByb2dyZXNzIGJhciBoYW5kbGUgYW5kIGlzXG4gICAqIGRyYWdnaW5nIGl0IGFsb25nIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2NydWJiaW5nXVxuICAgKiAgICAgICAgd2V0aGVyIHRoZSB1c2VyIGlzIG9yIGlzIG5vdCBzY3J1YmJpbmdcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBUaGUgdmFsdWUgb2Ygc2NydWJiaW5nIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc2NydWJiaW5nID0gZnVuY3Rpb24gc2NydWJiaW5nKGlzU2NydWJiaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBpc1NjcnViYmluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcnViYmluZ187XG4gICAgfVxuICAgIHRoaXMuc2NydWJiaW5nXyA9ICEhaXNTY3J1YmJpbmc7XG5cbiAgICBpZiAoaXNTY3J1YmJpbmcpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zY3J1YmJpbmcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNjcnViYmluZycpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgY3VycmVudCB0aW1lIChpbiBzZWNvbmRzKVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtzZWNvbmRzXVxuICAgKiAgICAgICAgVGhlIHRpbWUgdG8gc2VlayB0byBpbiBzZWNvbmRzXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICAtIHRoZSBjdXJyZW50IHRpbWUgaW4gc2Vjb25kcyB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmN1cnJlbnRUaW1lID0gZnVuY3Rpb24gY3VycmVudFRpbWUoc2Vjb25kcykge1xuICAgIGlmICh0eXBlb2Ygc2Vjb25kcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChzZWNvbmRzIDwgMCkge1xuICAgICAgICBzZWNvbmRzID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRDdXJyZW50VGltZScsIHNlY29uZHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNhY2hlIGxhc3QgY3VycmVudFRpbWUgYW5kIHJldHVybi4gZGVmYXVsdCB0byAwIHNlY29uZHNcbiAgICAvL1xuICAgIC8vIENhY2hpbmcgdGhlIGN1cnJlbnRUaW1lIGlzIG1lYW50IHRvIHByZXZlbnQgYSBtYXNzaXZlIGFtb3VudCBvZiByZWFkcyBvbiB0aGUgdGVjaCdzXG4gICAgLy8gY3VycmVudFRpbWUgd2hlbiBzY3J1YmJpbmcsIGJ1dCBtYXkgbm90IHByb3ZpZGUgbXVjaCBwZXJmb3JtYW5jZSBiZW5lZml0IGFmdGVyYWxsLlxuICAgIC8vIFNob3VsZCBiZSB0ZXN0ZWQuIEFsc28gc29tZXRoaW5nIGhhcyB0byByZWFkIHRoZSBhY3R1YWwgY3VycmVudCB0aW1lIG9yIHRoZSBjYWNoZSB3aWxsXG4gICAgLy8gbmV2ZXIgZ2V0IHVwZGF0ZWQuXG4gICAgdGhpcy5jYWNoZV8uY3VycmVudFRpbWUgPSB0aGlzLnRlY2hHZXRfKCdjdXJyZW50VGltZScpIHx8IDA7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBOb3JtYWxseSBnZXRzIHRoZSBsZW5ndGggaW4gdGltZSBvZiB0aGUgdmlkZW8gaW4gc2Vjb25kcztcbiAgICogaW4gYWxsIGJ1dCB0aGUgcmFyZXN0IHVzZSBjYXNlcyBhbiBhcmd1bWVudCB3aWxsIE5PVCBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZFxuICAgKlxuICAgKiA+ICoqTk9URSoqOiBUaGUgdmlkZW8gbXVzdCBoYXZlIHN0YXJ0ZWQgbG9hZGluZyBiZWZvcmUgdGhlIGR1cmF0aW9uIGNhbiBiZVxuICAgKiBrbm93biwgYW5kIGluIHRoZSBjYXNlIG9mIEZsYXNoLCBtYXkgbm90IGJlIGtub3duIHVudGlsIHRoZSB2aWRlbyBzdGFydHNcbiAgICogcGxheWluZy5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNkdXJhdGlvbmNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZHNdXG4gICAqICAgICAgICBUaGUgZHVyYXRpb24gb2YgdGhlIHZpZGVvIHRvIHNldCBpbiBzZWNvbmRzXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICAtIFRoZSBkdXJhdGlvbiBvZiB0aGUgdmlkZW8gaW4gc2Vjb25kcyB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24oc2Vjb25kcykge1xuICAgIGlmIChzZWNvbmRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBOYU4gaWYgdGhlIGR1cmF0aW9uIGlzIG5vdCBrbm93blxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVfLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyB0aGlzLmNhY2hlXy5kdXJhdGlvbiA6IE5hTjtcbiAgICB9XG5cbiAgICBzZWNvbmRzID0gcGFyc2VGbG9hdChzZWNvbmRzKTtcblxuICAgIC8vIFN0YW5kYXJkaXplIG9uIEluaWZpdHkgZm9yIHNpZ25hbGluZyB2aWRlbyBpcyBsaXZlXG4gICAgaWYgKHNlY29uZHMgPCAwKSB7XG4gICAgICBzZWNvbmRzID0gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgaWYgKHNlY29uZHMgIT09IHRoaXMuY2FjaGVfLmR1cmF0aW9uKSB7XG4gICAgICAvLyBDYWNoZSB0aGUgbGFzdCBzZXQgdmFsdWUgZm9yIG9wdGltaXplZCBzY3J1YmJpbmcgKGVzcC4gRmxhc2gpXG4gICAgICB0aGlzLmNhY2hlXy5kdXJhdGlvbiA9IHNlY29uZHM7XG5cbiAgICAgIGlmIChzZWNvbmRzID09PSBJbmZpbml0eSkge1xuICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtbGl2ZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWxpdmUnKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQGV2ZW50IFBsYXllciNkdXJhdGlvbmNoYW5nZVxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2R1cmF0aW9uY2hhbmdlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGhvdyBtdWNoIHRpbWUgaXMgbGVmdCBpbiB0aGUgdmlkZW8uIE5vdCBwYXJ0XG4gICAqIG9mIHRoZSBuYXRpdmUgdmlkZW8gQVBJLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHRpbWUgcmVtYWluaW5nIGluIHNlY29uZHNcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlbWFpbmluZ1RpbWUgPSBmdW5jdGlvbiByZW1haW5pbmdUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLmR1cmF0aW9uKCkgLSB0aGlzLmN1cnJlbnRUaW1lKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgcmVtYWluaW5nIHRpbWUgZnVuY3Rpb24gdGhhdCBpcyBpbnRlbnRlZCB0byBiZSB1c2VkIHdoZW5cbiAgICogdGhlIHRpbWUgaXMgdG8gYmUgZGlzcGxheWVkIGRpcmVjdGx5IHRvIHRoZSB1c2VyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHJvdW5kZWQgdGltZSByZW1haW5pbmcgaW4gc2Vjb25kc1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucmVtYWluaW5nVGltZURpc3BsYXkgPSBmdW5jdGlvbiByZW1haW5pbmdUaW1lRGlzcGxheSgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLmR1cmF0aW9uKCkpIC0gTWF0aC5mbG9vcih0aGlzLmN1cnJlbnRUaW1lKCkpO1xuICB9O1xuXG4gIC8vXG4gIC8vIEtpbmQgb2YgbGlrZSBhbiBhcnJheSBvZiBwb3J0aW9ucyBvZiB0aGUgdmlkZW8gdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZC5cblxuICAvKipcbiAgICogR2V0IGEgVGltZVJhbmdlIG9iamVjdCB3aXRoIGFuIGFycmF5IG9mIHRoZSB0aW1lcyBvZiB0aGUgdmlkZW9cbiAgICogdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZC4gSWYgeW91IGp1c3Qgd2FudCB0aGUgcGVyY2VudCBvZiB0aGVcbiAgICogdmlkZW8gdGhhdCdzIGJlZW4gZG93bmxvYWRlZCwgdXNlIGJ1ZmZlcmVkUGVyY2VudC5cbiAgICpcbiAgICogQHNlZSBbQnVmZmVyZWQgU3BlY117QGxpbmsgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvc3BlYy92aWRlby5odG1sI2RvbS1tZWRpYS1idWZmZXJlZH1cbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgKiAgICAgICAgIEEgbW9jayBUaW1lUmFuZ2Ugb2JqZWN0IChmb2xsb3dpbmcgSFRNTCBzcGVjKVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYnVmZmVyZWQgPSBmdW5jdGlvbiBidWZmZXJlZCgpIHtcbiAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLnRlY2hHZXRfKCdidWZmZXJlZCcpO1xuXG4gICAgaWYgKCFidWZmZXJlZCB8fCAhYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICBidWZmZXJlZCA9IGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBlcmNlbnQgKGFzIGEgZGVjaW1hbCkgb2YgdGhlIHZpZGVvIHRoYXQncyBiZWVuIGRvd25sb2FkZWQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBhIHBhcnQgb2YgdGhlIG5hdGl2ZSBIVE1MIHZpZGVvIEFQSS5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIEEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDEgcmVwcmVzZW50aW5nIHRoZSBwZXJjZW50XG4gICAqICAgICAgICAgdGhhdCBpcyBidWZmZXJyZWQgMCBiZWluZyAwJSBhbmQgMSBiZWluZyAxMDAlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5idWZmZXJlZFBlcmNlbnQgPSBmdW5jdGlvbiBidWZmZXJlZFBlcmNlbnQkJDEoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcmVkUGVyY2VudCh0aGlzLmJ1ZmZlcmVkKCksIHRoaXMuZHVyYXRpb24oKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZW5kaW5nIHRpbWUgb2YgdGhlIGxhc3QgYnVmZmVyZWQgdGltZSByYW5nZVxuICAgKiBUaGlzIGlzIHVzZWQgaW4gdGhlIHByb2dyZXNzIGJhciB0byBlbmNhcHN1bGF0ZSBhbGwgdGltZSByYW5nZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZW5kIG9mIHRoZSBsYXN0IGJ1ZmZlcmVkIHRpbWUgcmFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmJ1ZmZlcmVkRW5kID0gZnVuY3Rpb24gYnVmZmVyZWRFbmQoKSB7XG4gICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy5idWZmZXJlZCgpO1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKTtcbiAgICB2YXIgZW5kID0gYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkLmxlbmd0aCAtIDEpO1xuXG4gICAgaWYgKGVuZCA+IGR1cmF0aW9uKSB7XG4gICAgICBlbmQgPSBkdXJhdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgbWVkaWFcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbcGVyY2VudEFzRGVjaW1hbF1cbiAgICogICAgICAgICBUaGUgbmV3IHZvbHVtZSBhcyBhIGRlY2ltYWwgcGVyY2VudDpcbiAgICogICAgICAgICAtIDAgaXMgbXV0ZWQvMCUvb2ZmXG4gICAqICAgICAgICAgLSAxLjAgaXMgMTAwJS9mdWxsXG4gICAqICAgICAgICAgLSAwLjUgaXMgaGFsZiB2b2x1bWUgb3IgNTAlXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2b2x1bWUgYXMgYSBwZXJjZW50IHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24gdm9sdW1lKHBlcmNlbnRBc0RlY2ltYWwpIHtcbiAgICB2YXIgdm9sID0gdm9pZCAwO1xuXG4gICAgaWYgKHBlcmNlbnRBc0RlY2ltYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRm9yY2UgdmFsdWUgdG8gYmV0d2VlbiAwIGFuZCAxXG4gICAgICB2b2wgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwYXJzZUZsb2F0KHBlcmNlbnRBc0RlY2ltYWwpKSk7XG4gICAgICB0aGlzLmNhY2hlXy52b2x1bWUgPSB2b2w7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0Vm9sdW1lJywgdm9sKTtcblxuICAgICAgaWYgKHZvbCA+IDApIHtcbiAgICAgICAgdGhpcy5sYXN0Vm9sdW1lXyh2b2wpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byAxIHdoZW4gcmV0dXJuaW5nIGN1cnJlbnQgdm9sdW1lLlxuICAgIHZvbCA9IHBhcnNlRmxvYXQodGhpcy50ZWNoR2V0Xygndm9sdW1lJykpO1xuICAgIHJldHVybiBpc05hTih2b2wpID8gMSA6IHZvbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IG11dGVkIHN0YXRlLCBvciB0dXJuIG11dGUgb24gb3Igb2ZmXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211dGVkXVxuICAgKiAgICAgICAgLSB0cnVlIHRvIG11dGVcbiAgICogICAgICAgIC0gZmFsc2UgdG8gdW5tdXRlXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSB0cnVlIGlmIG11dGUgaXMgb24gYW5kIGdldHRpbmdcbiAgICogICAgICAgICAtIGZhbHNlIGlmIG11dGUgaXMgb2ZmIGFuZCBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5tdXRlZCA9IGZ1bmN0aW9uIG11dGVkKF9tdXRlZCkge1xuICAgIGlmIChfbXV0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldE11dGVkJywgX211dGVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ211dGVkJykgfHwgZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBkZWZhdWx0TXV0ZWQgc3RhdGUsIG9yIHR1cm4gZGVmYXVsdE11dGVkIG9uIG9yIG9mZi4gZGVmYXVsdE11dGVkXG4gICAqIGluZGljYXRlcyB0aGUgc3RhdGUgb2YgbXV0ZWQgb24gaW50aWFsIHBsYXliYWNrLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAgIHZhciBteVBsYXllciA9IHZpZGVvanMoJ3NvbWUtcGxheWVyLWlkJyk7XG4gICAqXG4gICAqICAgbXlQbGF5ZXIuc3JjKFwiaHR0cDovL3d3dy5leGFtcGxlLmNvbS9wYXRoL3RvL3ZpZGVvLm1wNFwiKTtcbiAgICpcbiAgICogICAvLyBnZXQsIHNob3VsZCBiZSBmYWxzZVxuICAgKiAgIGNvbnNvbGUubG9nKG15UGxheWVyLmRlZmF1bHRNdXRlZCgpKTtcbiAgICogICAvLyBzZXQgdG8gdHJ1ZVxuICAgKiAgIG15UGxheWVyLmRlZmF1bHRNdXRlZCh0cnVlKTtcbiAgICogICAvLyBnZXQgc2hvdWxkIGJlIHRydWVcbiAgICogICBjb25zb2xlLmxvZyhteVBsYXllci5kZWZhdWx0TXV0ZWQoKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWZhdWx0TXV0ZWRdXG4gICAqICAgICAgICAtIHRydWUgdG8gbXV0ZVxuICAgKiAgICAgICAgLSBmYWxzZSB0byB1bm11dGVcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbnxQbGF5ZXJ9XG4gICAqICAgICAgICAgLSB0cnVlIGlmIGRlZmF1bHRNdXRlZCBpcyBvbiBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gZmFsc2UgaWYgZGVmYXVsdE11dGVkIGlzIG9mZiBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZGVmYXVsdE11dGVkID0gZnVuY3Rpb24gZGVmYXVsdE11dGVkKF9kZWZhdWx0TXV0ZWQpIHtcbiAgICBpZiAoX2RlZmF1bHRNdXRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoQ2FsbF8oJ3NldERlZmF1bHRNdXRlZCcsIF9kZWZhdWx0TXV0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnZGVmYXVsdE11dGVkJykgfHwgZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCB2b2x1bWUsIG9yIHNldCBpdFxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtwZXJjZW50QXNEZWNpbWFsXVxuICAgKiAgICAgICAgIFRoZSBuZXcgbGFzdCB2b2x1bWUgYXMgYSBkZWNpbWFsIHBlcmNlbnQ6XG4gICAqICAgICAgICAgLSAwIGlzIG11dGVkLzAlL29mZlxuICAgKiAgICAgICAgIC0gMS4wIGlzIDEwMCUvZnVsbFxuICAgKiAgICAgICAgIC0gMC41IGlzIGhhbGYgdm9sdW1lIG9yIDUwJVxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgbGFzdFZvbHVtZSBhcyBhIHBlcmNlbnQgd2hlbiBnZXR0aW5nXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sYXN0Vm9sdW1lXyA9IGZ1bmN0aW9uIGxhc3RWb2x1bWVfKHBlcmNlbnRBc0RlY2ltYWwpIHtcbiAgICBpZiAocGVyY2VudEFzRGVjaW1hbCAhPT0gdW5kZWZpbmVkICYmIHBlcmNlbnRBc0RlY2ltYWwgIT09IDApIHtcbiAgICAgIHRoaXMuY2FjaGVfLmxhc3RWb2x1bWUgPSBwZXJjZW50QXNEZWNpbWFsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZV8ubGFzdFZvbHVtZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgY3VycmVudCB0ZWNoIGNhbiBzdXBwb3J0IG5hdGl2ZSBmdWxsc2NyZWVuXG4gICAqIChlLmcuIHdpdGggYnVpbHQgaW4gY29udHJvbHMgbGlrZSBpT1MsIHNvIG5vdCBvdXIgZmxhc2ggc3dmKVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIGlmIG5hdGl2ZSBmdWxsc2NyZWVuIGlzIHN1cHBvcnRlZFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc3VwcG9ydHNGdWxsU2NyZWVuID0gZnVuY3Rpb24gc3VwcG9ydHNGdWxsU2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdzdXBwb3J0c0Z1bGxTY3JlZW4nKSB8fCBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHBsYXllciBpcyBpbiBmdWxsc2NyZWVuIG1vZGUgb3IgdGVsbCB0aGUgcGxheWVyIHRoYXQgaXRcbiAgICogaXMgb3IgaXMgbm90IGluIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICpcbiAgICogPiBOT1RFOiBBcyBvZiB0aGUgbGF0ZXN0IEhUTUw1IHNwZWMsIGlzRnVsbHNjcmVlbiBpcyBubyBsb25nZXIgYW4gb2ZmaWNpYWxcbiAgICogcHJvcGVydHkgYW5kIGluc3RlYWQgZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgaXMgdXNlZC4gQnV0IGlzRnVsbHNjcmVlbiBpc1xuICAgKiBzdGlsbCBhIHZhbHVhYmxlIHByb3BlcnR5IGZvciBpbnRlcm5hbCBwbGF5ZXIgd29ya2luZ3MuXG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFtpc0ZTXVxuICAgKiAgICAgICAgIFNldCB0aGUgcGxheWVycyBjdXJyZW50IGZ1bGxzY3JlZW4gc3RhdGVcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIHRydWUgaWYgZnVsbHNjcmVlbiBpcyBvbiBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gZmFsc2UgaWYgZnVsbHNjcmVlbiBpcyBvZmYgYW5kIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmlzRnVsbHNjcmVlbiA9IGZ1bmN0aW9uIGlzRnVsbHNjcmVlbihpc0ZTKSB7XG4gICAgaWYgKGlzRlMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pc0Z1bGxzY3JlZW5fID0gISFpc0ZTO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLmlzRnVsbHNjcmVlbl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlIHRoZSBzaXplIG9mIHRoZSB2aWRlbyB0byBmdWxsIHNjcmVlblxuICAgKiBJbiBzb21lIGJyb3dzZXJzLCBmdWxsIHNjcmVlbiBpcyBub3Qgc3VwcG9ydGVkIG5hdGl2ZWx5LCBzbyBpdCBlbnRlcnNcbiAgICogXCJmdWxsIHdpbmRvdyBtb2RlXCIsIHdoZXJlIHRoZSB2aWRlbyBmaWxscyB0aGUgYnJvd3NlciB3aW5kb3cuXG4gICAqIEluIGJyb3dzZXJzIGFuZCBkZXZpY2VzIHRoYXQgc3VwcG9ydCBuYXRpdmUgZnVsbCBzY3JlZW4sIHNvbWV0aW1lcyB0aGVcbiAgICogYnJvd3NlcidzIGRlZmF1bHQgY29udHJvbHMgd2lsbCBiZSBzaG93biwgYW5kIG5vdCB0aGUgVmlkZW8uanMgY3VzdG9tIHNraW4uXG4gICAqIFRoaXMgaW5jbHVkZXMgbW9zdCBtb2JpbGUgZGV2aWNlcyAoaU9TLCBBbmRyb2lkKSBhbmQgb2xkZXIgdmVyc2lvbnMgb2ZcbiAgICogU2FmYXJpLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlcXVlc3RGdWxsc2NyZWVuID0gZnVuY3Rpb24gcmVxdWVzdEZ1bGxzY3JlZW4oKSB7XG4gICAgdmFyIGZzQXBpID0gRnVsbHNjcmVlbkFwaTtcblxuICAgIHRoaXMuaXNGdWxsc2NyZWVuKHRydWUpO1xuXG4gICAgaWYgKGZzQXBpLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAvLyB0aGUgYnJvd3NlciBzdXBwb3J0cyBnb2luZyBmdWxsc2NyZWVuIGF0IHRoZSBlbGVtZW50IGxldmVsIHNvIHdlIGNhblxuICAgICAgLy8gdGFrZSB0aGUgY29udHJvbHMgZnVsbHNjcmVlbiBhcyB3ZWxsIGFzIHRoZSB2aWRlb1xuXG4gICAgICAvLyBUcmlnZ2VyIGZ1bGxzY3JlZW5jaGFuZ2UgZXZlbnQgYWZ0ZXIgY2hhbmdlXG4gICAgICAvLyBXZSBoYXZlIHRvIHNwZWNpZmljYWxseSBhZGQgdGhpcyBlYWNoIHRpbWUsIGFuZCByZW1vdmVcbiAgICAgIC8vIHdoZW4gY2FuY2VsaW5nIGZ1bGxzY3JlZW4uIE90aGVyd2lzZSBpZiB0aGVyZSdzIG11bHRpcGxlXG4gICAgICAvLyBwbGF5ZXJzIG9uIGEgcGFnZSwgdGhleSB3b3VsZCBhbGwgYmUgcmVhY3RpbmcgdG8gdGhlIHNhbWUgZnVsbHNjcmVlblxuICAgICAgLy8gZXZlbnRzXG4gICAgICBvbihkb2N1bWVudCwgZnNBcGkuZnVsbHNjcmVlbmNoYW5nZSwgYmluZCh0aGlzLCBmdW5jdGlvbiBkb2N1bWVudEZ1bGxzY3JlZW5DaGFuZ2UoZSkge1xuICAgICAgICB0aGlzLmlzRnVsbHNjcmVlbihkb2N1bWVudFtmc0FwaS5mdWxsc2NyZWVuRWxlbWVudF0pO1xuXG4gICAgICAgIC8vIElmIGNhbmNlbGxpbmcgZnVsbHNjcmVlbiwgcmVtb3ZlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4oKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsIGZzQXBpLmZ1bGxzY3JlZW5jaGFuZ2UsIGRvY3VtZW50RnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICAgIH0pKTtcblxuICAgICAgdGhpcy5lbF9bZnNBcGkucmVxdWVzdEZ1bGxzY3JlZW5dKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRlY2hfLnN1cHBvcnRzRnVsbFNjcmVlbigpKSB7XG4gICAgICAvLyB3ZSBjYW4ndCB0YWtlIHRoZSB2aWRlby5qcyBjb250cm9scyBmdWxsc2NyZWVuIGJ1dCB3ZSBjYW4gZ28gZnVsbHNjcmVlblxuICAgICAgLy8gd2l0aCBuYXRpdmUgY29udHJvbHNcbiAgICAgIHRoaXMudGVjaENhbGxfKCdlbnRlckZ1bGxTY3JlZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZnVsbHNjcmVlbiBpc24ndCBzdXBwb3J0ZWQgc28gd2UnbGwganVzdCBzdHJldGNoIHRoZSB2aWRlbyBlbGVtZW50IHRvXG4gICAgICAvLyBmaWxsIHRoZSB2aWV3cG9ydFxuICAgICAgdGhpcy5lbnRlckZ1bGxXaW5kb3coKTtcbiAgICAgIC8qKlxuICAgICAgICogQGV2ZW50IFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB2aWRlbyB0byBpdHMgbm9ybWFsIHNpemUgYWZ0ZXIgaGF2aW5nIGJlZW4gaW4gZnVsbCBzY3JlZW4gbW9kZVxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmV4aXRGdWxsc2NyZWVuID0gZnVuY3Rpb24gZXhpdEZ1bGxzY3JlZW4oKSB7XG4gICAgdmFyIGZzQXBpID0gRnVsbHNjcmVlbkFwaTtcblxuICAgIHRoaXMuaXNGdWxsc2NyZWVuKGZhbHNlKTtcblxuICAgIC8vIENoZWNrIGZvciBicm93c2VyIGVsZW1lbnQgZnVsbHNjcmVlbiBzdXBwb3J0XG4gICAgaWYgKGZzQXBpLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICBkb2N1bWVudFtmc0FwaS5leGl0RnVsbHNjcmVlbl0oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudGVjaF8uc3VwcG9ydHNGdWxsU2NyZWVuKCkpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdleGl0RnVsbFNjcmVlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4aXRGdWxsV2luZG93KCk7XG4gICAgICAvKipcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gZnVsbHNjcmVlbiBpc24ndCBzdXBwb3J0ZWQgd2UgY2FuIHN0cmV0Y2ggdGhlXG4gICAqIHZpZGVvIGNvbnRhaW5lciB0byBhcyB3aWRlIGFzIHRoZSBicm93c2VyIHdpbGwgbGV0IHVzLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2VudGVyRnVsbFdpbmRvd1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZW50ZXJGdWxsV2luZG93ID0gZnVuY3Rpb24gZW50ZXJGdWxsV2luZG93KCkge1xuICAgIHRoaXMuaXNGdWxsV2luZG93ID0gdHJ1ZTtcblxuICAgIC8vIFN0b3Jpbmcgb3JpZ2luYWwgZG9jIG92ZXJmbG93IHZhbHVlIHRvIHJldHVybiB0byB3aGVuIGZ1bGxzY3JlZW4gaXMgb2ZmXG4gICAgdGhpcy5kb2NPcmlnT3ZlcmZsb3cgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3c7XG5cbiAgICAvLyBBZGQgbGlzdGVuZXIgZm9yIGVzYyBrZXkgdG8gZXhpdCBmdWxsc2NyZWVuXG4gICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmZ1bGxXaW5kb3dPbkVzY0tleSkpO1xuXG4gICAgLy8gSGlkZSBhbnkgc2Nyb2xsIGJhcnNcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICAgIC8vIEFwcGx5IGZ1bGxzY3JlZW4gc3R5bGVzXG4gICAgYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ3Zqcy1mdWxsLXdpbmRvdycpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFBsYXllciNlbnRlckZ1bGxXaW5kb3dcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdlbnRlckZ1bGxXaW5kb3cnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgZm9yIGNhbGwgdG8gZWl0aGVyIGV4aXQgZnVsbCB3aW5kb3cgb3JcbiAgICogZnVsbCBzY3JlZW4gb24gRVNDIGtleVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogICAgICAgIEV2ZW50IHRvIGNoZWNrIGZvciBrZXkgcHJlc3NcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmZ1bGxXaW5kb3dPbkVzY0tleSA9IGZ1bmN0aW9uIGZ1bGxXaW5kb3dPbkVzY0tleShldmVudCkge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuICAgICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leGl0RnVsbFdpbmRvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXhpdCBmdWxsIHdpbmRvd1xuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2V4aXRGdWxsV2luZG93XG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5leGl0RnVsbFdpbmRvdyA9IGZ1bmN0aW9uIGV4aXRGdWxsV2luZG93KCkge1xuICAgIHRoaXMuaXNGdWxsV2luZG93ID0gZmFsc2U7XG4gICAgb2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuZnVsbFdpbmRvd09uRXNjS2V5KTtcblxuICAgIC8vIFVuaGlkZSBzY3JvbGwgYmFycy5cbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSB0aGlzLmRvY09yaWdPdmVyZmxvdztcblxuICAgIC8vIFJlbW92ZSBmdWxsc2NyZWVuIHN0eWxlc1xuICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICd2anMtZnVsbC13aW5kb3cnKTtcblxuICAgIC8vIFJlc2l6ZSB0aGUgYm94LCBjb250cm9sbGVyLCBhbmQgcG9zdGVyIHRvIG9yaWdpbmFsIHNpemVzXG4gICAgLy8gdGhpcy5wb3NpdGlvbkFsbCgpO1xuICAgIC8qKlxuICAgICAqIEBldmVudCBQbGF5ZXIjZXhpdEZ1bGxXaW5kb3dcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdleGl0RnVsbFdpbmRvdycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBwbGF5ZXIgY2FuIHBsYXkgYSBnaXZlbiBtaW1ldHlwZVxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwMTEzL3ZpZGVvLmh0bWwjZG9tLW5hdmlnYXRvci1jYW5wbGF5dHlwZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiBjYW5QbGF5VHlwZSh0eXBlKSB7XG4gICAgdmFyIGNhbiA9IHZvaWQgMDtcblxuICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIHBsYXliYWNrIHRlY2hub2xvZ3kgaW4gdGhlIG9wdGlvbnMgb3JkZXJcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMub3B0aW9uc18udGVjaE9yZGVyOyBpIDwgai5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRlY2hOYW1lID0galtpXTtcbiAgICAgIHZhciB0ZWNoID0gVGVjaC5nZXRUZWNoKHRlY2hOYW1lKTtcblxuICAgICAgLy8gU3VwcG9ydCBvbGQgYmVoYXZpb3Igb2YgdGVjaHMgYmVpbmcgcmVnaXN0ZXJlZCBhcyBjb21wb25lbnRzLlxuICAgICAgLy8gUmVtb3ZlIG9uY2UgdGhhdCBkZXByZWNhdGVkIGJlaGF2aW9yIGlzIHJlbW92ZWQuXG4gICAgICBpZiAoIXRlY2gpIHtcbiAgICAgICAgdGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQodGVjaE5hbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCB0ZWNoIGlzIGRlZmluZWQgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgIGlmICghdGVjaCkge1xuICAgICAgICBsb2ckMS5lcnJvcignVGhlIFwiJyArIHRlY2hOYW1lICsgJ1wiIHRlY2ggaXMgdW5kZWZpbmVkLiBTa2lwcGVkIGJyb3dzZXIgc3VwcG9ydCBjaGVjayBmb3IgdGhhdCB0ZWNoLicpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyB0ZWNobm9sb2d5XG4gICAgICBpZiAodGVjaC5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgIGNhbiA9IHRlY2guY2FuUGxheVR5cGUodHlwZSk7XG5cbiAgICAgICAgaWYgKGNhbikge1xuICAgICAgICAgIHJldHVybiBjYW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBzb3VyY2UgYmFzZWQgb24gdGVjaC1vcmRlciBvciBzb3VyY2Utb3JkZXJcbiAgICogVXNlcyBzb3VyY2Utb3JkZXIgc2VsZWN0aW9uIGlmIGBvcHRpb25zLnNvdXJjZU9yZGVyYCBpcyB0cnV0aHkuIE90aGVyd2lzZSxcbiAgICogZGVmYXVsdHMgdG8gdGVjaC1vcmRlciBzZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gc291cmNlc1xuICAgKiAgICAgICAgVGhlIHNvdXJjZXMgZm9yIGEgbWVkaWEgYXNzZXRcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fGJvb2xlYW59XG4gICAqICAgICAgICAgT2JqZWN0IG9mIHNvdXJjZSBhbmQgdGVjaCBvcmRlciBvciBmYWxzZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc2VsZWN0U291cmNlID0gZnVuY3Rpb24gc2VsZWN0U291cmNlKHNvdXJjZXMpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIC8vIEdldCBvbmx5IHRoZSB0ZWNocyBzcGVjaWZpZWQgaW4gYHRlY2hPcmRlcmAgdGhhdCBleGlzdCBhbmQgYXJlIHN1cHBvcnRlZCBieSB0aGVcbiAgICAvLyBjdXJyZW50IHBsYXRmb3JtXG4gICAgdmFyIHRlY2hzID0gdGhpcy5vcHRpb25zXy50ZWNoT3JkZXIubWFwKGZ1bmN0aW9uICh0ZWNoTmFtZSkge1xuICAgICAgcmV0dXJuIFt0ZWNoTmFtZSwgVGVjaC5nZXRUZWNoKHRlY2hOYW1lKV07XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgdGVjaE5hbWUgPSBfcmVmWzBdLFxuICAgICAgICAgIHRlY2ggPSBfcmVmWzFdO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCB0ZWNoIGlzIGRlZmluZWQgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgIGlmICh0ZWNoKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoaXMgdGVjaG5vbG9neVxuICAgICAgICByZXR1cm4gdGVjaC5pc1N1cHBvcnRlZCgpO1xuICAgICAgfVxuXG4gICAgICBsb2ckMS5lcnJvcignVGhlIFwiJyArIHRlY2hOYW1lICsgJ1wiIHRlY2ggaXMgdW5kZWZpbmVkLiBTa2lwcGVkIGJyb3dzZXIgc3VwcG9ydCBjaGVjayBmb3IgdGhhdCB0ZWNoLicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGVhY2ggYGlubmVyQXJyYXlgIGVsZW1lbnQgb25jZSBwZXIgYG91dGVyQXJyYXlgIGVsZW1lbnQgYW5kIGV4ZWN1dGVcbiAgICAvLyBgdGVzdGVyYCB3aXRoIGJvdGguIElmIGB0ZXN0ZXJgIHJldHVybnMgYSBub24tZmFsc3kgdmFsdWUsIGV4aXQgZWFybHkgYW5kIHJldHVyblxuICAgIC8vIHRoYXQgdmFsdWUuXG4gICAgdmFyIGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpciA9IGZ1bmN0aW9uIGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpcihvdXRlckFycmF5LCBpbm5lckFycmF5LCB0ZXN0ZXIpIHtcbiAgICAgIHZhciBmb3VuZCA9IHZvaWQgMDtcblxuICAgICAgb3V0ZXJBcnJheS5zb21lKGZ1bmN0aW9uIChvdXRlckNob2ljZSkge1xuICAgICAgICByZXR1cm4gaW5uZXJBcnJheS5zb21lKGZ1bmN0aW9uIChpbm5lckNob2ljZSkge1xuICAgICAgICAgIGZvdW5kID0gdGVzdGVyKG91dGVyQ2hvaWNlLCBpbm5lckNob2ljZSk7XG5cbiAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH07XG5cbiAgICB2YXIgZm91bmRTb3VyY2VBbmRUZWNoID0gdm9pZCAwO1xuICAgIHZhciBmbGlwID0gZnVuY3Rpb24gZmxpcChmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBmbihiLCBhKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZmluZGVyID0gZnVuY3Rpb24gZmluZGVyKF9yZWYyLCBzb3VyY2UpIHtcbiAgICAgIHZhciB0ZWNoTmFtZSA9IF9yZWYyWzBdLFxuICAgICAgICAgIHRlY2ggPSBfcmVmMlsxXTtcblxuICAgICAgaWYgKHRlY2guY2FuUGxheVNvdXJjZShzb3VyY2UsIF90aGlzNi5vcHRpb25zX1t0ZWNoTmFtZS50b0xvd2VyQ2FzZSgpXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgc291cmNlOiBzb3VyY2UsIHRlY2g6IHRlY2hOYW1lIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIERlcGVuZGluZyBvbiB0aGUgdHJ1dGhpbmVzcyBvZiBgb3B0aW9ucy5zb3VyY2VPcmRlcmAsIHdlIHN3YXAgdGhlIG9yZGVyIG9mIHRlY2hzIGFuZCBzb3VyY2VzXG4gICAgLy8gdG8gc2VsZWN0IGZyb20gdGhlbSBiYXNlZCBvbiB0aGVpciBwcmlvcml0eS5cbiAgICBpZiAodGhpcy5vcHRpb25zXy5zb3VyY2VPcmRlcikge1xuICAgICAgLy8gU291cmNlLWZpcnN0IG9yZGVyaW5nXG4gICAgICBmb3VuZFNvdXJjZUFuZFRlY2ggPSBmaW5kRmlyc3RQYXNzaW5nVGVjaFNvdXJjZVBhaXIoc291cmNlcywgdGVjaHMsIGZsaXAoZmluZGVyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRlY2gtZmlyc3Qgb3JkZXJpbmdcbiAgICAgIGZvdW5kU291cmNlQW5kVGVjaCA9IGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpcih0ZWNocywgc291cmNlcywgZmluZGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm91bmRTb3VyY2VBbmRUZWNoIHx8IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSB2aWRlbyBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R8VGVjaH5Tb3VyY2VPYmplY3RbXXxzdHJpbmd9IFtzb3VyY2VdXG4gICAqICAgICAgICBBIFNvdXJjZU9iamVjdCwgYW4gYXJyYXkgb2YgU291cmNlT2JqZWN0cywgb3IgYSBzdHJpbmcgcmVmZXJlbmNpbmdcbiAgICogICAgICAgIGEgVVJMIHRvIGEgbWVkaWEgc291cmNlLiBJdCBpcyBfaGlnaGx5IHJlY29tbWVuZGVkXyB0aGF0IGFuIG9iamVjdFxuICAgKiAgICAgICAgb3IgYXJyYXkgb2Ygb2JqZWN0cyBpcyB1c2VkIGhlcmUsIHNvIHRoYXQgc291cmNlIHNlbGVjdGlvblxuICAgKiAgICAgICAgYWxnb3JpdGhtcyBjYW4gdGFrZSB0aGUgYHR5cGVgIGludG8gYWNjb3VudC5cbiAgICpcbiAgICogICAgICAgIElmIG5vdCBwcm92aWRlZCwgdGhpcyBtZXRob2QgYWN0cyBhcyBhIGdldHRlci5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICogICAgICAgICBJZiB0aGUgYHNvdXJjZWAgYXJndW1lbnQgaXMgbWlzc2luZywgcmV0dXJucyB0aGUgY3VycmVudCBzb3VyY2VcbiAgICogICAgICAgICBVUkwuIE90aGVyd2lzZSwgcmV0dXJucyBub3RoaW5nL3VuZGVmaW5lZC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uIHNyYyhzb3VyY2UpIHtcbiAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgIC8vIGdldHRlciB1c2FnZVxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVfLnNyYyB8fCAnJztcbiAgICB9XG4gICAgLy8gZmlsdGVyIG91dCBpbnZhbGlkIHNvdXJjZXMgYW5kIHR1cm4gb3VyIHNvdXJjZSBpbnRvXG4gICAgLy8gYW4gYXJyYXkgb2Ygc291cmNlIG9iamVjdHNcbiAgICB2YXIgc291cmNlcyA9IGZpbHRlclNvdXJjZShzb3VyY2UpO1xuXG4gICAgLy8gaWYgYSBzb3VyY2Ugd2FzIHBhc3NlZCBpbiB0aGVuIGl0IGlzIGludmFsaWQgYmVjYXVzZVxuICAgIC8vIGl0IHdhcyBmaWx0ZXJlZCB0byBhIHplcm8gbGVuZ3RoIEFycmF5LiBTbyB3ZSBoYXZlIHRvXG4gICAgLy8gc2hvdyBhbiBlcnJvclxuICAgIGlmICghc291cmNlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXJyb3IoeyBjb2RlOiA0LCBtZXNzYWdlOiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubm90U3VwcG9ydGVkTWVzc2FnZSkgfSk7XG4gICAgICB9LCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpbnRpYWwgc291cmNlc1xuICAgIHRoaXMuY2FjaGVfLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgIHRoaXMuY2hhbmdpbmdTcmNfID0gdHJ1ZTtcblxuICAgIC8vIGludGlhbCBzb3VyY2VcbiAgICB0aGlzLmNhY2hlXy5zb3VyY2UgPSBzb3VyY2VzWzBdO1xuXG4gICAgLy8gbWlkZGxld2FyZVNvdXJjZSBpcyB0aGUgc291cmNlIGFmdGVyIGl0IGhhcyBiZWVuIGNoYW5nZWQgYnkgbWlkZGxld2FyZVxuICAgIHNldFNvdXJjZSh0aGlzLCBzb3VyY2VzWzBdLCBmdW5jdGlvbiAobWlkZGxld2FyZVNvdXJjZSwgbXdzKSB7XG4gICAgICBfdGhpczcubWlkZGxld2FyZV8gPSBtd3M7XG5cbiAgICAgIHZhciBlcnIgPSBfdGhpczcuc3JjXyhtaWRkbGV3YXJlU291cmNlKTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoc291cmNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNy5zcmMoc291cmNlcy5zbGljZSgxKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiBhIHRpbWVvdXQgdG8gZ2l2ZSBmb2xrcyBhIGNoYW5jZSB0byBhZGQgZXJyb3IgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgX3RoaXM3LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuZXJyb3IoeyBjb2RlOiA0LCBtZXNzYWdlOiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubm90U3VwcG9ydGVkTWVzc2FnZSkgfSk7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIC8vIHdlIGNvdWxkIG5vdCBmaW5kIGFuIGFwcHJvcHJpYXRlIHRlY2gsIGJ1dCBsZXQncyBzdGlsbCBub3RpZnkgdGhlIGRlbGVnYXRlIHRoYXQgdGhpcyBpcyBpdFxuICAgICAgICAvLyB0aGlzIG5lZWRzIGEgYmV0dGVyIGNvbW1lbnQgYWJvdXQgd2h5IHRoaXMgaXMgbmVlZGVkXG4gICAgICAgIF90aGlzNy50cmlnZ2VyUmVhZHkoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzNy5jaGFuZ2luZ1NyY18gPSBmYWxzZTtcbiAgICAgIC8vIHZpZGVvIGVsZW1lbnQgbGlzdGVkIHNvdXJjZVxuICAgICAgX3RoaXM3LmNhY2hlXy5zcmMgPSBtaWRkbGV3YXJlU291cmNlLnNyYztcblxuICAgICAgc2V0VGVjaChtd3MsIF90aGlzNy50ZWNoXyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIG9iamVjdCBvbiB0aGUgdGVjaCwgcmV0dXJucyBhIGJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgd2V0aGVyXG4gICAqIHRoZXJlIGlzIGEgdGVjaCB0aGF0IGNhbiBwbGF5IHRoZSBzb3VyY2Ugb3Igbm90XG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNvdXJjZVxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3QgdG8gc2V0IG9uIHRoZSBUZWNoXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqICAgICAgICAgLSBUcnVlIGlmIHRoZXJlIGlzIG5vIFRlY2ggdG8gcGxheWJhY2sgdGhpcyBzb3VyY2VcbiAgICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc3JjXyA9IGZ1bmN0aW9uIHNyY18oc291cmNlKSB7XG4gICAgdmFyIHNvdXJjZVRlY2ggPSB0aGlzLnNlbGVjdFNvdXJjZShbc291cmNlXSk7XG5cbiAgICBpZiAoIXNvdXJjZVRlY2gpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGl0bGVDYXNlRXF1YWxzKHNvdXJjZVRlY2gudGVjaCwgdGhpcy50ZWNoTmFtZV8pKSB7XG4gICAgICB0aGlzLmNoYW5naW5nU3JjXyA9IHRydWU7XG5cbiAgICAgIC8vIGxvYWQgdGhpcyB0ZWNobm9sb2d5IHdpdGggdGhlIGNob3NlbiBzb3VyY2VcbiAgICAgIHRoaXMubG9hZFRlY2hfKHNvdXJjZVRlY2gudGVjaCwgc291cmNlVGVjaC5zb3VyY2UpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHdhaXQgdW50aWwgdGhlIHRlY2ggaXMgcmVhZHkgdG8gc2V0IHRoZSBzb3VyY2VcbiAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gVGhlIHNldFNvdXJjZSB0ZWNoIG1ldGhvZCB3YXMgYWRkZWQgd2l0aCBzb3VyY2UgaGFuZGxlcnNcbiAgICAgIC8vIHNvIG9sZGVyIHRlY2hzIHdvbid0IHN1cHBvcnQgaXRcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgdGhlIGRpcmVjdCBwcm90b3R5cGUgZm9yIHRoZSBjYXNlIHdoZXJlIHN1YmNsYXNzZXNcbiAgICAgIC8vIG9mIHRoZSB0ZWNoIGRvIG5vdCBzdXBwb3J0IHNvdXJjZSBoYW5kbGVyc1xuICAgICAgaWYgKHRoaXMudGVjaF8uY29uc3RydWN0b3IucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdzZXRTb3VyY2UnKSkge1xuICAgICAgICB0aGlzLnRlY2hDYWxsXygnc2V0U291cmNlJywgc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGVjaENhbGxfKCdzcmMnLCBzb3VyY2Uuc3JjKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9uc18ucHJlbG9hZCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIHNvdXJjZSBzeW5jaHJvbm91c2x5IGlmIHBvc3NpYmxlICgjMjMyNilcbiAgICB9LCB0cnVlKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQmVnaW4gbG9hZGluZyB0aGUgc3JjIGRhdGEuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZCgpIHtcbiAgICB0aGlzLnRlY2hDYWxsXygnbG9hZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgcGxheWVyLiBMb2FkcyB0aGUgZmlyc3QgdGVjaCBpbiB0aGUgdGVjaE9yZGVyLFxuICAgKiBhbmQgY2FsbHMgYHJlc2V0YCBvbiB0aGUgdGVjaGAuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMubG9hZFRlY2hfKHRoaXMub3B0aW9uc18udGVjaE9yZGVyWzBdLCBudWxsKTtcbiAgICB0aGlzLnRlY2hDYWxsXygncmVzZXQnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgb2YgdGhlIGN1cnJlbnQgc291cmNlIG9iamVjdHMuXG4gICAqXG4gICAqIEByZXR1cm4ge1RlY2h+U291cmNlT2JqZWN0W119XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgc291cmNlIG9iamVjdHNcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmN1cnJlbnRTb3VyY2VzID0gZnVuY3Rpb24gY3VycmVudFNvdXJjZXMoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuY3VycmVudFNvdXJjZSgpO1xuICAgIHZhciBzb3VyY2VzID0gW107XG5cbiAgICAvLyBhc3N1bWUgYHt9YCBvciBgeyBzcmMgfWBcbiAgICBpZiAoT2JqZWN0LmtleXMoc291cmNlKS5sZW5ndGggIT09IDApIHtcbiAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNhY2hlXy5zb3VyY2VzIHx8IHNvdXJjZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc291cmNlIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7VGVjaH5Tb3VyY2VPYmplY3R9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgc291cmNlIG9iamVjdFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY3VycmVudFNvdXJjZSA9IGZ1bmN0aW9uIGN1cnJlbnRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVfLnNvdXJjZSB8fCB7fTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZnVsbHkgcXVhbGlmaWVkIFVSTCBvZiB0aGUgY3VycmVudCBzb3VyY2UgdmFsdWUgZS5nLiBodHRwOi8vbXlzaXRlLmNvbS92aWRlby5tcDRcbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIGBjdXJyZW50VHlwZWAgdG8gYXNzaXN0IGluIHJlYnVpbGRpbmcgdGhlIGN1cnJlbnQgc291cmNlIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHNvdXJjZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY3VycmVudFNyYyA9IGZ1bmN0aW9uIGN1cnJlbnRTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFNvdXJjZSgpICYmIHRoaXMuY3VycmVudFNvdXJjZSgpLnNyYyB8fCAnJztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHNvdXJjZSB0eXBlIGUuZy4gdmlkZW8vbXA0XG4gICAqIFRoaXMgY2FuIGFsbG93IHlvdSByZWJ1aWxkIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3Qgc28gdGhhdCB5b3UgY291bGQgbG9hZCB0aGUgc2FtZVxuICAgKiBzb3VyY2UgYW5kIHRlY2ggbGF0ZXJcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBzb3VyY2UgTUlNRSB0eXBlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jdXJyZW50VHlwZSA9IGZ1bmN0aW9uIGN1cnJlbnRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTb3VyY2UoKSAmJiB0aGlzLmN1cnJlbnRTb3VyY2UoKS50eXBlIHx8ICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBwcmVsb2FkIGF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgIC0gdHJ1ZSBtZWFucyB0aGF0IHdlIHNob3VsZCBwcmVsb2FkXG4gICAqICAgICAgICAtIGZhbHNlIG1hZW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBwcmVsb2FkXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgcHJlbG9hZCBhdHRyaWJ1dGUgdmFsdWUgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wcmVsb2FkID0gZnVuY3Rpb24gcHJlbG9hZCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0UHJlbG9hZCcsIHZhbHVlKTtcbiAgICAgIHRoaXMub3B0aW9uc18ucHJlbG9hZCA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygncHJlbG9hZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBhdXRvcGxheSBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbHVlXVxuICAgKiAgICAgICAgLSB0cnVlIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIGF1dG9wbGF5XG4gICAqICAgICAgICAtIGZhbHNlIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBhdXRvcGxheVxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgYXV0b3BsYXkgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5hdXRvcGxheSA9IGZ1bmN0aW9uIGF1dG9wbGF5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRBdXRvcGxheScsIHZhbHVlKTtcbiAgICAgIHRoaXMub3B0aW9uc18uYXV0b3BsYXkgPSB2YWx1ZTtcbiAgICAgIHRoaXMucmVhZHkodGhpcy5mb3JjZUF1dG9wbGF5SW5DaHJvbWVfKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ2F1dG9wbGF5JywgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBjaHJvbWUgc3RhcnRlZCBwYXVzaW5nIHRoZSB2aWRlbyB3aGVuIG1vdmluZyBpbiB0aGUgRE9NXG4gICAqIGNhdXNpbmcgYXV0b3BsYXkgdG8gbm90IGNvbnRpbnVlIGR1ZSB0byBob3cgVmlkZW8uanMgZnVuY3Rpb25zLlxuICAgKiBTZWUgIzQ3MjAgZm9yIG1vcmUgaW5mby5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmZvcmNlQXV0b3BsYXlJbkNocm9tZV8gPSBmdW5jdGlvbiBmb3JjZUF1dG9wbGF5SW5DaHJvbWVfKCkge1xuICAgIGlmICh0aGlzLnBhdXNlZCgpICYmIChcbiAgICAvLyByZWFkIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQgb3Igb3B0aW9uc1xuICAgIHRoaXMuYXV0b3BsYXkoKSB8fCB0aGlzLm9wdGlvbnNfLmF1dG9wbGF5KSAmJlxuICAgIC8vIG9ubHkgdGFyZ2V0IGRlc2t0b3AgY2hyb21lXG4gICAgSVNfQ0hST01FICYmICFJU19BTkRST0lEKSB7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBvciB1bnNldCB0aGUgcGxheXNpbmxpbmUgYXR0cmlidXRlLlxuICAgKiBQbGF5c2lubGluZSB0ZWxscyB0aGUgYnJvd3NlciB0aGF0IG5vbi1mdWxsc2NyZWVuIHBsYXliYWNrIGlzIHByZWZlcnJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbdmFsdWVdXG4gICAqICAgICAgICAtIHRydWUgbWVhbnMgdGhhdCB3ZSBzaG91bGQgdHJ5IHRvIHBsYXkgaW5saW5lIGJ5IGRlZmF1bHRcbiAgICogICAgICAgIC0gZmFsc2UgbWVhbnMgdGhhdCB3ZSBzaG91bGQgdXNlIHRoZSBicm93c2VyJ3MgZGVmYXVsdCBwbGF5YmFjayBtb2RlLFxuICAgKiAgICAgICAgICB3aGljaCBpbiBtb3N0IGNhc2VzIGlzIGlubGluZS4gaU9TIFNhZmFyaSBpcyBhIG5vdGFibGUgZXhjZXB0aW9uXG4gICAqICAgICAgICAgIGFuZCBwbGF5cyBmdWxsc2NyZWVuIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ3xQbGF5ZXJ9XG4gICAqICAgICAgICAgLSB0aGUgY3VycmVudCB2YWx1ZSBvZiBwbGF5c2lubGluZVxuICAgKiAgICAgICAgIC0gdGhlIHBsYXllciB3aGVuIHNldHRpbmdcbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jYXR0ci12aWRlby1wbGF5c2lubGluZX1cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnBsYXlzaW5saW5lID0gZnVuY3Rpb24gcGxheXNpbmxpbmUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFBsYXlzaW5saW5lJywgdmFsdWUpO1xuICAgICAgdGhpcy5vcHRpb25zXy5wbGF5c2lubGluZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdwbGF5c2lubGluZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBsb29wIGF0dHJpYnV0ZSBvbiB0aGUgdmlkZW8gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbdmFsdWVdXG4gICAqICAgICAgICAtIHRydWUgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbG9vcCB0aGUgdmlkZW9cbiAgICogICAgICAgIC0gZmFsc2UgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxvb3AgdGhlIHZpZGVvXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBsb29wIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubG9vcCA9IGZ1bmN0aW9uIGxvb3AodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldExvb3AnLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfLmxvb3AgPSB2YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ2xvb3AnKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgcG9zdGVyIGltYWdlIHNvdXJjZSB1cmxcbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNwb3N0ZXJjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzcmNdXG4gICAqICAgICAgICBQb3N0ZXIgaW1hZ2Ugc291cmNlIFVSTFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgcG9zdGVyIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucG9zdGVyID0gZnVuY3Rpb24gcG9zdGVyKHNyYykge1xuICAgIGlmIChzcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9zdGVyXztcbiAgICB9XG5cbiAgICAvLyBUaGUgY29ycmVjdCB3YXkgdG8gcmVtb3ZlIGEgcG9zdGVyIGlzIHRvIHNldCBhcyBhbiBlbXB0eSBzdHJpbmdcbiAgICAvLyBvdGhlciBmYWxzZXkgdmFsdWVzIHdpbGwgdGhyb3cgZXJyb3JzXG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHNyYyA9ICcnO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0aGUgaW50ZXJuYWwgcG9zdGVyIHZhcmlhYmxlXG4gICAgdGhpcy5wb3N0ZXJfID0gc3JjO1xuXG4gICAgLy8gdXBkYXRlIHRoZSB0ZWNoJ3MgcG9zdGVyXG4gICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFBvc3RlcicsIHNyYyk7XG5cbiAgICAvLyBhbGVydCBjb21wb25lbnRzIHRoYXQgdGhlIHBvc3RlciBoYXMgYmVlbiBzZXRcbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGZpcmVzIHdoZW4gdGhlIHBvc3RlciBpbWFnZSBpcyBjaGFuZ2VkIG9uIHRoZSBwbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3Bvc3RlcmNoYW5nZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3Bvc3RlcmNoYW5nZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTb21lIHRlY2hzIChlLmcuIFlvdVR1YmUpIGNhbiBwcm92aWRlIGEgcG9zdGVyIHNvdXJjZSBpbiBhblxuICAgKiBhc3luY2hyb25vdXMgd2F5LiBXZSB3YW50IHRoZSBwb3N0ZXIgY29tcG9uZW50IHRvIHVzZSB0aGlzXG4gICAqIHBvc3RlciBzb3VyY2Ugc28gdGhhdCBpdCBjb3ZlcnMgdXAgdGhlIHRlY2gncyBjb250cm9scy5cbiAgICogKFlvdVR1YmUncyBwbGF5IGJ1dHRvbikuIEhvd2V2ZXIgd2Ugb25seSB3YW50IHRvIHVzZSB0aGlzXG4gICAqIHNvdXJjZSBpZiB0aGUgcGxheWVyIHVzZXIgaGFzbid0IHNldCBhIHBvc3RlciB0aHJvdWdoXG4gICAqIHRoZSBub3JtYWwgQVBJcy5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNwb3N0ZXJjaGFuZ2VcbiAgICogQGxpc3RlbnMgVGVjaCNwb3N0ZXJjaGFuZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hQb3N0ZXJDaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFBvc3RlckNoYW5nZV8oKSB7XG4gICAgaWYgKCF0aGlzLnBvc3Rlcl8gJiYgdGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLnBvc3Rlcikge1xuICAgICAgdGhpcy5wb3N0ZXJfID0gdGhpcy50ZWNoXy5wb3N0ZXIoKSB8fCAnJztcblxuICAgICAgLy8gTGV0IGNvbXBvbmVudHMga25vdyB0aGUgcG9zdGVyIGhhcyBjaGFuZ2VkXG4gICAgICB0aGlzLnRyaWdnZXIoJ3Bvc3RlcmNoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB3aGV0aGVyIG9yIG5vdCB0aGUgY29udHJvbHMgYXJlIHNob3dpbmcuXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjY29udHJvbHNlbmFibGVkXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb2xdXG4gICAqICAgICAgICAtIHRydWUgdG8gdHVybiBjb250cm9scyBvblxuICAgKiAgICAgICAgLSBmYWxzZSB0byB0dXJuIGNvbnRyb2xzIG9mZlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIGNvbnRyb2xzIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY29udHJvbHMgPSBmdW5jdGlvbiBjb250cm9scyhib29sKSB7XG4gICAgaWYgKGJvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5jb250cm9sc187XG4gICAgfVxuXG4gICAgYm9vbCA9ICEhYm9vbDtcblxuICAgIC8vIERvbid0IHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgdW5sZXNzIGl0IGFjdHVhbGx5IGNoYW5nZWRcbiAgICBpZiAodGhpcy5jb250cm9sc18gPT09IGJvb2wpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xzXyA9IGJvb2w7XG5cbiAgICBpZiAodGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKCkpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRDb250cm9scycsIGJvb2wpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbnRyb2xzXykge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWNvbnRyb2xzLWRpc2FibGVkJyk7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZW5hYmxlZCcpO1xuICAgICAgLyoqXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI2NvbnRyb2xzZW5hYmxlZFxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2NvbnRyb2xzZW5hYmxlZCcpO1xuICAgICAgaWYgKCF0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHMoKSkge1xuICAgICAgICB0aGlzLmFkZFRlY2hDb250cm9sc0xpc3RlbmVyc18oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWNvbnRyb2xzLWVuYWJsZWQnKTtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1jb250cm9scy1kaXNhYmxlZCcpO1xuICAgICAgLyoqXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI2NvbnRyb2xzZGlzYWJsZWRcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdjb250cm9sc2Rpc2FibGVkJyk7XG4gICAgICBpZiAoIXRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVG9nZ2xlIG5hdGl2ZSBjb250cm9scyBvbi9vZmYuIE5hdGl2ZSBjb250cm9scyBhcmUgdGhlIGNvbnRyb2xzIGJ1aWx0IGludG9cbiAgICogZGV2aWNlcyAoZS5nLiBkZWZhdWx0IGlQaG9uZSBjb250cm9scyksIEZsYXNoLCBvciBvdGhlciB0ZWNoc1xuICAgKiAoZS5nLiBWaW1lbyBDb250cm9scylcbiAgICogKipUaGlzIHNob3VsZCBvbmx5IGJlIHNldCBieSB0aGUgY3VycmVudCB0ZWNoLCBiZWNhdXNlIG9ubHkgdGhlIHRlY2gga25vd3NcbiAgICogaWYgaXQgY2FuIHN1cHBvcnQgbmF0aXZlIGNvbnRyb2xzKipcbiAgICpcbiAgICogQGZpcmVzIFBsYXllciN1c2luZ25hdGl2ZWNvbnRyb2xzXG4gICAqIEBmaXJlcyBQbGF5ZXIjdXNpbmdjdXN0b21jb250cm9sc1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib29sXVxuICAgKiAgICAgICAgLSB0cnVlIHRvIHR1cm4gbmF0aXZlIGNvbnRyb2xzIG9uXG4gICAqICAgICAgICAtIGZhbHNlIHRvIHR1cm4gbmF0aXZlIGNvbnRyb2xzIG9mZlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIG5hdGl2ZSBjb250cm9scyB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnVzaW5nTmF0aXZlQ29udHJvbHMgPSBmdW5jdGlvbiB1c2luZ05hdGl2ZUNvbnRyb2xzKGJvb2wpIHtcbiAgICBpZiAoYm9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHNfO1xuICAgIH1cblxuICAgIGJvb2wgPSAhIWJvb2w7XG5cbiAgICAvLyBEb24ndCB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IHVubGVzcyBpdCBhY3R1YWxseSBjaGFuZ2VkXG4gICAgaWYgKHRoaXMudXNpbmdOYXRpdmVDb250cm9sc18gPT09IGJvb2wpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHNfID0gYm9vbDtcblxuICAgIGlmICh0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHNfKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtdXNpbmctbmF0aXZlLWNvbnRyb2xzJyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogcGxheWVyIGlzIHVzaW5nIHRoZSBuYXRpdmUgZGV2aWNlIGNvbnRyb2xzXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IFBsYXllciN1c2luZ25hdGl2ZWNvbnRyb2xzXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcigndXNpbmduYXRpdmVjb250cm9scycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtdXNpbmctbmF0aXZlLWNvbnRyb2xzJyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogcGxheWVyIGlzIHVzaW5nIHRoZSBjdXN0b20gSFRNTCBjb250cm9sc1xuICAgICAgICpcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjdXNpbmdjdXN0b21jb250cm9sc1xuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ3VzaW5nY3VzdG9tY29udHJvbHMnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBvciBnZXQgdGhlIGN1cnJlbnQgTWVkaWFFcnJvclxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2Vycm9yXG4gICAqXG4gICAqIEBwYXJhbSAge01lZGlhRXJyb3J8c3RyaW5nfG51bWJlcn0gW2Vycl1cbiAgICogICAgICAgICBBIE1lZGlhRXJyb3Igb3IgYSBzdHJpbmcvbnVtYmVyIHRvIGJlIHR1cm5lZFxuICAgKiAgICAgICAgIGludG8gYSBNZWRpYUVycm9yXG4gICAqXG4gICAqIEByZXR1cm4ge01lZGlhRXJyb3J8bnVsbH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBNZWRpYUVycm9yIHdoZW4gZ2V0dGluZyAob3IgbnVsbClcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGVyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcnJvcl8gfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZXN0b3JpbmcgdG8gZGVmYXVsdFxuICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZXJyb3JfID0gZXJyO1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVycm9yJyk7XG4gICAgICBpZiAodGhpcy5lcnJvckRpc3BsYXkpIHtcbiAgICAgICAgdGhpcy5lcnJvckRpc3BsYXkuY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVycm9yXyA9IG5ldyBNZWRpYUVycm9yKGVycik7XG5cbiAgICAvLyBhZGQgdGhlIHZqcy1lcnJvciBjbGFzc25hbWUgdG8gdGhlIHBsYXllclxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1lcnJvcicpO1xuXG4gICAgLy8gbG9nIHRoZSBuYW1lIG9mIHRoZSBlcnJvciB0eXBlIGFuZCBhbnkgbWVzc2FnZVxuICAgIC8vIGllOCBqdXN0IGxvZ3MgXCJbb2JqZWN0IG9iamVjdF1cIiBpZiB5b3UganVzdCBsb2cgdGhlIGVycm9yIG9iamVjdFxuICAgIGxvZyQxLmVycm9yKCcoQ09ERTonICsgdGhpcy5lcnJvcl8uY29kZSArICcgJyArIE1lZGlhRXJyb3IuZXJyb3JUeXBlc1t0aGlzLmVycm9yXy5jb2RlXSArICcpJywgdGhpcy5lcnJvcl8ubWVzc2FnZSwgdGhpcy5lcnJvcl8pO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFBsYXllciNlcnJvclxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJyk7XG5cbiAgICByZXR1cm47XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcG9ydCB1c2VyIGFjdGl2aXR5XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgICAgICAgRXZlbnQgb2JqZWN0XG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZXBvcnRVc2VyQWN0aXZpdHkgPSBmdW5jdGlvbiByZXBvcnRVc2VyQWN0aXZpdHkoZXZlbnQpIHtcbiAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IGlmIHVzZXIgaXMgYWN0aXZlXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjdXNlcmFjdGl2ZVxuICAgKiBAZmlyZXMgUGxheWVyI3VzZXJpbmFjdGl2ZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib29sXVxuICAgKiAgICAgICAgLSB0cnVlIGlmIHRoZSB1c2VyIGlzIGFjdGl2ZVxuICAgKiAgICAgICAgLSBmYWxzZSBpZiB0aGUgdXNlciBpcyBpbmFjdGl2ZVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIHVzZXJBY3RpdmUgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS51c2VyQWN0aXZlID0gZnVuY3Rpb24gdXNlckFjdGl2ZShib29sKSB7XG4gICAgaWYgKGJvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMudXNlckFjdGl2ZV87XG4gICAgfVxuXG4gICAgYm9vbCA9ICEhYm9vbDtcblxuICAgIGlmIChib29sID09PSB0aGlzLnVzZXJBY3RpdmVfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy51c2VyQWN0aXZlXyA9IGJvb2w7XG5cbiAgICBpZiAodGhpcy51c2VyQWN0aXZlXykge1xuICAgICAgdGhpcy51c2VyQWN0aXZpdHlfID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy11c2VyLWluYWN0aXZlJyk7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtdXNlci1hY3RpdmUnKTtcbiAgICAgIC8qKlxuICAgICAgICogQGV2ZW50IFBsYXllciN1c2VyYWN0aXZlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcigndXNlcmFjdGl2ZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENocm9tZS9TYWZhcmkvSUUgaGF2ZSBidWdzIHdoZXJlIHdoZW4geW91IGNoYW5nZSB0aGUgY3Vyc29yIGl0IGNhblxuICAgIC8vIHRyaWdnZXIgYSBtb3VzZW1vdmUgZXZlbnQuIFRoaXMgY2F1c2VzIGFuIGlzc3VlIHdoZW4geW91J3JlIGhpZGluZ1xuICAgIC8vIHRoZSBjdXJzb3Igd2hlbiB0aGUgdXNlciBpcyBpbmFjdGl2ZSwgYW5kIGEgbW91c2Vtb3ZlIHNpZ25hbHMgdXNlclxuICAgIC8vIGFjdGl2aXR5LiBNYWtpbmcgaXQgaW1wb3NzaWJsZSB0byBnbyBpbnRvIGluYWN0aXZlIG1vZGUuIFNwZWNpZmljYWxseVxuICAgIC8vIHRoaXMgaGFwcGVucyBpbiBmdWxsc2NyZWVuIHdoZW4gd2UgcmVhbGx5IG5lZWQgdG8gaGlkZSB0aGUgY3Vyc29yLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGlzIGdldHMgcmVzb2x2ZWQgaW4gQUxMIGJyb3dzZXJzIGl0IGNhbiBiZSByZW1vdmVkXG4gICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwMzA0MVxuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICB0aGlzLnRlY2hfLm9uZSgnbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy51c2VyQWN0aXZpdHlfID0gZmFsc2U7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXVzZXItYWN0aXZlJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXVzZXItaW5hY3RpdmUnKTtcbiAgICAvKipcbiAgICAgKiBAZXZlbnQgUGxheWVyI3VzZXJpbmFjdGl2ZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3VzZXJpbmFjdGl2ZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0ZW4gZm9yIHVzZXIgYWN0aXZpdHkgYmFzZWQgb24gdGltZW91dCB2YWx1ZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubGlzdGVuRm9yVXNlckFjdGl2aXR5XyA9IGZ1bmN0aW9uIGxpc3RlbkZvclVzZXJBY3Rpdml0eV8oKSB7XG4gICAgdmFyIG1vdXNlSW5Qcm9ncmVzcyA9IHZvaWQgMDtcbiAgICB2YXIgbGFzdE1vdmVYID0gdm9pZCAwO1xuICAgIHZhciBsYXN0TW92ZVkgPSB2b2lkIDA7XG4gICAgdmFyIGhhbmRsZUFjdGl2aXR5ID0gYmluZCh0aGlzLCB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSk7XG5cbiAgICB2YXIgaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGUpIHtcbiAgICAgIC8vICMxMDY4IC0gUHJldmVudCBtb3VzZW1vdmUgc3BhbW1pbmdcbiAgICAgIC8vIENocm9tZSBCdWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNjY5NzBcbiAgICAgIGlmIChlLnNjcmVlblggIT09IGxhc3RNb3ZlWCB8fCBlLnNjcmVlblkgIT09IGxhc3RNb3ZlWSkge1xuICAgICAgICBsYXN0TW92ZVggPSBlLnNjcmVlblg7XG4gICAgICAgIGxhc3RNb3ZlWSA9IGUuc2NyZWVuWTtcbiAgICAgICAgaGFuZGxlQWN0aXZpdHkoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bigpIHtcbiAgICAgIGhhbmRsZUFjdGl2aXR5KCk7XG4gICAgICAvLyBGb3IgYXMgbG9uZyBhcyB0aGUgdGhleSBhcmUgdG91Y2hpbmcgdGhlIGRldmljZSBvciBoYXZlIHRoZWlyIG1vdXNlIGRvd24sXG4gICAgICAvLyB3ZSBjb25zaWRlciB0aGVtIGFjdGl2ZSBldmVuIGlmIHRoZXkncmUgbm90IG1vdmluZyB0aGVpciBmaW5nZXIgb3IgbW91c2UuXG4gICAgICAvLyBTbyB3ZSB3YW50IHRvIGNvbnRpbnVlIHRvIHVwZGF0ZSB0aGF0IHRoZXkgYXJlIGFjdGl2ZVxuICAgICAgdGhpcy5jbGVhckludGVydmFsKG1vdXNlSW5Qcm9ncmVzcyk7XG4gICAgICAvLyBTZXR0aW5nIHVzZXJBY3Rpdml0eT10cnVlIG5vdyBhbmQgc2V0dGluZyB0aGUgaW50ZXJ2YWwgdG8gdGhlIHNhbWUgdGltZVxuICAgICAgLy8gYXMgdGhlIGFjdGl2aXR5Q2hlY2sgaW50ZXJ2YWwgKDI1MCkgc2hvdWxkIGVuc3VyZSB3ZSBuZXZlciBtaXNzIHRoZVxuICAgICAgLy8gbmV4dCBhY3Rpdml0eUNoZWNrXG4gICAgICBtb3VzZUluUHJvZ3Jlc3MgPSB0aGlzLnNldEludGVydmFsKGhhbmRsZUFjdGl2aXR5LCAyNTApO1xuICAgIH07XG5cbiAgICB2YXIgaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoZXZlbnQpIHtcbiAgICAgIGhhbmRsZUFjdGl2aXR5KCk7XG4gICAgICAvLyBTdG9wIHRoZSBpbnRlcnZhbCB0aGF0IG1haW50YWlucyBhY3Rpdml0eSBpZiB0aGUgbW91c2UvdG91Y2ggaXMgZG93blxuICAgICAgdGhpcy5jbGVhckludGVydmFsKG1vdXNlSW5Qcm9ncmVzcyk7XG4gICAgfTtcblxuICAgIC8vIEFueSBtb3VzZSBtb3ZlbWVudCB3aWxsIGJlIGNvbnNpZGVyZWQgdXNlciBhY3Rpdml0eVxuICAgIHRoaXMub24oJ21vdXNlZG93bicsIGhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vbignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKCdtb3VzZXVwJywgaGFuZGxlTW91c2VVcCk7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIGtleWJvYXJkIG5hdmlnYXRpb25cbiAgICAvLyBTaG91bGRuJ3QgbmVlZCB0byB1c2UgaW5Qcm9ncmVzcyBpbnRlcnZhbCBiZWNhdXNlIG9mIGtleSByZXBlYXRcbiAgICB0aGlzLm9uKCdrZXlkb3duJywgaGFuZGxlQWN0aXZpdHkpO1xuICAgIHRoaXMub24oJ2tleXVwJywgaGFuZGxlQWN0aXZpdHkpO1xuXG4gICAgLy8gUnVuIGFuIGludGVydmFsIGV2ZXJ5IDI1MCBtaWxsaXNlY29uZHMgaW5zdGVhZCBvZiBzdHVmZmluZyBldmVyeXRoaW5nIGludG9cbiAgICAvLyB0aGUgbW91c2Vtb3ZlL3RvdWNobW92ZSBmdW5jdGlvbiBpdHNlbGYsIHRvIHByZXZlbnQgcGVyZm9ybWFuY2UgZGVncmFkYXRpb24uXG4gICAgLy8gYHRoaXMucmVwb3J0VXNlckFjdGl2aXR5YCBzaW1wbHkgc2V0cyB0aGlzLnVzZXJBY3Rpdml0eV8gdG8gdHJ1ZSwgd2hpY2hcbiAgICAvLyB0aGVuIGdldHMgcGlja2VkIHVwIGJ5IHRoaXMgbG9vcFxuICAgIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9sZWFybmluZy1mcm9tLXR3aXR0ZXIvXG4gICAgdmFyIGluYWN0aXZpdHlUaW1lb3V0ID0gdm9pZCAwO1xuXG4gICAgdGhpcy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDaGVjayB0byBzZWUgaWYgbW91c2UvdG91Y2ggYWN0aXZpdHkgaGFzIGhhcHBlbmVkXG4gICAgICBpZiAoIXRoaXMudXNlckFjdGl2aXR5Xykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IHRoZSBhY3Rpdml0eSB0cmFja2VyXG4gICAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSBmYWxzZTtcblxuICAgICAgLy8gSWYgdGhlIHVzZXIgc3RhdGUgd2FzIGluYWN0aXZlLCBzZXQgdGhlIHN0YXRlIHRvIGFjdGl2ZVxuICAgICAgdGhpcy51c2VyQWN0aXZlKHRydWUpO1xuXG4gICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgaW5hY3Rpdml0eSB0aW1lb3V0IHRvIHN0YXJ0IHRoZSB0aW1lciBvdmVyXG4gICAgICB0aGlzLmNsZWFyVGltZW91dChpbmFjdGl2aXR5VGltZW91dCk7XG5cbiAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy5vcHRpb25zXy5pbmFjdGl2aXR5VGltZW91dDtcblxuICAgICAgaWYgKHRpbWVvdXQgPD0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEluIDx0aW1lb3V0PiBtaWxsaXNlY29uZHMsIGlmIG5vIG1vcmUgYWN0aXZpdHkgaGFzIG9jY3VycmVkIHRoZVxuICAgICAgLy8gdXNlciB3aWxsIGJlIGNvbnNpZGVyZWQgaW5hY3RpdmVcbiAgICAgIGluYWN0aXZpdHlUaW1lb3V0ID0gdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IHRoZSBjYXNlIHdoZXJlIHRoZSBpbmFjdGl2aXR5VGltZW91dCBjYW4gdHJpZ2dlciBqdXN0XG4gICAgICAgIC8vIGJlZm9yZSB0aGUgbmV4dCB1c2VyIGFjdGl2aXR5IGlzIHBpY2tlZCB1cCBieSB0aGUgYWN0aXZpdHkgY2hlY2sgbG9vcFxuICAgICAgICAvLyBjYXVzaW5nIGEgZmxpY2tlclxuICAgICAgICBpZiAoIXRoaXMudXNlckFjdGl2aXR5Xykge1xuICAgICAgICAgIHRoaXMudXNlckFjdGl2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH0sIDI1MCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBwbGF5YmFjayByYXRlLiBBIHBsYXliYWNrIHJhdGUgb2ZcbiAgICogMS4wIHJlcHJlc2VudHMgbm9ybWFsIHNwZWVkIGFuZCAwLjUgd291bGQgaW5kaWNhdGUgaGFsZi1zcGVlZFxuICAgKiBwbGF5YmFjaywgZm9yIGluc3RhbmNlLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tbWVkaWEtcGxheWJhY2tyYXRlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmF0ZV1cbiAgICogICAgICAgTmV3IHBsYXliYWNrIHJhdGUgdG8gc2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZSB3aGVuIGdldHRpbmcgb3IgMS4wXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wbGF5YmFja1JhdGUgPSBmdW5jdGlvbiBwbGF5YmFja1JhdGUocmF0ZSkge1xuICAgIGlmIChyYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRQbGF5YmFja1JhdGUnLCByYXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLmZlYXR1cmVzUGxheWJhY2tSYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygncGxheWJhY2tSYXRlJyk7XG4gICAgfVxuICAgIHJldHVybiAxLjA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBkZWZhdWx0IHBsYXliYWNrIHJhdGUuIEEgZGVmYXVsdCBwbGF5YmFjayByYXRlIG9mXG4gICAqIDEuMCByZXByZXNlbnRzIG5vcm1hbCBzcGVlZCBhbmQgMC41IHdvdWxkIGluZGljYXRlIGhhbGYtc3BlZWQgcGxheWJhY2ssIGZvciBpbnN0YW5jZS5cbiAgICogZGVmYXVsdFBsYXliYWNrUmF0ZSB3aWxsIG9ubHkgcmVwcmVzZW50IHdoYXQgdGhlIGludGlhbCBwbGF5YmFja1JhdGUgb2YgYSB2aWRlbyB3YXMsIG5vdFxuICAgKiBub3QgdGhlIGN1cnJlbnQgcGxheWJhY2tSYXRlLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tbWVkaWEtZGVmYXVsdHBsYXliYWNrcmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JhdGVdXG4gICAqICAgICAgIE5ldyBkZWZhdWx0IHBsYXliYWNrIHJhdGUgdG8gc2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8UGxheWVyfVxuICAgKiAgICAgICAgIC0gVGhlIGRlZmF1bHQgcGxheWJhY2sgcmF0ZSB3aGVuIGdldHRpbmcgb3IgMS4wXG4gICAqICAgICAgICAgLSB0aGUgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZGVmYXVsdFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uIGRlZmF1bHRQbGF5YmFja1JhdGUocmF0ZSkge1xuICAgIGlmIChyYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hDYWxsXygnc2V0RGVmYXVsdFBsYXliYWNrUmF0ZScsIHJhdGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8uZmVhdHVyZXNQbGF5YmFja1JhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdkZWZhdWx0UGxheWJhY2tSYXRlJyk7XG4gICAgfVxuICAgIHJldHVybiAxLjA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgYXVkaW8gZmxhZ1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJvb2xcbiAgICogICAgICAgIC0gdHJ1ZSBzaWduYWxzIHRoYXQgdGhpcyBpcyBhbiBhdWRpbyBwbGF5ZXJcbiAgICogICAgICAgIC0gZmFsc2Ugc2lnbmFscyB0aGF0IHRoaXMgaXMgbm90IGFuIGF1ZGlvIHBsYXllclxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIGlzQXVkaW8gd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5pc0F1ZGlvID0gZnVuY3Rpb24gaXNBdWRpbyhib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pc0F1ZGlvXyA9ICEhYm9vbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gISF0aGlzLmlzQXVkaW9fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBtZXRob2QgZm9yIGFkZGluZyBhIHtAbGluayBUZXh0VHJhY2t9IHRvIG91clxuICAgKiB7QGxpbmsgVGV4dFRyYWNrTGlzdH0uXG4gICAqXG4gICAqIEluIGFkZGl0aW9uIHRvIHRoZSBXM0Mgc2V0dGluZ3Mgd2UgYWxsb3cgYWRkaW5nIGFkZGl0aW9uYWwgaW5mbyB0aHJvdWdoIG9wdGlvbnMuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWFkZHRleHR0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2tpbmRdXG4gICAqICAgICAgICB0aGUga2luZCBvZiBUZXh0VHJhY2sgeW91IGFyZSBhZGRpbmdcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYWJlbF1cbiAgICogICAgICAgIHRoZSBsYWJlbCB0byBnaXZlIHRoZSBUZXh0VHJhY2sgbGFiZWxcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV1cbiAgICogICAgICAgIHRoZSBsYW5ndWFnZSB0byBzZXQgb24gdGhlIFRleHRUcmFja1xuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2t8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIHRoZSBUZXh0VHJhY2sgdGhhdCB3YXMgYWRkZWQgb3IgdW5kZWZpbmVkXG4gICAqICAgICAgICAgaWYgdGhlcmUgaXMgbm8gdGVjaFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYWRkVGV4dFRyYWNrID0gZnVuY3Rpb24gYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5ndWFnZSkge1xuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoXy5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrfSBhbmQgYW4ge0BsaW5rIEhUTUxUcmFja0VsZW1lbnR9LiBJdCB3aWxsXG4gICAqIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50IHdoZW5ldmVyIHRoZSBzb3VyY2UgY2hhbmdlcywgdW5sZXNzXG4gICAqIG1hbnVhbENsZWFudXAgaXMgc2V0IHRvIGZhbHNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgT3B0aW9ucyB0byBwYXNzIHRvIHtAbGluayBIVE1MVHJhY2tFbGVtZW50fSBkdXJpbmcgY3JlYXRpb24uIFNlZVxuICAgKiAgICAgICAge0BsaW5rIEhUTUxUcmFja0VsZW1lbnR9IGZvciBvYmplY3QgcHJvcGVydGllcyB0aGF0IHlvdSBzaG91bGQgdXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttYW51YWxDbGVhbnVwPXRydWVdIGlmIHNldCB0byBmYWxzZSwgdGhlIFRleHRUcmFjayB3aWxsIGJlXG4gICAqXG4gICAqIEByZXR1cm4ge0h0bWxUcmFja0VsZW1lbnR9XG4gICAqICAgICAgICAgdGhlIEhUTUxUcmFja0VsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZCBhbmQgYWRkZWRcbiAgICogICAgICAgICB0byB0aGUgSHRtbFRyYWNrRWxlbWVudExpc3QgYW5kIHRoZSByZW1vdGVcbiAgICogICAgICAgICBUZXh0VHJhY2tMaXN0XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBcIm1hbnVhbENsZWFudXBcIiBwYXJhbWV0ZXIgd2lsbCBkZWZhdWx0XG4gICAqICAgICAgICAgICAgIHRvIFwiZmFsc2VcIiBpbiB1cGNvbWluZyB2ZXJzaW9ucyBvZiBWaWRlby5qc1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYWRkUmVtb3RlVGV4dFRyYWNrID0gZnVuY3Rpb24gYWRkUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMsIG1hbnVhbENsZWFudXApIHtcbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaF8uYWRkUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMsIG1hbnVhbENsZWFudXApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgcmVtb3RlIHtAbGluayBUZXh0VHJhY2t9IGZyb20gdGhlIHJlc3BlY3RpdmVcbiAgICoge0BsaW5rIFRleHRUcmFja0xpc3R9IGFuZCB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudExpc3R9LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhY2tcbiAgICogICAgICAgIFJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrfSB0byByZW1vdmVcbiAgICpcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIGRvZXMgbm90IHJldHVybiBhbnl0aGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucmVtb3ZlUmVtb3RlVGV4dFRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlUmVtb3RlVGV4dFRyYWNrKCkge1xuICAgIHZhciBfcmVmMyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIF9yZWYzJHRyYWNrID0gX3JlZjMudHJhY2ssXG4gICAgICAgIHRyYWNrID0gX3JlZjMkdHJhY2sgPT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9yZWYzJHRyYWNrO1xuXG4gICAgLy8gZGVzdHJ1Y3R1cmUgdGhlIGlucHV0IGludG8gYW4gb2JqZWN0IHdpdGggYSB0cmFjayBhcmd1bWVudCwgZGVmYXVsdGluZyB0byBhcmd1bWVudHNbMF1cbiAgICAvLyBkZWZhdWx0IHRoZSB3aG9sZSBhcmd1bWVudCB0byBhbiBlbXB0eSBvYmplY3QgaWYgbm90aGluZyB3YXMgcGFzc2VkIGluXG5cbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaF8ucmVtb3ZlUmVtb3RlVGV4dFRyYWNrKHRyYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYXZhaWxhYmxlIG1lZGlhIHBsYXliYWNrIHF1YWxpdHkgbWV0cmljcyBhcyBzcGVjaWZpZWQgYnkgdGhlIFczQydzIE1lZGlhXG4gICAqIFBsYXliYWNrIFF1YWxpdHkgQVBJLlxuICAgKlxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3dpY2cuZ2l0aHViLmlvL21lZGlhLXBsYXliYWNrLXF1YWxpdHl9XG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgQW4gb2JqZWN0IHdpdGggc3VwcG9ydGVkIG1lZGlhIHBsYXliYWNrIHF1YWxpdHkgbWV0cmljcyBvciB1bmRlZmluZWQgaWYgdGhlcmVcbiAgICogICAgICAgICBpcyBubyB0ZWNoIG9yIHRoZSB0ZWNoIGRvZXMgbm90IHN1cHBvcnQgaXQuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9IGZ1bmN0aW9uIGdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdnZXRWaWRlb1BsYXliYWNrUXVhbGl0eScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdmlkZW8gd2lkdGhcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIGN1cnJlbnQgdmlkZW8gd2lkdGhcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnZpZGVvV2lkdGggPSBmdW5jdGlvbiB2aWRlb1dpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8udmlkZW9XaWR0aCAmJiB0aGlzLnRlY2hfLnZpZGVvV2lkdGgoKSB8fCAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdmlkZW8gaGVpZ2h0XG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBjdXJyZW50IHZpZGVvIGhlaWdodFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudmlkZW9IZWlnaHQgPSBmdW5jdGlvbiB2aWRlb0hlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLnZpZGVvSGVpZ2h0ICYmIHRoaXMudGVjaF8udmlkZW9IZWlnaHQoKSB8fCAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcGxheWVyJ3MgbGFuZ3VhZ2UgY29kZVxuICAgKiBOT1RFOiBUaGUgbGFuZ3VhZ2Ugc2hvdWxkIGJlIHNldCBpbiB0aGUgcGxheWVyIG9wdGlvbnMgaWYgeW91IHdhbnQgdGhlXG4gICAqIHRoZSBjb250cm9scyB0byBiZSBidWlsdCB3aXRoIGEgc3BlY2lmaWMgbGFuZ3VhZ2UuIENoYW5naW5nIHRoZSBsYW51Z2FnZVxuICAgKiBsYXRlciB3aWxsIG5vdCB1cGRhdGUgY29udHJvbHMgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXVxuICAgKiAgICAgICAgdGhlIGxhbmd1YWdlIGNvZGUgdG8gc2V0IHRoZSBwbGF5ZXIgdG9cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGxhbmd1YWdlIGNvZGUgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sYW5ndWFnZSA9IGZ1bmN0aW9uIGxhbmd1YWdlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYW5ndWFnZV87XG4gICAgfVxuXG4gICAgdGhpcy5sYW5ndWFnZV8gPSBTdHJpbmcoY29kZSkudG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwbGF5ZXIncyBsYW5ndWFnZSBkaWN0aW9uYXJ5XG4gICAqIE1lcmdlIGV2ZXJ5IHRpbWUsIGJlY2F1c2UgYSBuZXdseSBhZGRlZCBwbHVnaW4gbWlnaHQgY2FsbCB2aWRlb2pzLmFkZExhbmd1YWdlKCkgYXQgYW55IHRpbWVcbiAgICogTGFuZ3VhZ2VzIHNwZWNpZmllZCBkaXJlY3RseSBpbiB0aGUgcGxheWVyIG9wdGlvbnMgaGF2ZSBwcmVjZWRlbmNlXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiAgICAgICAgIEFuIGFycmF5IG9mIG9mIHN1cHBvcnRlZCBsYW5ndWFnZXNcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmxhbmd1YWdlcyA9IGZ1bmN0aW9uIGxhbmd1YWdlcygpIHtcbiAgICByZXR1cm4gbWVyZ2VPcHRpb25zKFBsYXllci5wcm90b3R5cGUub3B0aW9uc18ubGFuZ3VhZ2VzLCB0aGlzLmxhbmd1YWdlc18pO1xuICB9O1xuXG4gIC8qKlxuICAgKiByZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3QgcmVwZXJlc2VudGluZyB0aGUgY3VycmVudCB0cmFja1xuICAgKiBpbmZvcm1hdGlvbi4gKipET0VTIG5vdCByZXR1cm4gaXQgYXMgSlNPTioqXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IG9mIHRyYWNrIGluZm9cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnNfKTtcbiAgICB2YXIgdHJhY2tzID0gb3B0aW9ucy50cmFja3M7XG5cbiAgICBvcHRpb25zLnRyYWNrcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgLy8gZGVlcCBtZXJnZSB0cmFja3MgYW5kIG51bGwgb3V0IHBsYXllciBzbyBubyBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICB0cmFjayA9IG1lcmdlT3B0aW9ucyh0cmFjayk7XG4gICAgICB0cmFjay5wbGF5ZXIgPSB1bmRlZmluZWQ7XG4gICAgICBvcHRpb25zLnRyYWNrc1tpXSA9IHRyYWNrO1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2ltcGxlIG1vZGFsIGRpYWxvZyAoYW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBNb2RhbERpYWxvZ31cbiAgICogY29tcG9uZW50KSB0aGF0IGltbWVkaWF0ZWx5IG92ZXJsYXlzIHRoZSBwbGF5ZXIgd2l0aCBhcmJpdHJhcnlcbiAgICogY29udGVudCBhbmQgcmVtb3ZlcyBpdHNlbGYgd2hlbiBjbG9zZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufEVsZW1lbnR8QXJyYXl8bnVsbH0gY29udGVudFxuICAgKiAgICAgICAgU2FtZSBhcyB7QGxpbmsgTW9kYWxEaWFsb2cjY29udGVudH0ncyBwYXJhbSBvZiB0aGUgc2FtZSBuYW1lLlxuICAgKiAgICAgICAgVGhlIG1vc3Qgc3RyYWlnaHQtZm9yd2FyZCB1c2FnZSBpcyB0byBwcm92aWRlIGEgc3RyaW5nIG9yIERPTVxuICAgKiAgICAgICAgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgRXh0cmEgb3B0aW9ucyB3aGljaCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUge0BsaW5rIE1vZGFsRGlhbG9nfS5cbiAgICpcbiAgICogQHJldHVybiB7TW9kYWxEaWFsb2d9XG4gICAqICAgICAgICAgdGhlIHtAbGluayBNb2RhbERpYWxvZ30gdGhhdCB3YXMgY3JlYXRlZFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY3JlYXRlTW9kYWwgPSBmdW5jdGlvbiBjcmVhdGVNb2RhbChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNvbnRlbnQgPSBjb250ZW50IHx8ICcnO1xuXG4gICAgdmFyIG1vZGFsID0gbmV3IE1vZGFsRGlhbG9nKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5hZGRDaGlsZChtb2RhbCk7XG4gICAgbW9kYWwub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczgucmVtb3ZlQ2hpbGQobW9kYWwpO1xuICAgIH0pO1xuXG4gICAgbW9kYWwub3BlbigpO1xuICAgIHJldHVybiBtb2RhbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0YWcgc2V0dGluZ3NcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YWdcbiAgICogICAgICAgIFRoZSBwbGF5ZXIgdGFnXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgb2YgdGhlIHNldHRpbmdzXG4gICAqICAgICAgICAgZm9yIGEgcGxheWVyIHRhZ1xuICAgKi9cblxuXG4gIFBsYXllci5nZXRUYWdTZXR0aW5ncyA9IGZ1bmN0aW9uIGdldFRhZ1NldHRpbmdzKHRhZykge1xuICAgIHZhciBiYXNlT3B0aW9ucyA9IHtcbiAgICAgIHNvdXJjZXM6IFtdLFxuICAgICAgdHJhY2tzOiBbXVxuICAgIH07XG5cbiAgICB2YXIgdGFnT3B0aW9ucyA9IGdldEF0dHJpYnV0ZXModGFnKTtcbiAgICB2YXIgZGF0YVNldHVwID0gdGFnT3B0aW9uc1snZGF0YS1zZXR1cCddO1xuXG4gICAgaWYgKGhhc0NsYXNzKHRhZywgJ3Zqcy1mbHVpZCcpKSB7XG4gICAgICB0YWdPcHRpb25zLmZsdWlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBkYXRhLXNldHVwIGF0dHIgZXhpc3RzLlxuICAgIGlmIChkYXRhU2V0dXAgIT09IG51bGwpIHtcbiAgICAgIC8vIFBhcnNlIG9wdGlvbnMgSlNPTlxuICAgICAgLy8gSWYgZW1wdHkgc3RyaW5nLCBtYWtlIGl0IGEgcGFyc2FibGUganNvbiBvYmplY3QuXG4gICAgICB2YXIgX3NhZmVQYXJzZVR1cGxlID0gc2FmZVBhcnNlVHVwbGUoZGF0YVNldHVwIHx8ICd7fScpLFxuICAgICAgICAgIGVyciA9IF9zYWZlUGFyc2VUdXBsZVswXSxcbiAgICAgICAgICBkYXRhID0gX3NhZmVQYXJzZVR1cGxlWzFdO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZyQxLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgICBhc3NpZ24odGFnT3B0aW9ucywgZGF0YSk7XG4gICAgfVxuXG4gICAgYXNzaWduKGJhc2VPcHRpb25zLCB0YWdPcHRpb25zKTtcblxuICAgIC8vIEdldCB0YWcgY2hpbGRyZW4gc2V0dGluZ3NcbiAgICBpZiAodGFnLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGFnLmNoaWxkTm9kZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAvLyBDaGFuZ2UgY2FzZSBuZWVkZWQ6IGh0dHA6Ly9lam9obi5vcmcvYmxvZy9ub2RlbmFtZS1jYXNlLXNlbnNpdGl2aXR5L1xuICAgICAgICB2YXIgY2hpbGROYW1lID0gY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnc291cmNlJykge1xuICAgICAgICAgIGJhc2VPcHRpb25zLnNvdXJjZXMucHVzaChnZXRBdHRyaWJ1dGVzKGNoaWxkKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGROYW1lID09PSAndHJhY2snKSB7XG4gICAgICAgICAgYmFzZU9wdGlvbnMudHJhY2tzLnB1c2goZ2V0QXR0cmlidXRlcyhjaGlsZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2VPcHRpb25zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2V0aGVyIG9yIG5vdCBmbGV4Ym94IGlzIHN1cHBvcnRlZFxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIC0gdHJ1ZSBpZiBmbGV4Ym94IGlzIHN1cHBvcnRlZFxuICAgKiAgICAgICAgIC0gZmFsc2UgaWYgZmxleGJveCBpcyBub3Qgc3VwcG9ydGVkXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5mbGV4Tm90U3VwcG9ydGVkXyA9IGZ1bmN0aW9uIGZsZXhOb3RTdXBwb3J0ZWRfKCkge1xuICAgIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpO1xuXG4gICAgLy8gTm90ZTogV2UgZG9uJ3QgYWN0dWFsbHkgdXNlIGZsZXhCYXNpcyAob3IgZmxleE9yZGVyKSwgYnV0IGl0J3Mgb25lIG9mIHRoZSBtb3JlXG4gICAgLy8gY29tbW9uIGZsZXggZmVhdHVyZXMgdGhhdCB3ZSBjYW4gcmVseSBvbiB3aGVuIGNoZWNraW5nIGZvciBmbGV4IHN1cHBvcnQuXG4gICAgcmV0dXJuICEoJ2ZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSB8fCAnd2Via2l0RmxleEJhc2lzJyBpbiBlbGVtLnN0eWxlIHx8ICdtb3pGbGV4QmFzaXMnIGluIGVsZW0uc3R5bGUgfHwgJ21zRmxleEJhc2lzJyBpbiBlbGVtLnN0eWxlIHx8XG4gICAgLy8gSUUxMC1zcGVjaWZpYyAoMjAxMiBmbGV4IHNwZWMpXG4gICAgJ21zRmxleE9yZGVyJyBpbiBlbGVtLnN0eWxlKTtcbiAgfTtcblxuICByZXR1cm4gUGxheWVyO1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIEdldCB0aGUge0BsaW5rIFZpZGVvVHJhY2tMaXN0fVxuICogQGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3ZpZGVvdHJhY2tsaXN0XG4gKlxuICogQHJldHVybiB7VmlkZW9UcmFja0xpc3R9XG4gKiAgICAgICAgIHRoZSBjdXJyZW50IHZpZGVvIHRyYWNrIGxpc3RcbiAqXG4gKiBAbWV0aG9kIFBsYXllci5wcm90b3R5cGUudmlkZW9UcmFja3NcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fVxuICogQGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2F1ZGlvdHJhY2tsaXN0XG4gKlxuICogQHJldHVybiB7QXVkaW9UcmFja0xpc3R9XG4gKiAgICAgICAgIHRoZSBjdXJyZW50IGF1ZGlvIHRyYWNrIGxpc3RcbiAqXG4gKiBAbWV0aG9kIFBsYXllci5wcm90b3R5cGUuYXVkaW9UcmFja3NcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUge0BsaW5rIFRleHRUcmFja0xpc3R9XG4gKlxuICogQGxpbmsgaHR0cDovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXRleHR0cmFja3NcbiAqXG4gKiBAcmV0dXJuIHtUZXh0VHJhY2tMaXN0fVxuICogICAgICAgICB0aGUgY3VycmVudCB0ZXh0IHRyYWNrIGxpc3RcbiAqXG4gKiBAbWV0aG9kIFBsYXllci5wcm90b3R5cGUudGV4dFRyYWNrc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSByZW1vdGUge0BsaW5rIFRleHRUcmFja0xpc3R9XG4gKlxuICogQHJldHVybiB7VGV4dFRyYWNrTGlzdH1cbiAqICAgICAgICAgVGhlIGN1cnJlbnQgcmVtb3RlIHRleHQgdHJhY2sgbGlzdFxuICpcbiAqIEBtZXRob2QgUGxheWVyLnByb3RvdHlwZS5yZW1vdGVUZXh0VHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHJlbW90ZSB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudExpc3R9IHRyYWNrcy5cbiAqXG4gKiBAcmV0dXJuIHtIdG1sVHJhY2tFbGVtZW50TGlzdH1cbiAqICAgICAgICAgVGhlIGN1cnJlbnQgcmVtb3RlIHRleHQgdHJhY2sgZWxlbWVudCBsaXN0XG4gKlxuICogQG1ldGhvZCBQbGF5ZXIucHJvdG90eXBlLnJlbW90ZVRleHRUcmFja0Vsc1xuICovXG5cbkFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XG4gIHZhciBwcm9wcyA9IEFMTFtuYW1lJCQxXTtcblxuICBQbGF5ZXIucHJvdG90eXBlW3Byb3BzLmdldHRlck5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoX1twcm9wcy5nZXR0ZXJOYW1lXSgpO1xuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkVGVjaF8sIHdlIGNyZWF0ZSB7dmlkZW8sYXVkaW8sdGV4dH1UcmFja3NfXG4gICAgLy8gdGhlc2Ugd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHRlY2ggZHVyaW5nIGxvYWRpbmdcbiAgICB0aGlzW3Byb3BzLnByaXZhdGVOYW1lXSA9IHRoaXNbcHJvcHMucHJpdmF0ZU5hbWVdIHx8IG5ldyBwcm9wcy5MaXN0Q2xhc3MoKTtcbiAgICByZXR1cm4gdGhpc1twcm9wcy5wcml2YXRlTmFtZV07XG4gIH07XG59KTtcblxuLyoqXG4gKiBHbG9iYWwgcGxheWVyIGxpc3RcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5QbGF5ZXIucGxheWVycyA9IHt9O1xuXG52YXIgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcjtcblxuLypcbiAqIFBsYXllciBpbnN0YW5jZSBvcHRpb25zLCBzdXJmYWNlZCB1c2luZyBvcHRpb25zXG4gKiBvcHRpb25zID0gUGxheWVyLnByb3RvdHlwZS5vcHRpb25zX1xuICogTWFrZSBjaGFuZ2VzIGluIG9wdGlvbnMsIG5vdCBoZXJlLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICAvLyBEZWZhdWx0IG9yZGVyIG9mIGZhbGxiYWNrIHRlY2hub2xvZ3lcbiAgdGVjaE9yZGVyOiBUZWNoLmRlZmF1bHRUZWNoT3JkZXJfLFxuXG4gIGh0bWw1OiB7fSxcbiAgZmxhc2g6IHt9LFxuXG4gIC8vIGRlZmF1bHQgaW5hY3Rpdml0eSB0aW1lb3V0XG4gIGluYWN0aXZpdHlUaW1lb3V0OiAyMDAwLFxuXG4gIC8vIGRlZmF1bHQgcGxheWJhY2sgcmF0ZXNcbiAgcGxheWJhY2tSYXRlczogW10sXG4gIC8vIEFkZCBwbGF5YmFjayByYXRlIHNlbGVjdGlvbiBieSBhZGRpbmcgcmF0ZXNcbiAgLy8gJ3BsYXliYWNrUmF0ZXMnOiBbMC41LCAxLCAxLjUsIDJdLFxuXG4gIC8vIEluY2x1ZGVkIGNvbnRyb2wgc2V0c1xuICBjaGlsZHJlbjogWydtZWRpYUxvYWRlcicsICdwb3N0ZXJJbWFnZScsICd0ZXh0VHJhY2tEaXNwbGF5JywgJ2xvYWRpbmdTcGlubmVyJywgJ2JpZ1BsYXlCdXR0b24nLCAnY29udHJvbEJhcicsICdlcnJvckRpc3BsYXknLCAndGV4dFRyYWNrU2V0dGluZ3MnXSxcblxuICBsYW5ndWFnZTogbmF2aWdhdG9yICYmIChuYXZpZ2F0b3IubGFuZ3VhZ2VzICYmIG5hdmlnYXRvci5sYW5ndWFnZXNbMF0gfHwgbmF2aWdhdG9yLnVzZXJMYW5ndWFnZSB8fCBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8ICdlbicsXG5cbiAgLy8gbG9jYWxlcyBhbmQgdGhlaXIgbGFuZ3VhZ2UgdHJhbnNsYXRpb25zXG4gIGxhbmd1YWdlczoge30sXG5cbiAgLy8gRGVmYXVsdCBtZXNzYWdlIHRvIHNob3cgd2hlbiBhIHZpZGVvIGNhbm5vdCBiZSBwbGF5ZWQuXG4gIG5vdFN1cHBvcnRlZE1lc3NhZ2U6ICdObyBjb21wYXRpYmxlIHNvdXJjZSB3YXMgZm91bmQgZm9yIHRoaXMgbWVkaWEuJ1xufTtcblxuW1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwbGF5ZXIgaXMgaW4gdGhlIFwiZW5kZWRcIiBzdGF0ZS5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwbGF5ZXIgaXMgaW4gdGhlIGVuZGVkIHN0YXRlLCBmYWxzZSBpZiBub3QuXG4gKiBAbWV0aG9kIFBsYXllciNlbmRlZFxuICovXG4nZW5kZWQnLFxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwbGF5ZXIgaXMgaW4gdGhlIFwic2Vla2luZ1wiIHN0YXRlLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBsYXllciBpcyBpbiB0aGUgc2Vla2luZyBzdGF0ZSwgZmFsc2UgaWYgbm90LlxuICogQG1ldGhvZCBQbGF5ZXIjc2Vla2luZ1xuICovXG4nc2Vla2luZycsXG4vKipcbiAqIFJldHVybnMgdGhlIFRpbWVSYW5nZXMgb2YgdGhlIG1lZGlhIHRoYXQgYXJlIGN1cnJlbnRseSBhdmFpbGFibGVcbiAqIGZvciBzZWVraW5nIHRvLlxuICpcbiAqIEByZXR1cm4ge1RpbWVSYW5nZXN9IHRoZSBzZWVrYWJsZSBpbnRlcnZhbHMgb2YgdGhlIG1lZGlhIHRpbWVsaW5lXG4gKiBAbWV0aG9kIFBsYXllciNzZWVrYWJsZVxuICovXG4nc2Vla2FibGUnLFxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlIG9mIG5ldHdvcmsgYWN0aXZpdHkgZm9yIHRoZSBlbGVtZW50LCBmcm9tXG4gKiB0aGUgY29kZXMgaW4gdGhlIGxpc3QgYmVsb3cuXG4gKiAtIE5FVFdPUktfRU1QVFkgKG51bWVyaWMgdmFsdWUgMClcbiAqICAgVGhlIGVsZW1lbnQgaGFzIG5vdCB5ZXQgYmVlbiBpbml0aWFsaXNlZC4gQWxsIGF0dHJpYnV0ZXMgYXJlIGluXG4gKiAgIHRoZWlyIGluaXRpYWwgc3RhdGVzLlxuICogLSBORVRXT1JLX0lETEUgKG51bWVyaWMgdmFsdWUgMSlcbiAqICAgVGhlIGVsZW1lbnQncyByZXNvdXJjZSBzZWxlY3Rpb24gYWxnb3JpdGhtIGlzIGFjdGl2ZSBhbmQgaGFzXG4gKiAgIHNlbGVjdGVkIGEgcmVzb3VyY2UsIGJ1dCBpdCBpcyBub3QgYWN0dWFsbHkgdXNpbmcgdGhlIG5ldHdvcmsgYXRcbiAqICAgdGhpcyB0aW1lLlxuICogLSBORVRXT1JLX0xPQURJTkcgKG51bWVyaWMgdmFsdWUgMilcbiAqICAgVGhlIHVzZXIgYWdlbnQgaXMgYWN0aXZlbHkgdHJ5aW5nIHRvIGRvd25sb2FkIGRhdGEuXG4gKiAtIE5FVFdPUktfTk9fU09VUkNFIChudW1lcmljIHZhbHVlIDMpXG4gKiAgIFRoZSBlbGVtZW50J3MgcmVzb3VyY2Ugc2VsZWN0aW9uIGFsZ29yaXRobSBpcyBhY3RpdmUsIGJ1dCBpdCBoYXNcbiAqICAgbm90IHlldCBmb3VuZCBhIHJlc291cmNlIHRvIHVzZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNuZXR3b3JrLXN0YXRlc1xuICogQHJldHVybiB7bnVtYmVyfSB0aGUgY3VycmVudCBuZXR3b3JrIGFjdGl2aXR5IHN0YXRlXG4gKiBAbWV0aG9kIFBsYXllciNuZXR3b3JrU3RhdGVcbiAqL1xuJ25ldHdvcmtTdGF0ZScsXG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSB0aGF0IGV4cHJlc3NlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZWxlbWVudFxuICogd2l0aCByZXNwZWN0IHRvIHJlbmRlcmluZyB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiwgZnJvbSB0aGVcbiAqIGNvZGVzIGluIHRoZSBsaXN0IGJlbG93LlxuICogLSBIQVZFX05PVEhJTkcgKG51bWVyaWMgdmFsdWUgMClcbiAqICAgTm8gaW5mb3JtYXRpb24gcmVnYXJkaW5nIHRoZSBtZWRpYSByZXNvdXJjZSBpcyBhdmFpbGFibGUuXG4gKiAtIEhBVkVfTUVUQURBVEEgKG51bWVyaWMgdmFsdWUgMSlcbiAqICAgRW5vdWdoIG9mIHRoZSByZXNvdXJjZSBoYXMgYmVlbiBvYnRhaW5lZCB0aGF0IHRoZSBkdXJhdGlvbiBvZiB0aGVcbiAqICAgcmVzb3VyY2UgaXMgYXZhaWxhYmxlLlxuICogLSBIQVZFX0NVUlJFTlRfREFUQSAobnVtZXJpYyB2YWx1ZSAyKVxuICogICBEYXRhIGZvciB0aGUgaW1tZWRpYXRlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaXMgYXZhaWxhYmxlLlxuICogLSBIQVZFX0ZVVFVSRV9EQVRBIChudW1lcmljIHZhbHVlIDMpXG4gKiAgIERhdGEgZm9yIHRoZSBpbW1lZGlhdGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiBpcyBhdmFpbGFibGUsIGFzXG4gKiAgIHdlbGwgYXMgZW5vdWdoIGRhdGEgZm9yIHRoZSB1c2VyIGFnZW50IHRvIGFkdmFuY2UgdGhlIGN1cnJlbnRcbiAqICAgcGxheWJhY2sgcG9zaXRpb24gaW4gdGhlIGRpcmVjdGlvbiBvZiBwbGF5YmFjay5cbiAqIC0gSEFWRV9FTk9VR0hfREFUQSAobnVtZXJpYyB2YWx1ZSA0KVxuICogICBUaGUgdXNlciBhZ2VudCBlc3RpbWF0ZXMgdGhhdCBlbm91Z2ggZGF0YSBpcyBhdmFpbGFibGUgZm9yXG4gKiAgIHBsYXliYWNrIHRvIHByb2NlZWQgdW5pbnRlcnJ1cHRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tbWVkaWEtcmVhZHlzdGF0ZVxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgY3VycmVudCBwbGF5YmFjayByZW5kZXJpbmcgc3RhdGVcbiAqIEBtZXRob2QgUGxheWVyI3JlYWR5U3RhdGVcbiAqL1xuJ3JlYWR5U3RhdGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICBQbGF5ZXIucHJvdG90eXBlW2ZuXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0Xyhmbik7XG4gIH07XG59KTtcblxuVEVDSF9FVkVOVFNfUkVUUklHR0VSLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gIFBsYXllci5wcm90b3R5cGVbJ2hhbmRsZVRlY2gnICsgdG9UaXRsZUNhc2UoZXZlbnQpICsgJ18nXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50cmlnZ2VyKGV2ZW50KTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBoYXMgaW5pdGlhbCBkdXJhdGlvbiBhbmQgZGltZW5zaW9uIGluZm9ybWF0aW9uXG4gKlxuICogQGV2ZW50IFBsYXllciNsb2FkZWRtZXRhZGF0YVxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIGhhcyBkb3dubG9hZGVkIGRhdGEgYXQgdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb25cbiAqXG4gKiBAZXZlbnQgUGxheWVyI2xvYWRlZGRhdGFcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaGFzIGNoYW5nZWQgKlxuICogRHVyaW5nIHBsYXliYWNrIHRoaXMgaXMgZmlyZWQgZXZlcnkgMTUtMjUwIG1pbGxpc2Vjb25kcywgZGVwZW5kaW5nIG9uIHRoZVxuICogcGxheWJhY2sgdGVjaG5vbG9neSBpbiB1c2UuXG4gKlxuICogQGV2ZW50IFBsYXllciN0aW1ldXBkYXRlXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSB2b2x1bWUgY2hhbmdlc1xuICpcbiAqIEBldmVudCBQbGF5ZXIjdm9sdW1lY2hhbmdlXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cblxuLyoqXG4gKiBSZXBvcnRzIHdoZXRoZXIgb3Igbm90IGEgcGxheWVyIGhhcyBhIHBsdWdpbiBhdmFpbGFibGUuXG4gKlxuICogVGhpcyBkb2VzIG5vdCByZXBvcnQgd2hldGhlciBvciBub3QgdGhlIHBsdWdpbiBoYXMgZXZlciBiZWVuIGluaXRpYWxpemVkXG4gKiBvbiB0aGlzIHBsYXllci4gRm9yIHRoYXQsIFt1c2luZ1BsdWdpbl17QGxpbmsgUGxheWVyI3VzaW5nUGx1Z2lufS5cbiAqXG4gKiBAbWV0aG9kIFBsYXllciNoYXNQbHVnaW5cbiAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWVcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgV2hldGhlciBvciBub3QgdGhpcyBwbGF5ZXIgaGFzIHRoZSByZXF1ZXN0ZWQgcGx1Z2luIGF2YWlsYWJsZS5cbiAqL1xuXG4vKipcbiAqIFJlcG9ydHMgd2hldGhlciBvciBub3QgYSBwbGF5ZXIgaXMgdXNpbmcgYSBwbHVnaW4gYnkgbmFtZS5cbiAqXG4gKiBGb3IgYmFzaWMgcGx1Z2lucywgdGhpcyBvbmx5IHJlcG9ydHMgd2hldGhlciB0aGUgcGx1Z2luIGhhcyBfZXZlcl8gYmVlblxuICogaW5pdGlhbGl6ZWQgb24gdGhpcyBwbGF5ZXIuXG4gKlxuICogQG1ldGhvZCBQbGF5ZXIjdXNpbmdQbHVnaW5cbiAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICogICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGlzIHBsYXllciBpcyB1c2luZyB0aGUgcmVxdWVzdGVkIHBsdWdpbi5cbiAqL1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXllcicsIFBsYXllcik7XG5cbi8qKlxuICogQGZpbGUgcGx1Z2luLmpzXG4gKi9cbi8qKlxuICogVGhlIGJhc2UgcGx1Z2luIG5hbWUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIEJBU0VfUExVR0lOX05BTUUgPSAncGx1Z2luJztcblxuLyoqXG4gKiBUaGUga2V5IG9uIHdoaWNoIGEgcGxheWVyJ3MgYWN0aXZlIHBsdWdpbnMgY2FjaGUgaXMgc3RvcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlICAgICB7c3RyaW5nfVxuICovXG52YXIgUExVR0lOX0NBQ0hFX0tFWSA9ICdhY3RpdmVQbHVnaW5zXyc7XG5cbi8qKlxuICogU3RvcmVzIHJlZ2lzdGVyZWQgcGx1Z2lucyBpbiBhIHByaXZhdGUgc3BhY2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0eXBlICAgIHtPYmplY3R9XG4gKi9cbnZhciBwbHVnaW5TdG9yYWdlID0ge307XG5cbi8qKlxuICogUmVwb3J0cyB3aGV0aGVyIG9yIG5vdCBhIHBsdWdpbiBoYXMgYmVlbiByZWdpc3RlcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqICAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBwbHVnaW4gaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAqL1xudmFyIHBsdWdpbkV4aXN0cyA9IGZ1bmN0aW9uIHBsdWdpbkV4aXN0cyhuYW1lKSB7XG4gIHJldHVybiBwbHVnaW5TdG9yYWdlLmhhc093blByb3BlcnR5KG5hbWUpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBzaW5nbGUgcmVnaXN0ZXJlZCBwbHVnaW4gYnkgbmFtZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICogICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqICAgICAgICAgIFRoZSBwbHVnaW4gKG9yIHVuZGVmaW5lZCkuXG4gKi9cbnZhciBnZXRQbHVnaW4gPSBmdW5jdGlvbiBnZXRQbHVnaW4obmFtZSkge1xuICByZXR1cm4gcGx1Z2luRXhpc3RzKG5hbWUpID8gcGx1Z2luU3RvcmFnZVtuYW1lXSA6IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogTWFya3MgYSBwbHVnaW4gYXMgXCJhY3RpdmVcIiBvbiBhIHBsYXllci5cbiAqXG4gKiBBbHNvLCBlbnN1cmVzIHRoYXQgdGhlIHBsYXllciBoYXMgYW4gb2JqZWN0IGZvciB0cmFja2luZyBhY3RpdmUgcGx1Z2lucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge1BsYXllcn0gcGxheWVyXG4gKiAgICAgICAgICBBIFZpZGVvLmpzIHBsYXllciBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqL1xudmFyIG1hcmtQbHVnaW5Bc0FjdGl2ZSA9IGZ1bmN0aW9uIG1hcmtQbHVnaW5Bc0FjdGl2ZShwbGF5ZXIsIG5hbWUpIHtcbiAgcGxheWVyW1BMVUdJTl9DQUNIRV9LRVldID0gcGxheWVyW1BMVUdJTl9DQUNIRV9LRVldIHx8IHt9O1xuICBwbGF5ZXJbUExVR0lOX0NBQ0hFX0tFWV1bbmFtZV0gPSB0cnVlO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VycyBhIHBhaXIgb2YgcGx1Z2luIHNldHVwIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAqICAgICAgICAgQSBWaWRlby5qcyBwbGF5ZXIgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtICB7UGx1Z2luflBsdWdpbkV2ZW50SGFzaH0gaGFzaFxuICogICAgICAgICBBIHBsdWdpbiBldmVudCBoYXNoLlxuICpcbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtiZWZvcmVdXG4gKiAgICAgICAgIElmIHRydWUsIHByZWZpeGVzIHRoZSBldmVudCBuYW1lIHdpdGggXCJiZWZvcmVcIi4gSW4gb3RoZXIgd29yZHMsXG4gKiAgICAgICAgIHVzZSB0aGlzIHRvIHRyaWdnZXIgXCJiZWZvcmVwbHVnaW5zZXR1cFwiIGluc3RlYWQgb2YgXCJwbHVnaW5zZXR1cFwiLlxuICovXG52YXIgdHJpZ2dlclNldHVwRXZlbnQgPSBmdW5jdGlvbiB0cmlnZ2VyU2V0dXBFdmVudChwbGF5ZXIsIGhhc2gsIGJlZm9yZSkge1xuICB2YXIgZXZlbnROYW1lID0gKGJlZm9yZSA/ICdiZWZvcmUnIDogJycpICsgJ3BsdWdpbnNldHVwJztcblxuICBwbGF5ZXIudHJpZ2dlcihldmVudE5hbWUsIGhhc2gpO1xuICBwbGF5ZXIudHJpZ2dlcihldmVudE5hbWUgKyAnOicgKyBoYXNoLm5hbWUsIGhhc2gpO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIGJhc2ljIHBsdWdpbiBmdW5jdGlvbiBhbmQgcmV0dXJucyBhIHdyYXBwZXIgZnVuY3Rpb24gd2hpY2ggbWFya3NcbiAqIG9uIHRoZSBwbGF5ZXIgdGhhdCB0aGUgcGx1Z2luIGhhcyBiZWVuIGFjdGl2YXRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICogICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0gICB7RnVuY3Rpb259IHBsdWdpblxuICogICAgICAgICAgVGhlIGJhc2ljIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKiAgICAgICAgICBBIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBwbHVnaW4uXG4gKi9cbnZhciBjcmVhdGVCYXNpY1BsdWdpbiA9IGZ1bmN0aW9uIGNyZWF0ZUJhc2ljUGx1Z2luKG5hbWUsIHBsdWdpbikge1xuICB2YXIgYmFzaWNQbHVnaW5XcmFwcGVyID0gZnVuY3Rpb24gYmFzaWNQbHVnaW5XcmFwcGVyKCkge1xuXG4gICAgLy8gV2UgdHJpZ2dlciB0aGUgXCJiZWZvcmVwbHVnaW5zZXR1cFwiIGFuZCBcInBsdWdpbnNldHVwXCIgZXZlbnRzIG9uIHRoZSBwbGF5ZXJcbiAgICAvLyByZWdhcmRsZXNzLCBidXQgd2Ugd2FudCB0aGUgaGFzaCB0byBiZSBjb25zaXN0ZW50IHdpdGggdGhlIGhhc2ggcHJvdmlkZWRcbiAgICAvLyBmb3IgYWR2YW5jZWQgcGx1Z2lucy5cbiAgICAvL1xuICAgIC8vIFRoZSBvbmx5IHBvdGVudGlhbGx5IGNvdW50ZXItaW50dWl0aXZlIHRoaW5nIGhlcmUgaXMgdGhlIGBpbnN0YW5jZWAgaW5cbiAgICAvLyB0aGUgXCJwbHVnaW5zZXR1cFwiIGV2ZW50IGlzIHRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgYHBsdWdpbmAgZnVuY3Rpb24uXG4gICAgdHJpZ2dlclNldHVwRXZlbnQodGhpcywgeyBuYW1lOiBuYW1lLCBwbHVnaW46IHBsdWdpbiwgaW5zdGFuY2U6IG51bGwgfSwgdHJ1ZSk7XG5cbiAgICB2YXIgaW5zdGFuY2UgPSBwbHVnaW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIG1hcmtQbHVnaW5Bc0FjdGl2ZSh0aGlzLCBuYW1lKTtcbiAgICB0cmlnZ2VyU2V0dXBFdmVudCh0aGlzLCB7IG5hbWU6IG5hbWUsIHBsdWdpbjogcGx1Z2luLCBpbnN0YW5jZTogaW5zdGFuY2UgfSk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgT2JqZWN0LmtleXMocGx1Z2luKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgYmFzaWNQbHVnaW5XcmFwcGVyW3Byb3BdID0gcGx1Z2luW3Byb3BdO1xuICB9KTtcblxuICByZXR1cm4gYmFzaWNQbHVnaW5XcmFwcGVyO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIHBsdWdpbiBzdWItY2xhc3MgYW5kIHJldHVybnMgYSBmYWN0b3J5IGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nXG4gKiBpbnN0YW5jZXMgb2YgaXQuXG4gKlxuICogVGhpcyBmYWN0b3J5IGZ1bmN0aW9uIHdpbGwgcmVwbGFjZSBpdHNlbGYgd2l0aCBhbiBpbnN0YW5jZSBvZiB0aGUgcmVxdWVzdGVkXG4gKiBzdWItY2xhc3Mgb2YgUGx1Z2luLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSAgIHtQbHVnaW59IFBsdWdpblN1YkNsYXNzXG4gKiAgICAgICAgICBUaGUgYWR2YW5jZWQgcGx1Z2luLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xudmFyIGNyZWF0ZVBsdWdpbkZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVQbHVnaW5GYWN0b3J5KG5hbWUsIFBsdWdpblN1YkNsYXNzKSB7XG5cbiAgLy8gQWRkIGEgYG5hbWVgIHByb3BlcnR5IHRvIHRoZSBwbHVnaW4gcHJvdG90eXBlIHNvIHRoYXQgZWFjaCBwbHVnaW4gY2FuXG4gIC8vIHJlZmVyIHRvIGl0c2VsZiBieSBuYW1lLlxuICBQbHVnaW5TdWJDbGFzcy5wcm90b3R5cGUubmFtZSA9IG5hbWU7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0cmlnZ2VyU2V0dXBFdmVudCh0aGlzLCB7IG5hbWU6IG5hbWUsIHBsdWdpbjogUGx1Z2luU3ViQ2xhc3MsIGluc3RhbmNlOiBudWxsIH0sIHRydWUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShQbHVnaW5TdWJDbGFzcywgW251bGxdLmNvbmNhdChbdGhpc10uY29uY2F0KGFyZ3MpKSkpKCk7XG5cbiAgICAvLyBUaGUgcGx1Z2luIGlzIHJlcGxhY2VkIGJ5IGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcblxuICAgIHRyaWdnZXJTZXR1cEV2ZW50KHRoaXMsIGluc3RhbmNlLmdldEV2ZW50SGFzaCgpKTtcblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn07XG5cbi8qKlxuICogUGFyZW50IGNsYXNzIGZvciBhbGwgYWR2YW5jZWQgcGx1Z2lucy5cbiAqXG4gKiBAbWl4ZXMgICBtb2R1bGU6ZXZlbnRlZH5FdmVudGVkTWl4aW5cbiAqIEBtaXhlcyAgIG1vZHVsZTpzdGF0ZWZ1bH5TdGF0ZWZ1bE1peGluXG4gKiBAZmlyZXMgICBQbGF5ZXIjYmVmb3JlcGx1Z2luc2V0dXBcbiAqIEBmaXJlcyAgIFBsYXllciNiZWZvcmVwbHVnaW5zZXR1cDokbmFtZVxuICogQGZpcmVzICAgUGxheWVyI3BsdWdpbnNldHVwXG4gKiBAZmlyZXMgICBQbGF5ZXIjcGx1Z2luc2V0dXA6JG5hbWVcbiAqIEBsaXN0ZW5zIFBsYXllciNkaXNwb3NlXG4gKiBAdGhyb3dzICB7RXJyb3J9XG4gKiAgICAgICAgICBJZiBhdHRlbXB0aW5nIHRvIGluc3RhbnRpYXRlIHRoZSBiYXNlIHtAbGluayBQbHVnaW59IGNsYXNzXG4gKiAgICAgICAgICBkaXJlY3RseSBpbnN0ZWFkIG9mIHZpYSBhIHN1Yi1jbGFzcy5cbiAqL1xuXG52YXIgUGx1Z2luID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIFN1Yi1jbGFzc2VzIHNob3VsZCBjYWxsIGBzdXBlcmAgdG8gZW5zdXJlIHBsdWdpbnMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBBIFZpZGVvLmpzIHBsYXllciBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIFBsdWdpbihwbGF5ZXIpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbHVnaW4pO1xuXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IFBsdWdpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbHVnaW4gbXVzdCBiZSBzdWItY2xhc3NlZDsgbm90IGRpcmVjdGx5IGluc3RhbnRpYXRlZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnBsYXllciA9IHBsYXllcjtcblxuICAgIC8vIE1ha2UgdGhpcyBvYmplY3QgZXZlbnRlZCwgYnV0IHJlbW92ZSB0aGUgYWRkZWQgYHRyaWdnZXJgIG1ldGhvZCBzbyB3ZVxuICAgIC8vIHVzZSB0aGUgcHJvdG90eXBlIHZlcnNpb24gaW5zdGVhZC5cbiAgICBldmVudGVkKHRoaXMpO1xuICAgIGRlbGV0ZSB0aGlzLnRyaWdnZXI7XG5cbiAgICBzdGF0ZWZ1bCh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRTdGF0ZSk7XG4gICAgbWFya1BsdWdpbkFzQWN0aXZlKHBsYXllciwgdGhpcy5uYW1lKTtcblxuICAgIC8vIEF1dG8tYmluZCB0aGUgZGlzcG9zZSBtZXRob2Qgc28gd2UgY2FuIHVzZSBpdCBhcyBhIGxpc3RlbmVyIGFuZCB1bmJpbmRcbiAgICAvLyBpdCBsYXRlciBlYXNpbHkuXG4gICAgdGhpcy5kaXNwb3NlID0gYmluZCh0aGlzLCB0aGlzLmRpc3Bvc2UpO1xuXG4gICAgLy8gSWYgdGhlIHBsYXllciBpcyBkaXNwb3NlZCwgZGlzcG9zZSB0aGUgcGx1Z2luLlxuICAgIHBsYXllci5vbignZGlzcG9zZScsIHRoaXMuZGlzcG9zZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2ZXJzaW9uIG9mIHRoZSBwbHVnaW4gdGhhdCB3YXMgc2V0IG9uIDxwbHVnaW5OYW1lPi5WRVJTSU9OXG4gICAqL1xuXG5cbiAgUGx1Z2luLnByb3RvdHlwZS52ZXJzaW9uID0gZnVuY3Rpb24gdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5WRVJTSU9OO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFYWNoIGV2ZW50IHRyaWdnZXJlZCBieSBwbHVnaW5zIGluY2x1ZGVzIGEgaGFzaCBvZiBhZGRpdGlvbmFsIGRhdGEgd2l0aFxuICAgKiBjb252ZW50aW9uYWwgcHJvcGVydGllcy5cbiAgICpcbiAgICogVGhpcyByZXR1cm5zIHRoYXQgb2JqZWN0IG9yIG11dGF0ZXMgYW4gZXhpc3RpbmcgaGFzaC5cbiAgICpcbiAgICogQHBhcmFtICAge09iamVjdH0gW2hhc2g9e31dXG4gICAqICAgICAgICAgIEFuIG9iamVjdCB0byBiZSB1c2VkIGFzIGV2ZW50IGFuIGV2ZW50IGhhc2guXG4gICAqXG4gICAqIEByZXR1cm5zIHtQbHVnaW5+UGx1Z2luRXZlbnRIYXNofVxuICAgKiAgICAgICAgICBBbiBldmVudCBoYXNoIG9iamVjdCB3aXRoIHByb3ZpZGVkIHByb3BlcnRpZXMgbWl4ZWQtaW4uXG4gICAqL1xuXG5cbiAgUGx1Z2luLnByb3RvdHlwZS5nZXRFdmVudEhhc2ggPSBmdW5jdGlvbiBnZXRFdmVudEhhc2goKSB7XG4gICAgdmFyIGhhc2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgaGFzaC5uYW1lID0gdGhpcy5uYW1lO1xuICAgIGhhc2gucGx1Z2luID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBoYXNoLmluc3RhbmNlID0gdGhpcztcbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlcnMgYW4gZXZlbnQgb24gdGhlIHBsdWdpbiBvYmplY3QgYW5kIG92ZXJyaWRlc1xuICAgKiB7QGxpbmsgbW9kdWxlOmV2ZW50ZWR+RXZlbnRlZE1peGluLnRyaWdnZXJ8RXZlbnRlZE1peGluLnRyaWdnZXJ9LlxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfE9iamVjdH0gZXZlbnRcbiAgICogICAgICAgICAgQW4gZXZlbnQgdHlwZSBvciBhbiBvYmplY3Qgd2l0aCBhIHR5cGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSAgIHtPYmplY3R9IFtoYXNoPXt9XVxuICAgKiAgICAgICAgICBBZGRpdGlvbmFsIGRhdGEgaGFzaCB0byBtZXJnZSB3aXRoIGFcbiAgICogICAgICAgICAge0BsaW5rIFBsdWdpbn5QbHVnaW5FdmVudEhhc2h8UGx1Z2luRXZlbnRIYXNofS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqICAgICAgICAgIFdoZXRoZXIgb3Igbm90IGRlZmF1bHQgd2FzIHByZXZlbnRlZC5cbiAgICovXG5cblxuICBQbHVnaW4ucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyJCQxKGV2ZW50KSB7XG4gICAgdmFyIGhhc2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgcmV0dXJuIHRyaWdnZXIodGhpcy5ldmVudEJ1c0VsXywgZXZlbnQsIHRoaXMuZ2V0RXZlbnRIYXNoKGhhc2gpKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlcyBcInN0YXRlY2hhbmdlZFwiIGV2ZW50cyBvbiB0aGUgcGx1Z2luLiBOby1vcCBieSBkZWZhdWx0LCBvdmVycmlkZSBieVxuICAgKiBzdWJjbGFzc2luZy5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSAgICB7RXZlbnR9IGVcbiAgICogICAgICAgICAgIEFuIGV2ZW50IG9iamVjdCBwcm92aWRlZCBieSBhIFwic3RhdGVjaGFuZ2VkXCIgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAgICB7T2JqZWN0fSBlLmNoYW5nZXNcbiAgICogICAgICAgICAgIEFuIG9iamVjdCBkZXNjcmliaW5nIGNoYW5nZXMgdGhhdCBvY2N1cnJlZCB3aXRoIHRoZSBcInN0YXRlY2hhbmdlZFwiXG4gICAqICAgICAgICAgICBldmVudC5cbiAgICovXG5cblxuICBQbHVnaW4ucHJvdG90eXBlLmhhbmRsZVN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uIGhhbmRsZVN0YXRlQ2hhbmdlZChlKSB7fTtcblxuICAvKipcbiAgICogRGlzcG9zZXMgYSBwbHVnaW4uXG4gICAqXG4gICAqIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgaWYgdGhleSB3YW50LCBidXQgZm9yIHRoZSBzYWtlIG9mIHNhZmV0eSxcbiAgICogaXQncyBwcm9iYWJseSBiZXN0IHRvIHN1YnNjcmliZSB0aGUgXCJkaXNwb3NlXCIgZXZlbnQuXG4gICAqXG4gICAqIEBmaXJlcyBQbHVnaW4jZGlzcG9zZVxuICAgKi9cblxuXG4gIFBsdWdpbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUsXG4gICAgICAgIHBsYXllciA9IHRoaXMucGxheWVyO1xuXG4gICAgLyoqXG4gICAgICogU2lnbmFscyB0aGF0IGEgYWR2YW5jZWQgcGx1Z2luIGlzIGFib3V0IHRvIGJlIGRpc3Bvc2VkLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsdWdpbiNkaXNwb3NlXG4gICAgICogQHR5cGUgIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cblxuICAgIHRoaXMudHJpZ2dlcignZGlzcG9zZScpO1xuICAgIHRoaXMub2ZmKCk7XG4gICAgcGxheWVyLm9mZignZGlzcG9zZScsIHRoaXMuZGlzcG9zZSk7XG5cbiAgICAvLyBFbGltaW5hdGUgYW55IHBvc3NpYmxlIHNvdXJjZXMgb2YgbGVha2luZyBtZW1vcnkgYnkgY2xlYXJpbmcgdXBcbiAgICAvLyByZWZlcmVuY2VzIGJldHdlZW4gdGhlIHBsYXllciBhbmQgdGhlIHBsdWdpbiBpbnN0YW5jZSBhbmQgbnVsbGluZyBvdXRcbiAgICAvLyB0aGUgcGx1Z2luJ3Mgc3RhdGUgYW5kIHJlcGxhY2luZyBtZXRob2RzIHdpdGggYSBmdW5jdGlvbiB0aGF0IHRocm93cy5cbiAgICBwbGF5ZXJbUExVR0lOX0NBQ0hFX0tFWV1bbmFtZV0gPSBmYWxzZTtcbiAgICB0aGlzLnBsYXllciA9IHRoaXMuc3RhdGUgPSBudWxsO1xuXG4gICAgLy8gRmluYWxseSwgcmVwbGFjZSB0aGUgcGx1Z2luIG5hbWUgb24gdGhlIHBsYXllciB3aXRoIGEgbmV3IGZhY3RvcnlcbiAgICAvLyBmdW5jdGlvbiwgc28gdGhhdCB0aGUgcGx1Z2luIGlzIHJlYWR5IHRvIGJlIHNldCB1cCBhZ2Fpbi5cbiAgICBwbGF5ZXJbbmFtZV0gPSBjcmVhdGVQbHVnaW5GYWN0b3J5KG5hbWUsIHBsdWdpblN0b3JhZ2VbbmFtZV0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGEgcGx1Z2luIGlzIGEgYmFzaWMgcGx1Z2luIChpLmUuIG5vdCBhIHN1Yi1jbGFzcyBvZiBgUGx1Z2luYCkuXG4gICAqXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd8RnVuY3Rpb259IHBsdWdpblxuICAgKiAgICAgICAgICBJZiBhIHN0cmluZywgbWF0Y2hlcyB0aGUgbmFtZSBvZiBhIHBsdWdpbi4gSWYgYSBmdW5jdGlvbiwgd2lsbCBiZVxuICAgKiAgICAgICAgICB0ZXN0ZWQgZGlyZWN0bHkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiAgICAgICAgICBXaGV0aGVyIG9yIG5vdCBhIHBsdWdpbiBpcyBhIGJhc2ljIHBsdWdpbi5cbiAgICovXG5cblxuICBQbHVnaW4uaXNCYXNpYyA9IGZ1bmN0aW9uIGlzQmFzaWMocGx1Z2luKSB7XG4gICAgdmFyIHAgPSB0eXBlb2YgcGx1Z2luID09PSAnc3RyaW5nJyA/IGdldFBsdWdpbihwbHVnaW4pIDogcGx1Z2luO1xuXG4gICAgcmV0dXJuIHR5cGVvZiBwID09PSAnZnVuY3Rpb24nICYmICFQbHVnaW4ucHJvdG90eXBlLmlzUHJvdG90eXBlT2YocC5wcm90b3R5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIFZpZGVvLmpzIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRvIGJlIHJlZ2lzdGVyZWQuIE11c3QgYmUgYSBzdHJpbmcgYW5kXG4gICAqICAgICAgICAgIG11c3Qgbm90IG1hdGNoIGFuIGV4aXN0aW5nIHBsdWdpbiBvciBhIG1ldGhvZCBvbiB0aGUgYFBsYXllcmBcbiAgICogICAgICAgICAgcHJvdG90eXBlLlxuICAgKlxuICAgKiBAcGFyYW0gICB7RnVuY3Rpb259IHBsdWdpblxuICAgKiAgICAgICAgICBBIHN1Yi1jbGFzcyBvZiBgUGx1Z2luYCBvciBhIGZ1bmN0aW9uIGZvciBiYXNpYyBwbHVnaW5zLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAqICAgICAgICAgIEZvciBhZHZhbmNlZCBwbHVnaW5zLCBhIGZhY3RvcnkgZnVuY3Rpb24gZm9yIHRoYXQgcGx1Z2luLiBGb3JcbiAgICogICAgICAgICAgYmFzaWMgcGx1Z2lucywgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIHBsdWdpbi5cbiAgICovXG5cblxuICBQbHVnaW4ucmVnaXN0ZXJQbHVnaW4gPSBmdW5jdGlvbiByZWdpc3RlclBsdWdpbihuYW1lLCBwbHVnaW4pIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgcGx1Z2luIG5hbWUsIFwiJyArIG5hbWUgKyAnXCIsIG11c3QgYmUgYSBzdHJpbmcsIHdhcyAnICsgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgKyAnLicpO1xuICAgIH1cblxuICAgIGlmIChwbHVnaW5FeGlzdHMobmFtZSkpIHtcbiAgICAgIGxvZyQxLndhcm4oJ0EgcGx1Z2luIG5hbWVkIFwiJyArIG5hbWUgKyAnXCIgYWxyZWFkeSBleGlzdHMuIFlvdSBtYXkgd2FudCB0byBhdm9pZCByZS1yZWdpc3RlcmluZyBwbHVnaW5zIScpO1xuICAgIH0gZWxzZSBpZiAoUGxheWVyLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIHBsdWdpbiBuYW1lLCBcIicgKyBuYW1lICsgJ1wiLCBjYW5ub3Qgc2hhcmUgYSBuYW1lIHdpdGggYW4gZXhpc3RpbmcgcGxheWVyIG1ldGhvZCEnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBsdWdpbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIHBsdWdpbiBmb3IgXCInICsgbmFtZSArICdcIiwgbXVzdCBiZSBhIGZ1bmN0aW9uLCB3YXMgJyArICh0eXBlb2YgcGx1Z2luID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwbHVnaW4pKSArICcuJyk7XG4gICAgfVxuXG4gICAgcGx1Z2luU3RvcmFnZVtuYW1lXSA9IHBsdWdpbjtcblxuICAgIC8vIEFkZCBhIHBsYXllciBwcm90b3R5cGUgbWV0aG9kIGZvciBhbGwgc3ViLWNsYXNzZWQgcGx1Z2lucyAoYnV0IG5vdCBmb3JcbiAgICAvLyB0aGUgYmFzZSBQbHVnaW4gY2xhc3MpLlxuICAgIGlmIChuYW1lICE9PSBCQVNFX1BMVUdJTl9OQU1FKSB7XG4gICAgICBpZiAoUGx1Z2luLmlzQmFzaWMocGx1Z2luKSkge1xuICAgICAgICBQbGF5ZXIucHJvdG90eXBlW25hbWVdID0gY3JlYXRlQmFzaWNQbHVnaW4obmFtZSwgcGx1Z2luKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFBsYXllci5wcm90b3R5cGVbbmFtZV0gPSBjcmVhdGVQbHVnaW5GYWN0b3J5KG5hbWUsIHBsdWdpbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsdWdpbjtcbiAgfTtcblxuICAvKipcbiAgICogRGUtcmVnaXN0ZXIgYSBWaWRlby5qcyBwbHVnaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRvIGJlIGRlcmVnaXN0ZXJlZC5cbiAgICovXG5cblxuICBQbHVnaW4uZGVyZWdpc3RlclBsdWdpbiA9IGZ1bmN0aW9uIGRlcmVnaXN0ZXJQbHVnaW4obmFtZSkge1xuICAgIGlmIChuYW1lID09PSBCQVNFX1BMVUdJTl9OQU1FKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZS1yZWdpc3RlciBiYXNlIHBsdWdpbi4nKTtcbiAgICB9XG4gICAgaWYgKHBsdWdpbkV4aXN0cyhuYW1lKSkge1xuICAgICAgZGVsZXRlIHBsdWdpblN0b3JhZ2VbbmFtZV07XG4gICAgICBkZWxldGUgUGxheWVyLnByb3RvdHlwZVtuYW1lXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbXVsdGlwbGUgVmlkZW8uanMgcGx1Z2lucy5cbiAgICpcbiAgICogQHBhcmFtICAge0FycmF5fSBbbmFtZXNdXG4gICAqICAgICAgICAgIElmIHByb3ZpZGVkLCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgcGx1Z2luIG5hbWVzLiBEZWZhdWx0cyB0byBfYWxsX1xuICAgKiAgICAgICAgICBwbHVnaW4gbmFtZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBwbHVnaW4ocykgYXNzb2NpYXRlZCB3aXRoIHRoZWlyIG5hbWUocykgb3JcbiAgICogICAgICAgICAgYHVuZGVmaW5lZGAgaWYgbm8gbWF0Y2hpbmcgcGx1Z2lucyBleGlzdCkuXG4gICAqL1xuXG5cbiAgUGx1Z2luLmdldFBsdWdpbnMgPSBmdW5jdGlvbiBnZXRQbHVnaW5zKCkge1xuICAgIHZhciBuYW1lcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogT2JqZWN0LmtleXMocGx1Z2luU3RvcmFnZSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuXG4gICAgbmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHBsdWdpbiA9IGdldFBsdWdpbihuYW1lKTtcblxuICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwge307XG4gICAgICAgIHJlc3VsdFtuYW1lXSA9IHBsdWdpbjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYSBwbHVnaW4ncyB2ZXJzaW9uLCBpZiBhdmFpbGFibGVcbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogICAgICAgICAgVGhlIHBsdWdpbidzIHZlcnNpb24gb3IgYW4gZW1wdHkgc3RyaW5nLlxuICAgKi9cblxuXG4gIFBsdWdpbi5nZXRQbHVnaW5WZXJzaW9uID0gZnVuY3Rpb24gZ2V0UGx1Z2luVmVyc2lvbihuYW1lKSB7XG4gICAgdmFyIHBsdWdpbiA9IGdldFBsdWdpbihuYW1lKTtcblxuICAgIHJldHVybiBwbHVnaW4gJiYgcGx1Z2luLlZFUlNJT04gfHwgJyc7XG4gIH07XG5cbiAgcmV0dXJuIFBsdWdpbjtcbn0oKTtcblxuLyoqXG4gKiBHZXRzIGEgcGx1Z2luIGJ5IG5hbWUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgICBnZXRQbHVnaW5cbiAqIEBtZW1iZXJPZiBQbHVnaW5cbiAqIEBwYXJhbSAgICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybnMgIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKiAgICAgICAgICAgVGhlIHBsdWdpbiAob3IgYHVuZGVmaW5lZGApLlxuICovXG5cblxuUGx1Z2luLmdldFBsdWdpbiA9IGdldFBsdWdpbjtcblxuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUgYmFzZSBwbHVnaW4gY2xhc3MgYXMgaXQgaXMgcmVnaXN0ZXJlZC5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5QbHVnaW4uQkFTRV9QTFVHSU5fTkFNRSA9IEJBU0VfUExVR0lOX05BTUU7XG5cblBsdWdpbi5yZWdpc3RlclBsdWdpbihCQVNFX1BMVUdJTl9OQU1FLCBQbHVnaW4pO1xuXG4vKipcbiAqIERvY3VtZW50ZWQgaW4gcGxheWVyLmpzXG4gKlxuICogQGlnbm9yZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLnVzaW5nUGx1Z2luID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICEhdGhpc1tQTFVHSU5fQ0FDSEVfS0VZXSAmJiB0aGlzW1BMVUdJTl9DQUNIRV9LRVldW25hbWVdID09PSB0cnVlO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudGVkIGluIHBsYXllci5qc1xuICpcbiAqIEBpZ25vcmVcbiAqL1xuUGxheWVyLnByb3RvdHlwZS5oYXNQbHVnaW4gPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gISFwbHVnaW5FeGlzdHMobmFtZSk7XG59O1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIHBsdWdpbiBpcyBhYm91dCB0byBiZSBzZXQgdXAgb24gYSBwbGF5ZXIuXG4gKlxuICogQGV2ZW50ICAgIFBsYXllciNiZWZvcmVwbHVnaW5zZXR1cFxuICogQHR5cGUgICAgIHtQbHVnaW5+UGx1Z2luRXZlbnRIYXNofVxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGEgcGx1Z2luIGlzIGFib3V0IHRvIGJlIHNldCB1cCBvbiBhIHBsYXllciAtIGJ5IG5hbWUuIFRoZSBuYW1lXG4gKiBpcyB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICpcbiAqIEBldmVudCAgICBQbGF5ZXIjYmVmb3JlcGx1Z2luc2V0dXA6JG5hbWVcbiAqIEB0eXBlICAgICB7UGx1Z2luflBsdWdpbkV2ZW50SGFzaH1cbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIHBsdWdpbiBoYXMganVzdCBiZWVuIHNldCB1cCBvbiBhIHBsYXllci5cbiAqXG4gKiBAZXZlbnQgICAgUGxheWVyI3BsdWdpbnNldHVwXG4gKiBAdHlwZSAgICAge1BsdWdpbn5QbHVnaW5FdmVudEhhc2h9XG4gKi9cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgYSBwbHVnaW4gaGFzIGp1c3QgYmVlbiBzZXQgdXAgb24gYSBwbGF5ZXIgLSBieSBuYW1lLiBUaGUgbmFtZVxuICogaXMgdGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAqXG4gKiBAZXZlbnQgICAgUGxheWVyI3BsdWdpbnNldHVwOiRuYW1lXG4gKiBAdHlwZSAgICAge1BsdWdpbn5QbHVnaW5FdmVudEhhc2h9XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiAge09iamVjdH0gUGx1Z2luflBsdWdpbkV2ZW50SGFzaFxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbnN0YW5jZVxuICogICAgICAgICAgIEZvciBiYXNpYyBwbHVnaW5zLCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwbHVnaW4gZnVuY3Rpb24uIEZvclxuICogICAgICAgICAgIGFkdmFuY2VkIHBsdWdpbnMsIHRoZSBwbHVnaW4gaW5zdGFuY2Ugb24gd2hpY2ggdGhlIGV2ZW50IGlzIGZpcmVkLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGx1Z2luXG4gKiAgICAgICAgICAgRm9yIGJhc2ljIHBsdWdpbnMsIHRoZSBwbHVnaW4gZnVuY3Rpb24uIEZvciBhZHZhbmNlZCBwbHVnaW5zLCB0aGVcbiAqICAgICAgICAgICBwbHVnaW4gY2xhc3MvY29uc3RydWN0b3IuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBleHRlbmQuanNcbiAqIEBtb2R1bGUgZXh0ZW5kXG4gKi9cblxuLyoqXG4gKiBBIGNvbWJpbmF0aW9uIG9mIG5vZGUgaW5oZXJpdHMgYW5kIGJhYmVsJ3MgaW5oZXJpdHMgKGFmdGVyIHRyYW5zcGlsZSkuXG4gKiBCb3RoIHdvcmsgdGhlIHNhbWUgYnV0IG5vZGUgYWRkcyBgc3VwZXJfYCB0byB0aGUgc3ViQ2xhc3NcbiAqIGFuZCBCYWJsZSBhZGRzIHRoZSBzdXBlckNsYXNzIGFzIF9fcHJvdG9fXy4gQm90aCBzZWVtIHVzZWZ1bC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3ViQ2xhc3NcbiAqICAgICAgICBUaGUgY2xhc3MgdG8gaW5oZXJpdCB0b1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdXBlckNsYXNzXG4gKiAgICAgICAgVGhlIGNsYXNzIHRvIGluaGVyaXQgZnJvbVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBfaW5oZXJpdHMgPSBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyAodHlwZW9mIHN1cGVyQ2xhc3MgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN1cGVyQ2xhc3MpKSk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHN1cGVyQ2xhc3MpIHtcbiAgICAvLyBub2RlXG4gICAgc3ViQ2xhc3Muc3VwZXJfID0gc3VwZXJDbGFzcztcbiAgfVxufTtcblxuLyoqXG4gKiBGdW5jdGlvbiBmb3Igc3ViY2xhc3NpbmcgdXNpbmcgdGhlIHNhbWUgaW5oZXJpdGFuY2UgdGhhdFxuICogdmlkZW9qcyB1c2VzIGludGVybmFsbHlcbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3VwZXJDbGFzc1xuICogICAgICAgIFRoZSBjbGFzcyB0byBpbmhlcml0IGZyb21cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW3N1YkNsYXNzTWV0aG9kcz17fV1cbiAqICAgICAgICBUaGUgY2xhc3MgdG8gaW5oZXJpdCB0b1xuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgVGhlIG5ldyBvYmplY3Qgd2l0aCBzdWJDbGFzc01ldGhvZHMgdGhhdCBpbmhlcml0ZWQgc3VwZXJDbGFzcy5cbiAqL1xudmFyIGV4dGVuZEZuID0gZnVuY3Rpb24gZXh0ZW5kRm4oc3VwZXJDbGFzcykge1xuICB2YXIgc3ViQ2xhc3NNZXRob2RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICB2YXIgc3ViQ2xhc3MgPSBmdW5jdGlvbiBzdWJDbGFzcygpIHtcbiAgICBzdXBlckNsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIG1ldGhvZHMgPSB7fTtcblxuICBpZiAoKHR5cGVvZiBzdWJDbGFzc01ldGhvZHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN1YkNsYXNzTWV0aG9kcykpID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChzdWJDbGFzc01ldGhvZHMuY29uc3RydWN0b3IgIT09IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IpIHtcbiAgICAgIHN1YkNsYXNzID0gc3ViQ2xhc3NNZXRob2RzLmNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBtZXRob2RzID0gc3ViQ2xhc3NNZXRob2RzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzdWJDbGFzc01ldGhvZHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdWJDbGFzcyA9IHN1YkNsYXNzTWV0aG9kcztcbiAgfVxuXG4gIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG5cbiAgLy8gRXh0ZW5kIHN1Yk9iaidzIHByb3RvdHlwZSB3aXRoIGZ1bmN0aW9ucyBhbmQgb3RoZXIgcHJvcGVydGllcyBmcm9tIHByb3BzXG4gIGZvciAodmFyIG5hbWUgaW4gbWV0aG9kcykge1xuICAgIGlmIChtZXRob2RzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBzdWJDbGFzcy5wcm90b3R5cGVbbmFtZV0gPSBtZXRob2RzW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJDbGFzcztcbn07XG5cbi8qKlxuICogQGZpbGUgdmlkZW8uanNcbiAqIEBtb2R1bGUgdmlkZW9qc1xuICovXG4vLyBJbmNsdWRlIHRoZSBidWlsdC1pbiB0ZWNoc1xuLy8gSFRNTDUgRWxlbWVudCBTaGltIGZvciBJRThcbmlmICh0eXBlb2YgSFRNTFZpZGVvRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgJiYgaXNSZWFsKCkpIHtcbiAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcbiAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHJhY2snKTtcbiAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8tanMnKTtcbn1cblxuLyoqXG4gKiBEb3VibGVzIGFzIHRoZSBtYWluIGZ1bmN0aW9uIGZvciB1c2VycyB0byBjcmVhdGUgYSBwbGF5ZXIgaW5zdGFuY2UgYW5kIGFsc29cbiAqIHRoZSBtYWluIGxpYnJhcnkgb2JqZWN0LlxuICogVGhlIGB2aWRlb2pzYCBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBpbml0aWFsaXplIG9yIHJldHJpZXZlIGEgcGxheWVyLlxuICAqXG4gKiBAcGFyYW0ge3N0cmluZ3xFbGVtZW50fSBpZFxuICogICAgICAgIFZpZGVvIGVsZW1lbnQgb3IgdmlkZW8gZWxlbWVudCBJRFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgICAgICBPcHRpb25hbCBvcHRpb25zIG9iamVjdCBmb3IgY29uZmlnL3NldHRpbmdzXG4gKlxuICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICogICAgICAgIE9wdGlvbmFsIHJlYWR5IGNhbGxiYWNrXG4gKlxuICogQHJldHVybiB7UGxheWVyfVxuICogICAgICAgICBBIHBsYXllciBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiB2aWRlb2pzKGlkLCBvcHRpb25zLCByZWFkeSkge1xuICB2YXIgdGFnID0gdm9pZCAwO1xuXG4gIC8vIEFsbG93IGZvciBlbGVtZW50IG9yIElEIHRvIGJlIHBhc3NlZCBpblxuICAvLyBTdHJpbmcgSURcbiAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgcGxheWVycyA9IHZpZGVvanMuZ2V0UGxheWVycygpO1xuXG4gICAgLy8gQWRqdXN0IGZvciBqUXVlcnkgSUQgc3ludGF4XG4gICAgaWYgKGlkLmluZGV4T2YoJyMnKSA9PT0gMCkge1xuICAgICAgaWQgPSBpZC5zbGljZSgxKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHBsYXllciBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgZm9yIHRoaXMgSUQgcmV0dXJuIGl0LlxuICAgIGlmIChwbGF5ZXJzW2lkXSkge1xuXG4gICAgICAvLyBJZiBvcHRpb25zIG9yIHJlYWR5IGZ1bmN0aW9uIGFyZSBwYXNzZWQsIHdhcm5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGxvZyQxLndhcm4oJ1BsYXllciBcIicgKyBpZCArICdcIiBpcyBhbHJlYWR5IGluaXRpYWxpc2VkLiBPcHRpb25zIHdpbGwgbm90IGJlIGFwcGxpZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWFkeSkge1xuICAgICAgICBwbGF5ZXJzW2lkXS5yZWFkeShyZWFkeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwbGF5ZXJzW2lkXTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UgZ2V0IGVsZW1lbnQgZm9yIElEXG4gICAgdGFnID0gJCgnIycgKyBpZCk7XG5cbiAgICAvLyBJRCBpcyBhIG1lZGlhIGVsZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB0YWcgPSBpZDtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBhIHVzZWFibGUgZWxlbWVudFxuICAvLyByZTogbm9kZU5hbWUsIGNvdWxkIGJlIGEgYm94IGRpdiBhbHNvXG4gIGlmICghdGFnIHx8ICF0YWcubm9kZU5hbWUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZWxlbWVudCBvciBJRCBzdXBwbGllZCBpcyBub3QgdmFsaWQuICh2aWRlb2pzKScpO1xuICB9XG5cbiAgLy8gRWxlbWVudCBtYXkgaGF2ZSBhIHBsYXllciBhdHRyIHJlZmVycmluZyB0byBhbiBhbHJlYWR5IGNyZWF0ZWQgcGxheWVyIGluc3RhbmNlLlxuICAvLyBJZiBzbyByZXR1cm4gdGhhdCBvdGhlcndpc2Ugc2V0IHVwIGEgbmV3IHBsYXllciBiZWxvd1xuICBpZiAodGFnLnBsYXllciB8fCBQbGF5ZXIucGxheWVyc1t0YWcucGxheWVySWRdKSB7XG4gICAgcmV0dXJuIHRhZy5wbGF5ZXIgfHwgUGxheWVyLnBsYXllcnNbdGFnLnBsYXllcklkXTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGVsZW1lbnQgaXMgaW5jbHVkZWQgaW4gdGhlIERPTVxuICBpZiAoaXNFbCh0YWcpICYmICFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRhZykpIHtcbiAgICBsb2ckMS53YXJuKCdUaGUgZWxlbWVudCBzdXBwbGllZCBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIERPTScpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmlkZW9qcy5ob29rcygnYmVmb3Jlc2V0dXAnKS5mb3JFYWNoKGZ1bmN0aW9uIChob29rRnVuY3Rpb24pIHtcbiAgICB2YXIgb3B0cyA9IGhvb2tGdW5jdGlvbih0YWcsIG1lcmdlT3B0aW9ucyhvcHRpb25zKSk7XG5cbiAgICBpZiAoIWlzT2JqZWN0KG9wdHMpIHx8IEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgIGxvZyQxLmVycm9yKCdwbGVhc2UgcmV0dXJuIGFuIG9iamVjdCBpbiBiZWZvcmVzZXR1cCBob29rcycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0aW9ucywgb3B0cyk7XG4gIH0pO1xuXG4gIHZhciBQbGF5ZXJDb21wb25lbnQgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KCdQbGF5ZXInKTtcbiAgLy8gSWYgbm90LCBzZXQgdXAgYSBuZXcgcGxheWVyXG4gIHZhciBwbGF5ZXIgPSBuZXcgUGxheWVyQ29tcG9uZW50KHRhZywgb3B0aW9ucywgcmVhZHkpO1xuXG4gIHZpZGVvanMuaG9va3MoJ3NldHVwJykuZm9yRWFjaChmdW5jdGlvbiAoaG9va0Z1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGhvb2tGdW5jdGlvbihwbGF5ZXIpO1xuICB9KTtcblxuICByZXR1cm4gcGxheWVyO1xufVxuXG4vKipcbiAqIEFuIE9iamVjdCB0aGF0IGNvbnRhaW5zIGxpZmVjeWNsZSBob29rcyBhcyBrZXlzIHdoaWNoIHBvaW50IHRvIGFuIGFycmF5XG4gKiBvZiBmdW5jdGlvbnMgdGhhdCBhcmUgcnVuIHdoZW4gYSBsaWZlY3ljbGUgaXMgdHJpZ2dlcmVkXG4gKi9cbnZpZGVvanMuaG9va3NfID0ge307XG5cbi8qKlxuICogR2V0IGEgbGlzdCBvZiBob29rcyBmb3IgYSBzcGVjaWZpYyBsaWZlY3ljbGVcbiAqIEBmdW5jdGlvbiB2aWRlb2pzLmhvb2tzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICB0aGUgbGlmZWN5bGUgdG8gZ2V0IGhvb2tzIGZyb21cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEZ1bmN0aW9uW119IFtmbl1cbiAqICAgICAgICBPcHRpb25hbGx5IGFkZCBhIGhvb2sgKG9yIGhvb2tzKSB0byB0aGUgbGlmZWN5Y2xlIHRoYXQgeW91ciBhcmUgZ2V0dGluZy5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqICAgICAgICAgYW4gYXJyYXkgb2YgaG9va3MsIG9yIGFuIGVtcHR5IGFycmF5IGlmIHRoZXJlIGFyZSBub25lLlxuICovXG52aWRlb2pzLmhvb2tzID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gIHZpZGVvanMuaG9va3NfW3R5cGVdID0gdmlkZW9qcy5ob29rc19bdHlwZV0gfHwgW107XG4gIGlmIChmbikge1xuICAgIHZpZGVvanMuaG9va3NfW3R5cGVdID0gdmlkZW9qcy5ob29rc19bdHlwZV0uY29uY2F0KGZuKTtcbiAgfVxuICByZXR1cm4gdmlkZW9qcy5ob29rc19bdHlwZV07XG59O1xuXG4vKipcbiAqIEFkZCBhIGZ1bmN0aW9uIGhvb2sgdG8gYSBzcGVjaWZpYyB2aWRlb2pzIGxpZmVjeWNsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIHRoZSBsaWZlY3ljbGUgdG8gaG9vayB0aGUgZnVuY3Rpb24gdG8uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxGdW5jdGlvbltdfVxuICogICAgICAgIFRoZSBmdW5jdGlvbiBvciBhcnJheSBvZiBmdW5jdGlvbnMgdG8gYXR0YWNoLlxuICovXG52aWRlb2pzLmhvb2sgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgdmlkZW9qcy5ob29rcyh0eXBlLCBmbik7XG59O1xuXG4vKipcbiAqIEFkZCBhIGZ1bmN0aW9uIGhvb2sgdGhhdCB3aWxsIG9ubHkgcnVuIG9uY2UgdG8gYSBzcGVjaWZpYyB2aWRlb2pzIGxpZmVjeWNsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIHRoZSBsaWZlY3ljbGUgdG8gaG9vayB0aGUgZnVuY3Rpb24gdG8uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxGdW5jdGlvbltdfVxuICogICAgICAgIFRoZSBmdW5jdGlvbiBvciBhcnJheSBvZiBmdW5jdGlvbnMgdG8gYXR0YWNoLlxuICovXG52aWRlb2pzLmhvb2tPbmNlID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gIHZpZGVvanMuaG9va3ModHlwZSwgW10uY29uY2F0KGZuKS5tYXAoZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgdmlkZW9qcy5yZW1vdmVIb29rKHR5cGUsIHdyYXBwZXIpO1xuICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH0pKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgaG9vayBmcm9tIGEgc3BlY2lmaWMgdmlkZW9qcyBsaWZlY3ljbGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICB0aGUgbGlmZWN5Y2xlIHRoYXQgdGhlIGZ1bmN0aW9uIGhvb2tlZCB0b1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiAgICAgICAgVGhlIGhvb2tlZCBmdW5jdGlvbiB0byByZW1vdmVcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCB3YXMgcmVtb3ZlZCBvciB1bmRlZlxuICovXG52aWRlb2pzLnJlbW92ZUhvb2sgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgdmFyIGluZGV4ID0gdmlkZW9qcy5ob29rcyh0eXBlKS5pbmRleE9mKGZuKTtcblxuICBpZiAoaW5kZXggPD0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2aWRlb2pzLmhvb2tzX1t0eXBlXSA9IHZpZGVvanMuaG9va3NfW3R5cGVdLnNsaWNlKCk7XG4gIHZpZGVvanMuaG9va3NfW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBBZGQgZGVmYXVsdCBzdHlsZXNcbmlmICh3aW5kb3cuVklERU9KU19OT19EWU5BTUlDX1NUWUxFICE9PSB0cnVlICYmIGlzUmVhbCgpKSB7XG4gIHZhciBzdHlsZSA9ICQoJy52anMtc3R5bGVzLWRlZmF1bHRzJyk7XG5cbiAgaWYgKCFzdHlsZSkge1xuICAgIHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KCd2anMtc3R5bGVzLWRlZmF1bHRzJyk7XG4gICAgdmFyIGhlYWQgPSAkKCdoZWFkJyk7XG5cbiAgICBpZiAoaGVhZCkge1xuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGUsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHNldFRleHRDb250ZW50KHN0eWxlLCAnXFxuICAgICAgLnZpZGVvLWpzIHtcXG4gICAgICAgIHdpZHRoOiAzMDBweDtcXG4gICAgICAgIGhlaWdodDogMTUwcHg7XFxuICAgICAgfVxcblxcbiAgICAgIC52anMtZmx1aWQge1xcbiAgICAgICAgcGFkZGluZy10b3A6IDU2LjI1JVxcbiAgICAgIH1cXG4gICAgJyk7XG4gIH1cbn1cblxuLy8gUnVuIEF1dG8tbG9hZCBwbGF5ZXJzXG4vLyBZb3UgaGF2ZSB0byB3YWl0IGF0IGxlYXN0IG9uY2UgaW4gY2FzZSB0aGlzIHNjcmlwdCBpcyBsb2FkZWQgYWZ0ZXIgeW91clxuLy8gdmlkZW8gaW4gdGhlIERPTSAod2VpcmQgYmVoYXZpb3Igb25seSB3aXRoIG1pbmlmaWVkIHZlcnNpb24pXG5hdXRvU2V0dXBUaW1lb3V0KDEsIHZpZGVvanMpO1xuXG4vKipcbiAqIEN1cnJlbnQgc29mdHdhcmUgdmVyc2lvbi4gRm9sbG93cyBzZW12ZXIuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmlkZW9qcy5WRVJTSU9OID0gdmVyc2lvbjtcblxuLyoqXG4gKiBUaGUgZ2xvYmFsIG9wdGlvbnMgb2JqZWN0LiBUaGVzZSBhcmUgdGhlIHNldHRpbmdzIHRoYXQgdGFrZSBlZmZlY3RcbiAqIGlmIG5vIG92ZXJyaWRlcyBhcmUgc3BlY2lmaWVkIHdoZW4gdGhlIHBsYXllciBpcyBjcmVhdGVkLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZpZGVvanMub3B0aW9ucyA9IFBsYXllci5wcm90b3R5cGUub3B0aW9uc187XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aXRoIHRoZSBjdXJyZW50bHkgY3JlYXRlZCBwbGF5ZXJzLCBrZXllZCBieSBwbGF5ZXIgSURcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIFRoZSBjcmVhdGVkIHBsYXllcnNcbiAqL1xudmlkZW9qcy5nZXRQbGF5ZXJzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gUGxheWVyLnBsYXllcnM7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBwbGF5ZXJzIG9iamVjdC5cbiAqXG4gKiBAbWVtYmVyT2YgdmlkZW9qc1xuICogQHByb3BlcnR5IHtPYmplY3R9IHBsYXllcnNcbiAqL1xudmlkZW9qcy5wbGF5ZXJzID0gUGxheWVyLnBsYXllcnM7XG5cbi8qKlxuICogR2V0IGEgY29tcG9uZW50IGNsYXNzIG9iamVjdCBieSBuYW1lXG4gKlxuICogQGJvcnJvd3MgQ29tcG9uZW50LmdldENvbXBvbmVudCBhcyB2aWRlb2pzLmdldENvbXBvbmVudFxuICovXG52aWRlb2pzLmdldENvbXBvbmVudCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQ7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBjb21wb25lbnQgc28gaXQgY2FuIHJlZmVycmVkIHRvIGJ5IG5hbWUuIFVzZWQgd2hlbiBhZGRpbmcgdG8gb3RoZXJcbiAqIGNvbXBvbmVudHMsIGVpdGhlciB0aHJvdWdoIGFkZENoaWxkIGBjb21wb25lbnQuYWRkQ2hpbGQoJ215Q29tcG9uZW50JylgIG9yIHRocm91Z2hcbiAqIGRlZmF1bHQgY2hpbGRyZW4gb3B0aW9ucyAgYHsgY2hpbGRyZW46IFsnbXlDb21wb25lbnQnXSB9YC5cbiAqXG4gKiA+IE5PVEU6IFlvdSBjb3VsZCBhbHNvIGp1c3QgaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50IGJlZm9yZSBhZGRpbmcuXG4gKiBgY29tcG9uZW50LmFkZENoaWxkKG5ldyBNeUNvbXBvbmVudCgpKTtgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICBUaGUgY2xhc3MgbmFtZSBvZiB0aGUgY29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtDb21wb25lbnR9IGNvbXBcbiAqICAgICAgICBUaGUgY29tcG9uZW50IGNsYXNzXG4gKlxuICogQHJldHVybiB7Q29tcG9uZW50fVxuICogICAgICAgICBUaGUgbmV3bHkgcmVnaXN0ZXJlZCBjb21wb25lbnRcbiAqL1xudmlkZW9qcy5yZWdpc3RlckNvbXBvbmVudCA9IGZ1bmN0aW9uIChuYW1lJCQxLCBjb21wKSB7XG4gIGlmIChUZWNoLmlzVGVjaChjb21wKSkge1xuICAgIGxvZyQxLndhcm4oJ1RoZSAnICsgbmFtZSQkMSArICcgdGVjaCB3YXMgcmVnaXN0ZXJlZCBhcyBhIGNvbXBvbmVudC4gSXQgc2hvdWxkIGluc3RlYWQgYmUgcmVnaXN0ZXJlZCB1c2luZyB2aWRlb2pzLnJlZ2lzdGVyVGVjaChuYW1lLCB0ZWNoKScpO1xuICB9XG5cbiAgQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50LmNhbGwoQ29tcG9uZW50LCBuYW1lJCQxLCBjb21wKTtcbn07XG5cbi8qKlxuICogR2V0IGEgVGVjaCBjbGFzcyBvYmplY3QgYnkgbmFtZVxuICpcbiAqIEBib3Jyb3dzIFRlY2guZ2V0VGVjaCBhcyB2aWRlb2pzLmdldFRlY2hcbiAqL1xudmlkZW9qcy5nZXRUZWNoID0gVGVjaC5nZXRUZWNoO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgVGVjaCBzbyBpdCBjYW4gcmVmZXJyZWQgdG8gYnkgbmFtZS5cbiAqIFRoaXMgaXMgdXNlZCBpbiB0aGUgdGVjaCBvcmRlciBmb3IgdGhlIHBsYXllci5cbiAqXG4gKiBAYm9ycm93cyBUZWNoLnJlZ2lzdGVyVGVjaCBhcyB2aWRlb2pzLnJlZ2lzdGVyVGVjaFxuICovXG52aWRlb2pzLnJlZ2lzdGVyVGVjaCA9IFRlY2gucmVnaXN0ZXJUZWNoO1xuXG52aWRlb2pzLnVzZSA9IHVzZTtcblxuLyoqXG4gKiBBIHN1aXRlIG9mIGJyb3dzZXIgYW5kIGRldmljZSB0ZXN0cyBmcm9tIHtAbGluayBicm93c2VyfS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmlkZW9qcy5icm93c2VyID0gYnJvd3NlcjtcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciBzdXBwb3J0cyB0b3VjaCBldmVudHMuIEluY2x1ZGVkIGZvciBiYWNrd2FyZFxuICogY29tcGF0aWJpbGl0eSB3aXRoIDQueCwgYnV0IGRlcHJlY2F0ZWQuIFVzZSBgdmlkZW9qcy5icm93c2VyLlRPVUNIX0VOQUJMRURgXG4gKiBpbnN0ZWFkIGdvaW5nIGZvcndhcmQuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1LjBcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG52aWRlb2pzLlRPVUNIX0VOQUJMRUQgPSBUT1VDSF9FTkFCTEVEO1xuXG4vKipcbiAqIFN1YmNsYXNzIGFuIGV4aXN0aW5nIGNsYXNzXG4gKiBNaW1pY3MgRVM2IHN1YmNsYXNzaW5nIHdpdGggdGhlIGBleHRlbmRgIGtleXdvcmRcbiAqXG4gKiBAYm9ycm93cyBleHRlbmQ6ZXh0ZW5kRm4gYXMgdmlkZW9qcy5leHRlbmRcbiAqL1xudmlkZW9qcy5leHRlbmQgPSBleHRlbmRGbjtcblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9ucyBvYmplY3RzIHJlY3Vyc2l2ZWx5XG4gKiBQZXJmb3JtcyBhIGRlZXAgbWVyZ2UgbGlrZSBsb2Rhc2gubWVyZ2UgYnV0ICoqb25seSBtZXJnZXMgcGxhaW4gb2JqZWN0cyoqXG4gKiAobm90IGFycmF5cywgZWxlbWVudHMsIGFueXRoaW5nIGVsc2UpXG4gKiBPdGhlciB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQgZGlyZWN0bHkgZnJvbSB0aGUgc2Vjb25kIG9iamVjdC5cbiAqXG4gKiBAYm9ycm93cyBtZXJnZS1vcHRpb25zOm1lcmdlT3B0aW9ucyBhcyB2aWRlb2pzLm1lcmdlT3B0aW9uc1xuICovXG52aWRlb2pzLm1lcmdlT3B0aW9ucyA9IG1lcmdlT3B0aW9ucztcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIGNvbnRleHQgKHRoaXMpIG9mIGEgZnVuY3Rpb25cbiAqXG4gKiA+IE5PVEU6IGFzIG9mIHY1LjAgd2UgcmVxdWlyZSBhbiBFUzUgc2hpbSwgc28geW91IHNob3VsZCB1c2UgdGhlIG5hdGl2ZVxuICogYGZ1bmN0aW9uKCkge30uYmluZChuZXdDb250ZXh0KTtgIGluc3RlYWQgb2YgdGhpcy5cbiAqXG4gKiBAYm9ycm93cyBmbjpiaW5kIGFzIHZpZGVvanMuYmluZFxuICovXG52aWRlb2pzLmJpbmQgPSBiaW5kO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgVmlkZW8uanMgcGx1Z2luLlxuICpcbiAqIEBib3Jyb3dzIHBsdWdpbjpyZWdpc3RlclBsdWdpbiBhcyB2aWRlb2pzLnJlZ2lzdGVyUGx1Z2luXG4gKiBAbWV0aG9kIHJlZ2lzdGVyUGx1Z2luXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdG8gYmUgcmVnaXN0ZXJlZC4gTXVzdCBiZSBhIHN0cmluZyBhbmRcbiAqICAgICAgICAgbXVzdCBub3QgbWF0Y2ggYW4gZXhpc3RpbmcgcGx1Z2luIG9yIGEgbWV0aG9kIG9uIHRoZSBgUGxheWVyYFxuICogICAgICAgICBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IHBsdWdpblxuICogICAgICAgICBBIHN1Yi1jbGFzcyBvZiBgUGx1Z2luYCBvciBhIGZ1bmN0aW9uIGZvciBiYXNpYyBwbHVnaW5zLlxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogICAgICAgICBGb3IgYWR2YW5jZWQgcGx1Z2lucywgYSBmYWN0b3J5IGZ1bmN0aW9uIGZvciB0aGF0IHBsdWdpbi4gRm9yXG4gKiAgICAgICAgIGJhc2ljIHBsdWdpbnMsIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IGluaXRpYWxpemVzIHRoZSBwbHVnaW4uXG4gKi9cbnZpZGVvanMucmVnaXN0ZXJQbHVnaW4gPSBQbHVnaW4ucmVnaXN0ZXJQbHVnaW47XG5cbi8qKlxuICogRGVwcmVjYXRlZCBtZXRob2QgdG8gcmVnaXN0ZXIgYSBwbHVnaW4gd2l0aCBWaWRlby5qc1xuICpcbiAqIEBkZXByZWNhdGVkXG4gKiAgICAgICAgdmlkZW9qcy5wbHVnaW4oKSBpcyBkZXByZWNhdGVkOyB1c2UgdmlkZW9qcy5yZWdpc3RlclBsdWdpbigpIGluc3RlYWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogICAgICAgIFRoZSBwbHVnaW4gbmFtZVxuICpcbiAqIEBwYXJhbSB7UGx1Z2lufEZ1bmN0aW9ufSBwbHVnaW5cbiAqICAgICAgICAgVGhlIHBsdWdpbiBzdWItY2xhc3Mgb3IgZnVuY3Rpb25cbiAqL1xudmlkZW9qcy5wbHVnaW4gPSBmdW5jdGlvbiAobmFtZSQkMSwgcGx1Z2luKSB7XG4gIGxvZyQxLndhcm4oJ3ZpZGVvanMucGx1Z2luKCkgaXMgZGVwcmVjYXRlZDsgdXNlIHZpZGVvanMucmVnaXN0ZXJQbHVnaW4oKSBpbnN0ZWFkJyk7XG4gIHJldHVybiBQbHVnaW4ucmVnaXN0ZXJQbHVnaW4obmFtZSQkMSwgcGx1Z2luKTtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBvYmplY3QgY29udGFpbmluZyBtdWx0aXBsZSBWaWRlby5qcyBwbHVnaW5zLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBbbmFtZXNdXG4gKiAgICAgICAgIElmIHByb3ZpZGVkLCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgcGx1Z2luIG5hbWVzLiBEZWZhdWx0cyB0byBfYWxsX1xuICogICAgICAgICBwbHVnaW4gbmFtZXMuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAqICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgcGx1Z2luKHMpIGFzc29jaWF0ZWQgd2l0aCB0aGVpciBuYW1lKHMpIG9yXG4gKiAgICAgICAgIGB1bmRlZmluZWRgIGlmIG5vIG1hdGNoaW5nIHBsdWdpbnMgZXhpc3QpLlxuICovXG52aWRlb2pzLmdldFBsdWdpbnMgPSBQbHVnaW4uZ2V0UGx1Z2lucztcblxuLyoqXG4gKiBHZXRzIGEgcGx1Z2luIGJ5IG5hbWUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICogICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKiAgICAgICAgIFRoZSBwbHVnaW4gKG9yIGB1bmRlZmluZWRgKS5cbiAqL1xudmlkZW9qcy5nZXRQbHVnaW4gPSBQbHVnaW4uZ2V0UGx1Z2luO1xuXG4vKipcbiAqIEdldHMgYSBwbHVnaW4ncyB2ZXJzaW9uLCBpZiBhdmFpbGFibGVcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgcGx1Z2luJ3MgdmVyc2lvbiBvciBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbnZpZGVvanMuZ2V0UGx1Z2luVmVyc2lvbiA9IFBsdWdpbi5nZXRQbHVnaW5WZXJzaW9uO1xuXG4vKipcbiAqIEFkZGluZyBsYW5ndWFnZXMgc28gdGhhdCB0aGV5J3JlIGF2YWlsYWJsZSB0byBhbGwgcGxheWVycy5cbiAqIEV4YW1wbGU6IGB2aWRlb2pzLmFkZExhbmd1YWdlKCdlcycsIHsgJ0hlbGxvJzogJ0hvbGEnIH0pO2BcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICogICAgICAgIFRoZSBsYW5ndWFnZSBjb2RlIG9yIGRpY3Rpb25hcnkgcHJvcGVydHlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogICAgICAgIFRoZSBkYXRhIHZhbHVlcyB0byBiZSB0cmFuc2xhdGVkXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBUaGUgcmVzdWx0aW5nIGxhbmd1YWdlIGRpY3Rpb25hcnkgb2JqZWN0XG4gKi9cbnZpZGVvanMuYWRkTGFuZ3VhZ2UgPSBmdW5jdGlvbiAoY29kZSwgZGF0YSkge1xuICB2YXIgX21lcmdlT3B0aW9ucztcblxuICBjb2RlID0gKCcnICsgY29kZSkudG9Mb3dlckNhc2UoKTtcblxuICB2aWRlb2pzLm9wdGlvbnMubGFuZ3VhZ2VzID0gbWVyZ2VPcHRpb25zKHZpZGVvanMub3B0aW9ucy5sYW5ndWFnZXMsIChfbWVyZ2VPcHRpb25zID0ge30sIF9tZXJnZU9wdGlvbnNbY29kZV0gPSBkYXRhLCBfbWVyZ2VPcHRpb25zKSk7XG5cbiAgcmV0dXJuIHZpZGVvanMub3B0aW9ucy5sYW5ndWFnZXNbY29kZV07XG59O1xuXG4vKipcbiAqIExvZyBtZXNzYWdlc1xuICpcbiAqIEBib3Jyb3dzIGxvZzpsb2cgYXMgdmlkZW9qcy5sb2dcbiAqL1xudmlkZW9qcy5sb2cgPSBsb2ckMTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVtdWxhdGVkIFRpbWVSYW5nZSBvYmplY3QuXG4gKlxuICogQGJvcnJvd3MgdGltZS1yYW5nZXM6Y3JlYXRlVGltZVJhbmdlcyBhcyB2aWRlb2pzLmNyZWF0ZVRpbWVSYW5nZVxuICovXG4vKipcbiAqIEBib3Jyb3dzIHRpbWUtcmFuZ2VzOmNyZWF0ZVRpbWVSYW5nZXMgYXMgdmlkZW9qcy5jcmVhdGVUaW1lUmFuZ2VzXG4gKi9cbnZpZGVvanMuY3JlYXRlVGltZVJhbmdlID0gdmlkZW9qcy5jcmVhdGVUaW1lUmFuZ2VzID0gY3JlYXRlVGltZVJhbmdlcztcblxuLyoqXG4gKiBGb3JtYXQgc2Vjb25kcyBhcyBhIHRpbWUgc3RyaW5nLCBIOk1NOlNTIG9yIE06U1NcbiAqIFN1cHBseWluZyBhIGd1aWRlIChpbiBzZWNvbmRzKSB3aWxsIGZvcmNlIGEgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3NcbiAqIHRvIGNvdmVyIHRoZSBsZW5ndGggb2YgdGhlIGd1aWRlXG4gKlxuICogQGJvcnJvd3MgZm9ybWF0LXRpbWU6Zm9ybWF0VGltZSBhcyB2aWRlb2pzLmZvcm1hdFRpbWVcbiAqL1xudmlkZW9qcy5mb3JtYXRUaW1lID0gZm9ybWF0VGltZTtcblxuLyoqXG4gKiBSZXNvbHZlIGFuZCBwYXJzZSB0aGUgZWxlbWVudHMgb2YgYSBVUkxcbiAqXG4gKiBAYm9ycm93cyB1cmw6cGFyc2VVcmwgYXMgdmlkZW9qcy5wYXJzZVVybFxuICovXG52aWRlb2pzLnBhcnNlVXJsID0gcGFyc2VVcmw7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSB1cmwgcGFzc2VkIGlzIGEgY3Jvc3MgZG9tYWluIHJlcXVlc3Qgb3Igbm90LlxuICpcbiAqIEBib3Jyb3dzIHVybDppc0Nyb3NzT3JpZ2luIGFzIHZpZGVvanMuaXNDcm9zc09yaWdpblxuICovXG52aWRlb2pzLmlzQ3Jvc3NPcmlnaW4gPSBpc0Nyb3NzT3JpZ2luO1xuXG4vKipcbiAqIEV2ZW50IHRhcmdldCBjbGFzcy5cbiAqXG4gKiBAYm9ycm93cyBFdmVudFRhcmdldCBhcyB2aWRlb2pzLkV2ZW50VGFyZ2V0XG4gKi9cbnZpZGVvanMuRXZlbnRUYXJnZXQgPSBFdmVudFRhcmdldDtcblxuLyoqXG4gKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gZWxlbWVudFxuICogSXQgc3RvcmVzIHRoZSBoYW5kbGVyIGZ1bmN0aW9uIGluIGEgc2VwYXJhdGUgY2FjaGUgb2JqZWN0XG4gKiBhbmQgYWRkcyBhIGdlbmVyaWMgaGFuZGxlciB0byB0aGUgZWxlbWVudCdzIGV2ZW50LFxuICogYWxvbmcgd2l0aCBhIHVuaXF1ZSBpZCAoZ3VpZCkgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogQGJvcnJvd3MgZXZlbnRzOm9uIGFzIHZpZGVvanMub25cbiAqL1xudmlkZW9qcy5vbiA9IG9uO1xuXG4vKipcbiAqIFRyaWdnZXIgYSBsaXN0ZW5lciBvbmx5IG9uY2UgZm9yIGFuIGV2ZW50XG4gKlxuICogQGJvcnJvd3MgZXZlbnRzOm9uZSBhcyB2aWRlb2pzLm9uZVxuICovXG52aWRlb2pzLm9uZSA9IG9uZTtcblxuLyoqXG4gKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBmcm9tIGFuIGVsZW1lbnRcbiAqXG4gKiBAYm9ycm93cyBldmVudHM6b2ZmIGFzIHZpZGVvanMub2ZmXG4gKi9cbnZpZGVvanMub2ZmID0gb2ZmO1xuXG4vKipcbiAqIFRyaWdnZXIgYW4gZXZlbnQgZm9yIGFuIGVsZW1lbnRcbiAqXG4gKiBAYm9ycm93cyBldmVudHM6dHJpZ2dlciBhcyB2aWRlb2pzLnRyaWdnZXJcbiAqL1xudmlkZW9qcy50cmlnZ2VyID0gdHJpZ2dlcjtcblxuLyoqXG4gKiBBIGNyb3NzLWJyb3dzZXIgWE1MSHR0cFJlcXVlc3Qgd3JhcHBlci4gSGVyZSdzIGEgc2ltcGxlIGV4YW1wbGU6XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICBzZXR0aW5ncyBmb3IgdGhlIHJlcXVlc3QuXG4gKlxuICogQHJldHVybiB7WE1MSHR0cFJlcXVlc3R8WERvbWFpblJlcXVlc3R9XG4gKiAgICAgICAgIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SYXlub3MveGhyXG4gKi9cbnZpZGVvanMueGhyID0geGhyO1xuXG4vKipcbiAqIFRleHRUcmFjayBjbGFzc1xuICpcbiAqIEBib3Jyb3dzIFRleHRUcmFjayBhcyB2aWRlb2pzLlRleHRUcmFja1xuICovXG52aWRlb2pzLlRleHRUcmFjayA9IFRleHRUcmFjaztcblxuLyoqXG4gKiBleHBvcnQgdGhlIEF1ZGlvVHJhY2sgY2xhc3Mgc28gdGhhdCBzb3VyY2UgaGFuZGxlcnMgY2FuIGNyZWF0ZVxuICogQXVkaW9UcmFja3MgYW5kIHRoZW4gYWRkIHRoZW0gdG8gdGhlIHBsYXllcnMgQXVkaW9UcmFja0xpc3RcbiAqXG4gKiBAYm9ycm93cyBBdWRpb1RyYWNrIGFzIHZpZGVvanMuQXVkaW9UcmFja1xuICovXG52aWRlb2pzLkF1ZGlvVHJhY2sgPSBBdWRpb1RyYWNrO1xuXG4vKipcbiAqIGV4cG9ydCB0aGUgVmlkZW9UcmFjayBjbGFzcyBzbyB0aGF0IHNvdXJjZSBoYW5kbGVycyBjYW4gY3JlYXRlXG4gKiBWaWRlb1RyYWNrcyBhbmQgdGhlbiBhZGQgdGhlbSB0byB0aGUgcGxheWVycyBWaWRlb1RyYWNrTGlzdFxuICpcbiAqIEBib3Jyb3dzIFZpZGVvVHJhY2sgYXMgdmlkZW9qcy5WaWRlb1RyYWNrXG4gKi9cbnZpZGVvanMuVmlkZW9UcmFjayA9IFZpZGVvVHJhY2s7XG5cbi8qKlxuICogRGV0ZXJtaW5lcywgdmlhIGR1Y2sgdHlwaW5nLCB3aGV0aGVyIG9yIG5vdCBhIHZhbHVlIGlzIGEgRE9NIGVsZW1lbnQuXG4gKlxuICogQGJvcnJvd3MgZG9tOmlzRWwgYXMgdmlkZW9qcy5pc0VsXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uaXNFbCgpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIERldGVybWluZXMsIHZpYSBkdWNrIHR5cGluZywgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIHRleHQgbm9kZS5cbiAqXG4gKiBAYm9ycm93cyBkb206aXNUZXh0Tm9kZSBhcyB2aWRlb2pzLmlzVGV4dE5vZGVcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5pc1RleHROb2RlKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbGVtZW50IGFuZCBhcHBsaWVzIHByb3BlcnRpZXMuXG4gKlxuICogQGJvcnJvd3MgZG9tOmNyZWF0ZUVsIGFzIHZpZGVvanMuY3JlYXRlRWxcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5jcmVhdGVFbCgpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaGFzIGEgQ1NTIGNsYXNzXG4gKlxuICogQGJvcnJvd3MgZG9tOmhhc0VsQ2xhc3MgYXMgdmlkZW9qcy5oYXNDbGFzc1xuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmhhc0NsYXNzKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogQWRkIGEgQ1NTIGNsYXNzIG5hbWUgdG8gYW4gZWxlbWVudFxuICpcbiAqIEBib3Jyb3dzIGRvbTphZGRFbENsYXNzIGFzIHZpZGVvanMuYWRkQ2xhc3NcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5hZGRDbGFzcygpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIFJlbW92ZSBhIENTUyBjbGFzcyBuYW1lIGZyb20gYW4gZWxlbWVudFxuICpcbiAqIEBib3Jyb3dzIGRvbTpyZW1vdmVFbENsYXNzIGFzIHZpZGVvanMucmVtb3ZlQ2xhc3NcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5yZW1vdmVDbGFzcygpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIEFkZHMgb3IgcmVtb3ZlcyBhIENTUyBjbGFzcyBuYW1lIG9uIGFuIGVsZW1lbnQgZGVwZW5kaW5nIG9uIGFuIG9wdGlvbmFsXG4gKiBjb25kaXRpb24gb3IgdGhlIHByZXNlbmNlL2Fic2VuY2Ugb2YgdGhlIGNsYXNzIG5hbWUuXG4gKlxuICogQGJvcnJvd3MgZG9tOnRvZ2dsZUVsQ2xhc3MgYXMgdmlkZW9qcy50b2dnbGVDbGFzc1xuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLnRvZ2dsZUNsYXNzKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogQXBwbHkgYXR0cmlidXRlcyB0byBhbiBIVE1MIGVsZW1lbnQuXG4gKlxuICogQGJvcnJvd3MgZG9tOnNldEVsQXR0cmlidXRlcyBhcyB2aWRlb2pzLnNldEF0dHJpYnV0ZVxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLnNldEF0dHJpYnV0ZXMoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZSB2YWx1ZXMsIGFzIGRlZmluZWQgb24gdGhlIEhUTUwgdGFnXG4gKiBBdHRyaWJ1dGVzIGFyZSBub3QgdGhlIHNhbWUgYXMgcHJvcGVydGllcy4gVGhleSdyZSBkZWZpbmVkIG9uIHRoZSB0YWdcbiAqIG9yIHdpdGggc2V0QXR0cmlidXRlICh3aGljaCBzaG91bGRuJ3QgYmUgdXNlZCB3aXRoIEhUTUwpXG4gKiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgb3IgZmFsc2UgZm9yIGJvb2xlYW4gYXR0cmlidXRlcy5cbiAqXG4gKiBAYm9ycm93cyBkb206Z2V0RWxBdHRyaWJ1dGVzIGFzIHZpZGVvanMuZ2V0QXR0cmlidXRlc1xuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmdldEF0dHJpYnV0ZXMoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBFbXB0aWVzIHRoZSBjb250ZW50cyBvZiBhbiBlbGVtZW50LlxuICpcbiAqIEBib3Jyb3dzIGRvbTplbXB0eUVsIGFzIHZpZGVvanMuZW1wdHlFbFxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmVtcHR5RWwoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBOb3JtYWxpemVzIGFuZCBhcHBlbmRzIGNvbnRlbnQgdG8gYW4gZWxlbWVudC5cbiAqXG4gKiBUaGUgY29udGVudCBmb3IgYW4gZWxlbWVudCBjYW4gYmUgcGFzc2VkIGluIG11bHRpcGxlIHR5cGVzIGFuZFxuICogY29tYmluYXRpb25zLCB3aG9zZSBiZWhhdmlvciBpcyBhcyBmb2xsb3dzOlxuICpcbiAqIC0gU3RyaW5nXG4gKiAgIE5vcm1hbGl6ZWQgaW50byBhIHRleHQgbm9kZS5cbiAqXG4gKiAtIEVsZW1lbnQsIFRleHROb2RlXG4gKiAgIFBhc3NlZCB0aHJvdWdoLlxuICpcbiAqIC0gQXJyYXlcbiAqICAgQSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2Ygc3RyaW5ncywgZWxlbWVudHMsIG5vZGVzLCBvciBmdW5jdGlvbnMgKHdoaWNoXG4gKiAgIHJldHVybiBzaW5nbGUgc3RyaW5ncywgZWxlbWVudHMsIG9yIG5vZGVzKS5cbiAqXG4gKiAtIEZ1bmN0aW9uXG4gKiAgIElmIHRoZSBzb2xlIGFyZ3VtZW50LCBpcyBleHBlY3RlZCB0byBwcm9kdWNlIGEgc3RyaW5nLCBlbGVtZW50LFxuICogICBub2RlLCBvciBhcnJheS5cbiAqXG4gKiBAYm9ycm93cyBkb206YXBwZW5kQ29udGVudHMgYXMgdmlkZW9qcy5hcHBlbmRDb250ZXRcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5hcHBlbmRDb250ZW50KCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogTm9ybWFsaXplcyBhbmQgaW5zZXJ0cyBjb250ZW50IGludG8gYW4gZWxlbWVudDsgdGhpcyBpcyBpZGVudGljYWwgdG9cbiAqIGBhcHBlbmRDb250ZW50KClgLCBleGNlcHQgaXQgZW1wdGllcyB0aGUgZWxlbWVudCBmaXJzdC5cbiAqXG4gKiBUaGUgY29udGVudCBmb3IgYW4gZWxlbWVudCBjYW4gYmUgcGFzc2VkIGluIG11bHRpcGxlIHR5cGVzIGFuZFxuICogY29tYmluYXRpb25zLCB3aG9zZSBiZWhhdmlvciBpcyBhcyBmb2xsb3dzOlxuICpcbiAqIC0gU3RyaW5nXG4gKiAgIE5vcm1hbGl6ZWQgaW50byBhIHRleHQgbm9kZS5cbiAqXG4gKiAtIEVsZW1lbnQsIFRleHROb2RlXG4gKiAgIFBhc3NlZCB0aHJvdWdoLlxuICpcbiAqIC0gQXJyYXlcbiAqICAgQSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2Ygc3RyaW5ncywgZWxlbWVudHMsIG5vZGVzLCBvciBmdW5jdGlvbnMgKHdoaWNoXG4gKiAgIHJldHVybiBzaW5nbGUgc3RyaW5ncywgZWxlbWVudHMsIG9yIG5vZGVzKS5cbiAqXG4gKiAtIEZ1bmN0aW9uXG4gKiAgIElmIHRoZSBzb2xlIGFyZ3VtZW50LCBpcyBleHBlY3RlZCB0byBwcm9kdWNlIGEgc3RyaW5nLCBlbGVtZW50LFxuICogICBub2RlLCBvciBhcnJheS5cbiAqXG4gKiBAYm9ycm93cyBkb206aW5zZXJ0Q29udGVudCBhcyB2aWRlb2pzLmluc2VydENvbnRlbnRcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5pbnNlcnRDb250ZW50KCkgaW5zdGVhZFxuICovXG5bJ2lzRWwnLCAnaXNUZXh0Tm9kZScsICdjcmVhdGVFbCcsICdoYXNDbGFzcycsICdhZGRDbGFzcycsICdyZW1vdmVDbGFzcycsICd0b2dnbGVDbGFzcycsICdzZXRBdHRyaWJ1dGVzJywgJ2dldEF0dHJpYnV0ZXMnLCAnZW1wdHlFbCcsICdhcHBlbmRDb250ZW50JywgJ2luc2VydENvbnRlbnQnXS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gIHZpZGVvanNba10gPSBmdW5jdGlvbiAoKSB7XG4gICAgbG9nJDEud2FybigndmlkZW9qcy4nICsgayArICcoKSBpcyBkZXByZWNhdGVkOyB1c2UgdmlkZW9qcy5kb20uJyArIGsgKyAnKCkgaW5zdGVhZCcpO1xuICAgIHJldHVybiBEb21ba10uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIEEgc2FmZSBnZXRDb21wdXRlZFN0eWxlIHdpdGggYW4gSUU4IGZhbGxiYWNrLlxuICpcbiAqIFRoaXMgaXMgYmVjYXVzZSBpbiBGaXJlZm94LCBpZiB0aGUgcGxheWVyIGlzIGxvYWRlZCBpbiBhbiBpZnJhbWUgd2l0aCBgZGlzcGxheTpub25lYCxcbiAqIHRoZW4gYGdldENvbXB1dGVkU3R5bGVgIHJldHVybnMgYG51bGxgLCBzbywgd2UgZG8gYSBudWxsLWNoZWNrIHRvIG1ha2Ugc3VyZVxuICogdGhhdCB0aGUgcGxheWVyIGRvZXNuJ3QgYnJlYWsgaW4gdGhlc2UgY2FzZXMuXG4gKiBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQGJvcnJvd3MgY29tcHV0ZWQtc3R5bGU6Y29tcHV0ZWRTdHlsZSBhcyB2aWRlb2pzLmNvbXB1dGVkU3R5bGVcbiAqL1xudmlkZW9qcy5jb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcblxuLyoqXG4gKiBFeHBvcnQgdGhlIERvbSB1dGlsaXRpZXMgZm9yIHVzZSBpbiBleHRlcm5hbCBwbHVnaW5zXG4gKiBhbmQgVGVjaCdzXG4gKi9cbnZpZGVvanMuZG9tID0gRG9tO1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgVXJsIHV0aWxpdGllcyBmb3IgdXNlIGluIGV4dGVybmFsIHBsdWdpbnNcbiAqIGFuZCBUZWNoJ3NcbiAqL1xudmlkZW9qcy51cmwgPSBVcmw7XG5cbm1vZHVsZS5leHBvcnRzID0gdmlkZW9qcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3ZpZGVvLmpzL2Rpc3QvdmlkZW8uY2pzLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){eval('var win;\n\nif (typeof window !== "undefined") {\n    win = window;\n} else if (false) {\n    win = global;\n} else if (typeof self !== "undefined"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanM/YzgzNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB3aW47XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgd2luID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgd2luID0ge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n')},function(module,exports){eval("module.exports = isFunction\n\nvar toString = Object.prototype.toString\n\nfunction isFunction (fn) {\n  var string = toString.call(fn)\n  return string === '[object Function]' ||\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\n    (typeof window !== 'undefined' &&\n     // IE8 and below\n     (fn === window.setTimeout ||\n      fn === window.alert ||\n      fn === window.confirm ||\n      fn === window.prompt))\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL2lzLWZ1bmN0aW9uL2luZGV4LmpzPzNlZjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHN0cmluZyA9IHRvU3RyaW5nLmNhbGwoZm4pXG4gIHJldHVybiBzdHJpbmcgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgfHxcbiAgICAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHN0cmluZyAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHx8XG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgIC8vIElFOCBhbmQgYmVsb3dcbiAgICAgKGZuID09PSB3aW5kb3cuc2V0VGltZW91dCB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5hbGVydCB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5jb25maXJtIHx8XG4gICAgICBmbiA9PT0gd2luZG93LnByb21wdCkpXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL2lzLWZ1bmN0aW9uL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")},function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn "@media " + item[2] + "{" + content + "}";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join("");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === "string")\n\t\t\tmodules = [[null, modules, ""]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === "number")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || \'\';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === \'function\') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn \'/*# sourceURL=\' + cssMapping.sourceRoot + source + \' */\'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n\t}\n\n\treturn [content].join(\'\\n\');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = \'sourceMappingURL=data:application/json;charset=utf-8;base64,\' + base64;\n\n\treturn \'/*# \' + data + \' */\';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MTU5ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n')},function(module,exports,__webpack_require__){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === "undefined") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === "undefined") {\n\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t}\n\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(24);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== "undefined" && DEBUG) {\n\t\tif (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === "object" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton) options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = "head";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = "bottom";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error("Couldn\'t find a style target. This probably means that the value for the \'insertInto\' parameter is invalid.");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === "top") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === "bottom") {\n\t\ttarget.appendChild(style);\n\t} else {\n\t\tthrow new Error("Invalid value for parameter \'insertAt\'. Must be \'top\' or \'bottom\'.");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement("style");\n\n\toptions.attrs.type = "text/css";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement("link");\n\n\toptions.attrs.type = "text/css";\n\toptions.attrs.rel = "stylesheet";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don\'t add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === "function" &&\n\t\ttypeof URL.createObjectURL === "function" &&\n\t\ttypeof URL.revokeObjectURL === "function" &&\n\t\ttypeof Blob === "function" &&\n\t\ttypeof btoa === "function"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join(\'\\n\');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? "" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute("media", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn\'t defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";\n\t}\n\n\tvar blob = new Blob([css], { type: "text/css" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/MzEzMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQSxtQkFBbUIsMkJBQTJCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBOztBQUVBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQsa0RBQWtELHNCQUFzQjtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUEsNkJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0bWVtb1tzZWxlY3Rvcl0gPSBmbi5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWVtb1tzZWxlY3Rvcl1cblx0fTtcbn0pKGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KVxufSk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n')},function(n,t,e){n.exports=e(6)},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // import  videojs from './lib/videojs/video.js'\n// require('./lib/videojs/video-js.css')\n\nvar _video = __webpack_require__(0);\n\nvar _video2 = _interopRequireDefault(_video);\n\n__webpack_require__(20);\n\n__webpack_require__(25);\n\n__webpack_require__(28);\n\nvar _vplayerCounter = __webpack_require__(30);\n\nvar _vplayerCounter2 = _interopRequireDefault(_vplayerCounter);\n\nvar _vplayerLinkProtecter = __webpack_require__(31);\n\nvar _vplayerLinkProtecter2 = _interopRequireDefault(_vplayerLinkProtecter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// require('videojs-flash');\nwindow.videojs = _video2.default;\n\n\n__webpack_require__(32);\n// import 'videojs-contrib-hls/dist/videojs-contrib-hls';\n// import  'videojs-contrib-hls';\n\n\n_video2.default.registerPlugin('counter', _vplayerCounter2.default);\n_video2.default.registerPlugin('linkProtecter', _vplayerLinkProtecter2.default);\n\n_video2.default.options.html5.nativeAudioTracks = false;\n_video2.default.options.html5.nativeVideoTracks = false;\n\n_video2.default.Hls.xhr.beforeRequest = function (options) {\n\t// 纠正uri\n\tif (/(\\/group\\d+\\/).+\\1/.test(options.uri)) {\n\t\toptions.uri = options.uri.replace(/\\/group\\d+\\/.+(?=\\/group\\d\\/)/, '');\n\t}\n\t// fdfs.test.ximalaya.com/group1/M01/50/76/wKgD3lnOBhaADk7MAAAA0Qr7A-I19.m3u8\n\t// group1/M01/51/C1/wKgDplnODUaAcfDWAAAKm8Nzv9k33.m3u8\n\t// console.log(options.uri)\n\treturn options;\n};\n\nvar gId = 0;\n\nvar VPlayer = function () {\n\tfunction VPlayer(option) {\n\t\tvar _defaultOption,\n\t\t    _this = this;\n\n\t\t_classCallCheck(this, VPlayer);\n\n\t\tvar defaultOption = (_defaultOption = {\n\t\t\tautoplay: false,\n\t\t\tcontrols: true,\n\t\t\tloop: false,\n\t\t\tmuted: false,\n\t\t\tposter: '',\n\t\t\tpreload: 'auto',\n\t\t\taspectRatio: '16:9',\n\t\t\tfluid: true,\n\t\t\tinactivityTimeout: 0,\n\t\t\tlanguage: 'cn',\n\t\t\ttechOrder: ['flash', 'html5'],\n\t\t\tplugins: {\n\t\t\t\t// counter: {\n\t\t\t\t//     playStart: 'http://game.test.ximalaya.com/api/spread_banner/home_page',\n\t\t\t\t//     playEnd: '/api/count/',\n\t\t\t\t//     transformUrl(type, url) {\n\n\t\t\t\t//     }\n\t\t\t\t// },\n\t\t\t\tlinkProtecter: {\n\t\t\t\t\tlinkProtecterQuery: 'http://training.test.ximalaya.com/co-pcs/play/lesson/video/{lessonId}',\n\t\t\t\t\tlinkProtecterCDN: '',\n\t\t\t\t\tisBackend: false,\n\t\t\t\t\taccountInfo: {\n\t\t\t\t\t\tuid: 129\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t// playbackRates: [0.5, 1, 1.5, 2],\n\t\t\tcontrolBar: {\n\t\t\t\tvolumePanel: {\n\t\t\t\t\tinline: false\n\t\t\t\t},\n\t\t\t\tcurrentTimeDisplay: {},\n\t\t\t\tchildren: ['playToggle', 'volumePanel', 'currentTimeDisplay',\n\t\t\t\t// 'timeDivider',\n\t\t\t\t'progressControl', 'durationDisplay', 'liveDisplay',\n\t\t\t\t// 'remainingTimeDisplay',\n\t\t\t\t'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subsCapsButton', 'audioTrackButton', 'fullscreenToggle']\n\t\t\t}\n\t\t}, _defineProperty(_defaultOption, 'techOrder', ['html5', 'flash']), _defineProperty(_defaultOption, 'html5', {\n\t\t\thls: {\n\t\t\t\toverrideNative: true\n\t\t\t\t// blacklistDuration:10,\n\t\t\t\t// withCredentials: true\n\t\t\t}\n\t\t}), _defaultOption);\n\n\t\tthis._videojs = _video2.default;\n\t\tthis.option = Object.assign(defaultOption, option);\n\n\t\tthis.setUp(this.option.el);\n\n\t\tthis.player.on('error', function () {\n\t\t\tconsole.log(_this.player.error());\n\t\t});\n\t}\n\n\t// 初始化\n\n\n\t_createClass(VPlayer, [{\n\t\tkey: 'setUp',\n\t\tvalue: function setUp(el) {\n\t\t\tif (!el) {\n\t\t\t\tconsole.log('init failed, video element not found!');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tel.className = 'video-js vjs-big-play-centered';\n\n\t\t\tthis.playerId = 'vplayer' + gId++;\n\t\t\tel.setAttribute('data-pid', this.playerId);\n\n\t\t\tthis.player = (0, _video2.default)(el, this.option, function () {\n\n\t\t\t\t// var model = this.player.createModal('',{\n\t\t\t\t// \ttemporary:true,\n\t\t\t\t// \tuncloseable:false,\n\t\t\t\t// });\n\n\t\t\t\t// model.on('modalclose',()=>{\n\t\t\t\t// \tthis.player.play()\n\t\t\t\t// })\n\t\t\t\t// console.log('init player')\n\t\t\t\t// \n\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: '_getSource',\n\t\tvalue: function _getSource(uri) {\n\t\t\tvar type = 'video/mp4';\n\n\t\t\tif (/.*(?=\\.m3u8)/.test(uri)) {\n\t\t\t\ttype = 'application/x-mpegurl';\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: type,\n\t\t\t\tsrc: uri\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: 'getState',\n\t\tvalue: function getState() {\n\t\t\tvar p = this.player;\n\t\t\treturn {\n\t\t\t\treadyState: p.readyState(),\n\t\t\t\tposter: p.poster(),\n\t\t\t\tvideoHeight: p.videoHeight(),\n\t\t\t\tvideoWidth: p.videoWidth(),\n\t\t\t\tcurrentHeight: p.currentHeight(),\n\t\t\t\tcurrentWidth: p.currentWidth(),\n\t\t\t\twidth: p.width(),\n\t\t\t\theight: p.height(),\n\t\t\t\tmuted: p.muted(),\n\t\t\t\tvolume: p.volume(),\n\t\t\t\tcontrols: p.controls(),\n\t\t\t\tloop: p.loop(),\n\t\t\t\tended: p.ended(),\n\t\t\t\tseekable: p.seekable(),\n\t\t\t\tplayed: p.played(),\n\t\t\t\tpaused: p.paused(),\n\t\t\t\tplaybackRate: p.playbackRate(),\n\t\t\t\tdefaultPlaybackRate: p.defaultPlaybackRate(),\n\t\t\t\tduration: p.duration(),\n\t\t\t\tcurrentTime: p.currentTime(),\n\t\t\t\tseeking: p.seeking(),\n\t\t\t\tbuffered: p.buffered(),\n\t\t\t\tnetworkState: p.networkState(),\n\t\t\t\tcurrentSrc: p.currentSrc()\n\t\t\t};\n\t\t}\n\n\t\t// 播放\n\n\t}, {\n\t\tkey: 'play',\n\t\tvalue: function play(video) {\n\t\t\tvar _this2 = this;\n\n\t\t\tif (video) {\n\t\t\t\tif (!video.src) {\n\t\t\t\t\tthis.player.linkProtecter().query(video, function () {\n\t\t\t\t\t\t_this2.play(video);\n\t\t\t\t\t}, function (data) {\n\t\t\t\t\t\t_this2.player.trigger('PAY_LISTEN_ERROR', data);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// video.src = 'http://fdfs.test.ximalaya.com/group1/M01/50/76/wKgD3lnOBhaADk7MAAAA0Qr7A-I19.m3u8';\n\t\t\t\t\tthis.player.src(this._getSource(video.src));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.player.play();\n\t\t\t}\n\t\t}\n\n\t\t// 暂停\n\n\t}, {\n\t\tkey: 'pause',\n\t\tvalue: function pause() {\n\t\t\tthis.player.pause();\n\t\t}\n\n\t\t/**\n   * [get/set 音量]\n   * @author jason.chen on 2017-09-14\n   * @param  {[type]} val [0-1]\n   * @return {[type]}     [description]\n   */\n\n\t}, {\n\t\tkey: 'volume',\n\t\tvalue: function volume(val) {\n\t\t\tif (val) {\n\t\t\t\tthis.player.volume(val);\n\t\t\t} else {\n\t\t\t\treturn this.player.volume();\n\t\t\t}\n\t\t}\n\t\t/**\n   * [muted get/set 静音]\n   * @author jason.chen on 2017-09-14\n   * @param  {[type]} val [boolean]\n   * @return {[type]} []\n   */\n\n\t}, {\n\t\tkey: 'muted',\n\t\tvalue: function muted(val) {\n\t\t\tif (typeof val !== 'undefined') {\n\t\t\t\tthis.player.muted(val);\n\t\t\t} else {\n\t\t\t\treturn this.player.muted();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'isFullscreen',\n\t\tvalue: function isFullscreen(val) {\n\t\t\tif (typeof val !== 'undefined') {\n\t\t\t\tthis.player.isFullscreen(val);\n\t\t\t} else {\n\t\t\t\treturn this.player.isFullscreen();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'controls',\n\t\tvalue: function controls(val) {\n\t\t\tif (typeof val === 'undefined') {\n\t\t\t\tthis.player.controls();\n\t\t\t} else {\n\t\t\t\tthis.player.controls(val);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'playbackRate',\n\t\tvalue: function playbackRate(val) {\n\t\t\tif (typeof val === 'undefined') {\n\t\t\t\tthis.player.playbackRate();\n\t\t\t} else {\n\t\t\t\tthis.player.playbackRate(val);\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * [fullscreen 进入/退出 全屏]\n   * @author jason.chen on 2017-09-14\n   * @param  {[type]} val [description]\n   * @return {[type]}     [description]\n   */\n\n\t}, {\n\t\tkey: 'fullscreen',\n\t\tvalue: function fullscreen(val) {\n\t\t\tif (val) {\n\t\t\t\tthis.player.requestFullscreen();\n\t\t\t} else {\n\t\t\t\treturn this.player.exitFullscreen();\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * 设置播放url业务逻辑 优先使用play方法\n   * @author jason.chen on 2017-10-23\n   * @param  {[type]} url [description]\n   * @return {[type]}     [description]\n   */\n\n\t}, {\n\t\tkey: 'currentSrc',\n\t\tvalue: function currentSrc(url) {\n\t\t\tif (url) {\n\t\t\t\tthis.player.src(this._getSource(url));\n\t\t\t} else {\n\t\t\t\treturn this.player.currentSrc();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'currentSource',\n\t\tvalue: function currentSource() {\n\t\t\treturn this.player.currentSource();\n\t\t}\n\t}, {\n\t\tkey: 'currentSources',\n\t\tvalue: function currentSources() {\n\t\t\treturn this.player.currentSources();\n\t\t}\n\n\t\t/**\n   * [loop 设置/获取循环播放]\n   * @author jason.chen on 2017-10-09\n   * @param  {[type]} val [description]\n   * @return {[type]}     [description]\n   */\n\n\t}, {\n\t\tkey: 'loop',\n\t\tvalue: function loop(val) {\n\t\t\tif (val) {\n\t\t\t\tthis.player.loop(val);\n\t\t\t} else {\n\t\t\t\treturn this.player.loop();\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * [poster 设置/获取海报地址]\n   * @author jason.chen on 2017-09-14\n   * @param {[type]} url [图片URL]\n   * @return {[type]}     [description]\n   */\n\n\t}, {\n\t\tkey: 'poster',\n\t\tvalue: function poster(url) {\n\t\t\tif (url) {\n\t\t\t\tthis.player.poster(url);\n\t\t\t} else {\n\t\t\t\treturn this.player.poster();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'getDuration',\n\t\tvalue: function getDuration() {\n\t\t\treturn this.player.duration();\n\t\t}\n\n\t\t/**\n   * [getBuffered 获取缓存数据]\n   * @author jason.chen on 2017-09-14\n   * // var firstRangeStart = bufferedTimeRange.start(0),\n  \t// // Time in seconds when the first range ends\n  // var firstRangeEnd = bufferedTimeRange.end(0),\n  \t// // Length in seconds of the first time range\n  \t// var firstRangeLength = firstRangeEnd - firstRangeStart;\n  \t * @return {[type]} [description]\n  \t * \n  \t */\n\n\t}, {\n\t\tkey: 'getBufferedInfo',\n\t\tvalue: function getBufferedInfo() {\n\t\t\tvar player = this.player;\n\t\t\treturn {\n\t\t\t\tbuffered: player.buffered(),\n\t\t\t\tbufferedPercent: player.bufferedPercent()\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: 'getRemainingTime',\n\t\tvalue: function getRemainingTime() {\n\t\t\treturn this.player.remainingTime();\n\t\t}\n\t\t/**\n   * [currentTime 设置播放头]\n   * @author jason.chen on 2017-09-14\n   * @param  {[type]} time [ 事件 s]\n   * @return {[type]}      [description]\n   */\n\n\t}, {\n\t\tkey: 'currentTime',\n\t\tvalue: function currentTime(time) {\n\t\t\tif (time) {\n\t\t\t\tthis.player.currentTime(time);\n\t\t\t} else {\n\t\t\t\treturn this.player.currentTime();\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * 设置/获取播放器宽高比 16：9  4：3\n   * @author jason.chen on 2017-10-09\n   * @param  {[type]} val [description]\n   * @return {[type]}     [description]\n   */\n\n\t}, {\n\t\tkey: 'aspectRatio',\n\t\tvalue: function aspectRatio(val) {\n\t\t\tif (val) {\n\t\t\t\tthis.player.aspectRatio(val);\n\t\t\t} else {\n\t\t\t\treturn this.player.aspectRatio();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'dispose',\n\t\tvalue: function dispose() {\n\t\t\tthis.player.dispose();\n\t\t}\n\t}, {\n\t\tkey: 'on',\n\t\tvalue: function on(name, handler) {\n\t\t\tvar _this3 = this;\n\n\t\t\tthis.player.on(name, function () {\n\t\t\t\thandler.call(_this3);\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: 'off',\n\t\tvalue: function off(name, handler) {\n\t\t\tthis.player.off(name, handler);\n\t\t}\n\t}]);\n\n\treturn VPlayer;\n}();\n\n// loadstart play pause playing ended volumechange durationchange error timeupdate progress enterFullScreen exitFullScreen\n\n\n// ready，，ended\n// myPlayer.paused()\n\n// player.on('ended', function() {\n//   this.dispose();\n// });\n\nmodule.exports = VPlayer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdnBsYXllci5qcz80MjI2Il0sIm5hbWVzIjpbIndpbmRvdyIsInZpZGVvanMiLCJyZXF1aXJlIiwicmVnaXN0ZXJQbHVnaW4iLCJvcHRpb25zIiwiaHRtbDUiLCJuYXRpdmVBdWRpb1RyYWNrcyIsIm5hdGl2ZVZpZGVvVHJhY2tzIiwiSGxzIiwieGhyIiwiYmVmb3JlUmVxdWVzdCIsInRlc3QiLCJ1cmkiLCJyZXBsYWNlIiwiZ0lkIiwiVlBsYXllciIsIm9wdGlvbiIsImRlZmF1bHRPcHRpb24iLCJhdXRvcGxheSIsImNvbnRyb2xzIiwibG9vcCIsIm11dGVkIiwicG9zdGVyIiwicHJlbG9hZCIsImFzcGVjdFJhdGlvIiwiZmx1aWQiLCJpbmFjdGl2aXR5VGltZW91dCIsImxhbmd1YWdlIiwidGVjaE9yZGVyIiwicGx1Z2lucyIsImxpbmtQcm90ZWN0ZXIiLCJsaW5rUHJvdGVjdGVyUXVlcnkiLCJsaW5rUHJvdGVjdGVyQ0ROIiwiaXNCYWNrZW5kIiwiYWNjb3VudEluZm8iLCJ1aWQiLCJjb250cm9sQmFyIiwidm9sdW1lUGFuZWwiLCJpbmxpbmUiLCJjdXJyZW50VGltZURpc3BsYXkiLCJjaGlsZHJlbiIsImhscyIsIm92ZXJyaWRlTmF0aXZlIiwiX3ZpZGVvanMiLCJPYmplY3QiLCJhc3NpZ24iLCJzZXRVcCIsImVsIiwicGxheWVyIiwib24iLCJjb25zb2xlIiwibG9nIiwiZXJyb3IiLCJjbGFzc05hbWUiLCJwbGF5ZXJJZCIsInNldEF0dHJpYnV0ZSIsInR5cGUiLCJzcmMiLCJwIiwicmVhZHlTdGF0ZSIsInZpZGVvSGVpZ2h0IiwidmlkZW9XaWR0aCIsImN1cnJlbnRIZWlnaHQiLCJjdXJyZW50V2lkdGgiLCJ3aWR0aCIsImhlaWdodCIsInZvbHVtZSIsImVuZGVkIiwic2Vla2FibGUiLCJwbGF5ZWQiLCJwYXVzZWQiLCJwbGF5YmFja1JhdGUiLCJkZWZhdWx0UGxheWJhY2tSYXRlIiwiZHVyYXRpb24iLCJjdXJyZW50VGltZSIsInNlZWtpbmciLCJidWZmZXJlZCIsIm5ldHdvcmtTdGF0ZSIsImN1cnJlbnRTcmMiLCJ2aWRlbyIsInF1ZXJ5IiwicGxheSIsImRhdGEiLCJ0cmlnZ2VyIiwiX2dldFNvdXJjZSIsInBhdXNlIiwidmFsIiwiaXNGdWxsc2NyZWVuIiwicmVxdWVzdEZ1bGxzY3JlZW4iLCJleGl0RnVsbHNjcmVlbiIsInVybCIsImN1cnJlbnRTb3VyY2UiLCJjdXJyZW50U291cmNlcyIsImJ1ZmZlcmVkUGVyY2VudCIsInJlbWFpbmluZ1RpbWUiLCJ0aW1lIiwiZGlzcG9zZSIsIm5hbWUiLCJoYW5kbGVyIiwiY2FsbCIsIm9mZiIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7O3FqQkFBQTtBQUNBOztBQUVBOzs7O0FBQ0E7O0FBSUE7O0FBS0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OztBQVRBO0FBQ0FBLE9BQU9DLE9BQVA7OztBQUdBLG1CQUFBQyxDQUFRLEVBQVI7QUFDQTtBQUNBOzs7QUFLQSxnQkFBUUMsY0FBUixDQUF1QixTQUF2QjtBQUNBLGdCQUFRQSxjQUFSLENBQXVCLGVBQXZCOztBQUVBLGdCQUFRQyxPQUFSLENBQWdCQyxLQUFoQixDQUFzQkMsaUJBQXRCLEdBQTBDLEtBQTFDO0FBQ0EsZ0JBQVFGLE9BQVIsQ0FBZ0JDLEtBQWhCLENBQXNCRSxpQkFBdEIsR0FBMEMsS0FBMUM7O0FBRUEsZ0JBQVFDLEdBQVIsQ0FBWUMsR0FBWixDQUFnQkMsYUFBaEIsR0FBZ0MsVUFBU04sT0FBVCxFQUFrQjtBQUNqRDtBQUNBLEtBQUkscUJBQXFCTyxJQUFyQixDQUEwQlAsUUFBUVEsR0FBbEMsQ0FBSixFQUE0QztBQUMzQ1IsVUFBUVEsR0FBUixHQUFjUixRQUFRUSxHQUFSLENBQVlDLE9BQVosQ0FBb0IsK0JBQXBCLEVBQXFELEVBQXJELENBQWQ7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQU9ULE9BQVA7QUFDQSxDQVREOztBQVlBLElBQUlVLE1BQU0sQ0FBVjs7SUFFTUMsTztBQUVM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O0FBQ0E7QUFDRDs7Ozs7Ozs7OzhCQU1ZQyxJLEVBQU07QUFDakIsT0FBSUEsSUFBSixFQUFVO0FBQ1QsU0FBSy9DLE1BQUwsQ0FBWTBCLFdBQVosQ0FBd0JxQixJQUF4QjtBQUNBLElBRkQsTUFFTztBQUNOLFdBQU8sS0FBSy9DLE1BQUwsQ0FBWTBCLFdBQVosRUFBUDtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs4QkFNWVksRyxFQUFLO0FBQ2hCLE9BQUlBLEdBQUosRUFBUztBQUNSLFNBQUt0QyxNQUFMLENBQVl4QixXQUFaLENBQXdCOEQsR0FBeEI7QUFDQSxJQUZELE1BRU87QUFDTixXQUFPLEtBQUt0QyxNQUFMLENBQVl4QixXQUFaLEVBQVA7QUFDQTtBQUNEOzs7NEJBRVM7QUFDVCxRQUFLd0IsTUFBTCxDQUFZZ0QsT0FBWjtBQUNBOzs7cUJBRUVDLEksRUFBTUMsTyxFQUFTO0FBQUE7O0FBQ2pCLFFBQUtsRCxNQUFMLENBQVlDLEVBQVosQ0FBZWdELElBQWYsRUFBcUIsWUFBTTtBQUMxQkMsWUFBUUMsSUFBUjtBQUNBLElBRkQ7QUFHQTs7O3NCQUNHRixJLEVBQU1DLE8sRUFBUztBQUNsQixRQUFLbEQsTUFBTCxDQUFZb0QsR0FBWixDQUFnQkgsSUFBaEIsRUFBc0JDLE9BQXRCO0FBQ0E7Ozs7OztBQUdGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQUcsT0FBT0MsT0FBUCxHQUFpQnZGLE9BQWpCIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgIHZpZGVvanMgZnJvbSAnLi9saWIvdmlkZW9qcy92aWRlby5qcydcbi8vIHJlcXVpcmUoJy4vbGliL3ZpZGVvanMvdmlkZW8tanMuY3NzJylcblxuaW1wb3J0IHZpZGVvanMgZnJvbSAndmlkZW8uanMnO1xuaW1wb3J0ICd2aWRlby5qcy9kaXN0L3ZpZGVvLWpzLmNzcyc7XG5cbi8vIHJlcXVpcmUoJ3ZpZGVvanMtZmxhc2gnKTtcbndpbmRvdy52aWRlb2pzID0gdmlkZW9qcztcbmltcG9ydCAndmlkZW9qcy1mbGFzaCc7XG5cbnJlcXVpcmUoJ3ZpZGVvanMtY29udHJpYi1obHMvZGlzdC92aWRlb2pzLWNvbnRyaWItaGxzJyk7XG4vLyBpbXBvcnQgJ3ZpZGVvanMtY29udHJpYi1obHMvZGlzdC92aWRlb2pzLWNvbnRyaWItaGxzJztcbi8vIGltcG9ydCAgJ3ZpZGVvanMtY29udHJpYi1obHMnO1xuaW1wb3J0ICcuL3ZwbGF5ZXIuY3NzJztcbmltcG9ydCBDb3VudGVyIGZyb20gJy4vdnBsYXllci1jb3VudGVyJztcbmltcG9ydCBMaW5rUHJvdGVjdGVyIGZyb20gJy4vdnBsYXllci1saW5rLXByb3RlY3Rlcic7XG5cbnZpZGVvanMucmVnaXN0ZXJQbHVnaW4oJ2NvdW50ZXInLCBDb3VudGVyKTtcbnZpZGVvanMucmVnaXN0ZXJQbHVnaW4oJ2xpbmtQcm90ZWN0ZXInLCBMaW5rUHJvdGVjdGVyKTtcblxudmlkZW9qcy5vcHRpb25zLmh0bWw1Lm5hdGl2ZUF1ZGlvVHJhY2tzID0gZmFsc2U7XG52aWRlb2pzLm9wdGlvbnMuaHRtbDUubmF0aXZlVmlkZW9UcmFja3MgPSBmYWxzZTtcblxudmlkZW9qcy5IbHMueGhyLmJlZm9yZVJlcXVlc3QgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdC8vIOe6oOato3VyaVxuXHRpZiAoLyhcXC9ncm91cFxcZCtcXC8pLitcXDEvLnRlc3Qob3B0aW9ucy51cmkpKSB7XG5cdFx0b3B0aW9ucy51cmkgPSBvcHRpb25zLnVyaS5yZXBsYWNlKC9cXC9ncm91cFxcZCtcXC8uKyg/PVxcL2dyb3VwXFxkXFwvKS8sICcnKTtcblx0fVxuXHQvLyBmZGZzLnRlc3QueGltYWxheWEuY29tL2dyb3VwMS9NMDEvNTAvNzYvd0tnRDNsbk9CaGFBRGs3TUFBQUEwUXI3QS1JMTkubTN1OFxuXHQvLyBncm91cDEvTTAxLzUxL0MxL3dLZ0RwbG5PRFVhQWNmRFdBQUFLbThOenY5azMzLm0zdThcblx0Ly8gY29uc29sZS5sb2cob3B0aW9ucy51cmkpXG5cdHJldHVybiBvcHRpb25zO1xufTtcblxuXG5sZXQgZ0lkID0gMDtcblxuY2xhc3MgVlBsYXllciB7XG5cblx0Y29uc3RydWN0b3Iob3B0aW9uKSB7XG5cdFx0bGV0IGRlZmF1bHRPcHRpb24gPSB7XG5cdFx0XHRhdXRvcGxheTogZmFsc2UsXG5cdFx0XHRjb250cm9sczogdHJ1ZSxcblx0XHRcdGxvb3A6IGZhbHNlLFxuXHRcdFx0bXV0ZWQ6IGZhbHNlLFxuXHRcdFx0cG9zdGVyOiAnJyxcblx0XHRcdHByZWxvYWQ6ICdhdXRvJyxcblx0XHRcdGFzcGVjdFJhdGlvOiAnMTY6OScsXG5cdFx0XHRmbHVpZDogdHJ1ZSxcblx0XHRcdGluYWN0aXZpdHlUaW1lb3V0OiAwLFxuXHRcdFx0bGFuZ3VhZ2U6ICdjbicsXG5cdFx0XHR0ZWNoT3JkZXI6IFsnZmxhc2gnLCAnaHRtbDUnXSxcblx0XHRcdHBsdWdpbnM6IHtcblx0XHRcdFx0Ly8gY291bnRlcjoge1xuXHRcdFx0XHQvLyAgICAgcGxheVN0YXJ0OiAnaHR0cDovL2dhbWUudGVzdC54aW1hbGF5YS5jb20vYXBpL3NwcmVhZF9iYW5uZXIvaG9tZV9wYWdlJyxcblx0XHRcdFx0Ly8gICAgIHBsYXlFbmQ6ICcvYXBpL2NvdW50LycsXG5cdFx0XHRcdC8vICAgICB0cmFuc2Zvcm1VcmwodHlwZSwgdXJsKSB7XG5cblx0XHRcdFx0Ly8gICAgIH1cblx0XHRcdFx0Ly8gfSxcblx0XHRcdFx0bGlua1Byb3RlY3Rlcjoge1xuXHRcdFx0XHRcdGxpbmtQcm90ZWN0ZXJRdWVyeTogJ2h0dHA6Ly90cmFpbmluZy50ZXN0LnhpbWFsYXlhLmNvbS9jby1wY3MvcGxheS9sZXNzb24vdmlkZW8ve2xlc3NvbklkfScsXG5cdFx0XHRcdFx0bGlua1Byb3RlY3RlckNETjogJycsXG5cdFx0XHRcdFx0aXNCYWNrZW5kOiBmYWxzZSxcblx0XHRcdFx0XHRhY2NvdW50SW5mbzoge1xuXHRcdFx0XHRcdFx0dWlkOiAxMjlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvLyBwbGF5YmFja1JhdGVzOiBbMC41LCAxLCAxLjUsIDJdLFxuXHRcdFx0Y29udHJvbEJhcjoge1xuXHRcdFx0XHR2b2x1bWVQYW5lbDoge1xuXHRcdFx0XHRcdGlubGluZTogZmFsc2Vcblx0XHRcdFx0fSxcblx0XHRcdFx0Y3VycmVudFRpbWVEaXNwbGF5OiB7fSxcblx0XHRcdFx0Y2hpbGRyZW46IFtcblx0XHRcdFx0XHQncGxheVRvZ2dsZScsXG5cdFx0XHRcdFx0J3ZvbHVtZVBhbmVsJyxcblx0XHRcdFx0XHQnY3VycmVudFRpbWVEaXNwbGF5Jyxcblx0XHRcdFx0XHQvLyAndGltZURpdmlkZXInLFxuXHRcdFx0XHRcdCdwcm9ncmVzc0NvbnRyb2wnLFxuXHRcdFx0XHRcdCdkdXJhdGlvbkRpc3BsYXknLFxuXHRcdFx0XHRcdCdsaXZlRGlzcGxheScsXG5cdFx0XHRcdFx0Ly8gJ3JlbWFpbmluZ1RpbWVEaXNwbGF5Jyxcblx0XHRcdFx0XHQnY3VzdG9tQ29udHJvbFNwYWNlcicsXG5cdFx0XHRcdFx0J3BsYXliYWNrUmF0ZU1lbnVCdXR0b24nLFxuXHRcdFx0XHRcdCdjaGFwdGVyc0J1dHRvbicsXG5cdFx0XHRcdFx0J2Rlc2NyaXB0aW9uc0J1dHRvbicsXG5cdFx0XHRcdFx0J3N1YnNDYXBzQnV0dG9uJyxcblx0XHRcdFx0XHQnYXVkaW9UcmFja0J1dHRvbicsXG5cdFx0XHRcdFx0J2Z1bGxzY3JlZW5Ub2dnbGUnXG5cdFx0XHRcdF1cblx0XHRcdH0sXG5cdFx0XHQvLyBlcnJvckRpc3BsYXk6ZmFsc2UsXG5cdFx0XHR0ZWNoT3JkZXI6IFsnaHRtbDUnLCAnZmxhc2gnXSxcblx0XHRcdGh0bWw1OiB7XG5cdFx0XHRcdGhsczoge1xuXHRcdFx0XHRcdG92ZXJyaWRlTmF0aXZlOiB0cnVlLFxuXHRcdFx0XHRcdC8vIGJsYWNrbGlzdER1cmF0aW9uOjEwLFxuXHRcdFx0XHRcdC8vIHdpdGhDcmVkZW50aWFsczogdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fdmlkZW9qcyA9IHZpZGVvanM7XG5cdFx0dGhpcy5vcHRpb24gPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb24sIG9wdGlvbik7XG5cblx0XHR0aGlzLnNldFVwKHRoaXMub3B0aW9uLmVsKTtcblxuXHRcdHRoaXMucGxheWVyLm9uKCdlcnJvcicsICgpID0+IHtcblx0XHRcdGNvbnNvbGUubG9nKHRoaXMucGxheWVyLmVycm9yKCkpXG5cdFx0fSk7XG5cdH1cblxuXHQvLyDliJ3lp4vljJZcblx0c2V0VXAoZWwpIHtcblx0XHRpZighZWwpe1xuXHRcdFx0Y29uc29sZS5sb2coJ2luaXQgZmFpbGVkLCB2aWRlbyBlbGVtZW50IG5vdCBmb3VuZCEnKVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0ZWwuY2xhc3NOYW1lID0gJ3ZpZGVvLWpzIHZqcy1iaWctcGxheS1jZW50ZXJlZCc7XG5cblx0XHR0aGlzLnBsYXllcklkID0gYHZwbGF5ZXIke2dJZCsrfWA7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKCdkYXRhLXBpZCcsIHRoaXMucGxheWVySWQpO1xuXG5cblx0XHR0aGlzLnBsYXllciA9IHZpZGVvanMoZWwsIHRoaXMub3B0aW9uLCAoKSA9PiB7XG5cblx0XHRcdC8vIHZhciBtb2RlbCA9IHRoaXMucGxheWVyLmNyZWF0ZU1vZGFsKCcnLHtcblx0XHRcdC8vIFx0dGVtcG9yYXJ5OnRydWUsXG5cdFx0XHQvLyBcdHVuY2xvc2VhYmxlOmZhbHNlLFxuXHRcdFx0Ly8gfSk7XG5cblx0XHRcdC8vIG1vZGVsLm9uKCdtb2RhbGNsb3NlJywoKT0+e1xuXHRcdFx0Ly8gXHR0aGlzLnBsYXllci5wbGF5KClcblx0XHRcdC8vIH0pXG5cdFx0XHQvLyBjb25zb2xlLmxvZygnaW5pdCBwbGF5ZXInKVxuXHRcdFx0Ly8gXG5cblx0XHR9KTtcblx0fVxuXG5cdF9nZXRTb3VyY2UodXJpKSB7XG5cdFx0bGV0IHR5cGUgPSAndmlkZW8vbXA0JztcblxuXHRcdGlmICgvLiooPz1cXC5tM3U4KS8udGVzdCh1cmkpKSB7XG5cdFx0XHR0eXBlID0gJ2FwcGxpY2F0aW9uL3gtbXBlZ3VybCdcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGUsXG5cdFx0XHRzcmM6IHVyaVxuXHRcdH07XG5cdH1cblxuXHRnZXRTdGF0ZSgpIHtcblx0XHRsZXQgcCA9IHRoaXMucGxheWVyO1xuXHRcdHJldHVybiB7XG5cdFx0XHRyZWFkeVN0YXRlOiBwLnJlYWR5U3RhdGUoKSxcblx0XHRcdHBvc3RlcjogcC5wb3N0ZXIoKSxcblx0XHRcdHZpZGVvSGVpZ2h0OiBwLnZpZGVvSGVpZ2h0KCksXG5cdFx0XHR2aWRlb1dpZHRoOiBwLnZpZGVvV2lkdGgoKSxcblx0XHRcdGN1cnJlbnRIZWlnaHQ6IHAuY3VycmVudEhlaWdodCgpLFxuXHRcdFx0Y3VycmVudFdpZHRoOiBwLmN1cnJlbnRXaWR0aCgpLFxuXHRcdFx0d2lkdGg6IHAud2lkdGgoKSxcblx0XHRcdGhlaWdodDogcC5oZWlnaHQoKSxcblx0XHRcdG11dGVkOiBwLm11dGVkKCksXG5cdFx0XHR2b2x1bWU6IHAudm9sdW1lKCksXG5cdFx0XHRjb250cm9sczogcC5jb250cm9scygpLFxuXHRcdFx0bG9vcDogcC5sb29wKCksXG5cdFx0XHRlbmRlZDogcC5lbmRlZCgpLFxuXHRcdFx0c2Vla2FibGU6IHAuc2Vla2FibGUoKSxcblx0XHRcdHBsYXllZDogcC5wbGF5ZWQoKSxcblx0XHRcdHBhdXNlZDogcC5wYXVzZWQoKSxcblx0XHRcdHBsYXliYWNrUmF0ZTogcC5wbGF5YmFja1JhdGUoKSxcblx0XHRcdGRlZmF1bHRQbGF5YmFja1JhdGU6IHAuZGVmYXVsdFBsYXliYWNrUmF0ZSgpLFxuXHRcdFx0ZHVyYXRpb246IHAuZHVyYXRpb24oKSxcblx0XHRcdGN1cnJlbnRUaW1lOiBwLmN1cnJlbnRUaW1lKCksXG5cdFx0XHRzZWVraW5nOiBwLnNlZWtpbmcoKSxcblx0XHRcdGJ1ZmZlcmVkOiBwLmJ1ZmZlcmVkKCksXG5cdFx0XHRuZXR3b3JrU3RhdGU6IHAubmV0d29ya1N0YXRlKCksXG5cdFx0XHRjdXJyZW50U3JjOiBwLmN1cnJlbnRTcmMoKVxuXHRcdH1cblx0fVxuXG5cdC8vIOaSreaUvlxuXHRwbGF5KHZpZGVvKSB7XG5cdFx0aWYgKHZpZGVvKSB7XG5cdFx0XHRpZiAoIXZpZGVvLnNyYykge1xuXHRcdFx0XHR0aGlzLnBsYXllci5saW5rUHJvdGVjdGVyKCkucXVlcnkodmlkZW8sICgpID0+IHtcblx0XHRcdFx0XHR0aGlzLnBsYXkodmlkZW8pO1xuXHRcdFx0XHR9LCAoZGF0YSkgPT4ge1xuXHRcdFx0XHRcdHRoaXMucGxheWVyLnRyaWdnZXIoJ1BBWV9MSVNURU5fRVJST1InLCBkYXRhKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB2aWRlby5zcmMgPSAnaHR0cDovL2ZkZnMudGVzdC54aW1hbGF5YS5jb20vZ3JvdXAxL00wMS81MC83Ni93S2dEM2xuT0JoYUFEazdNQUFBQTBRcjdBLUkxOS5tM3U4Jztcblx0XHRcdFx0dGhpcy5wbGF5ZXIuc3JjKHRoaXMuX2dldFNvdXJjZSh2aWRlby5zcmMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wbGF5ZXIucGxheSgpO1xuXHRcdH1cblx0fVxuXG5cdC8vIOaaguWBnFxuXHRwYXVzZSgpIHtcblx0XHR0aGlzLnBsYXllci5wYXVzZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFtnZXQvc2V0IOmfs+mHj11cblx0ICogQGF1dGhvciBqYXNvbi5jaGVuIG9uIDIwMTctMDktMTRcblx0ICogQHBhcmFtICB7W3R5cGVdfSB2YWwgWzAtMV1cblx0ICogQHJldHVybiB7W3R5cGVdfSAgICAgW2Rlc2NyaXB0aW9uXVxuXHQgKi9cblx0dm9sdW1lKHZhbCkge1xuXHRcdGlmICh2YWwpIHtcblx0XHRcdHRoaXMucGxheWVyLnZvbHVtZSh2YWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wbGF5ZXIudm9sdW1lKCk7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQgKiBbbXV0ZWQgZ2V0L3NldCDpnZnpn7NdXG5cdCAqIEBhdXRob3IgamFzb24uY2hlbiBvbiAyMDE3LTA5LTE0XG5cdCAqIEBwYXJhbSAge1t0eXBlXX0gdmFsIFtib29sZWFuXVxuXHQgKiBAcmV0dXJuIHtbdHlwZV19IFtdXG5cdCAqL1xuXHRtdXRlZCh2YWwpIHtcblx0XHRpZiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRoaXMucGxheWVyLm11dGVkKHZhbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLnBsYXllci5tdXRlZCgpO1xuXHRcdH1cblx0fVxuXG5cdGlzRnVsbHNjcmVlbih2YWwpIHtcblx0XHRpZiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRoaXMucGxheWVyLmlzRnVsbHNjcmVlbih2YWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wbGF5ZXIuaXNGdWxsc2NyZWVuKCk7XG5cdFx0fVxuXHR9XG5cblx0Y29udHJvbHModmFsKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aGlzLnBsYXllci5jb250cm9scygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBsYXllci5jb250cm9scyh2YWwpXG5cdFx0fVxuXHR9XG5cblx0cGxheWJhY2tSYXRlKHZhbCkge1xuXHRcdGlmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhpcy5wbGF5ZXIucGxheWJhY2tSYXRlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucGxheWVyLnBsYXliYWNrUmF0ZSh2YWwpXG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFtmdWxsc2NyZWVuIOi/m+WFpS/pgIDlh7og5YWo5bGPXVxuXHQgKiBAYXV0aG9yIGphc29uLmNoZW4gb24gMjAxNy0wOS0xNFxuXHQgKiBAcGFyYW0gIHtbdHlwZV19IHZhbCBbZGVzY3JpcHRpb25dXG5cdCAqIEByZXR1cm4ge1t0eXBlXX0gICAgIFtkZXNjcmlwdGlvbl1cblx0ICovXG5cdGZ1bGxzY3JlZW4odmFsKSB7XG5cdFx0aWYgKHZhbCkge1xuXHRcdFx0dGhpcy5wbGF5ZXIucmVxdWVzdEZ1bGxzY3JlZW4oKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMucGxheWVyLmV4aXRGdWxsc2NyZWVuKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIOiuvue9ruaSreaUvnVybOS4muWKoemAu+i+kSDkvJjlhYjkvb/nlKhwbGF55pa55rOVXG5cdCAqIEBhdXRob3IgamFzb24uY2hlbiBvbiAyMDE3LTEwLTIzXG5cdCAqIEBwYXJhbSAge1t0eXBlXX0gdXJsIFtkZXNjcmlwdGlvbl1cblx0ICogQHJldHVybiB7W3R5cGVdfSAgICAgW2Rlc2NyaXB0aW9uXVxuXHQgKi9cblx0Y3VycmVudFNyYyh1cmwpIHtcblx0XHRpZiAodXJsKSB7XG5cdFx0XHR0aGlzLnBsYXllci5zcmModGhpcy5fZ2V0U291cmNlKHVybCkpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLnBsYXllci5jdXJyZW50U3JjKCk7XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudFNvdXJjZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5wbGF5ZXIuY3VycmVudFNvdXJjZSgpO1xuXHR9XG5cblx0Y3VycmVudFNvdXJjZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMucGxheWVyLmN1cnJlbnRTb3VyY2VzKCk7XG5cdH1cblxuXHQvKipcblx0ICogW2xvb3Ag6K6+572uL+iOt+WPluW+queOr+aSreaUvl1cblx0ICogQGF1dGhvciBqYXNvbi5jaGVuIG9uIDIwMTctMTAtMDlcblx0ICogQHBhcmFtICB7W3R5cGVdfSB2YWwgW2Rlc2NyaXB0aW9uXVxuXHQgKiBAcmV0dXJuIHtbdHlwZV19ICAgICBbZGVzY3JpcHRpb25dXG5cdCAqL1xuXHRsb29wKHZhbCkge1xuXHRcdGlmICh2YWwpIHtcblx0XHRcdHRoaXMucGxheWVyLmxvb3AodmFsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMucGxheWVyLmxvb3AoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogW3Bvc3RlciDorr7nva4v6I635Y+W5rW35oql5Zyw5Z2AXVxuXHQgKiBAYXV0aG9yIGphc29uLmNoZW4gb24gMjAxNy0wOS0xNFxuXHQgKiBAcGFyYW0ge1t0eXBlXX0gdXJsIFvlm77niYdVUkxdXG5cdCAqIEByZXR1cm4ge1t0eXBlXX0gICAgIFtkZXNjcmlwdGlvbl1cblx0ICovXG5cdHBvc3Rlcih1cmwpIHtcblx0XHRpZiAodXJsKSB7XG5cdFx0XHR0aGlzLnBsYXllci5wb3N0ZXIodXJsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMucGxheWVyLnBvc3RlcigpO1xuXHRcdH1cblx0fVxuXG5cdGdldER1cmF0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnBsYXllci5kdXJhdGlvbigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFtnZXRCdWZmZXJlZCDojrflj5bnvJPlrZjmlbDmja5dXG5cdCAqIEBhdXRob3IgamFzb24uY2hlbiBvbiAyMDE3LTA5LTE0XG5cdCAqIC8vIHZhciBmaXJzdFJhbmdlU3RhcnQgPSBidWZmZXJlZFRpbWVSYW5nZS5zdGFydCgwKSxcblxuXHQvLyAvLyBUaW1lIGluIHNlY29uZHMgd2hlbiB0aGUgZmlyc3QgcmFuZ2UgZW5kc1xuXHQvLyB2YXIgZmlyc3RSYW5nZUVuZCA9IGJ1ZmZlcmVkVGltZVJhbmdlLmVuZCgwKSxcblxuXHQvLyAvLyBMZW5ndGggaW4gc2Vjb25kcyBvZiB0aGUgZmlyc3QgdGltZSByYW5nZVxuXHRcdC8vIHZhciBmaXJzdFJhbmdlTGVuZ3RoID0gZmlyc3RSYW5nZUVuZCAtIGZpcnN0UmFuZ2VTdGFydDtcblx0XHQgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cblx0XHQgKiBcblx0XHQgKi9cblx0Z2V0QnVmZmVyZWRJbmZvKCkge1xuXHRcdGxldCBwbGF5ZXIgPSB0aGlzLnBsYXllcjtcblx0XHRyZXR1cm4ge1xuXHRcdFx0YnVmZmVyZWQ6IHBsYXllci5idWZmZXJlZCgpLFxuXHRcdFx0YnVmZmVyZWRQZXJjZW50OiBwbGF5ZXIuYnVmZmVyZWRQZXJjZW50KClcblx0XHR9XG5cdH1cblxuXHRnZXRSZW1haW5pbmdUaW1lKCkge1xuXHRcdHJldHVybiB0aGlzLnBsYXllci5yZW1haW5pbmdUaW1lKCk7XG5cdH1cblx0LyoqXG5cdCAqIFtjdXJyZW50VGltZSDorr7nva7mkq3mlL7lpLRdXG5cdCAqIEBhdXRob3IgamFzb24uY2hlbiBvbiAyMDE3LTA5LTE0XG5cdCAqIEBwYXJhbSAge1t0eXBlXX0gdGltZSBbIOS6i+S7tiBzXVxuXHQgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxuXHQgKi9cblx0Y3VycmVudFRpbWUodGltZSkge1xuXHRcdGlmICh0aW1lKSB7XG5cdFx0XHR0aGlzLnBsYXllci5jdXJyZW50VGltZSh0aW1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMucGxheWVyLmN1cnJlbnRUaW1lKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIOiuvue9ri/ojrflj5bmkq3mlL7lmajlrr3pq5jmr5QgMTbvvJo5ICA077yaM1xuXHQgKiBAYXV0aG9yIGphc29uLmNoZW4gb24gMjAxNy0xMC0wOVxuXHQgKiBAcGFyYW0gIHtbdHlwZV19IHZhbCBbZGVzY3JpcHRpb25dXG5cdCAqIEByZXR1cm4ge1t0eXBlXX0gICAgIFtkZXNjcmlwdGlvbl1cblx0ICovXG5cdGFzcGVjdFJhdGlvKHZhbCkge1xuXHRcdGlmICh2YWwpIHtcblx0XHRcdHRoaXMucGxheWVyLmFzcGVjdFJhdGlvKHZhbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLnBsYXllci5hc3BlY3RSYXRpbygpO1xuXHRcdH1cblx0fVxuXG5cdGRpc3Bvc2UoKSB7XG5cdFx0dGhpcy5wbGF5ZXIuZGlzcG9zZSgpO1xuXHR9XG5cblx0b24obmFtZSwgaGFuZGxlcikge1xuXHRcdHRoaXMucGxheWVyLm9uKG5hbWUsICgpID0+IHtcblx0XHRcdGhhbmRsZXIuY2FsbCh0aGlzKVxuXHRcdH0pXG5cdH1cblx0b2ZmKG5hbWUsIGhhbmRsZXIpIHtcblx0XHR0aGlzLnBsYXllci5vZmYobmFtZSwgaGFuZGxlcilcblx0fVxufVxuXG4vLyBsb2Fkc3RhcnQgcGxheSBwYXVzZSBwbGF5aW5nIGVuZGVkIHZvbHVtZWNoYW5nZSBkdXJhdGlvbmNoYW5nZSBlcnJvciB0aW1ldXBkYXRlIHByb2dyZXNzIGVudGVyRnVsbFNjcmVlbiBleGl0RnVsbFNjcmVlblxuXG5cbi8vIHJlYWR577yM77yMZW5kZWRcbi8vIG15UGxheWVyLnBhdXNlZCgpXG5cbi8vIHBsYXllci5vbignZW5kZWQnLCBmdW5jdGlvbigpIHtcbi8vICAgdGhpcy5kaXNwb3NlKCk7XG4vLyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBWUGxheWVyXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3ZwbGF5ZXIuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n")},function(module,exports,__webpack_require__){eval("var topLevel =  false ? global :\n    typeof window !== 'undefined' ? window : {}\nvar minDoc = __webpack_require__(8);\n\nvar doccy;\n\nif (typeof document !== 'undefined') {\n    doccy = document;\n} else {\n    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n\n    if (!doccy) {\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n    }\n}\n\nmodule.exports = doccy;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL2dsb2JhbC9kb2N1bWVudC5qcz85YTI4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9wTGV2ZWwgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fVxudmFyIG1pbkRvYyA9IHJlcXVpcmUoJ21pbi1kb2N1bWVudCcpO1xuXG52YXIgZG9jY3k7XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZG9jY3kgPSBkb2N1bWVudDtcbn0gZWxzZSB7XG4gICAgZG9jY3kgPSB0b3BMZXZlbFsnX19HTE9CQUxfRE9DVU1FTlRfQ0FDSEVANCddO1xuXG4gICAgaWYgKCFkb2NjeSkge1xuICAgICAgICBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J10gPSBtaW5Eb2M7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRvY2N5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL2dsb2JhbC9kb2N1bWVudC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n")},function(module,exports){eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbWluLWRvY3VtZW50IChpZ25vcmVkKT8wY2VkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiAoaWdub3JlZCkgKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBtaW4tZG9jdW1lbnQgKGlnbm9yZWQpXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n")},function(module,exports){eval("function clean (s) {\n  return s.replace(/\\n\\r?\\s*/g, '')\n}\n\n\nmodule.exports = function tsml (sa) {\n  var s = ''\n    , i = 0\n\n  for (; i < arguments.length; i++)\n    s += clean(sa[i]) + (arguments[i + 1] || '')\n\n  return s\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL3RzbWwvdHNtbC5qcz9iYTBiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsc0JBQXNCO0FBQzlCOztBQUVBO0FBQ0EiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGNsZWFuIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1xcblxccj9cXHMqL2csICcnKVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHNtbCAoc2EpIHtcbiAgdmFyIHMgPSAnJ1xuICAgICwgaSA9IDBcblxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICBzICs9IGNsZWFuKHNhW2ldKSArIChhcmd1bWVudHNbaSArIDFdIHx8ICcnKVxuXG4gIHJldHVybiBzXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL3RzbWwvdHNtbC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n")},function(module,exports){eval("module.exports = SafeParseTuple\n\nfunction SafeParseTuple(obj, reviver) {\n    var json\n    var error = null\n\n    try {\n        json = JSON.parse(obj, reviver)\n    } catch (err) {\n        error = err\n    }\n\n    return [error, json]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL3NhZmUtanNvbi1wYXJzZS90dXBsZS5qcz9hNjFlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gU2FmZVBhcnNlVHVwbGVcblxuZnVuY3Rpb24gU2FmZVBhcnNlVHVwbGUob2JqLCByZXZpdmVyKSB7XG4gICAgdmFyIGpzb25cbiAgICB2YXIgZXJyb3IgPSBudWxsXG5cbiAgICB0cnkge1xuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShvYmosIHJldml2ZXIpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9yID0gZXJyXG4gICAgfVxuXG4gICAgcmV0dXJuIFtlcnJvciwganNvbl1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3ZpZGVvLmpzL25vZGVfbW9kdWxlcy9zYWZlLWpzb24tcGFyc2UvdHVwbGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n")},function(module,exports,__webpack_require__){"use strict";eval('\nvar window = __webpack_require__(1)\nvar isFunction = __webpack_require__(2)\nvar parseHeaders = __webpack_require__(12)\nvar xtend = __webpack_require__(15)\n\nmodule.exports = createXHR\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop\ncreateXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest\n\nforEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {\n    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {\n        options = initParams(uri, options, callback)\n        options.method = method.toUpperCase()\n        return _createXHR(options)\n    }\n})\n\nfunction forEachArray(array, iterator) {\n    for (var i = 0; i < array.length; i++) {\n        iterator(array[i])\n    }\n}\n\nfunction isEmpty(obj){\n    for(var i in obj){\n        if(obj.hasOwnProperty(i)) return false\n    }\n    return true\n}\n\nfunction initParams(uri, options, callback) {\n    var params = uri\n\n    if (isFunction(options)) {\n        callback = options\n        if (typeof uri === "string") {\n            params = {uri:uri}\n        }\n    } else {\n        params = xtend(options, {uri: uri})\n    }\n\n    params.callback = callback\n    return params\n}\n\nfunction createXHR(uri, options, callback) {\n    options = initParams(uri, options, callback)\n    return _createXHR(options)\n}\n\nfunction _createXHR(options) {\n    if(typeof options.callback === "undefined"){\n        throw new Error("callback argument missing")\n    }\n\n    var called = false\n    var callback = function cbOnce(err, response, body){\n        if(!called){\n            called = true\n            options.callback(err, response, body)\n        }\n    }\n\n    function readystatechange() {\n        if (xhr.readyState === 4) {\n            setTimeout(loadFunc, 0)\n        }\n    }\n\n    function getBody() {\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\n        var body = undefined\n\n        if (xhr.response) {\n            body = xhr.response\n        } else {\n            body = xhr.responseText || getXml(xhr)\n        }\n\n        if (isJson) {\n            try {\n                body = JSON.parse(body)\n            } catch (e) {}\n        }\n\n        return body\n    }\n\n    function errorFunc(evt) {\n        clearTimeout(timeoutTimer)\n        if(!(evt instanceof Error)){\n            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )\n        }\n        evt.statusCode = 0\n        return callback(evt, failureResponse)\n    }\n\n    // will load the data & process the response in a special response object\n    function loadFunc() {\n        if (aborted) return\n        var status\n        clearTimeout(timeoutTimer)\n        if(options.useXDR && xhr.status===undefined) {\n            //IE8 CORS GET successful response doesn\'t have a status field, but body is fine\n            status = 200\n        } else {\n            status = (xhr.status === 1223 ? 204 : xhr.status)\n        }\n        var response = failureResponse\n        var err = null\n\n        if (status !== 0){\n            response = {\n                body: getBody(),\n                statusCode: status,\n                method: method,\n                headers: {},\n                url: uri,\n                rawRequest: xhr\n            }\n            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE\n                response.headers = parseHeaders(xhr.getAllResponseHeaders())\n            }\n        } else {\n            err = new Error("Internal XMLHttpRequest Error")\n        }\n        return callback(err, response, response.body)\n    }\n\n    var xhr = options.xhr || null\n\n    if (!xhr) {\n        if (options.cors || options.useXDR) {\n            xhr = new createXHR.XDomainRequest()\n        }else{\n            xhr = new createXHR.XMLHttpRequest()\n        }\n    }\n\n    var key\n    var aborted\n    var uri = xhr.url = options.uri || options.url\n    var method = xhr.method = options.method || "GET"\n    var body = options.body || options.data\n    var headers = xhr.headers = options.headers || {}\n    var sync = !!options.sync\n    var isJson = false\n    var timeoutTimer\n    var failureResponse = {\n        body: undefined,\n        headers: {},\n        statusCode: 0,\n        method: method,\n        url: uri,\n        rawRequest: xhr\n    }\n\n    if ("json" in options && options.json !== false) {\n        isJson = true\n        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don\'t override existing accept header declared by user\n        if (method !== "GET" && method !== "HEAD") {\n            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don\'t override existing accept header declared by user\n            body = JSON.stringify(options.json === true ? body : options.json)\n        }\n    }\n\n    xhr.onreadystatechange = readystatechange\n    xhr.onload = loadFunc\n    xhr.onerror = errorFunc\n    // IE9 must have onprogress be set to a unique function.\n    xhr.onprogress = function () {\n        // IE must die\n    }\n    xhr.onabort = function(){\n        aborted = true;\n    }\n    xhr.ontimeout = errorFunc\n    xhr.open(method, uri, !sync, options.username, options.password)\n    //has to be after open\n    if(!sync) {\n        xhr.withCredentials = !!options.withCredentials\n    }\n    // Cannot set timeout with sync request\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n    // both npm\'s request and jquery 1.x use this kind of timeout, so this is being consistent\n    if (!sync && options.timeout > 0 ) {\n        timeoutTimer = setTimeout(function(){\n            if (aborted) return\n            aborted = true//IE9 may still call readystatechange\n            xhr.abort("timeout")\n            var e = new Error("XMLHttpRequest timeout")\n            e.code = "ETIMEDOUT"\n            errorFunc(e)\n        }, options.timeout )\n    }\n\n    if (xhr.setRequestHeader) {\n        for(key in headers){\n            if(headers.hasOwnProperty(key)){\n                xhr.setRequestHeader(key, headers[key])\n            }\n        }\n    } else if (options.headers && !isEmpty(options.headers)) {\n        throw new Error("Headers cannot be set on an XDomainRequest object")\n    }\n\n    if ("responseType" in options) {\n        xhr.responseType = options.responseType\n    }\n\n    if ("beforeSend" in options &&\n        typeof options.beforeSend === "function"\n    ) {\n        options.beforeSend(xhr)\n    }\n\n    // Microsoft Edge browser sends "undefined" when send is called with undefined value.\n    // XMLHttpRequest spec says to pass null as body to indicate no body\n    // See https://github.com/naugtur/xhr/issues/100.\n    xhr.send(body || null)\n\n    return xhr\n\n\n}\n\nfunction getXml(xhr) {\n    if (xhr.responseType === "document") {\n        return xhr.responseXML\n    }\n    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"\n    if (xhr.responseType === "" && !firefoxBugTakenEffect) {\n        return xhr.responseXML\n    }\n\n    return null\n}\n\nfunction noop() {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL3hoci9pbmRleC5qcz8wNzNmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLFNBQVM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgd2luZG93ID0gcmVxdWlyZShcImdsb2JhbC93aW5kb3dcIilcbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZShcImlzLWZ1bmN0aW9uXCIpXG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZShcInBhcnNlLWhlYWRlcnNcIilcbnZhciB4dGVuZCA9IHJlcXVpcmUoXCJ4dGVuZFwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVhIUlxuY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0ID0gd2luZG93LlhNTEh0dHBSZXF1ZXN0IHx8IG5vb3BcbmNyZWF0ZVhIUi5YRG9tYWluUmVxdWVzdCA9IFwid2l0aENyZWRlbnRpYWxzXCIgaW4gKG5ldyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QoKSkgPyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QgOiB3aW5kb3cuWERvbWFpblJlcXVlc3RcblxuZm9yRWFjaEFycmF5KFtcImdldFwiLCBcInB1dFwiLCBcInBvc3RcIiwgXCJwYXRjaFwiLCBcImhlYWRcIiwgXCJkZWxldGVcIl0sIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIGNyZWF0ZVhIUlttZXRob2QgPT09IFwiZGVsZXRlXCIgPyBcImRlbFwiIDogbWV0aG9kXSA9IGZ1bmN0aW9uKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICAgICAgICByZXR1cm4gX2NyZWF0ZVhIUihvcHRpb25zKVxuICAgIH1cbn0pXG5cbmZ1bmN0aW9uIGZvckVhY2hBcnJheShhcnJheSwgaXRlcmF0b3IpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGFycmF5W2ldKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNFbXB0eShvYmope1xuICAgIGZvcih2YXIgaSBpbiBvYmope1xuICAgICAgICBpZihvYmouaGFzT3duUHJvcGVydHkoaSkpIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFyYW1zID0gdXJpXG5cbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgICAgaWYgKHR5cGVvZiB1cmkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHt1cmk6dXJpfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zID0geHRlbmQob3B0aW9ucywge3VyaTogdXJpfSlcbiAgICB9XG5cbiAgICBwYXJhbXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHJldHVybiBwYXJhbXNcbn1cblxuZnVuY3Rpb24gY3JlYXRlWEhSKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBvcHRpb25zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIHJldHVybiBfY3JlYXRlWEhSKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVYSFIob3B0aW9ucykge1xuICAgIGlmKHR5cGVvZiBvcHRpb25zLmNhbGxiYWNrID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FsbGJhY2sgYXJndW1lbnQgbWlzc2luZ1wiKVxuICAgIH1cblxuICAgIHZhciBjYWxsZWQgPSBmYWxzZVxuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNiT25jZShlcnIsIHJlc3BvbnNlLCBib2R5KXtcbiAgICAgICAgaWYoIWNhbGxlZCl7XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlXG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIGJvZHkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQobG9hZEZ1bmMsIDApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgICAgICAvLyBDaHJvbWUgd2l0aCByZXF1ZXN0VHlwZT1ibG9iIHRocm93cyBlcnJvcnMgYXJyb3VuZCB3aGVuIGV2ZW4gdGVzdGluZyBhY2Nlc3MgdG8gcmVzcG9uc2VUZXh0XG4gICAgICAgIHZhciBib2R5ID0gdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVRleHQgfHwgZ2V0WG1sKHhocilcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0pzb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm9keVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yRnVuYyhldnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcilcbiAgICAgICAgaWYoIShldnQgaW5zdGFuY2VvZiBFcnJvcikpe1xuICAgICAgICAgICAgZXZ0ID0gbmV3IEVycm9yKFwiXCIgKyAoZXZ0IHx8IFwiVW5rbm93biBYTUxIdHRwUmVxdWVzdCBFcnJvclwiKSApXG4gICAgICAgIH1cbiAgICAgICAgZXZ0LnN0YXR1c0NvZGUgPSAwXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhldnQsIGZhaWx1cmVSZXNwb25zZSlcbiAgICB9XG5cbiAgICAvLyB3aWxsIGxvYWQgdGhlIGRhdGEgJiBwcm9jZXNzIHRoZSByZXNwb25zZSBpbiBhIHNwZWNpYWwgcmVzcG9uc2Ugb2JqZWN0XG4gICAgZnVuY3Rpb24gbG9hZEZ1bmMoKSB7XG4gICAgICAgIGlmIChhYm9ydGVkKSByZXR1cm5cbiAgICAgICAgdmFyIHN0YXR1c1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKVxuICAgICAgICBpZihvcHRpb25zLnVzZVhEUiAmJiB4aHIuc3RhdHVzPT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL0lFOCBDT1JTIEdFVCBzdWNjZXNzZnVsIHJlc3BvbnNlIGRvZXNuJ3QgaGF2ZSBhIHN0YXR1cyBmaWVsZCwgYnV0IGJvZHkgaXMgZmluZVxuICAgICAgICAgICAgc3RhdHVzID0gMjAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAoeGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXMpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3BvbnNlID0gZmFpbHVyZVJlc3BvbnNlXG4gICAgICAgIHZhciBlcnIgPSBudWxsXG5cbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gMCl7XG4gICAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBib2R5OiBnZXRCb2R5KCksXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgIHVybDogdXJpLFxuICAgICAgICAgICAgICAgIHJhd1JlcXVlc3Q6IHhoclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycyl7IC8vcmVtZW1iZXIgeGhyIGNhbiBpbiBmYWN0IGJlIFhEUiBmb3IgQ09SUyBpbiBJRVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKFwiSW50ZXJuYWwgWE1MSHR0cFJlcXVlc3QgRXJyb3JcIilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCByZXNwb25zZSwgcmVzcG9uc2UuYm9keSlcbiAgICB9XG5cbiAgICB2YXIgeGhyID0gb3B0aW9ucy54aHIgfHwgbnVsbFxuXG4gICAgaWYgKCF4aHIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29ycyB8fCBvcHRpb25zLnVzZVhEUikge1xuICAgICAgICAgICAgeGhyID0gbmV3IGNyZWF0ZVhIUi5YRG9tYWluUmVxdWVzdCgpXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgeGhyID0gbmV3IGNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5XG4gICAgdmFyIGFib3J0ZWRcbiAgICB2YXIgdXJpID0geGhyLnVybCA9IG9wdGlvbnMudXJpIHx8IG9wdGlvbnMudXJsXG4gICAgdmFyIG1ldGhvZCA9IHhoci5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiXG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5kYXRhXG4gICAgdmFyIGhlYWRlcnMgPSB4aHIuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fVxuICAgIHZhciBzeW5jID0gISFvcHRpb25zLnN5bmNcbiAgICB2YXIgaXNKc29uID0gZmFsc2VcbiAgICB2YXIgdGltZW91dFRpbWVyXG4gICAgdmFyIGZhaWx1cmVSZXNwb25zZSA9IHtcbiAgICAgICAgYm9keTogdW5kZWZpbmVkLFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgc3RhdHVzQ29kZTogMCxcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIHVybDogdXJpLFxuICAgICAgICByYXdSZXF1ZXN0OiB4aHJcbiAgICB9XG5cbiAgICBpZiAoXCJqc29uXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmpzb24gIT09IGZhbHNlKSB7XG4gICAgICAgIGlzSnNvbiA9IHRydWVcbiAgICAgICAgaGVhZGVyc1tcImFjY2VwdFwiXSB8fCBoZWFkZXJzW1wiQWNjZXB0XCJdIHx8IChoZWFkZXJzW1wiQWNjZXB0XCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIC8vRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYWNjZXB0IGhlYWRlciBkZWNsYXJlZCBieSB1c2VyXG4gICAgICAgIGlmIChtZXRob2QgIT09IFwiR0VUXCIgJiYgbWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdIHx8IChoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIC8vRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYWNjZXB0IGhlYWRlciBkZWNsYXJlZCBieSB1c2VyXG4gICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5qc29uID09PSB0cnVlID8gYm9keSA6IG9wdGlvbnMuanNvbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSByZWFkeXN0YXRlY2hhbmdlXG4gICAgeGhyLm9ubG9hZCA9IGxvYWRGdW5jXG4gICAgeGhyLm9uZXJyb3IgPSBlcnJvckZ1bmNcbiAgICAvLyBJRTkgbXVzdCBoYXZlIG9ucHJvZ3Jlc3MgYmUgc2V0IHRvIGEgdW5pcXVlIGZ1bmN0aW9uLlxuICAgIHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJRSBtdXN0IGRpZVxuICAgIH1cbiAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB4aHIub250aW1lb3V0ID0gZXJyb3JGdW5jXG4gICAgeGhyLm9wZW4obWV0aG9kLCB1cmksICFzeW5jLCBvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkKVxuICAgIC8vaGFzIHRvIGJlIGFmdGVyIG9wZW5cbiAgICBpZighc3luYykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRpb25zLndpdGhDcmVkZW50aWFsc1xuICAgIH1cbiAgICAvLyBDYW5ub3Qgc2V0IHRpbWVvdXQgd2l0aCBzeW5jIHJlcXVlc3RcbiAgICAvLyBub3Qgc2V0dGluZyB0aW1lb3V0IG9uIHRoZSB4aHIgb2JqZWN0LCBiZWNhdXNlIG9mIG9sZCB3ZWJraXRzIGV0Yy4gbm90IGhhbmRsaW5nIHRoYXQgY29ycmVjdGx5XG4gICAgLy8gYm90aCBucG0ncyByZXF1ZXN0IGFuZCBqcXVlcnkgMS54IHVzZSB0aGlzIGtpbmQgb2YgdGltZW91dCwgc28gdGhpcyBpcyBiZWluZyBjb25zaXN0ZW50XG4gICAgaWYgKCFzeW5jICYmIG9wdGlvbnMudGltZW91dCA+IDAgKSB7XG4gICAgICAgIHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmIChhYm9ydGVkKSByZXR1cm5cbiAgICAgICAgICAgIGFib3J0ZWQgPSB0cnVlLy9JRTkgbWF5IHN0aWxsIGNhbGwgcmVhZHlzdGF0ZWNoYW5nZVxuICAgICAgICAgICAgeGhyLmFib3J0KFwidGltZW91dFwiKVxuICAgICAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoXCJYTUxIdHRwUmVxdWVzdCB0aW1lb3V0XCIpXG4gICAgICAgICAgICBlLmNvZGUgPSBcIkVUSU1FRE9VVFwiXG4gICAgICAgICAgICBlcnJvckZ1bmMoZSlcbiAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0IClcbiAgICB9XG5cbiAgICBpZiAoeGhyLnNldFJlcXVlc3RIZWFkZXIpIHtcbiAgICAgICAgZm9yKGtleSBpbiBoZWFkZXJzKXtcbiAgICAgICAgICAgIGlmKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSl7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaGVhZGVycyAmJiAhaXNFbXB0eShvcHRpb25zLmhlYWRlcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhlYWRlcnMgY2Fubm90IGJlIHNldCBvbiBhbiBYRG9tYWluUmVxdWVzdCBvYmplY3RcIilcbiAgICB9XG5cbiAgICBpZiAoXCJyZXNwb25zZVR5cGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZVxuICAgIH1cblxuICAgIGlmIChcImJlZm9yZVNlbmRcIiBpbiBvcHRpb25zICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmJlZm9yZVNlbmQgPT09IFwiZnVuY3Rpb25cIlxuICAgICkge1xuICAgICAgICBvcHRpb25zLmJlZm9yZVNlbmQoeGhyKVxuICAgIH1cblxuICAgIC8vIE1pY3Jvc29mdCBFZGdlIGJyb3dzZXIgc2VuZHMgXCJ1bmRlZmluZWRcIiB3aGVuIHNlbmQgaXMgY2FsbGVkIHdpdGggdW5kZWZpbmVkIHZhbHVlLlxuICAgIC8vIFhNTEh0dHBSZXF1ZXN0IHNwZWMgc2F5cyB0byBwYXNzIG51bGwgYXMgYm9keSB0byBpbmRpY2F0ZSBubyBib2R5XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXVndHVyL3hoci9pc3N1ZXMvMTAwLlxuICAgIHhoci5zZW5kKGJvZHkgfHwgbnVsbClcblxuICAgIHJldHVybiB4aHJcblxuXG59XG5cbmZ1bmN0aW9uIGdldFhtbCh4aHIpIHtcbiAgICBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VYTUxcbiAgICB9XG4gICAgdmFyIGZpcmVmb3hCdWdUYWtlbkVmZmVjdCA9IHhoci5yZXNwb25zZVhNTCAmJiB4aHIucmVzcG9uc2VYTUwuZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lID09PSBcInBhcnNlcmVycm9yXCJcbiAgICBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gXCJcIiAmJiAhZmlyZWZveEJ1Z1Rha2VuRWZmZWN0KSB7XG4gICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VYTUxcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3ZpZGVvLmpzL25vZGVfbW9kdWxlcy94aHIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n')},function(module,exports,__webpack_require__){eval("var trim = __webpack_require__(13)\n  , forEach = __webpack_require__(14)\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  forEach(\n      trim(headers).split('\\n')\n    , function (row) {\n        var index = row.indexOf(':')\n          , key = trim(row.slice(0, index)).toLowerCase()\n          , value = trim(row.slice(index + 1))\n\n        if (typeof(result[key]) === 'undefined') {\n          result[key] = value\n        } else if (isArray(result[key])) {\n          result[key].push(value)\n        } else {\n          result[key] = [ result[key], value ]\n        }\n      }\n  )\n\n  return result\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvcGFyc2UtaGVhZGVycy5qcz9mMTBiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdHJpbSA9IHJlcXVpcmUoJ3RyaW0nKVxuICAsIGZvckVhY2ggPSByZXF1aXJlKCdmb3ItZWFjaCcpXG4gICwgaXNBcnJheSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaGVhZGVycykge1xuICBpZiAoIWhlYWRlcnMpXG4gICAgcmV0dXJuIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHt9XG5cbiAgZm9yRWFjaChcbiAgICAgIHRyaW0oaGVhZGVycykuc3BsaXQoJ1xcbicpXG4gICAgLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJvdy5pbmRleE9mKCc6JylcbiAgICAgICAgICAsIGtleSA9IHRyaW0ocm93LnNsaWNlKDAsIGluZGV4KSkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICwgdmFsdWUgPSB0cmltKHJvdy5zbGljZShpbmRleCArIDEpKVxuXG4gICAgICAgIGlmICh0eXBlb2YocmVzdWx0W2tleV0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBbIHJlc3VsdFtrZXldLCB2YWx1ZSBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgKVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92aWRlby5qcy9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9wYXJzZS1oZWFkZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12\n")},function(module,exports){eval("\nexports = module.exports = trim;\n\nfunction trim(str){\n  return str.replace(/^\\s*|\\s*$/g, '');\n}\n\nexports.left = function(str){\n  return str.replace(/^\\s*/, '');\n};\n\nexports.right = function(str){\n  return str.replace(/\\s*$/, '');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL3RyaW0vaW5kZXguanM/NmQzYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRyaW07XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7XG59XG5cbmV4cG9ydHMubGVmdCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJyk7XG59O1xuXG5leHBvcnRzLnJpZ2h0ID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92aWRlby5qcy9ub2RlX21vZHVsZXMvdHJpbS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n")},function(module,exports,__webpack_require__){eval("var isFunction = __webpack_require__(2)\n\nmodule.exports = forEach\n\nvar toString = Object.prototype.toString\nvar hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction forEach(list, iterator, context) {\n    if (!isFunction(iterator)) {\n        throw new TypeError('iterator must be a function')\n    }\n\n    if (arguments.length < 3) {\n        context = this\n    }\n    \n    if (toString.call(list) === '[object Array]')\n        forEachArray(list, iterator, context)\n    else if (typeof list === 'string')\n        forEachString(list, iterator, context)\n    else\n        forEachObject(list, iterator, context)\n}\n\nfunction forEachArray(array, iterator, context) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            iterator.call(context, array[i], i, array)\n        }\n    }\n}\n\nfunction forEachString(string, iterator, context) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        iterator.call(context, string.charAt(i), i, string)\n    }\n}\n\nfunction forEachObject(object, iterator, context) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            iterator.call(context, object[k], k, object)\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL2Zvci1lYWNoL2luZGV4LmpzP2FkZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxuZnVuY3Rpb24gZm9yRWFjaChsaXN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXNGdW5jdGlvbihpdGVyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXNcbiAgICB9XG4gICAgXG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobGlzdCkgPT09ICdbb2JqZWN0IEFycmF5XScpXG4gICAgICAgIGZvckVhY2hBcnJheShsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbiAgICBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIGZvckVhY2hTdHJpbmcobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZVxuICAgICAgICBmb3JFYWNoT2JqZWN0KGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBpKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVtpXSwgaSwgYXJyYXkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTdHJpbmcoc3RyaW5nLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmplY3Rba10sIGssIG9iamVjdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3ZpZGVvLmpzL25vZGVfbW9kdWxlcy9mb3ItZWFjaC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n")},function(module,exports){eval("module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcz85NzRmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge31cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92aWRlby5qcy9ub2RlX21vZHVsZXMveHRlbmQvaW1tdXRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n")},function(module,exports,__webpack_require__){eval('/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Default exports for Node. Export the extended versions of VTTCue and\n// VTTRegion in Node since we likely want the capability to convert back and\n// forth between JSON. If we don\'t then it\'s not that big of a deal since we\'re\n// off browser.\n\nvar window = __webpack_require__(1);\n\nvar vttjs = module.exports = {\n  WebVTT: __webpack_require__(17),\n  VTTCue: __webpack_require__(18),\n  VTTRegion: __webpack_require__(19)\n};\n\nwindow.vttjs = vttjs;\nwindow.WebVTT = vttjs.WebVTT;\n\nvar cueShim = vttjs.VTTCue;\nvar regionShim = vttjs.VTTRegion;\nvar nativeVTTCue = window.VTTCue;\nvar nativeVTTRegion = window.VTTRegion;\n\nvttjs.shim = function() {\n  window.VTTCue = cueShim;\n  window.VTTRegion = regionShim;\n};\n\nvttjs.restore = function() {\n  window.VTTCue = nativeVTTCue;\n  window.VTTRegion = nativeVTTRegion;\n};\n\nif (!window.VTTCue) {\n  vttjs.shim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL3ZpZGVvanMtdnR0LmpzL2xpYi9icm93c2VyLWluZGV4LmpzPzk4YmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8vIERlZmF1bHQgZXhwb3J0cyBmb3IgTm9kZS4gRXhwb3J0IHRoZSBleHRlbmRlZCB2ZXJzaW9ucyBvZiBWVFRDdWUgYW5kXG4vLyBWVFRSZWdpb24gaW4gTm9kZSBzaW5jZSB3ZSBsaWtlbHkgd2FudCB0aGUgY2FwYWJpbGl0eSB0byBjb252ZXJ0IGJhY2sgYW5kXG4vLyBmb3J0aCBiZXR3ZWVuIEpTT04uIElmIHdlIGRvbid0IHRoZW4gaXQncyBub3QgdGhhdCBiaWcgb2YgYSBkZWFsIHNpbmNlIHdlJ3JlXG4vLyBvZmYgYnJvd3Nlci5cblxudmFyIHdpbmRvdyA9IHJlcXVpcmUoJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIHZ0dGpzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYlZUVDogcmVxdWlyZShcIi4vdnR0LmpzXCIpLFxuICBWVFRDdWU6IHJlcXVpcmUoXCIuL3Z0dGN1ZS5qc1wiKSxcbiAgVlRUUmVnaW9uOiByZXF1aXJlKFwiLi92dHRyZWdpb24uanNcIilcbn07XG5cbndpbmRvdy52dHRqcyA9IHZ0dGpzO1xud2luZG93LldlYlZUVCA9IHZ0dGpzLldlYlZUVDtcblxudmFyIGN1ZVNoaW0gPSB2dHRqcy5WVFRDdWU7XG52YXIgcmVnaW9uU2hpbSA9IHZ0dGpzLlZUVFJlZ2lvbjtcbnZhciBuYXRpdmVWVFRDdWUgPSB3aW5kb3cuVlRUQ3VlO1xudmFyIG5hdGl2ZVZUVFJlZ2lvbiA9IHdpbmRvdy5WVFRSZWdpb247XG5cbnZ0dGpzLnNoaW0gPSBmdW5jdGlvbigpIHtcbiAgd2luZG93LlZUVEN1ZSA9IGN1ZVNoaW07XG4gIHdpbmRvdy5WVFRSZWdpb24gPSByZWdpb25TaGltO1xufTtcblxudnR0anMucmVzdG9yZSA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cuVlRUQ3VlID0gbmF0aXZlVlRUQ3VlO1xuICB3aW5kb3cuVlRUUmVnaW9uID0gbmF0aXZlVlRUUmVnaW9uO1xufTtcblxuaWYgKCF3aW5kb3cuVlRUQ3VlKSB7XG4gIHZ0dGpzLnNoaW0oKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3ZpZGVvLmpzL25vZGVfbW9kdWxlcy92aWRlb2pzLXZ0dC5qcy9saWIvYnJvd3Nlci1pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n')},function(module,exports){eval('/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\nvar _objCreate = Object.create || (function() {\n  function F() {}\n  return function(o) {\n    if (arguments.length !== 1) {\n      throw new Error(\'Object.create shim only accepts one parameter.\');\n    }\n    F.prototype = o;\n    return new F();\n  };\n})();\n\n// Creates a new ParserError object from an errorData object. The errorData\n// object should have default code and message properties. The default message\n// property can be overriden by passing in a message parameter.\n// See ParsingError.Errors below for acceptable errors.\nfunction ParsingError(errorData, message) {\n  this.name = "ParsingError";\n  this.code = errorData.code;\n  this.message = message || errorData.message;\n}\nParsingError.prototype = _objCreate(Error.prototype);\nParsingError.prototype.constructor = ParsingError;\n\n// ParsingError metadata for acceptable ParsingErrors.\nParsingError.Errors = {\n  BadSignature: {\n    code: 0,\n    message: "Malformed WebVTT signature."\n  },\n  BadTimeStamp: {\n    code: 1,\n    message: "Malformed time stamp."\n  }\n};\n\n// Try to parse input as a time stamp.\nfunction parseTimeStamp(input) {\n\n  function computeSeconds(h, m, s, f) {\n    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;\n  }\n\n  var m = input.match(/^(\\d+):(\\d{2})(:\\d{2})?\\.(\\d{3})/);\n  if (!m) {\n    return null;\n  }\n\n  if (m[3]) {\n    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]\n    return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);\n  } else if (m[1] > 59) {\n    // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n    // First position is hours as it\'s over 59.\n    return computeSeconds(m[1], m[2], 0,  m[4]);\n  } else {\n    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]\n    return computeSeconds(0, m[1], m[2], m[4]);\n  }\n}\n\n// A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\nfunction Settings() {\n  this.values = _objCreate(null);\n}\n\nSettings.prototype = {\n  // Only accept the first assignment to any key.\n  set: function(k, v) {\n    if (!this.get(k) && v !== "") {\n      this.values[k] = v;\n    }\n  },\n  // Return the value for a key, or a default value.\n  // If \'defaultKey\' is passed then \'dflt\' is assumed to be an object with\n  // a number of possible default values as properties where \'defaultKey\' is\n  // the key of the property that will be chosen; otherwise it\'s assumed to be\n  // a single value.\n  get: function(k, dflt, defaultKey) {\n    if (defaultKey) {\n      return this.has(k) ? this.values[k] : dflt[defaultKey];\n    }\n    return this.has(k) ? this.values[k] : dflt;\n  },\n  // Check whether we have a value for a key.\n  has: function(k) {\n    return k in this.values;\n  },\n  // Accept a setting if its one of the given alternatives.\n  alt: function(k, v, a) {\n    for (var n = 0; n < a.length; ++n) {\n      if (v === a[n]) {\n        this.set(k, v);\n        break;\n      }\n    }\n  },\n  // Accept a setting if its a valid (signed) integer.\n  integer: function(k, v) {\n    if (/^-?\\d+$/.test(v)) { // integer\n      this.set(k, parseInt(v, 10));\n    }\n  },\n  // Accept a setting if its a valid percentage.\n  percent: function(k, v) {\n    var m;\n    if ((m = v.match(/^([\\d]{1,3})(\\.[\\d]*)?%$/))) {\n      v = parseFloat(v);\n      if (v >= 0 && v <= 100) {\n        this.set(k, v);\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\n// Helper function to parse input into groups separated by \'groupDelim\', and\n// interprete each group as a key/value pair separated by \'keyValueDelim\'.\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n  var groups = groupDelim ? input.split(groupDelim) : [input];\n  for (var i in groups) {\n    if (typeof groups[i] !== "string") {\n      continue;\n    }\n    var kv = groups[i].split(keyValueDelim);\n    if (kv.length !== 2) {\n      continue;\n    }\n    var k = kv[0];\n    var v = kv[1];\n    callback(k, v);\n  }\n}\n\nfunction parseCue(input, cue, regionList) {\n  // Remember the original input if we need to throw an error.\n  var oInput = input;\n  // 4.1 WebVTT timestamp\n  function consumeTimeStamp() {\n    var ts = parseTimeStamp(input);\n    if (ts === null) {\n      throw new ParsingError(ParsingError.Errors.BadTimeStamp,\n                            "Malformed timestamp: " + oInput);\n    }\n    // Remove time stamp from input.\n    input = input.replace(/^[^\\sa-zA-Z-]+/, "");\n    return ts;\n  }\n\n  // 4.4.2 WebVTT cue settings\n  function consumeCueSettings(input, cue) {\n    var settings = new Settings();\n\n    parseOptions(input, function (k, v) {\n      switch (k) {\n      case "region":\n        // Find the last region we parsed with the same region id.\n        for (var i = regionList.length - 1; i >= 0; i--) {\n          if (regionList[i].id === v) {\n            settings.set(k, regionList[i].region);\n            break;\n          }\n        }\n        break;\n      case "vertical":\n        settings.alt(k, v, ["rl", "lr"]);\n        break;\n      case "line":\n        var vals = v.split(","),\n            vals0 = vals[0];\n        settings.integer(k, vals0);\n        settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;\n        settings.alt(k, vals0, ["auto"]);\n        if (vals.length === 2) {\n          settings.alt("lineAlign", vals[1], ["start", "middle", "end"]);\n        }\n        break;\n      case "position":\n        vals = v.split(",");\n        settings.percent(k, vals[0]);\n        if (vals.length === 2) {\n          settings.alt("positionAlign", vals[1], ["start", "middle", "end"]);\n        }\n        break;\n      case "size":\n        settings.percent(k, v);\n        break;\n      case "align":\n        settings.alt(k, v, ["start", "middle", "end", "left", "right"]);\n        break;\n      }\n    }, /:/, /\\s/);\n\n    // Apply default values for any missing fields.\n    cue.region = settings.get("region", null);\n    cue.vertical = settings.get("vertical", "");\n    cue.line = settings.get("line", "auto");\n    cue.lineAlign = settings.get("lineAlign", "start");\n    cue.snapToLines = settings.get("snapToLines", true);\n    cue.size = settings.get("size", 100);\n    cue.align = settings.get("align", "middle");\n    cue.position = settings.get("position", {\n      start: 0,\n      left: 0,\n      middle: 50,\n      end: 100,\n      right: 100\n    }, cue.align);\n    cue.positionAlign = settings.get("positionAlign", {\n      start: "start",\n      left: "start",\n      middle: "middle",\n      end: "end",\n      right: "end"\n    }, cue.align);\n  }\n\n  function skipWhitespace() {\n    input = input.replace(/^\\s+/, "");\n  }\n\n  // 4.1 WebVTT cue timings.\n  skipWhitespace();\n  cue.startTime = consumeTimeStamp();   // (1) collect cue start time\n  skipWhitespace();\n  if (input.substr(0, 3) !== "--\x3e") {     // (3) next characters must match "--\x3e"\n    throw new ParsingError(ParsingError.Errors.BadTimeStamp,\n                           "Malformed time stamp (time stamps must be separated by \'--\x3e\'): " +\n                           oInput);\n  }\n  input = input.substr(3);\n  skipWhitespace();\n  cue.endTime = consumeTimeStamp();     // (5) collect cue end time\n\n  // 4.1 WebVTT cue settings list.\n  skipWhitespace();\n  consumeCueSettings(input, cue);\n}\n\nvar ESCAPE = {\n  "&amp;": "&",\n  "&lt;": "<",\n  "&gt;": ">",\n  "&lrm;": "\\u200e",\n  "&rlm;": "\\u200f",\n  "&nbsp;": "\\u00a0"\n};\n\nvar TAG_NAME = {\n  c: "span",\n  i: "i",\n  b: "b",\n  u: "u",\n  ruby: "ruby",\n  rt: "rt",\n  v: "span",\n  lang: "span"\n};\n\nvar TAG_ANNOTATION = {\n  v: "title",\n  lang: "lang"\n};\n\nvar NEEDS_PARENT = {\n  rt: "ruby"\n};\n\n// Parse content into a document fragment.\nfunction parseContent(window, input) {\n  function nextToken() {\n    // Check for end-of-string.\n    if (!input) {\n      return null;\n    }\n\n    // Consume \'n\' characters from the input.\n    function consume(result) {\n      input = input.substr(result.length);\n      return result;\n    }\n\n    var m = input.match(/^([^<]*)(<[^>]+>?)?/);\n    // If there is some text before the next tag, return it, otherwise return\n    // the tag.\n    return consume(m[1] ? m[1] : m[2]);\n  }\n\n  // Unescape a string \'s\'.\n  function unescape1(e) {\n    return ESCAPE[e];\n  }\n  function unescape(s) {\n    while ((m = s.match(/&(amp|lt|gt|lrm|rlm|nbsp);/))) {\n      s = s.replace(m[0], unescape1);\n    }\n    return s;\n  }\n\n  function shouldAdd(current, element) {\n    return !NEEDS_PARENT[element.localName] ||\n           NEEDS_PARENT[element.localName] === current.localName;\n  }\n\n  // Create an element for this tag.\n  function createElement(type, annotation) {\n    var tagName = TAG_NAME[type];\n    if (!tagName) {\n      return null;\n    }\n    var element = window.document.createElement(tagName);\n    element.localName = tagName;\n    var name = TAG_ANNOTATION[type];\n    if (name && annotation) {\n      element[name] = annotation.trim();\n    }\n    return element;\n  }\n\n  var rootDiv = window.document.createElement("div"),\n      current = rootDiv,\n      t,\n      tagStack = [];\n\n  while ((t = nextToken()) !== null) {\n    if (t[0] === \'<\') {\n      if (t[1] === "/") {\n        // If the closing tag matches, move back up to the parent node.\n        if (tagStack.length &&\n            tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {\n          tagStack.pop();\n          current = current.parentNode;\n        }\n        // Otherwise just ignore the end tag.\n        continue;\n      }\n      var ts = parseTimeStamp(t.substr(1, t.length - 2));\n      var node;\n      if (ts) {\n        // Timestamps are lead nodes as well.\n        node = window.document.createProcessingInstruction("timestamp", ts);\n        current.appendChild(node);\n        continue;\n      }\n      var m = t.match(/^<([^.\\s/0-9>]+)(\\.[^\\s\\\\>]+)?([^>\\\\]+)?(\\\\?)>?$/);\n      // If we can\'t parse the tag, skip to the next tag.\n      if (!m) {\n        continue;\n      }\n      // Try to construct an element, and ignore the tag if we couldn\'t.\n      node = createElement(m[1], m[3]);\n      if (!node) {\n        continue;\n      }\n      // Determine if the tag should be added based on the context of where it\n      // is placed in the cuetext.\n      if (!shouldAdd(current, node)) {\n        continue;\n      }\n      // Set the class list (as a list of classes, separated by space).\n      if (m[2]) {\n        node.className = m[2].substr(1).replace(\'.\', \' \');\n      }\n      // Append the node to the current node, and enter the scope of the new\n      // node.\n      tagStack.push(m[1]);\n      current.appendChild(node);\n      current = node;\n      continue;\n    }\n\n    // Text nodes are leaf nodes.\n    current.appendChild(window.document.createTextNode(unescape(t)));\n  }\n\n  return rootDiv;\n}\n\n// This is a list of all the Unicode characters that have a strong\n// right-to-left category. What this means is that these characters are\n// written right-to-left for sure. It was generated by pulling all the strong\n// right-to-left characters out of the Unicode data table. That table can\n// found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt\nvar strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6],\n [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d],\n [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6],\n [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5],\n [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815],\n [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858],\n [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f],\n [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c],\n [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1],\n [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc],\n [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808],\n [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855],\n [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f],\n [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13],\n [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58],\n [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72],\n [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f],\n [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32],\n [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42],\n [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f],\n [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59],\n [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62],\n [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77],\n [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b],\n [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];\n\nfunction isStrongRTLChar(charCode) {\n  for (var i = 0; i < strongRTLRanges.length; i++) {\n    var currentRange = strongRTLRanges[i];\n    if (charCode >= currentRange[0] && charCode <= currentRange[1]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction determineBidi(cueDiv) {\n  var nodeStack = [],\n      text = "",\n      charCode;\n\n  if (!cueDiv || !cueDiv.childNodes) {\n    return "ltr";\n  }\n\n  function pushNodes(nodeStack, node) {\n    for (var i = node.childNodes.length - 1; i >= 0; i--) {\n      nodeStack.push(node.childNodes[i]);\n    }\n  }\n\n  function nextTextNode(nodeStack) {\n    if (!nodeStack || !nodeStack.length) {\n      return null;\n    }\n\n    var node = nodeStack.pop(),\n        text = node.textContent || node.innerText;\n    if (text) {\n      // TODO: This should match all unicode type B characters (paragraph\n      // separator characters). See issue #115.\n      var m = text.match(/^.*(\\n|\\r)/);\n      if (m) {\n        nodeStack.length = 0;\n        return m[0];\n      }\n      return text;\n    }\n    if (node.tagName === "ruby") {\n      return nextTextNode(nodeStack);\n    }\n    if (node.childNodes) {\n      pushNodes(nodeStack, node);\n      return nextTextNode(nodeStack);\n    }\n  }\n\n  pushNodes(nodeStack, cueDiv);\n  while ((text = nextTextNode(nodeStack))) {\n    for (var i = 0; i < text.length; i++) {\n      charCode = text.charCodeAt(i);\n      if (isStrongRTLChar(charCode)) {\n        return "rtl";\n      }\n    }\n  }\n  return "ltr";\n}\n\nfunction computeLinePos(cue) {\n  if (typeof cue.line === "number" &&\n      (cue.snapToLines || (cue.line >= 0 && cue.line <= 100))) {\n    return cue.line;\n  }\n  if (!cue.track || !cue.track.textTrackList ||\n      !cue.track.textTrackList.mediaElement) {\n    return -1;\n  }\n  var track = cue.track,\n      trackList = track.textTrackList,\n      count = 0;\n  for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {\n    if (trackList[i].mode === "showing") {\n      count++;\n    }\n  }\n  return ++count * -1;\n}\n\nfunction StyleBox() {\n}\n\n// Apply styles to a div. If there is no div passed then it defaults to the\n// div on \'this\'.\nStyleBox.prototype.applyStyles = function(styles, div) {\n  div = div || this.div;\n  for (var prop in styles) {\n    if (styles.hasOwnProperty(prop)) {\n      div.style[prop] = styles[prop];\n    }\n  }\n};\n\nStyleBox.prototype.formatStyle = function(val, unit) {\n  return val === 0 ? 0 : val + unit;\n};\n\n// Constructs the computed display state of the cue (a div). Places the div\n// into the overlay which should be a block level element (usually a div).\nfunction CueStyleBox(window, cue, styleOptions) {\n  var isIE8 = (/MSIE\\s8\\.0/).test(navigator.userAgent);\n  var color = "rgba(255, 255, 255, 1)";\n  var backgroundColor = "rgba(0, 0, 0, 0.8)";\n\n  if (isIE8) {\n    color = "rgb(255, 255, 255)";\n    backgroundColor = "rgb(0, 0, 0)";\n  }\n\n  StyleBox.call(this);\n  this.cue = cue;\n\n  // Parse our cue\'s text into a DOM tree rooted at \'cueDiv\'. This div will\n  // have inline positioning and will function as the cue background box.\n  this.cueDiv = parseContent(window, cue.text);\n  var styles = {\n    color: color,\n    backgroundColor: backgroundColor,\n    position: "relative",\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0,\n    display: "inline"\n  };\n\n  if (!isIE8) {\n    styles.writingMode = cue.vertical === "" ? "horizontal-tb"\n                                             : cue.vertical === "lr" ? "vertical-lr"\n                                                                     : "vertical-rl";\n    styles.unicodeBidi = "plaintext";\n  }\n  this.applyStyles(styles, this.cueDiv);\n\n  // Create an absolutely positioned div that will be used to position the cue\n  // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS\n  // mirrors of them except "middle" which is "center" in CSS.\n  this.div = window.document.createElement("div");\n  styles = {\n    textAlign: cue.align === "middle" ? "center" : cue.align,\n    font: styleOptions.font,\n    whiteSpace: "pre-line",\n    position: "absolute"\n  };\n\n  if (!isIE8) {\n    styles.direction = determineBidi(this.cueDiv);\n    styles.writingMode = cue.vertical === "" ? "horizontal-tb"\n                                             : cue.vertical === "lr" ? "vertical-lr"\n                                                                     : "vertical-rl".\n    stylesunicodeBidi =  "plaintext";\n  }\n\n  this.applyStyles(styles);\n\n  this.div.appendChild(this.cueDiv);\n\n  // Calculate the distance from the reference edge of the viewport to the text\n  // position of the cue box. The reference edge will be resolved later when\n  // the box orientation styles are applied.\n  var textPos = 0;\n  switch (cue.positionAlign) {\n  case "start":\n    textPos = cue.position;\n    break;\n  case "middle":\n    textPos = cue.position - (cue.size / 2);\n    break;\n  case "end":\n    textPos = cue.position - cue.size;\n    break;\n  }\n\n  // Horizontal box orientation; textPos is the distance from the left edge of the\n  // area to the left edge of the box and cue.size is the distance extending to\n  // the right from there.\n  if (cue.vertical === "") {\n    this.applyStyles({\n      left:  this.formatStyle(textPos, "%"),\n      width: this.formatStyle(cue.size, "%")\n    });\n  // Vertical box orientation; textPos is the distance from the top edge of the\n  // area to the top edge of the box and cue.size is the height extending\n  // downwards from there.\n  } else {\n    this.applyStyles({\n      top: this.formatStyle(textPos, "%"),\n      height: this.formatStyle(cue.size, "%")\n    });\n  }\n\n  this.move = function(box) {\n    this.applyStyles({\n      top: this.formatStyle(box.top, "px"),\n      bottom: this.formatStyle(box.bottom, "px"),\n      left: this.formatStyle(box.left, "px"),\n      right: this.formatStyle(box.right, "px"),\n      height: this.formatStyle(box.height, "px"),\n      width: this.formatStyle(box.width, "px")\n    });\n  };\n}\nCueStyleBox.prototype = _objCreate(StyleBox.prototype);\nCueStyleBox.prototype.constructor = CueStyleBox;\n\n// Represents the co-ordinates of an Element in a way that we can easily\n// compute things with such as if it overlaps or intersects with another Element.\n// Can initialize it with either a StyleBox or another BoxPosition.\nfunction BoxPosition(obj) {\n  var isIE8 = (/MSIE\\s8\\.0/).test(navigator.userAgent);\n\n  // Either a BoxPosition was passed in and we need to copy it, or a StyleBox\n  // was passed in and we need to copy the results of \'getBoundingClientRect\'\n  // as the object returned is readonly. All co-ordinate values are in reference\n  // to the viewport origin (top left).\n  var lh, height, width, top;\n  if (obj.div) {\n    height = obj.div.offsetHeight;\n    width = obj.div.offsetWidth;\n    top = obj.div.offsetTop;\n\n    var rects = (rects = obj.div.childNodes) && (rects = rects[0]) &&\n                rects.getClientRects && rects.getClientRects();\n    obj = obj.div.getBoundingClientRect();\n    // In certain cases the outter div will be slightly larger then the sum of\n    // the inner div\'s lines. This could be due to bold text, etc, on some platforms.\n    // In this case we should get the average line height and use that. This will\n    // result in the desired behaviour.\n    lh = rects ? Math.max((rects[0] && rects[0].height) || 0, obj.height / rects.length)\n               : 0;\n\n  }\n  this.left = obj.left;\n  this.right = obj.right;\n  this.top = obj.top || top;\n  this.height = obj.height || height;\n  this.bottom = obj.bottom || (top + (obj.height || height));\n  this.width = obj.width || width;\n  this.lineHeight = lh !== undefined ? lh : obj.lineHeight;\n\n  if (isIE8 && !this.lineHeight) {\n    this.lineHeight = 13;\n  }\n}\n\n// Move the box along a particular axis. Optionally pass in an amount to move\n// the box. If no amount is passed then the default is the line height of the\n// box.\nBoxPosition.prototype.move = function(axis, toMove) {\n  toMove = toMove !== undefined ? toMove : this.lineHeight;\n  switch (axis) {\n  case "+x":\n    this.left += toMove;\n    this.right += toMove;\n    break;\n  case "-x":\n    this.left -= toMove;\n    this.right -= toMove;\n    break;\n  case "+y":\n    this.top += toMove;\n    this.bottom += toMove;\n    break;\n  case "-y":\n    this.top -= toMove;\n    this.bottom -= toMove;\n    break;\n  }\n};\n\n// Check if this box overlaps another box, b2.\nBoxPosition.prototype.overlaps = function(b2) {\n  return this.left < b2.right &&\n         this.right > b2.left &&\n         this.top < b2.bottom &&\n         this.bottom > b2.top;\n};\n\n// Check if this box overlaps any other boxes in boxes.\nBoxPosition.prototype.overlapsAny = function(boxes) {\n  for (var i = 0; i < boxes.length; i++) {\n    if (this.overlaps(boxes[i])) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// Check if this box is within another box.\nBoxPosition.prototype.within = function(container) {\n  return this.top >= container.top &&\n         this.bottom <= container.bottom &&\n         this.left >= container.left &&\n         this.right <= container.right;\n};\n\n// Check if this box is entirely within the container or it is overlapping\n// on the edge opposite of the axis direction passed. For example, if "+x" is\n// passed and the box is overlapping on the left edge of the container, then\n// return true.\nBoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {\n  switch (axis) {\n  case "+x":\n    return this.left < container.left;\n  case "-x":\n    return this.right > container.right;\n  case "+y":\n    return this.top < container.top;\n  case "-y":\n    return this.bottom > container.bottom;\n  }\n};\n\n// Find the percentage of the area that this box is overlapping with another\n// box.\nBoxPosition.prototype.intersectPercentage = function(b2) {\n  var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),\n      y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),\n      intersectArea = x * y;\n  return intersectArea / (this.height * this.width);\n};\n\n// Convert the positions from this box to CSS compatible positions using\n// the reference container\'s positions. This has to be done because this\n// box\'s positions are in reference to the viewport origin, whereas, CSS\n// values are in referecne to their respective edges.\nBoxPosition.prototype.toCSSCompatValues = function(reference) {\n  return {\n    top: this.top - reference.top,\n    bottom: reference.bottom - this.bottom,\n    left: this.left - reference.left,\n    right: reference.right - this.right,\n    height: this.height,\n    width: this.width\n  };\n};\n\n// Get an object that represents the box\'s position without anything extra.\n// Can pass a StyleBox, HTMLElement, or another BoxPositon.\nBoxPosition.getSimpleBoxPosition = function(obj) {\n  var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;\n  var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;\n  var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;\n\n  obj = obj.div ? obj.div.getBoundingClientRect() :\n                obj.tagName ? obj.getBoundingClientRect() : obj;\n  var ret = {\n    left: obj.left,\n    right: obj.right,\n    top: obj.top || top,\n    height: obj.height || height,\n    bottom: obj.bottom || (top + (obj.height || height)),\n    width: obj.width || width\n  };\n  return ret;\n};\n\n// Move a StyleBox to its specified, or next best, position. The containerBox\n// is the box that contains the StyleBox, such as a div. boxPositions are\n// a list of other boxes that the styleBox can\'t overlap with.\nfunction moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {\n\n  // Find the best position for a cue box, b, on the video. The axis parameter\n  // is a list of axis, the order of which, it will move the box along. For example:\n  // Passing ["+x", "-x"] will move the box first along the x axis in the positive\n  // direction. If it doesn\'t find a good position for it there it will then move\n  // it along the x axis in the negative direction.\n  function findBestPosition(b, axis) {\n    var bestPosition,\n        specifiedPosition = new BoxPosition(b),\n        percentage = 1; // Highest possible so the first thing we get is better.\n\n    for (var i = 0; i < axis.length; i++) {\n      while (b.overlapsOppositeAxis(containerBox, axis[i]) ||\n             (b.within(containerBox) && b.overlapsAny(boxPositions))) {\n        b.move(axis[i]);\n      }\n      // We found a spot where we aren\'t overlapping anything. This is our\n      // best position.\n      if (b.within(containerBox)) {\n        return b;\n      }\n      var p = b.intersectPercentage(containerBox);\n      // If we\'re outside the container box less then we were on our last try\n      // then remember this position as the best position.\n      if (percentage > p) {\n        bestPosition = new BoxPosition(b);\n        percentage = p;\n      }\n      // Reset the box position to the specified position.\n      b = new BoxPosition(specifiedPosition);\n    }\n    return bestPosition || specifiedPosition;\n  }\n\n  var boxPosition = new BoxPosition(styleBox),\n      cue = styleBox.cue,\n      linePos = computeLinePos(cue),\n      axis = [];\n\n  // If we have a line number to align the cue to.\n  if (cue.snapToLines) {\n    var size;\n    switch (cue.vertical) {\n    case "":\n      axis = [ "+y", "-y" ];\n      size = "height";\n      break;\n    case "rl":\n      axis = [ "+x", "-x" ];\n      size = "width";\n      break;\n    case "lr":\n      axis = [ "-x", "+x" ];\n      size = "width";\n      break;\n    }\n\n    var step = boxPosition.lineHeight,\n        position = step * Math.round(linePos),\n        maxPosition = containerBox[size] + step,\n        initialAxis = axis[0];\n\n    // If the specified intial position is greater then the max position then\n    // clamp the box to the amount of steps it would take for the box to\n    // reach the max position.\n    if (Math.abs(position) > maxPosition) {\n      position = position < 0 ? -1 : 1;\n      position *= Math.ceil(maxPosition / step) * step;\n    }\n\n    // If computed line position returns negative then line numbers are\n    // relative to the bottom of the video instead of the top. Therefore, we\n    // need to increase our initial position by the length or width of the\n    // video, depending on the writing direction, and reverse our axis directions.\n    if (linePos < 0) {\n      position += cue.vertical === "" ? containerBox.height : containerBox.width;\n      axis = axis.reverse();\n    }\n\n    // Move the box to the specified position. This may not be its best\n    // position.\n    boxPosition.move(initialAxis, position);\n\n  } else {\n    // If we have a percentage line value for the cue.\n    var calculatedPercentage = (boxPosition.lineHeight / containerBox.height) * 100;\n\n    switch (cue.lineAlign) {\n    case "middle":\n      linePos -= (calculatedPercentage / 2);\n      break;\n    case "end":\n      linePos -= calculatedPercentage;\n      break;\n    }\n\n    // Apply initial line position to the cue box.\n    switch (cue.vertical) {\n    case "":\n      styleBox.applyStyles({\n        top: styleBox.formatStyle(linePos, "%")\n      });\n      break;\n    case "rl":\n      styleBox.applyStyles({\n        left: styleBox.formatStyle(linePos, "%")\n      });\n      break;\n    case "lr":\n      styleBox.applyStyles({\n        right: styleBox.formatStyle(linePos, "%")\n      });\n      break;\n    }\n\n    axis = [ "+y", "-x", "+x", "-y" ];\n\n    // Get the box position again after we\'ve applied the specified positioning\n    // to it.\n    boxPosition = new BoxPosition(styleBox);\n  }\n\n  var bestPosition = findBestPosition(boxPosition, axis);\n  styleBox.move(bestPosition.toCSSCompatValues(containerBox));\n}\n\nfunction WebVTT() {\n  // Nothing\n}\n\n// Helper to allow strings to be decoded instead of the default binary utf8 data.\nWebVTT.StringDecoder = function() {\n  return {\n    decode: function(data) {\n      if (!data) {\n        return "";\n      }\n      if (typeof data !== "string") {\n        throw new Error("Error - expected string data.");\n      }\n      return decodeURIComponent(encodeURIComponent(data));\n    }\n  };\n};\n\nWebVTT.convertCueToDOMTree = function(window, cuetext) {\n  if (!window || !cuetext) {\n    return null;\n  }\n  return parseContent(window, cuetext);\n};\n\nvar FONT_SIZE_PERCENT = 0.05;\nvar FONT_STYLE = "sans-serif";\nvar CUE_BACKGROUND_PADDING = "1.5%";\n\n// Runs the processing model over the cues and regions passed to it.\n// @param overlay A block level element (usually a div) that the computed cues\n//                and regions will be placed into.\nWebVTT.processCues = function(window, cues, overlay) {\n  if (!window || !cues || !overlay) {\n    return null;\n  }\n\n  // Remove all previous children.\n  while (overlay.firstChild) {\n    overlay.removeChild(overlay.firstChild);\n  }\n\n  var paddedOverlay = window.document.createElement("div");\n  paddedOverlay.style.position = "absolute";\n  paddedOverlay.style.left = "0";\n  paddedOverlay.style.right = "0";\n  paddedOverlay.style.top = "0";\n  paddedOverlay.style.bottom = "0";\n  paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;\n  overlay.appendChild(paddedOverlay);\n\n  // Determine if we need to compute the display states of the cues. This could\n  // be the case if a cue\'s state has been changed since the last computation or\n  // if it has not been computed yet.\n  function shouldCompute(cues) {\n    for (var i = 0; i < cues.length; i++) {\n      if (cues[i].hasBeenReset || !cues[i].displayState) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // We don\'t need to recompute the cues\' display states. Just reuse them.\n  if (!shouldCompute(cues)) {\n    for (var i = 0; i < cues.length; i++) {\n      paddedOverlay.appendChild(cues[i].displayState);\n    }\n    return;\n  }\n\n  var boxPositions = [],\n      containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),\n      fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;\n  var styleOptions = {\n    font: fontSize + "px " + FONT_STYLE\n  };\n\n  (function() {\n    var styleBox, cue;\n\n    for (var i = 0; i < cues.length; i++) {\n      cue = cues[i];\n\n      // Compute the intial position and styles of the cue div.\n      styleBox = new CueStyleBox(window, cue, styleOptions);\n      paddedOverlay.appendChild(styleBox.div);\n\n      // Move the cue div to it\'s correct line position.\n      moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);\n\n      // Remember the computed div so that we don\'t have to recompute it later\n      // if we don\'t have too.\n      cue.displayState = styleBox.div;\n\n      boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));\n    }\n  })();\n};\n\nWebVTT.Parser = function(window, vttjs, decoder) {\n  if (!decoder) {\n    decoder = vttjs;\n    vttjs = {};\n  }\n  if (!vttjs) {\n    vttjs = {};\n  }\n\n  this.window = window;\n  this.vttjs = vttjs;\n  this.state = "INITIAL";\n  this.buffer = "";\n  this.decoder = decoder || new TextDecoder("utf8");\n  this.regionList = [];\n};\n\nWebVTT.Parser.prototype = {\n  // If the error is a ParsingError then report it to the consumer if\n  // possible. If it\'s not a ParsingError then throw it like normal.\n  reportOrThrowError: function(e) {\n    if (e instanceof ParsingError) {\n      this.onparsingerror && this.onparsingerror(e);\n    } else {\n      throw e;\n    }\n  },\n  parse: function (data) {\n    var self = this;\n\n    // If there is no data then we won\'t decode it, but will just try to parse\n    // whatever is in buffer already. This may occur in circumstances, for\n    // example when flush() is called.\n    if (data) {\n      // Try to decode the data that we received.\n      self.buffer += self.decoder.decode(data, {stream: true});\n    }\n\n    function collectNextLine() {\n      var buffer = self.buffer;\n      var pos = 0;\n      while (pos < buffer.length && buffer[pos] !== \'\\r\' && buffer[pos] !== \'\\n\') {\n        ++pos;\n      }\n      var line = buffer.substr(0, pos);\n      // Advance the buffer early in case we fail below.\n      if (buffer[pos] === \'\\r\') {\n        ++pos;\n      }\n      if (buffer[pos] === \'\\n\') {\n        ++pos;\n      }\n      self.buffer = buffer.substr(pos);\n      return line;\n    }\n\n    // 3.4 WebVTT region and WebVTT region settings syntax\n    function parseRegion(input) {\n      var settings = new Settings();\n\n      parseOptions(input, function (k, v) {\n        switch (k) {\n        case "id":\n          settings.set(k, v);\n          break;\n        case "width":\n          settings.percent(k, v);\n          break;\n        case "lines":\n          settings.integer(k, v);\n          break;\n        case "regionanchor":\n        case "viewportanchor":\n          var xy = v.split(\',\');\n          if (xy.length !== 2) {\n            break;\n          }\n          // We have to make sure both x and y parse, so use a temporary\n          // settings object here.\n          var anchor = new Settings();\n          anchor.percent("x", xy[0]);\n          anchor.percent("y", xy[1]);\n          if (!anchor.has("x") || !anchor.has("y")) {\n            break;\n          }\n          settings.set(k + "X", anchor.get("x"));\n          settings.set(k + "Y", anchor.get("y"));\n          break;\n        case "scroll":\n          settings.alt(k, v, ["up"]);\n          break;\n        }\n      }, /=/, /\\s/);\n\n      // Create the region, using default values for any values that were not\n      // specified.\n      if (settings.has("id")) {\n        var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();\n        region.width = settings.get("width", 100);\n        region.lines = settings.get("lines", 3);\n        region.regionAnchorX = settings.get("regionanchorX", 0);\n        region.regionAnchorY = settings.get("regionanchorY", 100);\n        region.viewportAnchorX = settings.get("viewportanchorX", 0);\n        region.viewportAnchorY = settings.get("viewportanchorY", 100);\n        region.scroll = settings.get("scroll", "");\n        // Register the region.\n        self.onregion && self.onregion(region);\n        // Remember the VTTRegion for later in case we parse any VTTCues that\n        // reference it.\n        self.regionList.push({\n          id: settings.get("id"),\n          region: region\n        });\n      }\n    }\n\n    // draft-pantos-http-live-streaming-20\n    // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5\n    // 3.5 WebVTT\n    function parseTimestampMap(input) {\n      var settings = new Settings();\n\n      parseOptions(input, function(k, v) {\n        switch(k) {\n        case "MPEGT":\n          settings.integer(k + \'S\', v);\n          break;\n        case "LOCA":\n          settings.set(k + \'L\', parseTimeStamp(v));\n          break;\n        }\n      }, /[^\\d]:/, /,/);\n\n      self.ontimestampmap && self.ontimestampmap({\n        "MPEGTS": settings.get("MPEGTS"),\n        "LOCAL": settings.get("LOCAL")\n      });\n    }\n\n    // 3.2 WebVTT metadata header syntax\n    function parseHeader(input) {\n      if (input.match(/X-TIMESTAMP-MAP/)) {\n        // This line contains HLS X-TIMESTAMP-MAP metadata\n        parseOptions(input, function(k, v) {\n          switch(k) {\n          case "X-TIMESTAMP-MAP":\n            parseTimestampMap(v);\n            break;\n          }\n        }, /=/);\n      } else {\n        parseOptions(input, function (k, v) {\n          switch (k) {\n          case "Region":\n            // 3.3 WebVTT region metadata header syntax\n            parseRegion(v);\n            break;\n          }\n        }, /:/);\n      }\n\n    }\n\n    // 5.1 WebVTT file parsing.\n    try {\n      var line;\n      if (self.state === "INITIAL") {\n        // We can\'t start parsing until we have the first line.\n        if (!/\\r\\n|\\n/.test(self.buffer)) {\n          return this;\n        }\n\n        line = collectNextLine();\n\n        var m = line.match(/^WEBVTT([ \\t].*)?$/);\n        if (!m || !m[0]) {\n          throw new ParsingError(ParsingError.Errors.BadSignature);\n        }\n\n        self.state = "HEADER";\n      }\n\n      var alreadyCollectedLine = false;\n      while (self.buffer) {\n        // We can\'t parse a line until we have the full line.\n        if (!/\\r\\n|\\n/.test(self.buffer)) {\n          return this;\n        }\n\n        if (!alreadyCollectedLine) {\n          line = collectNextLine();\n        } else {\n          alreadyCollectedLine = false;\n        }\n\n        switch (self.state) {\n        case "HEADER":\n          // 13-18 - Allow a header (metadata) under the WEBVTT line.\n          if (/:/.test(line)) {\n            parseHeader(line);\n          } else if (!line) {\n            // An empty line terminates the header and starts the body (cues).\n            self.state = "ID";\n          }\n          continue;\n        case "NOTE":\n          // Ignore NOTE blocks.\n          if (!line) {\n            self.state = "ID";\n          }\n          continue;\n        case "ID":\n          // Check for the start of NOTE blocks.\n          if (/^NOTE($|[ \\t])/.test(line)) {\n            self.state = "NOTE";\n            break;\n          }\n          // 19-29 - Allow any number of line terminators, then initialize new cue values.\n          if (!line) {\n            continue;\n          }\n          self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, "");\n          self.state = "CUE";\n          // 30-39 - Check if self line contains an optional identifier or timing data.\n          if (line.indexOf("--\x3e") === -1) {\n            self.cue.id = line;\n            continue;\n          }\n          // Process line as start of a cue.\n          /*falls through*/\n        case "CUE":\n          // 40 - Collect cue timings and settings.\n          try {\n            parseCue(line, self.cue, self.regionList);\n          } catch (e) {\n            self.reportOrThrowError(e);\n            // In case of an error ignore rest of the cue.\n            self.cue = null;\n            self.state = "BADCUE";\n            continue;\n          }\n          self.state = "CUETEXT";\n          continue;\n        case "CUETEXT":\n          var hasSubstring = line.indexOf("--\x3e") !== -1;\n          // 34 - If we have an empty line then report the cue.\n          // 35 - If we have the special substring \'--\x3e\' then report the cue,\n          // but do not collect the line as we need to process the current\n          // one as a new cue.\n          if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n            // We are done parsing self cue.\n            self.oncue && self.oncue(self.cue);\n            self.cue = null;\n            self.state = "ID";\n            continue;\n          }\n          if (self.cue.text) {\n            self.cue.text += "\\n";\n          }\n          self.cue.text += line;\n          continue;\n        case "BADCUE": // BADCUE\n          // 54-62 - Collect and discard the remaining cue.\n          if (!line) {\n            self.state = "ID";\n          }\n          continue;\n        }\n      }\n    } catch (e) {\n      self.reportOrThrowError(e);\n\n      // If we are currently parsing a cue, report what we have.\n      if (self.state === "CUETEXT" && self.cue && self.oncue) {\n        self.oncue(self.cue);\n      }\n      self.cue = null;\n      // Enter BADWEBVTT state if header was not parsed correctly otherwise\n      // another exception occurred so enter BADCUE state.\n      self.state = self.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";\n    }\n    return this;\n  },\n  flush: function () {\n    var self = this;\n    try {\n      // Finish decoding the stream.\n      self.buffer += self.decoder.decode();\n      // Synthesize the end of the current cue or region.\n      if (self.cue || self.state === "HEADER") {\n        self.buffer += "\\n\\n";\n        self.parse();\n      }\n      // If we\'ve flushed, parsed, and we\'re still on the INITIAL state then\n      // that means we don\'t have enough of the stream to parse the first\n      // line.\n      if (self.state === "INITIAL") {\n        throw new ParsingError(ParsingError.Errors.BadSignature);\n      }\n    } catch(e) {\n      self.reportOrThrowError(e);\n    }\n    self.onflush && self.onflush();\n    return this;\n  }\n};\n\nmodule.exports = WebVTT;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL3ZpZGVvanMtdnR0LmpzL2xpYi92dHQuanM/NThjZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGNBQWMsdUJBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUixPQUFPO0FBQ1AsT0FBTztBQUNQLFFBQVE7QUFDUixRQUFRO0FBQ1IsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdEQUFnRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QixtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyB2dHQuanMgQ29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiAtKi0gTW9kZTogSmF2YTsgdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IGMtYmFzaWMtb2Zmc2V0OiAyIC0qLSAqL1xuLyogdmltOiBzZXQgc2hpZnR3aWR0aD0yIHRhYnN0b3A9MiBhdXRvaW5kZW50IGNpbmRlbnQgZXhwYW5kdGFiOiAqL1xudmFyIF9vYmpDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gRigpIHt9XG4gIHJldHVybiBmdW5jdGlvbihvKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0LmNyZWF0ZSBzaGltIG9ubHkgYWNjZXB0cyBvbmUgcGFyYW1ldGVyLicpO1xuICAgIH1cbiAgICBGLnByb3RvdHlwZSA9IG87XG4gICAgcmV0dXJuIG5ldyBGKCk7XG4gIH07XG59KSgpO1xuXG4vLyBDcmVhdGVzIGEgbmV3IFBhcnNlckVycm9yIG9iamVjdCBmcm9tIGFuIGVycm9yRGF0YSBvYmplY3QuIFRoZSBlcnJvckRhdGFcbi8vIG9iamVjdCBzaG91bGQgaGF2ZSBkZWZhdWx0IGNvZGUgYW5kIG1lc3NhZ2UgcHJvcGVydGllcy4gVGhlIGRlZmF1bHQgbWVzc2FnZVxuLy8gcHJvcGVydHkgY2FuIGJlIG92ZXJyaWRlbiBieSBwYXNzaW5nIGluIGEgbWVzc2FnZSBwYXJhbWV0ZXIuXG4vLyBTZWUgUGFyc2luZ0Vycm9yLkVycm9ycyBiZWxvdyBmb3IgYWNjZXB0YWJsZSBlcnJvcnMuXG5mdW5jdGlvbiBQYXJzaW5nRXJyb3IoZXJyb3JEYXRhLCBtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiUGFyc2luZ0Vycm9yXCI7XG4gIHRoaXMuY29kZSA9IGVycm9yRGF0YS5jb2RlO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IGVycm9yRGF0YS5tZXNzYWdlO1xufVxuUGFyc2luZ0Vycm9yLnByb3RvdHlwZSA9IF9vYmpDcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblBhcnNpbmdFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJzaW5nRXJyb3I7XG5cbi8vIFBhcnNpbmdFcnJvciBtZXRhZGF0YSBmb3IgYWNjZXB0YWJsZSBQYXJzaW5nRXJyb3JzLlxuUGFyc2luZ0Vycm9yLkVycm9ycyA9IHtcbiAgQmFkU2lnbmF0dXJlOiB7XG4gICAgY29kZTogMCxcbiAgICBtZXNzYWdlOiBcIk1hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLlwiXG4gIH0sXG4gIEJhZFRpbWVTdGFtcDoge1xuICAgIGNvZGU6IDEsXG4gICAgbWVzc2FnZTogXCJNYWxmb3JtZWQgdGltZSBzdGFtcC5cIlxuICB9XG59O1xuXG4vLyBUcnkgdG8gcGFyc2UgaW5wdXQgYXMgYSB0aW1lIHN0YW1wLlxuZnVuY3Rpb24gcGFyc2VUaW1lU3RhbXAoaW5wdXQpIHtcblxuICBmdW5jdGlvbiBjb21wdXRlU2Vjb25kcyhoLCBtLCBzLCBmKSB7XG4gICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIChmIHwgMCkgLyAxMDAwO1xuICB9XG5cbiAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihcXGQrKTooXFxkezJ9KSg6XFxkezJ9KT9cXC4oXFxkezN9KS8pO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChtWzNdKSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCBtWzNdLnJlcGxhY2UoXCI6XCIsIFwiXCIpLCBtWzRdKTtcbiAgfSBlbHNlIGlmIChtWzFdID4gNTkpIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzXTpbbWludXRlc10uW21pbGxpc2Vjb25kc11cbiAgICAvLyBGaXJzdCBwb3NpdGlvbiBpcyBob3VycyBhcyBpdCdzIG92ZXIgNTkuXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIDAsICBtWzRdKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcygwLCBtWzFdLCBtWzJdLCBtWzRdKTtcbiAgfVxufVxuXG4vLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3Rcbi8vIGFzc2lnbm1lbnQgdG8gYSBzcGVjaWZpYyBrZXkuXG5mdW5jdGlvbiBTZXR0aW5ncygpIHtcbiAgdGhpcy52YWx1ZXMgPSBfb2JqQ3JlYXRlKG51bGwpO1xufVxuXG5TZXR0aW5ncy5wcm90b3R5cGUgPSB7XG4gIC8vIE9ubHkgYWNjZXB0IHRoZSBmaXJzdCBhc3NpZ25tZW50IHRvIGFueSBrZXkuXG4gIHNldDogZnVuY3Rpb24oaywgdikge1xuICAgIGlmICghdGhpcy5nZXQoaykgJiYgdiAhPT0gXCJcIikge1xuICAgICAgdGhpcy52YWx1ZXNba10gPSB2O1xuICAgIH1cbiAgfSxcbiAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgYSBrZXksIG9yIGEgZGVmYXVsdCB2YWx1ZS5cbiAgLy8gSWYgJ2RlZmF1bHRLZXknIGlzIHBhc3NlZCB0aGVuICdkZmx0JyBpcyBhc3N1bWVkIHRvIGJlIGFuIG9iamVjdCB3aXRoXG4gIC8vIGEgbnVtYmVyIG9mIHBvc3NpYmxlIGRlZmF1bHQgdmFsdWVzIGFzIHByb3BlcnRpZXMgd2hlcmUgJ2RlZmF1bHRLZXknIGlzXG4gIC8vIHRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBjaG9zZW47IG90aGVyd2lzZSBpdCdzIGFzc3VtZWQgdG8gYmVcbiAgLy8gYSBzaW5nbGUgdmFsdWUuXG4gIGdldDogZnVuY3Rpb24oaywgZGZsdCwgZGVmYXVsdEtleSkge1xuICAgIGlmIChkZWZhdWx0S2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHRbZGVmYXVsdEtleV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdDtcbiAgfSxcbiAgLy8gQ2hlY2sgd2hldGhlciB3ZSBoYXZlIGEgdmFsdWUgZm9yIGEga2V5LlxuICBoYXM6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayBpbiB0aGlzLnZhbHVlcztcbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgb25lIG9mIHRoZSBnaXZlbiBhbHRlcm5hdGl2ZXMuXG4gIGFsdDogZnVuY3Rpb24oaywgdiwgYSkge1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgYS5sZW5ndGg7ICsrbikge1xuICAgICAgaWYgKHYgPT09IGFbbl0pIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCAoc2lnbmVkKSBpbnRlZ2VyLlxuICBpbnRlZ2VyOiBmdW5jdGlvbihrLCB2KSB7XG4gICAgaWYgKC9eLT9cXGQrJC8udGVzdCh2KSkgeyAvLyBpbnRlZ2VyXG4gICAgICB0aGlzLnNldChrLCBwYXJzZUludCh2LCAxMCkpO1xuICAgIH1cbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCBwZXJjZW50YWdlLlxuICBwZXJjZW50OiBmdW5jdGlvbihrLCB2KSB7XG4gICAgdmFyIG07XG4gICAgaWYgKChtID0gdi5tYXRjaCgvXihbXFxkXXsxLDN9KShcXC5bXFxkXSopPyUkLykpKSB7XG4gICAgICB2ID0gcGFyc2VGbG9hdCh2KTtcbiAgICAgIGlmICh2ID49IDAgJiYgdiA8PSAxMDApIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBpbnB1dCBpbnRvIGdyb3VwcyBzZXBhcmF0ZWQgYnkgJ2dyb3VwRGVsaW0nLCBhbmRcbi8vIGludGVycHJldGUgZWFjaCBncm91cCBhcyBhIGtleS92YWx1ZSBwYWlyIHNlcGFyYXRlZCBieSAna2V5VmFsdWVEZWxpbScuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMoaW5wdXQsIGNhbGxiYWNrLCBrZXlWYWx1ZURlbGltLCBncm91cERlbGltKSB7XG4gIHZhciBncm91cHMgPSBncm91cERlbGltID8gaW5wdXQuc3BsaXQoZ3JvdXBEZWxpbSkgOiBbaW5wdXRdO1xuICBmb3IgKHZhciBpIGluIGdyb3Vwcykge1xuICAgIGlmICh0eXBlb2YgZ3JvdXBzW2ldICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGt2ID0gZ3JvdXBzW2ldLnNwbGl0KGtleVZhbHVlRGVsaW0pO1xuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgayA9IGt2WzBdO1xuICAgIHZhciB2ID0ga3ZbMV07XG4gICAgY2FsbGJhY2soaywgdik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VDdWUoaW5wdXQsIGN1ZSwgcmVnaW9uTGlzdCkge1xuICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgdmFyIG9JbnB1dCA9IGlucHV0O1xuICAvLyA0LjEgV2ViVlRUIHRpbWVzdGFtcFxuICBmdW5jdGlvbiBjb25zdW1lVGltZVN0YW1wKCkge1xuICAgIHZhciB0cyA9IHBhcnNlVGltZVN0YW1wKGlucHV0KTtcbiAgICBpZiAodHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IoUGFyc2luZ0Vycm9yLkVycm9ycy5CYWRUaW1lU3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNYWxmb3JtZWQgdGltZXN0YW1wOiBcIiArIG9JbnB1dCk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aW1lIHN0YW1wIGZyb20gaW5wdXQuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCBcIlwiKTtcbiAgICByZXR1cm4gdHM7XG4gIH1cblxuICAvLyA0LjQuMiBXZWJWVFQgY3VlIHNldHRpbmdzXG4gIGZ1bmN0aW9uIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKSB7XG4gICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG5cbiAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICBzd2l0Y2ggKGspIHtcbiAgICAgIGNhc2UgXCJyZWdpb25cIjpcbiAgICAgICAgLy8gRmluZCB0aGUgbGFzdCByZWdpb24gd2UgcGFyc2VkIHdpdGggdGhlIHNhbWUgcmVnaW9uIGlkLlxuICAgICAgICBmb3IgKHZhciBpID0gcmVnaW9uTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5zZXQoaywgcmVnaW9uTGlzdFtpXS5yZWdpb24pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbXCJybFwiLCBcImxyXCJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICB2YXIgdmFscyA9IHYuc3BsaXQoXCIsXCIpLFxuICAgICAgICAgICAgdmFsczAgPSB2YWxzWzBdO1xuICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHZhbHMwKTtcbiAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzMCkgPyBzZXR0aW5ncy5zZXQoXCJzbmFwVG9MaW5lc1wiLCBmYWxzZSkgOiBudWxsO1xuICAgICAgICBzZXR0aW5ncy5hbHQoaywgdmFsczAsIFtcImF1dG9cIl0pO1xuICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoXCJsaW5lQWxpZ25cIiwgdmFsc1sxXSwgW1wic3RhcnRcIiwgXCJtaWRkbGVcIiwgXCJlbmRcIl0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvc2l0aW9uXCI6XG4gICAgICAgIHZhbHMgPSB2LnNwbGl0KFwiLFwiKTtcbiAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzWzBdKTtcbiAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KFwicG9zaXRpb25BbGlnblwiLCB2YWxzWzFdLCBbXCJzdGFydFwiLCBcIm1pZGRsZVwiLCBcImVuZFwiXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2l6ZVwiOlxuICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHYpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhbGlnblwiOlxuICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgW1wic3RhcnRcIiwgXCJtaWRkbGVcIiwgXCJlbmRcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LCAvOi8sIC9cXHMvKTtcblxuICAgIC8vIEFwcGx5IGRlZmF1bHQgdmFsdWVzIGZvciBhbnkgbWlzc2luZyBmaWVsZHMuXG4gICAgY3VlLnJlZ2lvbiA9IHNldHRpbmdzLmdldChcInJlZ2lvblwiLCBudWxsKTtcbiAgICBjdWUudmVydGljYWwgPSBzZXR0aW5ncy5nZXQoXCJ2ZXJ0aWNhbFwiLCBcIlwiKTtcbiAgICBjdWUubGluZSA9IHNldHRpbmdzLmdldChcImxpbmVcIiwgXCJhdXRvXCIpO1xuICAgIGN1ZS5saW5lQWxpZ24gPSBzZXR0aW5ncy5nZXQoXCJsaW5lQWxpZ25cIiwgXCJzdGFydFwiKTtcbiAgICBjdWUuc25hcFRvTGluZXMgPSBzZXR0aW5ncy5nZXQoXCJzbmFwVG9MaW5lc1wiLCB0cnVlKTtcbiAgICBjdWUuc2l6ZSA9IHNldHRpbmdzLmdldChcInNpemVcIiwgMTAwKTtcbiAgICBjdWUuYWxpZ24gPSBzZXR0aW5ncy5nZXQoXCJhbGlnblwiLCBcIm1pZGRsZVwiKTtcbiAgICBjdWUucG9zaXRpb24gPSBzZXR0aW5ncy5nZXQoXCJwb3NpdGlvblwiLCB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBtaWRkbGU6IDUwLFxuICAgICAgZW5kOiAxMDAsXG4gICAgICByaWdodDogMTAwXG4gICAgfSwgY3VlLmFsaWduKTtcbiAgICBjdWUucG9zaXRpb25BbGlnbiA9IHNldHRpbmdzLmdldChcInBvc2l0aW9uQWxpZ25cIiwge1xuICAgICAgc3RhcnQ6IFwic3RhcnRcIixcbiAgICAgIGxlZnQ6IFwic3RhcnRcIixcbiAgICAgIG1pZGRsZTogXCJtaWRkbGVcIixcbiAgICAgIGVuZDogXCJlbmRcIixcbiAgICAgIHJpZ2h0OiBcImVuZFwiXG4gICAgfSwgY3VlLmFsaWduKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXlxccysvLCBcIlwiKTtcbiAgfVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHRpbWluZ3MuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGN1ZS5zdGFydFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7ICAgLy8gKDEpIGNvbGxlY3QgY3VlIHN0YXJ0IHRpbWVcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgaWYgKGlucHV0LnN1YnN0cigwLCAzKSAhPT0gXCItLT5cIikgeyAgICAgLy8gKDMpIG5leHQgY2hhcmFjdGVycyBtdXN0IG1hdGNoIFwiLS0+XCJcbiAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvci5FcnJvcnMuQmFkVGltZVN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNYWxmb3JtZWQgdGltZSBzdGFtcCAodGltZSBzdGFtcHMgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgJy0tPicpOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvSW5wdXQpO1xuICB9XG4gIGlucHV0ID0gaW5wdXQuc3Vic3RyKDMpO1xuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuZW5kVGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgICAgIC8vICg1KSBjb2xsZWN0IGN1ZSBlbmQgdGltZVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHNldHRpbmdzIGxpc3QuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKTtcbn1cblxudmFyIEVTQ0FQRSA9IHtcbiAgXCImYW1wO1wiOiBcIiZcIixcbiAgXCImbHQ7XCI6IFwiPFwiLFxuICBcIiZndDtcIjogXCI+XCIsXG4gIFwiJmxybTtcIjogXCJcXHUyMDBlXCIsXG4gIFwiJnJsbTtcIjogXCJcXHUyMDBmXCIsXG4gIFwiJm5ic3A7XCI6IFwiXFx1MDBhMFwiXG59O1xuXG52YXIgVEFHX05BTUUgPSB7XG4gIGM6IFwic3BhblwiLFxuICBpOiBcImlcIixcbiAgYjogXCJiXCIsXG4gIHU6IFwidVwiLFxuICBydWJ5OiBcInJ1YnlcIixcbiAgcnQ6IFwicnRcIixcbiAgdjogXCJzcGFuXCIsXG4gIGxhbmc6IFwic3BhblwiXG59O1xuXG52YXIgVEFHX0FOTk9UQVRJT04gPSB7XG4gIHY6IFwidGl0bGVcIixcbiAgbGFuZzogXCJsYW5nXCJcbn07XG5cbnZhciBORUVEU19QQVJFTlQgPSB7XG4gIHJ0OiBcInJ1YnlcIlxufTtcblxuLy8gUGFyc2UgY29udGVudCBpbnRvIGEgZG9jdW1lbnQgZnJhZ21lbnQuXG5mdW5jdGlvbiBwYXJzZUNvbnRlbnQod2luZG93LCBpbnB1dCkge1xuICBmdW5jdGlvbiBuZXh0VG9rZW4oKSB7XG4gICAgLy8gQ2hlY2sgZm9yIGVuZC1vZi1zdHJpbmcuXG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ29uc3VtZSAnbicgY2hhcmFjdGVycyBmcm9tIHRoZSBpbnB1dC5cbiAgICBmdW5jdGlvbiBjb25zdW1lKHJlc3VsdCkge1xuICAgICAgaW5wdXQgPSBpbnB1dC5zdWJzdHIocmVzdWx0Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBtID0gaW5wdXQubWF0Y2goL14oW148XSopKDxbXj5dKz4/KT8vKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBzb21lIHRleHQgYmVmb3JlIHRoZSBuZXh0IHRhZywgcmV0dXJuIGl0LCBvdGhlcndpc2UgcmV0dXJuXG4gICAgLy8gdGhlIHRhZy5cbiAgICByZXR1cm4gY29uc3VtZShtWzFdID8gbVsxXSA6IG1bMl0pO1xuICB9XG5cbiAgLy8gVW5lc2NhcGUgYSBzdHJpbmcgJ3MnLlxuICBmdW5jdGlvbiB1bmVzY2FwZTEoZSkge1xuICAgIHJldHVybiBFU0NBUEVbZV07XG4gIH1cbiAgZnVuY3Rpb24gdW5lc2NhcGUocykge1xuICAgIHdoaWxlICgobSA9IHMubWF0Y2goLyYoYW1wfGx0fGd0fGxybXxybG18bmJzcCk7LykpKSB7XG4gICAgICBzID0gcy5yZXBsYWNlKG1bMF0sIHVuZXNjYXBlMSk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkQWRkKGN1cnJlbnQsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIU5FRURTX1BBUkVOVFtlbGVtZW50LmxvY2FsTmFtZV0gfHxcbiAgICAgICAgICAgTkVFRFNfUEFSRU5UW2VsZW1lbnQubG9jYWxOYW1lXSA9PT0gY3VycmVudC5sb2NhbE5hbWU7XG4gIH1cblxuICAvLyBDcmVhdGUgYW4gZWxlbWVudCBmb3IgdGhpcyB0YWcuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgYW5ub3RhdGlvbikge1xuICAgIHZhciB0YWdOYW1lID0gVEFHX05BTUVbdHlwZV07XG4gICAgaWYgKCF0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBlbGVtZW50LmxvY2FsTmFtZSA9IHRhZ05hbWU7XG4gICAgdmFyIG5hbWUgPSBUQUdfQU5OT1RBVElPTlt0eXBlXTtcbiAgICBpZiAobmFtZSAmJiBhbm5vdGF0aW9uKSB7XG4gICAgICBlbGVtZW50W25hbWVdID0gYW5ub3RhdGlvbi50cmltKCk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdmFyIHJvb3REaXYgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgIGN1cnJlbnQgPSByb290RGl2LFxuICAgICAgdCxcbiAgICAgIHRhZ1N0YWNrID0gW107XG5cbiAgd2hpbGUgKCh0ID0gbmV4dFRva2VuKCkpICE9PSBudWxsKSB7XG4gICAgaWYgKHRbMF0gPT09ICc8Jykge1xuICAgICAgaWYgKHRbMV0gPT09IFwiL1wiKSB7XG4gICAgICAgIC8vIElmIHRoZSBjbG9zaW5nIHRhZyBtYXRjaGVzLCBtb3ZlIGJhY2sgdXAgdG8gdGhlIHBhcmVudCBub2RlLlxuICAgICAgICBpZiAodGFnU3RhY2subGVuZ3RoICYmXG4gICAgICAgICAgICB0YWdTdGFja1t0YWdTdGFjay5sZW5ndGggLSAxXSA9PT0gdC5zdWJzdHIoMikucmVwbGFjZShcIj5cIiwgXCJcIikpIHtcbiAgICAgICAgICB0YWdTdGFjay5wb3AoKTtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGlnbm9yZSB0aGUgZW5kIHRhZy5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgdHMgPSBwYXJzZVRpbWVTdGFtcCh0LnN1YnN0cigxLCB0Lmxlbmd0aCAtIDIpKTtcbiAgICAgIHZhciBub2RlO1xuICAgICAgaWYgKHRzKSB7XG4gICAgICAgIC8vIFRpbWVzdGFtcHMgYXJlIGxlYWQgbm9kZXMgYXMgd2VsbC5cbiAgICAgICAgbm9kZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oXCJ0aW1lc3RhbXBcIiwgdHMpO1xuICAgICAgICBjdXJyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtID0gdC5tYXRjaCgvXjwoW14uXFxzLzAtOT5dKykoXFwuW15cXHNcXFxcPl0rKT8oW14+XFxcXF0rKT8oXFxcXD8pPj8kLyk7XG4gICAgICAvLyBJZiB3ZSBjYW4ndCBwYXJzZSB0aGUgdGFnLCBza2lwIHRvIHRoZSBuZXh0IHRhZy5cbiAgICAgIGlmICghbSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRyeSB0byBjb25zdHJ1Y3QgYW4gZWxlbWVudCwgYW5kIGlnbm9yZSB0aGUgdGFnIGlmIHdlIGNvdWxkbid0LlxuICAgICAgbm9kZSA9IGNyZWF0ZUVsZW1lbnQobVsxXSwgbVszXSk7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIHRhZyBzaG91bGQgYmUgYWRkZWQgYmFzZWQgb24gdGhlIGNvbnRleHQgb2Ygd2hlcmUgaXRcbiAgICAgIC8vIGlzIHBsYWNlZCBpbiB0aGUgY3VldGV4dC5cbiAgICAgIGlmICghc2hvdWxkQWRkKGN1cnJlbnQsIG5vZGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gU2V0IHRoZSBjbGFzcyBsaXN0IChhcyBhIGxpc3Qgb2YgY2xhc3Nlcywgc2VwYXJhdGVkIGJ5IHNwYWNlKS5cbiAgICAgIGlmIChtWzJdKSB7XG4gICAgICAgIG5vZGUuY2xhc3NOYW1lID0gbVsyXS5zdWJzdHIoMSkucmVwbGFjZSgnLicsICcgJyk7XG4gICAgICB9XG4gICAgICAvLyBBcHBlbmQgdGhlIG5vZGUgdG8gdGhlIGN1cnJlbnQgbm9kZSwgYW5kIGVudGVyIHRoZSBzY29wZSBvZiB0aGUgbmV3XG4gICAgICAvLyBub2RlLlxuICAgICAgdGFnU3RhY2sucHVzaChtWzFdKTtcbiAgICAgIGN1cnJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBjdXJyZW50ID0gbm9kZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFRleHQgbm9kZXMgYXJlIGxlYWYgbm9kZXMuXG4gICAgY3VycmVudC5hcHBlbmRDaGlsZCh3aW5kb3cuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodW5lc2NhcGUodCkpKTtcbiAgfVxuXG4gIHJldHVybiByb290RGl2O1xufVxuXG4vLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgdGhlIFVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYSBzdHJvbmdcbi8vIHJpZ2h0LXRvLWxlZnQgY2F0ZWdvcnkuIFdoYXQgdGhpcyBtZWFucyBpcyB0aGF0IHRoZXNlIGNoYXJhY3RlcnMgYXJlXG4vLyB3cml0dGVuIHJpZ2h0LXRvLWxlZnQgZm9yIHN1cmUuIEl0IHdhcyBnZW5lcmF0ZWQgYnkgcHVsbGluZyBhbGwgdGhlIHN0cm9uZ1xuLy8gcmlnaHQtdG8tbGVmdCBjaGFyYWN0ZXJzIG91dCBvZiB0aGUgVW5pY29kZSBkYXRhIHRhYmxlLiBUaGF0IHRhYmxlIGNhblxuLy8gZm91bmQgYXQ6IGh0dHA6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VOSURBVEEvVW5pY29kZURhdGEudHh0XG52YXIgc3Ryb25nUlRMUmFuZ2VzID0gW1sweDViZSwgMHg1YmVdLCBbMHg1YzAsIDB4NWMwXSwgWzB4NWMzLCAweDVjM10sIFsweDVjNiwgMHg1YzZdLFxuIFsweDVkMCwgMHg1ZWFdLCBbMHg1ZjAsIDB4NWY0XSwgWzB4NjA4LCAweDYwOF0sIFsweDYwYiwgMHg2MGJdLCBbMHg2MGQsIDB4NjBkXSxcbiBbMHg2MWIsIDB4NjFiXSwgWzB4NjFlLCAweDY0YV0sIFsweDY2ZCwgMHg2NmZdLCBbMHg2NzEsIDB4NmQ1XSwgWzB4NmU1LCAweDZlNl0sXG4gWzB4NmVlLCAweDZlZl0sIFsweDZmYSwgMHg3MGRdLCBbMHg3MGYsIDB4NzEwXSwgWzB4NzEyLCAweDcyZl0sIFsweDc0ZCwgMHg3YTVdLFxuIFsweDdiMSwgMHg3YjFdLCBbMHg3YzAsIDB4N2VhXSwgWzB4N2Y0LCAweDdmNV0sIFsweDdmYSwgMHg3ZmFdLCBbMHg4MDAsIDB4ODE1XSxcbiBbMHg4MWEsIDB4ODFhXSwgWzB4ODI0LCAweDgyNF0sIFsweDgyOCwgMHg4MjhdLCBbMHg4MzAsIDB4ODNlXSwgWzB4ODQwLCAweDg1OF0sXG4gWzB4ODVlLCAweDg1ZV0sIFsweDhhMCwgMHg4YTBdLCBbMHg4YTIsIDB4OGFjXSwgWzB4MjAwZiwgMHgyMDBmXSxcbiBbMHhmYjFkLCAweGZiMWRdLCBbMHhmYjFmLCAweGZiMjhdLCBbMHhmYjJhLCAweGZiMzZdLCBbMHhmYjM4LCAweGZiM2NdLFxuIFsweGZiM2UsIDB4ZmIzZV0sIFsweGZiNDAsIDB4ZmI0MV0sIFsweGZiNDMsIDB4ZmI0NF0sIFsweGZiNDYsIDB4ZmJjMV0sXG4gWzB4ZmJkMywgMHhmZDNkXSwgWzB4ZmQ1MCwgMHhmZDhmXSwgWzB4ZmQ5MiwgMHhmZGM3XSwgWzB4ZmRmMCwgMHhmZGZjXSxcbiBbMHhmZTcwLCAweGZlNzRdLCBbMHhmZTc2LCAweGZlZmNdLCBbMHgxMDgwMCwgMHgxMDgwNV0sIFsweDEwODA4LCAweDEwODA4XSxcbiBbMHgxMDgwYSwgMHgxMDgzNV0sIFsweDEwODM3LCAweDEwODM4XSwgWzB4MTA4M2MsIDB4MTA4M2NdLCBbMHgxMDgzZiwgMHgxMDg1NV0sXG4gWzB4MTA4NTcsIDB4MTA4NWZdLCBbMHgxMDkwMCwgMHgxMDkxYl0sIFsweDEwOTIwLCAweDEwOTM5XSwgWzB4MTA5M2YsIDB4MTA5M2ZdLFxuIFsweDEwOTgwLCAweDEwOWI3XSwgWzB4MTA5YmUsIDB4MTA5YmZdLCBbMHgxMGEwMCwgMHgxMGEwMF0sIFsweDEwYTEwLCAweDEwYTEzXSxcbiBbMHgxMGExNSwgMHgxMGExN10sIFsweDEwYTE5LCAweDEwYTMzXSwgWzB4MTBhNDAsIDB4MTBhNDddLCBbMHgxMGE1MCwgMHgxMGE1OF0sXG4gWzB4MTBhNjAsIDB4MTBhN2ZdLCBbMHgxMGIwMCwgMHgxMGIzNV0sIFsweDEwYjQwLCAweDEwYjU1XSwgWzB4MTBiNTgsIDB4MTBiNzJdLFxuIFsweDEwYjc4LCAweDEwYjdmXSwgWzB4MTBjMDAsIDB4MTBjNDhdLCBbMHgxZWUwMCwgMHgxZWUwM10sIFsweDFlZTA1LCAweDFlZTFmXSxcbiBbMHgxZWUyMSwgMHgxZWUyMl0sIFsweDFlZTI0LCAweDFlZTI0XSwgWzB4MWVlMjcsIDB4MWVlMjddLCBbMHgxZWUyOSwgMHgxZWUzMl0sXG4gWzB4MWVlMzQsIDB4MWVlMzddLCBbMHgxZWUzOSwgMHgxZWUzOV0sIFsweDFlZTNiLCAweDFlZTNiXSwgWzB4MWVlNDIsIDB4MWVlNDJdLFxuIFsweDFlZTQ3LCAweDFlZTQ3XSwgWzB4MWVlNDksIDB4MWVlNDldLCBbMHgxZWU0YiwgMHgxZWU0Yl0sIFsweDFlZTRkLCAweDFlZTRmXSxcbiBbMHgxZWU1MSwgMHgxZWU1Ml0sIFsweDFlZTU0LCAweDFlZTU0XSwgWzB4MWVlNTcsIDB4MWVlNTddLCBbMHgxZWU1OSwgMHgxZWU1OV0sXG4gWzB4MWVlNWIsIDB4MWVlNWJdLCBbMHgxZWU1ZCwgMHgxZWU1ZF0sIFsweDFlZTVmLCAweDFlZTVmXSwgWzB4MWVlNjEsIDB4MWVlNjJdLFxuIFsweDFlZTY0LCAweDFlZTY0XSwgWzB4MWVlNjcsIDB4MWVlNmFdLCBbMHgxZWU2YywgMHgxZWU3Ml0sIFsweDFlZTc0LCAweDFlZTc3XSxcbiBbMHgxZWU3OSwgMHgxZWU3Y10sIFsweDFlZTdlLCAweDFlZTdlXSwgWzB4MWVlODAsIDB4MWVlODldLCBbMHgxZWU4YiwgMHgxZWU5Yl0sXG4gWzB4MWVlYTEsIDB4MWVlYTNdLCBbMHgxZWVhNSwgMHgxZWVhOV0sIFsweDFlZWFiLCAweDFlZWJiXSwgWzB4MTBmZmZkLCAweDEwZmZmZF1dO1xuXG5mdW5jdGlvbiBpc1N0cm9uZ1JUTENoYXIoY2hhckNvZGUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJvbmdSVExSYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3VycmVudFJhbmdlID0gc3Ryb25nUlRMUmFuZ2VzW2ldO1xuICAgIGlmIChjaGFyQ29kZSA+PSBjdXJyZW50UmFuZ2VbMF0gJiYgY2hhckNvZGUgPD0gY3VycmVudFJhbmdlWzFdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZUJpZGkoY3VlRGl2KSB7XG4gIHZhciBub2RlU3RhY2sgPSBbXSxcbiAgICAgIHRleHQgPSBcIlwiLFxuICAgICAgY2hhckNvZGU7XG5cbiAgaWYgKCFjdWVEaXYgfHwgIWN1ZURpdi5jaGlsZE5vZGVzKSB7XG4gICAgcmV0dXJuIFwibHRyXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoTm9kZXMobm9kZVN0YWNrLCBub2RlKSB7XG4gICAgZm9yICh2YXIgaSA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbm9kZVN0YWNrLnB1c2gobm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0VGV4dE5vZGUobm9kZVN0YWNrKSB7XG4gICAgaWYgKCFub2RlU3RhY2sgfHwgIW5vZGVTdGFjay5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbm9kZVN0YWNrLnBvcCgpLFxuICAgICAgICB0ZXh0ID0gbm9kZS50ZXh0Q29udGVudCB8fCBub2RlLmlubmVyVGV4dDtcbiAgICBpZiAodGV4dCkge1xuICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbWF0Y2ggYWxsIHVuaWNvZGUgdHlwZSBCIGNoYXJhY3RlcnMgKHBhcmFncmFwaFxuICAgICAgLy8gc2VwYXJhdG9yIGNoYXJhY3RlcnMpLiBTZWUgaXNzdWUgIzExNS5cbiAgICAgIHZhciBtID0gdGV4dC5tYXRjaCgvXi4qKFxcbnxcXHIpLyk7XG4gICAgICBpZiAobSkge1xuICAgICAgICBub2RlU3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgcmV0dXJuIG1bMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gXCJydWJ5XCIpIHtcbiAgICAgIHJldHVybiBuZXh0VGV4dE5vZGUobm9kZVN0YWNrKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGROb2Rlcykge1xuICAgICAgcHVzaE5vZGVzKG5vZGVTdGFjaywgbm9kZSk7XG4gICAgICByZXR1cm4gbmV4dFRleHROb2RlKG5vZGVTdGFjayk7XG4gICAgfVxuICB9XG5cbiAgcHVzaE5vZGVzKG5vZGVTdGFjaywgY3VlRGl2KTtcbiAgd2hpbGUgKCh0ZXh0ID0gbmV4dFRleHROb2RlKG5vZGVTdGFjaykpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChpc1N0cm9uZ1JUTENoYXIoY2hhckNvZGUpKSB7XG4gICAgICAgIHJldHVybiBcInJ0bFwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gXCJsdHJcIjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUxpbmVQb3MoY3VlKSB7XG4gIGlmICh0eXBlb2YgY3VlLmxpbmUgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgIChjdWUuc25hcFRvTGluZXMgfHwgKGN1ZS5saW5lID49IDAgJiYgY3VlLmxpbmUgPD0gMTAwKSkpIHtcbiAgICByZXR1cm4gY3VlLmxpbmU7XG4gIH1cbiAgaWYgKCFjdWUudHJhY2sgfHwgIWN1ZS50cmFjay50ZXh0VHJhY2tMaXN0IHx8XG4gICAgICAhY3VlLnRyYWNrLnRleHRUcmFja0xpc3QubWVkaWFFbGVtZW50KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciB0cmFjayA9IGN1ZS50cmFjayxcbiAgICAgIHRyYWNrTGlzdCA9IHRyYWNrLnRleHRUcmFja0xpc3QsXG4gICAgICBjb3VudCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMaXN0Lmxlbmd0aCAmJiB0cmFja0xpc3RbaV0gIT09IHRyYWNrOyBpKyspIHtcbiAgICBpZiAodHJhY2tMaXN0W2ldLm1vZGUgPT09IFwic2hvd2luZ1wiKSB7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKytjb3VudCAqIC0xO1xufVxuXG5mdW5jdGlvbiBTdHlsZUJveCgpIHtcbn1cblxuLy8gQXBwbHkgc3R5bGVzIHRvIGEgZGl2LiBJZiB0aGVyZSBpcyBubyBkaXYgcGFzc2VkIHRoZW4gaXQgZGVmYXVsdHMgdG8gdGhlXG4vLyBkaXYgb24gJ3RoaXMnLlxuU3R5bGVCb3gucHJvdG90eXBlLmFwcGx5U3R5bGVzID0gZnVuY3Rpb24oc3R5bGVzLCBkaXYpIHtcbiAgZGl2ID0gZGl2IHx8IHRoaXMuZGl2O1xuICBmb3IgKHZhciBwcm9wIGluIHN0eWxlcykge1xuICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGRpdi5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXTtcbiAgICB9XG4gIH1cbn07XG5cblN0eWxlQm94LnByb3RvdHlwZS5mb3JtYXRTdHlsZSA9IGZ1bmN0aW9uKHZhbCwgdW5pdCkge1xuICByZXR1cm4gdmFsID09PSAwID8gMCA6IHZhbCArIHVuaXQ7XG59O1xuXG4vLyBDb25zdHJ1Y3RzIHRoZSBjb21wdXRlZCBkaXNwbGF5IHN0YXRlIG9mIHRoZSBjdWUgKGEgZGl2KS4gUGxhY2VzIHRoZSBkaXZcbi8vIGludG8gdGhlIG92ZXJsYXkgd2hpY2ggc2hvdWxkIGJlIGEgYmxvY2sgbGV2ZWwgZWxlbWVudCAodXN1YWxseSBhIGRpdikuXG5mdW5jdGlvbiBDdWVTdHlsZUJveCh3aW5kb3csIGN1ZSwgc3R5bGVPcHRpb25zKSB7XG4gIHZhciBpc0lFOCA9ICgvTVNJRVxcczhcXC4wLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIGNvbG9yID0gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpXCI7XG4gIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBcInJnYmEoMCwgMCwgMCwgMC44KVwiO1xuXG4gIGlmIChpc0lFOCkge1xuICAgIGNvbG9yID0gXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIjtcbiAgICBiYWNrZ3JvdW5kQ29sb3IgPSBcInJnYigwLCAwLCAwKVwiO1xuICB9XG5cbiAgU3R5bGVCb3guY2FsbCh0aGlzKTtcbiAgdGhpcy5jdWUgPSBjdWU7XG5cbiAgLy8gUGFyc2Ugb3VyIGN1ZSdzIHRleHQgaW50byBhIERPTSB0cmVlIHJvb3RlZCBhdCAnY3VlRGl2Jy4gVGhpcyBkaXYgd2lsbFxuICAvLyBoYXZlIGlubGluZSBwb3NpdGlvbmluZyBhbmQgd2lsbCBmdW5jdGlvbiBhcyB0aGUgY3VlIGJhY2tncm91bmQgYm94LlxuICB0aGlzLmN1ZURpdiA9IHBhcnNlQ29udGVudCh3aW5kb3csIGN1ZS50ZXh0KTtcbiAgdmFyIHN0eWxlcyA9IHtcbiAgICBjb2xvcjogY29sb3IsXG4gICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDAsXG4gICAgZGlzcGxheTogXCJpbmxpbmVcIlxuICB9O1xuXG4gIGlmICghaXNJRTgpIHtcbiAgICBzdHlsZXMud3JpdGluZ01vZGUgPSBjdWUudmVydGljYWwgPT09IFwiXCIgPyBcImhvcml6b250YWwtdGJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdWUudmVydGljYWwgPT09IFwibHJcIiA/IFwidmVydGljYWwtbHJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcInZlcnRpY2FsLXJsXCI7XG4gICAgc3R5bGVzLnVuaWNvZGVCaWRpID0gXCJwbGFpbnRleHRcIjtcbiAgfVxuICB0aGlzLmFwcGx5U3R5bGVzKHN0eWxlcywgdGhpcy5jdWVEaXYpO1xuXG4gIC8vIENyZWF0ZSBhbiBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgZGl2IHRoYXQgd2lsbCBiZSB1c2VkIHRvIHBvc2l0aW9uIHRoZSBjdWVcbiAgLy8gZGl2LiBOb3RlLCBhbGwgV2ViVlRUIGN1ZS1zZXR0aW5nIGFsaWdubWVudHMgYXJlIGVxdWl2YWxlbnQgdG8gdGhlIENTU1xuICAvLyBtaXJyb3JzIG9mIHRoZW0gZXhjZXB0IFwibWlkZGxlXCIgd2hpY2ggaXMgXCJjZW50ZXJcIiBpbiBDU1MuXG4gIHRoaXMuZGl2ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHN0eWxlcyA9IHtcbiAgICB0ZXh0QWxpZ246IGN1ZS5hbGlnbiA9PT0gXCJtaWRkbGVcIiA/IFwiY2VudGVyXCIgOiBjdWUuYWxpZ24sXG4gICAgZm9udDogc3R5bGVPcHRpb25zLmZvbnQsXG4gICAgd2hpdGVTcGFjZTogXCJwcmUtbGluZVwiLFxuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgfTtcblxuICBpZiAoIWlzSUU4KSB7XG4gICAgc3R5bGVzLmRpcmVjdGlvbiA9IGRldGVybWluZUJpZGkodGhpcy5jdWVEaXYpO1xuICAgIHN0eWxlcy53cml0aW5nTW9kZSA9IGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIiA/IFwiaG9yaXpvbnRhbC10YlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1ZS52ZXJ0aWNhbCA9PT0gXCJsclwiID8gXCJ2ZXJ0aWNhbC1sclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwidmVydGljYWwtcmxcIi5cbiAgICBzdHlsZXN1bmljb2RlQmlkaSA9ICBcInBsYWludGV4dFwiO1xuICB9XG5cbiAgdGhpcy5hcHBseVN0eWxlcyhzdHlsZXMpO1xuXG4gIHRoaXMuZGl2LmFwcGVuZENoaWxkKHRoaXMuY3VlRGl2KTtcblxuICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHJlZmVyZW5jZSBlZGdlIG9mIHRoZSB2aWV3cG9ydCB0byB0aGUgdGV4dFxuICAvLyBwb3NpdGlvbiBvZiB0aGUgY3VlIGJveC4gVGhlIHJlZmVyZW5jZSBlZGdlIHdpbGwgYmUgcmVzb2x2ZWQgbGF0ZXIgd2hlblxuICAvLyB0aGUgYm94IG9yaWVudGF0aW9uIHN0eWxlcyBhcmUgYXBwbGllZC5cbiAgdmFyIHRleHRQb3MgPSAwO1xuICBzd2l0Y2ggKGN1ZS5wb3NpdGlvbkFsaWduKSB7XG4gIGNhc2UgXCJzdGFydFwiOlxuICAgIHRleHRQb3MgPSBjdWUucG9zaXRpb247XG4gICAgYnJlYWs7XG4gIGNhc2UgXCJtaWRkbGVcIjpcbiAgICB0ZXh0UG9zID0gY3VlLnBvc2l0aW9uIC0gKGN1ZS5zaXplIC8gMik7XG4gICAgYnJlYWs7XG4gIGNhc2UgXCJlbmRcIjpcbiAgICB0ZXh0UG9zID0gY3VlLnBvc2l0aW9uIC0gY3VlLnNpemU7XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBIb3Jpem9udGFsIGJveCBvcmllbnRhdGlvbjsgdGV4dFBvcyBpcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZVxuICAvLyBhcmVhIHRvIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGJveCBhbmQgY3VlLnNpemUgaXMgdGhlIGRpc3RhbmNlIGV4dGVuZGluZyB0b1xuICAvLyB0aGUgcmlnaHQgZnJvbSB0aGVyZS5cbiAgaWYgKGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIikge1xuICAgIHRoaXMuYXBwbHlTdHlsZXMoe1xuICAgICAgbGVmdDogIHRoaXMuZm9ybWF0U3R5bGUodGV4dFBvcywgXCIlXCIpLFxuICAgICAgd2lkdGg6IHRoaXMuZm9ybWF0U3R5bGUoY3VlLnNpemUsIFwiJVwiKVxuICAgIH0pO1xuICAvLyBWZXJ0aWNhbCBib3ggb3JpZW50YXRpb247IHRleHRQb3MgaXMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHRvcCBlZGdlIG9mIHRoZVxuICAvLyBhcmVhIHRvIHRoZSB0b3AgZWRnZSBvZiB0aGUgYm94IGFuZCBjdWUuc2l6ZSBpcyB0aGUgaGVpZ2h0IGV4dGVuZGluZ1xuICAvLyBkb3dud2FyZHMgZnJvbSB0aGVyZS5cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFwcGx5U3R5bGVzKHtcbiAgICAgIHRvcDogdGhpcy5mb3JtYXRTdHlsZSh0ZXh0UG9zLCBcIiVcIiksXG4gICAgICBoZWlnaHQ6IHRoaXMuZm9ybWF0U3R5bGUoY3VlLnNpemUsIFwiJVwiKVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5tb3ZlID0gZnVuY3Rpb24oYm94KSB7XG4gICAgdGhpcy5hcHBseVN0eWxlcyh7XG4gICAgICB0b3A6IHRoaXMuZm9ybWF0U3R5bGUoYm94LnRvcCwgXCJweFwiKSxcbiAgICAgIGJvdHRvbTogdGhpcy5mb3JtYXRTdHlsZShib3guYm90dG9tLCBcInB4XCIpLFxuICAgICAgbGVmdDogdGhpcy5mb3JtYXRTdHlsZShib3gubGVmdCwgXCJweFwiKSxcbiAgICAgIHJpZ2h0OiB0aGlzLmZvcm1hdFN0eWxlKGJveC5yaWdodCwgXCJweFwiKSxcbiAgICAgIGhlaWdodDogdGhpcy5mb3JtYXRTdHlsZShib3guaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgd2lkdGg6IHRoaXMuZm9ybWF0U3R5bGUoYm94LndpZHRoLCBcInB4XCIpXG4gICAgfSk7XG4gIH07XG59XG5DdWVTdHlsZUJveC5wcm90b3R5cGUgPSBfb2JqQ3JlYXRlKFN0eWxlQm94LnByb3RvdHlwZSk7XG5DdWVTdHlsZUJveC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdWVTdHlsZUJveDtcblxuLy8gUmVwcmVzZW50cyB0aGUgY28tb3JkaW5hdGVzIG9mIGFuIEVsZW1lbnQgaW4gYSB3YXkgdGhhdCB3ZSBjYW4gZWFzaWx5XG4vLyBjb21wdXRlIHRoaW5ncyB3aXRoIHN1Y2ggYXMgaWYgaXQgb3ZlcmxhcHMgb3IgaW50ZXJzZWN0cyB3aXRoIGFub3RoZXIgRWxlbWVudC5cbi8vIENhbiBpbml0aWFsaXplIGl0IHdpdGggZWl0aGVyIGEgU3R5bGVCb3ggb3IgYW5vdGhlciBCb3hQb3NpdGlvbi5cbmZ1bmN0aW9uIEJveFBvc2l0aW9uKG9iaikge1xuICB2YXIgaXNJRTggPSAoL01TSUVcXHM4XFwuMC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgLy8gRWl0aGVyIGEgQm94UG9zaXRpb24gd2FzIHBhc3NlZCBpbiBhbmQgd2UgbmVlZCB0byBjb3B5IGl0LCBvciBhIFN0eWxlQm94XG4gIC8vIHdhcyBwYXNzZWQgaW4gYW5kIHdlIG5lZWQgdG8gY29weSB0aGUgcmVzdWx0cyBvZiAnZ2V0Qm91bmRpbmdDbGllbnRSZWN0J1xuICAvLyBhcyB0aGUgb2JqZWN0IHJldHVybmVkIGlzIHJlYWRvbmx5LiBBbGwgY28tb3JkaW5hdGUgdmFsdWVzIGFyZSBpbiByZWZlcmVuY2VcbiAgLy8gdG8gdGhlIHZpZXdwb3J0IG9yaWdpbiAodG9wIGxlZnQpLlxuICB2YXIgbGgsIGhlaWdodCwgd2lkdGgsIHRvcDtcbiAgaWYgKG9iai5kaXYpIHtcbiAgICBoZWlnaHQgPSBvYmouZGl2Lm9mZnNldEhlaWdodDtcbiAgICB3aWR0aCA9IG9iai5kaXYub2Zmc2V0V2lkdGg7XG4gICAgdG9wID0gb2JqLmRpdi5vZmZzZXRUb3A7XG5cbiAgICB2YXIgcmVjdHMgPSAocmVjdHMgPSBvYmouZGl2LmNoaWxkTm9kZXMpICYmIChyZWN0cyA9IHJlY3RzWzBdKSAmJlxuICAgICAgICAgICAgICAgIHJlY3RzLmdldENsaWVudFJlY3RzICYmIHJlY3RzLmdldENsaWVudFJlY3RzKCk7XG4gICAgb2JqID0gb2JqLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvLyBJbiBjZXJ0YWluIGNhc2VzIHRoZSBvdXR0ZXIgZGl2IHdpbGwgYmUgc2xpZ2h0bHkgbGFyZ2VyIHRoZW4gdGhlIHN1bSBvZlxuICAgIC8vIHRoZSBpbm5lciBkaXYncyBsaW5lcy4gVGhpcyBjb3VsZCBiZSBkdWUgdG8gYm9sZCB0ZXh0LCBldGMsIG9uIHNvbWUgcGxhdGZvcm1zLlxuICAgIC8vIEluIHRoaXMgY2FzZSB3ZSBzaG91bGQgZ2V0IHRoZSBhdmVyYWdlIGxpbmUgaGVpZ2h0IGFuZCB1c2UgdGhhdC4gVGhpcyB3aWxsXG4gICAgLy8gcmVzdWx0IGluIHRoZSBkZXNpcmVkIGJlaGF2aW91ci5cbiAgICBsaCA9IHJlY3RzID8gTWF0aC5tYXgoKHJlY3RzWzBdICYmIHJlY3RzWzBdLmhlaWdodCkgfHwgMCwgb2JqLmhlaWdodCAvIHJlY3RzLmxlbmd0aClcbiAgICAgICAgICAgICAgIDogMDtcblxuICB9XG4gIHRoaXMubGVmdCA9IG9iai5sZWZ0O1xuICB0aGlzLnJpZ2h0ID0gb2JqLnJpZ2h0O1xuICB0aGlzLnRvcCA9IG9iai50b3AgfHwgdG9wO1xuICB0aGlzLmhlaWdodCA9IG9iai5oZWlnaHQgfHwgaGVpZ2h0O1xuICB0aGlzLmJvdHRvbSA9IG9iai5ib3R0b20gfHwgKHRvcCArIChvYmouaGVpZ2h0IHx8IGhlaWdodCkpO1xuICB0aGlzLndpZHRoID0gb2JqLndpZHRoIHx8IHdpZHRoO1xuICB0aGlzLmxpbmVIZWlnaHQgPSBsaCAhPT0gdW5kZWZpbmVkID8gbGggOiBvYmoubGluZUhlaWdodDtcblxuICBpZiAoaXNJRTggJiYgIXRoaXMubGluZUhlaWdodCkge1xuICAgIHRoaXMubGluZUhlaWdodCA9IDEzO1xuICB9XG59XG5cbi8vIE1vdmUgdGhlIGJveCBhbG9uZyBhIHBhcnRpY3VsYXIgYXhpcy4gT3B0aW9uYWxseSBwYXNzIGluIGFuIGFtb3VudCB0byBtb3ZlXG4vLyB0aGUgYm94LiBJZiBubyBhbW91bnQgaXMgcGFzc2VkIHRoZW4gdGhlIGRlZmF1bHQgaXMgdGhlIGxpbmUgaGVpZ2h0IG9mIHRoZVxuLy8gYm94LlxuQm94UG9zaXRpb24ucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihheGlzLCB0b01vdmUpIHtcbiAgdG9Nb3ZlID0gdG9Nb3ZlICE9PSB1bmRlZmluZWQgPyB0b01vdmUgOiB0aGlzLmxpbmVIZWlnaHQ7XG4gIHN3aXRjaCAoYXhpcykge1xuICBjYXNlIFwiK3hcIjpcbiAgICB0aGlzLmxlZnQgKz0gdG9Nb3ZlO1xuICAgIHRoaXMucmlnaHQgKz0gdG9Nb3ZlO1xuICAgIGJyZWFrO1xuICBjYXNlIFwiLXhcIjpcbiAgICB0aGlzLmxlZnQgLT0gdG9Nb3ZlO1xuICAgIHRoaXMucmlnaHQgLT0gdG9Nb3ZlO1xuICAgIGJyZWFrO1xuICBjYXNlIFwiK3lcIjpcbiAgICB0aGlzLnRvcCArPSB0b01vdmU7XG4gICAgdGhpcy5ib3R0b20gKz0gdG9Nb3ZlO1xuICAgIGJyZWFrO1xuICBjYXNlIFwiLXlcIjpcbiAgICB0aGlzLnRvcCAtPSB0b01vdmU7XG4gICAgdGhpcy5ib3R0b20gLT0gdG9Nb3ZlO1xuICAgIGJyZWFrO1xuICB9XG59O1xuXG4vLyBDaGVjayBpZiB0aGlzIGJveCBvdmVybGFwcyBhbm90aGVyIGJveCwgYjIuXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUub3ZlcmxhcHMgPSBmdW5jdGlvbihiMikge1xuICByZXR1cm4gdGhpcy5sZWZ0IDwgYjIucmlnaHQgJiZcbiAgICAgICAgIHRoaXMucmlnaHQgPiBiMi5sZWZ0ICYmXG4gICAgICAgICB0aGlzLnRvcCA8IGIyLmJvdHRvbSAmJlxuICAgICAgICAgdGhpcy5ib3R0b20gPiBiMi50b3A7XG59O1xuXG4vLyBDaGVjayBpZiB0aGlzIGJveCBvdmVybGFwcyBhbnkgb3RoZXIgYm94ZXMgaW4gYm94ZXMuXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUub3ZlcmxhcHNBbnkgPSBmdW5jdGlvbihib3hlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMub3ZlcmxhcHMoYm94ZXNbaV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gQ2hlY2sgaWYgdGhpcyBib3ggaXMgd2l0aGluIGFub3RoZXIgYm94LlxuQm94UG9zaXRpb24ucHJvdG90eXBlLndpdGhpbiA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICByZXR1cm4gdGhpcy50b3AgPj0gY29udGFpbmVyLnRvcCAmJlxuICAgICAgICAgdGhpcy5ib3R0b20gPD0gY29udGFpbmVyLmJvdHRvbSAmJlxuICAgICAgICAgdGhpcy5sZWZ0ID49IGNvbnRhaW5lci5sZWZ0ICYmXG4gICAgICAgICB0aGlzLnJpZ2h0IDw9IGNvbnRhaW5lci5yaWdodDtcbn07XG5cbi8vIENoZWNrIGlmIHRoaXMgYm94IGlzIGVudGlyZWx5IHdpdGhpbiB0aGUgY29udGFpbmVyIG9yIGl0IGlzIG92ZXJsYXBwaW5nXG4vLyBvbiB0aGUgZWRnZSBvcHBvc2l0ZSBvZiB0aGUgYXhpcyBkaXJlY3Rpb24gcGFzc2VkLiBGb3IgZXhhbXBsZSwgaWYgXCIreFwiIGlzXG4vLyBwYXNzZWQgYW5kIHRoZSBib3ggaXMgb3ZlcmxhcHBpbmcgb24gdGhlIGxlZnQgZWRnZSBvZiB0aGUgY29udGFpbmVyLCB0aGVuXG4vLyByZXR1cm4gdHJ1ZS5cbkJveFBvc2l0aW9uLnByb3RvdHlwZS5vdmVybGFwc09wcG9zaXRlQXhpcyA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgYXhpcykge1xuICBzd2l0Y2ggKGF4aXMpIHtcbiAgY2FzZSBcIit4XCI6XG4gICAgcmV0dXJuIHRoaXMubGVmdCA8IGNvbnRhaW5lci5sZWZ0O1xuICBjYXNlIFwiLXhcIjpcbiAgICByZXR1cm4gdGhpcy5yaWdodCA+IGNvbnRhaW5lci5yaWdodDtcbiAgY2FzZSBcIit5XCI6XG4gICAgcmV0dXJuIHRoaXMudG9wIDwgY29udGFpbmVyLnRvcDtcbiAgY2FzZSBcIi15XCI6XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tID4gY29udGFpbmVyLmJvdHRvbTtcbiAgfVxufTtcblxuLy8gRmluZCB0aGUgcGVyY2VudGFnZSBvZiB0aGUgYXJlYSB0aGF0IHRoaXMgYm94IGlzIG92ZXJsYXBwaW5nIHdpdGggYW5vdGhlclxuLy8gYm94LlxuQm94UG9zaXRpb24ucHJvdG90eXBlLmludGVyc2VjdFBlcmNlbnRhZ2UgPSBmdW5jdGlvbihiMikge1xuICB2YXIgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMucmlnaHQsIGIyLnJpZ2h0KSAtIE1hdGgubWF4KHRoaXMubGVmdCwgYjIubGVmdCkpLFxuICAgICAgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuYm90dG9tLCBiMi5ib3R0b20pIC0gTWF0aC5tYXgodGhpcy50b3AsIGIyLnRvcCkpLFxuICAgICAgaW50ZXJzZWN0QXJlYSA9IHggKiB5O1xuICByZXR1cm4gaW50ZXJzZWN0QXJlYSAvICh0aGlzLmhlaWdodCAqIHRoaXMud2lkdGgpO1xufTtcblxuLy8gQ29udmVydCB0aGUgcG9zaXRpb25zIGZyb20gdGhpcyBib3ggdG8gQ1NTIGNvbXBhdGlibGUgcG9zaXRpb25zIHVzaW5nXG4vLyB0aGUgcmVmZXJlbmNlIGNvbnRhaW5lcidzIHBvc2l0aW9ucy4gVGhpcyBoYXMgdG8gYmUgZG9uZSBiZWNhdXNlIHRoaXNcbi8vIGJveCdzIHBvc2l0aW9ucyBhcmUgaW4gcmVmZXJlbmNlIHRvIHRoZSB2aWV3cG9ydCBvcmlnaW4sIHdoZXJlYXMsIENTU1xuLy8gdmFsdWVzIGFyZSBpbiByZWZlcmVjbmUgdG8gdGhlaXIgcmVzcGVjdGl2ZSBlZGdlcy5cbkJveFBvc2l0aW9uLnByb3RvdHlwZS50b0NTU0NvbXBhdFZhbHVlcyA9IGZ1bmN0aW9uKHJlZmVyZW5jZSkge1xuICByZXR1cm4ge1xuICAgIHRvcDogdGhpcy50b3AgLSByZWZlcmVuY2UudG9wLFxuICAgIGJvdHRvbTogcmVmZXJlbmNlLmJvdHRvbSAtIHRoaXMuYm90dG9tLFxuICAgIGxlZnQ6IHRoaXMubGVmdCAtIHJlZmVyZW5jZS5sZWZ0LFxuICAgIHJpZ2h0OiByZWZlcmVuY2UucmlnaHQgLSB0aGlzLnJpZ2h0LFxuICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgd2lkdGg6IHRoaXMud2lkdGhcbiAgfTtcbn07XG5cbi8vIEdldCBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBib3gncyBwb3NpdGlvbiB3aXRob3V0IGFueXRoaW5nIGV4dHJhLlxuLy8gQ2FuIHBhc3MgYSBTdHlsZUJveCwgSFRNTEVsZW1lbnQsIG9yIGFub3RoZXIgQm94UG9zaXRvbi5cbkJveFBvc2l0aW9uLmdldFNpbXBsZUJveFBvc2l0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBoZWlnaHQgPSBvYmouZGl2ID8gb2JqLmRpdi5vZmZzZXRIZWlnaHQgOiBvYmoudGFnTmFtZSA/IG9iai5vZmZzZXRIZWlnaHQgOiAwO1xuICB2YXIgd2lkdGggPSBvYmouZGl2ID8gb2JqLmRpdi5vZmZzZXRXaWR0aCA6IG9iai50YWdOYW1lID8gb2JqLm9mZnNldFdpZHRoIDogMDtcbiAgdmFyIHRvcCA9IG9iai5kaXYgPyBvYmouZGl2Lm9mZnNldFRvcCA6IG9iai50YWdOYW1lID8gb2JqLm9mZnNldFRvcCA6IDA7XG5cbiAgb2JqID0gb2JqLmRpdiA/IG9iai5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOlxuICAgICAgICAgICAgICAgIG9iai50YWdOYW1lID8gb2JqLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogb2JqO1xuICB2YXIgcmV0ID0ge1xuICAgIGxlZnQ6IG9iai5sZWZ0LFxuICAgIHJpZ2h0OiBvYmoucmlnaHQsXG4gICAgdG9wOiBvYmoudG9wIHx8IHRvcCxcbiAgICBoZWlnaHQ6IG9iai5oZWlnaHQgfHwgaGVpZ2h0LFxuICAgIGJvdHRvbTogb2JqLmJvdHRvbSB8fCAodG9wICsgKG9iai5oZWlnaHQgfHwgaGVpZ2h0KSksXG4gICAgd2lkdGg6IG9iai53aWR0aCB8fCB3aWR0aFxuICB9O1xuICByZXR1cm4gcmV0O1xufTtcblxuLy8gTW92ZSBhIFN0eWxlQm94IHRvIGl0cyBzcGVjaWZpZWQsIG9yIG5leHQgYmVzdCwgcG9zaXRpb24uIFRoZSBjb250YWluZXJCb3hcbi8vIGlzIHRoZSBib3ggdGhhdCBjb250YWlucyB0aGUgU3R5bGVCb3gsIHN1Y2ggYXMgYSBkaXYuIGJveFBvc2l0aW9ucyBhcmVcbi8vIGEgbGlzdCBvZiBvdGhlciBib3hlcyB0aGF0IHRoZSBzdHlsZUJveCBjYW4ndCBvdmVybGFwIHdpdGguXG5mdW5jdGlvbiBtb3ZlQm94VG9MaW5lUG9zaXRpb24od2luZG93LCBzdHlsZUJveCwgY29udGFpbmVyQm94LCBib3hQb3NpdGlvbnMpIHtcblxuICAvLyBGaW5kIHRoZSBiZXN0IHBvc2l0aW9uIGZvciBhIGN1ZSBib3gsIGIsIG9uIHRoZSB2aWRlby4gVGhlIGF4aXMgcGFyYW1ldGVyXG4gIC8vIGlzIGEgbGlzdCBvZiBheGlzLCB0aGUgb3JkZXIgb2Ygd2hpY2gsIGl0IHdpbGwgbW92ZSB0aGUgYm94IGFsb25nLiBGb3IgZXhhbXBsZTpcbiAgLy8gUGFzc2luZyBbXCIreFwiLCBcIi14XCJdIHdpbGwgbW92ZSB0aGUgYm94IGZpcnN0IGFsb25nIHRoZSB4IGF4aXMgaW4gdGhlIHBvc2l0aXZlXG4gIC8vIGRpcmVjdGlvbi4gSWYgaXQgZG9lc24ndCBmaW5kIGEgZ29vZCBwb3NpdGlvbiBmb3IgaXQgdGhlcmUgaXQgd2lsbCB0aGVuIG1vdmVcbiAgLy8gaXQgYWxvbmcgdGhlIHggYXhpcyBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uLlxuICBmdW5jdGlvbiBmaW5kQmVzdFBvc2l0aW9uKGIsIGF4aXMpIHtcbiAgICB2YXIgYmVzdFBvc2l0aW9uLFxuICAgICAgICBzcGVjaWZpZWRQb3NpdGlvbiA9IG5ldyBCb3hQb3NpdGlvbihiKSxcbiAgICAgICAgcGVyY2VudGFnZSA9IDE7IC8vIEhpZ2hlc3QgcG9zc2libGUgc28gdGhlIGZpcnN0IHRoaW5nIHdlIGdldCBpcyBiZXR0ZXIuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4aXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdoaWxlIChiLm92ZXJsYXBzT3Bwb3NpdGVBeGlzKGNvbnRhaW5lckJveCwgYXhpc1tpXSkgfHxcbiAgICAgICAgICAgICAoYi53aXRoaW4oY29udGFpbmVyQm94KSAmJiBiLm92ZXJsYXBzQW55KGJveFBvc2l0aW9ucykpKSB7XG4gICAgICAgIGIubW92ZShheGlzW2ldKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGZvdW5kIGEgc3BvdCB3aGVyZSB3ZSBhcmVuJ3Qgb3ZlcmxhcHBpbmcgYW55dGhpbmcuIFRoaXMgaXMgb3VyXG4gICAgICAvLyBiZXN0IHBvc2l0aW9uLlxuICAgICAgaWYgKGIud2l0aGluKGNvbnRhaW5lckJveCkpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgICB2YXIgcCA9IGIuaW50ZXJzZWN0UGVyY2VudGFnZShjb250YWluZXJCb3gpO1xuICAgICAgLy8gSWYgd2UncmUgb3V0c2lkZSB0aGUgY29udGFpbmVyIGJveCBsZXNzIHRoZW4gd2Ugd2VyZSBvbiBvdXIgbGFzdCB0cnlcbiAgICAgIC8vIHRoZW4gcmVtZW1iZXIgdGhpcyBwb3NpdGlvbiBhcyB0aGUgYmVzdCBwb3NpdGlvbi5cbiAgICAgIGlmIChwZXJjZW50YWdlID4gcCkge1xuICAgICAgICBiZXN0UG9zaXRpb24gPSBuZXcgQm94UG9zaXRpb24oYik7XG4gICAgICAgIHBlcmNlbnRhZ2UgPSBwO1xuICAgICAgfVxuICAgICAgLy8gUmVzZXQgdGhlIGJveCBwb3NpdGlvbiB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgICAgYiA9IG5ldyBCb3hQb3NpdGlvbihzcGVjaWZpZWRQb3NpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBiZXN0UG9zaXRpb24gfHwgc3BlY2lmaWVkUG9zaXRpb247XG4gIH1cblxuICB2YXIgYm94UG9zaXRpb24gPSBuZXcgQm94UG9zaXRpb24oc3R5bGVCb3gpLFxuICAgICAgY3VlID0gc3R5bGVCb3guY3VlLFxuICAgICAgbGluZVBvcyA9IGNvbXB1dGVMaW5lUG9zKGN1ZSksXG4gICAgICBheGlzID0gW107XG5cbiAgLy8gSWYgd2UgaGF2ZSBhIGxpbmUgbnVtYmVyIHRvIGFsaWduIHRoZSBjdWUgdG8uXG4gIGlmIChjdWUuc25hcFRvTGluZXMpIHtcbiAgICB2YXIgc2l6ZTtcbiAgICBzd2l0Y2ggKGN1ZS52ZXJ0aWNhbCkge1xuICAgIGNhc2UgXCJcIjpcbiAgICAgIGF4aXMgPSBbIFwiK3lcIiwgXCIteVwiIF07XG4gICAgICBzaXplID0gXCJoZWlnaHRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJybFwiOlxuICAgICAgYXhpcyA9IFsgXCIreFwiLCBcIi14XCIgXTtcbiAgICAgIHNpemUgPSBcIndpZHRoXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibHJcIjpcbiAgICAgIGF4aXMgPSBbIFwiLXhcIiwgXCIreFwiIF07XG4gICAgICBzaXplID0gXCJ3aWR0aFwiO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHN0ZXAgPSBib3hQb3NpdGlvbi5saW5lSGVpZ2h0LFxuICAgICAgICBwb3NpdGlvbiA9IHN0ZXAgKiBNYXRoLnJvdW5kKGxpbmVQb3MpLFxuICAgICAgICBtYXhQb3NpdGlvbiA9IGNvbnRhaW5lckJveFtzaXplXSArIHN0ZXAsXG4gICAgICAgIGluaXRpYWxBeGlzID0gYXhpc1swXTtcblxuICAgIC8vIElmIHRoZSBzcGVjaWZpZWQgaW50aWFsIHBvc2l0aW9uIGlzIGdyZWF0ZXIgdGhlbiB0aGUgbWF4IHBvc2l0aW9uIHRoZW5cbiAgICAvLyBjbGFtcCB0aGUgYm94IHRvIHRoZSBhbW91bnQgb2Ygc3RlcHMgaXQgd291bGQgdGFrZSBmb3IgdGhlIGJveCB0b1xuICAgIC8vIHJlYWNoIHRoZSBtYXggcG9zaXRpb24uXG4gICAgaWYgKE1hdGguYWJzKHBvc2l0aW9uKSA+IG1heFBvc2l0aW9uKSB7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIDwgMCA/IC0xIDogMTtcbiAgICAgIHBvc2l0aW9uICo9IE1hdGguY2VpbChtYXhQb3NpdGlvbiAvIHN0ZXApICogc3RlcDtcbiAgICB9XG5cbiAgICAvLyBJZiBjb21wdXRlZCBsaW5lIHBvc2l0aW9uIHJldHVybnMgbmVnYXRpdmUgdGhlbiBsaW5lIG51bWJlcnMgYXJlXG4gICAgLy8gcmVsYXRpdmUgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdmlkZW8gaW5zdGVhZCBvZiB0aGUgdG9wLiBUaGVyZWZvcmUsIHdlXG4gICAgLy8gbmVlZCB0byBpbmNyZWFzZSBvdXIgaW5pdGlhbCBwb3NpdGlvbiBieSB0aGUgbGVuZ3RoIG9yIHdpZHRoIG9mIHRoZVxuICAgIC8vIHZpZGVvLCBkZXBlbmRpbmcgb24gdGhlIHdyaXRpbmcgZGlyZWN0aW9uLCBhbmQgcmV2ZXJzZSBvdXIgYXhpcyBkaXJlY3Rpb25zLlxuICAgIGlmIChsaW5lUG9zIDwgMCkge1xuICAgICAgcG9zaXRpb24gKz0gY3VlLnZlcnRpY2FsID09PSBcIlwiID8gY29udGFpbmVyQm94LmhlaWdodCA6IGNvbnRhaW5lckJveC53aWR0aDtcbiAgICAgIGF4aXMgPSBheGlzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICAvLyBNb3ZlIHRoZSBib3ggdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi4gVGhpcyBtYXkgbm90IGJlIGl0cyBiZXN0XG4gICAgLy8gcG9zaXRpb24uXG4gICAgYm94UG9zaXRpb24ubW92ZShpbml0aWFsQXhpcywgcG9zaXRpb24pO1xuXG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhIHBlcmNlbnRhZ2UgbGluZSB2YWx1ZSBmb3IgdGhlIGN1ZS5cbiAgICB2YXIgY2FsY3VsYXRlZFBlcmNlbnRhZ2UgPSAoYm94UG9zaXRpb24ubGluZUhlaWdodCAvIGNvbnRhaW5lckJveC5oZWlnaHQpICogMTAwO1xuXG4gICAgc3dpdGNoIChjdWUubGluZUFsaWduKSB7XG4gICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgICAgbGluZVBvcyAtPSAoY2FsY3VsYXRlZFBlcmNlbnRhZ2UgLyAyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgIGxpbmVQb3MgLT0gY2FsY3VsYXRlZFBlcmNlbnRhZ2U7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBBcHBseSBpbml0aWFsIGxpbmUgcG9zaXRpb24gdG8gdGhlIGN1ZSBib3guXG4gICAgc3dpdGNoIChjdWUudmVydGljYWwpIHtcbiAgICBjYXNlIFwiXCI6XG4gICAgICBzdHlsZUJveC5hcHBseVN0eWxlcyh7XG4gICAgICAgIHRvcDogc3R5bGVCb3guZm9ybWF0U3R5bGUobGluZVBvcywgXCIlXCIpXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJybFwiOlxuICAgICAgc3R5bGVCb3guYXBwbHlTdHlsZXMoe1xuICAgICAgICBsZWZ0OiBzdHlsZUJveC5mb3JtYXRTdHlsZShsaW5lUG9zLCBcIiVcIilcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImxyXCI6XG4gICAgICBzdHlsZUJveC5hcHBseVN0eWxlcyh7XG4gICAgICAgIHJpZ2h0OiBzdHlsZUJveC5mb3JtYXRTdHlsZShsaW5lUG9zLCBcIiVcIilcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXhpcyA9IFsgXCIreVwiLCBcIi14XCIsIFwiK3hcIiwgXCIteVwiIF07XG5cbiAgICAvLyBHZXQgdGhlIGJveCBwb3NpdGlvbiBhZ2FpbiBhZnRlciB3ZSd2ZSBhcHBsaWVkIHRoZSBzcGVjaWZpZWQgcG9zaXRpb25pbmdcbiAgICAvLyB0byBpdC5cbiAgICBib3hQb3NpdGlvbiA9IG5ldyBCb3hQb3NpdGlvbihzdHlsZUJveCk7XG4gIH1cblxuICB2YXIgYmVzdFBvc2l0aW9uID0gZmluZEJlc3RQb3NpdGlvbihib3hQb3NpdGlvbiwgYXhpcyk7XG4gIHN0eWxlQm94Lm1vdmUoYmVzdFBvc2l0aW9uLnRvQ1NTQ29tcGF0VmFsdWVzKGNvbnRhaW5lckJveCkpO1xufVxuXG5mdW5jdGlvbiBXZWJWVFQoKSB7XG4gIC8vIE5vdGhpbmdcbn1cblxuLy8gSGVscGVyIHRvIGFsbG93IHN0cmluZ3MgdG8gYmUgZGVjb2RlZCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJpbmFyeSB1dGY4IGRhdGEuXG5XZWJWVFQuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIGRlY29kZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIC0gZXhwZWN0ZWQgc3RyaW5nIGRhdGEuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpO1xuICAgIH1cbiAgfTtcbn07XG5cbldlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlID0gZnVuY3Rpb24od2luZG93LCBjdWV0ZXh0KSB7XG4gIGlmICghd2luZG93IHx8ICFjdWV0ZXh0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhcnNlQ29udGVudCh3aW5kb3csIGN1ZXRleHQpO1xufTtcblxudmFyIEZPTlRfU0laRV9QRVJDRU5UID0gMC4wNTtcbnZhciBGT05UX1NUWUxFID0gXCJzYW5zLXNlcmlmXCI7XG52YXIgQ1VFX0JBQ0tHUk9VTkRfUEFERElORyA9IFwiMS41JVwiO1xuXG4vLyBSdW5zIHRoZSBwcm9jZXNzaW5nIG1vZGVsIG92ZXIgdGhlIGN1ZXMgYW5kIHJlZ2lvbnMgcGFzc2VkIHRvIGl0LlxuLy8gQHBhcmFtIG92ZXJsYXkgQSBibG9jayBsZXZlbCBlbGVtZW50ICh1c3VhbGx5IGEgZGl2KSB0aGF0IHRoZSBjb21wdXRlZCBjdWVzXG4vLyAgICAgICAgICAgICAgICBhbmQgcmVnaW9ucyB3aWxsIGJlIHBsYWNlZCBpbnRvLlxuV2ViVlRULnByb2Nlc3NDdWVzID0gZnVuY3Rpb24od2luZG93LCBjdWVzLCBvdmVybGF5KSB7XG4gIGlmICghd2luZG93IHx8ICFjdWVzIHx8ICFvdmVybGF5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIHByZXZpb3VzIGNoaWxkcmVuLlxuICB3aGlsZSAob3ZlcmxheS5maXJzdENoaWxkKSB7XG4gICAgb3ZlcmxheS5yZW1vdmVDaGlsZChvdmVybGF5LmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgdmFyIHBhZGRlZE92ZXJsYXkgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5sZWZ0ID0gXCIwXCI7XG4gIHBhZGRlZE92ZXJsYXkuc3R5bGUucmlnaHQgPSBcIjBcIjtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS50b3AgPSBcIjBcIjtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5ib3R0b20gPSBcIjBcIjtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5tYXJnaW4gPSBDVUVfQkFDS0dST1VORF9QQURESU5HO1xuICBvdmVybGF5LmFwcGVuZENoaWxkKHBhZGRlZE92ZXJsYXkpO1xuXG4gIC8vIERldGVybWluZSBpZiB3ZSBuZWVkIHRvIGNvbXB1dGUgdGhlIGRpc3BsYXkgc3RhdGVzIG9mIHRoZSBjdWVzLiBUaGlzIGNvdWxkXG4gIC8vIGJlIHRoZSBjYXNlIGlmIGEgY3VlJ3Mgc3RhdGUgaGFzIGJlZW4gY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBjb21wdXRhdGlvbiBvclxuICAvLyBpZiBpdCBoYXMgbm90IGJlZW4gY29tcHV0ZWQgeWV0LlxuICBmdW5jdGlvbiBzaG91bGRDb21wdXRlKGN1ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjdWVzW2ldLmhhc0JlZW5SZXNldCB8fCAhY3Vlc1tpXS5kaXNwbGF5U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFdlIGRvbid0IG5lZWQgdG8gcmVjb21wdXRlIHRoZSBjdWVzJyBkaXNwbGF5IHN0YXRlcy4gSnVzdCByZXVzZSB0aGVtLlxuICBpZiAoIXNob3VsZENvbXB1dGUoY3VlcykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhZGRlZE92ZXJsYXkuYXBwZW5kQ2hpbGQoY3Vlc1tpXS5kaXNwbGF5U3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYm94UG9zaXRpb25zID0gW10sXG4gICAgICBjb250YWluZXJCb3ggPSBCb3hQb3NpdGlvbi5nZXRTaW1wbGVCb3hQb3NpdGlvbihwYWRkZWRPdmVybGF5KSxcbiAgICAgIGZvbnRTaXplID0gTWF0aC5yb3VuZChjb250YWluZXJCb3guaGVpZ2h0ICogRk9OVF9TSVpFX1BFUkNFTlQgKiAxMDApIC8gMTAwO1xuICB2YXIgc3R5bGVPcHRpb25zID0ge1xuICAgIGZvbnQ6IGZvbnRTaXplICsgXCJweCBcIiArIEZPTlRfU1RZTEVcbiAgfTtcblxuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0eWxlQm94LCBjdWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1ZSA9IGN1ZXNbaV07XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIGludGlhbCBwb3NpdGlvbiBhbmQgc3R5bGVzIG9mIHRoZSBjdWUgZGl2LlxuICAgICAgc3R5bGVCb3ggPSBuZXcgQ3VlU3R5bGVCb3god2luZG93LCBjdWUsIHN0eWxlT3B0aW9ucyk7XG4gICAgICBwYWRkZWRPdmVybGF5LmFwcGVuZENoaWxkKHN0eWxlQm94LmRpdik7XG5cbiAgICAgIC8vIE1vdmUgdGhlIGN1ZSBkaXYgdG8gaXQncyBjb3JyZWN0IGxpbmUgcG9zaXRpb24uXG4gICAgICBtb3ZlQm94VG9MaW5lUG9zaXRpb24od2luZG93LCBzdHlsZUJveCwgY29udGFpbmVyQm94LCBib3hQb3NpdGlvbnMpO1xuXG4gICAgICAvLyBSZW1lbWJlciB0aGUgY29tcHV0ZWQgZGl2IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byByZWNvbXB1dGUgaXQgbGF0ZXJcbiAgICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgdG9vLlxuICAgICAgY3VlLmRpc3BsYXlTdGF0ZSA9IHN0eWxlQm94LmRpdjtcblxuICAgICAgYm94UG9zaXRpb25zLnB1c2goQm94UG9zaXRpb24uZ2V0U2ltcGxlQm94UG9zaXRpb24oc3R5bGVCb3gpKTtcbiAgICB9XG4gIH0pKCk7XG59O1xuXG5XZWJWVFQuUGFyc2VyID0gZnVuY3Rpb24od2luZG93LCB2dHRqcywgZGVjb2Rlcikge1xuICBpZiAoIWRlY29kZXIpIHtcbiAgICBkZWNvZGVyID0gdnR0anM7XG4gICAgdnR0anMgPSB7fTtcbiAgfVxuICBpZiAoIXZ0dGpzKSB7XG4gICAgdnR0anMgPSB7fTtcbiAgfVxuXG4gIHRoaXMud2luZG93ID0gd2luZG93O1xuICB0aGlzLnZ0dGpzID0gdnR0anM7XG4gIHRoaXMuc3RhdGUgPSBcIklOSVRJQUxcIjtcbiAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICB0aGlzLmRlY29kZXIgPSBkZWNvZGVyIHx8IG5ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik7XG4gIHRoaXMucmVnaW9uTGlzdCA9IFtdO1xufTtcblxuV2ViVlRULlBhcnNlci5wcm90b3R5cGUgPSB7XG4gIC8vIElmIHRoZSBlcnJvciBpcyBhIFBhcnNpbmdFcnJvciB0aGVuIHJlcG9ydCBpdCB0byB0aGUgY29uc3VtZXIgaWZcbiAgLy8gcG9zc2libGUuIElmIGl0J3Mgbm90IGEgUGFyc2luZ0Vycm9yIHRoZW4gdGhyb3cgaXQgbGlrZSBub3JtYWwuXG4gIHJlcG9ydE9yVGhyb3dFcnJvcjogZnVuY3Rpb24oZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yKSB7XG4gICAgICB0aGlzLm9ucGFyc2luZ2Vycm9yICYmIHRoaXMub25wYXJzaW5nZXJyb3IoZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBkYXRhIHRoZW4gd2Ugd29uJ3QgZGVjb2RlIGl0LCBidXQgd2lsbCBqdXN0IHRyeSB0byBwYXJzZVxuICAgIC8vIHdoYXRldmVyIGlzIGluIGJ1ZmZlciBhbHJlYWR5LiBUaGlzIG1heSBvY2N1ciBpbiBjaXJjdW1zdGFuY2VzLCBmb3JcbiAgICAvLyBleGFtcGxlIHdoZW4gZmx1c2goKSBpcyBjYWxsZWQuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIGRhdGEgdGhhdCB3ZSByZWNlaXZlZC5cbiAgICAgIHNlbGYuYnVmZmVyICs9IHNlbGYuZGVjb2Rlci5kZWNvZGUoZGF0YSwge3N0cmVhbTogdHJ1ZX0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3ROZXh0TGluZSgpIHtcbiAgICAgIHZhciBidWZmZXIgPSBzZWxmLmJ1ZmZlcjtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgd2hpbGUgKHBvcyA8IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyW3Bvc10gIT09ICdcXHInICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lID0gYnVmZmVyLnN1YnN0cigwLCBwb3MpO1xuICAgICAgLy8gQWR2YW5jZSB0aGUgYnVmZmVyIGVhcmx5IGluIGNhc2Ugd2UgZmFpbCBiZWxvdy5cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xccicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXG4nKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgc2VsZi5idWZmZXIgPSBidWZmZXIuc3Vic3RyKHBvcyk7XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9XG5cbiAgICAvLyAzLjQgV2ViVlRUIHJlZ2lvbiBhbmQgV2ViVlRUIHJlZ2lvbiBzZXR0aW5ncyBzeW50YXhcbiAgICBmdW5jdGlvbiBwYXJzZVJlZ2lvbihpbnB1dCkge1xuICAgICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG5cbiAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgIHNldHRpbmdzLnNldChrLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxpbmVzXCI6XG4gICAgICAgICAgc2V0dGluZ3MuaW50ZWdlcihrLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlZ2lvbmFuY2hvclwiOlxuICAgICAgICBjYXNlIFwidmlld3BvcnRhbmNob3JcIjpcbiAgICAgICAgICB2YXIgeHkgPSB2LnNwbGl0KCcsJyk7XG4gICAgICAgICAgaWYgKHh5Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbWFrZSBzdXJlIGJvdGggeCBhbmQgeSBwYXJzZSwgc28gdXNlIGEgdGVtcG9yYXJ5XG4gICAgICAgICAgLy8gc2V0dGluZ3Mgb2JqZWN0IGhlcmUuXG4gICAgICAgICAgdmFyIGFuY2hvciA9IG5ldyBTZXR0aW5ncygpO1xuICAgICAgICAgIGFuY2hvci5wZXJjZW50KFwieFwiLCB4eVswXSk7XG4gICAgICAgICAgYW5jaG9yLnBlcmNlbnQoXCJ5XCIsIHh5WzFdKTtcbiAgICAgICAgICBpZiAoIWFuY2hvci5oYXMoXCJ4XCIpIHx8ICFhbmNob3IuaGFzKFwieVwiKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldHRpbmdzLnNldChrICsgXCJYXCIsIGFuY2hvci5nZXQoXCJ4XCIpKTtcbiAgICAgICAgICBzZXR0aW5ncy5zZXQoayArIFwiWVwiLCBhbmNob3IuZ2V0KFwieVwiKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzY3JvbGxcIjpcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgW1widXBcIl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LCAvPS8sIC9cXHMvKTtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSByZWdpb24sIHVzaW5nIGRlZmF1bHQgdmFsdWVzIGZvciBhbnkgdmFsdWVzIHRoYXQgd2VyZSBub3RcbiAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgIGlmIChzZXR0aW5ncy5oYXMoXCJpZFwiKSkge1xuICAgICAgICB2YXIgcmVnaW9uID0gbmV3IChzZWxmLnZ0dGpzLlZUVFJlZ2lvbiB8fCBzZWxmLndpbmRvdy5WVFRSZWdpb24pKCk7XG4gICAgICAgIHJlZ2lvbi53aWR0aCA9IHNldHRpbmdzLmdldChcIndpZHRoXCIsIDEwMCk7XG4gICAgICAgIHJlZ2lvbi5saW5lcyA9IHNldHRpbmdzLmdldChcImxpbmVzXCIsIDMpO1xuICAgICAgICByZWdpb24ucmVnaW9uQW5jaG9yWCA9IHNldHRpbmdzLmdldChcInJlZ2lvbmFuY2hvclhcIiwgMCk7XG4gICAgICAgIHJlZ2lvbi5yZWdpb25BbmNob3JZID0gc2V0dGluZ3MuZ2V0KFwicmVnaW9uYW5jaG9yWVwiLCAxMDApO1xuICAgICAgICByZWdpb24udmlld3BvcnRBbmNob3JYID0gc2V0dGluZ3MuZ2V0KFwidmlld3BvcnRhbmNob3JYXCIsIDApO1xuICAgICAgICByZWdpb24udmlld3BvcnRBbmNob3JZID0gc2V0dGluZ3MuZ2V0KFwidmlld3BvcnRhbmNob3JZXCIsIDEwMCk7XG4gICAgICAgIHJlZ2lvbi5zY3JvbGwgPSBzZXR0aW5ncy5nZXQoXCJzY3JvbGxcIiwgXCJcIik7XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSByZWdpb24uXG4gICAgICAgIHNlbGYub25yZWdpb24gJiYgc2VsZi5vbnJlZ2lvbihyZWdpb24pO1xuICAgICAgICAvLyBSZW1lbWJlciB0aGUgVlRUUmVnaW9uIGZvciBsYXRlciBpbiBjYXNlIHdlIHBhcnNlIGFueSBWVFRDdWVzIHRoYXRcbiAgICAgICAgLy8gcmVmZXJlbmNlIGl0LlxuICAgICAgICBzZWxmLnJlZ2lvbkxpc3QucHVzaCh7XG4gICAgICAgICAgaWQ6IHNldHRpbmdzLmdldChcImlkXCIpLFxuICAgICAgICAgIHJlZ2lvbjogcmVnaW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRyYWZ0LXBhbnRvcy1odHRwLWxpdmUtc3RyZWFtaW5nLTIwXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXBhbnRvcy1odHRwLWxpdmUtc3RyZWFtaW5nLTIwI3NlY3Rpb24tMy41XG4gICAgLy8gMy41IFdlYlZUVFxuICAgIGZ1bmN0aW9uIHBhcnNlVGltZXN0YW1wTWFwKGlucHV0KSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcblxuICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgIHN3aXRjaChrKSB7XG4gICAgICAgIGNhc2UgXCJNUEVHVFwiOlxuICAgICAgICAgIHNldHRpbmdzLmludGVnZXIoayArICdTJywgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMT0NBXCI6XG4gICAgICAgICAgc2V0dGluZ3Muc2V0KGsgKyAnTCcsIHBhcnNlVGltZVN0YW1wKHYpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSwgL1teXFxkXTovLCAvLC8pO1xuXG4gICAgICBzZWxmLm9udGltZXN0YW1wbWFwICYmIHNlbGYub250aW1lc3RhbXBtYXAoe1xuICAgICAgICBcIk1QRUdUU1wiOiBzZXR0aW5ncy5nZXQoXCJNUEVHVFNcIiksXG4gICAgICAgIFwiTE9DQUxcIjogc2V0dGluZ3MuZ2V0KFwiTE9DQUxcIilcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIDMuMiBXZWJWVFQgbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQubWF0Y2goL1gtVElNRVNUQU1QLU1BUC8pKSB7XG4gICAgICAgIC8vIFRoaXMgbGluZSBjb250YWlucyBITFMgWC1USU1FU1RBTVAtTUFQIG1ldGFkYXRhXG4gICAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgIHN3aXRjaChrKSB7XG4gICAgICAgICAgY2FzZSBcIlgtVElNRVNUQU1QLU1BUFwiOlxuICAgICAgICAgICAgcGFyc2VUaW1lc3RhbXBNYXAodik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIC89Lyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgICAgY2FzZSBcIlJlZ2lvblwiOlxuICAgICAgICAgICAgLy8gMy4zIFdlYlZUVCByZWdpb24gbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgICAgICAgICAgcGFyc2VSZWdpb24odik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIC86Lyk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyA1LjEgV2ViVlRUIGZpbGUgcGFyc2luZy5cbiAgICB0cnkge1xuICAgICAgdmFyIGxpbmU7XG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gXCJJTklUSUFMXCIpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc3RhcnQgcGFyc2luZyB1bnRpbCB3ZSBoYXZlIHRoZSBmaXJzdCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KHNlbGYuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuXG4gICAgICAgIHZhciBtID0gbGluZS5tYXRjaCgvXldFQlZUVChbIFxcdF0uKik/JC8pO1xuICAgICAgICBpZiAoIW0gfHwgIW1bMF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvci5FcnJvcnMuQmFkU2lnbmF0dXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc3RhdGUgPSBcIkhFQURFUlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChzZWxmLmJ1ZmZlcikge1xuICAgICAgICAvLyBXZSBjYW4ndCBwYXJzZSBhIGxpbmUgdW50aWwgd2UgaGF2ZSB0aGUgZnVsbCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KHNlbGYuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhbHJlYWR5Q29sbGVjdGVkTGluZSkge1xuICAgICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChzZWxmLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgXCJIRUFERVJcIjpcbiAgICAgICAgICAvLyAxMy0xOCAtIEFsbG93IGEgaGVhZGVyIChtZXRhZGF0YSkgdW5kZXIgdGhlIFdFQlZUVCBsaW5lLlxuICAgICAgICAgIGlmICgvOi8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgcGFyc2VIZWFkZXIobGluZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICghbGluZSkge1xuICAgICAgICAgICAgLy8gQW4gZW1wdHkgbGluZSB0ZXJtaW5hdGVzIHRoZSBoZWFkZXIgYW5kIHN0YXJ0cyB0aGUgYm9keSAoY3VlcykuXG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJJRFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSBcIk5PVEVcIjpcbiAgICAgICAgICAvLyBJZ25vcmUgTk9URSBibG9ja3MuXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJJRFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSBcIklEXCI6XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzdGFydCBvZiBOT1RFIGJsb2Nrcy5cbiAgICAgICAgICBpZiAoL15OT1RFKCR8WyBcXHRdKS8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiTk9URVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIDE5LTI5IC0gQWxsb3cgYW55IG51bWJlciBvZiBsaW5lIHRlcm1pbmF0b3JzLCB0aGVuIGluaXRpYWxpemUgbmV3IGN1ZSB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5jdWUgPSBuZXcgKHNlbGYudnR0anMuVlRUQ3VlIHx8IHNlbGYud2luZG93LlZUVEN1ZSkoMCwgMCwgXCJcIik7XG4gICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiQ1VFXCI7XG4gICAgICAgICAgLy8gMzAtMzkgLSBDaGVjayBpZiBzZWxmIGxpbmUgY29udGFpbnMgYW4gb3B0aW9uYWwgaWRlbnRpZmllciBvciB0aW1pbmcgZGF0YS5cbiAgICAgICAgICBpZiAobGluZS5pbmRleE9mKFwiLS0+XCIpID09PSAtMSkge1xuICAgICAgICAgICAgc2VsZi5jdWUuaWQgPSBsaW5lO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFByb2Nlc3MgbGluZSBhcyBzdGFydCBvZiBhIGN1ZS5cbiAgICAgICAgICAvKmZhbGxzIHRocm91Z2gqL1xuICAgICAgICBjYXNlIFwiQ1VFXCI6XG4gICAgICAgICAgLy8gNDAgLSBDb2xsZWN0IGN1ZSB0aW1pbmdzIGFuZCBzZXR0aW5ncy5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VDdWUobGluZSwgc2VsZi5jdWUsIHNlbGYucmVnaW9uTGlzdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgc2VsZi5yZXBvcnRPclRocm93RXJyb3IoZSk7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXG4gICAgICAgICAgICBzZWxmLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJCQURDVUVcIjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLnN0YXRlID0gXCJDVUVURVhUXCI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgXCJDVUVURVhUXCI6XG4gICAgICAgICAgdmFyIGhhc1N1YnN0cmluZyA9IGxpbmUuaW5kZXhPZihcIi0tPlwiKSAhPT0gLTE7XG4gICAgICAgICAgLy8gMzQgLSBJZiB3ZSBoYXZlIGFuIGVtcHR5IGxpbmUgdGhlbiByZXBvcnQgdGhlIGN1ZS5cbiAgICAgICAgICAvLyAzNSAtIElmIHdlIGhhdmUgdGhlIHNwZWNpYWwgc3Vic3RyaW5nICctLT4nIHRoZW4gcmVwb3J0IHRoZSBjdWUsXG4gICAgICAgICAgLy8gYnV0IGRvIG5vdCBjb2xsZWN0IHRoZSBsaW5lIGFzIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGUgY3VycmVudFxuICAgICAgICAgIC8vIG9uZSBhcyBhIG5ldyBjdWUuXG4gICAgICAgICAgaWYgKCFsaW5lIHx8IGhhc1N1YnN0cmluZyAmJiAoYWxyZWFkeUNvbGxlY3RlZExpbmUgPSB0cnVlKSkge1xuICAgICAgICAgICAgLy8gV2UgYXJlIGRvbmUgcGFyc2luZyBzZWxmIGN1ZS5cbiAgICAgICAgICAgIHNlbGYub25jdWUgJiYgc2VsZi5vbmN1ZShzZWxmLmN1ZSk7XG4gICAgICAgICAgICBzZWxmLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJJRFwiO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWxmLmN1ZS50ZXh0KSB7XG4gICAgICAgICAgICBzZWxmLmN1ZS50ZXh0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuY3VlLnRleHQgKz0gbGluZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSBcIkJBRENVRVwiOiAvLyBCQURDVUVcbiAgICAgICAgICAvLyA1NC02MiAtIENvbGxlY3QgYW5kIGRpc2NhcmQgdGhlIHJlbWFpbmluZyBjdWUuXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJJRFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHNlbGYucmVwb3J0T3JUaHJvd0Vycm9yKGUpO1xuXG4gICAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IHBhcnNpbmcgYSBjdWUsIHJlcG9ydCB3aGF0IHdlIGhhdmUuXG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gXCJDVUVURVhUXCIgJiYgc2VsZi5jdWUgJiYgc2VsZi5vbmN1ZSkge1xuICAgICAgICBzZWxmLm9uY3VlKHNlbGYuY3VlKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgIC8vIEVudGVyIEJBRFdFQlZUVCBzdGF0ZSBpZiBoZWFkZXIgd2FzIG5vdCBwYXJzZWQgY29ycmVjdGx5IG90aGVyd2lzZVxuICAgICAgLy8gYW5vdGhlciBleGNlcHRpb24gb2NjdXJyZWQgc28gZW50ZXIgQkFEQ1VFIHN0YXRlLlxuICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuc3RhdGUgPT09IFwiSU5JVElBTFwiID8gXCJCQURXRUJWVFRcIiA6IFwiQkFEQ1VFXCI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBmbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgLy8gRmluaXNoIGRlY29kaW5nIHRoZSBzdHJlYW0uXG4gICAgICBzZWxmLmJ1ZmZlciArPSBzZWxmLmRlY29kZXIuZGVjb2RlKCk7XG4gICAgICAvLyBTeW50aGVzaXplIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgY3VlIG9yIHJlZ2lvbi5cbiAgICAgIGlmIChzZWxmLmN1ZSB8fCBzZWxmLnN0YXRlID09PSBcIkhFQURFUlwiKSB7XG4gICAgICAgIHNlbGYuYnVmZmVyICs9IFwiXFxuXFxuXCI7XG4gICAgICAgIHNlbGYucGFyc2UoKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlJ3ZlIGZsdXNoZWQsIHBhcnNlZCwgYW5kIHdlJ3JlIHN0aWxsIG9uIHRoZSBJTklUSUFMIHN0YXRlIHRoZW5cbiAgICAgIC8vIHRoYXQgbWVhbnMgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggb2YgdGhlIHN0cmVhbSB0byBwYXJzZSB0aGUgZmlyc3RcbiAgICAgIC8vIGxpbmUuXG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gXCJJTklUSUFMXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3IuRXJyb3JzLkJhZFNpZ25hdHVyZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBzZWxmLnJlcG9ydE9yVGhyb3dFcnJvcihlKTtcbiAgICB9XG4gICAgc2VsZi5vbmZsdXNoICYmIHNlbGYub25mbHVzaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlZUVDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3ZpZGVvLmpzL25vZGVfbW9kdWxlcy92aWRlb2pzLXZ0dC5qcy9saWIvdnR0LmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17\n')},function(module,exports){eval('/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar autoKeyword = "auto";\nvar directionSetting = {\n  "": true,\n  "lr": true,\n  "rl": true\n};\nvar alignSetting = {\n  "start": true,\n  "middle": true,\n  "end": true,\n  "left": true,\n  "right": true\n};\n\nfunction findDirectionSetting(value) {\n  if (typeof value !== "string") {\n    return false;\n  }\n  var dir = directionSetting[value.toLowerCase()];\n  return dir ? value.toLowerCase() : false;\n}\n\nfunction findAlignSetting(value) {\n  if (typeof value !== "string") {\n    return false;\n  }\n  var align = alignSetting[value.toLowerCase()];\n  return align ? value.toLowerCase() : false;\n}\n\nfunction extend(obj) {\n  var i = 1;\n  for (; i < arguments.length; i++) {\n    var cobj = arguments[i];\n    for (var p in cobj) {\n      obj[p] = cobj[p];\n    }\n  }\n\n  return obj;\n}\n\nfunction VTTCue(startTime, endTime, text) {\n  var cue = this;\n  var isIE8 = (/MSIE\\s8\\.0/).test(navigator.userAgent);\n  var baseObj = {};\n\n  if (isIE8) {\n    cue = document.createElement(\'custom\');\n  } else {\n    baseObj.enumerable = true;\n  }\n\n  /**\n   * Shim implementation specific properties. These properties are not in\n   * the spec.\n   */\n\n  // Lets us know when the VTTCue\'s data has changed in such a way that we need\n  // to recompute its display state. This lets us compute its display state\n  // lazily.\n  cue.hasBeenReset = false;\n\n  /**\n   * VTTCue and TextTrackCue properties\n   * http://dev.w3.org/html5/webvtt/#vttcue-interface\n   */\n\n  var _id = "";\n  var _pauseOnExit = false;\n  var _startTime = startTime;\n  var _endTime = endTime;\n  var _text = text;\n  var _region = null;\n  var _vertical = "";\n  var _snapToLines = true;\n  var _line = "auto";\n  var _lineAlign = "start";\n  var _position = 50;\n  var _positionAlign = "middle";\n  var _size = 50;\n  var _align = "middle";\n\n  Object.defineProperty(cue,\n    "id", extend({}, baseObj, {\n      get: function() {\n        return _id;\n      },\n      set: function(value) {\n        _id = "" + value;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    "pauseOnExit", extend({}, baseObj, {\n      get: function() {\n        return _pauseOnExit;\n      },\n      set: function(value) {\n        _pauseOnExit = !!value;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    "startTime", extend({}, baseObj, {\n      get: function() {\n        return _startTime;\n      },\n      set: function(value) {\n        if (typeof value !== "number") {\n          throw new TypeError("Start time must be set to a number.");\n        }\n        _startTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    "endTime", extend({}, baseObj, {\n      get: function() {\n        return _endTime;\n      },\n      set: function(value) {\n        if (typeof value !== "number") {\n          throw new TypeError("End time must be set to a number.");\n        }\n        _endTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    "text", extend({}, baseObj, {\n      get: function() {\n        return _text;\n      },\n      set: function(value) {\n        _text = "" + value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    "region", extend({}, baseObj, {\n      get: function() {\n        return _region;\n      },\n      set: function(value) {\n        _region = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    "vertical", extend({}, baseObj, {\n      get: function() {\n        return _vertical;\n      },\n      set: function(value) {\n        var setting = findDirectionSetting(value);\n        // Have to check for false because the setting an be an empty string.\n        if (setting === false) {\n          throw new SyntaxError("An invalid or illegal string was specified.");\n        }\n        _vertical = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    "snapToLines", extend({}, baseObj, {\n      get: function() {\n        return _snapToLines;\n      },\n      set: function(value) {\n        _snapToLines = !!value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    "line", extend({}, baseObj, {\n      get: function() {\n        return _line;\n      },\n      set: function(value) {\n        if (typeof value !== "number" && value !== autoKeyword) {\n          throw new SyntaxError("An invalid number or illegal string was specified.");\n        }\n        _line = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    "lineAlign", extend({}, baseObj, {\n      get: function() {\n        return _lineAlign;\n      },\n      set: function(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError("An invalid or illegal string was specified.");\n        }\n        _lineAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    "position", extend({}, baseObj, {\n      get: function() {\n        return _position;\n      },\n      set: function(value) {\n        if (value < 0 || value > 100) {\n          throw new Error("Position must be between 0 and 100.");\n        }\n        _position = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    "positionAlign", extend({}, baseObj, {\n      get: function() {\n        return _positionAlign;\n      },\n      set: function(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError("An invalid or illegal string was specified.");\n        }\n        _positionAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    "size", extend({}, baseObj, {\n      get: function() {\n        return _size;\n      },\n      set: function(value) {\n        if (value < 0 || value > 100) {\n          throw new Error("Size must be between 0 and 100.");\n        }\n        _size = value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  Object.defineProperty(cue,\n    "align", extend({}, baseObj, {\n      get: function() {\n        return _align;\n      },\n      set: function(value) {\n        var setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError("An invalid or illegal string was specified.");\n        }\n        _align = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n  /**\n   * Other <track> spec defined properties\n   */\n\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n  cue.displayState = undefined;\n\n  if (isIE8) {\n    return cue;\n  }\n}\n\n/**\n * VTTCue methods\n */\n\nVTTCue.prototype.getCueAsHTML = function() {\n  // Assume WebVTT.convertCueToDOMTree is on the global.\n  return WebVTT.convertCueToDOMTree(window, this.text);\n};\n\nmodule.exports = VTTCue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL3ZpZGVvanMtdnR0LmpzL2xpYi92dHRjdWUuanM/MGYzMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnZhciBhdXRvS2V5d29yZCA9IFwiYXV0b1wiO1xudmFyIGRpcmVjdGlvblNldHRpbmcgPSB7XG4gIFwiXCI6IHRydWUsXG4gIFwibHJcIjogdHJ1ZSxcbiAgXCJybFwiOiB0cnVlXG59O1xudmFyIGFsaWduU2V0dGluZyA9IHtcbiAgXCJzdGFydFwiOiB0cnVlLFxuICBcIm1pZGRsZVwiOiB0cnVlLFxuICBcImVuZFwiOiB0cnVlLFxuICBcImxlZnRcIjogdHJ1ZSxcbiAgXCJyaWdodFwiOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBkaXIgPSBkaXJlY3Rpb25TZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gZGlyID8gdmFsdWUudG9Mb3dlckNhc2UoKSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGFsaWduID0gYWxpZ25TZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gYWxpZ24gPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChvYmopIHtcbiAgdmFyIGkgPSAxO1xuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb2JqID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAodmFyIHAgaW4gY29iaikge1xuICAgICAgb2JqW3BdID0gY29ialtwXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCB0ZXh0KSB7XG4gIHZhciBjdWUgPSB0aGlzO1xuICB2YXIgaXNJRTggPSAoL01TSUVcXHM4XFwuMC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBiYXNlT2JqID0ge307XG5cbiAgaWYgKGlzSUU4KSB7XG4gICAgY3VlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gIH0gZWxzZSB7XG4gICAgYmFzZU9iai5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaGltIGltcGxlbWVudGF0aW9uIHNwZWNpZmljIHByb3BlcnRpZXMuIFRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBpblxuICAgKiB0aGUgc3BlYy5cbiAgICovXG5cbiAgLy8gTGV0cyB1cyBrbm93IHdoZW4gdGhlIFZUVEN1ZSdzIGRhdGEgaGFzIGNoYW5nZWQgaW4gc3VjaCBhIHdheSB0aGF0IHdlIG5lZWRcbiAgLy8gdG8gcmVjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlLiBUaGlzIGxldHMgdXMgY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZVxuICAvLyBsYXppbHkuXG4gIGN1ZS5oYXNCZWVuUmVzZXQgPSBmYWxzZTtcblxuICAvKipcbiAgICogVlRUQ3VlIGFuZCBUZXh0VHJhY2tDdWUgcHJvcGVydGllc1xuICAgKiBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJ2dHQvI3Z0dGN1ZS1pbnRlcmZhY2VcbiAgICovXG5cbiAgdmFyIF9pZCA9IFwiXCI7XG4gIHZhciBfcGF1c2VPbkV4aXQgPSBmYWxzZTtcbiAgdmFyIF9zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gIHZhciBfZW5kVGltZSA9IGVuZFRpbWU7XG4gIHZhciBfdGV4dCA9IHRleHQ7XG4gIHZhciBfcmVnaW9uID0gbnVsbDtcbiAgdmFyIF92ZXJ0aWNhbCA9IFwiXCI7XG4gIHZhciBfc25hcFRvTGluZXMgPSB0cnVlO1xuICB2YXIgX2xpbmUgPSBcImF1dG9cIjtcbiAgdmFyIF9saW5lQWxpZ24gPSBcInN0YXJ0XCI7XG4gIHZhciBfcG9zaXRpb24gPSA1MDtcbiAgdmFyIF9wb3NpdGlvbkFsaWduID0gXCJtaWRkbGVcIjtcbiAgdmFyIF9zaXplID0gNTA7XG4gIHZhciBfYWxpZ24gPSBcIm1pZGRsZVwiO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJpZFwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfaWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBfaWQgPSBcIlwiICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJwYXVzZU9uRXhpdFwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcGF1c2VPbkV4aXQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBfcGF1c2VPbkV4aXQgPSAhIXZhbHVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwic3RhcnRUaW1lXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdGFydFRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN0YXJ0IHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9zdGFydFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwiZW5kVGltZVwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZW5kVGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRW5kIHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9lbmRUaW1lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInRleHRcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3RleHQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBfdGV4dCA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwicmVnaW9uXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdpb247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBfcmVnaW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInZlcnRpY2FsXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF92ZXJ0aWNhbDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpO1xuICAgICAgICAvLyBIYXZlIHRvIGNoZWNrIGZvciBmYWxzZSBiZWNhdXNlIHRoZSBzZXR0aW5nIGFuIGJlIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgaWYgKHNldHRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfdmVydGljYWwgPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJzbmFwVG9MaW5lc1wiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc25hcFRvTGluZXM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBfc25hcFRvTGluZXMgPSAhIXZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJsaW5lXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9saW5lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIiAmJiB2YWx1ZSAhPT0gYXV0b0tleXdvcmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG51bWJlciBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfbGluZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJsaW5lQWxpZ25cIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2xpbmVBbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX2xpbmVBbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInBvc2l0aW9uXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3NpdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwicG9zaXRpb25BbGlnblwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcG9zaXRpb25BbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3Bvc2l0aW9uQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJzaXplXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpemUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3NpemUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwiYWxpZ25cIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2FsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfYWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIC8qKlxuICAgKiBPdGhlciA8dHJhY2s+IHNwZWMgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAqL1xuXG4gIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS12aWRlby1lbGVtZW50Lmh0bWwjdGV4dC10cmFjay1jdWUtZGlzcGxheS1zdGF0ZVxuICBjdWUuZGlzcGxheVN0YXRlID0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0lFOCkge1xuICAgIHJldHVybiBjdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBWVFRDdWUgbWV0aG9kc1xuICovXG5cblZUVEN1ZS5wcm90b3R5cGUuZ2V0Q3VlQXNIVE1MID0gZnVuY3Rpb24oKSB7XG4gIC8vIEFzc3VtZSBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSBpcyBvbiB0aGUgZ2xvYmFsLlxuICByZXR1cm4gV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUod2luZG93LCB0aGlzLnRleHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWVFRDdWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92aWRlby5qcy9ub2RlX21vZHVsZXMvdmlkZW9qcy12dHQuanMvbGliL3Z0dGN1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18\n')},function(module,exports){eval('/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar scrollSetting = {\n  "": true,\n  "up": true\n};\n\nfunction findScrollSetting(value) {\n  if (typeof value !== "string") {\n    return false;\n  }\n  var scroll = scrollSetting[value.toLowerCase()];\n  return scroll ? value.toLowerCase() : false;\n}\n\nfunction isValidPercentValue(value) {\n  return typeof value === "number" && (value >= 0 && value <= 100);\n}\n\n// VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface\nfunction VTTRegion() {\n  var _width = 100;\n  var _lines = 3;\n  var _regionAnchorX = 0;\n  var _regionAnchorY = 100;\n  var _viewportAnchorX = 0;\n  var _viewportAnchorY = 100;\n  var _scroll = "";\n\n  Object.defineProperties(this, {\n    "width": {\n      enumerable: true,\n      get: function() {\n        return _width;\n      },\n      set: function(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error("Width must be between 0 and 100.");\n        }\n        _width = value;\n      }\n    },\n    "lines": {\n      enumerable: true,\n      get: function() {\n        return _lines;\n      },\n      set: function(value) {\n        if (typeof value !== "number") {\n          throw new TypeError("Lines must be set to a number.");\n        }\n        _lines = value;\n      }\n    },\n    "regionAnchorY": {\n      enumerable: true,\n      get: function() {\n        return _regionAnchorY;\n      },\n      set: function(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error("RegionAnchorX must be between 0 and 100.");\n        }\n        _regionAnchorY = value;\n      }\n    },\n    "regionAnchorX": {\n      enumerable: true,\n      get: function() {\n        return _regionAnchorX;\n      },\n      set: function(value) {\n        if(!isValidPercentValue(value)) {\n          throw new Error("RegionAnchorY must be between 0 and 100.");\n        }\n        _regionAnchorX = value;\n      }\n    },\n    "viewportAnchorY": {\n      enumerable: true,\n      get: function() {\n        return _viewportAnchorY;\n      },\n      set: function(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error("ViewportAnchorY must be between 0 and 100.");\n        }\n        _viewportAnchorY = value;\n      }\n    },\n    "viewportAnchorX": {\n      enumerable: true,\n      get: function() {\n        return _viewportAnchorX;\n      },\n      set: function(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error("ViewportAnchorX must be between 0 and 100.");\n        }\n        _viewportAnchorX = value;\n      }\n    },\n    "scroll": {\n      enumerable: true,\n      get: function() {\n        return _scroll;\n      },\n      set: function(value) {\n        var setting = findScrollSetting(value);\n        // Have to check for false as an empty string is a legal value.\n        if (setting === false) {\n          throw new SyntaxError("An invalid or illegal string was specified.");\n        }\n        _scroll = setting;\n      }\n    }\n  });\n}\n\nmodule.exports = VTTRegion;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvbm9kZV9tb2R1bGVzL3ZpZGVvanMtdnR0LmpzL2xpYi92dHRyZWdpb24uanM/ZWRlNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIHNjcm9sbFNldHRpbmcgPSB7XG4gIFwiXCI6IHRydWUsXG4gIFwidXBcIjogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZmluZFNjcm9sbFNldHRpbmcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc2Nyb2xsID0gc2Nyb2xsU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgcmV0dXJuIHNjcm9sbCA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDEwMCk7XG59XG5cbi8vIFZUVFJlZ2lvbiBzaGltIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0cmVnaW9uLWludGVyZmFjZVxuZnVuY3Rpb24gVlRUUmVnaW9uKCkge1xuICB2YXIgX3dpZHRoID0gMTAwO1xuICB2YXIgX2xpbmVzID0gMztcbiAgdmFyIF9yZWdpb25BbmNob3JYID0gMDtcbiAgdmFyIF9yZWdpb25BbmNob3JZID0gMTAwO1xuICB2YXIgX3ZpZXdwb3J0QW5jaG9yWCA9IDA7XG4gIHZhciBfdmlld3BvcnRBbmNob3JZID0gMTAwO1xuICB2YXIgX3Njcm9sbCA9IFwiXCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIFwid2lkdGhcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfd2lkdGg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzVmFsaWRQZXJjZW50VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2lkdGggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3dpZHRoID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcImxpbmVzXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2xpbmVzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJMaW5lcyBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX2xpbmVzID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInJlZ2lvbkFuY2hvcllcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcmVnaW9uQW5jaG9yWTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWdpb25BbmNob3JYIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9yZWdpb25BbmNob3JZID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInJlZ2lvbkFuY2hvclhcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcmVnaW9uQW5jaG9yWDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmKCFpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZ2lvbkFuY2hvclkgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3JlZ2lvbkFuY2hvclggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwidmlld3BvcnRBbmNob3JZXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3ZpZXdwb3J0QW5jaG9yWTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWaWV3cG9ydEFuY2hvclkgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3ZpZXdwb3J0QW5jaG9yWSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJ2aWV3cG9ydEFuY2hvclhcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdmlld3BvcnRBbmNob3JYO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZpZXdwb3J0QW5jaG9yWCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfdmlld3BvcnRBbmNob3JYID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInNjcm9sbFwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zY3JvbGw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRTY3JvbGxTZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgLy8gSGF2ZSB0byBjaGVjayBmb3IgZmFsc2UgYXMgYW4gZW1wdHkgc3RyaW5nIGlzIGEgbGVnYWwgdmFsdWUuXG4gICAgICAgIGlmIChzZXR0aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3Njcm9sbCA9IHNldHRpbmc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWVFRSZWdpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92aWRlby5qcy9ub2RlX21vZHVsZXMvdmlkZW9qcy12dHQuanMvbGliL3Z0dHJlZ2lvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n')},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(21);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(4)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../css-loader/index.js!./video-js.css\", function() {\n\t\t\tvar newContent = require(\"!!../../css-loader/index.js!./video-js.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvZGlzdC92aWRlby1qcy5jc3M/NGJhZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi92aWRlby1qcy5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3ZpZGVvLWpzLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3ZpZGVvLWpzLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvZGlzdC92aWRlby1qcy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20\n")},function(module,exports,__webpack_require__){eval('var escape = __webpack_require__(22);\nexports = module.exports = __webpack_require__(3)(false);\n// imports\n\n\n// module\nexports.push([module.i, ".video-js .vjs-big-play-button .vjs-icon-placeholder:before,.video-js .vjs-modal-dialog,.vjs-button>.vjs-icon-placeholder:before,.vjs-modal-dialog .vjs-modal-dialog-content{position:absolute;top:0;left:0;width:100%;height:100%}.video-js .vjs-big-play-button .vjs-icon-placeholder:before,.vjs-button>.vjs-icon-placeholder:before{text-align:center}@font-face{font-family:VideoJS;src:url(" + escape(__webpack_require__(23)) + "?#iefix) format(\\"eot\\")}@font-face{font-family:VideoJS;src:url(data:application/font-woff;charset=utf-8;base64,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) format(\\"woff\\"),url(data:application/x-font-ttf;charset=utf-8;base64,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AG8AbgB0AGUAbABsAG8AIABwAHIAbwBqAGUAYwB0AC4AaAB0AHQAcAA6AC8ALwBmAG8AbgB0AGUAbABsAG8ALgBjAG8AbQAAAAIAAAAAAAAAEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIQECAQMBBAEFAQYBBwEIAQkBCgELAQwBDQEOAQ8BEAERARIBEwEUARUBFgEXARgBGQEaARsBHAEdAR4BHwEgASEBIgAEcGxheQtwbGF5LWNpcmNsZQVwYXVzZQt2b2x1bWUtbXV0ZQp2b2x1bWUtbG93CnZvbHVtZS1taWQLdm9sdW1lLWhpZ2gQZnVsbHNjcmVlbi1lbnRlcg9mdWxsc2NyZWVuLWV4aXQGc3F1YXJlB3NwaW5uZXIJc3VidGl0bGVzCGNhcHRpb25zCGNoYXB0ZXJzBXNoYXJlA2NvZwZjaXJjbGUOY2lyY2xlLW91dGxpbmUTY2lyY2xlLWlubmVyLWNpcmNsZQJoZAZjYW5jZWwGcmVwbGF5CGZhY2Vib29rBWdwbHVzCGxpbmtlZGluB3R3aXR0ZXIGdHVtYmxyCXBpbnRlcmVzdBFhdWRpby1kZXNjcmlwdGlvbgVhdWRpbwluZXh0LWl0ZW0NcHJldmlvdXMtaXRlbQAAAAA=) format(\\"truetype\\");font-weight:400;font-style:normal}.video-js .vjs-big-play-button .vjs-icon-placeholder:before,.video-js .vjs-play-control .vjs-icon-placeholder,.vjs-icon-play{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-big-play-button .vjs-icon-placeholder:before,.video-js .vjs-play-control .vjs-icon-placeholder:before,.vjs-icon-play:before{content:\\"\\\\F101\\"}.vjs-icon-play-circle{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-play-circle:before{content:\\"\\\\F102\\"}.video-js .vjs-play-control.vjs-playing .vjs-icon-placeholder,.vjs-icon-pause{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-play-control.vjs-playing .vjs-icon-placeholder:before,.vjs-icon-pause:before{content:\\"\\\\F103\\"}.video-js .vjs-mute-control.vjs-vol-0 .vjs-icon-placeholder,.vjs-icon-volume-mute{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-mute-control.vjs-vol-0 .vjs-icon-placeholder:before,.vjs-icon-volume-mute:before{content:\\"\\\\F104\\"}.video-js .vjs-mute-control.vjs-vol-1 .vjs-icon-placeholder,.vjs-icon-volume-low{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-mute-control.vjs-vol-1 .vjs-icon-placeholder:before,.vjs-icon-volume-low:before{content:\\"\\\\F105\\"}.video-js .vjs-mute-control.vjs-vol-2 .vjs-icon-placeholder,.vjs-icon-volume-mid{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-mute-control.vjs-vol-2 .vjs-icon-placeholder:before,.vjs-icon-volume-mid:before{content:\\"\\\\F106\\"}.video-js .vjs-mute-control .vjs-icon-placeholder,.vjs-icon-volume-high{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-mute-control .vjs-icon-placeholder:before,.vjs-icon-volume-high:before{content:\\"\\\\F107\\"}.video-js .vjs-fullscreen-control .vjs-icon-placeholder,.vjs-icon-fullscreen-enter{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-fullscreen-control .vjs-icon-placeholder:before,.vjs-icon-fullscreen-enter:before{content:\\"\\\\F108\\"}.video-js.vjs-fullscreen .vjs-fullscreen-control .vjs-icon-placeholder,.vjs-icon-fullscreen-exit{font-family:VideoJS;font-weight:400;font-style:normal}.video-js.vjs-fullscreen .vjs-fullscreen-control .vjs-icon-placeholder:before,.vjs-icon-fullscreen-exit:before{content:\\"\\\\F109\\"}.vjs-icon-square{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-square:before{content:\\"\\\\F10A\\"}.vjs-icon-spinner{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-spinner:before{content:\\"\\\\F10B\\"}.video-js.video-js:lang(en-AU) .vjs-subs-caps-button .vjs-icon-placeholder,.video-js.video-js:lang(en-GB) .vjs-subs-caps-button .vjs-icon-placeholder,.video-js.video-js:lang(en-IE) .vjs-subs-caps-button .vjs-icon-placeholder,.video-js.video-js:lang(en-NZ) .vjs-subs-caps-button .vjs-icon-placeholder,.video-js .vjs-subs-caps-button .vjs-icon-placeholder,.video-js .vjs-subtitles-button .vjs-icon-placeholder,.vjs-icon-subtitles{font-family:VideoJS;font-weight:400;font-style:normal}.video-js.video-js:lang(en-AU) .vjs-subs-caps-button .vjs-icon-placeholder:before,.video-js.video-js:lang(en-GB) .vjs-subs-caps-button .vjs-icon-placeholder:before,.video-js.video-js:lang(en-IE) .vjs-subs-caps-button .vjs-icon-placeholder:before,.video-js.video-js:lang(en-NZ) .vjs-subs-caps-button .vjs-icon-placeholder:before,.video-js .vjs-subs-caps-button .vjs-icon-placeholder:before,.video-js .vjs-subtitles-button .vjs-icon-placeholder:before,.vjs-icon-subtitles:before{content:\\"\\\\F10C\\"}.video-js .vjs-captions-button .vjs-icon-placeholder,.video-js:lang(en) .vjs-subs-caps-button .vjs-icon-placeholder,.video-js:lang(fr-CA) .vjs-subs-caps-button .vjs-icon-placeholder,.vjs-icon-captions{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-captions-button .vjs-icon-placeholder:before,.video-js:lang(en) .vjs-subs-caps-button .vjs-icon-placeholder:before,.video-js:lang(fr-CA) .vjs-subs-caps-button .vjs-icon-placeholder:before,.vjs-icon-captions:before{content:\\"\\\\F10D\\"}.video-js .vjs-chapters-button .vjs-icon-placeholder,.vjs-icon-chapters{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-chapters-button .vjs-icon-placeholder:before,.vjs-icon-chapters:before{content:\\"\\\\F10E\\"}.vjs-icon-share{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-share:before{content:\\"\\\\F10F\\"}.vjs-icon-cog{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-cog:before{content:\\"\\\\F110\\"}.video-js .vjs-play-progress,.video-js .vjs-volume-level,.vjs-icon-circle{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-play-progress:before,.video-js .vjs-volume-level:before,.vjs-icon-circle:before{content:\\"\\\\F111\\"}.vjs-icon-circle-outline{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-circle-outline:before{content:\\"\\\\F112\\"}.vjs-icon-circle-inner-circle{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-circle-inner-circle:before{content:\\"\\\\F113\\"}.vjs-icon-hd{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-hd:before{content:\\"\\\\F114\\"}.video-js .vjs-control.vjs-close-button .vjs-icon-placeholder,.vjs-icon-cancel{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-control.vjs-close-button .vjs-icon-placeholder:before,.vjs-icon-cancel:before{content:\\"\\\\F115\\"}.video-js .vjs-play-control.vjs-ended .vjs-icon-placeholder,.vjs-icon-replay{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-play-control.vjs-ended .vjs-icon-placeholder:before,.vjs-icon-replay:before{content:\\"\\\\F116\\"}.vjs-icon-facebook{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-facebook:before{content:\\"\\\\F117\\"}.vjs-icon-gplus{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-gplus:before{content:\\"\\\\F118\\"}.vjs-icon-linkedin{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-linkedin:before{content:\\"\\\\F119\\"}.vjs-icon-twitter{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-twitter:before{content:\\"\\\\F11A\\"}.vjs-icon-tumblr{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-tumblr:before{content:\\"\\\\F11B\\"}.vjs-icon-pinterest{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-pinterest:before{content:\\"\\\\F11C\\"}.video-js .vjs-descriptions-button .vjs-icon-placeholder,.vjs-icon-audio-description{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-descriptions-button .vjs-icon-placeholder:before,.vjs-icon-audio-description:before{content:\\"\\\\F11D\\"}.video-js .vjs-audio-button .vjs-icon-placeholder,.vjs-icon-audio{font-family:VideoJS;font-weight:400;font-style:normal}.video-js .vjs-audio-button .vjs-icon-placeholder:before,.vjs-icon-audio:before{content:\\"\\\\F11E\\"}.vjs-icon-next-item{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-next-item:before{content:\\"\\\\F11F\\"}.vjs-icon-previous-item{font-family:VideoJS;font-weight:400;font-style:normal}.vjs-icon-previous-item:before{content:\\"\\\\F120\\"}.video-js{display:block;vertical-align:top;box-sizing:border-box;color:#fff;background-color:#000;position:relative;padding:0;font-size:10px;line-height:1;font-weight:400;font-style:normal;font-family:Arial,Helvetica,sans-serif;word-break:normal}.video-js:-moz-full-screen{position:absolute}.video-js:-webkit-full-screen{width:100%!important;height:100%!important}.video-js[tabindex=\\"-1\\"]{outline:none}.video-js *,.video-js :after,.video-js :before{box-sizing:inherit}.video-js ul{font-family:inherit;font-size:inherit;line-height:inherit;list-style-position:outside;margin:0}.video-js.vjs-4-3,.video-js.vjs-16-9,.video-js.vjs-fluid{width:100%;max-width:100%;height:0}.video-js.vjs-16-9{padding-top:56.25%}.video-js.vjs-4-3{padding-top:75%}.video-js.vjs-fill,.video-js .vjs-tech{width:100%;height:100%}.video-js .vjs-tech{position:absolute;top:0;left:0}body.vjs-full-window{padding:0;margin:0;height:100%;overflow-y:auto}.vjs-full-window .video-js.vjs-fullscreen{position:fixed;overflow:hidden;z-index:1000;left:0;top:0;bottom:0;right:0}.video-js.vjs-fullscreen{width:100%!important;height:100%!important;padding-top:0!important}.video-js.vjs-fullscreen.vjs-user-inactive{cursor:none}.vjs-hidden{display:none!important}.vjs-disabled{opacity:.5;cursor:default}.video-js .vjs-offscreen{height:1px;left:-9999px;position:absolute;top:0;width:1px}.vjs-lock-showing{display:block!important;opacity:1;visibility:visible}.vjs-no-js{padding:20px;color:#fff;background-color:#000;font-size:18px;font-family:Arial,Helvetica,sans-serif;text-align:center;width:300px;height:150px;margin:0 auto}.vjs-no-js a,.vjs-no-js a:visited{color:#66a8cc}.video-js .vjs-big-play-button{font-size:3em;line-height:1.5em;height:1.5em;width:3em;display:block;position:absolute;top:10px;left:10px;padding:0;cursor:pointer;opacity:1;border:.06666em solid #fff;background-color:#2b333f;background-color:rgba(43,51,63,.7);-webkit-border-radius:.3em;-moz-border-radius:.3em;border-radius:.3em;-webkit-transition:all .4s;-moz-transition:all .4s;-ms-transition:all .4s;-o-transition:all .4s;transition:all .4s}.vjs-big-play-centered .vjs-big-play-button{top:50%;left:50%;margin-top:-.75em;margin-left:-1.5em}.video-js .vjs-big-play-button:focus,.video-js:hover .vjs-big-play-button{border-color:#fff;background-color:#73859f;background-color:rgba(115,133,159,.5);-webkit-transition:all 0s;-moz-transition:all 0s;-ms-transition:all 0s;-o-transition:all 0s;transition:all 0s}.vjs-controls-disabled .vjs-big-play-button,.vjs-error .vjs-big-play-button,.vjs-has-started .vjs-big-play-button,.vjs-using-native-controls .vjs-big-play-button{display:none}.vjs-has-started.vjs-paused.vjs-show-big-play-button-on-pause .vjs-big-play-button{display:block}.video-js button{background:none;border:none;color:inherit;display:inline-block;overflow:visible;font-size:inherit;line-height:inherit;text-transform:none;text-decoration:none;transition:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.vjs-control .vjs-button{width:100%;height:100%}.video-js .vjs-control.vjs-close-button{cursor:pointer;height:3em;position:absolute;right:0;top:.5em;z-index:2}.video-js .vjs-modal-dialog{background:rgba(0,0,0,.8);background:-webkit-linear-gradient(-90deg,rgba(0,0,0,.8),hsla(0,0%,100%,0));background:linear-gradient(180deg,rgba(0,0,0,.8),hsla(0,0%,100%,0));overflow:auto;box-sizing:content-box}.video-js .vjs-modal-dialog>*{box-sizing:border-box}.vjs-modal-dialog .vjs-modal-dialog-content{font-size:1.2em;line-height:1.5;padding:20px 24px;z-index:1}.vjs-menu-button{cursor:pointer}.vjs-menu-button.vjs-disabled{cursor:default}.vjs-workinghover .vjs-menu-button.vjs-disabled:hover .vjs-menu{display:none}.vjs-menu .vjs-menu-content{display:block;padding:0;margin:0;font-family:Arial,Helvetica,sans-serif;overflow:auto;box-sizing:content-box}.vjs-menu .vjs-menu-content>*{box-sizing:border-box}.vjs-scrubbing .vjs-menu-button:hover .vjs-menu{display:none}.vjs-menu li{list-style:none;margin:0;padding:.2em 0;line-height:1.4em;font-size:1.2em;text-align:center;text-transform:lowercase}.vjs-menu li.vjs-menu-item:focus,.vjs-menu li.vjs-menu-item:hover{background-color:#73859f;background-color:rgba(115,133,159,.5)}.vjs-menu li.vjs-selected,.vjs-menu li.vjs-selected:focus,.vjs-menu li.vjs-selected:hover{background-color:#fff;color:#2b333f}.vjs-menu li.vjs-menu-title{text-align:center;text-transform:uppercase;font-size:1em;line-height:2em;padding:0;margin:0 0 .3em;font-weight:700;cursor:default}.vjs-menu-button-popup .vjs-menu{display:none;position:absolute;bottom:0;width:10em;left:-3em;height:0;margin-bottom:1.5em;border-top-color:rgba(43,51,63,.7)}.vjs-menu-button-popup .vjs-menu .vjs-menu-content{background-color:#2b333f;background-color:rgba(43,51,63,.7);position:absolute;width:100%;bottom:1.5em;max-height:15em}.vjs-menu-button-popup .vjs-menu.vjs-lock-showing,.vjs-workinghover .vjs-menu-button-popup:hover .vjs-menu{display:block}.video-js .vjs-menu-button-inline{-webkit-transition:all .4s;-moz-transition:all .4s;-ms-transition:all .4s;-o-transition:all .4s;transition:all .4s;overflow:hidden}.video-js .vjs-menu-button-inline:before{width:2.222222222em}.video-js .vjs-menu-button-inline.vjs-slider-active,.video-js .vjs-menu-button-inline:focus,.video-js .vjs-menu-button-inline:hover,.video-js.vjs-no-flex .vjs-menu-button-inline{width:12em}.vjs-menu-button-inline .vjs-menu{opacity:0;height:100%;width:auto;position:absolute;left:4em;top:0;padding:0;margin:0;-webkit-transition:all .4s;-moz-transition:all .4s;-ms-transition:all .4s;-o-transition:all .4s;transition:all .4s}.vjs-menu-button-inline.vjs-slider-active .vjs-menu,.vjs-menu-button-inline:focus .vjs-menu,.vjs-menu-button-inline:hover .vjs-menu{display:block;opacity:1}.vjs-no-flex .vjs-menu-button-inline .vjs-menu{display:block;opacity:1;position:relative;width:auto}.vjs-no-flex .vjs-menu-button-inline.vjs-slider-active .vjs-menu,.vjs-no-flex .vjs-menu-button-inline:focus .vjs-menu,.vjs-no-flex .vjs-menu-button-inline:hover .vjs-menu{width:auto}.vjs-menu-button-inline .vjs-menu-content{width:auto;height:100%;margin:0;overflow:hidden}.video-js .vjs-control-bar{display:none;width:100%;position:absolute;bottom:0;left:0;right:0;height:3em;background-color:#2b333f;background-color:rgba(43,51,63,.7)}.vjs-has-started .vjs-control-bar{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;visibility:visible;opacity:1;-webkit-transition:visibility .1s,opacity .1s;-moz-transition:visibility .1s,opacity .1s;-ms-transition:visibility .1s,opacity .1s;-o-transition:visibility .1s,opacity .1s;transition:visibility .1s,opacity .1s}.vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar{visibility:visible;opacity:0;-webkit-transition:visibility 1s,opacity 1s;-moz-transition:visibility 1s,opacity 1s;-ms-transition:visibility 1s,opacity 1s;-o-transition:visibility 1s,opacity 1s;transition:visibility 1s,opacity 1s}.vjs-controls-disabled .vjs-control-bar,.vjs-error .vjs-control-bar,.vjs-using-native-controls .vjs-control-bar{display:none!important}.vjs-audio.vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar{opacity:1;visibility:visible}.vjs-has-started.vjs-no-flex .vjs-control-bar{display:table}.video-js .vjs-control{position:relative;text-align:center;margin:0;padding:0;height:100%;width:4em;-webkit-box-flex:none;-moz-box-flex:none;-webkit-flex:none;-ms-flex:none;flex:none}.vjs-button>.vjs-icon-placeholder:before{font-size:1.8em;line-height:1.67}.video-js .vjs-control:focus,.video-js .vjs-control:focus:before,.video-js .vjs-control:hover:before{text-shadow:0 0 1em #fff}.video-js .vjs-control-text{border:0;clip:rect(0 0 0 0);height:1px;overflow:hidden;padding:0;position:absolute;width:1px}.vjs-no-flex .vjs-control{display:table-cell;vertical-align:middle}.video-js .vjs-custom-control-spacer{display:none}.video-js .vjs-progress-control{cursor:pointer;-webkit-box-flex:auto;-moz-box-flex:auto;-webkit-flex:auto;-ms-flex:auto;flex:auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;min-width:4em}.video-js .vjs-progress-control.disabled{cursor:default}.vjs-live .vjs-progress-control{display:none}.vjs-no-flex .vjs-progress-control{width:auto}.video-js .vjs-progress-holder{-webkit-box-flex:auto;-moz-box-flex:auto;-webkit-flex:auto;-ms-flex:auto;flex:auto;-webkit-transition:all .2s;-moz-transition:all .2s;-ms-transition:all .2s;-o-transition:all .2s;transition:all .2s;height:.3em}.video-js .vjs-progress-control .vjs-progress-holder{margin:0 10px}.video-js .vjs-progress-control:hover .vjs-progress-holder{font-size:1.6666666666666667em}.video-js .vjs-progress-control:hover .vjs-progress-holder.disabled{font-size:1em}.video-js .vjs-progress-holder .vjs-load-progress,.video-js .vjs-progress-holder .vjs-load-progress div,.video-js .vjs-progress-holder .vjs-play-progress{position:absolute;display:block;height:100%;margin:0;padding:0;width:0;left:0;top:0}.video-js .vjs-play-progress{background-color:#fff}.video-js .vjs-play-progress:before{font-size:.9em;position:absolute;right:-.5em;top:-.333333333333333em;z-index:1}.video-js .vjs-load-progress{background:#bfc7d3;background:rgba(115,133,159,.5)}.video-js .vjs-load-progress div{background:#fff;background:rgba(115,133,159,.75)}.video-js .vjs-time-tooltip{background-color:#fff;background-color:hsla(0,0%,100%,.8);-webkit-border-radius:.3em;-moz-border-radius:.3em;border-radius:.3em;color:#000;float:right;font-family:Arial,Helvetica,sans-serif;font-size:1em;padding:6px 8px 8px;pointer-events:none;position:relative;top:-3.4em;visibility:hidden;z-index:1}.video-js .vjs-progress-holder:focus .vjs-time-tooltip{display:none}.video-js .vjs-progress-control:hover .vjs-progress-holder:focus .vjs-time-tooltip,.video-js .vjs-progress-control:hover .vjs-time-tooltip{display:block;font-size:.6em;visibility:visible}.video-js .vjs-progress-control.disabled:hover .vjs-time-tooltip{font-size:1em}.video-js .vjs-progress-control .vjs-mouse-display{display:none;position:absolute;width:1px;height:100%;background-color:#000;z-index:1}.vjs-no-flex .vjs-progress-control .vjs-mouse-display{z-index:0}.video-js .vjs-progress-control:hover .vjs-mouse-display{display:block}.video-js.vjs-user-inactive .vjs-progress-control .vjs-mouse-display{visibility:hidden;opacity:0;-webkit-transition:visibility 1s,opacity 1s;-moz-transition:visibility 1s,opacity 1s;-ms-transition:visibility 1s,opacity 1s;-o-transition:visibility 1s,opacity 1s;transition:visibility 1s,opacity 1s}.video-js.vjs-user-inactive.vjs-no-flex .vjs-progress-control .vjs-mouse-display{display:none}.vjs-mouse-display .vjs-time-tooltip{color:#fff;background-color:#000;background-color:rgba(0,0,0,.8)}.video-js .vjs-slider{position:relative;cursor:pointer;padding:0;margin:0 .45em;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:#73859f;background-color:rgba(115,133,159,.5)}.video-js .vjs-slider.disabled{cursor:default}.video-js .vjs-slider:focus{text-shadow:0 0 1em #fff;-webkit-box-shadow:0 0 1em #fff;-moz-box-shadow:0 0 1em #fff;box-shadow:0 0 1em #fff}.video-js .vjs-mute-control{cursor:pointer;-webkit-box-flex:none;-moz-box-flex:none;-webkit-flex:none;-ms-flex:none;flex:none;padding-left:2em;padding-right:2em;padding-bottom:3em}.video-js .vjs-volume-control{cursor:pointer;margin-right:1em;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.video-js .vjs-volume-control.vjs-volume-horizontal{width:5em}.video-js .vjs-volume-panel .vjs-volume-control{visibility:visible;opacity:0;width:1px;height:1px;margin-left:-1px}.vjs-no-flex .vjs-volume-panel .vjs-volume-control.vjs-volume-vertical,.vjs-no-flex .vjs-volume-panel .vjs-volume-control.vjs-volume-vertical .vjs-volume-bar,.vjs-no-flex .vjs-volume-panel .vjs-volume-control.vjs-volume-vertical .vjs-volume-level{-ms-filter:\\"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)\\"}.video-js .vjs-volume-panel{-webkit-transition:width 1s;-moz-transition:width 1s;-ms-transition:width 1s;-o-transition:width 1s;transition:width 1s}.video-js .vjs-volume-panel .vjs-mute-control:hover~.vjs-volume-control,.video-js .vjs-volume-panel .vjs-volume-control.vjs-slider-active,.video-js .vjs-volume-panel .vjs-volume-control:active,.video-js .vjs-volume-panel .vjs-volume-control:hover,.video-js .vjs-volume-panel:active .vjs-volume-control,.video-js .vjs-volume-panel:focus .vjs-volume-control,.video-js .vjs-volume-panel:hover .vjs-volume-control{visibility:visible;opacity:1;position:relative;-webkit-transition:visibility .1s,opacity .1s,height .1s,width .1s,left 0s,top 0s;-moz-transition:visibility .1s,opacity .1s,height .1s,width .1s,left 0s,top 0s;-ms-transition:visibility .1s,opacity .1s,height .1s,width .1s,left 0s,top 0s;-o-transition:visibility .1s,opacity .1s,height .1s,width .1s,left 0s,top 0s;transition:visibility .1s,opacity .1s,height .1s,width .1s,left 0s,top 0s}.video-js .vjs-volume-panel .vjs-mute-control:hover~.vjs-volume-control.vjs-volume-horizontal,.video-js .vjs-volume-panel .vjs-volume-control.vjs-slider-active.vjs-volume-horizontal,.video-js .vjs-volume-panel .vjs-volume-control:active.vjs-volume-horizontal,.video-js .vjs-volume-panel .vjs-volume-control:hover.vjs-volume-horizontal,.video-js .vjs-volume-panel:active .vjs-volume-control.vjs-volume-horizontal,.video-js .vjs-volume-panel:focus .vjs-volume-control.vjs-volume-horizontal,.video-js .vjs-volume-panel:hover .vjs-volume-control.vjs-volume-horizontal{width:5em;height:3em}.video-js .vjs-volume-panel .vjs-mute-control:hover~.vjs-volume-control.vjs-volume-vertical,.video-js .vjs-volume-panel .vjs-mute-control:hover~.vjs-volume-control.vjs-volume-vertical .vjs-volume-bar,.video-js .vjs-volume-panel .vjs-mute-control:hover~.vjs-volume-control.vjs-volume-vertical .vjs-volume-level,.video-js .vjs-volume-panel .vjs-volume-control.vjs-slider-active.vjs-volume-vertical,.video-js .vjs-volume-panel .vjs-volume-control.vjs-slider-active.vjs-volume-vertical .vjs-volume-bar,.video-js .vjs-volume-panel .vjs-volume-control.vjs-slider-active.vjs-volume-vertical .vjs-volume-level,.video-js .vjs-volume-panel .vjs-volume-control:active.vjs-volume-vertical,.video-js .vjs-volume-panel .vjs-volume-control:active.vjs-volume-vertical .vjs-volume-bar,.video-js .vjs-volume-panel .vjs-volume-control:active.vjs-volume-vertical .vjs-volume-level,.video-js .vjs-volume-panel .vjs-volume-control:hover.vjs-volume-vertical,.video-js .vjs-volume-panel .vjs-volume-control:hover.vjs-volume-vertical .vjs-volume-bar,.video-js .vjs-volume-panel .vjs-volume-control:hover.vjs-volume-vertical .vjs-volume-level,.video-js .vjs-volume-panel:active .vjs-volume-control.vjs-volume-vertical,.video-js .vjs-volume-panel:active .vjs-volume-control.vjs-volume-vertical .vjs-volume-bar,.video-js .vjs-volume-panel:active .vjs-volume-control.vjs-volume-vertical .vjs-volume-level,.video-js .vjs-volume-panel:focus .vjs-volume-control.vjs-volume-vertical,.video-js .vjs-volume-panel:focus .vjs-volume-control.vjs-volume-vertical .vjs-volume-bar,.video-js .vjs-volume-panel:focus .vjs-volume-control.vjs-volume-vertical .vjs-volume-level,.video-js .vjs-volume-panel:hover .vjs-volume-control.vjs-volume-vertical,.video-js .vjs-volume-panel:hover .vjs-volume-control.vjs-volume-vertical .vjs-volume-bar,.video-js .vjs-volume-panel:hover .vjs-volume-control.vjs-volume-vertical .vjs-volume-level{-ms-filter:\\"progid:DXImageTransform.Microsoft.Alpha(Opacity=100)\\"}.video-js .vjs-volume-panel.vjs-volume-panel-horizontal.vjs-slider-active,.video-js .vjs-volume-panel.vjs-volume-panel-horizontal:active,.video-js .vjs-volume-panel.vjs-volume-panel-horizontal:hover{width:9em;-webkit-transition:width .1s;-moz-transition:width .1s;-ms-transition:width .1s;-o-transition:width .1s;transition:width .1s}.video-js .vjs-volume-panel .vjs-volume-control.vjs-volume-vertical{height:8em;width:3em;left:-3.5em;-webkit-transition:visibility 1s,opacity 1s,height 1s 1s,width 1s 1s,left 1s 1s,top 1s 1s;-moz-transition:visibility 1s,opacity 1s,height 1s 1s,width 1s 1s,left 1s 1s,top 1s 1s;-ms-transition:visibility 1s,opacity 1s,height 1s 1s,width 1s 1s,left 1s 1s,top 1s 1s;-o-transition:visibility 1s,opacity 1s,height 1s 1s,width 1s 1s,left 1s 1s,top 1s 1s;transition:visibility 1s,opacity 1s,height 1s 1s,width 1s 1s,left 1s 1s,top 1s 1s}.video-js .vjs-volume-panel .vjs-volume-control.vjs-volume-horizontal{-webkit-transition:visibility 1s,opacity 1s,height 1s 1s,width 1s,left 1s 1s,top 1s 1s;-moz-transition:visibility 1s,opacity 1s,height 1s 1s,width 1s,left 1s 1s,top 1s 1s;-ms-transition:visibility 1s,opacity 1s,height 1s 1s,width 1s,left 1s 1s,top 1s 1s;-o-transition:visibility 1s,opacity 1s,height 1s 1s,width 1s,left 1s 1s,top 1s 1s;transition:visibility 1s,opacity 1s,height 1s 1s,width 1s,left 1s 1s,top 1s 1s}.video-js.vjs-no-flex .vjs-volume-panel .vjs-volume-control.vjs-volume-horizontal{width:5em;height:3em;visibility:visible;opacity:1;position:relative;-webkit-transition:none;-moz-transition:none;-ms-transition:none;-o-transition:none;transition:none}.video-js.vjs-no-flex .vjs-volume-control.vjs-volume-vertical,.video-js.vjs-no-flex .vjs-volume-panel .vjs-volume-control.vjs-volume-vertical{position:absolute;bottom:3em;left:.5em}.video-js .vjs-volume-panel{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.video-js .vjs-volume-bar{margin:1.35em .45em}.vjs-volume-bar.vjs-slider-horizontal{width:5em;height:.3em}.vjs-volume-bar.vjs-slider-vertical{width:.3em;height:5em;margin:1.35em auto}.video-js .vjs-volume-level{position:absolute;bottom:0;left:0;background-color:#fff}.video-js .vjs-volume-level:before{position:absolute;font-size:.9em}.vjs-slider-vertical .vjs-volume-level{width:.3em}.vjs-slider-vertical .vjs-volume-level:before{top:-.5em;left:-.3em}.vjs-slider-horizontal .vjs-volume-level{height:.3em}.vjs-slider-horizontal .vjs-volume-level:before{top:-.3em;right:-.5em}.video-js .vjs-volume-panel.vjs-volume-panel-vertical{width:4em}.vjs-volume-bar.vjs-slider-vertical .vjs-volume-level{height:100%}.vjs-volume-bar.vjs-slider-horizontal .vjs-volume-level{width:100%}.video-js .vjs-volume-vertical{width:3em;height:8em;bottom:8em;background-color:#2b333f;background-color:rgba(43,51,63,.7)}.video-js .vjs-volume-horizontal .vjs-menu{left:-2em}.vjs-poster{display:inline-block;background-repeat:no-repeat;background-position:50% 50%;background-size:contain;background-color:#000;cursor:pointer;margin:0;position:absolute;top:0;right:0;bottom:0;left:0;height:100%}.vjs-poster,.vjs-poster img{vertical-align:middle;padding:0}.vjs-poster img{display:block;margin:0 auto;max-height:100%;width:100%}.vjs-has-started .vjs-poster{display:none}.vjs-audio.vjs-has-started .vjs-poster{display:block}.vjs-using-native-controls .vjs-poster{display:none}.video-js .vjs-live-control{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-align:flex-start;-webkit-align-items:flex-start;-ms-flex-align:flex-start;align-items:flex-start;-webkit-box-flex:auto;-moz-box-flex:auto;-webkit-flex:auto;-ms-flex:auto;flex:auto;font-size:1em;line-height:3em}.vjs-no-flex .vjs-live-control{display:table-cell;width:auto;text-align:left}.video-js .vjs-time-control{-webkit-box-flex:none;-moz-box-flex:none;-webkit-flex:none;-ms-flex:none;flex:none;font-size:1em;line-height:3em;min-width:2em;width:auto;padding-left:1em;padding-right:1em}.video-js .vjs-current-time,.vjs-live .vjs-time-control,.vjs-no-flex .vjs-current-time{display:none}.vjs-no-flex .vjs-remaining-time.vjs-time-control.vjs-control{width:0!important;white-space:nowrap}.video-js .vjs-duration,.vjs-no-flex .vjs-duration{display:none}.vjs-time-divider{display:none;line-height:3em}.vjs-live .vjs-time-divider{display:none}.video-js .vjs-play-control .vjs-icon-placeholder{cursor:pointer;-webkit-box-flex:none;-moz-box-flex:none;-webkit-flex:none;-ms-flex:none;flex:none}.vjs-text-track-display{position:absolute;bottom:3em;left:0;right:0;top:0;pointer-events:none}.video-js.vjs-user-inactive.vjs-playing .vjs-text-track-display{bottom:1em}.video-js .vjs-text-track{font-size:1.4em;text-align:center;margin-bottom:.1em;background-color:#000;background-color:rgba(0,0,0,.5)}.vjs-subtitles{color:#fff}.vjs-captions{color:#fc6}.vjs-tt-cue{display:block}video::-webkit-media-text-track-display{-moz-transform:translateY(-3em);-ms-transform:translateY(-3em);-o-transform:translateY(-3em);-webkit-transform:translateY(-3em);transform:translateY(-3em)}.video-js.vjs-user-inactive.vjs-playing video::-webkit-media-text-track-display{-moz-transform:translateY(-1.5em);-ms-transform:translateY(-1.5em);-o-transform:translateY(-1.5em);-webkit-transform:translateY(-1.5em);transform:translateY(-1.5em)}.video-js .vjs-fullscreen-control{cursor:pointer;-webkit-box-flex:none;-moz-box-flex:none;-webkit-flex:none;-ms-flex:none;flex:none}.vjs-playback-rate .vjs-playback-rate-value,.vjs-playback-rate>.vjs-menu-button{position:absolute;top:0;left:0;width:100%;height:100%}.vjs-playback-rate .vjs-playback-rate-value{pointer-events:none;font-size:1.5em;line-height:2;text-align:center}.vjs-playback-rate .vjs-menu{width:4em;left:0}.vjs-error .vjs-error-display .vjs-modal-dialog-content{font-size:1.4em;text-align:center}.vjs-error .vjs-error-display:before{color:#fff;content:\\"X\\";font-family:Arial,Helvetica,sans-serif;font-size:4em;left:0;line-height:1;margin-top:-.5em;position:absolute;text-shadow:.05em .05em .1em #000;text-align:center;top:50%;vertical-align:middle;width:100%}.vjs-loading-spinner{display:none;position:absolute;top:50%;left:50%;margin:-25px 0 0 -25px;opacity:.85;text-align:left;border:6px solid rgba(43,51,63,.7);box-sizing:border-box;background-clip:padding-box;width:50px;height:50px;border-radius:25px;visibility:hidden}.vjs-seeking .vjs-loading-spinner,.vjs-waiting .vjs-loading-spinner{display:block;animation:0s linear .3s forwards vjs-spinner-show}.vjs-loading-spinner:after,.vjs-loading-spinner:before{content:\\"\\";position:absolute;margin:-6px;box-sizing:inherit;width:inherit;height:inherit;border-radius:inherit;opacity:1;border:inherit;border-color:transparent;border-top-color:#fff}.vjs-seeking .vjs-loading-spinner:after,.vjs-seeking .vjs-loading-spinner:before,.vjs-waiting .vjs-loading-spinner:after,.vjs-waiting .vjs-loading-spinner:before{-webkit-animation:vjs-spinner-spin 1.1s cubic-bezier(.6,.2,0,.8) infinite,vjs-spinner-fade 1.1s linear infinite;animation:vjs-spinner-spin 1.1s cubic-bezier(.6,.2,0,.8) infinite,vjs-spinner-fade 1.1s linear infinite}.vjs-seeking .vjs-loading-spinner:before,.vjs-waiting .vjs-loading-spinner:before{border-top-color:#fff}.vjs-seeking .vjs-loading-spinner:after,.vjs-waiting .vjs-loading-spinner:after{border-top-color:#fff;-webkit-animation-delay:.44s;animation-delay:.44s}@keyframes vjs-spinner-show{to{visibility:visible}}@-webkit-keyframes vjs-spinner-show{to{visibility:visible}}@keyframes vjs-spinner-spin{to{transform:rotate(1turn)}}@-webkit-keyframes vjs-spinner-spin{to{-webkit-transform:rotate(1turn)}}@keyframes vjs-spinner-fade{0%{border-top-color:#73859f}20%{border-top-color:#73859f}35%{border-top-color:#fff}60%{border-top-color:#73859f}to{border-top-color:#73859f}}@-webkit-keyframes vjs-spinner-fade{0%{border-top-color:#73859f}20%{border-top-color:#73859f}35%{border-top-color:#fff}60%{border-top-color:#73859f}to{border-top-color:#73859f}}.vjs-chapters-button .vjs-menu ul{width:24em}.video-js .vjs-subs-caps-button+.vjs-menu .vjs-captions-menu-item .vjs-menu-item-text .vjs-icon-placeholder{position:absolute}.video-js .vjs-subs-caps-button+.vjs-menu .vjs-captions-menu-item .vjs-menu-item-text .vjs-icon-placeholder:before{font-family:VideoJS;content:\\"\\\\F10D\\";font-size:1.5em;line-height:inherit}.video-js.vjs-layout-tiny:not(.vjs-fullscreen) .vjs-custom-control-spacer{-webkit-box-flex:auto;-moz-box-flex:auto;-webkit-flex:auto;-ms-flex:auto;flex:auto}.video-js.vjs-layout-tiny:not(.vjs-fullscreen).vjs-no-flex .vjs-custom-control-spacer{width:auto}.video-js.vjs-layout-small:not(.vjs-fullscreen) .vjs-captions-button,.video-js.vjs-layout-small:not(.vjs-fullscreen) .vjs-chapters-button,.video-js.vjs-layout-small:not(.vjs-fullscreen) .vjs-current-time,.video-js.vjs-layout-small:not(.vjs-fullscreen) .vjs-descriptions-button,.video-js.vjs-layout-small:not(.vjs-fullscreen) .vjs-duration,.video-js.vjs-layout-small:not(.vjs-fullscreen) .vjs-mute-control,.video-js.vjs-layout-small:not(.vjs-fullscreen) .vjs-playback-rate,.video-js.vjs-layout-small:not(.vjs-fullscreen) .vjs-remaining-time,.video-js.vjs-layout-small:not(.vjs-fullscreen) .vjs-subtitles-button .vjs-audio-button,.video-js.vjs-layout-small:not(.vjs-fullscreen) .vjs-time-divider,.video-js.vjs-layout-small:not(.vjs-fullscreen) .vjs-volume-control,.video-js.vjs-layout-tiny:not(.vjs-fullscreen) .vjs-audio-button,.video-js.vjs-layout-tiny:not(.vjs-fullscreen) .vjs-captions-button,.video-js.vjs-layout-tiny:not(.vjs-fullscreen) .vjs-chapters-button,.video-js.vjs-layout-tiny:not(.vjs-fullscreen) .vjs-current-time,.video-js.vjs-layout-tiny:not(.vjs-fullscreen) .vjs-descriptions-button,.video-js.vjs-layout-tiny:not(.vjs-fullscreen) .vjs-duration,.video-js.vjs-layout-tiny:not(.vjs-fullscreen) .vjs-mute-control,.video-js.vjs-layout-tiny:not(.vjs-fullscreen) .vjs-playback-rate,.video-js.vjs-layout-tiny:not(.vjs-fullscreen) .vjs-progress-control,.video-js.vjs-layout-tiny:not(.vjs-fullscreen) .vjs-remaining-time,.video-js.vjs-layout-tiny:not(.vjs-fullscreen) .vjs-subtitles-button,.video-js.vjs-layout-tiny:not(.vjs-fullscreen) .vjs-time-divider,.video-js.vjs-layout-tiny:not(.vjs-fullscreen) .vjs-volume-control,.video-js.vjs-layout-x-small:not(.vjs-fullscreen) .vjs-audio-button,.video-js.vjs-layout-x-small:not(.vjs-fullscreen) .vjs-captions-button,.video-js.vjs-layout-x-small:not(.vjs-fullscreen) .vjs-chapters-button,.video-js.vjs-layout-x-small:not(.vjs-fullscreen) .vjs-current-time,.video-js.vjs-layout-x-small:not(.vjs-fullscreen) .vjs-descriptions-button,.video-js.vjs-layout-x-small:not(.vjs-fullscreen) .vjs-duration,.video-js.vjs-layout-x-small:not(.vjs-fullscreen) .vjs-mute-control,.video-js.vjs-layout-x-small:not(.vjs-fullscreen) .vjs-playback-rate,.video-js.vjs-layout-x-small:not(.vjs-fullscreen) .vjs-remaining-time,.video-js.vjs-layout-x-small:not(.vjs-fullscreen) .vjs-subtitles-button,.video-js.vjs-layout-x-small:not(.vjs-fullscreen) .vjs-time-divider,.video-js.vjs-layout-x-small:not(.vjs-fullscreen) .vjs-volume-control{display:none}.vjs-modal-dialog.vjs-text-track-settings{background-color:#2b333f;background-color:rgba(43,51,63,.75);color:#fff;height:70%}.vjs-text-track-settings .vjs-modal-dialog-content{display:table}.vjs-text-track-settings .vjs-track-settings-colors,.vjs-text-track-settings .vjs-track-settings-controls,.vjs-text-track-settings .vjs-track-settings-font{display:table-cell}.vjs-text-track-settings .vjs-track-settings-controls{text-align:right;vertical-align:bottom}.vjs-text-track-settings fieldset{margin:5px;padding:3px;border:none}.vjs-text-track-settings fieldset span{display:inline-block;margin-left:5px}.vjs-text-track-settings legend{color:#fff;margin:0 0 5px}.vjs-text-track-settings .vjs-label{position:absolute;clip:rect(1px 1px 1px 1px);clip:rect(1px,1px,1px,1px);display:block;margin:0 0 5px;padding:0;border:0;height:1px;width:1px;overflow:hidden}.vjs-track-settings-controls button:active,.vjs-track-settings-controls button:focus{outline-style:solid;outline-width:medium;background-image:linear-gradient(0deg,#fff 88%,#73859f)}.vjs-track-settings-controls button:hover{color:rgba(43,51,63,.75)}.vjs-track-settings-controls button{background-color:#fff;background-image:linear-gradient(-180deg,#fff 88%,#73859f);color:#2b333f;cursor:pointer;border-radius:2px}.vjs-track-settings-controls .vjs-default-button{margin-right:1em}@media print{.video-js>:not(.vjs-tech):not(.vjs-poster){visibility:hidden}}@media \\\\0screen{.vjs-user-inactive.vjs-playing .vjs-control-bar :before{content:\\"\\"}}@media \\\\0screen{.vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar{visibility:hidden}}", ""]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvZGlzdC92aWRlby1qcy5jc3M/NjFlOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esc01BQXVNLGtCQUFrQixNQUFNLE9BQU8sV0FBVyxZQUFZLHFHQUFxRyxrQkFBa0IsV0FBVyxvQkFBb0Isd0VBQThFLFdBQVcsb0JBQW9CLG1DQUFtQyxjQUFjLGsvS0FBay9LLGNBQWMsMDNSQUEwM1IsZ0JBQWdCLGtCQUFrQiw2SEFBNkgsb0JBQW9CLGdCQUFnQixrQkFBa0IsMklBQTJJLG1CQUFtQixzQkFBc0Isb0JBQW9CLGdCQUFnQixrQkFBa0IsNkJBQTZCLG1CQUFtQiw4RUFBOEUsb0JBQW9CLGdCQUFnQixrQkFBa0IsNEZBQTRGLG1CQUFtQixrRkFBa0Ysb0JBQW9CLGdCQUFnQixrQkFBa0IsZ0dBQWdHLG1CQUFtQixpRkFBaUYsb0JBQW9CLGdCQUFnQixrQkFBa0IsK0ZBQStGLG1CQUFtQixpRkFBaUYsb0JBQW9CLGdCQUFnQixrQkFBa0IsK0ZBQStGLG1CQUFtQix3RUFBd0Usb0JBQW9CLGdCQUFnQixrQkFBa0Isc0ZBQXNGLG1CQUFtQixtRkFBbUYsb0JBQW9CLGdCQUFnQixrQkFBa0IsaUdBQWlHLG1CQUFtQixpR0FBaUcsb0JBQW9CLGdCQUFnQixrQkFBa0IsK0dBQStHLG1CQUFtQixpQkFBaUIsb0JBQW9CLGdCQUFnQixrQkFBa0Isd0JBQXdCLG1CQUFtQixrQkFBa0Isb0JBQW9CLGdCQUFnQixrQkFBa0IseUJBQXlCLG1CQUFtQiw0YUFBNGEsb0JBQW9CLGdCQUFnQixrQkFBa0IsNmRBQTZkLG1CQUFtQix5TUFBeU0sb0JBQW9CLGdCQUFnQixrQkFBa0IscU9BQXFPLG1CQUFtQix3RUFBd0Usb0JBQW9CLGdCQUFnQixrQkFBa0Isc0ZBQXNGLG1CQUFtQixnQkFBZ0Isb0JBQW9CLGdCQUFnQixrQkFBa0IsdUJBQXVCLG1CQUFtQixjQUFjLG9C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LG1CQUFtQjs7QUFFdHBpRCIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBlc2NhcGUgPSByZXF1aXJlKFwiLi4vLi4vY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qc1wiKTtcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIudmlkZW8tanMgLnZqcy1iaWctcGxheS1idXR0b24gLnZqcy1pY29uLXBsYWNlaG9sZGVyOmJlZm9yZSwudmlkZW8tanMgLnZqcy1tb2RhbC1kaWFsb2csLnZqcy1idXR0b24+LnZqcy1pY29uLXBsYWNlaG9sZGVyOmJlZm9yZSwudmpzLW1vZGFsLWRpYWxvZyAudmpzLW1vZGFsLWRpYWxvZy1jb250ZW50e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlfS52aWRlby1qcyAudmpzLWJpZy1wbGF5LWJ1dHRvbiAudmpzLWljb24tcGxhY2Vob2xkZXI6YmVmb3JlLC52anMtYnV0dG9uPi52anMtaWNvbi1wbGFjZWhvbGRlcjpiZWZvcmV7dGV4dC1hbGlnbjpjZW50ZXJ9QGZvbnQtZmFjZXtmb250LWZhbWlseTpWaWRlb0pTO3NyYzp1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4vZm9udC9WaWRlb0pTLmVvdFwiKSkgKyBcIj8jaWVmaXgpIGZvcm1hdChcXFwiZW90XFxcIil9QGZvbnQtZmFjZXtmb250LWZhbWlseTpWaWRlb0pTO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmY7Y2hhcnNldD11dGYtODtiYXNlNjQsZDA5R1JnQUJBQUFBQUJCSUFBc0FBQUFBR29RQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJIVTFWQ0FBQUJDQUFBQURzQUFBQlVJSXNsZWs5VEx6SUFBQUZFQUFBQVBnQUFBRlpSaVYzUlkyMWhjQUFBQVlRQUFBRFFBQUFESWpuMDk4Wm5iSGxtQUFBQ1ZBQUFDdjRBQUJFSUF3blN3MmhsWVdRQUFBMVVBQUFBS3dBQUFEWVN5MmhMYUdobFlRQUFEWUFBQUFBYkFBQUFKQTREQnlGb2JYUjRBQUFObkFBQUFBOEFBQUNFNEFBQUFHeHZZMkVBQUEyc0FBQUFSQUFBQUVROU5FSEdiV0Y0Y0FBQURmQUFBQUFmQUFBQUlBRXlBSUZ1WVcxbEFBQU9FQUFBQVNVQUFBSUsxY2Yxb0hCdmMzUUFBQTg0QUFBQkR3QUFBWjVBQWwvMGVKeGpZR1JnWU9CaU1HQ3dZMkJ5Y2ZNSlllRExTU3pKWTVCaVlHR0FBSkE4TXBzeEp6TTlrWUVEeGdQS3NZQnBEaUJtZzRnQ0FDWTdCVWdBZUp4allHUTd4VGlCZ1pXQmdhV1E1UmtEQThNdkNNMGN3eERPZUk2QmdZbUJsWmtCS3doSWMwMWhjUGpJK0ZHQkhjUmR5QTRSWmdRUkFDNEhDd0VBQUhpYzdkRnByc0lnQUVYaGc4VTYxWG1lV2NCYjFGdVFQNHc3WlFYSzVib01tM3ljbEZEU0FOQUhtdUt2aUJCZUJQUTh5bXlvOHczak9oLzVyMnVpNW5ONnY4c1lOSmIzV01kZVdSdkxqaTBEaG96S2R4TTZwc3lZczJESmlqVWJ0dXpZYytESWlUTVhydHk0azhvR0xiK24weENlMzdla003WjY2ajFEYlV5M2w2UHBIbkxmZExPNU5kU0JvUTROZFdTb1k5T041NG1oZHFhL3kxTkRuUm5xM0ZBWGhybzAxSldocmcxMVk2aGJROTBaNnQ1UUQ0WjZOTlNUb1o0TjlXS29WME85R2VyZFVKT1JQcWtoVGQ1NG5KMVlEWEJVMVJWKzU3Ni9KQnMyYlBZUGtyRFp0NXZzSnJ2NTNWL0k1bWNsaEdEQ1R3Z0dCUVFTVEVqaTRoQ2tZSUFHZDRUR0lXRkFoVjBSUVRwV21RcDF4djZoQTRPVE9sTnIyekZBTmJIVVlicTJPdE5DcFZpUnFzaytlKzdiVFFBaHp0aTh2UGZ1UGZmY2M4ODk1OXp6bmJjTU1QakhEL0tEREdFWTBBQnBZWDM4NE5obG9tSVlsbzRKSVNHRVk5bU1oMkZTaWRZaXFrRVVwaHROWURTWS9kWGc5MDIzbDREZHhscVVsMGNodVpSaG5jSktyc0NRSEl3Y0d1d2ZuaE1JekJudUg0U3ltKzFEMnphR2poZVhsaFlmRDIzOHo4MG1LWU1tdko1WGVPVHpkOHo5ZXVqYk14Sk5odTRDOXhQRS9iQ01pRHVTTklXZ2tUUXdCRTU1aExTQUU3WndockhMbkFIWk9HVi9rbUJHVGlOalp4ekk3N0hiN0hxano2OFRqVDZ2aCs1SlQvY0NJa3FTMEQ2Q3FQZjVqWDRRamR4NWo2dmxEZlpNNGFaRmRiVlhJeHRPbEphUC9Xb3R0TW5INkNKUTNiVGl1ZTNQclkyM0hqbkNodHVhbXh3dnZ6Rmp4a1ByTmozejB0RzlUNTYxSERZZjZPZ21SV3ZsWTNKUUhvUWI4bHRWMllldDdZZldjdEVqUjFBdHhTL2NTWDZVNGFsZjZOSkVCUTdZS2c5d3JYUUtkMEllWkNiMnV4NzVVaGgxVW4rTnorOUxUT0U3UEs3NzduTjV4cWRUbmVUQmhDYng0NDZtWnJoblVrckN6MlloQTlkU014YUcwU1ltVDhoaTlaUHUxRTk0UEpZUVNINkxSbWh4ZWM3UTdaZVhudGdRdVZwYmgrYTRxV05zY2tWeVRkbjBQN283RHBnUFc4NCt1UmNxMEJJVGZsQmlrR2RVakFaOXdZQlZJM210ck52cjlrcGcxVXNhSzZ0MzY5MGFvb3JDMWxnMEdwTUgySEFNdGtaanNTaTVJZzlFU1Zvc09oN0dRZkxqS05MdktwTUtrTFNLTkZBa2E3MTBHZGdTaThvRE1Tb05ocWprS0JYVGduM3N3dGF4eXpHa1V6SXphZTlSdExkV2tTbFoxS0RYNkV6Z2xselY0TlY0U29ERlNPR0Q0K0hDZVFVRjh3clo1SHM4ekliNUVhVnh5OERZRlRiTUNKUG5MSVdaeHVnWkUyTmxpdkMwZ2MxcUVRVVI4akVLZ1pjQVhlSDE4QmlDZ2w1bmxIaDBDcmpCNEhiNWZYNGdiMEo3YzlQdUhWc2Zna3gybi92VFkvSlY4a244UEd4ZjdmYU9aOHFYOEpWQnl1SWY0d2hrOXNxWGxpMmh2UEpWOWhycDBoWTdsOHIyeDM3eWRhVnNiNHh2WHYvNDd2Mk5qZkNsOG01b1JESmNsRk1vRTF5azBVaDFUZTQvbThsRlhlOXFCWkQwRWtoZWljZWJYdnpJMlBMQ3VvS0N1a0x1aFBJZUt3YUhQRW91eHcza01xYUlVWERRMXAwbWlwK015Q09SU0NRYW9Vc25ZMVZaMzhuVVRyRzIxV3ZWbzRmMU9zRUpGaHZTZkFGd0dmVDhWSFJNZUFWVXB3TE9vTHpqVC9SRUlqM08zRmh1VVJFK25FUkYrMHBUSWQ1Rnl4djVzZndHeWc0TytteTR2WnYwc1ptN29lUWxGWk9SaUIrdEcwTXdlVk5yYWVpdGw3eXhpUElIVGs0L2RpVnhzOTRvNWxFWWlzaEIyaUF0a2NoRW5zQWN0b0VweDQ0Rm84WG5zUU1hQTIyQmxxQzIwUm1oQkt6WW9qWnlZYXhnK0pnZ01jNEhIWTJtK0w5RWtXU1lsamlyT2lzck83ZDNWb3J4enlaNlZjNGxKcUlUQXUxYjJ3T0JkckxFbEFQK2JGYzJlR2FaRlZia21Ka3R2NXVUNkpsejVEL01uQkZvcjZpZy9KUG5SVmlCc1YzTE5LR0dxQjFDaEowdGdReXdsVkxGSkl1UWdURnR0d2tpS3hoeVFkQVpNZE1ZdFNhb0Fld3FmdlhWWVBBYkRUNi8xbWV6ODVZUzhGU0R5d1E2TmZBbmVmNkZORUdNaWxucHB5dm41ckI2dFR5cTFwT2NlUlducDJXSkVaRlhIZVg1b3lvZW0xblRUZ2RxYzRoZURZN2JPZUt6NjN2bnorL2RSeCtzMzFIdDJKR2FuUTVzZWlyZldKTDl0am96VS8xMlRuRWpuNW91eDlPelUzY2tHYkJ6QndOT3lrNjlKeWtLSDBuLzBMTTlBNzJ0dXdNM3pRcElSdTRBeGlUb3NlRXBnUE9tYlJPeUZlOS9YMnllVXZvVXNDeUV2amNnczdmcFdQMy9hS2xGTjArNkhGVWU2RDlIRnovWFB3QmxOOXRUcU55WmpGSjhVTzJSVVQ1L2g0Q3B0Q2N0RXllaXNuT3lYakFMRXA3ZFhLYVFLZjZPN0lNbkdqTk5BQ1JNTHhxZFlKWDhlTUx2bW1kNjhEK2F5Qkx5S0tZWndZeER0L0dOaHpFVERKMDVReGx5aTNwaTMvWjkzbmRZVlN1bWdqMFYvS2tJRmxPNisxSzNmRjIrM2cwcStZdHVTSWYwYnZtTHFWMDlubm9iSTZod2NqSVA4YVBDS2F5anNGNUpCWTNMYUtBZVJMU3lZQjFoODFvVHdlOVNsUE1rWEI3RzBtZkw5cTcxZ2FxcXdQcXU2N1FSS1MxK09iVHgrc2JReTlRVjJPUUhFU2NHa2RGQmVUN3Y3cWlzcXFyczZONTJpNzgvUis2UzBxUU9OVmoyNmFnT1Zvc3dDeVFXSVY1RDg2dkg1M2J4TlVlWFYwSytYWmFIdi9ubS9Lc0hoT3Z5bHdzV25KWC9IRThsLzRXQ3Y1eCtsNW4wOHo2VVU4YlVNYTNNQnBTbU03RjYzQXhudGRDOWVCQ0tFWlc5SHIrQUJOcXR4Z0FRclNiTXRtclc3bEtRdW9TZ0JoU3JUYXpXVlUyUUFLV1k4d2lpdWhxRm1RZ1dKQmdvWGl1V0ltNDJON2hxWmJCc2dYejUyTzVQNXVTdmFOZ0ZHbk91dnNSdzhJOExhaGE5MXdNdkR1eHFXRmhlTjcvOEdWdFRsdGRTODNEUXNYUm1xYzVadGNKWEVWcmxWMmRvVFdrNStZdW5tNzFkRzVmNTVtL3FZME1qSTkzdnY5L05mcHhYVjlzVVhyeHkyZmJOeTFvcjY1Y09sRFJuT29LRmVlWGNidzQySC9iTkRUNVFzM2ZsZ3MzMWdXQzFsRDFuZlVWL1g3TmRDblNVZEhZMmU4YWZ6ZktzcVo1WmxqZkRxakxPbWszVWViTlhCK2FIQXJQWURScysvSEREeGVUNURpUCtzRmc3T3BSYVZRTUdCVjg5UHBlQmRqMjJoQ0UwVXViMFVxd0xyTldzRzBjdXlhZGdMWFRlUjVyYk80KzNjL3ZsMTVjdXIyblJxK1RYQ1FEY1MzU08rczZhaytlNS9lTVMrMWR3M2J0dTNZRzJ0dkZMOFhkSVp2ZGpkVzZUTy80QjdJZHJaV1ZQbWN0bTUvNTlBZ3NQSXRUU2JDaUlCcjJPcUlHem11MjBTTUtBUzd5cXdHQlVmR2ZnakRZbExMRGVGMFNmY0xCMkxTeDhmbFQrMDgva3p6NnlPajk2cmZ0NHJwVGpkUFFjbUxkNDd1S2liYkRxN1pTei9YdGJIMm5ONzE3TmQ2MnJVK2M4SWNldnZ2N0kwOXdBNld2alZjYWZiK0ZzYk5HK1pRODBSbjZaWnN2clA3dGVQMmR6VGRvRVR2TmhqQ21zcjhGSUQyc0o2OVZZdmRVY3hrNEF6WVJsS2NhRTM4ZVhOUmxmVzlIMWFzOWk2YWNMSHAxWHB1TkI1SzdESXZrWDA4eTFaWXZoM0tmV2FpQ3pIK3p0clNEbUQ3THVYNzN4L21KZWxCOFlqMzl0OG5oTlFKSjJDQXRocG9GR0xzR2d0U09DSm9vQ0dvYUpBTVRqU1dIVlowOFlBYTFGZzlsUEk1VTZET3NHVmpEYXNKZVpaK1l5aGZDd2ZPekN4bEJBNjlNOVhMWHR6YTdIL3Jhdis5VGpxNXhOaTB3cEtRSVJOTzRMcnp6N3lwNVFWWU02SmQvb2MxVXZuL21RaGh1V2g2RU5Yb1MyWVRaOFFUNDJiRjVkLzU1OXpwNXIwVWZmMlZuUjJ0ZGYyL1dDT2QyY08wTXc2cXBXUG52eHBWMG5ydDVmWmQyeUl0YzE5OUdXZTh2bE5mTkRxK0NILzd5QUFuQjlobjdUNFFPNGMxZzlTY3hzWmdtem50bkUvSURHbmR0SE13NjlsRndvQ25Zc01HeCtyQnA4SlNCcWRMekJyOVFSUHEvUGJoV01XRnRRWnAxeGd1eS9oYXczVEVIbTNUV0FueEZXUVFXZ3Q3TTVPVjBsQ3oxVlJZdWNwV2xpeTd6NlpkNHVyd1BJeWVaUXFsaTJMZ2c3c3pKVjA5UHlzQVRiT1F0WUlyQjJZemJrSllrR2dKMG00QWpQVWFwMXB2WXUxSzlxcjk3ejBZbDNwMzMyYjJMWUI3OG5jWUlsUmthdS84R09iU3NPbFphbmNBQ0U1ZDVpbHkrYzIrN2g1WWo0bHFoVm1YWEIraVhMZnZkcVNncWZLdFF2ZkhEVjBPbnZRUjFxaHc0MlhTL3ZrdnNoL2hYY3JERlAwYStTSk5Jb21FZkQxbnNyWUdPKzFiZ1RPSmhNOEh2NmVrKzd2VmdseHVTUndvS24xN1M5MzdibTZZSkNlU1NHME9wMW4rN3RFMzd0Y1ovcDdkc1R2NEVVckdwRGJXdWVLaWdzTEhocVRWc29FaitKVTBrYVNqbmo5dHo4L2dyeVFXd0o5QmNKWEJDLzdzbU8rSS9JRlVSSmV0RlByZHQ1V2NvTDZEYkVKYXlnSThDVEhmUVRqZjQwb2ZEK0R3YWxUcUlBQUhpY1kyQmtZR0FBNGpDNXQyL2orVzIrTW5Dek00REF0VEMrNWNnME95TlluSU9CQ1VRQkFBY2VCOTBBZUp4allHUmdZR2NBQVJENS96ODdJd01qQXlwUUJBQXRnd0k0QUhpY1kyQmdZR0FmWUF3QU9rUUE0UUFBQUFBQUFBNEFhQUIrQU13QTRBRUNBVUlCYkFHWUFjSUNHQUpZQXJRQzRBTXdBN0FEM2dRd0JKWUUzQVVrQldZRmlnWWdCbVlHdEFicUIxZ0lFZ2hZQ0c0SWhIaWNZMkJrWUdCUVpDaGxZR2NBQVNZZzVnSkNCb2IvWUQ0REFCZlRBYlFBZUp4ZGtFMXFnMEFZaGw4VGs5QUlvVkRhVlNtemFoY0Y4N1BNQVJMSU1vRkFsMFpIWTFCSGRCSklUOUFUOUFROVJROVFlcXkreXRlTk16RHpmTSs4OHcwSzRCWS9jTkFNQjZOMmJVYVBQQkx1a3liQ0x2bGVlQUFQajhKRCtoZmhNVjdoQzN1NHd4czdPTzROelFTWmNJLzhMdHduZndpNzVFL2hBUjd3SlR5ay94WWVZNDlmWVEvUHp0TStqYlRaN0xZNk9XZEJKZFgvcHFzNk5ZV2Erek14YTEzb0tyQTZVb2VycWkvSnd0cFl4WlhKMWNvVVZtZVpVV1ZsVGpxMC90SGFjam1keHVMOTBPUjhPMFVFRFlNTmR0aVNFcHo1WFFHcXpsbTMwa3pVZEFZRkZPYjhSN05PWmswcTJsd0F5ejFpN29BcjF4b1h2ck9ndFloWng4d1k1S1JWMjY5Slo1eUdwbXpQVGpRaHZZOWplNnZFRWxQT3VKUDNtV0tuUDVNM1YrWUFBQUI0bkcyUHlYTENNQkJFM1lDTkRXRUwyZmZrN284UzhvQ25rQ1ZIQzVDL2p6QlFsVVA2SUhWUHpZeWVrbDV5MGlMNVg1L29vWThCVW1RWUlrZUJFY2E0d2dSVHpEREhBdGRZNGdhM3VNTTlIdkNJSnp6akJhOTR3enMrOEltdlpOQXE4VE0rSHFWa0t4V2xyUWlPeGp1alFrTmxFenlOemw2Wi9jVTJYRjA2YXQ3VTgzVlF5a2xMcEV2U251enNiK0hBUG5QZlFWZ2F1cGExSmx1NHNQTHNGYmxjaXRhejBkSFUwWkYxcWF0aloxK2FUWFlDbXA2dTBnU3ZXTlB5SEx0RlorWmVYV1ZTYUVrcXMzVDhTNzRXa2xiR2JOTk5xNExMNCtDV0t0WkR2MmNmWDhsOGFGYktGaEVuSm5KK0lVTEZwcXdvUW5OSGxIYVZRdFBCbCt5cG1iU1dkbXlDNjFLUy9BS1pDM1krQUE9PSkgZm9ybWF0KFxcXCJ3b2ZmXFxcIiksdXJsKGRhdGE6YXBwbGljYXRpb24veC1mb250LXR0ZjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxBQUVBQUFBTEFJQUFBd0F3UjFOVlFpQ0xKWG9BQUFFNEFBQUFWRTlUTHpKUmlWM1JBQUFCakFBQUFGWmpiV0Z3T2ZUM3hnQUFBbWdBQUFNaVoyeDVaZ01KMHNNQUFBWFFBQUFSQ0dobFlXUVN5MmhMQUFBQTRBQUFBRFpvYUdWaERnTUhJUUFBQUx3QUFBQWthRzEwZU9BQUFBQUFBQUhrQUFBQWhHeHZZMkU5TkVIR0FBQUZqQUFBQUVSdFlYaHdBVElBZ1FBQUFSZ0FBQUFnYm1GdFpkWEg5YUFBQUJiWUFBQUNDbkJ2YzNSQUFsLzBBQUFZNUFBQUFaNEFBUUFBQndBQUFBQUFCd0FBQVAvL0J3RUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFDRUFBUUFBQUFFQUFGWWZUd2xmRHp6MUFBc0hBQUFBQUFEV1ZnNm5BQUFBQU5aV0RxY0FBQUFBQndFSEFBQUFBQWdBQWdBQUFBQUFBQUFCQUFBQUlRQjFBQWNBQUFBQUFBSUFBQUFLQUFvQUFBRC9BQUFBQUFBQUFBRUFBQUFLQURBQVBnQUNSRVpNVkFBT2JHRjBiZ0FhQUFRQUFBQUFBQUFBQVFBQUFBUUFBQUFBQUFBQUFRQUFBQUZzYVdkaEFBZ0FBQUFCQUFBQUFRQUVBQVFBQUFBQkFBZ0FBUUFHQUFBQUFRQUFBQUVHeWdHUUFBVUFBQVJ4Qk9ZQUFBRDZCSEVFNWdBQUExd0FWd0hPQUFBQ0FBVURBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZCbVJXUUFRUEVCOFNBSEFBQUFBS0VIQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFIQUFBQUJ3QUFBQWNBQUFBSEFBQUFCd0FBQUFjQUFBQUhBQUFBQndBQUFBY0FBQUFIQUFBQUJ3QUFBQWNBQUFBSEFBQUFCd0FBQUFjQUFBQUhBQUFBQndBQUFBY0FBQUFIQUFBQUJ3QUFBQWNBQUFBSEFBQUFCd0FBQUFjQUFBQUhBQUFBQndBQUFBY0FBQUFIQUFBQUJ3QUFBQWNBQUFBSEFBQUFCd0FBQUFBQUFBVUFBQUFEQUFBQUxBQUFBQVFBQUFHU0FBRUFBQUFBQUl3QUF3QUJBQUFBTEFBREFBb0FBQUdTQUFRQVlBQUFBQVFBQkFBQkFBRHhJUC8vQUFEeEFmLy9BQUFBQVFBRUFBQUFBUUFDQUFNQUJBQUZBQVlBQndBSUFBa0FDZ0FMQUF3QURRQU9BQThBRUFBUkFCSUFFd0FVQUJVQUZnQVhBQmdBR1FBYUFCc0FIQUFkQUI0QUh3QWdBQUFCQmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNQUFBQUFBR1FBQUFBQUFBQUFDQUFBUEVCQUFEeEFRQUFBQUVBQVBFQ0FBRHhBZ0FBQUFJQUFQRURBQUR4QXdBQUFBTUFBUEVFQUFEeEJBQUFBQVFBQVBFRkFBRHhCUUFBQUFVQUFQRUdBQUR4QmdBQUFBWUFBUEVIQUFEeEJ3QUFBQWNBQVBFSUFBRHhDQUFBQUFnQUFQRUpBQUR4Q1FBQUFBa0FBUEVLQUFEeENnQUFBQW9BQVBFTEFBRHhDd0FBQUFzQUFQRU1BQUR4REFBQUFBd0FBUEVOQUFEeERRQUFBQTBBQVBFT0FBRHhEZ0FBQUE0QUFQRVBBQUR4RHdBQUFBOEFBUEVRQUFEeEVBQUFBQkFBQVBFUkFBRHhFUUFBQUJFQUFQRVNBQUR4RWdBQUFCSUFBUEVUQUFEeEV3QUFBQk1BQVBFVUFBRHhGQUFBQUJRQUFQRVZBQUR4RlFBQUFCVUFBUEVXQUFEeEZnQUFBQllBQVBFWEFBRHhGd0FBQUJjQUFQRVlBQUR4R0FBQUFCZ0FBUEVaQUFEeEdRQUFBQmtBQVBFYUFBRHhHZ0FBQUJvQUFQRWJBQUR4R3dBQUFCc0FBUEVjQUFEeEhBQUFBQndBQVBFZEFBRHhIUUFBQUIwQUFQRWVBQUR4SGdBQUFCNEFBUEVmQUFEeEh3QUFBQjhBQVBFZ0FBRHhJQUFBQUNBQUFBQUFBQUFBRGdCb0FINEF6QURnQVFJQlFnRnNBWmdCd2dJWUFsZ0N0QUxnQXpBRHNBUGVCREFFbGdUY0JTUUZaZ1dLQmlBR1pnYTBCdW9IV0FnU0NGZ0liZ2lFQUFFQUFBQUFCWXNGaXdBQ0FBQUJFUUVDVlFNMkJZdjc2Z0lMQUFBREFBQUFBQVpyQm1zQUFnQWJBRFFBQUFrQ0V5SUhEZ0VIQmhBWEhnRVhGaUEzUGdFM05oQW5MZ0VuSmdNaUp5NEJKeVkwTno0Qk56WXlGeDRCRnhZVUJ3NEJCd1lDNndIQS9rQ1ZtSXVHemprN096bk9ob3NCTUl1R3pqazdPem5PaG91WWVXOXJwaTB2THkybWEyL3liMnVtTFM4dkxhWnJid0l3QVZBQlVBR2JPem5PaG92KzBJdUd6ams3T3puT2hvc0JNSXVHemprNytzQXZMYVpyYi9KdmE2WXRMeTh0cG10djhtOXJwaTB2QUFBQ0FBQUFBQVZBQllzQUF3QUhBQUFCSVJFcEFSRWhFUUhBQVN2KzFRSlZBU3NCZFFRVysrb0VGZ0FBQUFRQUFBQUFCaUVHSUFBSEFCY0FKd0FxQUFBQk5DY21KeFVYTmpjVUJ4YzJOVFFuTGdFbkZSNEJGeFlCQndFaEVTRUJFUUVHQnhVMk54YzNBUWNYQk5BME1sVzRBN3NwY1UxRlErNlZiS292TWZ1MFh3RmgvcDhCS3dGMUFUNVFXWmw2bVYvOVlKeWNBNEJoVWxBcXBiZ1lHR05pY1pLa25ZeUh2U0thSUpObGFRSXNYLzZmL2tEK2l3SDIvc0k5RzVvalpKaGZCSmFjbkFBQUFBRUFBQUFBQktzRjFnQUZBQUFCRVNFQkVRRUNDd0VxQVhiK2lnUmcva0QraXdTcS9vc0FBQUFDQUFBQUFBVm1CZFlBQ0FBT0FBQUJOQ2NtSnhFMk56WUJFU0VCRVFFRlpUUXlWRlF5TlB3UUFTc0JkZjZMQTRCaFVsQXEvYVlxVUZJQlFmNUEvb3NFcXY2TEFBTUFBQUFBQmlBR0R3QUZBQTRBSWdBQUV4RWhBUkVCQlRRbkppY1JOamMyQXhVZUFSY1dGQWNPQVFjVlBnRTNOaEFuTGdIZ0FTc0JkZjZMQXNVME1sVlZNalM3Yktvdk1URXZxbXlWN2tORlJVUHVCR0QrUVA2TEJLcitpK0JoVWxBcS9hWXFVRklDOEpvZ2syVnA2R2xsa3lDYUlyMkhqQUU2akllOUFBQUFCQUFBQUFBRml3V0xBQVVBQ3dBUkFCY0FBQUVqRVNFMUl3TXpOVE0xSVFFakZTRVJJd01WTXhVekVRSUxsZ0YyNEphVzRQNktBNERnQVhhVzRPQ1dBdXYraXBZQ0N1Q1cvSUNXQVhZQ29KYmdBWFlBQkFBQUFBQUZpd1dMQUFVQUN3QVJBQmNBQUFFekZUTVJJUk1qRlNFUkl3RXpOVE0xSVJNMUl4RWhOUUYxNEpiK2l1RGdBWGFXQWNDVzRQNktscFlCZGdKVjRBRjJBY0NXQVhiNzZ1Q1dBY0RnL29xV0FBQUFBQUlBQUFBQUJkWUYxZ0FUQUJjQUFBRWhJZzRCRlJFVUhnRXpJVEkrQVRVUk5DNEJBeUVSSVFWQS9JQXBSQ2dvUkNrRGdDbEVLQ2hFS2Z5QUE0QUYxU2hFS2Z5QUtVUW9LRVFwQTRBcFJDajc2d09BQUFZQUFBQUFCbXNHYXdBSUFBMEFGUUFlQUNNQUxBQUFDUUVtSXlJSEJnY0JKUzRCSndFRklRRTJOelkxTkFVQkJnY0dGUlFYSVFVZUFSY0JNd0VXTXpJM05qY0JBcjRCWkZKUWhIdDJZd0VTQTQ0ejdaLys3Z0xsL2RBQmVsMHpOZndTL3QxZE16VVBBakQ5NURQdG53RVNlUDdkVTArRWUzWmovdTREOEFKb0V5MHJVZjRuZDZQNlBQNG5TLzF6Wm4rRWowdExBZmhtZjRTUFMwcExvL284QWRuK0NCTXRLMUVCMlFBRkFBQUFBQVpyQmRZQUV3QVhBQnNBSHdBakFBQUJJU0lPQVJVUkZCNEJNeUV5UGdFMUVUUXVBUUVoRlNFQklUVWhCU0UxSVRVaE5TRUYxZnRXS1VVb0tFVXBCS29wUlNnb1Jmc3RBU3IrMWdMcS9SWUM2Z0hBL3RZQkt2MFdBdW9GMVNoRUtmeUFLVVFvS0VRcEE0QXBSQ2o5cTVYKzFaV1ZsWmFWQUFBQUFBTUFBQUFBQmlBRjFnQVRBQ3NBUXdBQUFTRWlEZ0VWRVJRZUFUTWhNajRCTlJFMExnRUJJelVqRlRNMU14VVVCaXNCSWlZMUVUUTJPd0V5RmhVRkl6VWpGVE0xTXhVVUJpc0JJaVkxRVRRMk93RXlGaFVGaS92cUtFVW9LRVVvQkJZb1JTZ29SZjJDY0pXVmNDc2Y0QjhzTEIvZ0h5c0NDM0NWbFhBc0grQWZLeXNmNEI4c0JkVW9SQ244Z0NsRUtDaEVLUU9BS1VRby9mWWw0Q1ZLSHl3c0h3RXFIeXdzSDBvbDRDVktIeXdzSHdFcUh5d3NId0FHQUFBQUFBWWdCUFlBQXdBSEFBc0FEd0FUQUJjQUFCTXpOU01STXpVakVUTTFJd0VoTlNFUklUVWhFUlVoTmVDVmxaV1ZsWlVCS3dRVisrc0VGZnZyQkJVRE5aYitRSlVCd0pYK1FKYitRSlVDVlpXVkFBQUFBUUFBQUFBR0lRWnNBREVBQUFFaUJnY0JOalFuQVI0Qk16SStBVFF1QVNJT0FSVVVGd0V1QVNNaURnRVVIZ0V6TWpZM0FRWVZGQjRCTWo0Qk5DNEJCVUFxU3g3OTdBY0hBZzhlVHlzOVp6dzhaM3BuUEFmOThSNVBLejFuUER4blBTdFBIZ0lVQmp0a2RtUTdPMlFDVHg0Y0FUY2JNaHNCTkIwZ1BHZDZaenc4WnowWkcvN05IQ0E4WjNwblBDQWMvc29aR0R0a09qcGtkbVE3QUFBQUFBSUFBQUFBQmxrR2F3QkRBRkFBQUFFMk5DYzNQZ0VuQXk0QkR3RW1Md0V1QVNNaElnWVBBUVlISnlZR0J3TUdGaDhCQmhRWEJ3NEJGeE1lQVQ4QkZoOEJIZ0V6SVRJMlB3RTJOeGNXTmpjVE5pWW5CU0l1QVRRK0FUSWVBUlFPQVFXckJRV2VDZ1lIbGdjYURMbzhRaHdERlE3KzFnNFZBaHhFT3JvTkdnZVZCd1VMblFVRm5Rc0ZCNVVIR2cyNk8wTWNBaFVPQVNvT0ZRSWNSRHE2RFJvSGxRY0ZDLzA0UjNoR1JuaU9lRVpHZUFNM0tqNHFld2tiREFFRERBa0ZTeTRieGc0U0VnN0dIQzFMQlFrTS92ME1Hd2w3S2o0cWV3a2JEUDc5REFrRlN5NGJ4ZzRTRWc3R0hDMUxCUWtNQVFNTUd3bEJSbmlPZUVaR2VJNTRSZ0FCQUFBQUFBWnJCbXNBR0FBQUV4UVhIZ0VYRmlBM1BnRTNOaEFuTGdFbkppQUhEZ0VIQnBVN09jNkdpd0V3aTRiT09UczdPYzZHaS83UWk0Yk9PVHNEZ0ppTGhzNDVPenM1em9hTEFUQ0xoczQ1T3pzNXpvYUxBQUFBQUFJQUFBQUFCbXNHYXdBWUFERUFBQUVpQnc0QkJ3WVFGeDRCRnhZZ056NEJOellRSnk0Qkp5WURJaWN1QVNjbU5EYytBVGMyTWhjZUFSY1dGQWNPQVFjR0E0Q1lpNGJPT1RzN09jNkdpd0V3aTRiT09UczdPYzZHaTVoNWIydW1MUzh2TGFacmIvSnZhNll0THk4dHBtdHZCbXM3T2M2R2kvN1FpNGJPT1RzN09jNkdpd0V3aTRiT09UdjZ3Qzh0cG10djhtOXJwaTB2THkybWEyL3liMnVtTFM4QUF3QUFBQUFHYXdackFCZ0FNUUErQUFBQklnY09BUWNHRUJjZUFSY1dJRGMrQVRjMkVDY3VBU2NtQXlJbkxnRW5KalEzUGdFM05qSVhIZ0VYRmhRSERnRUhCaE1VRGdFaUxnRTBQZ0V5SGdFRGdKaUtoczg1T3pzNXo0YUtBVENLaHM4NU96czV6NGFLbUhsdmE2WXRMeTh0cG10djhtOXJwaTB2THkybWEyOW5QR2Q2Wnp3OFozcG5QQVpyT3puUGhvciswSXFHenprN096blBob29CTUlxR3p6azcrc0F2TGFacmIvSnZhNll0THk4dHBtdHY4bTlycGkwdkFsVTlaenc4WjNwblBEeG5BQUFBQkFBQUFBQUdJQVloQUJNQUh3QXBBQzBBQUFFaElnNEJGUkVVSGdFeklUSStBVFVSTkM0QkFTTTFJeFVqRVRNVk16VTdBU0V5RmhVUkZBWWpJVGN6TlNNRmkvdnFLRVVvS0VVb0JCWW9SU2dvUmYyQ2NKVndjSlZ3bGdFcUh5d3NILzdXY0pXVkJpQW9SU2o3NmloRktDaEZLQVFXS0VVby9JQ1ZsUUhBdTdzc0gvN1dIeXh3NEFBQUFBQUNBQUFBQUFackJtc0FHQUFrQUFBQklnY09BUWNHRUJjZUFSY1dJRGMrQVRjMkVDY3VBU2NtRXdjSkFTY0pBVGNKQVJjQkE0Q1lpNGJPT1RzN09jNkdpd0V3aTRiT09UczdPYzZHaTkxcC92VCs5R2tCQy83MWFRRU1BUXhwL3ZVR2F6czV6b2FML3RDTGhzNDVPenM1em9hTEFUQ0xoczQ1Ty93SmFRRUwvdlZwQVF3QkRHbis5UUVMYWY3MEFBQUJBQUFBQUFYV0JyWUFKd0FBQVJFSkFSRXlGeFlYRmhRSEJnY0dJaWNtSnlZMUl4UVhIZ0VYRmpJM1BnRTNOalFuTGdFbkpnT0Evb3NCZFhwb1pqczlQVHRtYVBSb1pqczlsUzh0cFd0djlHOXJwUzB2THkybGEyOEZpd0VxL292K2l3RXFQVHRtYVBOcFpUdzlQVHhsYVhsNWIydW1MUzh2TGFacmIvTnZhNlV1THdBQkFBQUFBQVUvQndBQUZBQUFBUkVqSWdZZEFTRURJeEVoRVNNUk16VTBOak15QlQrZFZqd0JKU2YrL3M3Ly85Q3Rrd2IwL3ZoSVNMMysyUDBKQXZjQktOcTZ6UUFBQUFBRUFBQUFBQWFPQndBQU1BQkZBR0FBYkFBQUFSUWVBeFVVQndZRUl5SW1KeVkxTkRZM05pVXVBVFUwTndZaklpWTFORFkzUGdFeklRY2pIZ0VWRkE0REp6STJOelkxTkM0Q0l5SUdCd1lWRkI0REV6SStBalUwTGdFdkFTWXZBaVlqSWc0REZSUWVBZ0V6RlNNVkl6VWpOVE0xTXdNZlFGdGFRREJJL3VxZmhPVTVKVmxLZ3dFUklCOFZMaGFVeTBnL1RkTndBYUtLZzBwTU1VVkdNWkltVUJvMUlqOXFRQ3BSR1M4VUt6MVpOanByV3pjT0R4TWVDaHdsVGhBZ05XaHZVelpHY1gwRGE5WFZhZFRVYVFQa0pFVkRVSUJPV2xONmMxTmdQRWRSaWk1U0VpcEFLU1F4Qk1HVVVwbzJRa0JZUDR4YVNITkhPMEErSVJzNVpqcUdmVkluSVR0bExtZG5ValQ4bHhvMFhqNFpNQ1FZSXdzWEhUZ0NEaVE0WFR0R2F6c2RBMnhzMjl0czJRQURBQUFBQUFhQUJtd0FBd0FPQUNvQUFBRVJJUkVCRmdZckFTSW1ORFl5RmdFUklSRTBKaU1pQmdjR0ZSRWhFaEF2QVNFVkl6NERNeklXQWQzK3RnRmZBV2RVQWxKa1o2WmtCSS8rdDFGV1AxVVZDLzYzQWdFQkFVa0NGQ3BIWnorcjBBU1AvQ0VEM3dFeVNXSmlrMkZoL04zOXlBSVNhWGRGTXg0ei9kY0Jqd0h3TURDUUlEQTRIK01BQUFFQUFBQUFCcFFHQUFBeEFBQUJCZ2NXRlJRQ0RnRUVJeUFuRmpNeU55NEJKeFl6TWpjdUFUMEJGaGN1QVRVME54WUVGeVkxTkRZek1oYzJOd1lITmdhVVExOEJUSnZXL3RLcy92SGhJeXZoc0dtbUh5RWNLeXB3azBST1FrNHNlUUZieGdpOWhveGdiV0FsYVYwRmFHSkZEaHlDL3YzdXQyMlJCSW9DZldFRkN4ZXhkUVFtQXl5T1UxaExsYk1LSmlTR3ZXWVZPWE0vQ2dBQUFBRUFBQUFBQllBSEFBQWlBQUFCRnc0QkJ3WXVBelVSSXpVK0JEYytBVHNCRVNFVklSRVVIZ0kzTmdVd1VCZXdXV2l0Y0U0aHFFaHlSREFVQlFFSEJQUUJUZjZ5RFNCRE1FNEJ6KzBqUGdFQ09GeDRlRG9DSU5jYVYxMXZWeTBGQi81WS9QMzZIalExSGdFQ0FBRUFBQUFBQm9BR2dBQktBQUFCRkFJRUl5SW5OajhCSGdFek1qNEJOVFF1QVNNaURnTVZGQllYRmo4Qk5qYzJKeVkxTkRZek1oWVZGQVlqSWlZM1BnSTFOQ1lqSWdZVkZCY0RCaGNtQWpVMEVpUWdCQklHZ003K245RnZhenNUTmhScVBYbSthSGZpam1tMmYxc3JVRTBlQ0FnR0FnWVJNOUdwbDZtSmF6MUtEZ2dsRnpZeVBsWVpZeEVFenY3T0FXRUJvZ0ZoemdPQTBmNmZ6aUJkUjlNbk9ZbndsbkxJZmpwZ2ZZWkRhSjRnRENBZkdBWVhGRDFhbDlta2c2cnVWejBqZFZrZk1rSnlWVWt4L2w1R2Exc0JmT25SQVdIT3p2NmZBQUFIQUFBQUFBY0JCTThBRndBaEFEZ0FUd0JtQUhFQWRBQUFBUkV6TmhjV0Z4WVhGaGNXQnc0QkJ3WUhCaWNtTHdFbU54WTJOell1QVFjUkZBVVdOelkvQVRZM05qVTJKeU1HRnhZZkFSWVhGaGNVRnhZM05qOEJOamMyTnpZbkl3WVhGaDhCRmhjV0ZSWVhGamMyUHdFMk56WTNOaWNqQmhjV0h3RVdGeFlWRmdVelB3RVZNeEVqQmdzQkFSVW5BeHdjYUM1TU5EMHNUU3N2Q2dkVlJFZFROV2cxS2dFQ3ExSnJDUWN3WWtBQmZob1NDeEFLSkJRWEFYNGRBUU1DQmdNbkZ4c0JKQm9TQ3hBS0pCUVdBUUYrSGdFRUFnVUVKeGNiQVNNWkV3c1FDaVFVRmdFQmZoNEJCQUlGQkNjWEd3SDVRKzVCNGFyTkRmSHZBaGFPQWNrQy9RSUJBd3dQSHpkY1pYbFptQzh4Q0FRQkFRSURCTUlEVmt4Q1pEUUYvcFVId2djVEN5QVVRRWRQVThldENBZ0ZDUVpIVEZ4YndMb0hFd3NnRkVCSFQxUEhyUWdJQlFrR1IweGNXOEM2QnhNTElCUkFSMDlUeDYwSUNBVUpCa2RNWEZ2QXdHUUJaUU1NRmY2RC9vWUIvZmtCQUFBQkFBQUFBQVloQnJZQUxBQUFBU0lIRGdFSEJoVVJGQjRCT3dFUklUVTBOejRCTnpZeUZ4NEJGeFlkQVNFUk16SStBVFVSTkNjdUFTY21BNENKZlhpNk16VThaejNnL3RVcEtKRmVZZFJoWHBFb0tmN1Y0RDFuUERVenVuaDlCclUwTTd0NGZZbjk5ajFuUEFKVmxXdGhYcEFvS1Nrb2tGNWhhNVg5cXp4blBRSUtpWDE0dXpNMEFBQUFBQUlBQUFBQUJVQUZRQUFDQUFZQUFBa0NJUkV6RVFIQUFudjloUUxybFFIQUFjQUJ3UHlBQTRBQUFBQUFBZ0FBQUFBRlFBVkFBQU1BQmdBQUFUTVJJd2tCRVFIQWxaVUJCUUo3QlVEOGdBSEEva0FEZ0FBQUFBQUFBQkFBeGdBQkFBQUFBQUFCQUFjQUFBQUJBQUFBQUFBQ0FBY0FCd0FCQUFBQUFBQURBQWNBRGdBQkFBQUFBQUFFQUFjQUZRQUJBQUFBQUFBRkFBc0FIQUFCQUFBQUFBQUdBQWNBSndBQkFBQUFBQUFLQUNzQUxnQUJBQUFBQUFBTEFCTUFXUUFEQUFFRUNRQUJBQTRBYkFBREFBRUVDUUFDQUE0QWVnQURBQUVFQ1FBREFBNEFpQUFEQUFFRUNRQUVBQTRBbGdBREFBRUVDUUFGQUJZQXBBQURBQUVFQ1FBR0FBNEF1Z0FEQUFFRUNRQUtBRllBeUFBREFBRUVDUUFMQUNZQkhsWnBaR1Z2U2xOU1pXZDFiR0Z5Vm1sa1pXOUtVMVpwWkdWdlNsTldaWEp6YVc5dUlERXVNRlpwWkdWdlNsTkhaVzVsY21GMFpXUWdZbmtnYzNabk1uUjBaaUJtY205dElFWnZiblJsYkd4dklIQnliMnBsWTNRdWFIUjBjRG92TDJadmJuUmxiR3h2TG1OdmJRQldBR2tBWkFCbEFHOEFTZ0JUQUZJQVpRQm5BSFVBYkFCaEFISUFWZ0JwQUdRQVpRQnZBRW9BVXdCV0FHa0FaQUJsQUc4QVNnQlRBRllBWlFCeUFITUFhUUJ2QUc0QUlBQXhBQzRBTUFCV0FHa0FaQUJsQUc4QVNnQlRBRWNBWlFCdUFHVUFjZ0JoQUhRQVpRQmtBQ0FBWWdCNUFDQUFjd0IyQUdjQU1nQjBBSFFBWmdBZ0FHWUFjZ0J2QUcwQUlBQkdBRzhBYmdCMEFHVUFiQUJzQUc4QUlBQndBSElBYndCcUFHVUFZd0IwQUM0QWFBQjBBSFFBY0FBNkFDOEFMd0JtQUc4QWJnQjBBR1VBYkFCc0FHOEFMZ0JqQUc4QWJRQUFBQUlBQUFBQUFBQUFFUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlRRUNBUU1CQkFFRkFRWUJCd0VJQVFrQkNnRUxBUXdCRFFFT0FROEJFQUVSQVJJQkV3RVVBUlVCRmdFWEFSZ0JHUUVhQVJzQkhBRWRBUjRCSHdFZ0FTRUJJZ0FFY0d4aGVRdHdiR0Y1TFdOcGNtTnNaUVZ3WVhWelpRdDJiMngxYldVdGJYVjBaUXAyYjJ4MWJXVXRiRzkzQ25admJIVnRaUzF0YVdRTGRtOXNkVzFsTFdocFoyZ1FablZzYkhOamNtVmxiaTFsYm5SbGNnOW1kV3hzYzJOeVpXVnVMV1Y0YVhRR2MzRjFZWEpsQjNOd2FXNXVaWElKYzNWaWRHbDBiR1Z6Q0dOaGNIUnBiMjV6Q0dOb1lYQjBaWEp6QlhOb1lYSmxBMk52WndaamFYSmpiR1VPWTJseVkyeGxMVzkxZEd4cGJtVVRZMmx5WTJ4bExXbHVibVZ5TFdOcGNtTnNaUUpvWkFaallXNWpaV3dHY21Wd2JHRjVDR1poWTJWaWIyOXJCV2R3YkhWekNHeHBibXRsWkdsdUIzUjNhWFIwWlhJR2RIVnRZbXh5Q1hCcGJuUmxjbVZ6ZEJGaGRXUnBieTFrWlhOamNtbHdkR2x2YmdWaGRXUnBid2x1WlhoMExXbDBaVzBOY0hKbGRtbHZkWE10YVhSbGJRQUFBQUE9KSBmb3JtYXQoXFxcInRydWV0eXBlXFxcIik7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsfS52aWRlby1qcyAudmpzLWJpZy1wbGF5LWJ1dHRvbiAudmpzLWljb24tcGxhY2Vob2xkZXI6YmVmb3JlLC52aWRlby1qcyAudmpzLXBsYXktY29udHJvbCAudmpzLWljb24tcGxhY2Vob2xkZXIsLnZqcy1pY29uLXBsYXl7Zm9udC1mYW1pbHk6VmlkZW9KUztmb250LXdlaWdodDo0MDA7Zm9udC1zdHlsZTpub3JtYWx9LnZpZGVvLWpzIC52anMtYmlnLXBsYXktYnV0dG9uIC52anMtaWNvbi1wbGFjZWhvbGRlcjpiZWZvcmUsLnZpZGVvLWpzIC52anMtcGxheS1jb250cm9sIC52anMtaWNvbi1wbGFjZWhvbGRlcjpiZWZvcmUsLnZqcy1pY29uLXBsYXk6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxGMTAxXFxcIn0udmpzLWljb24tcGxheS1jaXJjbGV7Zm9udC1mYW1pbHk6VmlkZW9KUztmb250LXdlaWdodDo0MDA7Zm9udC1zdHlsZTpub3JtYWx9LnZqcy1pY29uLXBsYXktY2lyY2xlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRjEwMlxcXCJ9LnZpZGVvLWpzIC52anMtcGxheS1jb250cm9sLnZqcy1wbGF5aW5nIC52anMtaWNvbi1wbGFjZWhvbGRlciwudmpzLWljb24tcGF1c2V7Zm9udC1mYW1pbHk6VmlkZW9KUztmb250LXdlaWdodDo0MDA7Zm9udC1zdHlsZTpub3JtYWx9LnZpZGVvLWpzIC52anMtcGxheS1jb250cm9sLnZqcy1wbGF5aW5nIC52anMtaWNvbi1wbGFjZWhvbGRlcjpiZWZvcmUsLnZqcy1pY29uLXBhdXNlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRjEwM1xcXCJ9LnZpZGVvLWpzIC52anMtbXV0ZS1jb250cm9sLnZqcy12b2wtMCAudmpzLWljb24tcGxhY2Vob2xkZXIsLnZqcy1pY29uLXZvbHVtZS1tdXRle2ZvbnQtZmFtaWx5OlZpZGVvSlM7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsfS52aWRlby1qcyAudmpzLW11dGUtY29udHJvbC52anMtdm9sLTAgLnZqcy1pY29uLXBsYWNlaG9sZGVyOmJlZm9yZSwudmpzLWljb24tdm9sdW1lLW11dGU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxGMTA0XFxcIn0udmlkZW8tanMgLnZqcy1tdXRlLWNvbnRyb2wudmpzLXZvbC0xIC52anMtaWNvbi1wbGFjZWhvbGRlciwudmpzLWljb24tdm9sdW1lLWxvd3tmb250LWZhbWlseTpWaWRlb0pTO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbH0udmlkZW8tanMgLnZqcy1tdXRlLWNvbnRyb2wudmpzLXZvbC0xIC52anMtaWNvbi1wbGFjZWhvbGRlcjpiZWZvcmUsLnZqcy1pY29uLXZvbHVtZS1sb3c6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxGMTA1XFxcIn0udmlkZW8tanMgLnZqcy1tdXRlLWNvbnRyb2wudmpzLXZvbC0yIC52anMtaWNvbi1wbGFjZWhvbGRlciwudmpzLWljb24tdm9sdW1lLW1pZHtmb250LWZhbWlseTpWaWRlb0pTO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbH0udmlkZW8tanMgLnZqcy1tdXRlLWNvbnRyb2wudmpzLXZvbC0yIC52anMtaWNvbi1wbGFjZWhvbGRlcjpiZWZvcmUsLnZqcy1pY29uLXZvbHVtZS1taWQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxGMTA2XFxcIn0udmlkZW8tanMgLnZqcy1tdXRlLWNvbnRyb2wgLnZqcy1pY29uLXBsYWNlaG9sZGVyLC52anMtaWNvbi12b2x1bWUtaGlnaHtmb250LWZhbWlseTpWaWRlb0pTO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbH0udmlkZW8tanMgLnZqcy1tdXRlLWNvbnRyb2wgLnZqcy1pY29uLXBsYWNlaG9sZGVyOmJlZm9yZSwudmpzLWljb24tdm9sdW1lLWhpZ2g6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxGMTA3XFxcIn0udmlkZW8tanMgLnZqcy1mdWxsc2NyZWVuLWNvbnRyb2wgLnZqcy1pY29uLXBsYWNlaG9sZGVyLC52anMtaWNvbi1mdWxsc2NyZWVuLWVudGVye2ZvbnQtZmFtaWx5OlZpZGVvSlM7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsfS52aWRlby1qcyAudmpzLWZ1bGxzY3JlZW4tY29udHJvbCAudmpzLWljb24tcGxhY2Vob2xkZXI6YmVmb3JlLC52anMtaWNvbi1mdWxsc2NyZWVuLWVudGVyOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRjEwOFxcXCJ9LnZpZGVvLWpzLnZqcy1mdWxsc2NyZWVuIC52anMtZnVsbHNjcmVlbi1jb250cm9sIC52anMtaWNvbi1wbGFjZWhvbGRlciwudmpzLWljb24tZnVsbHNjcmVlbi1leGl0e2ZvbnQtZmFtaWx5OlZpZGVvSlM7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsfS52aWRlby1qcy52anMtZnVsbHNjcmVlbiAudmpzLWZ1bGxzY3JlZW4tY29udHJvbCAudmpzLWljb24tcGxhY2Vob2xkZXI6YmVmb3JlLC52anMtaWNvbi1mdWxsc2NyZWVuLWV4aXQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxGMTA5XFxcIn0udmpzLWljb24tc3F1YXJle2ZvbnQtZmFtaWx5OlZpZGVvSlM7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsfS52anMtaWNvbi1zcXVhcmU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxGMTBBXFxcIn0udmpzLWljb24tc3Bpbm5lcntmb250LWZhbWlseTpWaWRlb0pTO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbH0udmpzLWljb24tc3Bpbm5lcjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEYxMEJcXFwifS52aWRlby1qcy52aWRlby1qczpsYW5nKGVuLUFVKSAudmpzLXN1YnMtY2Fwcy1idXR0b24gLnZqcy1pY29uLXBsYWNlaG9sZGVyLC52aWRlby1qcy52aWRlby1qczpsYW5nKGVuLUdCKSAudmpzLXN1YnMtY2Fwcy1idXR0b24gLnZqcy1pY29uLXBsYWNlaG9sZGVyLC52aWRlby1qcy52aWRlby1qczpsYW5nKGVuLUlFKSAudmpzLXN1YnMtY2Fwcy1idXR0b24gLnZqcy1pY29uLXBsYWNlaG9sZGVyLC52aWRlby1qcy52aWRlby1qczpsYW5nKGVuLU5aKSAudmpzLXN1YnMtY2Fwcy1idXR0b24gLnZqcy1pY29uLXBsYWNlaG9sZGVyLC52aWRlby1qcyAudmpzLXN1YnMtY2Fwcy1idXR0b24gLnZqcy1pY29uLXBsYWNlaG9sZGVyLC52aWRlby1qcyAudmpzLXN1YnRpdGxlcy1idXR0b24gLnZqcy1pY29uLXBsYWNlaG9sZGVyLC52anMtaWNvbi1zdWJ0aXRsZXN7Zm9udC1mYW1pbHk6VmlkZW9KUztmb250LXdlaWdodDo0MDA7Zm9udC1zdHlsZTpub3JtYWx9LnZpZGVvLWpzLnZpZGVvLWpzOmxhbmcoZW4tQVUpIC52anMtc3Vicy1jYXBzLWJ1dHRvbiAudmpzLWljb24tcGxhY2Vob2xkZXI6YmVmb3JlLC52aWRlby1qcy52aWRlby1qczpsYW5nKGVuLUdCKSAudmpzLXN1YnMtY2Fwcy1idXR0b24gLnZqcy1pY29uLXBsYWNlaG9sZGVyOmJlZm9yZSwudmlkZW8tanMudmlkZW8tanM6bGFuZyhlbi1JRSkgLnZqcy1zdWJzLWNhcHMtYnV0dG9uIC52anMtaWNvbi1wbGFjZWhvbGRlcjpiZWZvcmUsLnZpZGVvLWpzLnZpZGVvLWpzOmxhbmcoZW4tTlopIC52anMtc3Vicy1jYXBzLWJ1dHRvbiAudmpzLWljb24tcGxhY2Vob2xkZXI6YmVmb3JlLC52aWRlby1qcyAudmpzLXN1YnMtY2Fwcy1idXR0b24gLnZqcy1pY29uLXBsYWNlaG9sZGVyOmJlZm9yZSwudmlkZW8tanMgLnZqcy1zdWJ0aXRsZXMtYnV0dG9uIC52anMtaWNvbi1wbGFjZWhvbGRlcjpiZWZvcmUsLnZqcy1pY29uLXN1YnRpdGxlczpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEYxMENcXFwifS52aWRlby1qcyAudmpzLWNhcHRpb25zLWJ1dHRvbiAudmpzLWljb24tcGxhY2Vob2xkZXIsLnZpZGVvLWpzOmxhbmcoZW4pIC52anMtc3Vicy1jYXBzLWJ1dHRvbiAudmpzLWljb24tcGxhY2Vob2xkZXIsLnZpZGVvLWpzOmxhbmcoZnItQ0EpIC52anMtc3Vicy1jYXBzLWJ1dHRvbiAudmpzLWljb24tcGxhY2Vob2xkZXIsLnZqcy1pY29uLWNhcHRpb25ze2ZvbnQtZmFtaWx5OlZpZGVvSlM7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsfS52aWRlby1qcyAudmpzLWNhcHRpb25zLWJ1dHRvbiAudmpzLWljb24tcGxhY2Vob2xkZXI6YmVmb3JlLC52aWRlby1qczpsYW5nKGVuKSAudmpzLXN1YnMtY2Fwcy1idXR0b24gLnZqcy1pY29uLXBsYWNlaG9sZGVyOmJlZm9yZSwudmlkZW8tanM6bGFuZyhmci1DQSkgLnZqcy1zdWJzLWNhcHMtYnV0dG9uIC52anMtaWNvbi1wbGFjZWhvbGRlcjpiZWZvcmUsLnZqcy1pY29uLWNhcHRpb25zOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRjEwRFxcXCJ9LnZpZGVvLWpzIC52anMtY2hhcHRlcnMtYnV0dG9uIC52anMtaWNvbi1wbGFjZWhvbGRlciwudmpzLWljb24tY2hhcHRlcnN7Zm9udC1mYW1pbHk6VmlkZW9KUztmb250LXdlaWdodDo0MDA7Zm9udC1zdHlsZTpub3JtYWx9LnZpZGVvLWpzIC52anMtY2hhcHRlcnMtYnV0dG9uIC52anMtaWNvbi1wbGFjZWhvbGRlcjpiZWZvcmUsLnZqcy1pY29uLWNoYXB0ZXJzOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRjEwRVxcXCJ9LnZqcy1pY29uLXNoYXJle2ZvbnQtZmFtaWx5OlZpZGVvSlM7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsfS52anMtaWNvbi1zaGFyZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEYxMEZcXFwifS52anMtaWNvbi1jb2d7Zm9udC1mYW1pbHk6VmlkZW9KUztmb250LXdlaWdodDo0MDA7Zm9udC1zdHlsZTpub3JtYWx9LnZqcy1pY29uLWNvZzpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEYxMTBcXFwifS52aWRlby1qcyAudmpzLXBsYXktcHJvZ3Jlc3MsLnZpZGVvLWpzIC52anMtdm9sdW1lLWxldmVsLC52anMtaWNvbi1jaXJjbGV7Zm9udC1mYW1pbHk6VmlkZW9KUztmb250LXdlaWdodDo0MDA7Zm9udC1zdHlsZTpub3JtYWx9LnZpZGVvLWpzIC52anMtcGxheS1wcm9ncmVzczpiZWZvcmUsLnZpZGVvLWpzIC52anMtdm9sdW1lLWxldmVsOmJlZm9yZSwudmpzLWljb24tY2lyY2xlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRjExMVxcXCJ9LnZqcy1pY29uLWNpcmNsZS1vdXRsaW5le2ZvbnQtZmFtaWx5OlZpZGVvSlM7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsfS52anMtaWNvbi1jaXJjbGUtb3V0bGluZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEYxMTJcXFwifS52anMtaWNvbi1jaXJjbGUtaW5uZXItY2lyY2xle2ZvbnQtZmFtaWx5OlZpZGVvSlM7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsfS52anMtaWNvbi1jaXJjbGUtaW5uZXItY2lyY2xlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRjExM1xcXCJ9LnZqcy1pY29uLWhke2ZvbnQtZmFtaWx5OlZpZGVvSlM7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsfS52anMtaWNvbi1oZDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEYxMTRcXFwifS52aWRlby1qcyAudmpzLWNvbnRyb2wudmpzLWNsb3NlLWJ1dHRvbiAudmpzLWljb24tcGxhY2Vob2xkZXIsLnZqcy1pY29uLWNhbmNlbHtmb250LWZhbWlseTpWaWRlb0pTO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbH0udmlkZW8tanMgLnZqcy1jb250cm9sLnZqcy1jbG9zZS1idXR0b24gLnZqcy1pY29uLXBsYWNlaG9sZGVyOmJlZm9yZSwudmpzLWljb24tY2FuY2VsOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRjExNVxcXCJ9LnZpZGVvLWpzIC52anMtcGxheS1jb250cm9sLnZqcy1lbmRlZCAudmpzLWljb24tcGxhY2Vob2xkZXIsLnZqcy1pY29uLXJlcGxheXtmb250LWZhbWlseTpWaWRlb0pTO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbH0udmlkZW8tanMgLnZqcy1wbGF5LWNvbnRyb2wudmpzLWVuZGVkIC52anMtaWNvbi1wbGFjZWhvbGRlcjpiZWZvcmUsLnZqcy1pY29uLXJlcGxheTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEYxMTZcXFwifS52anMtaWNvbi1mYWNlYm9va3tmb250LWZhbWlseTpWaWRlb0pTO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbH0udmpzLWljb24tZmFjZWJvb2s6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxGMTE3XFxcIn0udmpzLWljb24tZ3BsdXN7Zm9udC1mYW1pbHk6VmlkZW9KUztmb250LXdlaWdodDo0MDA7Zm9udC1zdHlsZTpub3JtYWx9LnZqcy1pY29uLWdwbHVzOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRjExOFxcXCJ9LnZqcy1pY29uLWxpbmtlZGlue2ZvbnQtZmFtaWx5OlZpZGVvSlM7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsfS52anMtaWNvbi1saW5rZWRpbjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEYxMTlcXFwifS52anMtaWNvbi10d2l0dGVye2ZvbnQtZmFtaWx5OlZpZGVvSlM7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsfS52anMtaWNvbi10d2l0dGVyOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRjExQVxcXCJ9LnZqcy1pY29uLXR1bWJscntmb250LWZhbWlseTpWaWRlb0pTO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbH0udmpzLWljb24tdHVtYmxyOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRjExQlxcXCJ9LnZqcy1pY29uLXBpbnRlcmVzdHtmb250LWZhbWlseTpWaWRlb0pTO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbH0udmpzLWljb24tcGludGVyZXN0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcRjExQ1xcXCJ9LnZpZGVvLWpzIC52anMtZGVzY3JpcHRpb25zLWJ1dHRvbiAudmpzLWljb24tcGxhY2Vob2xkZXIsLnZqcy1pY29uLWF1ZGlvLWRlc2NyaXB0aW9ue2ZvbnQtZmFtaWx5OlZpZGVvSlM7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsfS52aWRlby1qcyAudmpzLWRlc2NyaXB0aW9ucy1idXR0b24gLnZqcy1pY29uLXBsYWNlaG9sZGVyOmJlZm9yZSwudmpzLWljb24tYXVkaW8tZGVzY3JpcHRpb246YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxGMTFEXFxcIn0udmlkZW8tanMgLnZqcy1hdWRpby1idXR0b24gLnZqcy1pY29uLXBsYWNlaG9sZGVyLC52anMtaWNvbi1hdWRpb3tmb250LWZhbWlseTpWaWRlb0pTO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbH0udmlkZW8tanMgLnZqcy1hdWRpby1idXR0b24gLnZqcy1pY29uLXBsYWNlaG9sZGVyOmJlZm9yZSwudmpzLWljb24tYXVkaW86YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxGMTFFXFxcIn0udmpzLWljb24tbmV4dC1pdGVte2ZvbnQtZmFtaWx5OlZpZGVvSlM7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsfS52anMtaWNvbi1uZXh0LWl0ZW06YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxGMTFGXFxcIn0udmpzLWljb24tcHJldmlvdXMtaXRlbXtmb250LWZhbWlseTpWaWRlb0pTO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbH0udmpzLWljb24tcHJldmlvdXMtaXRlbTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXEYxMjBcXFwifS52aWRlby1qc3tkaXNwbGF5OmJsb2NrO3ZlcnRpY2FsLWFsaWduOnRvcDtib3gtc2l6aW5nOmJvcmRlci1ib3g7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiMwMDA7cG9zaXRpb246cmVsYXRpdmU7cGFkZGluZzowO2ZvbnQtc2l6ZToxMHB4O2xpbmUtaGVpZ2h0OjE7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtZmFtaWx5OkFyaWFsLEhlbHZldGljYSxzYW5zLXNlcmlmO3dvcmQtYnJlYWs6bm9ybWFsfS52aWRlby1qczotbW96LWZ1bGwtc2NyZWVue3Bvc2l0aW9uOmFic29sdXRlfS52aWRlby1qczotd2Via2l0LWZ1bGwtc2NyZWVue3dpZHRoOjEwMCUhaW1wb3J0YW50O2hlaWdodDoxMDAlIWltcG9ydGFudH0udmlkZW8tanNbdGFiaW5kZXg9XFxcIi0xXFxcIl17b3V0bGluZTpub25lfS52aWRlby1qcyAqLC52aWRlby1qcyA6YWZ0ZXIsLnZpZGVvLWpzIDpiZWZvcmV7Ym94LXNpemluZzppbmhlcml0fS52aWRlby1qcyB1bHtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtc2l6ZTppbmhlcml0O2xpbmUtaGVpZ2h0OmluaGVyaXQ7bGlzdC1zdHlsZS1wb3NpdGlvbjpvdXRzaWRlO21hcmdpbjowfS52aWRlby1qcy52anMtNC0zLC52aWRlby1qcy52anMtMTYtOSwudmlkZW8tanMudmpzLWZsdWlke3dpZHRoOjEwMCU7bWF4LXdpZHRoOjEwMCU7aGVpZ2h0OjB9LnZpZGVvLWpzLnZqcy0xNi05e3BhZGRpbmctdG9wOjU2LjI1JX0udmlkZW8tanMudmpzLTQtM3twYWRkaW5nLXRvcDo3NSV9LnZpZGVvLWpzLnZqcy1maWxsLC52aWRlby1qcyAudmpzLXRlY2h7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX0udmlkZW8tanMgLnZqcy10ZWNoe3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MH1ib2R5LnZqcy1mdWxsLXdpbmRvd3twYWRkaW5nOjA7bWFyZ2luOjA7aGVpZ2h0OjEwMCU7b3ZlcmZsb3cteTphdXRvfS52anMtZnVsbC13aW5kb3cgLnZpZGVvLWpzLnZqcy1mdWxsc2NyZWVue3Bvc2l0aW9uOmZpeGVkO292ZXJmbG93OmhpZGRlbjt6LWluZGV4OjEwMDA7bGVmdDowO3RvcDowO2JvdHRvbTowO3JpZ2h0OjB9LnZpZGVvLWpzLnZqcy1mdWxsc2NyZWVue3dpZHRoOjEwMCUhaW1wb3J0YW50O2hlaWdodDoxMDAlIWltcG9ydGFudDtwYWRkaW5nLXRvcDowIWltcG9ydGFudH0udmlkZW8tanMudmpzLWZ1bGxzY3JlZW4udmpzLXVzZXItaW5hY3RpdmV7Y3Vyc29yOm5vbmV9LnZqcy1oaWRkZW57ZGlzcGxheTpub25lIWltcG9ydGFudH0udmpzLWRpc2FibGVke29wYWNpdHk6LjU7Y3Vyc29yOmRlZmF1bHR9LnZpZGVvLWpzIC52anMtb2Zmc2NyZWVue2hlaWdodDoxcHg7bGVmdDotOTk5OXB4O3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3dpZHRoOjFweH0udmpzLWxvY2stc2hvd2luZ3tkaXNwbGF5OmJsb2NrIWltcG9ydGFudDtvcGFjaXR5OjE7dmlzaWJpbGl0eTp2aXNpYmxlfS52anMtbm8tanN7cGFkZGluZzoyMHB4O2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMDAwO2ZvbnQtc2l6ZToxOHB4O2ZvbnQtZmFtaWx5OkFyaWFsLEhlbHZldGljYSxzYW5zLXNlcmlmO3RleHQtYWxpZ246Y2VudGVyO3dpZHRoOjMwMHB4O2hlaWdodDoxNTBweDttYXJnaW46MCBhdXRvfS52anMtbm8tanMgYSwudmpzLW5vLWpzIGE6dmlzaXRlZHtjb2xvcjojNjZhOGNjfS52aWRlby1qcyAudmpzLWJpZy1wbGF5LWJ1dHRvbntmb250LXNpemU6M2VtO2xpbmUtaGVpZ2h0OjEuNWVtO2hlaWdodDoxLjVlbTt3aWR0aDozZW07ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTBweDtsZWZ0OjEwcHg7cGFkZGluZzowO2N1cnNvcjpwb2ludGVyO29wYWNpdHk6MTtib3JkZXI6LjA2NjY2ZW0gc29saWQgI2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiMyYjMzM2Y7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDQzLDUxLDYzLC43KTstd2Via2l0LWJvcmRlci1yYWRpdXM6LjNlbTstbW96LWJvcmRlci1yYWRpdXM6LjNlbTtib3JkZXItcmFkaXVzOi4zZW07LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuNHM7LW1vei10cmFuc2l0aW9uOmFsbCAuNHM7LW1zLXRyYW5zaXRpb246YWxsIC40czstby10cmFuc2l0aW9uOmFsbCAuNHM7dHJhbnNpdGlvbjphbGwgLjRzfS52anMtYmlnLXBsYXktY2VudGVyZWQgLnZqcy1iaWctcGxheS1idXR0b257dG9wOjUwJTtsZWZ0OjUwJTttYXJnaW4tdG9wOi0uNzVlbTttYXJnaW4tbGVmdDotMS41ZW19LnZpZGVvLWpzIC52anMtYmlnLXBsYXktYnV0dG9uOmZvY3VzLC52aWRlby1qczpob3ZlciAudmpzLWJpZy1wbGF5LWJ1dHRvbntib3JkZXItY29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiM3Mzg1OWY7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDExNSwxMzMsMTU5LC41KTstd2Via2l0LXRyYW5zaXRpb246YWxsIDBzOy1tb3otdHJhbnNpdGlvbjphbGwgMHM7LW1zLXRyYW5zaXRpb246YWxsIDBzOy1vLXRyYW5zaXRpb246YWxsIDBzO3RyYW5zaXRpb246YWxsIDBzfS52anMtY29udHJvbHMtZGlzYWJsZWQgLnZqcy1iaWctcGxheS1idXR0b24sLnZqcy1lcnJvciAudmpzLWJpZy1wbGF5LWJ1dHRvbiwudmpzLWhhcy1zdGFydGVkIC52anMtYmlnLXBsYXktYnV0dG9uLC52anMtdXNpbmctbmF0aXZlLWNvbnRyb2xzIC52anMtYmlnLXBsYXktYnV0dG9ue2Rpc3BsYXk6bm9uZX0udmpzLWhhcy1zdGFydGVkLnZqcy1wYXVzZWQudmpzLXNob3ctYmlnLXBsYXktYnV0dG9uLW9uLXBhdXNlIC52anMtYmlnLXBsYXktYnV0dG9ue2Rpc3BsYXk6YmxvY2t9LnZpZGVvLWpzIGJ1dHRvbntiYWNrZ3JvdW5kOm5vbmU7Ym9yZGVyOm5vbmU7Y29sb3I6aW5oZXJpdDtkaXNwbGF5OmlubGluZS1ibG9jaztvdmVyZmxvdzp2aXNpYmxlO2ZvbnQtc2l6ZTppbmhlcml0O2xpbmUtaGVpZ2h0OmluaGVyaXQ7dGV4dC10cmFuc2Zvcm06bm9uZTt0ZXh0LWRlY29yYXRpb246bm9uZTt0cmFuc2l0aW9uOm5vbmU7LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7LW1vei1hcHBlYXJhbmNlOm5vbmU7YXBwZWFyYW5jZTpub25lfS52anMtY29udHJvbCAudmpzLWJ1dHRvbnt3aWR0aDoxMDAlO2hlaWdodDoxMDAlfS52aWRlby1qcyAudmpzLWNvbnRyb2wudmpzLWNsb3NlLWJ1dHRvbntjdXJzb3I6cG9pbnRlcjtoZWlnaHQ6M2VtO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOi41ZW07ei1pbmRleDoyfS52aWRlby1qcyAudmpzLW1vZGFsLWRpYWxvZ3tiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjgpO2JhY2tncm91bmQ6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQoLTkwZGVnLHJnYmEoMCwwLDAsLjgpLGhzbGEoMCwwJSwxMDAlLDApKTtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCgxODBkZWcscmdiYSgwLDAsMCwuOCksaHNsYSgwLDAlLDEwMCUsMCkpO292ZXJmbG93OmF1dG87Ym94LXNpemluZzpjb250ZW50LWJveH0udmlkZW8tanMgLnZqcy1tb2RhbC1kaWFsb2c+Kntib3gtc2l6aW5nOmJvcmRlci1ib3h9LnZqcy1tb2RhbC1kaWFsb2cgLnZqcy1tb2RhbC1kaWFsb2ctY29udGVudHtmb250LXNpemU6MS4yZW07bGluZS1oZWlnaHQ6MS41O3BhZGRpbmc6MjBweCAyNHB4O3otaW5kZXg6MX0udmpzLW1lbnUtYnV0dG9ue2N1cnNvcjpwb2ludGVyfS52anMtbWVudS1idXR0b24udmpzLWRpc2FibGVke2N1cnNvcjpkZWZhdWx0fS52anMtd29ya2luZ2hvdmVyIC52anMtbWVudS1idXR0b24udmpzLWRpc2FibGVkOmhvdmVyIC52anMtbWVudXtkaXNwbGF5Om5vbmV9LnZqcy1tZW51IC52anMtbWVudS1jb250ZW50e2Rpc3BsYXk6YmxvY2s7cGFkZGluZzowO21hcmdpbjowO2ZvbnQtZmFtaWx5OkFyaWFsLEhlbHZldGljYSxzYW5zLXNlcmlmO292ZXJmbG93OmF1dG87Ym94LXNpemluZzpjb250ZW50LWJveH0udmpzLW1lbnUgLnZqcy1tZW51LWNvbnRlbnQ+Kntib3gtc2l6aW5nOmJvcmRlci1ib3h9LnZqcy1zY3J1YmJpbmcgLnZqcy1tZW51LWJ1dHRvbjpob3ZlciAudmpzLW1lbnV7ZGlzcGxheTpub25lfS52anMtbWVudSBsaXtsaXN0LXN0eWxlOm5vbmU7bWFyZ2luOjA7cGFkZGluZzouMmVtIDA7bGluZS1oZWlnaHQ6MS40ZW07Zm9udC1zaXplOjEuMmVtO3RleHQtYWxpZ246Y2VudGVyO3RleHQtdHJhbnNmb3JtOmxvd2VyY2FzZX0udmpzLW1lbnUgbGkudmpzLW1lbnUtaXRlbTpmb2N1cywudmpzLW1lbnUgbGkudmpzLW1lbnUtaXRlbTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiM3Mzg1OWY7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDExNSwxMzMsMTU5LC41KX0udmpzLW1lbnUgbGkudmpzLXNlbGVjdGVkLC52anMtbWVudSBsaS52anMtc2VsZWN0ZWQ6Zm9jdXMsLnZqcy1tZW51IGxpLnZqcy1zZWxlY3RlZDpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Y29sb3I6IzJiMzMzZn0udmpzLW1lbnUgbGkudmpzLW1lbnUtdGl0bGV7dGV4dC1hbGlnbjpjZW50ZXI7dGV4dC10cmFuc2Zvcm06dXBwZXJjYXNlO2ZvbnQtc2l6ZToxZW07bGluZS1oZWlnaHQ6MmVtO3BhZGRpbmc6MDttYXJnaW46MCAwIC4zZW07Zm9udC13ZWlnaHQ6NzAwO2N1cnNvcjpkZWZhdWx0fS52anMtbWVudS1idXR0b24tcG9wdXAgLnZqcy1tZW51e2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDt3aWR0aDoxMGVtO2xlZnQ6LTNlbTtoZWlnaHQ6MDttYXJnaW4tYm90dG9tOjEuNWVtO2JvcmRlci10b3AtY29sb3I6cmdiYSg0Myw1MSw2MywuNyl9LnZqcy1tZW51LWJ1dHRvbi1wb3B1cCAudmpzLW1lbnUgLnZqcy1tZW51LWNvbnRlbnR7YmFja2dyb3VuZC1jb2xvcjojMmIzMzNmO2JhY2tncm91bmQtY29sb3I6cmdiYSg0Myw1MSw2MywuNyk7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJTtib3R0b206MS41ZW07bWF4LWhlaWdodDoxNWVtfS52anMtbWVudS1idXR0b24tcG9wdXAgLnZqcy1tZW51LnZqcy1sb2NrLXNob3dpbmcsLnZqcy13b3JraW5naG92ZXIgLnZqcy1tZW51LWJ1dHRvbi1wb3B1cDpob3ZlciAudmpzLW1lbnV7ZGlzcGxheTpibG9ja30udmlkZW8tanMgLnZqcy1tZW51LWJ1dHRvbi1pbmxpbmV7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuNHM7LW1vei10cmFuc2l0aW9uOmFsbCAuNHM7LW1zLXRyYW5zaXRpb246YWxsIC40czstby10cmFuc2l0aW9uOmFsbCAuNHM7dHJhbnNpdGlvbjphbGwgLjRzO292ZXJmbG93OmhpZGRlbn0udmlkZW8tanMgLnZqcy1tZW51LWJ1dHRvbi1pbmxpbmU6YmVmb3Jle3dpZHRoOjIuMjIyMjIyMjIyZW19LnZpZGVvLWpzIC52anMtbWVudS1idXR0b24taW5saW5lLnZqcy1zbGlkZXItYWN0aXZlLC52aWRlby1qcyAudmpzLW1lbnUtYnV0dG9uLWlubGluZTpmb2N1cywudmlkZW8tanMgLnZqcy1tZW51LWJ1dHRvbi1pbmxpbmU6aG92ZXIsLnZpZGVvLWpzLnZqcy1uby1mbGV4IC52anMtbWVudS1idXR0b24taW5saW5le3dpZHRoOjEyZW19LnZqcy1tZW51LWJ1dHRvbi1pbmxpbmUgLnZqcy1tZW51e29wYWNpdHk6MDtoZWlnaHQ6MTAwJTt3aWR0aDphdXRvO3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6NGVtO3RvcDowO3BhZGRpbmc6MDttYXJnaW46MDstd2Via2l0LXRyYW5zaXRpb246YWxsIC40czstbW96LXRyYW5zaXRpb246YWxsIC40czstbXMtdHJhbnNpdGlvbjphbGwgLjRzOy1vLXRyYW5zaXRpb246YWxsIC40czt0cmFuc2l0aW9uOmFsbCAuNHN9LnZqcy1tZW51LWJ1dHRvbi1pbmxpbmUudmpzLXNsaWRlci1hY3RpdmUgLnZqcy1tZW51LC52anMtbWVudS1idXR0b24taW5saW5lOmZvY3VzIC52anMtbWVudSwudmpzLW1lbnUtYnV0dG9uLWlubGluZTpob3ZlciAudmpzLW1lbnV7ZGlzcGxheTpibG9jaztvcGFjaXR5OjF9LnZqcy1uby1mbGV4IC52anMtbWVudS1idXR0b24taW5saW5lIC52anMtbWVudXtkaXNwbGF5OmJsb2NrO29wYWNpdHk6MTtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDphdXRvfS52anMtbm8tZmxleCAudmpzLW1lbnUtYnV0dG9uLWlubGluZS52anMtc2xpZGVyLWFjdGl2ZSAudmpzLW1lbnUsLnZqcy1uby1mbGV4IC52anMtbWVudS1idXR0b24taW5saW5lOmZvY3VzIC52anMtbWVudSwudmpzLW5vLWZsZXggLnZqcy1tZW51LWJ1dHRvbi1pbmxpbmU6aG92ZXIgLnZqcy1tZW51e3dpZHRoOmF1dG99LnZqcy1tZW51LWJ1dHRvbi1pbmxpbmUgLnZqcy1tZW51LWNvbnRlbnR7d2lkdGg6YXV0bztoZWlnaHQ6MTAwJTttYXJnaW46MDtvdmVyZmxvdzpoaWRkZW59LnZpZGVvLWpzIC52anMtY29udHJvbC1iYXJ7ZGlzcGxheTpub25lO3dpZHRoOjEwMCU7cG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOjA7bGVmdDowO3JpZ2h0OjA7aGVpZ2h0OjNlbTtiYWNrZ3JvdW5kLWNvbG9yOiMyYjMzM2Y7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDQzLDUxLDYzLC43KX0udmpzLWhhcy1zdGFydGVkIC52anMtY29udHJvbC1iYXJ7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi13ZWJraXQtZmxleDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDt2aXNpYmlsaXR5OnZpc2libGU7b3BhY2l0eToxOy13ZWJraXQtdHJhbnNpdGlvbjp2aXNpYmlsaXR5IC4xcyxvcGFjaXR5IC4xczstbW96LXRyYW5zaXRpb246dmlzaWJpbGl0eSAuMXMsb3BhY2l0eSAuMXM7LW1zLXRyYW5zaXRpb246dmlzaWJpbGl0eSAuMXMsb3BhY2l0eSAuMXM7LW8tdHJhbnNpdGlvbjp2aXNpYmlsaXR5IC4xcyxvcGFjaXR5IC4xczt0cmFuc2l0aW9uOnZpc2liaWxpdHkgLjFzLG9wYWNpdHkgLjFzfS52anMtaGFzLXN0YXJ0ZWQudmpzLXVzZXItaW5hY3RpdmUudmpzLXBsYXlpbmcgLnZqcy1jb250cm9sLWJhcnt2aXNpYmlsaXR5OnZpc2libGU7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNpdGlvbjp2aXNpYmlsaXR5IDFzLG9wYWNpdHkgMXM7LW1vei10cmFuc2l0aW9uOnZpc2liaWxpdHkgMXMsb3BhY2l0eSAxczstbXMtdHJhbnNpdGlvbjp2aXNpYmlsaXR5IDFzLG9wYWNpdHkgMXM7LW8tdHJhbnNpdGlvbjp2aXNpYmlsaXR5IDFzLG9wYWNpdHkgMXM7dHJhbnNpdGlvbjp2aXNpYmlsaXR5IDFzLG9wYWNpdHkgMXN9LnZqcy1jb250cm9scy1kaXNhYmxlZCAudmpzLWNvbnRyb2wtYmFyLC52anMtZXJyb3IgLnZqcy1jb250cm9sLWJhciwudmpzLXVzaW5nLW5hdGl2ZS1jb250cm9scyAudmpzLWNvbnRyb2wtYmFye2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9LnZqcy1hdWRpby52anMtaGFzLXN0YXJ0ZWQudmpzLXVzZXItaW5hY3RpdmUudmpzLXBsYXlpbmcgLnZqcy1jb250cm9sLWJhcntvcGFjaXR5OjE7dmlzaWJpbGl0eTp2aXNpYmxlfS52anMtaGFzLXN0YXJ0ZWQudmpzLW5vLWZsZXggLnZqcy1jb250cm9sLWJhcntkaXNwbGF5OnRhYmxlfS52aWRlby1qcyAudmpzLWNvbnRyb2x7cG9zaXRpb246cmVsYXRpdmU7dGV4dC1hbGlnbjpjZW50ZXI7bWFyZ2luOjA7cGFkZGluZzowO2hlaWdodDoxMDAlO3dpZHRoOjRlbTstd2Via2l0LWJveC1mbGV4Om5vbmU7LW1vei1ib3gtZmxleDpub25lOy13ZWJraXQtZmxleDpub25lOy1tcy1mbGV4Om5vbmU7ZmxleDpub25lfS52anMtYnV0dG9uPi52anMtaWNvbi1wbGFjZWhvbGRlcjpiZWZvcmV7Zm9udC1zaXplOjEuOGVtO2xpbmUtaGVpZ2h0OjEuNjd9LnZpZGVvLWpzIC52anMtY29udHJvbDpmb2N1cywudmlkZW8tanMgLnZqcy1jb250cm9sOmZvY3VzOmJlZm9yZSwudmlkZW8tanMgLnZqcy1jb250cm9sOmhvdmVyOmJlZm9yZXt0ZXh0LXNoYWRvdzowIDAgMWVtICNmZmZ9LnZpZGVvLWpzIC52anMtY29udHJvbC10ZXh0e2JvcmRlcjowO2NsaXA6cmVjdCgwIDAgMCAwKTtoZWlnaHQ6MXB4O292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjA7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MXB4fS52anMtbm8tZmxleCAudmpzLWNvbnRyb2x7ZGlzcGxheTp0YWJsZS1jZWxsO3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0udmlkZW8tanMgLnZqcy1jdXN0b20tY29udHJvbC1zcGFjZXJ7ZGlzcGxheTpub25lfS52aWRlby1qcyAudmpzLXByb2dyZXNzLWNvbnRyb2x7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC1ib3gtZmxleDphdXRvOy1tb3otYm94LWZsZXg6YXV0bzstd2Via2l0LWZsZXg6YXV0bzstbXMtZmxleDphdXRvO2ZsZXg6YXV0bztkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LXdlYmtpdC1mbGV4O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstd2Via2l0LWFsaWduLWl0ZW1zOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO21pbi13aWR0aDo0ZW19LnZpZGVvLWpzIC52anMtcHJvZ3Jlc3MtY29udHJvbC5kaXNhYmxlZHtjdXJzb3I6ZGVmYXVsdH0udmpzLWxpdmUgLnZqcy1wcm9ncmVzcy1jb250cm9se2Rpc3BsYXk6bm9uZX0udmpzLW5vLWZsZXggLnZqcy1wcm9ncmVzcy1jb250cm9se3dpZHRoOmF1dG99LnZpZGVvLWpzIC52anMtcHJvZ3Jlc3MtaG9sZGVyey13ZWJraXQtYm94LWZsZXg6YXV0bzstbW96LWJveC1mbGV4OmF1dG87LXdlYmtpdC1mbGV4OmF1dG87LW1zLWZsZXg6YXV0bztmbGV4OmF1dG87LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMnM7LW1vei10cmFuc2l0aW9uOmFsbCAuMnM7LW1zLXRyYW5zaXRpb246YWxsIC4yczstby10cmFuc2l0aW9uOmFsbCAuMnM7dHJhbnNpdGlvbjphbGwgLjJzO2hlaWdodDouM2VtfS52aWRlby1qcyAudmpzLXByb2dyZXNzLWNvbnRyb2wgLnZqcy1wcm9ncmVzcy1ob2xkZXJ7bWFyZ2luOjAgMTBweH0udmlkZW8tanMgLnZqcy1wcm9ncmVzcy1jb250cm9sOmhvdmVyIC52anMtcHJvZ3Jlc3MtaG9sZGVye2ZvbnQtc2l6ZToxLjY2NjY2NjY2NjY2NjY2NjdlbX0udmlkZW8tanMgLnZqcy1wcm9ncmVzcy1jb250cm9sOmhvdmVyIC52anMtcHJvZ3Jlc3MtaG9sZGVyLmRpc2FibGVke2ZvbnQtc2l6ZToxZW19LnZpZGVvLWpzIC52anMtcHJvZ3Jlc3MtaG9sZGVyIC52anMtbG9hZC1wcm9ncmVzcywudmlkZW8tanMgLnZqcy1wcm9ncmVzcy1ob2xkZXIgLnZqcy1sb2FkLXByb2dyZXNzIGRpdiwudmlkZW8tanMgLnZqcy1wcm9ncmVzcy1ob2xkZXIgLnZqcy1wbGF5LXByb2dyZXNze3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7aGVpZ2h0OjEwMCU7bWFyZ2luOjA7cGFkZGluZzowO3dpZHRoOjA7bGVmdDowO3RvcDowfS52aWRlby1qcyAudmpzLXBsYXktcHJvZ3Jlc3N7YmFja2dyb3VuZC1jb2xvcjojZmZmfS52aWRlby1qcyAudmpzLXBsYXktcHJvZ3Jlc3M6YmVmb3Jle2ZvbnQtc2l6ZTouOWVtO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0Oi0uNWVtO3RvcDotLjMzMzMzMzMzMzMzMzMzM2VtO3otaW5kZXg6MX0udmlkZW8tanMgLnZqcy1sb2FkLXByb2dyZXNze2JhY2tncm91bmQ6I2JmYzdkMztiYWNrZ3JvdW5kOnJnYmEoMTE1LDEzMywxNTksLjUpfS52aWRlby1qcyAudmpzLWxvYWQtcHJvZ3Jlc3MgZGl2e2JhY2tncm91bmQ6I2ZmZjtiYWNrZ3JvdW5kOnJnYmEoMTE1LDEzMywxNTksLjc1KX0udmlkZW8tanMgLnZqcy10aW1lLXRvb2x0aXB7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6aHNsYSgwLDAlLDEwMCUsLjgpOy13ZWJraXQtYm9yZGVyLXJhZGl1czouM2VtOy1tb3otYm9yZGVyLXJhZGl1czouM2VtO2JvcmRlci1yYWRpdXM6LjNlbTtjb2xvcjojMDAwO2Zsb2F0OnJpZ2h0O2ZvbnQtZmFtaWx5OkFyaWFsLEhlbHZldGljYSxzYW5zLXNlcmlmO2ZvbnQtc2l6ZToxZW07cGFkZGluZzo2cHggOHB4IDhweDtwb2ludGVyLWV2ZW50czpub25lO3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDotMy40ZW07dmlzaWJpbGl0eTpoaWRkZW47ei1pbmRleDoxfS52aWRlby1qcyAudmpzLXByb2dyZXNzLWhvbGRlcjpmb2N1cyAudmpzLXRpbWUtdG9vbHRpcHtkaXNwbGF5Om5vbmV9LnZpZGVvLWpzIC52anMtcHJvZ3Jlc3MtY29udHJvbDpob3ZlciAudmpzLXByb2dyZXNzLWhvbGRlcjpmb2N1cyAudmpzLXRpbWUtdG9vbHRpcCwudmlkZW8tanMgLnZqcy1wcm9ncmVzcy1jb250cm9sOmhvdmVyIC52anMtdGltZS10b29sdGlwe2Rpc3BsYXk6YmxvY2s7Zm9udC1zaXplOi42ZW07dmlzaWJpbGl0eTp2aXNpYmxlfS52aWRlby1qcyAudmpzLXByb2dyZXNzLWNvbnRyb2wuZGlzYWJsZWQ6aG92ZXIgLnZqcy10aW1lLXRvb2x0aXB7Zm9udC1zaXplOjFlbX0udmlkZW8tanMgLnZqcy1wcm9ncmVzcy1jb250cm9sIC52anMtbW91c2UtZGlzcGxheXtkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MXB4O2hlaWdodDoxMDAlO2JhY2tncm91bmQtY29sb3I6IzAwMDt6LWluZGV4OjF9LnZqcy1uby1mbGV4IC52anMtcHJvZ3Jlc3MtY29udHJvbCAudmpzLW1vdXNlLWRpc3BsYXl7ei1pbmRleDowfS52aWRlby1qcyAudmpzLXByb2dyZXNzLWNvbnRyb2w6aG92ZXIgLnZqcy1tb3VzZS1kaXNwbGF5e2Rpc3BsYXk6YmxvY2t9LnZpZGVvLWpzLnZqcy11c2VyLWluYWN0aXZlIC52anMtcHJvZ3Jlc3MtY29udHJvbCAudmpzLW1vdXNlLWRpc3BsYXl7dmlzaWJpbGl0eTpoaWRkZW47b3BhY2l0eTowOy13ZWJraXQtdHJhbnNpdGlvbjp2aXNpYmlsaXR5IDFzLG9wYWNpdHkgMXM7LW1vei10cmFuc2l0aW9uOnZpc2liaWxpdHkgMXMsb3BhY2l0eSAxczstbXMtdHJhbnNpdGlvbjp2aXNpYmlsaXR5IDFzLG9wYWNpdHkgMXM7LW8tdHJhbnNpdGlvbjp2aXNpYmlsaXR5IDFzLG9wYWNpdHkgMXM7dHJhbnNpdGlvbjp2aXNpYmlsaXR5IDFzLG9wYWNpdHkgMXN9LnZpZGVvLWpzLnZqcy11c2VyLWluYWN0aXZlLnZqcy1uby1mbGV4IC52anMtcHJvZ3Jlc3MtY29udHJvbCAudmpzLW1vdXNlLWRpc3BsYXl7ZGlzcGxheTpub25lfS52anMtbW91c2UtZGlzcGxheSAudmpzLXRpbWUtdG9vbHRpcHtjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzAwMDtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjgpfS52aWRlby1qcyAudmpzLXNsaWRlcntwb3NpdGlvbjpyZWxhdGl2ZTtjdXJzb3I6cG9pbnRlcjtwYWRkaW5nOjA7bWFyZ2luOjAgLjQ1ZW07LXdlYmtpdC10b3VjaC1jYWxsb3V0Om5vbmU7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1raHRtbC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO2JhY2tncm91bmQtY29sb3I6IzczODU5ZjtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMTE1LDEzMywxNTksLjUpfS52aWRlby1qcyAudmpzLXNsaWRlci5kaXNhYmxlZHtjdXJzb3I6ZGVmYXVsdH0udmlkZW8tanMgLnZqcy1zbGlkZXI6Zm9jdXN7dGV4dC1zaGFkb3c6MCAwIDFlbSAjZmZmOy13ZWJraXQtYm94LXNoYWRvdzowIDAgMWVtICNmZmY7LW1vei1ib3gtc2hhZG93OjAgMCAxZW0gI2ZmZjtib3gtc2hhZG93OjAgMCAxZW0gI2ZmZn0udmlkZW8tanMgLnZqcy1tdXRlLWNvbnRyb2x7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC1ib3gtZmxleDpub25lOy1tb3otYm94LWZsZXg6bm9uZTstd2Via2l0LWZsZXg6bm9uZTstbXMtZmxleDpub25lO2ZsZXg6bm9uZTtwYWRkaW5nLWxlZnQ6MmVtO3BhZGRpbmctcmlnaHQ6MmVtO3BhZGRpbmctYm90dG9tOjNlbX0udmlkZW8tanMgLnZqcy12b2x1bWUtY29udHJvbHtjdXJzb3I6cG9pbnRlcjttYXJnaW4tcmlnaHQ6MWVtO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotd2Via2l0LWZsZXg7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXh9LnZpZGVvLWpzIC52anMtdm9sdW1lLWNvbnRyb2wudmpzLXZvbHVtZS1ob3Jpem9udGFse3dpZHRoOjVlbX0udmlkZW8tanMgLnZqcy12b2x1bWUtcGFuZWwgLnZqcy12b2x1bWUtY29udHJvbHt2aXNpYmlsaXR5OnZpc2libGU7b3BhY2l0eTowO3dpZHRoOjFweDtoZWlnaHQ6MXB4O21hcmdpbi1sZWZ0Oi0xcHh9LnZqcy1uby1mbGV4IC52anMtdm9sdW1lLXBhbmVsIC52anMtdm9sdW1lLWNvbnRyb2wudmpzLXZvbHVtZS12ZXJ0aWNhbCwudmpzLW5vLWZsZXggLnZqcy12b2x1bWUtcGFuZWwgLnZqcy12b2x1bWUtY29udHJvbC52anMtdm9sdW1lLXZlcnRpY2FsIC52anMtdm9sdW1lLWJhciwudmpzLW5vLWZsZXggLnZqcy12b2x1bWUtcGFuZWwgLnZqcy12b2x1bWUtY29udHJvbC52anMtdm9sdW1lLXZlcnRpY2FsIC52anMtdm9sdW1lLWxldmVsey1tcy1maWx0ZXI6XFxcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PTApXFxcIn0udmlkZW8tanMgLnZqcy12b2x1bWUtcGFuZWx7LXdlYmtpdC10cmFuc2l0aW9uOndpZHRoIDFzOy1tb3otdHJhbnNpdGlvbjp3aWR0aCAxczstbXMtdHJhbnNpdGlvbjp3aWR0aCAxczstby10cmFuc2l0aW9uOndpZHRoIDFzO3RyYW5zaXRpb246d2lkdGggMXN9LnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsIC52anMtbXV0ZS1jb250cm9sOmhvdmVyfi52anMtdm9sdW1lLWNvbnRyb2wsLnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsIC52anMtdm9sdW1lLWNvbnRyb2wudmpzLXNsaWRlci1hY3RpdmUsLnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsIC52anMtdm9sdW1lLWNvbnRyb2w6YWN0aXZlLC52aWRlby1qcyAudmpzLXZvbHVtZS1wYW5lbCAudmpzLXZvbHVtZS1jb250cm9sOmhvdmVyLC52aWRlby1qcyAudmpzLXZvbHVtZS1wYW5lbDphY3RpdmUgLnZqcy12b2x1bWUtY29udHJvbCwudmlkZW8tanMgLnZqcy12b2x1bWUtcGFuZWw6Zm9jdXMgLnZqcy12b2x1bWUtY29udHJvbCwudmlkZW8tanMgLnZqcy12b2x1bWUtcGFuZWw6aG92ZXIgLnZqcy12b2x1bWUtY29udHJvbHt2aXNpYmlsaXR5OnZpc2libGU7b3BhY2l0eToxO3Bvc2l0aW9uOnJlbGF0aXZlOy13ZWJraXQtdHJhbnNpdGlvbjp2aXNpYmlsaXR5IC4xcyxvcGFjaXR5IC4xcyxoZWlnaHQgLjFzLHdpZHRoIC4xcyxsZWZ0IDBzLHRvcCAwczstbW96LXRyYW5zaXRpb246dmlzaWJpbGl0eSAuMXMsb3BhY2l0eSAuMXMsaGVpZ2h0IC4xcyx3aWR0aCAuMXMsbGVmdCAwcyx0b3AgMHM7LW1zLXRyYW5zaXRpb246dmlzaWJpbGl0eSAuMXMsb3BhY2l0eSAuMXMsaGVpZ2h0IC4xcyx3aWR0aCAuMXMsbGVmdCAwcyx0b3AgMHM7LW8tdHJhbnNpdGlvbjp2aXNpYmlsaXR5IC4xcyxvcGFjaXR5IC4xcyxoZWlnaHQgLjFzLHdpZHRoIC4xcyxsZWZ0IDBzLHRvcCAwczt0cmFuc2l0aW9uOnZpc2liaWxpdHkgLjFzLG9wYWNpdHkgLjFzLGhlaWdodCAuMXMsd2lkdGggLjFzLGxlZnQgMHMsdG9wIDBzfS52aWRlby1qcyAudmpzLXZvbHVtZS1wYW5lbCAudmpzLW11dGUtY29udHJvbDpob3Zlcn4udmpzLXZvbHVtZS1jb250cm9sLnZqcy12b2x1bWUtaG9yaXpvbnRhbCwudmlkZW8tanMgLnZqcy12b2x1bWUtcGFuZWwgLnZqcy12b2x1bWUtY29udHJvbC52anMtc2xpZGVyLWFjdGl2ZS52anMtdm9sdW1lLWhvcml6b250YWwsLnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsIC52anMtdm9sdW1lLWNvbnRyb2w6YWN0aXZlLnZqcy12b2x1bWUtaG9yaXpvbnRhbCwudmlkZW8tanMgLnZqcy12b2x1bWUtcGFuZWwgLnZqcy12b2x1bWUtY29udHJvbDpob3Zlci52anMtdm9sdW1lLWhvcml6b250YWwsLnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsOmFjdGl2ZSAudmpzLXZvbHVtZS1jb250cm9sLnZqcy12b2x1bWUtaG9yaXpvbnRhbCwudmlkZW8tanMgLnZqcy12b2x1bWUtcGFuZWw6Zm9jdXMgLnZqcy12b2x1bWUtY29udHJvbC52anMtdm9sdW1lLWhvcml6b250YWwsLnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsOmhvdmVyIC52anMtdm9sdW1lLWNvbnRyb2wudmpzLXZvbHVtZS1ob3Jpem9udGFse3dpZHRoOjVlbTtoZWlnaHQ6M2VtfS52aWRlby1qcyAudmpzLXZvbHVtZS1wYW5lbCAudmpzLW11dGUtY29udHJvbDpob3Zlcn4udmpzLXZvbHVtZS1jb250cm9sLnZqcy12b2x1bWUtdmVydGljYWwsLnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsIC52anMtbXV0ZS1jb250cm9sOmhvdmVyfi52anMtdm9sdW1lLWNvbnRyb2wudmpzLXZvbHVtZS12ZXJ0aWNhbCAudmpzLXZvbHVtZS1iYXIsLnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsIC52anMtbXV0ZS1jb250cm9sOmhvdmVyfi52anMtdm9sdW1lLWNvbnRyb2wudmpzLXZvbHVtZS12ZXJ0aWNhbCAudmpzLXZvbHVtZS1sZXZlbCwudmlkZW8tanMgLnZqcy12b2x1bWUtcGFuZWwgLnZqcy12b2x1bWUtY29udHJvbC52anMtc2xpZGVyLWFjdGl2ZS52anMtdm9sdW1lLXZlcnRpY2FsLC52aWRlby1qcyAudmpzLXZvbHVtZS1wYW5lbCAudmpzLXZvbHVtZS1jb250cm9sLnZqcy1zbGlkZXItYWN0aXZlLnZqcy12b2x1bWUtdmVydGljYWwgLnZqcy12b2x1bWUtYmFyLC52aWRlby1qcyAudmpzLXZvbHVtZS1wYW5lbCAudmpzLXZvbHVtZS1jb250cm9sLnZqcy1zbGlkZXItYWN0aXZlLnZqcy12b2x1bWUtdmVydGljYWwgLnZqcy12b2x1bWUtbGV2ZWwsLnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsIC52anMtdm9sdW1lLWNvbnRyb2w6YWN0aXZlLnZqcy12b2x1bWUtdmVydGljYWwsLnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsIC52anMtdm9sdW1lLWNvbnRyb2w6YWN0aXZlLnZqcy12b2x1bWUtdmVydGljYWwgLnZqcy12b2x1bWUtYmFyLC52aWRlby1qcyAudmpzLXZvbHVtZS1wYW5lbCAudmpzLXZvbHVtZS1jb250cm9sOmFjdGl2ZS52anMtdm9sdW1lLXZlcnRpY2FsIC52anMtdm9sdW1lLWxldmVsLC52aWRlby1qcyAudmpzLXZvbHVtZS1wYW5lbCAudmpzLXZvbHVtZS1jb250cm9sOmhvdmVyLnZqcy12b2x1bWUtdmVydGljYWwsLnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsIC52anMtdm9sdW1lLWNvbnRyb2w6aG92ZXIudmpzLXZvbHVtZS12ZXJ0aWNhbCAudmpzLXZvbHVtZS1iYXIsLnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsIC52anMtdm9sdW1lLWNvbnRyb2w6aG92ZXIudmpzLXZvbHVtZS12ZXJ0aWNhbCAudmpzLXZvbHVtZS1sZXZlbCwudmlkZW8tanMgLnZqcy12b2x1bWUtcGFuZWw6YWN0aXZlIC52anMtdm9sdW1lLWNvbnRyb2wudmpzLXZvbHVtZS12ZXJ0aWNhbCwudmlkZW8tanMgLnZqcy12b2x1bWUtcGFuZWw6YWN0aXZlIC52anMtdm9sdW1lLWNvbnRyb2wudmpzLXZvbHVtZS12ZXJ0aWNhbCAudmpzLXZvbHVtZS1iYXIsLnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsOmFjdGl2ZSAudmpzLXZvbHVtZS1jb250cm9sLnZqcy12b2x1bWUtdmVydGljYWwgLnZqcy12b2x1bWUtbGV2ZWwsLnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsOmZvY3VzIC52anMtdm9sdW1lLWNvbnRyb2wudmpzLXZvbHVtZS12ZXJ0aWNhbCwudmlkZW8tanMgLnZqcy12b2x1bWUtcGFuZWw6Zm9jdXMgLnZqcy12b2x1bWUtY29udHJvbC52anMtdm9sdW1lLXZlcnRpY2FsIC52anMtdm9sdW1lLWJhciwudmlkZW8tanMgLnZqcy12b2x1bWUtcGFuZWw6Zm9jdXMgLnZqcy12b2x1bWUtY29udHJvbC52anMtdm9sdW1lLXZlcnRpY2FsIC52anMtdm9sdW1lLWxldmVsLC52aWRlby1qcyAudmpzLXZvbHVtZS1wYW5lbDpob3ZlciAudmpzLXZvbHVtZS1jb250cm9sLnZqcy12b2x1bWUtdmVydGljYWwsLnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsOmhvdmVyIC52anMtdm9sdW1lLWNvbnRyb2wudmpzLXZvbHVtZS12ZXJ0aWNhbCAudmpzLXZvbHVtZS1iYXIsLnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsOmhvdmVyIC52anMtdm9sdW1lLWNvbnRyb2wudmpzLXZvbHVtZS12ZXJ0aWNhbCAudmpzLXZvbHVtZS1sZXZlbHstbXMtZmlsdGVyOlxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEoT3BhY2l0eT0xMDApXFxcIn0udmlkZW8tanMgLnZqcy12b2x1bWUtcGFuZWwudmpzLXZvbHVtZS1wYW5lbC1ob3Jpem9udGFsLnZqcy1zbGlkZXItYWN0aXZlLC52aWRlby1qcyAudmpzLXZvbHVtZS1wYW5lbC52anMtdm9sdW1lLXBhbmVsLWhvcml6b250YWw6YWN0aXZlLC52aWRlby1qcyAudmpzLXZvbHVtZS1wYW5lbC52anMtdm9sdW1lLXBhbmVsLWhvcml6b250YWw6aG92ZXJ7d2lkdGg6OWVtOy13ZWJraXQtdHJhbnNpdGlvbjp3aWR0aCAuMXM7LW1vei10cmFuc2l0aW9uOndpZHRoIC4xczstbXMtdHJhbnNpdGlvbjp3aWR0aCAuMXM7LW8tdHJhbnNpdGlvbjp3aWR0aCAuMXM7dHJhbnNpdGlvbjp3aWR0aCAuMXN9LnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsIC52anMtdm9sdW1lLWNvbnRyb2wudmpzLXZvbHVtZS12ZXJ0aWNhbHtoZWlnaHQ6OGVtO3dpZHRoOjNlbTtsZWZ0Oi0zLjVlbTstd2Via2l0LXRyYW5zaXRpb246dmlzaWJpbGl0eSAxcyxvcGFjaXR5IDFzLGhlaWdodCAxcyAxcyx3aWR0aCAxcyAxcyxsZWZ0IDFzIDFzLHRvcCAxcyAxczstbW96LXRyYW5zaXRpb246dmlzaWJpbGl0eSAxcyxvcGFjaXR5IDFzLGhlaWdodCAxcyAxcyx3aWR0aCAxcyAxcyxsZWZ0IDFzIDFzLHRvcCAxcyAxczstbXMtdHJhbnNpdGlvbjp2aXNpYmlsaXR5IDFzLG9wYWNpdHkgMXMsaGVpZ2h0IDFzIDFzLHdpZHRoIDFzIDFzLGxlZnQgMXMgMXMsdG9wIDFzIDFzOy1vLXRyYW5zaXRpb246dmlzaWJpbGl0eSAxcyxvcGFjaXR5IDFzLGhlaWdodCAxcyAxcyx3aWR0aCAxcyAxcyxsZWZ0IDFzIDFzLHRvcCAxcyAxczt0cmFuc2l0aW9uOnZpc2liaWxpdHkgMXMsb3BhY2l0eSAxcyxoZWlnaHQgMXMgMXMsd2lkdGggMXMgMXMsbGVmdCAxcyAxcyx0b3AgMXMgMXN9LnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsIC52anMtdm9sdW1lLWNvbnRyb2wudmpzLXZvbHVtZS1ob3Jpem9udGFsey13ZWJraXQtdHJhbnNpdGlvbjp2aXNpYmlsaXR5IDFzLG9wYWNpdHkgMXMsaGVpZ2h0IDFzIDFzLHdpZHRoIDFzLGxlZnQgMXMgMXMsdG9wIDFzIDFzOy1tb3otdHJhbnNpdGlvbjp2aXNpYmlsaXR5IDFzLG9wYWNpdHkgMXMsaGVpZ2h0IDFzIDFzLHdpZHRoIDFzLGxlZnQgMXMgMXMsdG9wIDFzIDFzOy1tcy10cmFuc2l0aW9uOnZpc2liaWxpdHkgMXMsb3BhY2l0eSAxcyxoZWlnaHQgMXMgMXMsd2lkdGggMXMsbGVmdCAxcyAxcyx0b3AgMXMgMXM7LW8tdHJhbnNpdGlvbjp2aXNpYmlsaXR5IDFzLG9wYWNpdHkgMXMsaGVpZ2h0IDFzIDFzLHdpZHRoIDFzLGxlZnQgMXMgMXMsdG9wIDFzIDFzO3RyYW5zaXRpb246dmlzaWJpbGl0eSAxcyxvcGFjaXR5IDFzLGhlaWdodCAxcyAxcyx3aWR0aCAxcyxsZWZ0IDFzIDFzLHRvcCAxcyAxc30udmlkZW8tanMudmpzLW5vLWZsZXggLnZqcy12b2x1bWUtcGFuZWwgLnZqcy12b2x1bWUtY29udHJvbC52anMtdm9sdW1lLWhvcml6b250YWx7d2lkdGg6NWVtO2hlaWdodDozZW07dmlzaWJpbGl0eTp2aXNpYmxlO29wYWNpdHk6MTtwb3NpdGlvbjpyZWxhdGl2ZTstd2Via2l0LXRyYW5zaXRpb246bm9uZTstbW96LXRyYW5zaXRpb246bm9uZTstbXMtdHJhbnNpdGlvbjpub25lOy1vLXRyYW5zaXRpb246bm9uZTt0cmFuc2l0aW9uOm5vbmV9LnZpZGVvLWpzLnZqcy1uby1mbGV4IC52anMtdm9sdW1lLWNvbnRyb2wudmpzLXZvbHVtZS12ZXJ0aWNhbCwudmlkZW8tanMudmpzLW5vLWZsZXggLnZqcy12b2x1bWUtcGFuZWwgLnZqcy12b2x1bWUtY29udHJvbC52anMtdm9sdW1lLXZlcnRpY2Fse3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTozZW07bGVmdDouNWVtfS52aWRlby1qcyAudmpzLXZvbHVtZS1wYW5lbHtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LXdlYmtpdC1mbGV4O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4fS52aWRlby1qcyAudmpzLXZvbHVtZS1iYXJ7bWFyZ2luOjEuMzVlbSAuNDVlbX0udmpzLXZvbHVtZS1iYXIudmpzLXNsaWRlci1ob3Jpem9udGFse3dpZHRoOjVlbTtoZWlnaHQ6LjNlbX0udmpzLXZvbHVtZS1iYXIudmpzLXNsaWRlci12ZXJ0aWNhbHt3aWR0aDouM2VtO2hlaWdodDo1ZW07bWFyZ2luOjEuMzVlbSBhdXRvfS52aWRlby1qcyAudmpzLXZvbHVtZS1sZXZlbHtwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDtsZWZ0OjA7YmFja2dyb3VuZC1jb2xvcjojZmZmfS52aWRlby1qcyAudmpzLXZvbHVtZS1sZXZlbDpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7Zm9udC1zaXplOi45ZW19LnZqcy1zbGlkZXItdmVydGljYWwgLnZqcy12b2x1bWUtbGV2ZWx7d2lkdGg6LjNlbX0udmpzLXNsaWRlci12ZXJ0aWNhbCAudmpzLXZvbHVtZS1sZXZlbDpiZWZvcmV7dG9wOi0uNWVtO2xlZnQ6LS4zZW19LnZqcy1zbGlkZXItaG9yaXpvbnRhbCAudmpzLXZvbHVtZS1sZXZlbHtoZWlnaHQ6LjNlbX0udmpzLXNsaWRlci1ob3Jpem9udGFsIC52anMtdm9sdW1lLWxldmVsOmJlZm9yZXt0b3A6LS4zZW07cmlnaHQ6LS41ZW19LnZpZGVvLWpzIC52anMtdm9sdW1lLXBhbmVsLnZqcy12b2x1bWUtcGFuZWwtdmVydGljYWx7d2lkdGg6NGVtfS52anMtdm9sdW1lLWJhci52anMtc2xpZGVyLXZlcnRpY2FsIC52anMtdm9sdW1lLWxldmVse2hlaWdodDoxMDAlfS52anMtdm9sdW1lLWJhci52anMtc2xpZGVyLWhvcml6b250YWwgLnZqcy12b2x1bWUtbGV2ZWx7d2lkdGg6MTAwJX0udmlkZW8tanMgLnZqcy12b2x1bWUtdmVydGljYWx7d2lkdGg6M2VtO2hlaWdodDo4ZW07Ym90dG9tOjhlbTtiYWNrZ3JvdW5kLWNvbG9yOiMyYjMzM2Y7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDQzLDUxLDYzLC43KX0udmlkZW8tanMgLnZqcy12b2x1bWUtaG9yaXpvbnRhbCAudmpzLW1lbnV7bGVmdDotMmVtfS52anMtcG9zdGVye2Rpc3BsYXk6aW5saW5lLWJsb2NrO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLXBvc2l0aW9uOjUwJSA1MCU7YmFja2dyb3VuZC1zaXplOmNvbnRhaW47YmFja2dyb3VuZC1jb2xvcjojMDAwO2N1cnNvcjpwb2ludGVyO21hcmdpbjowO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO2hlaWdodDoxMDAlfS52anMtcG9zdGVyLC52anMtcG9zdGVyIGltZ3t2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7cGFkZGluZzowfS52anMtcG9zdGVyIGltZ3tkaXNwbGF5OmJsb2NrO21hcmdpbjowIGF1dG87bWF4LWhlaWdodDoxMDAlO3dpZHRoOjEwMCV9LnZqcy1oYXMtc3RhcnRlZCAudmpzLXBvc3RlcntkaXNwbGF5Om5vbmV9LnZqcy1hdWRpby52anMtaGFzLXN0YXJ0ZWQgLnZqcy1wb3N0ZXJ7ZGlzcGxheTpibG9ja30udmpzLXVzaW5nLW5hdGl2ZS1jb250cm9scyAudmpzLXBvc3RlcntkaXNwbGF5Om5vbmV9LnZpZGVvLWpzIC52anMtbGl2ZS1jb250cm9se2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotd2Via2l0LWZsZXg7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtYWxpZ246ZmxleC1zdGFydDstd2Via2l0LWFsaWduLWl0ZW1zOmZsZXgtc3RhcnQ7LW1zLWZsZXgtYWxpZ246ZmxleC1zdGFydDthbGlnbi1pdGVtczpmbGV4LXN0YXJ0Oy13ZWJraXQtYm94LWZsZXg6YXV0bzstbW96LWJveC1mbGV4OmF1dG87LXdlYmtpdC1mbGV4OmF1dG87LW1zLWZsZXg6YXV0bztmbGV4OmF1dG87Zm9udC1zaXplOjFlbTtsaW5lLWhlaWdodDozZW19LnZqcy1uby1mbGV4IC52anMtbGl2ZS1jb250cm9se2Rpc3BsYXk6dGFibGUtY2VsbDt3aWR0aDphdXRvO3RleHQtYWxpZ246bGVmdH0udmlkZW8tanMgLnZqcy10aW1lLWNvbnRyb2x7LXdlYmtpdC1ib3gtZmxleDpub25lOy1tb3otYm94LWZsZXg6bm9uZTstd2Via2l0LWZsZXg6bm9uZTstbXMtZmxleDpub25lO2ZsZXg6bm9uZTtmb250LXNpemU6MWVtO2xpbmUtaGVpZ2h0OjNlbTttaW4td2lkdGg6MmVtO3dpZHRoOmF1dG87cGFkZGluZy1sZWZ0OjFlbTtwYWRkaW5nLXJpZ2h0OjFlbX0udmlkZW8tanMgLnZqcy1jdXJyZW50LXRpbWUsLnZqcy1saXZlIC52anMtdGltZS1jb250cm9sLC52anMtbm8tZmxleCAudmpzLWN1cnJlbnQtdGltZXtkaXNwbGF5Om5vbmV9LnZqcy1uby1mbGV4IC52anMtcmVtYWluaW5nLXRpbWUudmpzLXRpbWUtY29udHJvbC52anMtY29udHJvbHt3aWR0aDowIWltcG9ydGFudDt3aGl0ZS1zcGFjZTpub3dyYXB9LnZpZGVvLWpzIC52anMtZHVyYXRpb24sLnZqcy1uby1mbGV4IC52anMtZHVyYXRpb257ZGlzcGxheTpub25lfS52anMtdGltZS1kaXZpZGVye2Rpc3BsYXk6bm9uZTtsaW5lLWhlaWdodDozZW19LnZqcy1saXZlIC52anMtdGltZS1kaXZpZGVye2Rpc3BsYXk6bm9uZX0udmlkZW8tanMgLnZqcy1wbGF5LWNvbnRyb2wgLnZqcy1pY29uLXBsYWNlaG9sZGVye2N1cnNvcjpwb2ludGVyOy13ZWJraXQtYm94LWZsZXg6bm9uZTstbW96LWJveC1mbGV4Om5vbmU7LXdlYmtpdC1mbGV4Om5vbmU7LW1zLWZsZXg6bm9uZTtmbGV4Om5vbmV9LnZqcy10ZXh0LXRyYWNrLWRpc3BsYXl7cG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOjNlbTtsZWZ0OjA7cmlnaHQ6MDt0b3A6MDtwb2ludGVyLWV2ZW50czpub25lfS52aWRlby1qcy52anMtdXNlci1pbmFjdGl2ZS52anMtcGxheWluZyAudmpzLXRleHQtdHJhY2stZGlzcGxheXtib3R0b206MWVtfS52aWRlby1qcyAudmpzLXRleHQtdHJhY2t7Zm9udC1zaXplOjEuNGVtO3RleHQtYWxpZ246Y2VudGVyO21hcmdpbi1ib3R0b206LjFlbTtiYWNrZ3JvdW5kLWNvbG9yOiMwMDA7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLC41KX0udmpzLXN1YnRpdGxlc3tjb2xvcjojZmZmfS52anMtY2FwdGlvbnN7Y29sb3I6I2ZjNn0udmpzLXR0LWN1ZXtkaXNwbGF5OmJsb2NrfXZpZGVvOjotd2Via2l0LW1lZGlhLXRleHQtdHJhY2stZGlzcGxheXstbW96LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC0zZW0pOy1tcy10cmFuc2Zvcm06dHJhbnNsYXRlWSgtM2VtKTstby10cmFuc2Zvcm06dHJhbnNsYXRlWSgtM2VtKTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC0zZW0pO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0zZW0pfS52aWRlby1qcy52anMtdXNlci1pbmFjdGl2ZS52anMtcGxheWluZyB2aWRlbzo6LXdlYmtpdC1tZWRpYS10ZXh0LXRyYWNrLWRpc3BsYXl7LW1vei10cmFuc2Zvcm06dHJhbnNsYXRlWSgtMS41ZW0pOy1tcy10cmFuc2Zvcm06dHJhbnNsYXRlWSgtMS41ZW0pOy1vLXRyYW5zZm9ybTp0cmFuc2xhdGVZKC0xLjVlbSk7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtMS41ZW0pO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0xLjVlbSl9LnZpZGVvLWpzIC52anMtZnVsbHNjcmVlbi1jb250cm9se2N1cnNvcjpwb2ludGVyOy13ZWJraXQtYm94LWZsZXg6bm9uZTstbW96LWJveC1mbGV4Om5vbmU7LXdlYmtpdC1mbGV4Om5vbmU7LW1zLWZsZXg6bm9uZTtmbGV4Om5vbmV9LnZqcy1wbGF5YmFjay1yYXRlIC52anMtcGxheWJhY2stcmF0ZS12YWx1ZSwudmpzLXBsYXliYWNrLXJhdGU+LnZqcy1tZW51LWJ1dHRvbntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX0udmpzLXBsYXliYWNrLXJhdGUgLnZqcy1wbGF5YmFjay1yYXRlLXZhbHVle3BvaW50ZXItZXZlbnRzOm5vbmU7Zm9udC1zaXplOjEuNWVtO2xpbmUtaGVpZ2h0OjI7dGV4dC1hbGlnbjpjZW50ZXJ9LnZqcy1wbGF5YmFjay1yYXRlIC52anMtbWVudXt3aWR0aDo0ZW07bGVmdDowfS52anMtZXJyb3IgLnZqcy1lcnJvci1kaXNwbGF5IC52anMtbW9kYWwtZGlhbG9nLWNvbnRlbnR7Zm9udC1zaXplOjEuNGVtO3RleHQtYWxpZ246Y2VudGVyfS52anMtZXJyb3IgLnZqcy1lcnJvci1kaXNwbGF5OmJlZm9yZXtjb2xvcjojZmZmO2NvbnRlbnQ6XFxcIlhcXFwiO2ZvbnQtZmFtaWx5OkFyaWFsLEhlbHZldGljYSxzYW5zLXNlcmlmO2ZvbnQtc2l6ZTo0ZW07bGVmdDowO2xpbmUtaGVpZ2h0OjE7bWFyZ2luLXRvcDotLjVlbTtwb3NpdGlvbjphYnNvbHV0ZTt0ZXh0LXNoYWRvdzouMDVlbSAuMDVlbSAuMWVtICMwMDA7dGV4dC1hbGlnbjpjZW50ZXI7dG9wOjUwJTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7d2lkdGg6MTAwJX0udmpzLWxvYWRpbmctc3Bpbm5lcntkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtsZWZ0OjUwJTttYXJnaW46LTI1cHggMCAwIC0yNXB4O29wYWNpdHk6Ljg1O3RleHQtYWxpZ246bGVmdDtib3JkZXI6NnB4IHNvbGlkIHJnYmEoNDMsNTEsNjMsLjcpO2JveC1zaXppbmc6Ym9yZGVyLWJveDtiYWNrZ3JvdW5kLWNsaXA6cGFkZGluZy1ib3g7d2lkdGg6NTBweDtoZWlnaHQ6NTBweDtib3JkZXItcmFkaXVzOjI1cHg7dmlzaWJpbGl0eTpoaWRkZW59LnZqcy1zZWVraW5nIC52anMtbG9hZGluZy1zcGlubmVyLC52anMtd2FpdGluZyAudmpzLWxvYWRpbmctc3Bpbm5lcntkaXNwbGF5OmJsb2NrO2FuaW1hdGlvbjowcyBsaW5lYXIgLjNzIGZvcndhcmRzIHZqcy1zcGlubmVyLXNob3d9LnZqcy1sb2FkaW5nLXNwaW5uZXI6YWZ0ZXIsLnZqcy1sb2FkaW5nLXNwaW5uZXI6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXCI7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luOi02cHg7Ym94LXNpemluZzppbmhlcml0O3dpZHRoOmluaGVyaXQ7aGVpZ2h0OmluaGVyaXQ7Ym9yZGVyLXJhZGl1czppbmhlcml0O29wYWNpdHk6MTtib3JkZXI6aW5oZXJpdDtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcC1jb2xvcjojZmZmfS52anMtc2Vla2luZyAudmpzLWxvYWRpbmctc3Bpbm5lcjphZnRlciwudmpzLXNlZWtpbmcgLnZqcy1sb2FkaW5nLXNwaW5uZXI6YmVmb3JlLC52anMtd2FpdGluZyAudmpzLWxvYWRpbmctc3Bpbm5lcjphZnRlciwudmpzLXdhaXRpbmcgLnZqcy1sb2FkaW5nLXNwaW5uZXI6YmVmb3Jley13ZWJraXQtYW5pbWF0aW9uOnZqcy1zcGlubmVyLXNwaW4gMS4xcyBjdWJpYy1iZXppZXIoLjYsLjIsMCwuOCkgaW5maW5pdGUsdmpzLXNwaW5uZXItZmFkZSAxLjFzIGxpbmVhciBpbmZpbml0ZTthbmltYXRpb246dmpzLXNwaW5uZXItc3BpbiAxLjFzIGN1YmljLWJlemllciguNiwuMiwwLC44KSBpbmZpbml0ZSx2anMtc3Bpbm5lci1mYWRlIDEuMXMgbGluZWFyIGluZmluaXRlfS52anMtc2Vla2luZyAudmpzLWxvYWRpbmctc3Bpbm5lcjpiZWZvcmUsLnZqcy13YWl0aW5nIC52anMtbG9hZGluZy1zcGlubmVyOmJlZm9yZXtib3JkZXItdG9wLWNvbG9yOiNmZmZ9LnZqcy1zZWVraW5nIC52anMtbG9hZGluZy1zcGlubmVyOmFmdGVyLC52anMtd2FpdGluZyAudmpzLWxvYWRpbmctc3Bpbm5lcjphZnRlcntib3JkZXItdG9wLWNvbG9yOiNmZmY7LXdlYmtpdC1hbmltYXRpb24tZGVsYXk6LjQ0czthbmltYXRpb24tZGVsYXk6LjQ0c31Aa2V5ZnJhbWVzIHZqcy1zcGlubmVyLXNob3d7dG97dmlzaWJpbGl0eTp2aXNpYmxlfX1ALXdlYmtpdC1rZXlmcmFtZXMgdmpzLXNwaW5uZXItc2hvd3t0b3t2aXNpYmlsaXR5OnZpc2libGV9fUBrZXlmcmFtZXMgdmpzLXNwaW5uZXItc3Bpbnt0b3t0cmFuc2Zvcm06cm90YXRlKDF0dXJuKX19QC13ZWJraXQta2V5ZnJhbWVzIHZqcy1zcGlubmVyLXNwaW57dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDF0dXJuKX19QGtleWZyYW1lcyB2anMtc3Bpbm5lci1mYWRlezAle2JvcmRlci10b3AtY29sb3I6IzczODU5Zn0yMCV7Ym9yZGVyLXRvcC1jb2xvcjojNzM4NTlmfTM1JXtib3JkZXItdG9wLWNvbG9yOiNmZmZ9NjAle2JvcmRlci10b3AtY29sb3I6IzczODU5Zn10b3tib3JkZXItdG9wLWNvbG9yOiM3Mzg1OWZ9fUAtd2Via2l0LWtleWZyYW1lcyB2anMtc3Bpbm5lci1mYWRlezAle2JvcmRlci10b3AtY29sb3I6IzczODU5Zn0yMCV7Ym9yZGVyLXRvcC1jb2xvcjojNzM4NTlmfTM1JXtib3JkZXItdG9wLWNvbG9yOiNmZmZ9NjAle2JvcmRlci10b3AtY29sb3I6IzczODU5Zn10b3tib3JkZXItdG9wLWNvbG9yOiM3Mzg1OWZ9fS52anMtY2hhcHRlcnMtYnV0dG9uIC52anMtbWVudSB1bHt3aWR0aDoyNGVtfS52aWRlby1qcyAudmpzLXN1YnMtY2Fwcy1idXR0b24rLnZqcy1tZW51IC52anMtY2FwdGlvbnMtbWVudS1pdGVtIC52anMtbWVudS1pdGVtLXRleHQgLnZqcy1pY29uLXBsYWNlaG9sZGVye3Bvc2l0aW9uOmFic29sdXRlfS52aWRlby1qcyAudmpzLXN1YnMtY2Fwcy1idXR0b24rLnZqcy1tZW51IC52anMtY2FwdGlvbnMtbWVudS1pdGVtIC52anMtbWVudS1pdGVtLXRleHQgLnZqcy1pY29uLXBsYWNlaG9sZGVyOmJlZm9yZXtmb250LWZhbWlseTpWaWRlb0pTO2NvbnRlbnQ6XFxcIlxcXFxGMTBEXFxcIjtmb250LXNpemU6MS41ZW07bGluZS1oZWlnaHQ6aW5oZXJpdH0udmlkZW8tanMudmpzLWxheW91dC10aW55Om5vdCgudmpzLWZ1bGxzY3JlZW4pIC52anMtY3VzdG9tLWNvbnRyb2wtc3BhY2Vyey13ZWJraXQtYm94LWZsZXg6YXV0bzstbW96LWJveC1mbGV4OmF1dG87LXdlYmtpdC1mbGV4OmF1dG87LW1zLWZsZXg6YXV0bztmbGV4OmF1dG99LnZpZGVvLWpzLnZqcy1sYXlvdXQtdGlueTpub3QoLnZqcy1mdWxsc2NyZWVuKS52anMtbm8tZmxleCAudmpzLWN1c3RvbS1jb250cm9sLXNwYWNlcnt3aWR0aDphdXRvfS52aWRlby1qcy52anMtbGF5b3V0LXNtYWxsOm5vdCgudmpzLWZ1bGxzY3JlZW4pIC52anMtY2FwdGlvbnMtYnV0dG9uLC52aWRlby1qcy52anMtbGF5b3V0LXNtYWxsOm5vdCgudmpzLWZ1bGxzY3JlZW4pIC52anMtY2hhcHRlcnMtYnV0dG9uLC52aWRlby1qcy52anMtbGF5b3V0LXNtYWxsOm5vdCgudmpzLWZ1bGxzY3JlZW4pIC52anMtY3VycmVudC10aW1lLC52aWRlby1qcy52anMtbGF5b3V0LXNtYWxsOm5vdCgudmpzLWZ1bGxzY3JlZW4pIC52anMtZGVzY3JpcHRpb25zLWJ1dHRvbiwudmlkZW8tanMudmpzLWxheW91dC1zbWFsbDpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLWR1cmF0aW9uLC52aWRlby1qcy52anMtbGF5b3V0LXNtYWxsOm5vdCgudmpzLWZ1bGxzY3JlZW4pIC52anMtbXV0ZS1jb250cm9sLC52aWRlby1qcy52anMtbGF5b3V0LXNtYWxsOm5vdCgudmpzLWZ1bGxzY3JlZW4pIC52anMtcGxheWJhY2stcmF0ZSwudmlkZW8tanMudmpzLWxheW91dC1zbWFsbDpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLXJlbWFpbmluZy10aW1lLC52aWRlby1qcy52anMtbGF5b3V0LXNtYWxsOm5vdCgudmpzLWZ1bGxzY3JlZW4pIC52anMtc3VidGl0bGVzLWJ1dHRvbiAudmpzLWF1ZGlvLWJ1dHRvbiwudmlkZW8tanMudmpzLWxheW91dC1zbWFsbDpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLXRpbWUtZGl2aWRlciwudmlkZW8tanMudmpzLWxheW91dC1zbWFsbDpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLXZvbHVtZS1jb250cm9sLC52aWRlby1qcy52anMtbGF5b3V0LXRpbnk6bm90KC52anMtZnVsbHNjcmVlbikgLnZqcy1hdWRpby1idXR0b24sLnZpZGVvLWpzLnZqcy1sYXlvdXQtdGlueTpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLWNhcHRpb25zLWJ1dHRvbiwudmlkZW8tanMudmpzLWxheW91dC10aW55Om5vdCgudmpzLWZ1bGxzY3JlZW4pIC52anMtY2hhcHRlcnMtYnV0dG9uLC52aWRlby1qcy52anMtbGF5b3V0LXRpbnk6bm90KC52anMtZnVsbHNjcmVlbikgLnZqcy1jdXJyZW50LXRpbWUsLnZpZGVvLWpzLnZqcy1sYXlvdXQtdGlueTpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLWRlc2NyaXB0aW9ucy1idXR0b24sLnZpZGVvLWpzLnZqcy1sYXlvdXQtdGlueTpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLWR1cmF0aW9uLC52aWRlby1qcy52anMtbGF5b3V0LXRpbnk6bm90KC52anMtZnVsbHNjcmVlbikgLnZqcy1tdXRlLWNvbnRyb2wsLnZpZGVvLWpzLnZqcy1sYXlvdXQtdGlueTpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLXBsYXliYWNrLXJhdGUsLnZpZGVvLWpzLnZqcy1sYXlvdXQtdGlueTpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLXByb2dyZXNzLWNvbnRyb2wsLnZpZGVvLWpzLnZqcy1sYXlvdXQtdGlueTpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLXJlbWFpbmluZy10aW1lLC52aWRlby1qcy52anMtbGF5b3V0LXRpbnk6bm90KC52anMtZnVsbHNjcmVlbikgLnZqcy1zdWJ0aXRsZXMtYnV0dG9uLC52aWRlby1qcy52anMtbGF5b3V0LXRpbnk6bm90KC52anMtZnVsbHNjcmVlbikgLnZqcy10aW1lLWRpdmlkZXIsLnZpZGVvLWpzLnZqcy1sYXlvdXQtdGlueTpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLXZvbHVtZS1jb250cm9sLC52aWRlby1qcy52anMtbGF5b3V0LXgtc21hbGw6bm90KC52anMtZnVsbHNjcmVlbikgLnZqcy1hdWRpby1idXR0b24sLnZpZGVvLWpzLnZqcy1sYXlvdXQteC1zbWFsbDpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLWNhcHRpb25zLWJ1dHRvbiwudmlkZW8tanMudmpzLWxheW91dC14LXNtYWxsOm5vdCgudmpzLWZ1bGxzY3JlZW4pIC52anMtY2hhcHRlcnMtYnV0dG9uLC52aWRlby1qcy52anMtbGF5b3V0LXgtc21hbGw6bm90KC52anMtZnVsbHNjcmVlbikgLnZqcy1jdXJyZW50LXRpbWUsLnZpZGVvLWpzLnZqcy1sYXlvdXQteC1zbWFsbDpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLWRlc2NyaXB0aW9ucy1idXR0b24sLnZpZGVvLWpzLnZqcy1sYXlvdXQteC1zbWFsbDpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLWR1cmF0aW9uLC52aWRlby1qcy52anMtbGF5b3V0LXgtc21hbGw6bm90KC52anMtZnVsbHNjcmVlbikgLnZqcy1tdXRlLWNvbnRyb2wsLnZpZGVvLWpzLnZqcy1sYXlvdXQteC1zbWFsbDpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLXBsYXliYWNrLXJhdGUsLnZpZGVvLWpzLnZqcy1sYXlvdXQteC1zbWFsbDpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLXJlbWFpbmluZy10aW1lLC52aWRlby1qcy52anMtbGF5b3V0LXgtc21hbGw6bm90KC52anMtZnVsbHNjcmVlbikgLnZqcy1zdWJ0aXRsZXMtYnV0dG9uLC52aWRlby1qcy52anMtbGF5b3V0LXgtc21hbGw6bm90KC52anMtZnVsbHNjcmVlbikgLnZqcy10aW1lLWRpdmlkZXIsLnZpZGVvLWpzLnZqcy1sYXlvdXQteC1zbWFsbDpub3QoLnZqcy1mdWxsc2NyZWVuKSAudmpzLXZvbHVtZS1jb250cm9se2Rpc3BsYXk6bm9uZX0udmpzLW1vZGFsLWRpYWxvZy52anMtdGV4dC10cmFjay1zZXR0aW5nc3tiYWNrZ3JvdW5kLWNvbG9yOiMyYjMzM2Y7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDQzLDUxLDYzLC43NSk7Y29sb3I6I2ZmZjtoZWlnaHQ6NzAlfS52anMtdGV4dC10cmFjay1zZXR0aW5ncyAudmpzLW1vZGFsLWRpYWxvZy1jb250ZW50e2Rpc3BsYXk6dGFibGV9LnZqcy10ZXh0LXRyYWNrLXNldHRpbmdzIC52anMtdHJhY2stc2V0dGluZ3MtY29sb3JzLC52anMtdGV4dC10cmFjay1zZXR0aW5ncyAudmpzLXRyYWNrLXNldHRpbmdzLWNvbnRyb2xzLC52anMtdGV4dC10cmFjay1zZXR0aW5ncyAudmpzLXRyYWNrLXNldHRpbmdzLWZvbnR7ZGlzcGxheTp0YWJsZS1jZWxsfS52anMtdGV4dC10cmFjay1zZXR0aW5ncyAudmpzLXRyYWNrLXNldHRpbmdzLWNvbnRyb2xze3RleHQtYWxpZ246cmlnaHQ7dmVydGljYWwtYWxpZ246Ym90dG9tfS52anMtdGV4dC10cmFjay1zZXR0aW5ncyBmaWVsZHNldHttYXJnaW46NXB4O3BhZGRpbmc6M3B4O2JvcmRlcjpub25lfS52anMtdGV4dC10cmFjay1zZXR0aW5ncyBmaWVsZHNldCBzcGFue2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1sZWZ0OjVweH0udmpzLXRleHQtdHJhY2stc2V0dGluZ3MgbGVnZW5ke2NvbG9yOiNmZmY7bWFyZ2luOjAgMCA1cHh9LnZqcy10ZXh0LXRyYWNrLXNldHRpbmdzIC52anMtbGFiZWx7cG9zaXRpb246YWJzb2x1dGU7Y2xpcDpyZWN0KDFweCAxcHggMXB4IDFweCk7Y2xpcDpyZWN0KDFweCwxcHgsMXB4LDFweCk7ZGlzcGxheTpibG9jazttYXJnaW46MCAwIDVweDtwYWRkaW5nOjA7Ym9yZGVyOjA7aGVpZ2h0OjFweDt3aWR0aDoxcHg7b3ZlcmZsb3c6aGlkZGVufS52anMtdHJhY2stc2V0dGluZ3MtY29udHJvbHMgYnV0dG9uOmFjdGl2ZSwudmpzLXRyYWNrLXNldHRpbmdzLWNvbnRyb2xzIGJ1dHRvbjpmb2N1c3tvdXRsaW5lLXN0eWxlOnNvbGlkO291dGxpbmUtd2lkdGg6bWVkaXVtO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KDBkZWcsI2ZmZiA4OCUsIzczODU5Zil9LnZqcy10cmFjay1zZXR0aW5ncy1jb250cm9scyBidXR0b246aG92ZXJ7Y29sb3I6cmdiYSg0Myw1MSw2MywuNzUpfS52anMtdHJhY2stc2V0dGluZ3MtY29udHJvbHMgYnV0dG9ue2JhY2tncm91bmQtY29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCgtMTgwZGVnLCNmZmYgODglLCM3Mzg1OWYpO2NvbG9yOiMyYjMzM2Y7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyLXJhZGl1czoycHh9LnZqcy10cmFjay1zZXR0aW5ncy1jb250cm9scyAudmpzLWRlZmF1bHQtYnV0dG9ue21hcmdpbi1yaWdodDoxZW19QG1lZGlhIHByaW50ey52aWRlby1qcz46bm90KC52anMtdGVjaCk6bm90KC52anMtcG9zdGVyKXt2aXNpYmlsaXR5OmhpZGRlbn19QG1lZGlhIFxcXFwwc2NyZWVuey52anMtdXNlci1pbmFjdGl2ZS52anMtcGxheWluZyAudmpzLWNvbnRyb2wtYmFyIDpiZWZvcmV7Y29udGVudDpcXFwiXFxcIn19QG1lZGlhIFxcXFwwc2NyZWVuey52anMtaGFzLXN0YXJ0ZWQudmpzLXVzZXItaW5hY3RpdmUudmpzLXBsYXlpbmcgLnZqcy1jb250cm9sLWJhcnt2aXNpYmlsaXR5OmhpZGRlbn19XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL25vZGVfbW9kdWxlcy92aWRlby5qcy9kaXN0L3ZpZGVvLWpzLmNzc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///21\n')},function(module,exports){eval("module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qcz85MzExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZSh1cmwpIHtcbiAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgICAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cbiAgICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICAgICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAgIC8vIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG4gICAgaWYgKC9bXCInKCkgXFx0XFxuXS8udGVzdCh1cmwpKSB7XG4gICAgICAgIHJldHVybiAnXCInICsgdXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJykgKyAnXCInXG4gICAgfVxuXG4gICAgcmV0dXJuIHVybFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22\n")},function(module,exports){eval('module.exports = "data:application/vnd.ms-fontobject;base64,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dHRwOi8vZm9udGVsbG8uY29tAFYAaQBkAGUAbwBKAFMAUgBlAGcAdQBsAGEAcgBWAGkAZABlAG8ASgBTAFYAaQBkAGUAbwBKAFMAVgBlAHIAcwBpAG8AbgAgADEALgAwAFYAaQBkAGUAbwBKAFMARwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABzAHYAZwAyAHQAdABmACAAZgByAG8AbQAgAEYAbwBuAHQAZQBsAGwAbwAgAHAAcgBvAGoAZQBjAHQALgBoAHQAdABwADoALwAvAGYAbwBuAHQAZQBsAGwAbwAuAGMAbwBtAAAAAgAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiAARwbGF5C3BsYXktY2lyY2xlBXBhdXNlC3ZvbHVtZS1tdXRlCnZvbHVtZS1sb3cKdm9sdW1lLW1pZAt2b2x1bWUtaGlnaBBmdWxsc2NyZWVuLWVudGVyD2Z1bGxzY3JlZW4tZXhpdAZzcXVhcmUHc3Bpbm5lcglzdWJ0aXRsZXMIY2FwdGlvbnMIY2hhcHRlcnMFc2hhcmUDY29nBmNpcmNsZQ5jaXJjbGUtb3V0bGluZRNjaXJjbGUtaW5uZXItY2lyY2xlAmhkBmNhbmNlbAZyZXBsYXkIZmFjZWJvb2sFZ3BsdXMIbGlua2VkaW4HdHdpdHRlcgZ0dW1ibHIJcGludGVyZXN0EWF1ZGlvLWRlc2NyaXB0aW9uBWF1ZGlvCW5leHQtaXRlbQ1wcmV2aW91cy1pdGVtAAAAAA=="//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8uanMvZGlzdC9mb250L1ZpZGVvSlMuZW90P2YxOWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEscURBQXFEIiwiZmlsZSI6IjIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6YXBwbGljYXRpb24vdm5kLm1zLWZvbnRvYmplY3Q7YmFzZTY0LEtCc0FBSVFhQUFBQkFBSUFBQUFBQUFJQUJRTUFBQUFBQUFBQkFKQUJBQUFBQUV4UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQ1U4ZlZnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBNEFWZ0JwQUdRQVpRQnZBRW9BVXdBQUFBNEFVZ0JsQUdjQWRRQnNBR0VBY2dBQUFCWUFWZ0JsQUhJQWN3QnBBRzhBYmdBZ0FERUFMZ0F3QUFBQURnQldBR2tBWkFCbEFHOEFTZ0JUQUFBQUFBQUFBUUFBQUFzQWdBQURBREJIVTFWQ0lJc2xlZ0FBQVRnQUFBQlVUMU12TWxHSlhkRUFBQUdNQUFBQVZtTnRZWEE1OVBmR0FBQUNhQUFBQXlKbmJIbG1Bd25Td3dBQUJkQUFBQkVJYUdWaFpCTExhRXNBQUFEZ0FBQUFObWhvWldFT0F3Y2hBQUFBdkFBQUFDUm9iWFI0NEFBQUFBQUFBZVFBQUFDRWJHOWpZVDAwUWNZQUFBV01BQUFBUkcxaGVIQUJNZ0NCQUFBQkdBQUFBQ0J1WVcxbDFjZjFvQUFBRnRnQUFBSUtjRzl6ZEVBQ1gvUUFBQmprQUFBQm5nQUJBQUFIQUFBQUFBQUhBQUFBLy84SEFRQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUlRQUJBQUFBQVFBQVZoOVBDVjhQUFBVQUN3Y0FBQUFBQU5aV0RxY0FBQUFBMWxZT3B3QUFBQUFIQVFjQUFBQUFDQUFDQUFBQUFBQUFBQUVBQUFBaEFIVUFCd0FBQUFBQUFnQUFBQW9BQ2dBQUFQOEFBQUFBQUFBQUFRQUFBQW9BTUFBK0FBSkVSa3hVQUE1c1lYUnVBQm9BQkFBQUFBQUFBQUFCQUFBQUJBQUFBQUFBQUFBQkFBQUFBV3hwWjJFQUNBQUFBQUVBQUFBQkFBUUFCQUFBQUFFQUNBQUJBQVlBQUFBQkFBQUFBUWJLQVpBQUJRQUFCSEVFNWdBQUFQb0VjUVRtQUFBRFhBQlhBYzRBQUFJQUJRTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUdaRlpBQkE4UUh4SUFjQUFBQUFvUWNBQUFBQUFBQUJBQUFBQUFBQUFBQUFBQWNBQUFBSEFBQUFCd0FBQUFjQUFBQUhBQUFBQndBQUFBY0FBQUFIQUFBQUJ3QUFBQWNBQUFBSEFBQUFCd0FBQUFjQUFBQUhBQUFBQndBQUFBY0FBQUFIQUFBQUJ3QUFBQWNBQUFBSEFBQUFCd0FBQUFjQUFBQUhBQUFBQndBQUFBY0FBQUFIQUFBQUJ3QUFBQWNBQUFBSEFBQUFCd0FBQUFjQUFBQUhBQUFBQUFBQUJRQUFBQU1BQUFBc0FBQUFCQUFBQVpJQUFRQUFBQUFBakFBREFBRUFBQUFzQUFNQUNnQUFBWklBQkFCZ0FBQUFCQUFFQUFFQUFQRWcvLzhBQVBFQi8vOEFBQUFCQUFRQUFBQUJBQUlBQXdBRUFBVUFCZ0FIQUFnQUNRQUtBQXNBREFBTkFBNEFEd0FRQUJFQUVnQVRBQlFBRlFBV0FCY0FHQUFaQUJvQUd3QWNBQjBBSGdBZkFDQUFBQUVHQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXdBQUFBQUFaQUFBQUFBQUFBQUlBQUE4UUVBQVBFQkFBQUFBUUFBOFFJQUFQRUNBQUFBQWdBQThRTUFBUEVEQUFBQUF3QUE4UVFBQVBFRUFBQUFCQUFBOFFVQUFQRUZBQUFBQlFBQThRWUFBUEVHQUFBQUJnQUE4UWNBQVBFSEFBQUFCd0FBOFFnQUFQRUlBQUFBQ0FBQThRa0FBUEVKQUFBQUNRQUE4UW9BQVBFS0FBQUFDZ0FBOFFzQUFQRUxBQUFBQ3dBQThRd0FBUEVNQUFBQURBQUE4UTBBQVBFTkFBQUFEUUFBOFE0QUFQRU9BQUFBRGdBQThROEFBUEVQQUFBQUR3QUE4UkFBQVBFUUFBQUFFQUFBOFJFQUFQRVJBQUFBRVFBQThSSUFBUEVTQUFBQUVnQUE4Uk1BQVBFVEFBQUFFd0FBOFJRQUFQRVVBQUFBRkFBQThSVUFBUEVWQUFBQUZRQUE4UllBQVBFV0FBQUFGZ0FBOFJjQUFQRVhBQUFBRndBQThSZ0FBUEVZQUFBQUdBQUE4UmtBQVBFWkFBQUFHUUFBOFJvQUFQRWFBQUFBR2dBQThSc0FBUEViQUFBQUd3QUE4UndBQVBFY0FBQUFIQUFBOFIwQUFQRWRBQUFBSFFBQThSNEFBUEVlQUFBQUhnQUE4UjhBQVBFZkFBQUFId0FBOFNBQUFQRWdBQUFBSUFBQUFBQUFBQUFPQUdnQWZnRE1BT0FCQWdGQ0FXd0JtQUhDQWhnQ1dBSzBBdUFETUFPd0E5NEVNQVNXQk53RkpBVm1CWW9HSUFabUJyUUc2Z2RZQ0JJSVdBaHVDSVFBQVFBQUFBQUZpd1dMQUFJQUFBRVJBUUpWQXpZRmkvdnFBZ3NBQUFNQUFBQUFCbXNHYXdBQ0FCc0FOQUFBQ1FJVElnY09BUWNHRUJjZUFSY1dJRGMrQVRjMkVDY3VBU2NtQXlJbkxnRW5KalEzUGdFM05qSVhIZ0VYRmhRSERnRUhCZ0xyQWNEK1FKV1lpNGJPT1RzN09jNkdpd0V3aTRiT09UczdPYzZHaTVoNWIydW1MUzh2TGFacmIvSnZhNll0THk4dHBtdHZBakFCVUFGUUFaczdPYzZHaS83UWk0Yk9PVHM3T2M2R2l3RXdpNGJPT1R2NndDOHRwbXR2OG05cnBpMHZMeTJtYTIveWIydW1MUzhBQUFJQUFBQUFCVUFGaXdBREFBY0FBQUVoRVNrQkVTRVJBY0FCSy83VkFsVUJLd0YxQkJiNzZnUVdBQUFBQkFBQUFBQUdJUVlnQUFjQUZ3QW5BQ29BQUFFMEp5WW5GUmMyTnhRSEZ6WTFOQ2N1QVNjVkhnRVhGZ0VIQVNFUklRRVJBUVlIRlRZM0Z6Y0JCeGNFMERReVZiZ0R1eWx4VFVWRDdwVnNxaTh4KzdSZkFXSCtud0VyQVhVQlBsQlptWHFaWC8xZ25Kd0RnR0ZTVUNxbHVCZ1lZMkp4a3FTZGpJZTlJcG9nazJWcEFpeGYvcC8rUVA2TEFmYit3ajBibWlOa21GOEVscHljQUFBQUFRQUFBQUFFcXdYV0FBVUFBQUVSSVFFUkFRSUxBU29CZHY2S0JHRCtRUDZMQktyK2l3QUFBQUlBQUFBQUJXWUYxZ0FJQUE0QUFBRTBKeVluRVRZM05nRVJJUUVSQVFWbE5ESlVWREkwL0JBQkt3RjEvb3NEZ0dGU1VDcjlwaXBRVWdGQi9rRCtpd1NxL29zQUF3QUFBQUFHSUFZUEFBVUFEZ0FpQUFBVEVTRUJFUUVGTkNjbUp4RTJOellERlI0QkZ4WVVCdzRCQnhVK0FUYzJFQ2N1QWVBQkt3RjEvb3NDeFRReVZWVXlOTHRzcWk4eE1TK3FiSlh1UTBWRlErNEVZUDVBL29zRXF2Nkw0R0ZTVUNyOXBpcFFVZ0x3bWlDVFpXbm9hV1dUSUpvaXZZZU1BVHFNaDcwQUFBQUVBQUFBQUFXTEJZc0FCUUFMQUJFQUZ3QUFBU01SSVRVakF6TTFNelVoQVNNVklSRWpBeFV6RlRNUkFndVdBWGJnbHBiZy9vb0RnT0FCZHBiZzRKWUM2LzZLbGdJSzRKYjhnSllCZGdLZ2x1QUJkZ0FFQUFBQUFBV0xCWXNBQlFBTEFCRUFGd0FBQVRNVk14RWhFeU1WSVJFakFUTTFNelVoRXpVakVTRTFBWFhnbHY2SzRPQUJkcFlCd0piZy9vcVdsZ0YyQWxYZ0FYWUJ3SllCZHZ2cTRKWUJ3T0QraXBZQUFBQUFBZ0FBQUFBRjFnWFdBQk1BRndBQUFTRWlEZ0VWRVJRZUFUTWhNajRCTlJFMExnRURJUkVoQlVEOGdDbEVLQ2hFS1FPQUtVUW9LRVFwL0lBRGdBWFZLRVFwL0lBcFJDZ29SQ2tEZ0NsRUtQdnJBNEFBQmdBQUFBQUdhd1pyQUFnQURRQVZBQjRBSXdBc0FBQUpBU1lqSWdjR0J3RWxMZ0VuQVFVaEFUWTNOalUwQlFFR0J3WVZGQmNoQlI0QkZ3RXpBUll6TWpjMk53RUN2Z0ZrVWxDRWUzWmpBUklEampQdG4vN3VBdVg5MEFGNlhUTTEvQkwrM1Ywek5ROENNUDNrTSsyZkFSSjQvdDFUVDRSN2RtUCs3Z1B3QW1nVExTdFIvaWQzby9vOC9pZEwvWE5tZjRTUFMwc0IrR1ovaEk5TFNrdWorandCMmY0SUV5MHJVUUhaQUFVQUFBQUFCbXNGMWdBVEFCY0FHd0FmQUNNQUFBRWhJZzRCRlJFVUhnRXpJVEkrQVRVUk5DNEJBU0VWSVFFaE5TRUZJVFVoTlNFMUlRWFYrMVlwUlNnb1JTa0VxaWxGS0NoRit5MEJLdjdXQXVyOUZnTHFBY0QrMWdFcS9SWUM2Z1hWS0VRcC9JQXBSQ2dvUkNrRGdDbEVLUDJybGY3VmxaV1ZscFVBQUFBQUF3QUFBQUFHSUFYV0FCTUFLd0JEQUFBQklTSU9BUlVSRkI0Qk15RXlQZ0UxRVRRdUFRRWpOU01WTXpVekZSUUdLd0VpSmpVUk5EWTdBVElXRlFVak5TTVZNelV6RlJRR0t3RWlKalVSTkRZN0FUSVdGUVdMKytvb1JTZ29SU2dFRmloRktDaEYvWUp3bFpWd0t4L2dIeXdzSCtBZkt3SUxjSldWY0N3ZjRCOHJLeC9nSHl3RjFTaEVLZnlBS1VRb0tFUXBBNEFwUkNqOTlpWGdKVW9mTEN3ZkFTb2ZMQ3dmU2lYZ0pVb2ZMQ3dmQVNvZkxDd2ZBQVlBQUFBQUJpQUU5Z0FEQUFjQUN3QVBBQk1BRndBQUV6TTFJeEV6TlNNUk16VWpBU0UxSVJFaE5TRVJGU0UxNEpXVmxaV1ZsUUVyQkJYNzZ3UVYrK3NFRlFNMWx2NUFsUUhBbGY1QWx2NUFsUUpWbFpVQUFBQUJBQUFBQUFZaEJtd0FNUUFBQVNJR0J3RTJOQ2NCSGdFek1qNEJOQzRCSWc0QkZSUVhBUzRCSXlJT0FSUWVBVE15TmpjQkJoVVVIZ0V5UGdFMExnRUZRQ3BMSHYzc0J3Y0NEeDVQS3oxblBEeG5lbWM4Qi8zeEhrOHJQV2M4UEdjOUswOGVBaFFHTzJSMlpEczdaQUpQSGh3Qk54c3lHd0UwSFNBOFozcG5QRHhuUFJrYi9zMGNJRHhuZW1jOElCeit5aGtZTzJRNk9tUjJaRHNBQUFBQUFnQUFBQUFHV1FackFFTUFVQUFBQVRZMEp6YytBU2NETGdFUEFTWXZBUzRCSXlFaUJnOEJCZ2NuSmdZSEF3WVdId0VHRkJjSERnRVhFeDRCUHdFV0h3RWVBVE1oTWpZL0FUWTNGeFkyTnhNMkppY0ZJaTRCTkQ0Qk1oNEJGQTRCQmFzRkJaNEtCZ2VXQnhvTXVqeENIQU1WRHY3V0RoVUNIRVE2dWcwYUI1VUhCUXVkQlFXZEN3VUhsUWNhRGJvN1F4d0NGUTRCS2c0VkFoeEVPcm9OR2dlVkJ3VUwvVGhIZUVaR2VJNTRSa1o0QXpjcVBpcDdDUnNNQVFNTUNRVkxMaHZHRGhJU0RzWWNMVXNGQ1F6Ky9Rd2JDWHNxUGlwN0NSc00vdjBNQ1FWTExodkdEaElTRHNZY0xVc0ZDUXdCQXd3YkNVRkdlSTU0UmtaNGpuaEdBQUVBQUFBQUJtc0dhd0FZQUFBVEZCY2VBUmNXSURjK0FUYzJFQ2N1QVNjbUlBY09BUWNHbFRzNXpvYUxBVENMaHM0NU96czV6b2FML3RDTGhzNDVPd09BbUl1R3pqazdPem5PaG9zQk1JdUd6ams3T3puT2hvc0FBQUFBQWdBQUFBQUdhd1pyQUJnQU1RQUFBU0lIRGdFSEJoQVhIZ0VYRmlBM1BnRTNOaEFuTGdFbkpnTWlKeTRCSnlZME56NEJOell5Rng0QkZ4WVVCdzRCQndZRGdKaUxoczQ1T3pzNXpvYUxBVENMaHM0NU96czV6b2FMbUhsdmE2WXRMeTh0cG10djhtOXJwaTB2THkybWEyOEdhenM1em9hTC90Q0xoczQ1T3pzNXpvYUxBVENMaHM0NU8vckFMeTJtYTIveWIydW1MUzh2TGFacmIvSnZhNll0THdBREFBQUFBQVpyQm1zQUdBQXhBRDRBQUFFaUJ3NEJCd1lRRng0QkZ4WWdOejRCTnpZUUp5NEJKeVlESWljdUFTY21ORGMrQVRjMk1oY2VBUmNXRkFjT0FRY0dFeFFPQVNJdUFUUStBVEllQVFPQW1JcUd6ems3T3puUGhvb0JNSXFHenprN096blBob3FZZVc5cnBpMHZMeTJtYTIveWIydW1MUzh2TGFacmIyYzhaM3BuUER4bmVtYzhCbXM3T2MrR2l2N1Fpb2JQT1RzN09jK0dpZ0V3aW9iUE9UdjZ3Qzh0cG10djhtOXJwaTB2THkybWEyL3liMnVtTFM4Q1ZUMW5QRHhuZW1jOFBHY0FBQUFFQUFBQUFBWWdCaUVBRXdBZkFDa0FMUUFBQVNFaURnRVZFUlFlQVRNaE1qNEJOUkUwTGdFQkl6VWpGU01STXhVek5Uc0JJVElXRlJFVUJpTWhOek0xSXdXTCsrb29SU2dvUlNnRUZpaEZLQ2hGL1lKd2xYQndsWENXQVNvZkxDd2YvdFp3bFpVR0lDaEZLUHZxS0VVb0tFVW9CQllvUlNqOGdKV1ZBY0M3dXl3Zi90WWZMSERnQUFBQUFBSUFBQUFBQm1zR2F3QVlBQ1FBQUFFaUJ3NEJCd1lRRng0QkZ4WWdOejRCTnpZUUp5NEJKeVlUQndrQkp3a0JOd2tCRndFRGdKaUxoczQ1T3pzNXpvYUxBVENMaHM0NU96czV6b2FMM1duKzlQNzBhUUVML3ZWcEFRd0JER24rOVFack96bk9ob3YrMEl1R3pqazdPem5PaG9zQk1JdUd6ams3L0FscEFRdis5V2tCREFFTWFmNzFBUXRwL3ZRQUFBRUFBQUFBQmRZR3RnQW5BQUFCRVFrQkVUSVhGaGNXRkFjR0J3WWlKeVluSmpVakZCY2VBUmNXTWpjK0FUYzJOQ2N1QVNjbUE0RCtpd0YxZW1obU96MDlPMlpvOUdobU96MlZMeTJsYTIvMGIydWxMUzh2TGFWcmJ3V0xBU3IraS82TEFTbzlPMlpvODJsbFBEMDlQR1ZwZVhsdmE2WXRMeTh0cG10djgyOXJwUzR2QUFFQUFBQUFCVDhIQUFBVUFBQUJFU01pQmgwQklRTWpFU0VSSXhFek5UUTJNeklGUDUxV1BBRWxKLzcrenYvLzBLMlRCdlQrK0VoSXZmN1kvUWtDOXdFbzJyck5BQUFBQUFRQUFBQUFCbzRIQUFBd0FFVUFZQUJzQUFBQkZCNERGUlFIQmdRaklpWW5KalUwTmpjMkpTNEJOVFEzQmlNaUpqVTBOamMrQVRNaEJ5TWVBUlVVRGdNbk1qWTNOalUwTGdJaklnWUhCaFVVSGdNVE1qNENOVFF1QVM4QkppOENKaU1pRGdNVkZCNENBVE1WSXhVak5TTTFNelV6QXg5QVcxcEFNRWorNnArRTVUa2xXVXFEQVJFZ0h4VXVGcFRMU0Q5TjAzQUJvb3FEU2t3eFJVWXhraVpRR2pVaVAycEFLbEVaTHhRclBWazJPbXRiTnc0UEV4NEtIQ1ZPRUNBMWFHOVROa1p4ZlFOcjFkVnAxTlJwQStRa1JVTlFnRTVhVTNwelUyQThSMUdLTGxJU0trQXBKREVFd1pSU21qWkNRRmcvakZwSWMwYzdRRDRoR3psbU9vWjlVaWNoTzJVdVoyZFNOUHlYR2pSZVBoa3dKQmdqQ3hjZE9BSU9KRGhkTzBack94MERiR3piMjJ6WkFBTUFBQUFBQm9BR2JBQURBQTRBS2dBQUFSRWhFUUVXQmlzQklpWTBOaklXQVJFaEVUUW1JeUlHQndZVkVTRVNFQzhCSVJValBnTXpNaFlCM2Y2MkFWOEJaMVFDVW1SbnBtUUVqLzYzVVZZL1ZSVUwvcmNDQVFFQlNRSVVLa2RuUDZ2UUJJLzhJUVBmQVRKSlltS1RZV0g4M2YzSUFoSnBkMFV6SGpQOTF3R1BBZkF3TUpBZ01EZ2Y0d0FBQVFBQUFBQUdsQVlBQURFQUFBRUdCeFlWRkFJT0FRUWpJQ2NXTXpJM0xnRW5Gak15Tnk0QlBRRVdGeTRCTlRRM0ZnUVhKalUwTmpNeUZ6WTNCZ2MyQnBSRFh3Rk1tOWIrMHF6KzhlRWpLK0d3YWFZZklSd3JLbkNUUkU1Q1RpeDVBVnZHQ0wyR2pHQnRZQ1ZwWFFWb1lrVU9ISUwrL2U2M2JaRUVpZ0o5WVFVTEY3RjFCQ1lETEk1VFdFdVZzd29tSklhOVpoVTVjejhLQUFBQUFRQUFBQUFGZ0FjQUFDSUFBQUVYRGdFSEJpNEROUkVqTlQ0RU56NEJPd0VSSVJVaEVSUWVBamMyQlRCUUY3QlphSzF3VGlHb1NISkVNQlFGQVFjRTlBRk4vcklOSUVNd1RnSFA3U00rQVFJNFhIaDRPZ0lnMXhwWFhXOVhMUVVIL2xqOC9mb2VORFVlQVFJQUFRQUFBQUFHZ0FhQUFFb0FBQUVVQWdRaklpYzJQd0VlQVRNeVBnRTFOQzRCSXlJT0F4VVVGaGNXUHdFMk56WW5KalUwTmpNeUZoVVVCaU1pSmpjK0FqVTBKaU1pQmhVVUZ3TUdGeVlDTlRRU0pDQUVFZ2FBenY2ZjBXOXJPeE0yRkdvOWViNW9kK0tPYWJaL1d5dFFUUjRJQ0FZQ0JoRXowYW1YcVlsclBVb09DQ1VYTmpJK1ZobGpFUVRPL3M0QllRR2lBV0hPQTREUi9wL09JRjFIMHljNWlmQ1djc2grT21COWhrTm9uaUFNSUI4WUJoY1VQVnFYMmFTRHF1NVhQU04xV1I4eVFuSlZTVEgrWGtacld3Rjg2ZEVCWWM3Ty9wOEFBQWNBQUFBQUJ3RUV6d0FYQUNFQU9BQlBBR1lBY1FCMEFBQUJFVE0yRnhZWEZoY1dGeFlIRGdFSEJnY0dKeVl2QVNZM0ZqWTNOaTRCQnhFVUJSWTNOajhCTmpjMk5UWW5Jd1lYRmg4QkZoY1dGeFFYRmpjMlB3RTJOelkzTmljakJoY1dId0VXRnhZVkZoY1dOelkvQVRZM05qYzJKeU1HRnhZZkFSWVhGaFVXQlRNL0FSVXpFU01HQ3dFQkZTY0RIQnhvTGt3MFBTeE5LeThLQjFWRVIxTTFhRFVxQVFLclVtc0pCekJpUUFGK0doSUxFQW9rRkJjQmZoMEJBd0lHQXljWEd3RWtHaElMRUFva0ZCWUJBWDRlQVFRQ0JRUW5GeHNCSXhrVEN4QUtKQlFXQVFGK0hnRUVBZ1VFSnhjYkFmbEQ3a0hocXMwTjhlOENGbzRCeVFMOUFnRUREQThmTjF4bGVWbVlMekVJQkFFQkFnTUV3Z05XVEVKa05BWCtsUWZDQnhNTElCUkFSMDlUeDYwSUNBVUpCa2RNWEZ2QXVnY1RDeUFVUUVkUFU4ZXRDQWdGQ1FaSFRGeGJ3TG9IRXdzZ0ZFQkhUMVBIclFnSUJRa0dSMHhjVzhEQVpBRmxBd3dWL29QK2hnSDkrUUVBQUFFQUFBQUFCaUVHdGdBc0FBQUJJZ2NPQVFjR0ZSRVVIZ0U3QVJFaE5UUTNQZ0UzTmpJWEhnRVhGaDBCSVJFek1qNEJOUkUwSnk0Qkp5WURnSWw5ZUxvek5UeG5QZUQrMVNrb2tWNWgxR0Zla1NncC90WGdQV2M4TlRPNmVIMEd0VFF6dTNoOWlmMzJQV2M4QWxXVmEyRmVrQ2dwS1NpUVhtRnJsZjJyUEdjOUFncUpmWGk3TXpRQUFBQUFBZ0FBQUFBRlFBVkFBQUlBQmdBQUNRSWhFVE1SQWNBQ2UvMkZBdXVWQWNBQndBSEEvSUFEZ0FBQUFBQUNBQUFBQUFWQUJVQUFBd0FHQUFBQk14RWpDUUVSQWNDVmxRRUZBbnNGUVB5QUFjRCtRQU9BQUFBQUFBQUFFQURHQUFFQUFBQUFBQUVBQndBQUFBRUFBQUFBQUFJQUJ3QUhBQUVBQUFBQUFBTUFCd0FPQUFFQUFBQUFBQVFBQndBVkFBRUFBQUFBQUFVQUN3QWNBQUVBQUFBQUFBWUFCd0FuQUFFQUFBQUFBQW9BS3dBdUFBRUFBQUFBQUFzQUV3QlpBQU1BQVFRSkFBRUFEZ0JzQUFNQUFRUUpBQUlBRGdCNkFBTUFBUVFKQUFNQURnQ0lBQU1BQVFRSkFBUUFEZ0NXQUFNQUFRUUpBQVVBRmdDa0FBTUFBUVFKQUFZQURnQzZBQU1BQVFRSkFBb0FWZ0RJQUFNQUFRUUpBQXNBSmdFZVZtbGtaVzlLVTFKbFozVnNZWEpXYVdSbGIwcFRWbWxrWlc5S1UxWmxjbk5wYjI0Z01TNHdWbWxrWlc5S1UwZGxibVZ5WVhSbFpDQmllU0J6ZG1jeWRIUm1JR1p5YjIwZ1JtOXVkR1ZzYkc4Z2NISnZhbVZqZEM1b2RIUndPaTh2Wm05dWRHVnNiRzh1WTI5dEFGWUFhUUJrQUdVQWJ3QktBRk1BVWdCbEFHY0FkUUJzQUdFQWNnQldBR2tBWkFCbEFHOEFTZ0JUQUZZQWFRQmtBR1VBYndCS0FGTUFWZ0JsQUhJQWN3QnBBRzhBYmdBZ0FERUFMZ0F3QUZZQWFRQmtBR1VBYndCS0FGTUFSd0JsQUc0QVpRQnlBR0VBZEFCbEFHUUFJQUJpQUhrQUlBQnpBSFlBWndBeUFIUUFkQUJtQUNBQVpnQnlBRzhBYlFBZ0FFWUFid0J1QUhRQVpRQnNBR3dBYndBZ0FIQUFjZ0J2QUdvQVpRQmpBSFFBTGdCb0FIUUFkQUJ3QURvQUx3QXZBR1lBYndCdUFIUUFaUUJzQUd3QWJ3QXVBR01BYndCdEFBQUFBZ0FBQUFBQUFBQVJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBaEFRSUJBd0VFQVFVQkJnRUhBUWdCQ1FFS0FRc0JEQUVOQVE0QkR3RVFBUkVCRWdFVEFSUUJGUUVXQVJjQkdBRVpBUm9CR3dFY0FSMEJIZ0VmQVNBQklRRWlBQVJ3YkdGNUMzQnNZWGt0WTJseVkyeGxCWEJoZFhObEMzWnZiSFZ0WlMxdGRYUmxDblp2YkhWdFpTMXNiM2NLZG05c2RXMWxMVzFwWkF0MmIyeDFiV1V0YUdsbmFCQm1kV3hzYzJOeVpXVnVMV1Z1ZEdWeUQyWjFiR3h6WTNKbFpXNHRaWGhwZEFaemNYVmhjbVVIYzNCcGJtNWxjZ2x6ZFdKMGFYUnNaWE1JWTJGd2RHbHZibk1JWTJoaGNIUmxjbk1GYzJoaGNtVURZMjluQm1OcGNtTnNaUTVqYVhKamJHVXRiM1YwYkdsdVpSTmphWEpqYkdVdGFXNXVaWEl0WTJseVkyeGxBbWhrQm1OaGJtTmxiQVp5WlhCc1lYa0labUZqWldKdmIyc0ZaM0JzZFhNSWJHbHVhMlZrYVc0SGRIZHBkSFJsY2daMGRXMWliSElKY0dsdWRHVnlaWE4wRVdGMVpHbHZMV1JsYzJOeWFYQjBhVzl1QldGMVpHbHZDVzVsZUhRdGFYUmxiUTF3Y21WMmFXOTFjeTFwZEdWdEFBQUFBQT09XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92aWRlby5qcy9kaXN0L2ZvbnQvVmlkZW9KUy5lb3Rcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23\n')},function(module,exports){eval('\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function "fixes" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== "undefined" && window.location;\n\n  if (!location) {\n    throw new Error("fixUrls requires window.location");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== "string") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + "//" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, "/");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word "url" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn\'t a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn\'t a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn\'t a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^"(.*)"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^\'(.*)\'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf("//") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf("/") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with \'/\'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, ""); // Strip leading \'./\'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn "url(" + JSON.stringify(newUrl) + ")";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzPzk4OTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiIyNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///24\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_video_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_video_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_video_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_videojs_swf_package_json__ = __webpack_require__(26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_videojs_swf_package_json___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_videojs_swf_package_json__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_global_window__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_global_window___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_global_window__);\n\n\n\n\nvar version$1 = \"2.0.1\";\n\n/**\n * @file flash-rtmp.js\n * @module flash-rtmp\n */\n\n/**\n * Add RTMP properties to the {@link Flash} Tech.\n *\n * @param {Flash} Flash\n *        The flash tech class.\n *\n * @mixin FlashRtmpDecorator\n *\n * @return {Flash}\n *         The flash tech with RTMP properties added.\n */\nfunction FlashRtmpDecorator(Flash) {\n  Flash.streamingFormats = {\n    'rtmp/mp4': 'MP4',\n    'rtmp/flv': 'FLV'\n  };\n\n  /**\n   * Join connection and stream with an ampersand.\n   *\n   * @param {string} connection\n   *        The connection string.\n   *\n   * @param {string} stream\n   *        The stream string.\n   *\n   * @return {string}\n   *         The connection and stream joined with an `&` character\n   */\n  Flash.streamFromParts = function (connection, stream) {\n    return connection + '&' + stream;\n  };\n\n  /**\n   * The flash parts object that contains connection and stream info.\n   *\n   * @typedef {Object} Flash~PartsObject\n   *\n   * @property {string} connection\n   *           The connection string of a source, defaults to an empty string.\n   *\n   * @property {string} stream\n   *           The stream string of the source, defaults to an empty string.\n   */\n\n  /**\n   * Convert a source url into a stream and connection parts.\n   *\n   * @param {string} src\n   *        the source url\n   *\n   * @return {Flash~PartsObject}\n   *         The parts object that contains a connection and a stream\n   */\n  Flash.streamToParts = function (src) {\n    var parts = {\n      connection: '',\n      stream: ''\n    };\n\n    if (!src) {\n      return parts;\n    }\n\n    // Look for the normal URL separator we expect, '&'.\n    // If found, we split the URL into two pieces around the\n    // first '&'.\n    var connEnd = src.search(/&(?!\\w+=)/);\n    var streamBegin = void 0;\n\n    if (connEnd !== -1) {\n      streamBegin = connEnd + 1;\n    } else {\n      // If there's not a '&', we use the last '/' as the delimiter.\n      connEnd = streamBegin = src.lastIndexOf('/') + 1;\n      if (connEnd === 0) {\n        // really, there's not a '/'?\n        connEnd = streamBegin = src.length;\n      }\n    }\n\n    parts.connection = src.substring(0, connEnd);\n    parts.stream = src.substring(streamBegin, src.length);\n\n    return parts;\n  };\n\n  /**\n   * Check if the source type is a streaming type.\n   *\n   * @param {string} srcType\n   *        The mime type to check.\n   *\n   * @return {boolean}\n   *          - True if the source type is a streaming type.\n   *          - False if the source type is not a streaming type.\n   */\n  Flash.isStreamingType = function (srcType) {\n    return srcType in Flash.streamingFormats;\n  };\n\n  // RTMP has four variations, any string starting\n  // with one of these protocols should be valid\n\n  /**\n   * Regular expression used to check if the source is an rtmp source.\n   *\n   * @property {RegExp} Flash.RTMP_RE\n   */\n  Flash.RTMP_RE = /^rtmp[set]?:\\/\\//i;\n\n  /**\n   * Check if the source itself is a streaming type.\n   *\n   * @param {string} src\n   *        The url to the source.\n   *\n   * @return {boolean}\n   *          - True if the source url indicates that the source is streaming.\n   *          - False if the shource url indicates that the source url is not streaming.\n   */\n  Flash.isStreamingSrc = function (src) {\n    return Flash.RTMP_RE.test(src);\n  };\n\n  /**\n   * A source handler for RTMP urls\n   * @type {Object}\n   */\n  Flash.rtmpSourceHandler = {};\n\n  /**\n   * Check if Flash can play the given mime type.\n   *\n   * @param {string} type\n   *        The mime type to check\n   *\n   * @return {string}\n   *         'maybe', or '' (empty string)\n   */\n  Flash.rtmpSourceHandler.canPlayType = function (type) {\n    if (Flash.isStreamingType(type)) {\n      return 'maybe';\n    }\n\n    return '';\n  };\n\n  /**\n   * Check if Flash can handle the source natively\n   *\n   * @param {Object} source\n   *        The source object\n   *\n   * @param {Object} [options]\n   *        The options passed to the tech\n   *\n   * @return {string}\n   *         'maybe', or '' (empty string)\n   */\n  Flash.rtmpSourceHandler.canHandleSource = function (source, options) {\n    var can = Flash.rtmpSourceHandler.canPlayType(source.type);\n\n    if (can) {\n      return can;\n    }\n\n    if (Flash.isStreamingSrc(source.src)) {\n      return 'maybe';\n    }\n\n    return '';\n  };\n\n  /**\n   * Pass the source to the flash object.\n   *\n   * @param {Object} source\n   *        The source object\n   *\n   * @param {Flash} tech\n   *        The instance of the Flash tech\n   *\n   * @param {Object} [options]\n   *        The options to pass to the source\n   */\n  Flash.rtmpSourceHandler.handleSource = function (source, tech, options) {\n    var srcParts = Flash.streamToParts(source.src);\n\n    tech.setRtmpConnection(srcParts.connection);\n    tech.setRtmpStream(srcParts.stream);\n  };\n\n  // Register the native source handler\n  Flash.registerSourceHandler(Flash.rtmpSourceHandler);\n\n  return Flash;\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n\n\n\n\n\n\n\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n/**\n * @file flash.js\n * VideoJS-SWF - Custom Flash Player with HTML5-ish API\n * https://github.com/zencoder/video-js-swf\n * Not using setupTriggers. Using global onEvent func to distribute events\n */\n\nvar Tech = __WEBPACK_IMPORTED_MODULE_0_video_js___default.a.getComponent('Tech');\nvar Dom = __WEBPACK_IMPORTED_MODULE_0_video_js___default.a.dom;\nvar Url = __WEBPACK_IMPORTED_MODULE_0_video_js___default.a.url;\nvar createTimeRange = __WEBPACK_IMPORTED_MODULE_0_video_js___default.a.createTimeRange;\nvar mergeOptions = __WEBPACK_IMPORTED_MODULE_0_video_js___default.a.mergeOptions;\n\nvar navigator = __WEBPACK_IMPORTED_MODULE_2_global_window___default.a && __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.navigator || {};\n\n/**\n * Flash Media Controller - Wrapper for Flash Media API\n *\n * @mixes FlashRtmpDecorator\n * @mixes Tech~SouceHandlerAdditions\n * @extends Tech\n */\n\nvar Flash = function (_Tech) {\n  inherits(Flash, _Tech);\n\n  /**\n   * Create an instance of this Tech.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} ready\n   *        Callback function to call when the `Flash` Tech is ready.\n   */\n  function Flash(options, ready) {\n    classCallCheck(this, Flash);\n\n    // Set the source when ready\n    var _this = possibleConstructorReturn(this, _Tech.call(this, options, ready));\n\n    if (options.source) {\n      _this.ready(function () {\n        this.setSource(options.source);\n      }, true);\n    }\n\n    // Having issues with Flash reloading on certain page actions\n    // (hide/resize/fullscreen) in certain browsers\n    // This allows resetting the playhead when we catch the reload\n    if (options.startTime) {\n      _this.ready(function () {\n        this.load();\n        this.play();\n        this.currentTime(options.startTime);\n      }, true);\n    }\n\n    // Add global window functions that the swf expects\n    // A 4.x workflow we weren't able to solve for in 5.0\n    // because of the need to hard code these functions\n    // into the swf for security reasons\n    __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.videojs = __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.videojs || {};\n    __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.videojs.Flash = __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.videojs.Flash || {};\n    __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.videojs.Flash.onReady = Flash.onReady;\n    __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.videojs.Flash.onEvent = Flash.onEvent;\n    __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.videojs.Flash.onError = Flash.onError;\n\n    _this.on('seeked', function () {\n      this.lastSeekTarget_ = undefined;\n    });\n\n    return _this;\n  }\n\n  /**\n   * Create the `Flash` Tech's DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */\n\n\n  Flash.prototype.createEl = function createEl() {\n    var options = this.options_;\n\n    // If video.js is hosted locally you should also set the location\n    // for the hosted swf, which should be relative to the page (not video.js)\n    // Otherwise this adds a CDN url.\n    // The CDN also auto-adds a swf URL for that specific version.\n    if (!options.swf) {\n      options.swf = '//vjs.zencdn.net/swf/' + __WEBPACK_IMPORTED_MODULE_1_videojs_swf_package_json__[\"version\"] + '/video-js.swf';\n    }\n\n    // Generate ID for swf object\n    var objId = options.techId;\n\n    // Merge default flashvars with ones passed in to init\n    var flashVars = mergeOptions({\n\n      // SWF Callback Functions\n      readyFunction: 'videojs.Flash.onReady',\n      eventProxyFunction: 'videojs.Flash.onEvent',\n      errorEventProxyFunction: 'videojs.Flash.onError',\n\n      // Player Settings\n      autoplay: options.autoplay,\n      preload: options.preload,\n      loop: options.loop,\n      muted: options.muted\n\n    }, options.flashVars);\n\n    // Merge default parames with ones passed in\n    var params = mergeOptions({\n      // Opaque is needed to overlay controls, but can affect playback performance\n      wmode: 'opaque',\n      // Using bgcolor prevents a white flash when the object is loading\n      bgcolor: '#000000'\n    }, options.params);\n\n    // Merge default attributes with ones passed in\n    var attributes = mergeOptions({\n      // Both ID and Name needed or swf to identify itself\n      id: objId,\n      name: objId,\n      'class': 'vjs-tech'\n    }, options.attributes);\n\n    this.el_ = Flash.embed(options.swf, flashVars, params, attributes);\n    this.el_.tech = this;\n\n    return this.el_;\n  };\n\n  /**\n   * Called by {@link Player#play} to play using the `Flash` `Tech`.\n   */\n\n\n  Flash.prototype.play = function play() {\n    if (this.ended()) {\n      this.setCurrentTime(0);\n    }\n    this.el_.vjs_play();\n  };\n\n  /**\n   * Called by {@link Player#pause} to pause using the `Flash` `Tech`.\n   */\n\n\n  Flash.prototype.pause = function pause() {\n    this.el_.vjs_pause();\n  };\n\n  /**\n   * A getter/setter for the `Flash` Tech's source object.\n   * > Note: Please use {@link Flash#setSource}\n   *\n   * @param {Tech~SourceObject} [src]\n   *        The source object you want to set on the `Flash` techs.\n   *\n   * @return {Tech~SourceObject|undefined}\n   *         - The current source object when a source is not passed in.\n   *         - undefined when setting\n   *\n   * @deprecated Since version 5.\n   */\n\n\n  Flash.prototype.src = function src(_src) {\n    if (_src === undefined) {\n      return this.currentSrc();\n    }\n\n    // Setting src through `src` not `setSrc` will be deprecated\n    return this.setSrc(_src);\n  };\n\n  /**\n   * A getter/setter for the `Flash` Tech's source object.\n   *\n   * @param {Tech~SourceObject} [src]\n   *        The source object you want to set on the `Flash` techs.\n   */\n\n\n  Flash.prototype.setSrc = function setSrc(src) {\n    var _this2 = this;\n\n    // Make sure source URL is absolute.\n    src = Url.getAbsoluteURL(src);\n    this.el_.vjs_src(src);\n\n    // Currently the SWF doesn't autoplay if you load a source later.\n    // e.g. Load player w/ no source, wait 2s, set src.\n    if (this.autoplay()) {\n      this.setTimeout(function () {\n        return _this2.play();\n      }, 0);\n    }\n  };\n\n  /**\n   * Indicates whether the media is currently seeking to a new position or not.\n   *\n   * @return {boolean}\n   *         - True if seeking to a new position\n   *         - False otherwise\n   */\n\n\n  Flash.prototype.seeking = function seeking() {\n    return this.lastSeekTarget_ !== undefined;\n  };\n\n  /**\n   * Returns the current time in seconds that the media is at in playback.\n   *\n   * @param {number} time\n   *        Current playtime of the media in seconds.\n   */\n\n\n  Flash.prototype.setCurrentTime = function setCurrentTime(time) {\n    var seekable = this.seekable();\n\n    if (seekable.length) {\n      // clamp to the current seekable range\n      time = time > seekable.start(0) ? time : seekable.start(0);\n      time = time < seekable.end(seekable.length - 1) ? time : seekable.end(seekable.length - 1);\n\n      this.lastSeekTarget_ = time;\n      this.trigger('seeking');\n      this.el_.vjs_setProperty('currentTime', time);\n      _Tech.prototype.setCurrentTime.call(this);\n    }\n  };\n\n  /**\n   * Get the current playback time in seconds\n   *\n   * @return {number}\n   *         The current time of playback in seconds.\n   */\n\n\n  Flash.prototype.currentTime = function currentTime() {\n    // when seeking make the reported time keep up with the requested time\n    // by reading the time we're seeking to\n    if (this.seeking()) {\n      return this.lastSeekTarget_ || 0;\n    }\n    return this.el_.vjs_getProperty('currentTime');\n  };\n\n  /**\n   * Get the current source\n   *\n   * @method currentSrc\n   * @return {Tech~SourceObject}\n   *         The current source\n   */\n\n\n  Flash.prototype.currentSrc = function currentSrc() {\n    if (this.currentSource_) {\n      return this.currentSource_.src;\n    }\n    return this.el_.vjs_getProperty('currentSrc');\n  };\n\n  /**\n   * Get the total duration of the current media.\n   *\n   * @return {number}\n   8          The total duration of the current media.\n   */\n\n\n  Flash.prototype.duration = function duration() {\n    if (this.readyState() === 0) {\n      return NaN;\n    }\n    var duration = this.el_.vjs_getProperty('duration');\n\n    return duration >= 0 ? duration : Infinity;\n  };\n\n  /**\n   * Load media into Tech.\n   */\n\n\n  Flash.prototype.load = function load() {\n    this.el_.vjs_load();\n  };\n\n  /**\n   * Get the poster image that was set on the tech.\n   */\n\n\n  Flash.prototype.poster = function poster() {\n    this.el_.vjs_getProperty('poster');\n  };\n\n  /**\n   * Poster images are not handled by the Flash tech so make this is a no-op.\n   */\n\n\n  Flash.prototype.setPoster = function setPoster() {};\n\n  /**\n   * Determine the time ranges that can be seeked to in the media.\n   *\n   * @return {TimeRange}\n   *         Returns the time ranges that can be seeked to.\n   */\n\n\n  Flash.prototype.seekable = function seekable() {\n    var duration = this.duration();\n\n    if (duration === 0) {\n      return createTimeRange();\n    }\n    return createTimeRange(0, duration);\n  };\n\n  /**\n   * Get and create a `TimeRange` object for buffering.\n   *\n   * @return {TimeRange}\n   *         The time range object that was created.\n   */\n\n\n  Flash.prototype.buffered = function buffered() {\n    var ranges = this.el_.vjs_getProperty('buffered');\n\n    if (ranges.length === 0) {\n      return createTimeRange();\n    }\n    return createTimeRange(ranges[0][0], ranges[0][1]);\n  };\n\n  /**\n   * Get fullscreen support -\n   *\n   * Flash does not allow fullscreen through javascript\n   * so this always returns false.\n   *\n   * @return {boolean}\n   *         The Flash tech does not support fullscreen, so it will always return false.\n   */\n\n\n  Flash.prototype.supportsFullScreen = function supportsFullScreen() {\n    // Flash does not allow fullscreen through javascript\n    return false;\n  };\n\n  /**\n   * Flash does not allow fullscreen through javascript\n   * so this always returns false.\n   *\n   * @return {boolean}\n   *         The Flash tech does not support fullscreen, so it will always return false.\n   */\n\n\n  Flash.prototype.enterFullScreen = function enterFullScreen() {\n    return false;\n  };\n\n  /**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object}\n   *         An object with supported media playback quality metrics\n   */\n\n\n  Flash.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {\n    var videoPlaybackQuality = this.el_.vjs_getProperty('getVideoPlaybackQuality');\n\n    if (__WEBPACK_IMPORTED_MODULE_2_global_window___default.a.performance && typeof __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.performance.now === 'function') {\n      videoPlaybackQuality.creationTime = __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.performance.now();\n    } else if (__WEBPACK_IMPORTED_MODULE_2_global_window___default.a.performance && __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.performance.timing && typeof __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.performance.timing.navigationStart === 'number') {\n      videoPlaybackQuality.creationTime = __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.Date.now() - __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.performance.timing.navigationStart;\n    }\n\n    return videoPlaybackQuality;\n  };\n\n  return Flash;\n}(Tech);\n\n// Create setters and getters for attributes\n\n\nvar _readWrite = ['rtmpConnection', 'rtmpStream', 'preload', 'defaultPlaybackRate', 'playbackRate', 'autoplay', 'loop', 'controls', 'volume', 'muted', 'defaultMuted'];\nvar _readOnly = ['networkState', 'readyState', 'initialTime', 'startOffsetTime', 'paused', 'ended', 'videoWidth', 'videoHeight'];\nvar _api = Flash.prototype;\n\n/**\n * Create setters for the swf on the element\n *\n * @param {string} attr\n *        The name of the parameter\n *\n * @private\n */\nfunction _createSetter(attr) {\n  var attrUpper = attr.charAt(0).toUpperCase() + attr.slice(1);\n\n  _api['set' + attrUpper] = function (val) {\n    return this.el_.vjs_setProperty(attr, val);\n  };\n}\n\n/**\n * Create petters for the swf on the element\n *\n * @param {string} attr\n *        The name of the parameter\n *\n * @private\n */\nfunction _createGetter(attr) {\n  _api[attr] = function () {\n    return this.el_.vjs_getProperty(attr);\n  };\n}\n\n// Create getter and setters for all read/write attributes\nfor (var i = 0; i < _readWrite.length; i++) {\n  _createGetter(_readWrite[i]);\n  _createSetter(_readWrite[i]);\n}\n\n// Create getters for read-only attributes\nfor (var _i = 0; _i < _readOnly.length; _i++) {\n  _createGetter(_readOnly[_i]);\n}\n\n/** ------------------------------ Getters ------------------------------ **/\n/**\n * Get the value of `rtmpConnection` from the swf.\n *\n * @method Flash#rtmpConnection\n * @return {string}\n *         The current value of `rtmpConnection` on the swf.\n */\n\n/**\n * Get the value of `rtmpStream` from the swf.\n *\n * @method Flash#rtmpStream\n * @return {string}\n *         The current value of `rtmpStream` on the swf.\n */\n\n/**\n * Get the value of `preload` from the swf. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Flash#preload\n * @return {string}\n *         The value of `preload` from the swf. Will be 'none', 'metadata',\n *         or 'auto'.\n */\n\n/**\n * Get the value of `defaultPlaybackRate` from the swf.\n *\n * @method Flash#defaultPlaybackRate\n * @return {number}\n *         The current value of `defaultPlaybackRate` on the swf.\n */\n\n/**\n * Get the value of `playbackRate` from the swf. `playbackRate` indicates\n * the rate at which the media is currently playing back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Flash#playbackRate\n * @return {number}\n *         The value of `playbackRate` from the swf. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n */\n\n/**\n * Get the value of `autoplay` from the swf. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Flash#autoplay\n * @return {boolean}\n *         - The value of `autoplay` from the swf.\n *         - True indicates that the media ashould start as soon as the page loads.\n *         - False indicates that the media should not start as soon as the page loads.\n */\n\n/**\n * Get the value of `loop` from the swf. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Flash#loop\n * @return {boolean}\n *         - The value of `loop` from the swf.\n *         - True indicates that playback should seek back to start once\n *           the end of a media is reached.\n *         - False indicates that playback should not loop back to the start when the\n *           end of the media is reached.\n */\n\n/**\n * Get the value of `mediaGroup` from the swf.\n *\n * @method Flash#mediaGroup\n * @return {string}\n *         The current value of `mediaGroup` on the swf.\n */\n\n/**\n * Get the value of `controller` from the swf.\n *\n * @method Flash#controller\n * @return {string}\n *         The current value of `controller` on the swf.\n */\n\n/**\n * Get the value of `controls` from the swf. `controls` indicates\n * whether the native flash controls should be shown or hidden.\n *\n * @method Flash#controls\n * @return {boolean}\n *         - The value of `controls` from the swf.\n *         - True indicates that native controls should be showing.\n *         - False indicates that native controls should be hidden.\n */\n\n/**\n * Get the value of the `volume` from the swf. `volume` indicates the current\n * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and\n * so on.\n *\n * @method Flash#volume\n * @return {number}\n *         The volume percent as a decimal. Value will be between 0-1.\n */\n\n/**\n * Get the value of the `muted` from the swf. `muted` indicates the current\n * audio level should be silent.\n *\n * @method Flash#muted\n * @return {boolean}\n *         - True if the audio should be set to silent\n *         - False otherwise\n */\n\n/**\n * Get the value of `defaultMuted` from the swf. `defaultMuted` indicates\n * whether the media should start muted or not. Only changes the default state of the\n * media. `muted` and `defaultMuted` can have different values. `muted` indicates the\n * current state.\n *\n * @method Flash#defaultMuted\n * @return {boolean}\n *         - The value of `defaultMuted` from the swf.\n *         - True indicates that the media should start muted.\n *         - False indicates that the media should not start muted.\n */\n\n/**\n * Get the value of `networkState` from the swf. `networkState` indicates\n * the current network state. It returns an enumeration from the following list:\n * - 0: NETWORK_EMPTY\n * - 1: NEWORK_IDLE\n * - 2: NETWORK_LOADING\n * - 3: NETWORK_NO_SOURCE\n *\n * @method Flash#networkState\n * @return {number}\n *         The value of `networkState` from the swf. This will be a number\n *         from the list in the description.\n */\n\n/**\n * Get the value of `readyState` from the swf. `readyState` indicates\n * the current state of the media element. It returns an enumeration from the\n * following list:\n * - 0: HAVE_NOTHING\n * - 1: HAVE_METADATA\n * - 2: HAVE_CURRENT_DATA\n * - 3: HAVE_FUTURE_DATA\n * - 4: HAVE_ENOUGH_DATA\n *\n * @method Flash#readyState\n * @return {number}\n *         The value of `readyState` from the swf. This will be a number\n *         from the list in the description.\n */\n\n/**\n * Get the value of `readyState` from the swf. `readyState` indicates\n * the current state of the media element. It returns an enumeration from the\n * following list:\n * - 0: HAVE_NOTHING\n * - 1: HAVE_METADATA\n * - 2: HAVE_CURRENT_DATA\n * - 3: HAVE_FUTURE_DATA\n * - 4: HAVE_ENOUGH_DATA\n *\n * @method Flash#readyState\n * @return {number}\n *         The value of `readyState` from the swf. This will be a number\n *         from the list in the description.\n */\n\n/**\n * Get the value of `initialTime` from the swf.\n *\n * @method Flash#initialTime\n * @return {number}\n *         The `initialTime` proprety on the swf.\n */\n\n/**\n * Get the value of `startOffsetTime` from the swf.\n *\n * @method Flash#startOffsetTime\n * @return {number}\n *         The `startOffsetTime` proprety on the swf.\n */\n\n/**\n * Get the value of `paused` from the swf. `paused` indicates whether the swf\n * is current paused or not.\n *\n * @method Flash#paused\n * @return {boolean}\n *         The value of `paused` from the swf.\n */\n\n/**\n * Get the value of `ended` from the swf. `ended` indicates whether\n * the media has reached the end or not.\n *\n * @method Flash#ended\n * @return {boolean}\n *         - True indicates that the media has ended.\n *         - False indicates that the media has not ended.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}\n */\n\n/**\n * Get the value of `videoWidth` from the swf. `videoWidth` indicates\n * the current width of the media in css pixels.\n *\n * @method Flash#videoWidth\n * @return {number}\n *         The value of `videoWidth` from the swf. This will be a number\n *         in css pixels.\n */\n\n/**\n * Get the value of `videoHeight` from the swf. `videoHeigth` indicates\n * the current height of the media in css pixels.\n *\n * @method Flassh.prototype.videoHeight\n * @return {number}\n *         The value of `videoHeight` from the swf. This will be a number\n *         in css pixels.\n */\n/** ------------------------------ Setters ------------------------------ **/\n\n/**\n * Set the value of `rtmpConnection` on the swf.\n *\n * @method Flash#setRtmpConnection\n * @param {string} rtmpConnection\n *        New value to set the `rtmpConnection` property to.\n */\n\n/**\n * Set the value of `rtmpStream` on the swf.\n *\n * @method Flash#setRtmpStream\n * @param {string} rtmpStream\n *        New value to set the `rtmpStream` property to.\n */\n\n/**\n * Set the value of `preload` on the swf. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Flash#setPreload\n * @param {string} preload\n *        The value of `preload` to set on the swf. Should be 'none', 'metadata',\n *        or 'auto'.\n */\n\n/**\n * Set the value of `defaultPlaybackRate` on the swf.\n *\n * @method Flash#setDefaultPlaybackRate\n * @param {number} defaultPlaybackRate\n *        New value to set the `defaultPlaybackRate` property to.\n */\n\n/**\n * Set the value of `playbackRate` on the swf. `playbackRate` indicates\n * the rate at which the media is currently playing back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Flash#setPlaybackRate\n * @param {number} playbackRate\n *        New value of `playbackRate` on the swf. A number indicating\n *        the current playback speed of the media, where 1 is normal speed.\n */\n\n/**\n * Set the value of `autoplay` on the swf. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Flash#setAutoplay\n * @param {boolean} autoplay\n *        - The value of `autoplay` from the swf.\n *        - True indicates that the media ashould start as soon as the page loads.\n *        - False indicates that the media should not start as soon as the page loads.\n */\n\n/**\n * Set the value of `loop` on the swf. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Flash#setLoop\n * @param {boolean} loop\n *        - True indicates that playback should seek back to start once\n *          the end of a media is reached.\n *        - False indicates that playback should not loop back to the start when the\n *          end of the media is reached.\n */\n\n/**\n * Set the value of `mediaGroup` on the swf.\n *\n * @method Flash#setMediaGroup\n * @param {string} mediaGroup\n *        New value of `mediaGroup` to set on the swf.\n */\n\n/**\n * Set the value of `controller` on the swf.\n *\n * @method Flash#setController\n * @param {string} controller\n *        New value the current value of `controller` on the swf.\n */\n\n/**\n * Get the value of `controls` from the swf. `controls` indicates\n * whether the native flash controls should be shown or hidden.\n *\n * @method Flash#controls\n * @return {boolean}\n *         - The value of `controls` from the swf.\n *         - True indicates that native controls should be showing.\n *         - False indicates that native controls should be hidden.\n */\n\n/**\n * Set the value of the `volume` on the swf. `volume` indicates the current\n * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and\n * so on.\n *\n * @method Flash#setVolume\n * @param {number} percentAsDecimal\n *         The volume percent as a decimal. Value will be between 0-1.\n */\n\n/**\n * Set the value of the `muted` on the swf. `muted` indicates that the current\n * audio level should be silent.\n *\n * @method Flash#setMuted\n * @param {boolean} muted\n *         - True if the audio should be set to silent\n *         - False otherwise\n */\n\n/**\n * Set the value of `defaultMuted` on the swf. `defaultMuted` indicates\n * whether the media should start muted or not. Only changes the default state of the\n * media. `muted` and `defaultMuted` can have different values. `muted` indicates the\n * current state.\n *\n * @method Flash#setDefaultMuted\n * @param {boolean} defaultMuted\n *         - True indicates that the media should start muted.\n *         - False indicates that the media should not start muted.\n */\n\n/* Flash Support Testing -------------------------------------------------------- */\n\n/**\n * Check if the Flash tech is currently supported.\n *\n * @return {boolean}\n *          - True if the flash tech is supported.\n *          - False otherwise.\n */\nFlash.isSupported = function () {\n  return Flash.version()[0] >= 10;\n  // return swfobject.hasFlashPlayerVersion('10');\n};\n\n// Add Source Handler pattern functions to this tech\nTech.withSourceHandlers(Flash);\n\n/*\n * Native source handler for flash,  simply passes the source to the swf element.\n *\n * @property {Tech~SourceObject} source\n *           The source object\n *\n * @property {Flash} tech\n *           The instance of the Flash tech\n */\nFlash.nativeSourceHandler = {};\n\n/**\n * Check if the Flash can play the given mime type.\n *\n * @param {string} type\n *        The mimetype to check\n *\n * @return {string}\n *         'maybe', or '' (empty string)\n */\nFlash.nativeSourceHandler.canPlayType = function (type) {\n  if (type in Flash.formats) {\n    return 'maybe';\n  }\n\n  return '';\n};\n\n/**\n * Check if the media element can handle a source natively.\n *\n * @param {Tech~SourceObject} source\n *         The source object\n *\n * @param {Object} [options]\n *         Options to be passed to the tech.\n *\n * @return {string}\n *         'maybe', or '' (empty string).\n */\nFlash.nativeSourceHandler.canHandleSource = function (source, options) {\n  var type = void 0;\n\n  /**\n   * Guess the mime type of a file if it does not have one\n   *\n   * @param {Tech~SourceObject} src\n   *        The source object to guess the mime type for\n   *\n   * @return {string}\n   *         The mime type that was guessed\n   */\n  function guessMimeType(src) {\n    var ext = Url.getFileExtension(src);\n\n    if (ext) {\n      return 'video/' + ext;\n    }\n    return '';\n  }\n\n  if (!source.type) {\n    type = guessMimeType(source.src);\n  } else {\n    // Strip code information from the type because we don't get that specific\n    type = source.type.replace(/;.*/, '').toLowerCase();\n  }\n\n  return Flash.nativeSourceHandler.canPlayType(type);\n};\n\n/**\n * Pass the source to the swf.\n *\n * @param {Tech~SourceObject} source\n *        The source object\n *\n * @param {Flash} tech\n *        The instance of the Flash tech\n *\n * @param {Object} [options]\n *        The options to pass to the source\n */\nFlash.nativeSourceHandler.handleSource = function (source, tech, options) {\n  tech.setSrc(source.src);\n};\n\n/**\n * noop for native source handler dispose, as cleanup will happen automatically.\n */\nFlash.nativeSourceHandler.dispose = function () {};\n\n// Register the native source handler\nFlash.registerSourceHandler(Flash.nativeSourceHandler);\n\n/**\n * Flash supported mime types.\n *\n * @constant {Object}\n */\nFlash.formats = {\n  'video/flv': 'FLV',\n  'video/x-flv': 'FLV',\n  'video/mp4': 'MP4',\n  'video/m4v': 'MP4'\n};\n\n/**\n * Called when the the swf is \"ready\", and makes sure that the swf is really\n * ready using {@link Flash#checkReady}\n *\n * @param {Object} currSwf\n *        The current swf object\n */\nFlash.onReady = function (currSwf) {\n  var el = Dom.$('#' + currSwf);\n  var tech = el && el.tech;\n\n  // if there is no el then the tech has been disposed\n  // and the tech element was removed from the player div\n  if (tech && tech.el()) {\n    // check that the flash object is really ready\n    Flash.checkReady(tech);\n  }\n};\n\n/**\n * The SWF isn't always ready when it says it is. Sometimes the API functions still\n * need to be added to the object. If it's not ready, we set a timeout to check again\n * shortly.\n *\n * @param {Flash} tech\n *        The instance of the flash tech to check.\n */\nFlash.checkReady = function (tech) {\n  // stop worrying if the tech has been disposed\n  if (!tech.el()) {\n    return;\n  }\n\n  // check if API property exists\n  if (tech.el().vjs_getProperty) {\n    // tell tech it's ready\n    tech.triggerReady();\n  } else {\n    // wait longer\n    this.setTimeout(function () {\n      Flash.checkReady(tech);\n    }, 50);\n  }\n};\n\n/**\n * Trigger events from the swf on the Flash Tech.\n *\n * @param {number} swfID\n *        The id of the swf that had the event\n *\n * @param {string} eventName\n *        The name of the event to trigger\n */\nFlash.onEvent = function (swfID, eventName) {\n  var tech = Dom.$('#' + swfID).tech;\n  var args = Array.prototype.slice.call(arguments, 2);\n\n  // dispatch Flash events asynchronously for two reasons:\n  // - Flash swallows any exceptions generated by javascript it\n  //   invokes\n  // - Flash is suspended until the javascript returns which may cause\n  //   playback performance issues\n  tech.setTimeout(function () {\n    tech.trigger(eventName, args);\n  }, 1);\n};\n\n/**\n * Log errors from the swf on the Flash tech.\n *\n * @param {number} swfID\n *        The id of the swf that had an error.\n *\n * @param {string} err\n *        The error to set on the Flash Tech.\n *\n * @return {MediaError|undefined}\n *          - Returns a MediaError when err is 'srcnotfound'\n *          - Returns undefined otherwise.\n */\nFlash.onError = function (swfID, err) {\n  var tech = Dom.$('#' + swfID).tech;\n\n  // trigger MEDIA_ERR_SRC_NOT_SUPPORTED\n  if (err === 'srcnotfound') {\n    return tech.error(4);\n  }\n\n  // trigger a custom error\n  tech.error('FLASH: ' + err);\n};\n\n/**\n * Get the current version of Flash that is in use on the page.\n *\n * @return {Array}\n *          an array of versions that are available.\n */\nFlash.version = function () {\n  var version$$1 = '0,0,0';\n\n  // IE\n  try {\n    version$$1 = new __WEBPACK_IMPORTED_MODULE_2_global_window___default.a.ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\\D+/g, ',').match(/^,?(.+),?$/)[1];\n\n    // other browsers\n  } catch (e) {\n    try {\n      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {\n        version$$1 = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\\D+/g, ',').match(/^,?(.+),?$/)[1];\n      }\n    } catch (err) {\n      // satisfy linter\n    }\n  }\n  return version$$1.split(',');\n};\n\n/**\n * Only use for non-iframe embeds.\n *\n * @param {Object} swf\n *        The videojs-swf object.\n *\n * @param {Object} flashVars\n *        Names and values to use as flash option variables.\n *\n * @param {Object} params\n *        Style parameters to set on the object.\n *\n * @param {Object} attributes\n *        Attributes to set on the element.\n *\n * @return {Element}\n *          The embeded Flash DOM element.\n */\nFlash.embed = function (swf, flashVars, params, attributes) {\n  var code = Flash.getEmbedCode(swf, flashVars, params, attributes);\n\n  // Get element by embedding code and retrieving created element\n  var obj = Dom.createEl('div', { innerHTML: code }).childNodes[0];\n\n  return obj;\n};\n\n/**\n * Only use for non-iframe embeds.\n *\n * @param {Object} swf\n *        The videojs-swf object.\n *\n * @param {Object} flashVars\n *        Names and values to use as flash option variables.\n *\n * @param {Object} params\n *        Style parameters to set on the object.\n *\n * @param {Object} attributes\n *        Attributes to set on the element.\n *\n * @return {Element}\n *          The embeded Flash DOM element.\n */\nFlash.getEmbedCode = function (swf, flashVars, params, attributes) {\n  var objTag = '<object type=\"application/x-shockwave-flash\" ';\n  var flashVarsString = '';\n  var paramsString = '';\n  var attrsString = '';\n\n  // Convert flash vars to string\n  if (flashVars) {\n    Object.getOwnPropertyNames(flashVars).forEach(function (key) {\n      flashVarsString += key + '=' + flashVars[key] + '&amp;';\n    });\n  }\n\n  // Add swf, flashVars, and other default params\n  params = mergeOptions({\n    movie: swf,\n    flashvars: flashVarsString,\n    // Required to talk to swf\n    allowScriptAccess: 'always',\n    // All should be default, but having security issues.\n    allowNetworking: 'all'\n  }, params);\n\n  // Create param tags string\n  Object.getOwnPropertyNames(params).forEach(function (key) {\n    paramsString += '<param name=\"' + key + '\" value=\"' + params[key] + '\" />';\n  });\n\n  attributes = mergeOptions({\n    // Add swf to attributes (need both for IE and Others to work)\n    data: swf,\n\n    // Default to 100% width/height\n    width: '100%',\n    height: '100%'\n\n  }, attributes);\n\n  // Create Attributes string\n  Object.getOwnPropertyNames(attributes).forEach(function (key) {\n    attrsString += key + '=\"' + attributes[key] + '\" ';\n  });\n\n  return '' + objTag + attrsString + '>' + paramsString + '</object>';\n};\n\n// Run Flash through the RTMP decorator\nFlashRtmpDecorator(Flash);\n\nif (Tech.getTech('Flash')) {\n  __WEBPACK_IMPORTED_MODULE_0_video_js___default.a.log.warn('Not using videojs-flash as it appears to already be registered');\n  __WEBPACK_IMPORTED_MODULE_0_video_js___default.a.log.warn('videojs-flash should only be used with video.js@6 and above');\n} else {\n  __WEBPACK_IMPORTED_MODULE_0_video_js___default.a.registerTech('Flash', Flash);\n}\n\nFlash.VERSION = version$1;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Flash);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1mbGFzaC9kaXN0L3ZpZGVvanMtZmxhc2guZXMuanM/ZTAyMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDa0I7QUFDbEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFPO0FBQ2xCO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmlkZW9qcyBmcm9tICd2aWRlby5qcyc7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAndmlkZW9qcy1zd2YvcGFja2FnZS5qc29uJztcbmltcG9ydCB3aW5kb3cgZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5cbnZhciB2ZXJzaW9uJDEgPSBcIjIuMC4xXCI7XG5cbi8qKlxuICogQGZpbGUgZmxhc2gtcnRtcC5qc1xuICogQG1vZHVsZSBmbGFzaC1ydG1wXG4gKi9cblxuLyoqXG4gKiBBZGQgUlRNUCBwcm9wZXJ0aWVzIHRvIHRoZSB7QGxpbmsgRmxhc2h9IFRlY2guXG4gKlxuICogQHBhcmFtIHtGbGFzaH0gRmxhc2hcbiAqICAgICAgICBUaGUgZmxhc2ggdGVjaCBjbGFzcy5cbiAqXG4gKiBAbWl4aW4gRmxhc2hSdG1wRGVjb3JhdG9yXG4gKlxuICogQHJldHVybiB7Rmxhc2h9XG4gKiAgICAgICAgIFRoZSBmbGFzaCB0ZWNoIHdpdGggUlRNUCBwcm9wZXJ0aWVzIGFkZGVkLlxuICovXG5mdW5jdGlvbiBGbGFzaFJ0bXBEZWNvcmF0b3IoRmxhc2gpIHtcbiAgRmxhc2guc3RyZWFtaW5nRm9ybWF0cyA9IHtcbiAgICAncnRtcC9tcDQnOiAnTVA0JyxcbiAgICAncnRtcC9mbHYnOiAnRkxWJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBKb2luIGNvbm5lY3Rpb24gYW5kIHN0cmVhbSB3aXRoIGFuIGFtcGVyc2FuZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbm5lY3Rpb25cbiAgICogICAgICAgIFRoZSBjb25uZWN0aW9uIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmVhbVxuICAgKiAgICAgICAgVGhlIHN0cmVhbSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgY29ubmVjdGlvbiBhbmQgc3RyZWFtIGpvaW5lZCB3aXRoIGFuIGAmYCBjaGFyYWN0ZXJcbiAgICovXG4gIEZsYXNoLnN0cmVhbUZyb21QYXJ0cyA9IGZ1bmN0aW9uIChjb25uZWN0aW9uLCBzdHJlYW0pIHtcbiAgICByZXR1cm4gY29ubmVjdGlvbiArICcmJyArIHN0cmVhbTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGZsYXNoIHBhcnRzIG9iamVjdCB0aGF0IGNvbnRhaW5zIGNvbm5lY3Rpb24gYW5kIHN0cmVhbSBpbmZvLlxuICAgKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBGbGFzaH5QYXJ0c09iamVjdFxuICAgKlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gY29ubmVjdGlvblxuICAgKiAgICAgICAgICAgVGhlIGNvbm5lY3Rpb24gc3RyaW5nIG9mIGEgc291cmNlLCBkZWZhdWx0cyB0byBhbiBlbXB0eSBzdHJpbmcuXG4gICAqXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdHJlYW1cbiAgICogICAgICAgICAgIFRoZSBzdHJlYW0gc3RyaW5nIG9mIHRoZSBzb3VyY2UsIGRlZmF1bHRzIHRvIGFuIGVtcHR5IHN0cmluZy5cbiAgICovXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBzb3VyY2UgdXJsIGludG8gYSBzdHJlYW0gYW5kIGNvbm5lY3Rpb24gcGFydHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcmNcbiAgICogICAgICAgIHRoZSBzb3VyY2UgdXJsXG4gICAqXG4gICAqIEByZXR1cm4ge0ZsYXNoflBhcnRzT2JqZWN0fVxuICAgKiAgICAgICAgIFRoZSBwYXJ0cyBvYmplY3QgdGhhdCBjb250YWlucyBhIGNvbm5lY3Rpb24gYW5kIGEgc3RyZWFtXG4gICAqL1xuICBGbGFzaC5zdHJlYW1Ub1BhcnRzID0gZnVuY3Rpb24gKHNyYykge1xuICAgIHZhciBwYXJ0cyA9IHtcbiAgICAgIGNvbm5lY3Rpb246ICcnLFxuICAgICAgc3RyZWFtOiAnJ1xuICAgIH07XG5cbiAgICBpZiAoIXNyYykge1xuICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cblxuICAgIC8vIExvb2sgZm9yIHRoZSBub3JtYWwgVVJMIHNlcGFyYXRvciB3ZSBleHBlY3QsICcmJy5cbiAgICAvLyBJZiBmb3VuZCwgd2Ugc3BsaXQgdGhlIFVSTCBpbnRvIHR3byBwaWVjZXMgYXJvdW5kIHRoZVxuICAgIC8vIGZpcnN0ICcmJy5cbiAgICB2YXIgY29ubkVuZCA9IHNyYy5zZWFyY2goLyYoPyFcXHcrPSkvKTtcbiAgICB2YXIgc3RyZWFtQmVnaW4gPSB2b2lkIDA7XG5cbiAgICBpZiAoY29ubkVuZCAhPT0gLTEpIHtcbiAgICAgIHN0cmVhbUJlZ2luID0gY29ubkVuZCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm90IGEgJyYnLCB3ZSB1c2UgdGhlIGxhc3QgJy8nIGFzIHRoZSBkZWxpbWl0ZXIuXG4gICAgICBjb25uRW5kID0gc3RyZWFtQmVnaW4gPSBzcmMubGFzdEluZGV4T2YoJy8nKSArIDE7XG4gICAgICBpZiAoY29ubkVuZCA9PT0gMCkge1xuICAgICAgICAvLyByZWFsbHksIHRoZXJlJ3Mgbm90IGEgJy8nP1xuICAgICAgICBjb25uRW5kID0gc3RyZWFtQmVnaW4gPSBzcmMubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnRzLmNvbm5lY3Rpb24gPSBzcmMuc3Vic3RyaW5nKDAsIGNvbm5FbmQpO1xuICAgIHBhcnRzLnN0cmVhbSA9IHNyYy5zdWJzdHJpbmcoc3RyZWFtQmVnaW4sIHNyYy5sZW5ndGgpO1xuXG4gICAgcmV0dXJuIHBhcnRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgc291cmNlIHR5cGUgaXMgYSBzdHJlYW1pbmcgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNyY1R5cGVcbiAgICogICAgICAgIFRoZSBtaW1lIHR5cGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgc291cmNlIHR5cGUgaXMgYSBzdHJlYW1pbmcgdHlwZS5cbiAgICogICAgICAgICAgLSBGYWxzZSBpZiB0aGUgc291cmNlIHR5cGUgaXMgbm90IGEgc3RyZWFtaW5nIHR5cGUuXG4gICAqL1xuICBGbGFzaC5pc1N0cmVhbWluZ1R5cGUgPSBmdW5jdGlvbiAoc3JjVHlwZSkge1xuICAgIHJldHVybiBzcmNUeXBlIGluIEZsYXNoLnN0cmVhbWluZ0Zvcm1hdHM7XG4gIH07XG5cbiAgLy8gUlRNUCBoYXMgZm91ciB2YXJpYXRpb25zLCBhbnkgc3RyaW5nIHN0YXJ0aW5nXG4gIC8vIHdpdGggb25lIG9mIHRoZXNlIHByb3RvY29scyBzaG91bGQgYmUgdmFsaWRcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gY2hlY2sgaWYgdGhlIHNvdXJjZSBpcyBhbiBydG1wIHNvdXJjZS5cbiAgICpcbiAgICogQHByb3BlcnR5IHtSZWdFeHB9IEZsYXNoLlJUTVBfUkVcbiAgICovXG4gIEZsYXNoLlJUTVBfUkUgPSAvXnJ0bXBbc2V0XT86XFwvXFwvL2k7XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBzb3VyY2UgaXRzZWxmIGlzIGEgc3RyZWFtaW5nIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcmNcbiAgICogICAgICAgIFRoZSB1cmwgdG8gdGhlIHNvdXJjZS5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAgLSBUcnVlIGlmIHRoZSBzb3VyY2UgdXJsIGluZGljYXRlcyB0aGF0IHRoZSBzb3VyY2UgaXMgc3RyZWFtaW5nLlxuICAgKiAgICAgICAgICAtIEZhbHNlIGlmIHRoZSBzaG91cmNlIHVybCBpbmRpY2F0ZXMgdGhhdCB0aGUgc291cmNlIHVybCBpcyBub3Qgc3RyZWFtaW5nLlxuICAgKi9cbiAgRmxhc2guaXNTdHJlYW1pbmdTcmMgPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgcmV0dXJuIEZsYXNoLlJUTVBfUkUudGVzdChzcmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIHNvdXJjZSBoYW5kbGVyIGZvciBSVE1QIHVybHNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIEZsYXNoLnJ0bXBTb3VyY2VIYW5kbGVyID0ge307XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIEZsYXNoIGNhbiBwbGF5IHRoZSBnaXZlbiBtaW1lIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBUaGUgbWltZSB0eXBlIHRvIGNoZWNrXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKi9cbiAgRmxhc2gucnRtcFNvdXJjZUhhbmRsZXIuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmIChGbGFzaC5pc1N0cmVhbWluZ1R5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiAnbWF5YmUnO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgRmxhc2ggY2FuIGhhbmRsZSB0aGUgc291cmNlIG5hdGl2ZWx5XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgdGVjaFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAgICovXG4gIEZsYXNoLnJ0bXBTb3VyY2VIYW5kbGVyLmNhbkhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgY2FuID0gRmxhc2gucnRtcFNvdXJjZUhhbmRsZXIuY2FuUGxheVR5cGUoc291cmNlLnR5cGUpO1xuXG4gICAgaWYgKGNhbikge1xuICAgICAgcmV0dXJuIGNhbjtcbiAgICB9XG5cbiAgICBpZiAoRmxhc2guaXNTdHJlYW1pbmdTcmMoc291cmNlLnNyYykpIHtcbiAgICAgIHJldHVybiAnbWF5YmUnO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogUGFzcyB0aGUgc291cmNlIHRvIHRoZSBmbGFzaCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7Rmxhc2h9IHRlY2hcbiAgICogICAgICAgIFRoZSBpbnN0YW5jZSBvZiB0aGUgRmxhc2ggdGVjaFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBzb3VyY2VcbiAgICovXG4gIEZsYXNoLnJ0bXBTb3VyY2VIYW5kbGVyLmhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRlY2gsIG9wdGlvbnMpIHtcbiAgICB2YXIgc3JjUGFydHMgPSBGbGFzaC5zdHJlYW1Ub1BhcnRzKHNvdXJjZS5zcmMpO1xuXG4gICAgdGVjaC5zZXRSdG1wQ29ubmVjdGlvbihzcmNQYXJ0cy5jb25uZWN0aW9uKTtcbiAgICB0ZWNoLnNldFJ0bXBTdHJlYW0oc3JjUGFydHMuc3RyZWFtKTtcbiAgfTtcblxuICAvLyBSZWdpc3RlciB0aGUgbmF0aXZlIHNvdXJjZSBoYW5kbGVyXG4gIEZsYXNoLnJlZ2lzdGVyU291cmNlSGFuZGxlcihGbGFzaC5ydG1wU291cmNlSGFuZGxlcik7XG5cbiAgcmV0dXJuIEZsYXNoO1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG4vKipcbiAqIEBmaWxlIGZsYXNoLmpzXG4gKiBWaWRlb0pTLVNXRiAtIEN1c3RvbSBGbGFzaCBQbGF5ZXIgd2l0aCBIVE1MNS1pc2ggQVBJXG4gKiBodHRwczovL2dpdGh1Yi5jb20vemVuY29kZXIvdmlkZW8tanMtc3dmXG4gKiBOb3QgdXNpbmcgc2V0dXBUcmlnZ2Vycy4gVXNpbmcgZ2xvYmFsIG9uRXZlbnQgZnVuYyB0byBkaXN0cmlidXRlIGV2ZW50c1xuICovXG5cbnZhciBUZWNoID0gdmlkZW9qcy5nZXRDb21wb25lbnQoJ1RlY2gnKTtcbnZhciBEb20gPSB2aWRlb2pzLmRvbTtcbnZhciBVcmwgPSB2aWRlb2pzLnVybDtcbnZhciBjcmVhdGVUaW1lUmFuZ2UgPSB2aWRlb2pzLmNyZWF0ZVRpbWVSYW5nZTtcbnZhciBtZXJnZU9wdGlvbnMgPSB2aWRlb2pzLm1lcmdlT3B0aW9ucztcblxudmFyIG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yIHx8IHt9O1xuXG4vKipcbiAqIEZsYXNoIE1lZGlhIENvbnRyb2xsZXIgLSBXcmFwcGVyIGZvciBGbGFzaCBNZWRpYSBBUElcbiAqXG4gKiBAbWl4ZXMgRmxhc2hSdG1wRGVjb3JhdG9yXG4gKiBAbWl4ZXMgVGVjaH5Tb3VjZUhhbmRsZXJBZGRpdGlvbnNcbiAqIEBleHRlbmRzIFRlY2hcbiAqL1xuXG52YXIgRmxhc2ggPSBmdW5jdGlvbiAoX1RlY2gpIHtcbiAgaW5oZXJpdHMoRmxhc2gsIF9UZWNoKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgVGVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gcmVhZHlcbiAgICogICAgICAgIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgYEZsYXNoYCBUZWNoIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gRmxhc2gob3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBGbGFzaCk7XG5cbiAgICAvLyBTZXQgdGhlIHNvdXJjZSB3aGVuIHJlYWR5XG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGVjaC5jYWxsKHRoaXMsIG9wdGlvbnMsIHJlYWR5KSk7XG5cbiAgICBpZiAob3B0aW9ucy5zb3VyY2UpIHtcbiAgICAgIF90aGlzLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRTb3VyY2Uob3B0aW9ucy5zb3VyY2UpO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gSGF2aW5nIGlzc3VlcyB3aXRoIEZsYXNoIHJlbG9hZGluZyBvbiBjZXJ0YWluIHBhZ2UgYWN0aW9uc1xuICAgIC8vIChoaWRlL3Jlc2l6ZS9mdWxsc2NyZWVuKSBpbiBjZXJ0YWluIGJyb3dzZXJzXG4gICAgLy8gVGhpcyBhbGxvd3MgcmVzZXR0aW5nIHRoZSBwbGF5aGVhZCB3aGVuIHdlIGNhdGNoIHRoZSByZWxvYWRcbiAgICBpZiAob3B0aW9ucy5zdGFydFRpbWUpIHtcbiAgICAgIF90aGlzLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lKG9wdGlvbnMuc3RhcnRUaW1lKTtcbiAgICAgIH0sIHRydWUpO1xuICAgIH1cblxuICAgIC8vIEFkZCBnbG9iYWwgd2luZG93IGZ1bmN0aW9ucyB0aGF0IHRoZSBzd2YgZXhwZWN0c1xuICAgIC8vIEEgNC54IHdvcmtmbG93IHdlIHdlcmVuJ3QgYWJsZSB0byBzb2x2ZSBmb3IgaW4gNS4wXG4gICAgLy8gYmVjYXVzZSBvZiB0aGUgbmVlZCB0byBoYXJkIGNvZGUgdGhlc2UgZnVuY3Rpb25zXG4gICAgLy8gaW50byB0aGUgc3dmIGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgd2luZG93LnZpZGVvanMgPSB3aW5kb3cudmlkZW9qcyB8fCB7fTtcbiAgICB3aW5kb3cudmlkZW9qcy5GbGFzaCA9IHdpbmRvdy52aWRlb2pzLkZsYXNoIHx8IHt9O1xuICAgIHdpbmRvdy52aWRlb2pzLkZsYXNoLm9uUmVhZHkgPSBGbGFzaC5vblJlYWR5O1xuICAgIHdpbmRvdy52aWRlb2pzLkZsYXNoLm9uRXZlbnQgPSBGbGFzaC5vbkV2ZW50O1xuICAgIHdpbmRvdy52aWRlb2pzLkZsYXNoLm9uRXJyb3IgPSBGbGFzaC5vbkVycm9yO1xuXG4gICAgX3RoaXMub24oJ3NlZWtlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubGFzdFNlZWtUYXJnZXRfID0gdW5kZWZpbmVkO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYEZsYXNoYCBUZWNoJ3MgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgRmxhc2gucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNfO1xuXG4gICAgLy8gSWYgdmlkZW8uanMgaXMgaG9zdGVkIGxvY2FsbHkgeW91IHNob3VsZCBhbHNvIHNldCB0aGUgbG9jYXRpb25cbiAgICAvLyBmb3IgdGhlIGhvc3RlZCBzd2YsIHdoaWNoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgcGFnZSAobm90IHZpZGVvLmpzKVxuICAgIC8vIE90aGVyd2lzZSB0aGlzIGFkZHMgYSBDRE4gdXJsLlxuICAgIC8vIFRoZSBDRE4gYWxzbyBhdXRvLWFkZHMgYSBzd2YgVVJMIGZvciB0aGF0IHNwZWNpZmljIHZlcnNpb24uXG4gICAgaWYgKCFvcHRpb25zLnN3Zikge1xuICAgICAgb3B0aW9ucy5zd2YgPSAnLy92anMuemVuY2RuLm5ldC9zd2YvJyArIHZlcnNpb24gKyAnL3ZpZGVvLWpzLnN3Zic7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgSUQgZm9yIHN3ZiBvYmplY3RcbiAgICB2YXIgb2JqSWQgPSBvcHRpb25zLnRlY2hJZDtcblxuICAgIC8vIE1lcmdlIGRlZmF1bHQgZmxhc2h2YXJzIHdpdGggb25lcyBwYXNzZWQgaW4gdG8gaW5pdFxuICAgIHZhciBmbGFzaFZhcnMgPSBtZXJnZU9wdGlvbnMoe1xuXG4gICAgICAvLyBTV0YgQ2FsbGJhY2sgRnVuY3Rpb25zXG4gICAgICByZWFkeUZ1bmN0aW9uOiAndmlkZW9qcy5GbGFzaC5vblJlYWR5JyxcbiAgICAgIGV2ZW50UHJveHlGdW5jdGlvbjogJ3ZpZGVvanMuRmxhc2gub25FdmVudCcsXG4gICAgICBlcnJvckV2ZW50UHJveHlGdW5jdGlvbjogJ3ZpZGVvanMuRmxhc2gub25FcnJvcicsXG5cbiAgICAgIC8vIFBsYXllciBTZXR0aW5nc1xuICAgICAgYXV0b3BsYXk6IG9wdGlvbnMuYXV0b3BsYXksXG4gICAgICBwcmVsb2FkOiBvcHRpb25zLnByZWxvYWQsXG4gICAgICBsb29wOiBvcHRpb25zLmxvb3AsXG4gICAgICBtdXRlZDogb3B0aW9ucy5tdXRlZFxuXG4gICAgfSwgb3B0aW9ucy5mbGFzaFZhcnMpO1xuXG4gICAgLy8gTWVyZ2UgZGVmYXVsdCBwYXJhbWVzIHdpdGggb25lcyBwYXNzZWQgaW5cbiAgICB2YXIgcGFyYW1zID0gbWVyZ2VPcHRpb25zKHtcbiAgICAgIC8vIE9wYXF1ZSBpcyBuZWVkZWQgdG8gb3ZlcmxheSBjb250cm9scywgYnV0IGNhbiBhZmZlY3QgcGxheWJhY2sgcGVyZm9ybWFuY2VcbiAgICAgIHdtb2RlOiAnb3BhcXVlJyxcbiAgICAgIC8vIFVzaW5nIGJnY29sb3IgcHJldmVudHMgYSB3aGl0ZSBmbGFzaCB3aGVuIHRoZSBvYmplY3QgaXMgbG9hZGluZ1xuICAgICAgYmdjb2xvcjogJyMwMDAwMDAnXG4gICAgfSwgb3B0aW9ucy5wYXJhbXMpO1xuXG4gICAgLy8gTWVyZ2UgZGVmYXVsdCBhdHRyaWJ1dGVzIHdpdGggb25lcyBwYXNzZWQgaW5cbiAgICB2YXIgYXR0cmlidXRlcyA9IG1lcmdlT3B0aW9ucyh7XG4gICAgICAvLyBCb3RoIElEIGFuZCBOYW1lIG5lZWRlZCBvciBzd2YgdG8gaWRlbnRpZnkgaXRzZWxmXG4gICAgICBpZDogb2JqSWQsXG4gICAgICBuYW1lOiBvYmpJZCxcbiAgICAgICdjbGFzcyc6ICd2anMtdGVjaCdcbiAgICB9LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuXG4gICAgdGhpcy5lbF8gPSBGbGFzaC5lbWJlZChvcHRpb25zLnN3ZiwgZmxhc2hWYXJzLCBwYXJhbXMsIGF0dHJpYnV0ZXMpO1xuICAgIHRoaXMuZWxfLnRlY2ggPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuZWxfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgYnkge0BsaW5rIFBsYXllciNwbGF5fSB0byBwbGF5IHVzaW5nIHRoZSBgRmxhc2hgIGBUZWNoYC5cbiAgICovXG5cblxuICBGbGFzaC5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgaWYgKHRoaXMuZW5kZWQoKSkge1xuICAgICAgdGhpcy5zZXRDdXJyZW50VGltZSgwKTtcbiAgICB9XG4gICAgdGhpcy5lbF8udmpzX3BsYXkoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIGJ5IHtAbGluayBQbGF5ZXIjcGF1c2V9IHRvIHBhdXNlIHVzaW5nIHRoZSBgRmxhc2hgIGBUZWNoYC5cbiAgICovXG5cblxuICBGbGFzaC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICB0aGlzLmVsXy52anNfcGF1c2UoKTtcbiAgfTtcblxuICAvKipcbiAgICogQSBnZXR0ZXIvc2V0dGVyIGZvciB0aGUgYEZsYXNoYCBUZWNoJ3Mgc291cmNlIG9iamVjdC5cbiAgICogPiBOb3RlOiBQbGVhc2UgdXNlIHtAbGluayBGbGFzaCNzZXRTb3VyY2V9XG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IFtzcmNdXG4gICAqICAgICAgICBUaGUgc291cmNlIG9iamVjdCB5b3Ugd2FudCB0byBzZXQgb24gdGhlIGBGbGFzaGAgdGVjaHMuXG4gICAqXG4gICAqIEByZXR1cm4ge1RlY2h+U291cmNlT2JqZWN0fHVuZGVmaW5lZH1cbiAgICogICAgICAgICAtIFRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3Qgd2hlbiBhIHNvdXJjZSBpcyBub3QgcGFzc2VkIGluLlxuICAgKiAgICAgICAgIC0gdW5kZWZpbmVkIHdoZW4gc2V0dGluZ1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBTaW5jZSB2ZXJzaW9uIDUuXG4gICAqL1xuXG5cbiAgRmxhc2gucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uIHNyYyhfc3JjKSB7XG4gICAgaWYgKF9zcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNyYygpO1xuICAgIH1cblxuICAgIC8vIFNldHRpbmcgc3JjIHRocm91Z2ggYHNyY2Agbm90IGBzZXRTcmNgIHdpbGwgYmUgZGVwcmVjYXRlZFxuICAgIHJldHVybiB0aGlzLnNldFNyYyhfc3JjKTtcbiAgfTtcblxuICAvKipcbiAgICogQSBnZXR0ZXIvc2V0dGVyIGZvciB0aGUgYEZsYXNoYCBUZWNoJ3Mgc291cmNlIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gW3NyY11cbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0IHlvdSB3YW50IHRvIHNldCBvbiB0aGUgYEZsYXNoYCB0ZWNocy5cbiAgICovXG5cblxuICBGbGFzaC5wcm90b3R5cGUuc2V0U3JjID0gZnVuY3Rpb24gc2V0U3JjKHNyYykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgLy8gTWFrZSBzdXJlIHNvdXJjZSBVUkwgaXMgYWJzb2x1dGUuXG4gICAgc3JjID0gVXJsLmdldEFic29sdXRlVVJMKHNyYyk7XG4gICAgdGhpcy5lbF8udmpzX3NyYyhzcmMpO1xuXG4gICAgLy8gQ3VycmVudGx5IHRoZSBTV0YgZG9lc24ndCBhdXRvcGxheSBpZiB5b3UgbG9hZCBhIHNvdXJjZSBsYXRlci5cbiAgICAvLyBlLmcuIExvYWQgcGxheWVyIHcvIG5vIHNvdXJjZSwgd2FpdCAycywgc2V0IHNyYy5cbiAgICBpZiAodGhpcy5hdXRvcGxheSgpKSB7XG4gICAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnBsYXkoKTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBzZWVraW5nIHRvIGEgbmV3IHBvc2l0aW9uIG9yIG5vdC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIFRydWUgaWYgc2Vla2luZyB0byBhIG5ldyBwb3NpdGlvblxuICAgKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuXG5cbiAgRmxhc2gucHJvdG90eXBlLnNlZWtpbmcgPSBmdW5jdGlvbiBzZWVraW5nKCkge1xuICAgIHJldHVybiB0aGlzLmxhc3RTZWVrVGFyZ2V0XyAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRpbWUgaW4gc2Vjb25kcyB0aGF0IHRoZSBtZWRpYSBpcyBhdCBpbiBwbGF5YmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcbiAgICogICAgICAgIEN1cnJlbnQgcGxheXRpbWUgb2YgdGhlIG1lZGlhIGluIHNlY29uZHMuXG4gICAqL1xuXG5cbiAgRmxhc2gucHJvdG90eXBlLnNldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24gc2V0Q3VycmVudFRpbWUodGltZSkge1xuICAgIHZhciBzZWVrYWJsZSA9IHRoaXMuc2Vla2FibGUoKTtcblxuICAgIGlmIChzZWVrYWJsZS5sZW5ndGgpIHtcbiAgICAgIC8vIGNsYW1wIHRvIHRoZSBjdXJyZW50IHNlZWthYmxlIHJhbmdlXG4gICAgICB0aW1lID0gdGltZSA+IHNlZWthYmxlLnN0YXJ0KDApID8gdGltZSA6IHNlZWthYmxlLnN0YXJ0KDApO1xuICAgICAgdGltZSA9IHRpbWUgPCBzZWVrYWJsZS5lbmQoc2Vla2FibGUubGVuZ3RoIC0gMSkgPyB0aW1lIDogc2Vla2FibGUuZW5kKHNlZWthYmxlLmxlbmd0aCAtIDEpO1xuXG4gICAgICB0aGlzLmxhc3RTZWVrVGFyZ2V0XyA9IHRpbWU7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3NlZWtpbmcnKTtcbiAgICAgIHRoaXMuZWxfLnZqc19zZXRQcm9wZXJ0eSgnY3VycmVudFRpbWUnLCB0aW1lKTtcbiAgICAgIF9UZWNoLnByb3RvdHlwZS5zZXRDdXJyZW50VGltZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHBsYXliYWNrIHRpbWUgaW4gc2Vjb25kc1xuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdGltZSBvZiBwbGF5YmFjayBpbiBzZWNvbmRzLlxuICAgKi9cblxuXG4gIEZsYXNoLnByb3RvdHlwZS5jdXJyZW50VGltZSA9IGZ1bmN0aW9uIGN1cnJlbnRUaW1lKCkge1xuICAgIC8vIHdoZW4gc2Vla2luZyBtYWtlIHRoZSByZXBvcnRlZCB0aW1lIGtlZXAgdXAgd2l0aCB0aGUgcmVxdWVzdGVkIHRpbWVcbiAgICAvLyBieSByZWFkaW5nIHRoZSB0aW1lIHdlJ3JlIHNlZWtpbmcgdG9cbiAgICBpZiAodGhpcy5zZWVraW5nKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhc3RTZWVrVGFyZ2V0XyB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbF8udmpzX2dldFByb3BlcnR5KCdjdXJyZW50VGltZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc291cmNlXG4gICAqXG4gICAqIEBtZXRob2QgY3VycmVudFNyY1xuICAgKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBzb3VyY2VcbiAgICovXG5cblxuICBGbGFzaC5wcm90b3R5cGUuY3VycmVudFNyYyA9IGZ1bmN0aW9uIGN1cnJlbnRTcmMoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNvdXJjZV8pIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTb3VyY2VfLnNyYztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWxfLnZqc19nZXRQcm9wZXJ0eSgnY3VycmVudFNyYycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRvdGFsIGR1cmF0aW9uIG9mIHRoZSBjdXJyZW50IG1lZGlhLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICA4ICAgICAgICAgIFRoZSB0b3RhbCBkdXJhdGlvbiBvZiB0aGUgY3VycmVudCBtZWRpYS5cbiAgICovXG5cblxuICBGbGFzaC5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlKCkgPT09IDApIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZWxfLnZqc19nZXRQcm9wZXJ0eSgnZHVyYXRpb24nKTtcblxuICAgIHJldHVybiBkdXJhdGlvbiA+PSAwID8gZHVyYXRpb24gOiBJbmZpbml0eTtcbiAgfTtcblxuICAvKipcbiAgICogTG9hZCBtZWRpYSBpbnRvIFRlY2guXG4gICAqL1xuXG5cbiAgRmxhc2gucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkKCkge1xuICAgIHRoaXMuZWxfLnZqc19sb2FkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcG9zdGVyIGltYWdlIHRoYXQgd2FzIHNldCBvbiB0aGUgdGVjaC5cbiAgICovXG5cblxuICBGbGFzaC5wcm90b3R5cGUucG9zdGVyID0gZnVuY3Rpb24gcG9zdGVyKCkge1xuICAgIHRoaXMuZWxfLnZqc19nZXRQcm9wZXJ0eSgncG9zdGVyJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBvc3RlciBpbWFnZXMgYXJlIG5vdCBoYW5kbGVkIGJ5IHRoZSBGbGFzaCB0ZWNoIHNvIG1ha2UgdGhpcyBpcyBhIG5vLW9wLlxuICAgKi9cblxuXG4gIEZsYXNoLnByb3RvdHlwZS5zZXRQb3N0ZXIgPSBmdW5jdGlvbiBzZXRQb3N0ZXIoKSB7fTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSB0aW1lIHJhbmdlcyB0aGF0IGNhbiBiZSBzZWVrZWQgdG8gaW4gdGhlIG1lZGlhLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gICAqICAgICAgICAgUmV0dXJucyB0aGUgdGltZSByYW5nZXMgdGhhdCBjYW4gYmUgc2Vla2VkIHRvLlxuICAgKi9cblxuXG4gIEZsYXNoLnByb3RvdHlwZS5zZWVrYWJsZSA9IGZ1bmN0aW9uIHNlZWthYmxlKCkge1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKTtcblxuICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZSgpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlKDAsIGR1cmF0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuZCBjcmVhdGUgYSBgVGltZVJhbmdlYCBvYmplY3QgZm9yIGJ1ZmZlcmluZy5cbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgKiAgICAgICAgIFRoZSB0aW1lIHJhbmdlIG9iamVjdCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIEZsYXNoLnByb3RvdHlwZS5idWZmZXJlZCA9IGZ1bmN0aW9uIGJ1ZmZlcmVkKCkge1xuICAgIHZhciByYW5nZXMgPSB0aGlzLmVsXy52anNfZ2V0UHJvcGVydHkoJ2J1ZmZlcmVkJyk7XG5cbiAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZSgpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlKHJhbmdlc1swXVswXSwgcmFuZ2VzWzBdWzFdKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGZ1bGxzY3JlZW4gc3VwcG9ydCAtXG4gICAqXG4gICAqIEZsYXNoIGRvZXMgbm90IGFsbG93IGZ1bGxzY3JlZW4gdGhyb3VnaCBqYXZhc2NyaXB0XG4gICAqIHNvIHRoaXMgYWx3YXlzIHJldHVybnMgZmFsc2UuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgVGhlIEZsYXNoIHRlY2ggZG9lcyBub3Qgc3VwcG9ydCBmdWxsc2NyZWVuLCBzbyBpdCB3aWxsIGFsd2F5cyByZXR1cm4gZmFsc2UuXG4gICAqL1xuXG5cbiAgRmxhc2gucHJvdG90eXBlLnN1cHBvcnRzRnVsbFNjcmVlbiA9IGZ1bmN0aW9uIHN1cHBvcnRzRnVsbFNjcmVlbigpIHtcbiAgICAvLyBGbGFzaCBkb2VzIG5vdCBhbGxvdyBmdWxsc2NyZWVuIHRocm91Z2ggamF2YXNjcmlwdFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRmxhc2ggZG9lcyBub3QgYWxsb3cgZnVsbHNjcmVlbiB0aHJvdWdoIGphdmFzY3JpcHRcbiAgICogc28gdGhpcyBhbHdheXMgcmV0dXJucyBmYWxzZS5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBUaGUgRmxhc2ggdGVjaCBkb2VzIG5vdCBzdXBwb3J0IGZ1bGxzY3JlZW4sIHNvIGl0IHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZS5cbiAgICovXG5cblxuICBGbGFzaC5wcm90b3R5cGUuZW50ZXJGdWxsU2NyZWVuID0gZnVuY3Rpb24gZW50ZXJGdWxsU2NyZWVuKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhdmFpbGFibGUgbWVkaWEgcGxheWJhY2sgcXVhbGl0eSBtZXRyaWNzIGFzIHNwZWNpZmllZCBieSB0aGUgVzNDJ3MgTWVkaWFcbiAgICogUGxheWJhY2sgUXVhbGl0eSBBUEkuXG4gICAqXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vbWVkaWEtcGxheWJhY2stcXVhbGl0eX1cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIEFuIG9iamVjdCB3aXRoIHN1cHBvcnRlZCBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3NcbiAgICovXG5cblxuICBGbGFzaC5wcm90b3R5cGUuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPSBmdW5jdGlvbiBnZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpIHtcbiAgICB2YXIgdmlkZW9QbGF5YmFja1F1YWxpdHkgPSB0aGlzLmVsXy52anNfZ2V0UHJvcGVydHkoJ2dldFZpZGVvUGxheWJhY2tRdWFsaXR5Jyk7XG5cbiAgICBpZiAod2luZG93LnBlcmZvcm1hbmNlICYmIHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2aWRlb1BsYXliYWNrUXVhbGl0eS5jcmVhdGlvblRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfSBlbHNlIGlmICh3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLnRpbWluZyAmJiB0eXBlb2Ygd2luZG93LnBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQgPT09ICdudW1iZXInKSB7XG4gICAgICB2aWRlb1BsYXliYWNrUXVhbGl0eS5jcmVhdGlvblRpbWUgPSB3aW5kb3cuRGF0ZS5ub3coKSAtIHdpbmRvdy5wZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiB2aWRlb1BsYXliYWNrUXVhbGl0eTtcbiAgfTtcblxuICByZXR1cm4gRmxhc2g7XG59KFRlY2gpO1xuXG4vLyBDcmVhdGUgc2V0dGVycyBhbmQgZ2V0dGVycyBmb3IgYXR0cmlidXRlc1xuXG5cbnZhciBfcmVhZFdyaXRlID0gWydydG1wQ29ubmVjdGlvbicsICdydG1wU3RyZWFtJywgJ3ByZWxvYWQnLCAnZGVmYXVsdFBsYXliYWNrUmF0ZScsICdwbGF5YmFja1JhdGUnLCAnYXV0b3BsYXknLCAnbG9vcCcsICdjb250cm9scycsICd2b2x1bWUnLCAnbXV0ZWQnLCAnZGVmYXVsdE11dGVkJ107XG52YXIgX3JlYWRPbmx5ID0gWyduZXR3b3JrU3RhdGUnLCAncmVhZHlTdGF0ZScsICdpbml0aWFsVGltZScsICdzdGFydE9mZnNldFRpbWUnLCAncGF1c2VkJywgJ2VuZGVkJywgJ3ZpZGVvV2lkdGgnLCAndmlkZW9IZWlnaHQnXTtcbnZhciBfYXBpID0gRmxhc2gucHJvdG90eXBlO1xuXG4vKipcbiAqIENyZWF0ZSBzZXR0ZXJzIGZvciB0aGUgc3dmIG9uIHRoZSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZVNldHRlcihhdHRyKSB7XG4gIHZhciBhdHRyVXBwZXIgPSBhdHRyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgYXR0ci5zbGljZSgxKTtcblxuICBfYXBpWydzZXQnICsgYXR0clVwcGVyXSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5lbF8udmpzX3NldFByb3BlcnR5KGF0dHIsIHZhbCk7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIHBldHRlcnMgZm9yIHRoZSBzd2Ygb24gdGhlIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfY3JlYXRlR2V0dGVyKGF0dHIpIHtcbiAgX2FwaVthdHRyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF8udmpzX2dldFByb3BlcnR5KGF0dHIpO1xuICB9O1xufVxuXG4vLyBDcmVhdGUgZ2V0dGVyIGFuZCBzZXR0ZXJzIGZvciBhbGwgcmVhZC93cml0ZSBhdHRyaWJ1dGVzXG5mb3IgKHZhciBpID0gMDsgaSA8IF9yZWFkV3JpdGUubGVuZ3RoOyBpKyspIHtcbiAgX2NyZWF0ZUdldHRlcihfcmVhZFdyaXRlW2ldKTtcbiAgX2NyZWF0ZVNldHRlcihfcmVhZFdyaXRlW2ldKTtcbn1cblxuLy8gQ3JlYXRlIGdldHRlcnMgZm9yIHJlYWQtb25seSBhdHRyaWJ1dGVzXG5mb3IgKHZhciBfaSA9IDA7IF9pIDwgX3JlYWRPbmx5Lmxlbmd0aDsgX2krKykge1xuICBfY3JlYXRlR2V0dGVyKF9yZWFkT25seVtfaV0pO1xufVxuXG4vKiogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEdldHRlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICoqL1xuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBydG1wQ29ubmVjdGlvbmAgZnJvbSB0aGUgc3dmLlxuICpcbiAqIEBtZXRob2QgRmxhc2gjcnRtcENvbm5lY3Rpb25cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgYHJ0bXBDb25uZWN0aW9uYCBvbiB0aGUgc3dmLlxuICovXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcnRtcFN0cmVhbWAgZnJvbSB0aGUgc3dmLlxuICpcbiAqIEBtZXRob2QgRmxhc2gjcnRtcFN0cmVhbVxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBgcnRtcFN0cmVhbWAgb24gdGhlIHN3Zi5cbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHByZWxvYWRgIGZyb20gdGhlIHN3Zi4gYHByZWxvYWRgIGluZGljYXRlc1xuICogd2hhdCBzaG91bGQgZG93bmxvYWQgYmVmb3JlIHRoZSBtZWRpYSBpcyBpbnRlcmFjdGVkIHdpdGguIEl0IGNhbiBoYXZlIHRoZSBmb2xsb3dpbmdcbiAqIHZhbHVlczpcbiAqIC0gbm9uZTogbm90aGluZyBzaG91bGQgYmUgZG93bmxvYWRlZFxuICogLSBtZXRhZGF0YTogcG9zdGVyIGFuZCB0aGUgZmlyc3QgZmV3IGZyYW1lcyBvZiB0aGUgbWVkaWEgbWF5IGJlIGRvd25sb2FkZWQgdG8gZ2V0XG4gKiAgIG1lZGlhIGRpbWVuc2lvbnMgYW5kIG90aGVyIG1ldGFkYXRhXG4gKiAtIGF1dG86IGFsbG93IHRoZSBtZWRpYSBhbmQgbWV0YWRhdGEgZm9yIHRoZSBtZWRpYSB0byBiZSBkb3dubG9hZGVkIGJlZm9yZVxuICogICAgaW50ZXJhY3Rpb25cbiAqXG4gKiBAbWV0aG9kIEZsYXNoI3ByZWxvYWRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwcmVsb2FkYCBmcm9tIHRoZSBzd2YuIFdpbGwgYmUgJ25vbmUnLCAnbWV0YWRhdGEnLFxuICogICAgICAgICBvciAnYXV0bycuXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBmcm9tIHRoZSBzd2YuXG4gKlxuICogQG1ldGhvZCBGbGFzaCNkZWZhdWx0UGxheWJhY2tSYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBvbiB0aGUgc3dmLlxuICovXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcGxheWJhY2tSYXRlYCBmcm9tIHRoZSBzd2YuIGBwbGF5YmFja1JhdGVgIGluZGljYXRlc1xuICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBwbGF5aW5nIGJhY2suIEV4YW1wbGVzOlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMiwgbWVkaWEgd2lsbCBwbGF5IHR3aWNlIGFzIGZhc3QuXG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAwLjUsIG1lZGlhIHdpbGwgcGxheSBoYWxmIGFzIGZhc3QuXG4gKlxuICogQG1ldGhvZCBGbGFzaCNwbGF5YmFja1JhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwbGF5YmFja1JhdGVgIGZyb20gdGhlIHN3Zi4gQSBudW1iZXIgaW5kaWNhdGluZ1xuICogICAgICAgICB0aGUgY3VycmVudCBwbGF5YmFjayBzcGVlZCBvZiB0aGUgbWVkaWEsIHdoZXJlIDEgaXMgbm9ybWFsIHNwZWVkLlxuICovXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgYXV0b3BsYXlgIGZyb20gdGhlIHN3Zi4gYGF1dG9wbGF5YCBpbmRpY2F0ZXNcbiAqIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBzdGFydCB0byBwbGF5IGFzIHNvb24gYXMgdGhlIHBhZ2UgaXMgcmVhZHkuXG4gKlxuICogQG1ldGhvZCBGbGFzaCNhdXRvcGxheVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGF1dG9wbGF5YCBmcm9tIHRoZSBzd2YuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgYXNob3VsZCBzdGFydCBhcyBzb29uIGFzIHRoZSBwYWdlIGxvYWRzLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgbm90IHN0YXJ0IGFzIHNvb24gYXMgdGhlIHBhZ2UgbG9hZHMuXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBsb29wYCBmcm9tIHRoZSBzd2YuIGBsb29wYCBpbmRpY2F0ZXNcbiAqIHRoYXQgdGhlIG1lZGlhIHNob3VsZCByZXR1cm4gdG8gdGhlIHN0YXJ0IG9mIHRoZSBtZWRpYSBhbmQgY29udGludWUgcGxheWluZyBvbmNlXG4gKiBpdCByZWFjaGVzIHRoZSBlbmQuXG4gKlxuICogQG1ldGhvZCBGbGFzaCNsb29wXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgbG9vcGAgZnJvbSB0aGUgc3dmLlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgcGxheWJhY2sgc2hvdWxkIHNlZWsgYmFjayB0byBzdGFydCBvbmNlXG4gKiAgICAgICAgICAgdGhlIGVuZCBvZiBhIG1lZGlhIGlzIHJlYWNoZWQuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgcGxheWJhY2sgc2hvdWxkIG5vdCBsb29wIGJhY2sgdG8gdGhlIHN0YXJ0IHdoZW4gdGhlXG4gKiAgICAgICAgICAgZW5kIG9mIHRoZSBtZWRpYSBpcyByZWFjaGVkLlxuICovXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgbWVkaWFHcm91cGAgZnJvbSB0aGUgc3dmLlxuICpcbiAqIEBtZXRob2QgRmxhc2gjbWVkaWFHcm91cFxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBgbWVkaWFHcm91cGAgb24gdGhlIHN3Zi5cbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGNvbnRyb2xsZXJgIGZyb20gdGhlIHN3Zi5cbiAqXG4gKiBAbWV0aG9kIEZsYXNoI2NvbnRyb2xsZXJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgYGNvbnRyb2xsZXJgIG9uIHRoZSBzd2YuXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBjb250cm9sc2AgZnJvbSB0aGUgc3dmLiBgY29udHJvbHNgIGluZGljYXRlc1xuICogd2hldGhlciB0aGUgbmF0aXZlIGZsYXNoIGNvbnRyb2xzIHNob3VsZCBiZSBzaG93biBvciBoaWRkZW4uXG4gKlxuICogQG1ldGhvZCBGbGFzaCNjb250cm9sc1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGNvbnRyb2xzYCBmcm9tIHRoZSBzd2YuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCBuYXRpdmUgY29udHJvbHMgc2hvdWxkIGJlIHNob3dpbmcuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgbmF0aXZlIGNvbnRyb2xzIHNob3VsZCBiZSBoaWRkZW4uXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBgdm9sdW1lYCBmcm9tIHRoZSBzd2YuIGB2b2x1bWVgIGluZGljYXRlcyB0aGUgY3VycmVudFxuICogYXVkaW8gbGV2ZWwgYXMgYSBwZXJjZW50YWdlIGluIGRlY2ltYWwgZm9ybS4gVGhpcyBtZWFucyB0aGF0IDEgaXMgMTAwJSwgMC41IGlzIDUwJSwgYW5kXG4gKiBzbyBvbi5cbiAqXG4gKiBAbWV0aG9kIEZsYXNoI3ZvbHVtZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdm9sdW1lIHBlcmNlbnQgYXMgYSBkZWNpbWFsLiBWYWx1ZSB3aWxsIGJlIGJldHdlZW4gMC0xLlxuICovXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgYG11dGVkYCBmcm9tIHRoZSBzd2YuIGBtdXRlZGAgaW5kaWNhdGVzIHRoZSBjdXJyZW50XG4gKiBhdWRpbyBsZXZlbCBzaG91bGQgYmUgc2lsZW50LlxuICpcbiAqIEBtZXRob2QgRmxhc2gjbXV0ZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgYXVkaW8gc2hvdWxkIGJlIHNldCB0byBzaWxlbnRcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRNdXRlZGAgZnJvbSB0aGUgc3dmLiBgZGVmYXVsdE11dGVkYCBpbmRpY2F0ZXNcbiAqIHdoZXRoZXIgdGhlIG1lZGlhIHNob3VsZCBzdGFydCBtdXRlZCBvciBub3QuIE9ubHkgY2hhbmdlcyB0aGUgZGVmYXVsdCBzdGF0ZSBvZiB0aGVcbiAqIG1lZGlhLiBgbXV0ZWRgIGFuZCBgZGVmYXVsdE11dGVkYCBjYW4gaGF2ZSBkaWZmZXJlbnQgdmFsdWVzLiBgbXV0ZWRgIGluZGljYXRlcyB0aGVcbiAqIGN1cnJlbnQgc3RhdGUuXG4gKlxuICogQG1ldGhvZCBGbGFzaCNkZWZhdWx0TXV0ZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBkZWZhdWx0TXV0ZWRgIGZyb20gdGhlIHN3Zi5cbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgbXV0ZWQuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBub3Qgc3RhcnQgbXV0ZWQuXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBuZXR3b3JrU3RhdGVgIGZyb20gdGhlIHN3Zi4gYG5ldHdvcmtTdGF0ZWAgaW5kaWNhdGVzXG4gKiB0aGUgY3VycmVudCBuZXR3b3JrIHN0YXRlLiBJdCByZXR1cm5zIGFuIGVudW1lcmF0aW9uIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0OlxuICogLSAwOiBORVRXT1JLX0VNUFRZXG4gKiAtIDE6IE5FV09SS19JRExFXG4gKiAtIDI6IE5FVFdPUktfTE9BRElOR1xuICogLSAzOiBORVRXT1JLX05PX1NPVVJDRVxuICpcbiAqIEBtZXRob2QgRmxhc2gjbmV0d29ya1N0YXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgbmV0d29ya1N0YXRlYCBmcm9tIHRoZSBzd2YuIFRoaXMgd2lsbCBiZSBhIG51bWJlclxuICogICAgICAgICBmcm9tIHRoZSBsaXN0IGluIHRoZSBkZXNjcmlwdGlvbi5cbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHJlYWR5U3RhdGVgIGZyb20gdGhlIHN3Zi4gYHJlYWR5U3RhdGVgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIG1lZGlhIGVsZW1lbnQuIEl0IHJldHVybnMgYW4gZW51bWVyYXRpb24gZnJvbSB0aGVcbiAqIGZvbGxvd2luZyBsaXN0OlxuICogLSAwOiBIQVZFX05PVEhJTkdcbiAqIC0gMTogSEFWRV9NRVRBREFUQVxuICogLSAyOiBIQVZFX0NVUlJFTlRfREFUQVxuICogLSAzOiBIQVZFX0ZVVFVSRV9EQVRBXG4gKiAtIDQ6IEhBVkVfRU5PVUdIX0RBVEFcbiAqXG4gKiBAbWV0aG9kIEZsYXNoI3JlYWR5U3RhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGByZWFkeVN0YXRlYCBmcm9tIHRoZSBzd2YuIFRoaXMgd2lsbCBiZSBhIG51bWJlclxuICogICAgICAgICBmcm9tIHRoZSBsaXN0IGluIHRoZSBkZXNjcmlwdGlvbi5cbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHJlYWR5U3RhdGVgIGZyb20gdGhlIHN3Zi4gYHJlYWR5U3RhdGVgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIG1lZGlhIGVsZW1lbnQuIEl0IHJldHVybnMgYW4gZW51bWVyYXRpb24gZnJvbSB0aGVcbiAqIGZvbGxvd2luZyBsaXN0OlxuICogLSAwOiBIQVZFX05PVEhJTkdcbiAqIC0gMTogSEFWRV9NRVRBREFUQVxuICogLSAyOiBIQVZFX0NVUlJFTlRfREFUQVxuICogLSAzOiBIQVZFX0ZVVFVSRV9EQVRBXG4gKiAtIDQ6IEhBVkVfRU5PVUdIX0RBVEFcbiAqXG4gKiBAbWV0aG9kIEZsYXNoI3JlYWR5U3RhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGByZWFkeVN0YXRlYCBmcm9tIHRoZSBzd2YuIFRoaXMgd2lsbCBiZSBhIG51bWJlclxuICogICAgICAgICBmcm9tIHRoZSBsaXN0IGluIHRoZSBkZXNjcmlwdGlvbi5cbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGluaXRpYWxUaW1lYCBmcm9tIHRoZSBzd2YuXG4gKlxuICogQG1ldGhvZCBGbGFzaCNpbml0aWFsVGltZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgYGluaXRpYWxUaW1lYCBwcm9wcmV0eSBvbiB0aGUgc3dmLlxuICovXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgc3RhcnRPZmZzZXRUaW1lYCBmcm9tIHRoZSBzd2YuXG4gKlxuICogQG1ldGhvZCBGbGFzaCNzdGFydE9mZnNldFRpbWVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIGBzdGFydE9mZnNldFRpbWVgIHByb3ByZXR5IG9uIHRoZSBzd2YuXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwYXVzZWRgIGZyb20gdGhlIHN3Zi4gYHBhdXNlZGAgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN3ZlxuICogaXMgY3VycmVudCBwYXVzZWQgb3Igbm90LlxuICpcbiAqIEBtZXRob2QgRmxhc2gjcGF1c2VkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHBhdXNlZGAgZnJvbSB0aGUgc3dmLlxuICovXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgZW5kZWRgIGZyb20gdGhlIHN3Zi4gYGVuZGVkYCBpbmRpY2F0ZXMgd2hldGhlclxuICogdGhlIG1lZGlhIGhhcyByZWFjaGVkIHRoZSBlbmQgb3Igbm90LlxuICpcbiAqIEBtZXRob2QgRmxhc2gjZW5kZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgaGFzIGVuZGVkLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBoYXMgbm90IGVuZGVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtZW5kZWR9XG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGB2aWRlb1dpZHRoYCBmcm9tIHRoZSBzd2YuIGB2aWRlb1dpZHRoYCBpbmRpY2F0ZXNcbiAqIHRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBtZWRpYSBpbiBjc3MgcGl4ZWxzLlxuICpcbiAqIEBtZXRob2QgRmxhc2gjdmlkZW9XaWR0aFxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHZpZGVvV2lkdGhgIGZyb20gdGhlIHN3Zi4gVGhpcyB3aWxsIGJlIGEgbnVtYmVyXG4gKiAgICAgICAgIGluIGNzcyBwaXhlbHMuXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGB2aWRlb0hlaWdodGAgZnJvbSB0aGUgc3dmLiBgdmlkZW9IZWlndGhgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSBtZWRpYSBpbiBjc3MgcGl4ZWxzLlxuICpcbiAqIEBtZXRob2QgRmxhc3NoLnByb3RvdHlwZS52aWRlb0hlaWdodFxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHZpZGVvSGVpZ2h0YCBmcm9tIHRoZSBzd2YuIFRoaXMgd2lsbCBiZSBhIG51bWJlclxuICogICAgICAgICBpbiBjc3MgcGl4ZWxzLlxuICovXG4vKiogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNldHRlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICoqL1xuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYHJ0bXBDb25uZWN0aW9uYCBvbiB0aGUgc3dmLlxuICpcbiAqIEBtZXRob2QgRmxhc2gjc2V0UnRtcENvbm5lY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBydG1wQ29ubmVjdGlvblxuICogICAgICAgIE5ldyB2YWx1ZSB0byBzZXQgdGhlIGBydG1wQ29ubmVjdGlvbmAgcHJvcGVydHkgdG8uXG4gKi9cblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBydG1wU3RyZWFtYCBvbiB0aGUgc3dmLlxuICpcbiAqIEBtZXRob2QgRmxhc2gjc2V0UnRtcFN0cmVhbVxuICogQHBhcmFtIHtzdHJpbmd9IHJ0bXBTdHJlYW1cbiAqICAgICAgICBOZXcgdmFsdWUgdG8gc2V0IHRoZSBgcnRtcFN0cmVhbWAgcHJvcGVydHkgdG8uXG4gKi9cblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBwcmVsb2FkYCBvbiB0aGUgc3dmLiBgcHJlbG9hZGAgaW5kaWNhdGVzXG4gKiB3aGF0IHNob3VsZCBkb3dubG9hZCBiZWZvcmUgdGhlIG1lZGlhIGlzIGludGVyYWN0ZWQgd2l0aC4gSXQgY2FuIGhhdmUgdGhlIGZvbGxvd2luZ1xuICogdmFsdWVzOlxuICogLSBub25lOiBub3RoaW5nIHNob3VsZCBiZSBkb3dubG9hZGVkXG4gKiAtIG1ldGFkYXRhOiBwb3N0ZXIgYW5kIHRoZSBmaXJzdCBmZXcgZnJhbWVzIG9mIHRoZSBtZWRpYSBtYXkgYmUgZG93bmxvYWRlZCB0byBnZXRcbiAqICAgbWVkaWEgZGltZW5zaW9ucyBhbmQgb3RoZXIgbWV0YWRhdGFcbiAqIC0gYXV0bzogYWxsb3cgdGhlIG1lZGlhIGFuZCBtZXRhZGF0YSBmb3IgdGhlIG1lZGlhIHRvIGJlIGRvd25sb2FkZWQgYmVmb3JlXG4gKiAgICBpbnRlcmFjdGlvblxuICpcbiAqIEBtZXRob2QgRmxhc2gjc2V0UHJlbG9hZFxuICogQHBhcmFtIHtzdHJpbmd9IHByZWxvYWRcbiAqICAgICAgICBUaGUgdmFsdWUgb2YgYHByZWxvYWRgIHRvIHNldCBvbiB0aGUgc3dmLiBTaG91bGQgYmUgJ25vbmUnLCAnbWV0YWRhdGEnLFxuICogICAgICAgIG9yICdhdXRvJy5cbiAqL1xuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRQbGF5YmFja1JhdGVgIG9uIHRoZSBzd2YuXG4gKlxuICogQG1ldGhvZCBGbGFzaCNzZXREZWZhdWx0UGxheWJhY2tSYXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFBsYXliYWNrUmF0ZVxuICogICAgICAgIE5ldyB2YWx1ZSB0byBzZXQgdGhlIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBwcm9wZXJ0eSB0by5cbiAqL1xuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYHBsYXliYWNrUmF0ZWAgb24gdGhlIHN3Zi4gYHBsYXliYWNrUmF0ZWAgaW5kaWNhdGVzXG4gKiB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgbWVkaWEgaXMgY3VycmVudGx5IHBsYXlpbmcgYmFjay4gRXhhbXBsZXM6XG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAyLCBtZWRpYSB3aWxsIHBsYXkgdHdpY2UgYXMgZmFzdC5cbiAqICAgLSBpZiBwbGF5YmFja1JhdGUgaXMgc2V0IHRvIDAuNSwgbWVkaWEgd2lsbCBwbGF5IGhhbGYgYXMgZmFzdC5cbiAqXG4gKiBAbWV0aG9kIEZsYXNoI3NldFBsYXliYWNrUmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHBsYXliYWNrUmF0ZVxuICogICAgICAgIE5ldyB2YWx1ZSBvZiBgcGxheWJhY2tSYXRlYCBvbiB0aGUgc3dmLiBBIG51bWJlciBpbmRpY2F0aW5nXG4gKiAgICAgICAgdGhlIGN1cnJlbnQgcGxheWJhY2sgc3BlZWQgb2YgdGhlIG1lZGlhLCB3aGVyZSAxIGlzIG5vcm1hbCBzcGVlZC5cbiAqL1xuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYGF1dG9wbGF5YCBvbiB0aGUgc3dmLiBgYXV0b3BsYXlgIGluZGljYXRlc1xuICogdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IHRvIHBsYXkgYXMgc29vbiBhcyB0aGUgcGFnZSBpcyByZWFkeS5cbiAqXG4gKiBAbWV0aG9kIEZsYXNoI3NldEF1dG9wbGF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGF1dG9wbGF5XG4gKiAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGF1dG9wbGF5YCBmcm9tIHRoZSBzd2YuXG4gKiAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBhc2hvdWxkIHN0YXJ0IGFzIHNvb24gYXMgdGhlIHBhZ2UgbG9hZHMuXG4gKiAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBzdGFydCBhcyBzb29uIGFzIHRoZSBwYWdlIGxvYWRzLlxuICovXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgbG9vcGAgb24gdGhlIHN3Zi4gYGxvb3BgIGluZGljYXRlc1xuICogdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHJldHVybiB0byB0aGUgc3RhcnQgb2YgdGhlIG1lZGlhIGFuZCBjb250aW51ZSBwbGF5aW5nIG9uY2VcbiAqIGl0IHJlYWNoZXMgdGhlIGVuZC5cbiAqXG4gKiBAbWV0aG9kIEZsYXNoI3NldExvb3BcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICogICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCBwbGF5YmFjayBzaG91bGQgc2VlayBiYWNrIHRvIHN0YXJ0IG9uY2VcbiAqICAgICAgICAgIHRoZSBlbmQgb2YgYSBtZWRpYSBpcyByZWFjaGVkLlxuICogICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgcGxheWJhY2sgc2hvdWxkIG5vdCBsb29wIGJhY2sgdG8gdGhlIHN0YXJ0IHdoZW4gdGhlXG4gKiAgICAgICAgICBlbmQgb2YgdGhlIG1lZGlhIGlzIHJlYWNoZWQuXG4gKi9cblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBtZWRpYUdyb3VwYCBvbiB0aGUgc3dmLlxuICpcbiAqIEBtZXRob2QgRmxhc2gjc2V0TWVkaWFHcm91cFxuICogQHBhcmFtIHtzdHJpbmd9IG1lZGlhR3JvdXBcbiAqICAgICAgICBOZXcgdmFsdWUgb2YgYG1lZGlhR3JvdXBgIHRvIHNldCBvbiB0aGUgc3dmLlxuICovXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgY29udHJvbGxlcmAgb24gdGhlIHN3Zi5cbiAqXG4gKiBAbWV0aG9kIEZsYXNoI3NldENvbnRyb2xsZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250cm9sbGVyXG4gKiAgICAgICAgTmV3IHZhbHVlIHRoZSBjdXJyZW50IHZhbHVlIG9mIGBjb250cm9sbGVyYCBvbiB0aGUgc3dmLlxuICovXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgY29udHJvbHNgIGZyb20gdGhlIHN3Zi4gYGNvbnRyb2xzYCBpbmRpY2F0ZXNcbiAqIHdoZXRoZXIgdGhlIG5hdGl2ZSBmbGFzaCBjb250cm9scyBzaG91bGQgYmUgc2hvd24gb3IgaGlkZGVuLlxuICpcbiAqIEBtZXRob2QgRmxhc2gjY29udHJvbHNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBjb250cm9sc2AgZnJvbSB0aGUgc3dmLlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgbmF0aXZlIGNvbnRyb2xzIHNob3VsZCBiZSBzaG93aW5nLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IG5hdGl2ZSBjb250cm9scyBzaG91bGQgYmUgaGlkZGVuLlxuICovXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgYHZvbHVtZWAgb24gdGhlIHN3Zi4gYHZvbHVtZWAgaW5kaWNhdGVzIHRoZSBjdXJyZW50XG4gKiBhdWRpbyBsZXZlbCBhcyBhIHBlcmNlbnRhZ2UgaW4gZGVjaW1hbCBmb3JtLiBUaGlzIG1lYW5zIHRoYXQgMSBpcyAxMDAlLCAwLjUgaXMgNTAlLCBhbmRcbiAqIHNvIG9uLlxuICpcbiAqIEBtZXRob2QgRmxhc2gjc2V0Vm9sdW1lXG4gKiBAcGFyYW0ge251bWJlcn0gcGVyY2VudEFzRGVjaW1hbFxuICogICAgICAgICBUaGUgdm9sdW1lIHBlcmNlbnQgYXMgYSBkZWNpbWFsLiBWYWx1ZSB3aWxsIGJlIGJldHdlZW4gMC0xLlxuICovXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgYG11dGVkYCBvbiB0aGUgc3dmLiBgbXV0ZWRgIGluZGljYXRlcyB0aGF0IHRoZSBjdXJyZW50XG4gKiBhdWRpbyBsZXZlbCBzaG91bGQgYmUgc2lsZW50LlxuICpcbiAqIEBtZXRob2QgRmxhc2gjc2V0TXV0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXV0ZWRcbiAqICAgICAgICAgLSBUcnVlIGlmIHRoZSBhdWRpbyBzaG91bGQgYmUgc2V0IHRvIHNpbGVudFxuICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICovXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgZGVmYXVsdE11dGVkYCBvbiB0aGUgc3dmLiBgZGVmYXVsdE11dGVkYCBpbmRpY2F0ZXNcbiAqIHdoZXRoZXIgdGhlIG1lZGlhIHNob3VsZCBzdGFydCBtdXRlZCBvciBub3QuIE9ubHkgY2hhbmdlcyB0aGUgZGVmYXVsdCBzdGF0ZSBvZiB0aGVcbiAqIG1lZGlhLiBgbXV0ZWRgIGFuZCBgZGVmYXVsdE11dGVkYCBjYW4gaGF2ZSBkaWZmZXJlbnQgdmFsdWVzLiBgbXV0ZWRgIGluZGljYXRlcyB0aGVcbiAqIGN1cnJlbnQgc3RhdGUuXG4gKlxuICogQG1ldGhvZCBGbGFzaCNzZXREZWZhdWx0TXV0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVmYXVsdE11dGVkXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IG11dGVkLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgbm90IHN0YXJ0IG11dGVkLlxuICovXG5cbi8qIEZsYXNoIFN1cHBvcnQgVGVzdGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBGbGFzaCB0ZWNoIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgZmxhc2ggdGVjaCBpcyBzdXBwb3J0ZWQuXG4gKiAgICAgICAgICAtIEZhbHNlIG90aGVyd2lzZS5cbiAqL1xuRmxhc2guaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBGbGFzaC52ZXJzaW9uKClbMF0gPj0gMTA7XG4gIC8vIHJldHVybiBzd2ZvYmplY3QuaGFzRmxhc2hQbGF5ZXJWZXJzaW9uKCcxMCcpO1xufTtcblxuLy8gQWRkIFNvdXJjZSBIYW5kbGVyIHBhdHRlcm4gZnVuY3Rpb25zIHRvIHRoaXMgdGVjaFxuVGVjaC53aXRoU291cmNlSGFuZGxlcnMoRmxhc2gpO1xuXG4vKlxuICogTmF0aXZlIHNvdXJjZSBoYW5kbGVyIGZvciBmbGFzaCwgIHNpbXBseSBwYXNzZXMgdGhlIHNvdXJjZSB0byB0aGUgc3dmIGVsZW1lbnQuXG4gKlxuICogQHByb3BlcnR5IHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gKiAgICAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge0ZsYXNofSB0ZWNoXG4gKiAgICAgICAgICAgVGhlIGluc3RhbmNlIG9mIHRoZSBGbGFzaCB0ZWNoXG4gKi9cbkZsYXNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIgPSB7fTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgRmxhc2ggY2FuIHBsYXkgdGhlIGdpdmVuIG1pbWUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIFRoZSBtaW1ldHlwZSB0byBjaGVja1xuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAqL1xuRmxhc2gubmF0aXZlU291cmNlSGFuZGxlci5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIGlmICh0eXBlIGluIEZsYXNoLmZvcm1hdHMpIHtcbiAgICByZXR1cm4gJ21heWJlJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIG1lZGlhIGVsZW1lbnQgY2FuIGhhbmRsZSBhIHNvdXJjZSBuYXRpdmVseS5cbiAqXG4gKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzb3VyY2VcbiAqICAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgICAgICAgIE9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIHRoZSB0ZWNoLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZykuXG4gKi9cbkZsYXNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIuY2FuSGFuZGxlU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgdHlwZSA9IHZvaWQgMDtcblxuICAvKipcbiAgICogR3Vlc3MgdGhlIG1pbWUgdHlwZSBvZiBhIGZpbGUgaWYgaXQgZG9lcyBub3QgaGF2ZSBvbmVcbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc3JjXG4gICAqICAgICAgICBUaGUgc291cmNlIG9iamVjdCB0byBndWVzcyB0aGUgbWltZSB0eXBlIGZvclxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIG1pbWUgdHlwZSB0aGF0IHdhcyBndWVzc2VkXG4gICAqL1xuICBmdW5jdGlvbiBndWVzc01pbWVUeXBlKHNyYykge1xuICAgIHZhciBleHQgPSBVcmwuZ2V0RmlsZUV4dGVuc2lvbihzcmMpO1xuXG4gICAgaWYgKGV4dCkge1xuICAgICAgcmV0dXJuICd2aWRlby8nICsgZXh0O1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoIXNvdXJjZS50eXBlKSB7XG4gICAgdHlwZSA9IGd1ZXNzTWltZVR5cGUoc291cmNlLnNyYyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaXAgY29kZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSB0eXBlIGJlY2F1c2Ugd2UgZG9uJ3QgZ2V0IHRoYXQgc3BlY2lmaWNcbiAgICB0eXBlID0gc291cmNlLnR5cGUucmVwbGFjZSgvOy4qLywgJycpLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICByZXR1cm4gRmxhc2gubmF0aXZlU291cmNlSGFuZGxlci5jYW5QbGF5VHlwZSh0eXBlKTtcbn07XG5cbi8qKlxuICogUGFzcyB0aGUgc291cmNlIHRvIHRoZSBzd2YuXG4gKlxuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge0ZsYXNofSB0ZWNoXG4gKiAgICAgICAgVGhlIGluc3RhbmNlIG9mIHRoZSBGbGFzaCB0ZWNoXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZVxuICovXG5GbGFzaC5uYXRpdmVTb3VyY2VIYW5kbGVyLmhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRlY2gsIG9wdGlvbnMpIHtcbiAgdGVjaC5zZXRTcmMoc291cmNlLnNyYyk7XG59O1xuXG4vKipcbiAqIG5vb3AgZm9yIG5hdGl2ZSBzb3VyY2UgaGFuZGxlciBkaXNwb3NlLCBhcyBjbGVhbnVwIHdpbGwgaGFwcGVuIGF1dG9tYXRpY2FsbHkuXG4gKi9cbkZsYXNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBSZWdpc3RlciB0aGUgbmF0aXZlIHNvdXJjZSBoYW5kbGVyXG5GbGFzaC5yZWdpc3RlclNvdXJjZUhhbmRsZXIoRmxhc2gubmF0aXZlU291cmNlSGFuZGxlcik7XG5cbi8qKlxuICogRmxhc2ggc3VwcG9ydGVkIG1pbWUgdHlwZXMuXG4gKlxuICogQGNvbnN0YW50IHtPYmplY3R9XG4gKi9cbkZsYXNoLmZvcm1hdHMgPSB7XG4gICd2aWRlby9mbHYnOiAnRkxWJyxcbiAgJ3ZpZGVvL3gtZmx2JzogJ0ZMVicsXG4gICd2aWRlby9tcDQnOiAnTVA0JyxcbiAgJ3ZpZGVvL200dic6ICdNUDQnXG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoZSB0aGUgc3dmIGlzIFwicmVhZHlcIiwgYW5kIG1ha2VzIHN1cmUgdGhhdCB0aGUgc3dmIGlzIHJlYWxseVxuICogcmVhZHkgdXNpbmcge0BsaW5rIEZsYXNoI2NoZWNrUmVhZHl9XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN1cnJTd2ZcbiAqICAgICAgICBUaGUgY3VycmVudCBzd2Ygb2JqZWN0XG4gKi9cbkZsYXNoLm9uUmVhZHkgPSBmdW5jdGlvbiAoY3VyclN3Zikge1xuICB2YXIgZWwgPSBEb20uJCgnIycgKyBjdXJyU3dmKTtcbiAgdmFyIHRlY2ggPSBlbCAmJiBlbC50ZWNoO1xuXG4gIC8vIGlmIHRoZXJlIGlzIG5vIGVsIHRoZW4gdGhlIHRlY2ggaGFzIGJlZW4gZGlzcG9zZWRcbiAgLy8gYW5kIHRoZSB0ZWNoIGVsZW1lbnQgd2FzIHJlbW92ZWQgZnJvbSB0aGUgcGxheWVyIGRpdlxuICBpZiAodGVjaCAmJiB0ZWNoLmVsKCkpIHtcbiAgICAvLyBjaGVjayB0aGF0IHRoZSBmbGFzaCBvYmplY3QgaXMgcmVhbGx5IHJlYWR5XG4gICAgRmxhc2guY2hlY2tSZWFkeSh0ZWNoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgU1dGIGlzbid0IGFsd2F5cyByZWFkeSB3aGVuIGl0IHNheXMgaXQgaXMuIFNvbWV0aW1lcyB0aGUgQVBJIGZ1bmN0aW9ucyBzdGlsbFxuICogbmVlZCB0byBiZSBhZGRlZCB0byB0aGUgb2JqZWN0LiBJZiBpdCdzIG5vdCByZWFkeSwgd2Ugc2V0IGEgdGltZW91dCB0byBjaGVjayBhZ2FpblxuICogc2hvcnRseS5cbiAqXG4gKiBAcGFyYW0ge0ZsYXNofSB0ZWNoXG4gKiAgICAgICAgVGhlIGluc3RhbmNlIG9mIHRoZSBmbGFzaCB0ZWNoIHRvIGNoZWNrLlxuICovXG5GbGFzaC5jaGVja1JlYWR5ID0gZnVuY3Rpb24gKHRlY2gpIHtcbiAgLy8gc3RvcCB3b3JyeWluZyBpZiB0aGUgdGVjaCBoYXMgYmVlbiBkaXNwb3NlZFxuICBpZiAoIXRlY2guZWwoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIEFQSSBwcm9wZXJ0eSBleGlzdHNcbiAgaWYgKHRlY2guZWwoKS52anNfZ2V0UHJvcGVydHkpIHtcbiAgICAvLyB0ZWxsIHRlY2ggaXQncyByZWFkeVxuICAgIHRlY2gudHJpZ2dlclJlYWR5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gd2FpdCBsb25nZXJcbiAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgRmxhc2guY2hlY2tSZWFkeSh0ZWNoKTtcbiAgICB9LCA1MCk7XG4gIH1cbn07XG5cbi8qKlxuICogVHJpZ2dlciBldmVudHMgZnJvbSB0aGUgc3dmIG9uIHRoZSBGbGFzaCBUZWNoLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzd2ZJRFxuICogICAgICAgIFRoZSBpZCBvZiB0aGUgc3dmIHRoYXQgaGFkIHRoZSBldmVudFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJpZ2dlclxuICovXG5GbGFzaC5vbkV2ZW50ID0gZnVuY3Rpb24gKHN3ZklELCBldmVudE5hbWUpIHtcbiAgdmFyIHRlY2ggPSBEb20uJCgnIycgKyBzd2ZJRCkudGVjaDtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXG4gIC8vIGRpc3BhdGNoIEZsYXNoIGV2ZW50cyBhc3luY2hyb25vdXNseSBmb3IgdHdvIHJlYXNvbnM6XG4gIC8vIC0gRmxhc2ggc3dhbGxvd3MgYW55IGV4Y2VwdGlvbnMgZ2VuZXJhdGVkIGJ5IGphdmFzY3JpcHQgaXRcbiAgLy8gICBpbnZva2VzXG4gIC8vIC0gRmxhc2ggaXMgc3VzcGVuZGVkIHVudGlsIHRoZSBqYXZhc2NyaXB0IHJldHVybnMgd2hpY2ggbWF5IGNhdXNlXG4gIC8vICAgcGxheWJhY2sgcGVyZm9ybWFuY2UgaXNzdWVzXG4gIHRlY2guc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdGVjaC50cmlnZ2VyKGV2ZW50TmFtZSwgYXJncyk7XG4gIH0sIDEpO1xufTtcblxuLyoqXG4gKiBMb2cgZXJyb3JzIGZyb20gdGhlIHN3ZiBvbiB0aGUgRmxhc2ggdGVjaC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gc3dmSURcbiAqICAgICAgICBUaGUgaWQgb2YgdGhlIHN3ZiB0aGF0IGhhZCBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXJyXG4gKiAgICAgICAgVGhlIGVycm9yIHRvIHNldCBvbiB0aGUgRmxhc2ggVGVjaC5cbiAqXG4gKiBAcmV0dXJuIHtNZWRpYUVycm9yfHVuZGVmaW5lZH1cbiAqICAgICAgICAgIC0gUmV0dXJucyBhIE1lZGlhRXJyb3Igd2hlbiBlcnIgaXMgJ3NyY25vdGZvdW5kJ1xuICogICAgICAgICAgLSBSZXR1cm5zIHVuZGVmaW5lZCBvdGhlcndpc2UuXG4gKi9cbkZsYXNoLm9uRXJyb3IgPSBmdW5jdGlvbiAoc3dmSUQsIGVycikge1xuICB2YXIgdGVjaCA9IERvbS4kKCcjJyArIHN3ZklEKS50ZWNoO1xuXG4gIC8vIHRyaWdnZXIgTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEXG4gIGlmIChlcnIgPT09ICdzcmNub3Rmb3VuZCcpIHtcbiAgICByZXR1cm4gdGVjaC5lcnJvcig0KTtcbiAgfVxuXG4gIC8vIHRyaWdnZXIgYSBjdXN0b20gZXJyb3JcbiAgdGVjaC5lcnJvcignRkxBU0g6ICcgKyBlcnIpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBGbGFzaCB0aGF0IGlzIGluIHVzZSBvbiB0aGUgcGFnZS5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqICAgICAgICAgIGFuIGFycmF5IG9mIHZlcnNpb25zIHRoYXQgYXJlIGF2YWlsYWJsZS5cbiAqL1xuRmxhc2gudmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlcnNpb24kJDEgPSAnMCwwLDAnO1xuXG4gIC8vIElFXG4gIHRyeSB7XG4gICAgdmVyc2lvbiQkMSA9IG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCgnU2hvY2t3YXZlRmxhc2guU2hvY2t3YXZlRmxhc2gnKS5HZXRWYXJpYWJsZSgnJHZlcnNpb24nKS5yZXBsYWNlKC9cXEQrL2csICcsJykubWF0Y2goL14sPyguKyksPyQvKVsxXTtcblxuICAgIC8vIG90aGVyIGJyb3dzZXJzXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKG5hdmlnYXRvci5taW1lVHlwZXNbJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJ10uZW5hYmxlZFBsdWdpbikge1xuICAgICAgICB2ZXJzaW9uJCQxID0gKG5hdmlnYXRvci5wbHVnaW5zWydTaG9ja3dhdmUgRmxhc2ggMi4wJ10gfHwgbmF2aWdhdG9yLnBsdWdpbnNbJ1Nob2Nrd2F2ZSBGbGFzaCddKS5kZXNjcmlwdGlvbi5yZXBsYWNlKC9cXEQrL2csICcsJykubWF0Y2goL14sPyguKyksPyQvKVsxXTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIHNhdGlzZnkgbGludGVyXG4gICAgfVxuICB9XG4gIHJldHVybiB2ZXJzaW9uJCQxLnNwbGl0KCcsJyk7XG59O1xuXG4vKipcbiAqIE9ubHkgdXNlIGZvciBub24taWZyYW1lIGVtYmVkcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3dmXG4gKiAgICAgICAgVGhlIHZpZGVvanMtc3dmIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmxhc2hWYXJzXG4gKiAgICAgICAgTmFtZXMgYW5kIHZhbHVlcyB0byB1c2UgYXMgZmxhc2ggb3B0aW9uIHZhcmlhYmxlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gKiAgICAgICAgU3R5bGUgcGFyYW1ldGVycyB0byBzZXQgb24gdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlc1xuICogICAgICAgIEF0dHJpYnV0ZXMgdG8gc2V0IG9uIHRoZSBlbGVtZW50LlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgICBUaGUgZW1iZWRlZCBGbGFzaCBET00gZWxlbWVudC5cbiAqL1xuRmxhc2guZW1iZWQgPSBmdW5jdGlvbiAoc3dmLCBmbGFzaFZhcnMsIHBhcmFtcywgYXR0cmlidXRlcykge1xuICB2YXIgY29kZSA9IEZsYXNoLmdldEVtYmVkQ29kZShzd2YsIGZsYXNoVmFycywgcGFyYW1zLCBhdHRyaWJ1dGVzKTtcblxuICAvLyBHZXQgZWxlbWVudCBieSBlbWJlZGRpbmcgY29kZSBhbmQgcmV0cmlldmluZyBjcmVhdGVkIGVsZW1lbnRcbiAgdmFyIG9iaiA9IERvbS5jcmVhdGVFbCgnZGl2JywgeyBpbm5lckhUTUw6IGNvZGUgfSkuY2hpbGROb2Rlc1swXTtcblxuICByZXR1cm4gb2JqO1xufTtcblxuLyoqXG4gKiBPbmx5IHVzZSBmb3Igbm9uLWlmcmFtZSBlbWJlZHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN3ZlxuICogICAgICAgIFRoZSB2aWRlb2pzLXN3ZiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZsYXNoVmFyc1xuICogICAgICAgIE5hbWVzIGFuZCB2YWx1ZXMgdG8gdXNlIGFzIGZsYXNoIG9wdGlvbiB2YXJpYWJsZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICogICAgICAgIFN0eWxlIHBhcmFtZXRlcnMgdG8gc2V0IG9uIHRoZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAqICAgICAgICBBdHRyaWJ1dGVzIHRvIHNldCBvbiB0aGUgZWxlbWVudC5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICAgVGhlIGVtYmVkZWQgRmxhc2ggRE9NIGVsZW1lbnQuXG4gKi9cbkZsYXNoLmdldEVtYmVkQ29kZSA9IGZ1bmN0aW9uIChzd2YsIGZsYXNoVmFycywgcGFyYW1zLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBvYmpUYWcgPSAnPG9iamVjdCB0eXBlPVwiYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2hcIiAnO1xuICB2YXIgZmxhc2hWYXJzU3RyaW5nID0gJyc7XG4gIHZhciBwYXJhbXNTdHJpbmcgPSAnJztcbiAgdmFyIGF0dHJzU3RyaW5nID0gJyc7XG5cbiAgLy8gQ29udmVydCBmbGFzaCB2YXJzIHRvIHN0cmluZ1xuICBpZiAoZmxhc2hWYXJzKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZmxhc2hWYXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGZsYXNoVmFyc1N0cmluZyArPSBrZXkgKyAnPScgKyBmbGFzaFZhcnNba2V5XSArICcmYW1wOyc7XG4gICAgfSk7XG4gIH1cblxuICAvLyBBZGQgc3dmLCBmbGFzaFZhcnMsIGFuZCBvdGhlciBkZWZhdWx0IHBhcmFtc1xuICBwYXJhbXMgPSBtZXJnZU9wdGlvbnMoe1xuICAgIG1vdmllOiBzd2YsXG4gICAgZmxhc2h2YXJzOiBmbGFzaFZhcnNTdHJpbmcsXG4gICAgLy8gUmVxdWlyZWQgdG8gdGFsayB0byBzd2ZcbiAgICBhbGxvd1NjcmlwdEFjY2VzczogJ2Fsd2F5cycsXG4gICAgLy8gQWxsIHNob3VsZCBiZSBkZWZhdWx0LCBidXQgaGF2aW5nIHNlY3VyaXR5IGlzc3Vlcy5cbiAgICBhbGxvd05ldHdvcmtpbmc6ICdhbGwnXG4gIH0sIHBhcmFtcyk7XG5cbiAgLy8gQ3JlYXRlIHBhcmFtIHRhZ3Mgc3RyaW5nXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcGFyYW1zU3RyaW5nICs9ICc8cGFyYW0gbmFtZT1cIicgKyBrZXkgKyAnXCIgdmFsdWU9XCInICsgcGFyYW1zW2tleV0gKyAnXCIgLz4nO1xuICB9KTtcblxuICBhdHRyaWJ1dGVzID0gbWVyZ2VPcHRpb25zKHtcbiAgICAvLyBBZGQgc3dmIHRvIGF0dHJpYnV0ZXMgKG5lZWQgYm90aCBmb3IgSUUgYW5kIE90aGVycyB0byB3b3JrKVxuICAgIGRhdGE6IHN3ZixcblxuICAgIC8vIERlZmF1bHQgdG8gMTAwJSB3aWR0aC9oZWlnaHRcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGhlaWdodDogJzEwMCUnXG5cbiAgfSwgYXR0cmlidXRlcyk7XG5cbiAgLy8gQ3JlYXRlIEF0dHJpYnV0ZXMgc3RyaW5nXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGF0dHJzU3RyaW5nICs9IGtleSArICc9XCInICsgYXR0cmlidXRlc1trZXldICsgJ1wiICc7XG4gIH0pO1xuXG4gIHJldHVybiAnJyArIG9ialRhZyArIGF0dHJzU3RyaW5nICsgJz4nICsgcGFyYW1zU3RyaW5nICsgJzwvb2JqZWN0Pic7XG59O1xuXG4vLyBSdW4gRmxhc2ggdGhyb3VnaCB0aGUgUlRNUCBkZWNvcmF0b3JcbkZsYXNoUnRtcERlY29yYXRvcihGbGFzaCk7XG5cbmlmIChUZWNoLmdldFRlY2goJ0ZsYXNoJykpIHtcbiAgdmlkZW9qcy5sb2cud2FybignTm90IHVzaW5nIHZpZGVvanMtZmxhc2ggYXMgaXQgYXBwZWFycyB0byBhbHJlYWR5IGJlIHJlZ2lzdGVyZWQnKTtcbiAgdmlkZW9qcy5sb2cud2FybigndmlkZW9qcy1mbGFzaCBzaG91bGQgb25seSBiZSB1c2VkIHdpdGggdmlkZW8uanNANiBhbmQgYWJvdmUnKTtcbn0gZWxzZSB7XG4gIHZpZGVvanMucmVnaXN0ZXJUZWNoKCdGbGFzaCcsIEZsYXNoKTtcbn1cblxuRmxhc2guVkVSU0lPTiA9IHZlcnNpb24kMTtcblxuZXhwb3J0IGRlZmF1bHQgRmxhc2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92aWRlb2pzLWZsYXNoL2Rpc3QvdmlkZW9qcy1mbGFzaC5lcy5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25\n")},function(module,exports){eval('module.exports = {"_args":[["videojs-swf@5.4.1","/Users/nali/Documents/work/git_libs/vplayer"]],"_from":"videojs-swf@5.4.1","_id":"videojs-swf@5.4.1","_inBundle":false,"_integrity":"sha1-IHfvccdJ8seCPvSbq65N0qywj4c=","_location":"/videojs-swf","_phantomChildren":{},"_requested":{"type":"version","registry":true,"raw":"videojs-swf@5.4.1","name":"videojs-swf","escapedName":"videojs-swf","rawSpec":"5.4.1","saveSpec":null,"fetchSpec":"5.4.1"},"_requiredBy":["/videojs-contrib-hls/videojs-contrib-media-sources/video.js","/videojs-flash"],"_resolved":"http://r.cnpmjs.org/videojs-swf/download/videojs-swf-5.4.1.tgz","_spec":"5.4.1","_where":"/Users/nali/Documents/work/git_libs/vplayer","author":{"name":"Brightcove"},"bugs":{"url":"https://github.com/videojs/video-js-swf/issues"},"copyright":"Copyright 2014 Brightcove, Inc. https://github.com/videojs/video-js-swf/blob/master/LICENSE","description":"The Flash-fallback video player for video.js (http://videojs.com)","devDependencies":{"async":"~0.2.9","chg":"^0.3.2","flex-sdk":"4.6.0-0","grunt":"~0.4.0","grunt-bumpup":"~0.5.0","grunt-cli":"~0.1.0","grunt-connect":"~0.2.0","grunt-contrib-jshint":"~0.4.3","grunt-contrib-qunit":"~0.2.1","grunt-contrib-watch":"~0.1.4","grunt-npm":"~0.0.2","grunt-prompt":"~0.1.2","grunt-shell":"~0.6.1","grunt-tagrelease":"~0.3.1","qunitjs":"~1.12.0","video.js":"^5.9.2"},"homepage":"http://videojs.com","keywords":["flash","video","player"],"name":"videojs-swf","repository":{"type":"git","url":"git+https://github.com/videojs/video-js-swf.git"},"scripts":{"version":"chg release -y && grunt dist && git add -f dist/ && git add CHANGELOG.md"},"version":"5.4.1"}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1zd2YvcGFja2FnZS5qc29uP2JjMGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsa0JBQWtCLHVQQUF1UCxlQUFlLGtLQUFrSyw4UEFBOFAsb0JBQW9CLFNBQVMsdURBQXVELGdOQUFnTixrWEFBa1gsMEdBQTBHLHFFQUFxRSxZQUFZLHFGQUFxRiIsImZpbGUiOiIyNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1wiX2FyZ3NcIjpbW1widmlkZW9qcy1zd2ZANS40LjFcIixcIi9Vc2Vycy9uYWxpL0RvY3VtZW50cy93b3JrL2dpdF9saWJzL3ZwbGF5ZXJcIl1dLFwiX2Zyb21cIjpcInZpZGVvanMtc3dmQDUuNC4xXCIsXCJfaWRcIjpcInZpZGVvanMtc3dmQDUuNC4xXCIsXCJfaW5CdW5kbGVcIjpmYWxzZSxcIl9pbnRlZ3JpdHlcIjpcInNoYTEtSUhmdmNjZEo4c2VDUHZTYnE2NU4wcXl3ajRjPVwiLFwiX2xvY2F0aW9uXCI6XCIvdmlkZW9qcy1zd2ZcIixcIl9waGFudG9tQ2hpbGRyZW5cIjp7fSxcIl9yZXF1ZXN0ZWRcIjp7XCJ0eXBlXCI6XCJ2ZXJzaW9uXCIsXCJyZWdpc3RyeVwiOnRydWUsXCJyYXdcIjpcInZpZGVvanMtc3dmQDUuNC4xXCIsXCJuYW1lXCI6XCJ2aWRlb2pzLXN3ZlwiLFwiZXNjYXBlZE5hbWVcIjpcInZpZGVvanMtc3dmXCIsXCJyYXdTcGVjXCI6XCI1LjQuMVwiLFwic2F2ZVNwZWNcIjpudWxsLFwiZmV0Y2hTcGVjXCI6XCI1LjQuMVwifSxcIl9yZXF1aXJlZEJ5XCI6W1wiL3ZpZGVvanMtY29udHJpYi1obHMvdmlkZW9qcy1jb250cmliLW1lZGlhLXNvdXJjZXMvdmlkZW8uanNcIixcIi92aWRlb2pzLWZsYXNoXCJdLFwiX3Jlc29sdmVkXCI6XCJodHRwOi8vci5jbnBtanMub3JnL3ZpZGVvanMtc3dmL2Rvd25sb2FkL3ZpZGVvanMtc3dmLTUuNC4xLnRnelwiLFwiX3NwZWNcIjpcIjUuNC4xXCIsXCJfd2hlcmVcIjpcIi9Vc2Vycy9uYWxpL0RvY3VtZW50cy93b3JrL2dpdF9saWJzL3ZwbGF5ZXJcIixcImF1dGhvclwiOntcIm5hbWVcIjpcIkJyaWdodGNvdmVcIn0sXCJidWdzXCI6e1widXJsXCI6XCJodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby1qcy1zd2YvaXNzdWVzXCJ9LFwiY29weXJpZ2h0XCI6XCJDb3B5cmlnaHQgMjAxNCBCcmlnaHRjb3ZlLCBJbmMuIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLWpzLXN3Zi9ibG9iL21hc3Rlci9MSUNFTlNFXCIsXCJkZXNjcmlwdGlvblwiOlwiVGhlIEZsYXNoLWZhbGxiYWNrIHZpZGVvIHBsYXllciBmb3IgdmlkZW8uanMgKGh0dHA6Ly92aWRlb2pzLmNvbSlcIixcImRldkRlcGVuZGVuY2llc1wiOntcImFzeW5jXCI6XCJ+MC4yLjlcIixcImNoZ1wiOlwiXjAuMy4yXCIsXCJmbGV4LXNka1wiOlwiNC42LjAtMFwiLFwiZ3J1bnRcIjpcIn4wLjQuMFwiLFwiZ3J1bnQtYnVtcHVwXCI6XCJ+MC41LjBcIixcImdydW50LWNsaVwiOlwifjAuMS4wXCIsXCJncnVudC1jb25uZWN0XCI6XCJ+MC4yLjBcIixcImdydW50LWNvbnRyaWItanNoaW50XCI6XCJ+MC40LjNcIixcImdydW50LWNvbnRyaWItcXVuaXRcIjpcIn4wLjIuMVwiLFwiZ3J1bnQtY29udHJpYi13YXRjaFwiOlwifjAuMS40XCIsXCJncnVudC1ucG1cIjpcIn4wLjAuMlwiLFwiZ3J1bnQtcHJvbXB0XCI6XCJ+MC4xLjJcIixcImdydW50LXNoZWxsXCI6XCJ+MC42LjFcIixcImdydW50LXRhZ3JlbGVhc2VcIjpcIn4wLjMuMVwiLFwicXVuaXRqc1wiOlwifjEuMTIuMFwiLFwidmlkZW8uanNcIjpcIl41LjkuMlwifSxcImhvbWVwYWdlXCI6XCJodHRwOi8vdmlkZW9qcy5jb21cIixcImtleXdvcmRzXCI6W1wiZmxhc2hcIixcInZpZGVvXCIsXCJwbGF5ZXJcIl0sXCJuYW1lXCI6XCJ2aWRlb2pzLXN3ZlwiLFwicmVwb3NpdG9yeVwiOntcInR5cGVcIjpcImdpdFwiLFwidXJsXCI6XCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8tanMtc3dmLmdpdFwifSxcInNjcmlwdHNcIjp7XCJ2ZXJzaW9uXCI6XCJjaGcgcmVsZWFzZSAteSAmJiBncnVudCBkaXN0ICYmIGdpdCBhZGQgLWYgZGlzdC8gJiYgZ2l0IGFkZCBDSEFOR0VMT0cubWRcIn0sXCJ2ZXJzaW9uXCI6XCI1LjQuMVwifVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3ZpZGVvanMtc3dmL3BhY2thZ2UuanNvblxuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26\n')},function(module,exports,__webpack_require__){eval('var win;\n\nif (typeof window !== "undefined") {\n    win = window;\n} else if (false) {\n    win = global;\n} else if (typeof self !== "undefined"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsL3dpbmRvdy5qcz82YjAxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSIsImZpbGUiOiIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB3aW47XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgd2luID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgd2luID0ge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2xvYmFsL3dpbmRvdy5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27\n')},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(29);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(4)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!./vplayer.css\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!./vplayer.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdnBsYXllci5jc3M/YjM0ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vdnBsYXllci5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vdnBsYXllci5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vdnBsYXllci5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZwbGF5ZXIuY3NzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///28\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(3)(false);\n// imports\n\n\n// module\nexports.push([module.i, ".video-js .vjs-big-play-button{width:2em;height:2em;line-height:2em;border-radius:50%;margin-top:-1em;margin-left:-1em}.video-js .vjs-current-time,.video-js .vjs-duration{display:inline-block}.vjs-play-progress .vjs-time-tooltip{display:none!important}", ""]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdnBsYXllci5jc3M/OTI2MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLHdEQUF5RCxVQUFVLFdBQVcsZ0JBQWdCLGtCQUFrQixnQkFBZ0IsaUJBQWlCLG9EQUFvRCxxQkFBcUIscUNBQXFDLHVCQUF1Qjs7QUFFdFIiLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi52aWRlby1qcyAudmpzLWJpZy1wbGF5LWJ1dHRvbnt3aWR0aDoyZW07aGVpZ2h0OjJlbTtsaW5lLWhlaWdodDoyZW07Ym9yZGVyLXJhZGl1czo1MCU7bWFyZ2luLXRvcDotMWVtO21hcmdpbi1sZWZ0Oi0xZW19LnZpZGVvLWpzIC52anMtY3VycmVudC10aW1lLC52aWRlby1qcyAudmpzLWR1cmF0aW9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrfS52anMtcGxheS1wcm9ncmVzcyAudmpzLXRpbWUtdG9vbHRpcHtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhLi9zcmMvdnBsYXllci5jc3Ncbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _video = __webpack_require__(0);\n\nvar _video2 = _interopRequireDefault(_video);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // import  videojs from './lib/videojs/video.js'\n// require('./lib/videojs/video-js.css')\n\nvar Plugin = _video2.default.getPlugin('plugin');\n\nvar VPlayerCounter = function (_Plugin) {\n    _inherits(VPlayerCounter, _Plugin);\n\n    function VPlayerCounter(player, options) {\n        _classCallCheck(this, VPlayerCounter);\n\n        var _this = _possibleConstructorReturn(this, (VPlayerCounter.__proto__ || Object.getPrototypeOf(VPlayerCounter)).call(this, player, options));\n\n        _this._option = options;\n        // 播放统计\n        _this.on(player, 'firstplay', function () {\n            _this.sendStats('playStart');\n        });\n\n        _this.on(player, 'ended', function () {\n            _this.sendStats('playEnd');\n        });\n        return _this;\n    }\n\n    _createClass(VPlayerCounter, [{\n        key: 'sendStats',\n        value: function sendStats(type) {\n\n            // https://github.com/naugtur/xhr\n            _video2.default.xhr({\n                url: this._option[type],\n                method: 'get',\n                timeout: 6000,\n                // headers: Object?,\n                // body: String? | Object?,\n                // json: false,\n                // withCredentials: false,\n                responseType: 'json'\n                // beforeSend: Function?\n            }, function (err, option, resp) {\n                // check resp.statusCode\n                // console.log(arguments)\n            });\n        }\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            _get(VPlayerCounter.prototype.__proto__ || Object.getPrototypeOf(VPlayerCounter.prototype), 'dispose', this).call(this);\n            _video2.default.log('the advanced plugin is being disposed');\n        }\n    }, {\n        key: 'updateState',\n        value: function updateState(type) {\n            this.setState({ playing: !player.paused() });\n        }\n    }, {\n        key: 'logState',\n        value: function logState(changed) {\n            _video2.default.log('the player is now ' + (this.state.playing ? 'playing' : 'paused'));\n        }\n    }]);\n\n    return VPlayerCounter;\n}(Plugin);\n\nexports.default = VPlayerCounter;\nmodule.exports = exports['default'];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdnBsYXllci1jb3VudGVyLmpzPzY5ZmIiXSwibmFtZXMiOlsiUGx1Z2luIiwiZ2V0UGx1Z2luIiwiVlBsYXllckNvdW50ZXIiLCJwbGF5ZXIiLCJvcHRpb25zIiwiX29wdGlvbiIsIm9uIiwic2VuZFN0YXRzIiwidHlwZSIsInhociIsInVybCIsIm1ldGhvZCIsInRpbWVvdXQiLCJyZXNwb25zZVR5cGUiLCJlcnIiLCJvcHRpb24iLCJyZXNwIiwibG9nIiwic2V0U3RhdGUiLCJwbGF5aW5nIiwicGF1c2VkIiwiY2hhbmdlZCIsInN0YXRlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBR0E7Ozs7Ozs7Ozs7K2VBSEE7QUFDQTs7QUFJQSxJQUFNQSxTQUFTLGdCQUFRQyxTQUFSLENBQWtCLFFBQWxCLENBQWY7O0lBRU1DLGM7OztBQUVGLDRCQUFZQyxNQUFaLEVBQW9CQyxPQUFwQixFQUE2QjtBQUFBOztBQUFBLG9JQUNuQkQsTUFEbUIsRUFDWEMsT0FEVzs7QUFFekIsY0FBS0MsT0FBTCxHQUFlRCxPQUFmO0FBQ0E7QUFDQSxjQUFLRSxFQUFMLENBQVFILE1BQVIsRUFBZ0IsV0FBaEIsRUFBNkIsWUFBTTtBQUMvQixrQkFBS0ksU0FBTCxDQUFlLFdBQWY7QUFDSCxTQUZEOztBQUlBLGNBQUtELEVBQUwsQ0FBUUgsTUFBUixFQUFnQixPQUFoQixFQUF5QixZQUFNO0FBQzNCLGtCQUFLSSxTQUFMLENBQWUsU0FBZjtBQUNILFNBRkQ7QUFSeUI7QUFXNUI7Ozs7a0NBRVNDLEksRUFBTTs7QUFFWjtBQUNBLDRCQUFRQyxHQUFSLENBQVk7QUFDUkMscUJBQUssS0FBS0wsT0FBTCxDQUFhRyxJQUFiLENBREc7QUFFUkcsd0JBQVEsS0FGQTtBQUdSQyx5QkFBUyxJQUhEO0FBSVI7QUFDQTtBQUNBO0FBQ0E7QUFDQUMsOEJBQWM7QUFDZDtBQVRRLGFBQVosRUFVRyxVQUFTQyxHQUFULEVBQWNDLE1BQWQsRUFBc0JDLElBQXRCLEVBQTRCO0FBQzNCO0FBQ0E7QUFDSCxhQWJEO0FBY0g7OztrQ0FFUztBQUNOO0FBQ0EsNEJBQVFDLEdBQVIsQ0FBWSx1Q0FBWjtBQUNIOzs7b0NBRVdULEksRUFBTTtBQUNkLGlCQUFLVSxRQUFMLENBQWMsRUFBRUMsU0FBUyxDQUFDaEIsT0FBT2lCLE1BQVAsRUFBWixFQUFkO0FBRUg7OztpQ0FFUUMsTyxFQUFTO0FBQ2QsNEJBQVFKLEdBQVIseUJBQWlDLEtBQUtLLEtBQUwsQ0FBV0gsT0FBWCxHQUFxQixTQUFyQixHQUFpQyxRQUFsRTtBQUNIOzs7O0VBOUN3Qm5CLE07O2tCQWlEZEUsYyIsImZpbGUiOiIzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydCAgdmlkZW9qcyBmcm9tICcuL2xpYi92aWRlb2pzL3ZpZGVvLmpzJ1xuLy8gcmVxdWlyZSgnLi9saWIvdmlkZW9qcy92aWRlby1qcy5jc3MnKVxuXG5pbXBvcnQgdmlkZW9qcyBmcm9tICd2aWRlby5qcyc7XG5cbmNvbnN0IFBsdWdpbiA9IHZpZGVvanMuZ2V0UGx1Z2luKCdwbHVnaW4nKTtcblxuY2xhc3MgVlBsYXllckNvdW50ZXIgZXh0ZW5kcyBQbHVnaW4ge1xuXG4gICAgY29uc3RydWN0b3IocGxheWVyLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHBsYXllciwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX29wdGlvbiA9IG9wdGlvbnM7XG4gICAgICAgIC8vIOaSreaUvue7n+iuoVxuICAgICAgICB0aGlzLm9uKHBsYXllciwgJ2ZpcnN0cGxheScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VuZFN0YXRzKCdwbGF5U3RhcnQnKVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9uKHBsYXllciwgJ2VuZGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZW5kU3RhdHMoJ3BsYXlFbmQnKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZW5kU3RhdHModHlwZSkge1xuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXVndHVyL3hoclxuICAgICAgICB2aWRlb2pzLnhocih7XG4gICAgICAgICAgICB1cmw6IHRoaXMuX29wdGlvblt0eXBlXSxcbiAgICAgICAgICAgIG1ldGhvZDogJ2dldCcsXG4gICAgICAgICAgICB0aW1lb3V0OiA2MDAwLFxuICAgICAgICAgICAgLy8gaGVhZGVyczogT2JqZWN0PyxcbiAgICAgICAgICAgIC8vIGJvZHk6IFN0cmluZz8gfCBPYmplY3Q/LFxuICAgICAgICAgICAgLy8ganNvbjogZmFsc2UsXG4gICAgICAgICAgICAvLyB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgICAgICAvLyBiZWZvcmVTZW5kOiBGdW5jdGlvbj9cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBvcHRpb24sIHJlc3ApIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHJlc3Auc3RhdHVzQ29kZVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYXJndW1lbnRzKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgICAgIHZpZGVvanMubG9nKCd0aGUgYWR2YW5jZWQgcGx1Z2luIGlzIGJlaW5nIGRpc3Bvc2VkJyk7XG4gICAgfVxuXG4gICAgdXBkYXRlU3RhdGUodHlwZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgcGxheWluZzogIXBsYXllci5wYXVzZWQoKSB9KTtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgbG9nU3RhdGUoY2hhbmdlZCkge1xuICAgICAgICB2aWRlb2pzLmxvZyhgdGhlIHBsYXllciBpcyBub3cgJHt0aGlzLnN0YXRlLnBsYXlpbmcgPyAncGxheWluZycgOiAncGF1c2VkJ31gKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZQbGF5ZXJDb3VudGVyXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3ZwbGF5ZXItY291bnRlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///30\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _video = __webpack_require__(0);\n\nvar _video2 = _interopRequireDefault(_video);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// s:算法区\nfunction pa(a) {\n    if (!a) return "";\n    var a = a.toString(),\n        c,\n        b,\n        f,\n        k,\n        e,\n        h = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1];\n    k = a.length;\n    f = 0;\n    for (e = ""; f < k;) {\n        do {\n            c = h[a.charCodeAt(f++) & 255];\n        } while (f < k && -1 == c);\n        if (-1 == c) break;\n        do {\n            b = h[a.charCodeAt(f++) & 255];\n        } while (f < k && -1 == b);\n        if (-1 == b) break;\n        e += String.fromCharCode(c << 2 | (b & 48) >> 4);\n        do {\n            c = a.charCodeAt(f++) & 255;\n            if (61 == c) return e;\n            c = h[c];\n        } while (f < k && -1 == c);\n        if (-1 == c) break;\n        e += String.fromCharCode((b & 15) << 4 | (c & 60) >> 2);\n        do {\n            b = a.charCodeAt(f++) & 255;\n            if (61 == b) return e;\n            b = h[b];\n        } while (f < k && -1 == b);\n        if (-1 == b) break;\n        e += String.fromCharCode((c & 3) << 6 | b);\n    }\n    return e;\n}\n\nfunction E(a) {\n    if (!a) return "";\n    var a = a.toString(),\n        b,\n        d,\n        f,\n        e,\n        g,\n        h;\n    f = a.length;\n    d = 0;\n    for (b = ""; d < f;) {\n        e = a.charCodeAt(d++) & 255;\n        if (d == f) {\n            b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e >> 2);\n            b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((e & 3) << 4);\n            b += "==";\n            break;\n        }\n        g = a.charCodeAt(d++);\n        if (d == f) {\n            b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e >> 2);\n            b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((e & 3) << 4 | (g & 240) >> 4);\n            b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((g & 15) << 2);\n            b += "=";\n            break;\n        }\n        h = a.charCodeAt(d++);\n        b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e >> 2);\n        b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((e & 3) << 4 | (g & 240) >> 4);\n        b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((g & 15) << 2 | (h & 192) >> 6);\n        b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(h & 63);\n    }\n    return b;\n}\n\nfunction F(a, c) {\n    for (var b = [], f = 0, k, e = "", h = 0; 256 > h; h++) {\n        b[h] = h;\n    }for (h = 0; 256 > h; h++) {\n        f = (f + b[h] + a.charCodeAt(h % a.length)) % 256, k = b[h], b[h] = b[f], b[f] = k;\n    }for (var p = f = h = 0; p < c.length; p++) {\n        h = (h + 1) % 256, f = (f + b[h]) % 256, k = b[h], b[h] = b[f], b[f] = k, e += String.fromCharCode(c.charCodeAt(p) ^ b[(b[h] + b[f]) % 256]);\n    }return e;\n}\n\nfunction G(a, c) {\n    for (var b = [], f = 0; f < a.length; f++) {\n        for (var e = 0, e = "a" <= a[f] && "z" >= a[f] ? a[f].charCodeAt(0) - 97 : a[f] - 0 + 26, g = 0; 36 > g; g++) {\n            if (c[g] == e) {\n                e = g;\n                break;\n            }\n        }b[f] = 25 < e ? e - 26 : String.fromCharCode(e + 97);\n    }\n    return b.join("");\n}\n\nfunction W(a) {\n    this._randomSeed = a;\n    this.cg_hun();\n}\nW.prototype = {\n    cg_hun: function cg_hun() {\n        this._cgStr = "";\n        var a = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/\\\\:._-1234567890",\n            c = a.length,\n            b = 0;\n        for (b = 0; b < c; b++) {\n            var k = this.ran();\n            var kk = k * a.length;\n            var f = parseInt(kk);\n            this._cgStr += a.charAt(f);\n            a = a.split(a.charAt(f)).join("");\n        }\n    },\n    cg_fun: function cg_fun(a) {\n        var a = a.split("*"),\n            c = "",\n            b = 0;\n        for (b = 0; b < a.length - 1; b++) {\n            c += this._cgStr.charAt(a[b]);\n        }return c;\n    },\n    ran: function ran() {\n        this._randomSeed = (211 * this._randomSeed + 30031) % 65536;\n        return this._randomSeed / 65536;\n    },\n    cg_decode: function cg_decode(a) {\n        var c = "",\n            b = 0;\n        for (b = 0; b < a.length; b++) {\n            var k = a.charAt(b);\n            var index = this._cgStr.indexOf(k);\n            if (index !== -1) {\n                c += "" + index + "*";\n            }\n        }\n        return c;\n    }\n};\n\n// e:算法区\nfunction serialize(obj) {\n    var arr = [];\n    for (var p in obj) {\n        if (obj.hasOwnProperty(p)) {\n            arr.push(p + \'=\' + obj[p]);\n        }\n    }\n    return arr.join(\'&\');\n}\n\nfunction addExtraParam(obj, url) {\n    var uri = url || window.location.href;\n\n    // url 含有参数\n    if (uri.indexOf(\'?\') > -1) {\n        var match = uri.match(/\\?([^#]*)/);\n        var params = match[1].split(\'&\');\n        var query = {};\n\n        for (var i = params.length - 1; i >= 0; i--) {\n            var tem = params[i].split(\'=\');\n            query[tem[0]] = decodeURIComponent(tem[1]);\n        }\n\n        for (var p in obj) {\n            if (obj.hasOwnProperty(p)) {\n                query[p] = obj[p];\n            }\n        }\n        return uri.replace(/\\?([^#]*)/, \'?\' + serialize(query));\n    } else {\n        var qStr = serialize(obj);\n        if (uri.indexOf(\'#\') > -1) {\n\n            qStr !== \'\' && (uri = uri.replace(/([^#]*)(?=#)/, \'$1?\' + qStr));\n        } else {\n            qStr !== \'\' && (uri += \'?\' + qStr);\n        }\n        return uri;\n    }\n\n    return url;\n}\n\nvar Plugin = _video2.default.getPlugin(\'plugin\');\n\nvar VPlayerLinkProtecter = function (_Plugin) {\n    _inherits(VPlayerLinkProtecter, _Plugin);\n\n    function VPlayerLinkProtecter(player, options) {\n        _classCallCheck(this, VPlayerLinkProtecter);\n\n        var _this = _possibleConstructorReturn(this, (VPlayerLinkProtecter.__proto__ || Object.getPrototypeOf(VPlayerLinkProtecter)).call(this, player));\n\n        _this._option = Object.assign({\n            linkProtecterQuery: \'\',\n            linkProtecterCDN: \'\',\n            isBackend: false,\n            accountInfo: {\n                uid: 99\n            },\n            deviceType: \'pc\',\n            parseQueryUrl: null\n        }, options);\n        return _this;\n    }\n\n    _createClass(VPlayerLinkProtecter, [{\n        key: "_parseQueryUrl",\n        value: function _parseQueryUrl(url, video, opt) {\n            var params = {\n                device: opt.deviceType,\n                isBackend: opt.isBackend,\n                uid: opt.accountInfo.uid,\n                // token:opt.accountInfo.token,\n                ts: +new Date(),\n                def: 1 //清晰度选择（0：标清；1：高清）\n            };\n\n            var url = url.replace(\'{lessonId}\', video.id).replace(\'{businessType}\', video.businessType);\n            return addExtraParam(params, url);\n        }\n    }, {\n        key: "query",\n        value: function query(video, canPlay, cannotPlay) {\n            // videojs.browser\n            var opt = this._option;\n            var url = (opt.parseQueryUrl || this._parseQueryUrl).call(this, opt.linkProtecterQuery, video, opt);\n\n            // https://github.com/naugtur/xhr\n            _video2.default.xhr({\n                url: url,\n                method: \'get\',\n                timeout: 10e3,\n                // sync:true,\n                // json:true,   // application/json\n                // headers: {\n                // \t\'X-Requested-With\':\'XMLHttpRequest\'\n                // },\n                // body: String? | Object?,\n                // withCredentials: false,\n                responseType: \'json\'\n                // beforeSend: Function?\n            }, function (err, res, data) {\n\n                if (err) {\n                    cannotPlay(video, err);\n                    return;\n                }\n\n                // 处理异常\n                if ([400, 403, 404, 500].indexOf(res.statusCode) > -1) {\n                    try {\n                        if (res && res.body) {\n                            var _data = res.body;\n                            video.linkData = _data;\n                            cannotPlay(_data);\n                        }\n                    } catch (e) {}\n                    return;\n                }\n\n                if (data.ret) {\n                    cannotPlay(data);\n                    return;\n                }\n\n                video.linkData = data;\n\n                var G_key = \'dg3utf1k6yxdwi09\';\n                var G_data = [19, 1, 4, 7, 30, 14, 28, 8, 24, 17, 6, 35, 34, 16, 9, 10, 13, 22, 32, 29, 31, 21, 18, 3, 2, 23, 25, 27, 11, 20, 5, 15, 12, 0, 33, 26];\n                var rc4_key = G(G_key, G_data);\n                var arr = F(rc4_key, pa(data.ep)).split("-");\n                var w = new W(data.seed);\n                var r = w.cg_fun(data.fileId);\n                var sign = arr[1];\n                var buy_key = arr[0];\n                var token = arr[2];\n                var timestamp = arr[3];\n                var duration = data.duration;\n                r = r[0] === \'/\' ? r : \'/\' + r;\n                var src = (data.domain || opt.linkProtecterCDN) + \'/download/\' + data.apiVersion + r + \'?sign=\' + encodeURIComponent(sign) + \'&buy_key=\' + encodeURIComponent(buy_key) + \'&timestamp=\' + timestamp + \'&token=\' + encodeURIComponent(token) + \'&duration=\' + duration;\n\n                video.src = src;\n\n                // console.log(src)\n                // video.src = \'http://fdfs.test.ximalaya.com/group1/M01/50/76/wKgD3lnOBhaADk7MAAAA0Qr7A-I19.m3u8\';\n                canPlay(video);\n            });\n        }\n    }]);\n\n    return VPlayerLinkProtecter;\n}(Plugin);\n\nexports.default = VPlayerLinkProtecter;\nmodule.exports = exports["default"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdnBsYXllci1saW5rLXByb3RlY3Rlci5qcz8wNzgwIl0sIm5hbWVzIjpbInBhIiwiYSIsInRvU3RyaW5nIiwiYyIsImIiLCJmIiwiayIsImUiLCJoIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIkUiLCJkIiwiZyIsImNoYXJBdCIsIkYiLCJwIiwiRyIsImpvaW4iLCJXIiwiX3JhbmRvbVNlZWQiLCJjZ19odW4iLCJwcm90b3R5cGUiLCJfY2dTdHIiLCJyYW4iLCJrayIsInBhcnNlSW50Iiwic3BsaXQiLCJjZ19mdW4iLCJjZ19kZWNvZGUiLCJpbmRleCIsImluZGV4T2YiLCJzZXJpYWxpemUiLCJvYmoiLCJhcnIiLCJoYXNPd25Qcm9wZXJ0eSIsInB1c2giLCJhZGRFeHRyYVBhcmFtIiwidXJsIiwidXJpIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwibWF0Y2giLCJwYXJhbXMiLCJxdWVyeSIsImkiLCJ0ZW0iLCJkZWNvZGVVUklDb21wb25lbnQiLCJyZXBsYWNlIiwicVN0ciIsIlBsdWdpbiIsImdldFBsdWdpbiIsIlZQbGF5ZXJMaW5rUHJvdGVjdGVyIiwicGxheWVyIiwib3B0aW9ucyIsIl9vcHRpb24iLCJPYmplY3QiLCJhc3NpZ24iLCJsaW5rUHJvdGVjdGVyUXVlcnkiLCJsaW5rUHJvdGVjdGVyQ0ROIiwiaXNCYWNrZW5kIiwiYWNjb3VudEluZm8iLCJ1aWQiLCJkZXZpY2VUeXBlIiwicGFyc2VRdWVyeVVybCIsInZpZGVvIiwib3B0IiwiZGV2aWNlIiwidHMiLCJEYXRlIiwiZGVmIiwiaWQiLCJidXNpbmVzc1R5cGUiLCJjYW5QbGF5IiwiY2Fubm90UGxheSIsIl9wYXJzZVF1ZXJ5VXJsIiwiY2FsbCIsInhociIsIm1ldGhvZCIsInRpbWVvdXQiLCJyZXNwb25zZVR5cGUiLCJlcnIiLCJyZXMiLCJkYXRhIiwic3RhdHVzQ29kZSIsImJvZHkiLCJsaW5rRGF0YSIsInJldCIsIkdfa2V5IiwiR19kYXRhIiwicmM0X2tleSIsImVwIiwidyIsInNlZWQiLCJyIiwiZmlsZUlkIiwic2lnbiIsImJ1eV9rZXkiLCJ0b2tlbiIsInRpbWVzdGFtcCIsImR1cmF0aW9uIiwic3JjIiwiZG9tYWluIiwiYXBpVmVyc2lvbiIsImVuY29kZVVSSUNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7O0FBRUE7QUFDQSxTQUFTQSxFQUFULENBQVlDLENBQVosRUFBZTtBQUNYLFFBQUksQ0FBQ0EsQ0FBTCxFQUFRLE9BQU8sRUFBUDtBQUNSLFFBQUlBLElBQUlBLEVBQUVDLFFBQUYsRUFBUjtBQUFBLFFBQ0lDLENBREo7QUFBQSxRQUNPQyxDQURQO0FBQUEsUUFDVUMsQ0FEVjtBQUFBLFFBQ2FDLENBRGI7QUFBQSxRQUNnQkMsQ0FEaEI7QUFBQSxRQUNtQkMsSUFBSSxDQUFDLENBQUMsQ0FBRixFQUFLLENBQUMsQ0FBTixFQUFTLENBQUMsQ0FBVixFQUFhLENBQUMsQ0FBZCxFQUFpQixDQUFDLENBQWxCLEVBQXFCLENBQUMsQ0FBdEIsRUFBeUIsQ0FBQyxDQUExQixFQUE2QixDQUFDLENBQTlCLEVBQWlDLENBQUMsQ0FBbEMsRUFBcUMsQ0FBQyxDQUF0QyxFQUF5QyxDQUFDLENBQTFDLEVBQTZDLENBQUMsQ0FBOUMsRUFBaUQsQ0FBQyxDQUFsRCxFQUFxRCxDQUFDLENBQXRELEVBQXlELENBQUMsQ0FBMUQsRUFBNkQsQ0FBQyxDQUE5RCxFQUFpRSxDQUFDLENBQWxFLEVBQXFFLENBQUMsQ0FBdEUsRUFBeUUsQ0FBQyxDQUExRSxFQUE2RSxDQUFDLENBQTlFLEVBQWlGLENBQUMsQ0FBbEYsRUFBcUYsQ0FBQyxDQUF0RixFQUF5RixDQUFDLENBQTFGLEVBQTZGLENBQUMsQ0FBOUYsRUFBaUcsQ0FBQyxDQUFsRyxFQUFxRyxDQUFDLENBQXRHLEVBQXlHLENBQUMsQ0FBMUcsRUFBNkcsQ0FBQyxDQUE5RyxFQUFpSCxDQUFDLENBQWxILEVBQXFILENBQUMsQ0FBdEgs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LENBQWQ7QUFDQSxvQkFBSWlFLFFBQVFqRSxJQUFJLENBQUosQ0FBWjtBQUNBLG9CQUFJa0UsWUFBWWxFLElBQUksQ0FBSixDQUFoQjtBQUNBLG9CQUFJbUUsV0FBV2pCLEtBQUtpQixRQUFwQjtBQUNBTixvQkFBSUEsRUFBRSxDQUFGLE1BQVMsR0FBVCxHQUFlQSxDQUFmLEdBQW9CLE1BQU1BLENBQTlCO0FBQ0Esb0JBQUlPLE1BQU0sQ0FBQ2xCLEtBQUttQixNQUFMLElBQWVwQyxJQUFJUCxnQkFBcEIsSUFBd0MsWUFBeEMsR0FBdUR3QixLQUFLb0IsVUFBNUQsR0FBeUVULENBQXpFLEdBQ04sUUFETSxHQUNLVSxtQkFBbUJSLElBQW5CLENBREwsR0FFTixXQUZNLEdBRVFRLG1CQUFtQlAsT0FBbkIsQ0FGUixHQUdOLGFBSE0sR0FHVUUsU0FIVixHQUlOLFNBSk0sR0FJTUssbUJBQW1CTixLQUFuQixDQUpOLEdBS04sWUFMTSxHQUtTRSxRQUxuQjs7QUFPQW5DLHNCQUFNb0MsR0FBTixHQUFZQSxHQUFaOztBQUVBO0FBQ0E7QUFDQTVCLHdCQUFRUixLQUFSO0FBQ0gsYUEvREQ7QUFnRUg7Ozs7RUFwRzhCZixNOztrQkF1R3BCRSxvQiIsImZpbGUiOiIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2aWRlb2pzIGZyb20gJ3ZpZGVvLmpzJztcblxuLy8gczrnrpfms5XljLpcbmZ1bmN0aW9uIHBhKGEpIHtcbiAgICBpZiAoIWEpIHJldHVybiBcIlwiO1xuICAgIHZhciBhID0gYS50b1N0cmluZygpLFxuICAgICAgICBjLCBiLCBmLCBrLCBlLCBoID0gWy0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCA2MiwgLTEsIC0xLCAtMSwgNjMsIDUyLCA1MywgNTQsIDU1LCA1NiwgNTcsIDU4LCA1OSwgNjAsIDYxLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIDI2LCAyNyxcbiAgICAgICAgICAgIDI4LCAyOSwgMzAsIDMxLCAzMiwgMzMsIDM0LCAzNSwgMzYsIDM3LCAzOCwgMzksIDQwLCA0MSwgNDIsIDQzLCA0NCwgNDUsIDQ2LCA0NywgNDgsIDQ5LCA1MCwgNTEsIC0xLCAtMSwgLTEsIC0xLCAtMVxuICAgICAgICBdO1xuICAgIGsgPSBhLmxlbmd0aDtcbiAgICBmID0gMDtcbiAgICBmb3IgKGUgPSBcIlwiOyBmIDwgazspIHtcbiAgICAgICAgZG8gYyA9IGhbYS5jaGFyQ29kZUF0KGYrKykgJiAyNTVdO1xuICAgICAgICB3aGlsZSAoZiA8IGsgJiYgLTEgPT0gYyk7XG4gICAgICAgIGlmICgtMSA9PSBjKSBicmVhaztcbiAgICAgICAgZG8gYiA9IGhbYS5jaGFyQ29kZUF0KGYrKykgJiAyNTVdO1xuICAgICAgICB3aGlsZSAoZiA8IGsgJiYgLTEgPT0gYik7XG4gICAgICAgIGlmICgtMSA9PSBiKSBicmVhaztcbiAgICAgICAgZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMgPDwgMiB8IChiICYgNDgpID4+IDQpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjID0gYS5jaGFyQ29kZUF0KGYrKykgJiAyNTU7XG4gICAgICAgICAgICBpZiAoNjEgPT0gYykgcmV0dXJuIGU7XG4gICAgICAgICAgICBjID0gaFtjXVxuICAgICAgICB9IHdoaWxlIChmIDwgayAmJiAtMSA9PSBjKTtcbiAgICAgICAgaWYgKC0xID09IGMpIGJyZWFrO1xuICAgICAgICBlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGIgJiAxNSkgPDwgNCB8IChjICYgNjApID4+IDIpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBiID0gYS5jaGFyQ29kZUF0KGYrKykgJiAyNTU7XG4gICAgICAgICAgICBpZiAoNjEgPT0gYikgcmV0dXJuIGU7XG4gICAgICAgICAgICBiID0gaFtiXVxuICAgICAgICB9IHdoaWxlIChmIDwgayAmJiAtMSA9PSBiKTtcbiAgICAgICAgaWYgKC0xID09IGIpIGJyZWFrO1xuICAgICAgICBlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAzKSA8PCA2IHwgYilcbiAgICB9XG4gICAgcmV0dXJuIGVcbn1cblxuZnVuY3Rpb24gRShhKSB7XG4gICAgaWYgKCFhKSByZXR1cm4gXCJcIjtcbiAgICB2YXIgYSA9IGEudG9TdHJpbmcoKSxcbiAgICAgICAgYiwgZCwgZiwgZSwgZywgaDtcbiAgICBmID0gYS5sZW5ndGg7XG4gICAgZCA9IDA7XG4gICAgZm9yIChiID0gXCJcIjsgZCA8IGY7KSB7XG4gICAgICAgIGUgPSBhLmNoYXJDb2RlQXQoZCsrKSAmIDI1NTtcbiAgICAgICAgaWYgKGQgPT0gZikge1xuICAgICAgICAgICAgYiArPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5jaGFyQXQoZSA+PiAyKTtcbiAgICAgICAgICAgIGIgKz0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIuY2hhckF0KChlICYgMykgPDwgNCk7XG4gICAgICAgICAgICBiICs9IFwiPT1cIjtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZyA9IGEuY2hhckNvZGVBdChkKyspO1xuICAgICAgICBpZiAoZCA9PSBmKSB7XG4gICAgICAgICAgICBiICs9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLmNoYXJBdChlID4+IDIpO1xuICAgICAgICAgICAgYiArPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5jaGFyQXQoKGUgJiAzKSA8PCA0IHwgKGcgJiAyNDApID4+IDQpO1xuICAgICAgICAgICAgYiArPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5jaGFyQXQoKGcgJiAxNSkgPDwgMik7XG4gICAgICAgICAgICBiICs9IFwiPVwiO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBoID0gYS5jaGFyQ29kZUF0KGQrKyk7XG4gICAgICAgIGIgKz0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIuY2hhckF0KGUgPj4gMik7XG4gICAgICAgIGIgKz0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIuY2hhckF0KChlICYgMykgPDwgNCB8IChnICYgMjQwKSA+PiA0KTtcbiAgICAgICAgYiArPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5jaGFyQXQoKGcgJiAxNSkgPDwgMiB8IChoICYgMTkyKSA+PiA2KTtcbiAgICAgICAgYiArPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5jaGFyQXQoaCAmIDYzKVxuICAgIH1cbiAgICByZXR1cm4gYlxufVxuXG5mdW5jdGlvbiBGKGEsIGMpIHtcbiAgICBmb3IgKHZhciBiID0gW10sIGYgPSAwLCBrLCBlID0gXCJcIiwgaCA9IDA7IDI1NiA+IGg7IGgrKykgYltoXSA9IGg7XG4gICAgZm9yIChoID0gMDsgMjU2ID4gaDsgaCsrKSBmID0gKGYgKyBiW2hdICsgYS5jaGFyQ29kZUF0KGggJSBhLmxlbmd0aCkpICUgMjU2LCBrID0gYltoXSwgYltoXSA9IGJbZl0sIGJbZl0gPSBrO1xuICAgIGZvciAodmFyIHAgPSBmID0gaCA9IDA7IHAgPCBjLmxlbmd0aDsgcCsrKSBoID0gKGggKyAxKSAlIDI1NiwgZiA9IChmICsgYltoXSkgJSAyNTYsIGsgPSBiW2hdLCBiW2hdID0gYltmXSwgYltmXSA9IGssIGUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjLmNoYXJDb2RlQXQocCkgXiBiWyhiW2hdICsgYltmXSkgJSAyNTZdKTtcbiAgICByZXR1cm4gZVxufVxuXG5mdW5jdGlvbiBHKGEsIGMpIHtcbiAgICBmb3IgKHZhciBiID0gW10sIGYgPSAwOyBmIDwgYS5sZW5ndGg7IGYrKykge1xuICAgICAgICBmb3IgKHZhciBlID0gMCwgZSA9IFwiYVwiIDw9IGFbZl0gJiYgXCJ6XCIgPj0gYVtmXSA/IGFbZl0uY2hhckNvZGVBdCgwKSAtIDk3IDogYVtmXSAtIDAgKyAyNiwgZyA9IDA7IDM2ID4gZzsgZysrKVxuICAgICAgICAgICAgaWYgKGNbZ10gPT0gZSkge1xuICAgICAgICAgICAgICAgIGUgPSBnO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIGJbZl0gPSAyNSA8IGUgPyBlIC0gMjYgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGUgKyA5NylcbiAgICB9XG4gICAgcmV0dXJuIGIuam9pbihcIlwiKVxufVxuXG5mdW5jdGlvbiBXKGEpIHtcbiAgICB0aGlzLl9yYW5kb21TZWVkID0gYTtcbiAgICB0aGlzLmNnX2h1bigpO1xufVxuVy5wcm90b3R5cGUgPSB7XG4gICAgY2dfaHVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fY2dTdHIgPSBcIlwiO1xuICAgICAgICB2YXIgYSA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWi9cXFxcOi5fLTEyMzQ1Njc4OTBcIixcbiAgICAgICAgICAgIGMgPSBhLmxlbmd0aCxcbiAgICAgICAgICAgIGIgPSAwO1xuICAgICAgICBmb3IgKGIgPSAwOyBiIDwgYzsgYisrKSB7XG4gICAgICAgICAgICB2YXIgayA9IHRoaXMucmFuKCk7XG4gICAgICAgICAgICB2YXIga2sgPSBrICogYS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZiA9IHBhcnNlSW50KGtrKTtcbiAgICAgICAgICAgIHRoaXMuX2NnU3RyICs9IGEuY2hhckF0KGYpO1xuICAgICAgICAgICAgYSA9IGEuc3BsaXQoYS5jaGFyQXQoZikpLmpvaW4oXCJcIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNnX2Z1bjogZnVuY3Rpb24oYSkge1xuICAgICAgICB2YXIgYSA9IGEuc3BsaXQoXCIqXCIpLFxuICAgICAgICAgICAgYyA9IFwiXCIsXG4gICAgICAgICAgICBiID0gMDtcbiAgICAgICAgZm9yIChiID0gMDsgYiA8IGEubGVuZ3RoIC0gMTsgYisrKSBjICs9IHRoaXMuX2NnU3RyLmNoYXJBdChhW2JdKTtcbiAgICAgICAgcmV0dXJuIGNcbiAgICB9LFxuICAgIHJhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JhbmRvbVNlZWQgPSAoMjExICogdGhpcy5fcmFuZG9tU2VlZCArIDMwMDMxKSAlIDY1NTM2O1xuICAgICAgICByZXR1cm4gdGhpcy5fcmFuZG9tU2VlZCAvIDY1NTM2O1xuICAgIH0sXG4gICAgY2dfZGVjb2RlOiBmdW5jdGlvbihhKSB7XG4gICAgICAgIHZhciBjID0gXCJcIixcbiAgICAgICAgICAgIGIgPSAwO1xuICAgICAgICBmb3IgKGIgPSAwOyBiIDwgYS5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgdmFyIGsgPSBhLmNoYXJBdChiKTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2NnU3RyLmluZGV4T2Yoayk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYyArPSBcIlwiICsgaW5kZXggKyBcIipcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY1xuICAgIH1cbn07XG5cbi8vIGU6566X5rOV5Yy6XG5mdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvciAodmFyIHAgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKHAgKyAnPScgKyBvYmpbcF0pXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyci5qb2luKCcmJyk7XG59XG5cbmZ1bmN0aW9uIGFkZEV4dHJhUGFyYW0ob2JqLCB1cmwpIHtcbiAgICB2YXIgdXJpID0gdXJsIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuXG4gICAgLy8gdXJsIOWQq+acieWPguaVsFxuICAgIGlmICh1cmkuaW5kZXhPZignPycpID4gLTEpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gdXJpLm1hdGNoKC9cXD8oW14jXSopLyk7XG4gICAgICAgIHZhciBwYXJhbXMgPSBtYXRjaFsxXS5zcGxpdCgnJicpO1xuICAgICAgICB2YXIgcXVlcnkgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gcGFyYW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgdGVtID0gcGFyYW1zW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICBxdWVyeVt0ZW1bMF1dID0gZGVjb2RlVVJJQ29tcG9uZW50KHRlbVsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBwIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5W3BdID0gb2JqW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmkucmVwbGFjZSgvXFw/KFteI10qKS8sICc/JyArIHNlcmlhbGl6ZShxdWVyeSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBxU3RyID0gc2VyaWFsaXplKG9iaik7XG4gICAgICAgIGlmICh1cmkuaW5kZXhPZignIycpID4gLTEpIHtcblxuICAgICAgICAgICAgcVN0ciAhPT0gJycgJiYgKHVyaSA9IHVyaS5yZXBsYWNlKC8oW14jXSopKD89IykvLCAnJDE/JyArIHFTdHIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHFTdHIgIT09ICcnICYmICh1cmkgKz0gJz8nICsgcVN0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsO1xufVxuXG5jb25zdCBQbHVnaW4gPSB2aWRlb2pzLmdldFBsdWdpbigncGx1Z2luJyk7XG5cbmNsYXNzIFZQbGF5ZXJMaW5rUHJvdGVjdGVyIGV4dGVuZHMgUGx1Z2luIHtcblxuICAgIGNvbnN0cnVjdG9yKHBsYXllciwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihwbGF5ZXIpO1xuICAgICAgICB0aGlzLl9vcHRpb24gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGxpbmtQcm90ZWN0ZXJRdWVyeTogJycsXG4gICAgICAgICAgICBsaW5rUHJvdGVjdGVyQ0ROOiAnJyxcbiAgICAgICAgICAgIGlzQmFja2VuZDogZmFsc2UsXG4gICAgICAgICAgICBhY2NvdW50SW5mbzoge1xuICAgICAgICAgICAgICAgIHVpZDogOTlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXZpY2VUeXBlOiAncGMnLFxuICAgICAgICAgICAgcGFyc2VRdWVyeVVybDogbnVsbFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBfcGFyc2VRdWVyeVVybCh1cmwsdmlkZW8sb3B0KSB7XG4gICAgICAgIGxldCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBkZXZpY2U6IG9wdC5kZXZpY2VUeXBlLFxuICAgICAgICAgICAgaXNCYWNrZW5kOiBvcHQuaXNCYWNrZW5kLFxuICAgICAgICAgICAgdWlkOiBvcHQuYWNjb3VudEluZm8udWlkLFxuICAgICAgICAgICAgLy8gdG9rZW46b3B0LmFjY291bnRJbmZvLnRva2VuLFxuICAgICAgICAgICAgdHM6ICtuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgZGVmOiAxIC8v5riF5pmw5bqm6YCJ5oup77yIMO+8muagh+a4he+8mzHvvJrpq5jmuIXvvIlcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cmwgPSB1cmwucmVwbGFjZSgne2xlc3NvbklkfScsIHZpZGVvLmlkKS5yZXBsYWNlKCd7YnVzaW5lc3NUeXBlfScsIHZpZGVvLmJ1c2luZXNzVHlwZSk7XG4gICAgICAgIHJldHVybiBhZGRFeHRyYVBhcmFtKHBhcmFtcywgdXJsKTtcbiAgICB9XG5cbiAgICBxdWVyeSh2aWRlbywgY2FuUGxheSwgY2Fubm90UGxheSkge1xuICAgICAgICAvLyB2aWRlb2pzLmJyb3dzZXJcbiAgICAgICAgbGV0IG9wdCA9IHRoaXMuX29wdGlvbjtcbiAgICAgICAgbGV0IHVybCA9IChvcHQucGFyc2VRdWVyeVVybCB8fCB0aGlzLl9wYXJzZVF1ZXJ5VXJsKS5jYWxsKHRoaXMsIG9wdC5saW5rUHJvdGVjdGVyUXVlcnksIHZpZGVvLG9wdCk7XG4gICAgICAgIFxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbmF1Z3R1ci94aHJcbiAgICAgICAgdmlkZW9qcy54aHIoe1xuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBtZXRob2Q6ICdnZXQnLFxuICAgICAgICAgICAgdGltZW91dDogMTBlMyxcbiAgICAgICAgICAgIC8vIHN5bmM6dHJ1ZSxcbiAgICAgICAgICAgIC8vIGpzb246dHJ1ZSwgICAvLyBhcHBsaWNhdGlvbi9qc29uXG4gICAgICAgICAgICAvLyBoZWFkZXJzOiB7XG4gICAgICAgICAgICAvLyBcdCdYLVJlcXVlc3RlZC1XaXRoJzonWE1MSHR0cFJlcXVlc3QnXG4gICAgICAgICAgICAvLyB9LFxuICAgICAgICAgICAgLy8gYm9keTogU3RyaW5nPyB8IE9iamVjdD8sXG4gICAgICAgICAgICAvLyB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgICAgICAvLyBiZWZvcmVTZW5kOiBGdW5jdGlvbj9cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCByZXMsIGRhdGEpIHtcblxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbm5vdFBsYXkodmlkZW8sIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyDlpITnkIblvILluLhcbiAgICAgICAgICAgIGlmIChbNDAwLCA0MDMsIDQwNCwgNTAwXS5pbmRleE9mKHJlcy5zdGF0dXNDb2RlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyAmJiByZXMuYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSByZXMuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvLmxpbmtEYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm5vdFBsYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YS5yZXQpIHtcbiAgICAgICAgICAgICAgICBjYW5ub3RQbGF5KGRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlkZW8ubGlua0RhdGEgPSBkYXRhO1xuXG4gICAgICAgICAgICBsZXQgR19rZXkgPSAnZGczdXRmMWs2eXhkd2kwOSc7XG4gICAgICAgICAgICBsZXQgR19kYXRhID0gWzE5LCAxLCA0LCA3LCAzMCwgMTQsIDI4LCA4LCAyNCwgMTcsIDYsIDM1LCAzNCwgMTYsIDksIDEwLCAxMywgMjIsIDMyLCAyOSwgMzEsIDIxLCAxOCwgMywgMiwgMjMsIDI1LCAyNywgMTEsIDIwLCA1LCAxNSwgMTIsIDAsIDMzLCAyNl07XG4gICAgICAgICAgICBsZXQgcmM0X2tleSA9IEcoR19rZXksIEdfZGF0YSk7XG4gICAgICAgICAgICBsZXQgYXJyID0gRihyYzRfa2V5LCBwYShkYXRhLmVwKSkuc3BsaXQoXCItXCIpO1xuICAgICAgICAgICAgbGV0IHcgPSBuZXcgVyhkYXRhLnNlZWQpO1xuICAgICAgICAgICAgbGV0IHIgPSB3LmNnX2Z1bihkYXRhLmZpbGVJZCk7XG4gICAgICAgICAgICBsZXQgc2lnbiA9IGFyclsxXTtcbiAgICAgICAgICAgIGxldCBidXlfa2V5ID0gYXJyWzBdO1xuICAgICAgICAgICAgbGV0IHRva2VuID0gYXJyWzJdO1xuICAgICAgICAgICAgbGV0IHRpbWVzdGFtcCA9IGFyclszXTtcbiAgICAgICAgICAgIGxldCBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG4gICAgICAgICAgICByID0gclswXSA9PT0gJy8nID8gciA6ICgnLycgKyByKTtcbiAgICAgICAgICAgIGxldCBzcmMgPSAoZGF0YS5kb21haW4gfHwgb3B0LmxpbmtQcm90ZWN0ZXJDRE4pICsgJy9kb3dubG9hZC8nICsgZGF0YS5hcGlWZXJzaW9uICsgciArXG4gICAgICAgICAgICAgICAgJz9zaWduPScgKyBlbmNvZGVVUklDb21wb25lbnQoc2lnbikgK1xuICAgICAgICAgICAgICAgICcmYnV5X2tleT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGJ1eV9rZXkpICtcbiAgICAgICAgICAgICAgICAnJnRpbWVzdGFtcD0nICsgdGltZXN0YW1wICtcbiAgICAgICAgICAgICAgICAnJnRva2VuPScgKyBlbmNvZGVVUklDb21wb25lbnQodG9rZW4pICtcbiAgICAgICAgICAgICAgICAnJmR1cmF0aW9uPScgKyBkdXJhdGlvbjtcblxuICAgICAgICAgICAgdmlkZW8uc3JjID0gc3JjO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhzcmMpXG4gICAgICAgICAgICAvLyB2aWRlby5zcmMgPSAnaHR0cDovL2ZkZnMudGVzdC54aW1hbGF5YS5jb20vZ3JvdXAxL00wMS81MC83Ni93S2dEM2xuT0JoYUFEazdNQUFBQTBRcjdBLUkxOS5tM3U4JztcbiAgICAgICAgICAgIGNhblBsYXkodmlkZW8pO1xuICAgICAgICB9KVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVlBsYXllckxpbmtQcm90ZWN0ZXJcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdnBsYXllci1saW5rLXByb3RlY3Rlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31\n')},function(module,exports,__webpack_require__){eval("var require;var require;/**\n * videojs-contrib-hls\n * @version 5.12.2\n * @copyright 2017 Brightcove, Inc\n * @license Apache-2.0\n */\n(function(f){if(true){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.videojsContribHls = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * @file ad-cue-tags.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\n/**\n * Searches for an ad cue that overlaps with the given mediaTime\n */\nvar findAdCue = function findAdCue(track, mediaTime) {\n  var cues = track.cues;\n\n  for (var i = 0; i < cues.length; i++) {\n    var cue = cues[i];\n\n    if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) {\n      return cue;\n    }\n  }\n  return null;\n};\n\nvar updateAdCues = function updateAdCues(media, track) {\n  var offset = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n  if (!media.segments) {\n    return;\n  }\n\n  var mediaTime = offset;\n  var cue = undefined;\n\n  for (var i = 0; i < media.segments.length; i++) {\n    var segment = media.segments[i];\n\n    if (!cue) {\n      // Since the cues will span for at least the segment duration, adding a fudge\n      // factor of half segment duration will prevent duplicate cues from being\n      // created when timing info is not exact (e.g. cue start time initialized\n      // at 10.006677, but next call mediaTime is 10.003332 )\n      cue = findAdCue(track, mediaTime + segment.duration / 2);\n    }\n\n    if (cue) {\n      if ('cueIn' in segment) {\n        // Found a CUE-IN so end the cue\n        cue.endTime = mediaTime;\n        cue.adEndTime = mediaTime;\n        mediaTime += segment.duration;\n        cue = null;\n        continue;\n      }\n\n      if (mediaTime < cue.endTime) {\n        // Already processed this mediaTime for this cue\n        mediaTime += segment.duration;\n        continue;\n      }\n\n      // otherwise extend cue until a CUE-IN is found\n      cue.endTime += segment.duration;\n    } else {\n      if ('cueOut' in segment) {\n        cue = new _globalWindow2['default'].VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut);\n        cue.adStartTime = mediaTime;\n        // Assumes tag format to be\n        // #EXT-X-CUE-OUT:30\n        cue.adEndTime = mediaTime + parseFloat(segment.cueOut);\n        track.addCue(cue);\n      }\n\n      if ('cueOutCont' in segment) {\n        // Entered into the middle of an ad cue\n        var adOffset = undefined;\n        var adTotal = undefined;\n\n        // Assumes tag formate to be\n        // #EXT-X-CUE-OUT-CONT:10/30\n\n        var _segment$cueOutCont$split$map = segment.cueOutCont.split('/').map(parseFloat);\n\n        var _segment$cueOutCont$split$map2 = _slicedToArray(_segment$cueOutCont$split$map, 2);\n\n        adOffset = _segment$cueOutCont$split$map2[0];\n        adTotal = _segment$cueOutCont$split$map2[1];\n\n        cue = new _globalWindow2['default'].VTTCue(mediaTime, mediaTime + segment.duration, '');\n        cue.adStartTime = mediaTime - adOffset;\n        cue.adEndTime = cue.adStartTime + adTotal;\n        track.addCue(cue);\n      }\n    }\n    mediaTime += segment.duration;\n  }\n};\n\nexports['default'] = {\n  updateAdCues: updateAdCues,\n  findAdCue: findAdCue\n};\nmodule.exports = exports['default'];\n},{\"global/window\":32}],2:[function(require,module,exports){\n/**\n * @file bin-utils.js\n */\n\n/**\n * convert a TimeRange to text\n *\n * @param {TimeRange} range the timerange to use for conversion\n * @param {Number} i the iterator on the range to convert\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar textRange = function textRange(range, i) {\n  return range.start(i) + '-' + range.end(i);\n};\n\n/**\n * format a number as hex string\n *\n * @param {Number} e The number\n * @param {Number} i the iterator\n */\nvar formatHexString = function formatHexString(e, i) {\n  var value = e.toString(16);\n\n  return '00'.substring(0, 2 - value.length) + value + (i % 2 ? ' ' : '');\n};\nvar formatAsciiString = function formatAsciiString(e) {\n  if (e >= 0x20 && e < 0x7e) {\n    return String.fromCharCode(e);\n  }\n  return '.';\n};\n\n/**\n * Creates an object for sending to a web worker modifying properties that are TypedArrays\n * into a new object with seperated properties for the buffer, byteOffset, and byteLength.\n *\n * @param {Object} message\n *        Object of properties and values to send to the web worker\n * @return {Object}\n *         Modified message with TypedArray values expanded\n * @function createTransferableMessage\n */\nvar createTransferableMessage = function createTransferableMessage(message) {\n  var transferable = {};\n\n  Object.keys(message).forEach(function (key) {\n    var value = message[key];\n\n    if (ArrayBuffer.isView(value)) {\n      transferable[key] = {\n        bytes: value.buffer,\n        byteOffset: value.byteOffset,\n        byteLength: value.byteLength\n      };\n    } else {\n      transferable[key] = value;\n    }\n  });\n\n  return transferable;\n};\n\n/**\n * Returns a unique string identifier for a media initialization\n * segment.\n */\nvar initSegmentId = function initSegmentId(initSegment) {\n  var byterange = initSegment.byterange || {\n    length: Infinity,\n    offset: 0\n  };\n\n  return [byterange.length, byterange.offset, initSegment.resolvedUri].join(',');\n};\n\n/**\n * utils to help dump binary data to the console\n */\nvar utils = {\n  hexDump: function hexDump(data) {\n    var bytes = Array.prototype.slice.call(data);\n    var step = 16;\n    var result = '';\n    var hex = undefined;\n    var ascii = undefined;\n\n    for (var j = 0; j < bytes.length / step; j++) {\n      hex = bytes.slice(j * step, j * step + step).map(formatHexString).join('');\n      ascii = bytes.slice(j * step, j * step + step).map(formatAsciiString).join('');\n      result += hex + ' ' + ascii + '\\n';\n    }\n    return result;\n  },\n  tagDump: function tagDump(tag) {\n    return utils.hexDump(tag.bytes);\n  },\n  textRanges: function textRanges(ranges) {\n    var result = '';\n    var i = undefined;\n\n    for (i = 0; i < ranges.length; i++) {\n      result += textRange(ranges, i) + ' ';\n    }\n    return result;\n  },\n  createTransferableMessage: createTransferableMessage,\n  initSegmentId: initSegmentId\n};\n\nexports['default'] = utils;\nmodule.exports = exports['default'];\n},{}],3:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = {\n  GOAL_BUFFER_LENGTH: 30,\n  MAX_GOAL_BUFFER_LENGTH: 60,\n  GOAL_BUFFER_LENGTH_RATE: 1,\n  // A fudge factor to apply to advertised playlist bitrates to account for\n  // temporary flucations in client bandwidth\n  BANDWIDTH_VARIANCE: 1.2,\n  // How much of the buffer must be filled before we consider upswitching\n  BUFFER_LOW_WATER_LINE: 0,\n  MAX_BUFFER_LOW_WATER_LINE: 30,\n  BUFFER_LOW_WATER_LINE_RATE: 1\n};\nmodule.exports = exports[\"default\"];\n},{}],4:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _aesDecrypter = require('aes-decrypter');\n\nvar _binUtils = require('./bin-utils');\n\n/**\n * Our web worker interface so that things can talk to aes-decrypter\n * that will be running in a web worker. the scope is passed to this by\n * webworkify.\n *\n * @param {Object} self\n *        the scope for the web worker\n */\nvar DecrypterWorker = function DecrypterWorker(self) {\n  self.onmessage = function (event) {\n    var data = event.data;\n    var encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength);\n    var key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4);\n    var iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);\n\n    /* eslint-disable no-new, handle-callback-err */\n    new _aesDecrypter.Decrypter(encrypted, key, iv, function (err, bytes) {\n      _globalWindow2['default'].postMessage((0, _binUtils.createTransferableMessage)({\n        source: data.source,\n        decrypted: bytes\n      }), [bytes.buffer]);\n    });\n    /* eslint-enable */\n  };\n};\n\nexports['default'] = function (self) {\n  return new DecrypterWorker(self);\n};\n\nmodule.exports = exports['default'];\n},{\"./bin-utils\":2,\"aes-decrypter\":25,\"global/window\":32}],5:[function(require,module,exports){\n(function (global){\n/**\n * @file master-playlist-controller.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _playlistLoader = require('./playlist-loader');\n\nvar _playlistLoader2 = _interopRequireDefault(_playlistLoader);\n\nvar _playlistJs = require('./playlist.js');\n\nvar _segmentLoader = require('./segment-loader');\n\nvar _segmentLoader2 = _interopRequireDefault(_segmentLoader);\n\nvar _vttSegmentLoader = require('./vtt-segment-loader');\n\nvar _vttSegmentLoader2 = _interopRequireDefault(_vttSegmentLoader);\n\nvar _ranges = require('./ranges');\n\nvar _ranges2 = _interopRequireDefault(_ranges);\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _adCueTags = require('./ad-cue-tags');\n\nvar _adCueTags2 = _interopRequireDefault(_adCueTags);\n\nvar _syncController = require('./sync-controller');\n\nvar _syncController2 = _interopRequireDefault(_syncController);\n\nvar _videojsContribMediaSourcesEs5CodecUtils = require('videojs-contrib-media-sources/es5/codec-utils');\n\nvar _webworkify = require('webworkify');\n\nvar _webworkify2 = _interopRequireDefault(_webworkify);\n\nvar _decrypterWorker = require('./decrypter-worker');\n\nvar _decrypterWorker2 = _interopRequireDefault(_decrypterWorker);\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _utilCodecsJs = require('./util/codecs.js');\n\nvar _mediaGroups = require('./media-groups');\n\nvar ABORT_EARLY_BLACKLIST_SECONDS = 60 * 2;\n\nvar Hls = undefined;\n\n// Default codec parameters if none were provided for video and/or audio\nvar defaultCodecs = {\n  videoCodec: 'avc1',\n  videoObjectTypeIndicator: '.4d400d',\n  // AAC-LC\n  audioProfile: '2'\n};\n\n// SegmentLoader stats that need to have each loader's\n// values summed to calculate the final value\nvar loaderStats = ['mediaRequests', 'mediaRequestsAborted', 'mediaRequestsTimedout', 'mediaRequestsErrored', 'mediaTransferDuration', 'mediaBytesTransferred'];\nvar sumLoaderStat = function sumLoaderStat(stat) {\n  return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];\n};\n\n/**\n * Replace codecs in the codec string with the old apple-style `avc1.<dd>.<dd>` to the\n * standard `avc1.<hhhhhh>`.\n *\n * @param codecString {String} the codec string\n * @return {String} the codec string with old apple-style codecs replaced\n *\n * @private\n */\nvar mapLegacyAvcCodecs_ = function mapLegacyAvcCodecs_(codecString) {\n  return codecString.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (match) {\n    return (0, _videojsContribMediaSourcesEs5CodecUtils.translateLegacyCodecs)([match])[0];\n  });\n};\n\nexports.mapLegacyAvcCodecs_ = mapLegacyAvcCodecs_;\n/**\n * Build a media mime-type string from a set of parameters\n * @param {String} type either 'audio' or 'video'\n * @param {String} container either 'mp2t' or 'mp4'\n * @param {Array} codecs an array of codec strings to add\n * @return {String} a valid media mime-type\n */\nvar makeMimeTypeString = function makeMimeTypeString(type, container, codecs) {\n  // The codecs array is filtered so that falsey values are\n  // dropped and don't cause Array#join to create spurious\n  // commas\n  return type + '/' + container + '; codecs=\"' + codecs.filter(function (c) {\n    return !!c;\n  }).join(', ') + '\"';\n};\n\n/**\n * Returns the type container based on information in the playlist\n * @param {Playlist} media the current media playlist\n * @return {String} a valid media container type\n */\nvar getContainerType = function getContainerType(media) {\n  // An initialization segment means the media playlist is an iframe\n  // playlist or is using the mp4 container. We don't currently\n  // support iframe playlists, so assume this is signalling mp4\n  // fragments.\n  if (media.segments && media.segments.length && media.segments[0].map) {\n    return 'mp4';\n  }\n  return 'mp2t';\n};\n\n/**\n * Returns a set of codec strings parsed from the playlist or the default\n * codec strings if no codecs were specified in the playlist\n * @param {Playlist} media the current media playlist\n * @return {Object} an object with the video and audio codecs\n */\nvar getCodecs = function getCodecs(media) {\n  // if the codecs were explicitly specified, use them instead of the\n  // defaults\n  var mediaAttributes = media.attributes || {};\n\n  if (mediaAttributes.CODECS) {\n    return (0, _utilCodecsJs.parseCodecs)(mediaAttributes.CODECS);\n  }\n  return defaultCodecs;\n};\n\n/**\n * Calculates the MIME type strings for a working configuration of\n * SourceBuffers to play variant streams in a master playlist. If\n * there is no possible working configuration, an empty array will be\n * returned.\n *\n * @param master {Object} the m3u8 object for the master playlist\n * @param media {Object} the m3u8 object for the variant playlist\n * @return {Array} the MIME type strings. If the array has more than\n * one entry, the first element should be applied to the video\n * SourceBuffer and the second to the audio SourceBuffer.\n *\n * @private\n */\nvar mimeTypesForPlaylist_ = function mimeTypesForPlaylist_(master, media) {\n  var containerType = getContainerType(media);\n  var codecInfo = getCodecs(media);\n  var mediaAttributes = media.attributes || {};\n  // Default condition for a traditional HLS (no demuxed audio/video)\n  var isMuxed = true;\n  var isMaat = false;\n\n  if (!media) {\n    // Not enough information\n    return [];\n  }\n\n  if (master.mediaGroups.AUDIO && mediaAttributes.AUDIO) {\n    var audioGroup = master.mediaGroups.AUDIO[mediaAttributes.AUDIO];\n\n    // Handle the case where we are in a multiple-audio track scenario\n    if (audioGroup) {\n      isMaat = true;\n      // Start with the everything demuxed then...\n      isMuxed = false;\n      // ...check to see if any audio group tracks are muxed (ie. lacking a uri)\n      for (var groupId in audioGroup) {\n        if (!audioGroup[groupId].uri) {\n          isMuxed = true;\n          break;\n        }\n      }\n    }\n  }\n\n  // HLS with multiple-audio tracks must always get an audio codec.\n  // Put another way, there is no way to have a video-only multiple-audio HLS!\n  if (isMaat && !codecInfo.audioProfile) {\n    _videoJs2['default'].log.warn('Multiple audio tracks present but no audio codec string is specified. ' + 'Attempting to use the default audio codec (mp4a.40.2)');\n    codecInfo.audioProfile = defaultCodecs.audioProfile;\n  }\n\n  // Generate the final codec strings from the codec object generated above\n  var codecStrings = {};\n\n  if (codecInfo.videoCodec) {\n    codecStrings.video = '' + codecInfo.videoCodec + codecInfo.videoObjectTypeIndicator;\n  }\n\n  if (codecInfo.audioProfile) {\n    codecStrings.audio = 'mp4a.40.' + codecInfo.audioProfile;\n  }\n\n  // Finally, make and return an array with proper mime-types depending on\n  // the configuration\n  var justAudio = makeMimeTypeString('audio', containerType, [codecStrings.audio]);\n  var justVideo = makeMimeTypeString('video', containerType, [codecStrings.video]);\n  var bothVideoAudio = makeMimeTypeString('video', containerType, [codecStrings.video, codecStrings.audio]);\n\n  if (isMaat) {\n    if (!isMuxed && codecStrings.video) {\n      return [justVideo, justAudio];\n    }\n    // There exists the possiblity that this will return a `video/container`\n    // mime-type for the first entry in the array even when there is only audio.\n    // This doesn't appear to be a problem and simplifies the code.\n    return [bothVideoAudio, justAudio];\n  }\n\n  // If there is ano video codec at all, always just return a single\n  // audio/<container> mime-type\n  if (!codecStrings.video) {\n    return [justAudio];\n  }\n\n  // When not using separate audio media groups, audio and video is\n  // *always* muxed\n  return [bothVideoAudio];\n};\n\nexports.mimeTypesForPlaylist_ = mimeTypesForPlaylist_;\n/**\n * the master playlist controller controller all interactons\n * between playlists and segmentloaders. At this time this mainly\n * involves a master playlist and a series of audio playlists\n * if they are available\n *\n * @class MasterPlaylistController\n * @extends videojs.EventTarget\n */\n\nvar MasterPlaylistController = (function (_videojs$EventTarget) {\n  _inherits(MasterPlaylistController, _videojs$EventTarget);\n\n  function MasterPlaylistController(options) {\n    var _this = this;\n\n    _classCallCheck(this, MasterPlaylistController);\n\n    _get(Object.getPrototypeOf(MasterPlaylistController.prototype), 'constructor', this).call(this);\n\n    var url = options.url;\n    var withCredentials = options.withCredentials;\n    var mode = options.mode;\n    var tech = options.tech;\n    var bandwidth = options.bandwidth;\n    var externHls = options.externHls;\n    var useCueTags = options.useCueTags;\n    var blacklistDuration = options.blacklistDuration;\n    var enableLowInitialPlaylist = options.enableLowInitialPlaylist;\n\n    if (!url) {\n      throw new Error('A non-empty playlist URL is required');\n    }\n\n    Hls = externHls;\n\n    this.withCredentials = withCredentials;\n    this.tech_ = tech;\n    this.hls_ = tech.hls;\n    this.mode_ = mode;\n    this.useCueTags_ = useCueTags;\n    this.blacklistDuration = blacklistDuration;\n    this.enableLowInitialPlaylist = enableLowInitialPlaylist;\n    if (this.useCueTags_) {\n      this.cueTagsTrack_ = this.tech_.addTextTrack('metadata', 'ad-cues');\n      this.cueTagsTrack_.inBandMetadataTrackDispatchType = '';\n    }\n\n    this.requestOptions_ = {\n      withCredentials: this.withCredentials,\n      timeout: null\n    };\n\n    this.mediaTypes_ = (0, _mediaGroups.createMediaTypes)();\n\n    this.mediaSource = new _videoJs2['default'].MediaSource({ mode: mode });\n\n    // load the media source into the player\n    this.mediaSource.addEventListener('sourceopen', this.handleSourceOpen_.bind(this));\n\n    this.seekable_ = _videoJs2['default'].createTimeRanges();\n    this.hasPlayed_ = function () {\n      return false;\n    };\n\n    this.syncController_ = new _syncController2['default'](options);\n    this.segmentMetadataTrack_ = tech.addRemoteTextTrack({\n      kind: 'metadata',\n      label: 'segment-metadata'\n    }, false).track;\n\n    this.decrypter_ = (0, _webworkify2['default'])(_decrypterWorker2['default']);\n\n    var segmentLoaderSettings = {\n      hls: this.hls_,\n      mediaSource: this.mediaSource,\n      currentTime: this.tech_.currentTime.bind(this.tech_),\n      seekable: function seekable() {\n        return _this.seekable();\n      },\n      seeking: function seeking() {\n        return _this.tech_.seeking();\n      },\n      duration: function duration() {\n        return _this.mediaSource.duration;\n      },\n      hasPlayed: function hasPlayed() {\n        return _this.hasPlayed_();\n      },\n      goalBufferLength: function goalBufferLength() {\n        return _this.goalBufferLength();\n      },\n      bandwidth: bandwidth,\n      syncController: this.syncController_,\n      decrypter: this.decrypter_\n    };\n\n    // setup playlist loaders\n    this.masterPlaylistLoader_ = new _playlistLoader2['default'](url, this.hls_, this.withCredentials);\n    this.setupMasterPlaylistLoaderListeners_();\n\n    // setup segment loaders\n    // combined audio/video or just video when alternate audio track is selected\n    this.mainSegmentLoader_ = new _segmentLoader2['default'](_videoJs2['default'].mergeOptions(segmentLoaderSettings, {\n      segmentMetadataTrack: this.segmentMetadataTrack_,\n      loaderType: 'main'\n    }), options);\n\n    // alternate audio track\n    this.audioSegmentLoader_ = new _segmentLoader2['default'](_videoJs2['default'].mergeOptions(segmentLoaderSettings, {\n      loaderType: 'audio'\n    }), options);\n\n    this.subtitleSegmentLoader_ = new _vttSegmentLoader2['default'](_videoJs2['default'].mergeOptions(segmentLoaderSettings, {\n      loaderType: 'vtt'\n    }), options);\n\n    this.setupSegmentLoaderListeners_();\n\n    // Create SegmentLoader stat-getters\n    loaderStats.forEach(function (stat) {\n      _this[stat + '_'] = sumLoaderStat.bind(_this, stat);\n    });\n\n    this.masterPlaylistLoader_.load();\n  }\n\n  /**\n   * Register event handlers on the master playlist loader. A helper\n   * function for construction time.\n   *\n   * @private\n   */\n\n  _createClass(MasterPlaylistController, [{\n    key: 'setupMasterPlaylistLoaderListeners_',\n    value: function setupMasterPlaylistLoaderListeners_() {\n      var _this2 = this;\n\n      this.masterPlaylistLoader_.on('loadedmetadata', function () {\n        var media = _this2.masterPlaylistLoader_.media();\n        var requestTimeout = _this2.masterPlaylistLoader_.targetDuration * 1.5 * 1000;\n\n        // If we don't have any more available playlists, we don't want to\n        // timeout the request.\n        if ((0, _playlistJs.isLowestEnabledRendition)(_this2.masterPlaylistLoader_.master, _this2.masterPlaylistLoader_.media())) {\n          _this2.requestOptions_.timeout = 0;\n        } else {\n          _this2.requestOptions_.timeout = requestTimeout;\n        }\n\n        // if this isn't a live video and preload permits, start\n        // downloading segments\n        if (media.endList && _this2.tech_.preload() !== 'none') {\n          _this2.mainSegmentLoader_.playlist(media, _this2.requestOptions_);\n          _this2.mainSegmentLoader_.load();\n        }\n\n        (0, _mediaGroups.setupMediaGroups)({\n          segmentLoaders: {\n            AUDIO: _this2.audioSegmentLoader_,\n            SUBTITLES: _this2.subtitleSegmentLoader_,\n            main: _this2.mainSegmentLoader_\n          },\n          tech: _this2.tech_,\n          requestOptions: _this2.requestOptions_,\n          masterPlaylistLoader: _this2.masterPlaylistLoader_,\n          mode: _this2.mode_,\n          hls: _this2.hls_,\n          master: _this2.master(),\n          mediaTypes: _this2.mediaTypes_,\n          blacklistCurrentPlaylist: _this2.blacklistCurrentPlaylist.bind(_this2)\n        });\n\n        _this2.triggerPresenceUsage_(_this2.master(), media);\n\n        try {\n          _this2.setupSourceBuffers_();\n        } catch (e) {\n          _videoJs2['default'].log.warn('Failed to create SourceBuffers', e);\n          return _this2.mediaSource.endOfStream('decode');\n        }\n        _this2.setupFirstPlay();\n\n        _this2.trigger('selectedinitialmedia');\n      });\n\n      this.masterPlaylistLoader_.on('loadedplaylist', function () {\n        var updatedPlaylist = _this2.masterPlaylistLoader_.media();\n\n        if (!updatedPlaylist) {\n          var selectedMedia = undefined;\n\n          if (_this2.enableLowInitialPlaylist) {\n            selectedMedia = _this2.selectInitialPlaylist();\n          }\n\n          if (!selectedMedia) {\n            selectedMedia = _this2.selectPlaylist();\n          }\n\n          _this2.initialMedia_ = selectedMedia;\n          _this2.masterPlaylistLoader_.media(_this2.initialMedia_);\n          return;\n        }\n\n        if (_this2.useCueTags_) {\n          _this2.updateAdCues_(updatedPlaylist);\n        }\n\n        // TODO: Create a new event on the PlaylistLoader that signals\n        // that the segments have changed in some way and use that to\n        // update the SegmentLoader instead of doing it twice here and\n        // on `mediachange`\n        _this2.mainSegmentLoader_.playlist(updatedPlaylist, _this2.requestOptions_);\n        _this2.updateDuration();\n\n        // If the player isn't paused, ensure that the segment loader is running,\n        // as it is possible that it was temporarily stopped while waiting for\n        // a playlist (e.g., in case the playlist errored and we re-requested it).\n        if (!_this2.tech_.paused()) {\n          _this2.mainSegmentLoader_.load();\n        }\n\n        if (!updatedPlaylist.endList) {\n          (function () {\n            var addSeekableRange = function addSeekableRange() {\n              var seekable = _this2.seekable();\n\n              if (seekable.length !== 0) {\n                _this2.mediaSource.addSeekableRange_(seekable.start(0), seekable.end(0));\n              }\n            };\n\n            if (_this2.duration() !== Infinity) {\n              (function () {\n                var onDurationchange = function onDurationchange() {\n                  if (_this2.duration() === Infinity) {\n                    addSeekableRange();\n                  } else {\n                    _this2.tech_.one('durationchange', onDurationchange);\n                  }\n                };\n\n                _this2.tech_.one('durationchange', onDurationchange);\n              })();\n            } else {\n              addSeekableRange();\n            }\n          })();\n        }\n      });\n\n      this.masterPlaylistLoader_.on('error', function () {\n        _this2.blacklistCurrentPlaylist(_this2.masterPlaylistLoader_.error);\n      });\n\n      this.masterPlaylistLoader_.on('mediachanging', function () {\n        _this2.mainSegmentLoader_.abort();\n        _this2.mainSegmentLoader_.pause();\n      });\n\n      this.masterPlaylistLoader_.on('mediachange', function () {\n        var media = _this2.masterPlaylistLoader_.media();\n        var requestTimeout = _this2.masterPlaylistLoader_.targetDuration * 1.5 * 1000;\n\n        // If we don't have any more available playlists, we don't want to\n        // timeout the request.\n        if ((0, _playlistJs.isLowestEnabledRendition)(_this2.masterPlaylistLoader_.master, _this2.masterPlaylistLoader_.media())) {\n          _this2.requestOptions_.timeout = 0;\n        } else {\n          _this2.requestOptions_.timeout = requestTimeout;\n        }\n\n        // TODO: Create a new event on the PlaylistLoader that signals\n        // that the segments have changed in some way and use that to\n        // update the SegmentLoader instead of doing it twice here and\n        // on `loadedplaylist`\n        _this2.mainSegmentLoader_.playlist(media, _this2.requestOptions_);\n        _this2.mainSegmentLoader_.load();\n\n        _this2.tech_.trigger({\n          type: 'mediachange',\n          bubbles: true\n        });\n      });\n\n      this.masterPlaylistLoader_.on('playlistunchanged', function () {\n        var updatedPlaylist = _this2.masterPlaylistLoader_.media();\n        var playlistOutdated = _this2.stuckAtPlaylistEnd_(updatedPlaylist);\n\n        if (playlistOutdated) {\n          // Playlist has stopped updating and we're stuck at its end. Try to\n          // blacklist it and switch to another playlist in the hope that that\n          // one is updating (and give the player a chance to re-adjust to the\n          // safe live point).\n          _this2.blacklistCurrentPlaylist({\n            message: 'Playlist no longer updating.'\n          });\n          // useful for monitoring QoS\n          _this2.tech_.trigger('playliststuck');\n        }\n      });\n\n      this.masterPlaylistLoader_.on('renditiondisabled', function () {\n        _this2.tech_.trigger({ type: 'usage', name: 'hls-rendition-disabled' });\n      });\n      this.masterPlaylistLoader_.on('renditionenabled', function () {\n        _this2.tech_.trigger({ type: 'usage', name: 'hls-rendition-enabled' });\n      });\n    }\n\n    /**\n     * A helper function for triggerring presence usage events once per source\n     *\n     * @private\n     */\n  }, {\n    key: 'triggerPresenceUsage_',\n    value: function triggerPresenceUsage_(master, media) {\n      var mediaGroups = master.mediaGroups || {};\n      var defaultDemuxed = true;\n      var audioGroupKeys = Object.keys(mediaGroups.AUDIO);\n\n      for (var mediaGroup in mediaGroups.AUDIO) {\n        for (var label in mediaGroups.AUDIO[mediaGroup]) {\n          var properties = mediaGroups.AUDIO[mediaGroup][label];\n\n          if (!properties.uri) {\n            defaultDemuxed = false;\n          }\n        }\n      }\n\n      if (defaultDemuxed) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-demuxed' });\n      }\n\n      if (Object.keys(mediaGroups.SUBTITLES).length) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-webvtt' });\n      }\n\n      if (Hls.Playlist.isAes(media)) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-aes' });\n      }\n\n      if (Hls.Playlist.isFmp4(media)) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-fmp4' });\n      }\n\n      if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-alternate-audio' });\n      }\n\n      if (this.useCueTags_) {\n        this.tech_.trigger({ type: 'usage', name: 'hls-playlist-cue-tags' });\n      }\n    }\n\n    /**\n     * Register event handlers on the segment loaders. A helper function\n     * for construction time.\n     *\n     * @private\n     */\n  }, {\n    key: 'setupSegmentLoaderListeners_',\n    value: function setupSegmentLoaderListeners_() {\n      var _this3 = this;\n\n      this.mainSegmentLoader_.on('bandwidthupdate', function () {\n        var nextPlaylist = _this3.selectPlaylist();\n        var currentPlaylist = _this3.masterPlaylistLoader_.media();\n        var buffered = _this3.tech_.buffered();\n        var forwardBuffer = buffered.length ? buffered.end(buffered.length - 1) - _this3.tech_.currentTime() : 0;\n\n        var bufferLowWaterLine = _this3.bufferLowWaterLine();\n\n        // If the playlist is live, then we want to not take low water line into account.\n        // This is because in LIVE, the player plays 3 segments from the end of the\n        // playlist, and if `BUFFER_LOW_WATER_LINE` is greater than the duration availble\n        // in those segments, a viewer will never experience a rendition upswitch.\n        if (!currentPlaylist.endList ||\n        // For the same reason as LIVE, we ignore the low water line when the VOD\n        // duration is below the max potential low water line\n        _this3.duration() < _config2['default'].MAX_BUFFER_LOW_WATER_LINE ||\n        // we want to switch down to lower resolutions quickly to continue playback, but\n        nextPlaylist.attributes.BANDWIDTH < currentPlaylist.attributes.BANDWIDTH ||\n        // ensure we have some buffer before we switch up to prevent us running out of\n        // buffer while loading a higher rendition.\n        forwardBuffer >= bufferLowWaterLine) {\n          _this3.masterPlaylistLoader_.media(nextPlaylist);\n        }\n\n        _this3.tech_.trigger('bandwidthupdate');\n      });\n      this.mainSegmentLoader_.on('progress', function () {\n        _this3.trigger('progress');\n      });\n\n      this.mainSegmentLoader_.on('error', function () {\n        _this3.blacklistCurrentPlaylist(_this3.mainSegmentLoader_.error());\n      });\n\n      this.mainSegmentLoader_.on('syncinfoupdate', function () {\n        _this3.onSyncInfoUpdate_();\n      });\n\n      this.mainSegmentLoader_.on('timestampoffset', function () {\n        _this3.tech_.trigger({ type: 'usage', name: 'hls-timestamp-offset' });\n      });\n      this.audioSegmentLoader_.on('syncinfoupdate', function () {\n        _this3.onSyncInfoUpdate_();\n      });\n\n      this.mainSegmentLoader_.on('ended', function () {\n        _this3.onEndOfStream();\n      });\n\n      this.mainSegmentLoader_.on('earlyabort', function () {\n        _this3.blacklistCurrentPlaylist({\n          message: 'Aborted early because there isn\\'t enough bandwidth to complete the ' + 'request without rebuffering.'\n        }, ABORT_EARLY_BLACKLIST_SECONDS);\n      });\n\n      this.mainSegmentLoader_.on('reseteverything', function () {\n        // If playing an MTS stream, a videojs.MediaSource is listening for\n        // hls-reset to reset caption parsing state in the transmuxer\n        _this3.tech_.trigger('hls-reset');\n      });\n\n      this.mainSegmentLoader_.on('segmenttimemapping', function (event) {\n        // If playing an MTS stream in html, a videojs.MediaSource is listening for\n        // hls-segment-time-mapping update its internal mapping of stream to display time\n        _this3.tech_.trigger({\n          type: 'hls-segment-time-mapping',\n          mapping: event.mapping\n        });\n      });\n\n      this.audioSegmentLoader_.on('ended', function () {\n        _this3.onEndOfStream();\n      });\n    }\n  }, {\n    key: 'mediaSecondsLoaded_',\n    value: function mediaSecondsLoaded_() {\n      return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);\n    }\n\n    /**\n     * Call load on our SegmentLoaders\n     */\n  }, {\n    key: 'load',\n    value: function load() {\n      this.mainSegmentLoader_.load();\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        this.audioSegmentLoader_.load();\n      }\n      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n        this.subtitleSegmentLoader_.load();\n      }\n    }\n\n    /**\n     * Re-tune playback quality level for the current player\n     * conditions. This method may perform destructive actions, like\n     * removing already buffered content, to readjust the currently\n     * active playlist quickly.\n     *\n     * @private\n     */\n  }, {\n    key: 'fastQualityChange_',\n    value: function fastQualityChange_() {\n      var media = this.selectPlaylist();\n\n      if (media !== this.masterPlaylistLoader_.media()) {\n        this.masterPlaylistLoader_.media(media);\n\n        this.mainSegmentLoader_.resetLoader();\n        // don't need to reset audio as it is reset when media changes\n      }\n    }\n\n    /**\n     * Begin playback.\n     */\n  }, {\n    key: 'play',\n    value: function play() {\n      if (this.setupFirstPlay()) {\n        return;\n      }\n\n      if (this.tech_.ended()) {\n        this.tech_.setCurrentTime(0);\n      }\n\n      if (this.hasPlayed_()) {\n        this.load();\n      }\n\n      var seekable = this.tech_.seekable();\n\n      // if the viewer has paused and we fell out of the live window,\n      // seek forward to the live point\n      if (this.tech_.duration() === Infinity) {\n        if (this.tech_.currentTime() < seekable.start(0)) {\n          return this.tech_.setCurrentTime(seekable.end(seekable.length - 1));\n        }\n      }\n    }\n\n    /**\n     * Seek to the latest media position if this is a live video and the\n     * player and video are loaded and initialized.\n     */\n  }, {\n    key: 'setupFirstPlay',\n    value: function setupFirstPlay() {\n      var _this4 = this;\n\n      var media = this.masterPlaylistLoader_.media();\n\n      // Check that everything is ready to begin buffering for the first call to play\n      //  If 1) there is no active media\n      //     2) the player is paused\n      //     3) the first play has already been setup\n      // then exit early\n      if (!media || this.tech_.paused() || this.hasPlayed_()) {\n        return false;\n      }\n\n      // when the video is a live stream\n      if (!media.endList) {\n        var _ret3 = (function () {\n          var seekable = _this4.seekable();\n\n          if (!seekable.length) {\n            // without a seekable range, the player cannot seek to begin buffering at the live\n            // point\n            return {\n              v: false\n            };\n          }\n\n          if (_videoJs2['default'].browser.IE_VERSION && _this4.mode_ === 'html5' && _this4.tech_.readyState() === 0) {\n            // IE11 throws an InvalidStateError if you try to set currentTime while the\n            // readyState is 0, so it must be delayed until the tech fires loadedmetadata.\n            _this4.tech_.one('loadedmetadata', function () {\n              _this4.trigger('firstplay');\n              _this4.tech_.setCurrentTime(seekable.end(0));\n              _this4.hasPlayed_ = function () {\n                return true;\n              };\n            });\n\n            return {\n              v: false\n            };\n          }\n\n          // trigger firstplay to inform the source handler to ignore the next seek event\n          _this4.trigger('firstplay');\n          // seek to the live point\n          _this4.tech_.setCurrentTime(seekable.end(0));\n        })();\n\n        if (typeof _ret3 === 'object') return _ret3.v;\n      }\n\n      this.hasPlayed_ = function () {\n        return true;\n      };\n      // we can begin loading now that everything is ready\n      this.load();\n      return true;\n    }\n\n    /**\n     * handle the sourceopen event on the MediaSource\n     *\n     * @private\n     */\n  }, {\n    key: 'handleSourceOpen_',\n    value: function handleSourceOpen_() {\n      // Only attempt to create the source buffer if none already exist.\n      // handleSourceOpen is also called when we are \"re-opening\" a source buffer\n      // after `endOfStream` has been called (in response to a seek for instance)\n      try {\n        this.setupSourceBuffers_();\n      } catch (e) {\n        _videoJs2['default'].log.warn('Failed to create Source Buffers', e);\n        return this.mediaSource.endOfStream('decode');\n      }\n\n      // if autoplay is enabled, begin playback. This is duplicative of\n      // code in video.js but is required because play() must be invoked\n      // *after* the media source has opened.\n      if (this.tech_.autoplay()) {\n        this.tech_.play();\n      }\n\n      this.trigger('sourceopen');\n    }\n\n    /**\n     * Calls endOfStream on the media source when all active stream types have called\n     * endOfStream\n     *\n     * @param {string} streamType\n     *        Stream type of the segment loader that called endOfStream\n     * @private\n     */\n  }, {\n    key: 'onEndOfStream',\n    value: function onEndOfStream() {\n      var isEndOfStream = this.mainSegmentLoader_.ended_;\n\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        // if the audio playlist loader exists, then alternate audio is active, so we need\n        // to wait for both the main and audio segment loaders to call endOfStream\n        isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_;\n      }\n\n      if (isEndOfStream) {\n        this.mediaSource.endOfStream();\n      }\n    }\n\n    /**\n     * Check if a playlist has stopped being updated\n     * @param {Object} playlist the media playlist object\n     * @return {boolean} whether the playlist has stopped being updated or not\n     */\n  }, {\n    key: 'stuckAtPlaylistEnd_',\n    value: function stuckAtPlaylistEnd_(playlist) {\n      var seekable = this.seekable();\n\n      if (!seekable.length) {\n        // playlist doesn't have enough information to determine whether we are stuck\n        return false;\n      }\n\n      var expired = this.syncController_.getExpiredTime(playlist, this.mediaSource.duration);\n\n      if (expired === null) {\n        return false;\n      }\n\n      // does not use the safe live end to calculate playlist end, since we\n      // don't want to say we are stuck while there is still content\n      var absolutePlaylistEnd = Hls.Playlist.playlistEnd(playlist, expired);\n      var currentTime = this.tech_.currentTime();\n      var buffered = this.tech_.buffered();\n\n      if (!buffered.length) {\n        // return true if the playhead reached the absolute end of the playlist\n        return absolutePlaylistEnd - currentTime <= _ranges2['default'].SAFE_TIME_DELTA;\n      }\n      var bufferedEnd = buffered.end(buffered.length - 1);\n\n      // return true if there is too little buffer left and buffer has reached absolute\n      // end of playlist\n      return bufferedEnd - currentTime <= _ranges2['default'].SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= _ranges2['default'].SAFE_TIME_DELTA;\n    }\n\n    /**\n     * Blacklists a playlist when an error occurs for a set amount of time\n     * making it unavailable for selection by the rendition selection algorithm\n     * and then forces a new playlist (rendition) selection.\n     *\n     * @param {Object=} error an optional error that may include the playlist\n     * to blacklist\n     * @param {Number=} blacklistDuration an optional number of seconds to blacklist the\n     * playlist\n     */\n  }, {\n    key: 'blacklistCurrentPlaylist',\n    value: function blacklistCurrentPlaylist(error, blacklistDuration) {\n      if (error === undefined) error = {};\n\n      var currentPlaylist = undefined;\n      var nextPlaylist = undefined;\n\n      // If the `error` was generated by the playlist loader, it will contain\n      // the playlist we were trying to load (but failed) and that should be\n      // blacklisted instead of the currently selected playlist which is likely\n      // out-of-date in this scenario\n      currentPlaylist = error.playlist || this.masterPlaylistLoader_.media();\n\n      blacklistDuration = blacklistDuration || error.blacklistDuration || this.blacklistDuration;\n\n      // If there is no current playlist, then an error occurred while we were\n      // trying to load the master OR while we were disposing of the tech\n      if (!currentPlaylist) {\n        this.error = error;\n\n        try {\n          return this.mediaSource.endOfStream('network');\n        } catch (e) {\n          return this.trigger('error');\n        }\n      }\n\n      var isFinalRendition = this.masterPlaylistLoader_.master.playlists.filter(_playlistJs.isEnabled).length === 1;\n\n      if (isFinalRendition) {\n        // Never blacklisting this playlist because it's final rendition\n        _videoJs2['default'].log.warn('Problem encountered with the current ' + 'HLS playlist. Trying again since it is the final playlist.');\n\n        this.tech_.trigger('retryplaylist');\n        return this.masterPlaylistLoader_.load(isFinalRendition);\n      }\n      // Blacklist this playlist\n      currentPlaylist.excludeUntil = Date.now() + blacklistDuration * 1000;\n      this.tech_.trigger('blacklistplaylist');\n      this.tech_.trigger({ type: 'usage', name: 'hls-rendition-blacklisted' });\n\n      // Select a new playlist\n      nextPlaylist = this.selectPlaylist();\n      _videoJs2['default'].log.warn('Problem encountered with the current HLS playlist.' + (error.message ? ' ' + error.message : '') + ' Switching to another playlist.');\n\n      return this.masterPlaylistLoader_.media(nextPlaylist);\n    }\n\n    /**\n     * Pause all segment loaders\n     */\n  }, {\n    key: 'pauseLoading',\n    value: function pauseLoading() {\n      this.mainSegmentLoader_.pause();\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        this.audioSegmentLoader_.pause();\n      }\n      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n        this.subtitleSegmentLoader_.pause();\n      }\n    }\n\n    /**\n     * set the current time on all segment loaders\n     *\n     * @param {TimeRange} currentTime the current time to set\n     * @return {TimeRange} the current time\n     */\n  }, {\n    key: 'setCurrentTime',\n    value: function setCurrentTime(currentTime) {\n      var buffered = _ranges2['default'].findRange(this.tech_.buffered(), currentTime);\n\n      if (!(this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media())) {\n        // return immediately if the metadata is not ready yet\n        return 0;\n      }\n\n      // it's clearly an edge-case but don't thrown an error if asked to\n      // seek within an empty playlist\n      if (!this.masterPlaylistLoader_.media().segments) {\n        return 0;\n      }\n\n      // In flash playback, the segment loaders should be reset on every seek, even\n      // in buffer seeks. If the seek location is already buffered, continue buffering as\n      // usual\n      if (buffered && buffered.length && this.mode_ !== 'flash') {\n        return currentTime;\n      }\n\n      // cancel outstanding requests so we begin buffering at the new\n      // location\n      this.mainSegmentLoader_.resetEverything();\n      this.mainSegmentLoader_.abort();\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        this.audioSegmentLoader_.resetEverything();\n        this.audioSegmentLoader_.abort();\n      }\n      if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n        this.subtitleSegmentLoader_.resetEverything();\n        this.subtitleSegmentLoader_.abort();\n      }\n\n      // start segment loader loading in case they are paused\n      this.load();\n    }\n\n    /**\n     * get the current duration\n     *\n     * @return {TimeRange} the duration\n     */\n  }, {\n    key: 'duration',\n    value: function duration() {\n      if (!this.masterPlaylistLoader_) {\n        return 0;\n      }\n\n      if (this.mediaSource) {\n        return this.mediaSource.duration;\n      }\n\n      return Hls.Playlist.duration(this.masterPlaylistLoader_.media());\n    }\n\n    /**\n     * check the seekable range\n     *\n     * @return {TimeRange} the seekable range\n     */\n  }, {\n    key: 'seekable',\n    value: function seekable() {\n      return this.seekable_;\n    }\n  }, {\n    key: 'onSyncInfoUpdate_',\n    value: function onSyncInfoUpdate_() {\n      var mainSeekable = undefined;\n      var audioSeekable = undefined;\n\n      if (!this.masterPlaylistLoader_) {\n        return;\n      }\n\n      var media = this.masterPlaylistLoader_.media();\n\n      if (!media) {\n        return;\n      }\n\n      var expired = this.syncController_.getExpiredTime(media, this.mediaSource.duration);\n\n      if (expired === null) {\n        // not enough information to update seekable\n        return;\n      }\n\n      mainSeekable = Hls.Playlist.seekable(media, expired);\n\n      if (mainSeekable.length === 0) {\n        return;\n      }\n\n      if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n        media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();\n        expired = this.syncController_.getExpiredTime(media, this.mediaSource.duration);\n\n        if (expired === null) {\n          return;\n        }\n\n        audioSeekable = Hls.Playlist.seekable(media, expired);\n\n        if (audioSeekable.length === 0) {\n          return;\n        }\n      }\n\n      if (!audioSeekable) {\n        // seekable has been calculated based on buffering video data so it\n        // can be returned directly\n        this.seekable_ = mainSeekable;\n      } else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) {\n        // seekables are pretty far off, rely on main\n        this.seekable_ = mainSeekable;\n      } else {\n        this.seekable_ = _videoJs2['default'].createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);\n      }\n\n      this.tech_.trigger('seekablechanged');\n    }\n\n    /**\n     * Update the player duration\n     */\n  }, {\n    key: 'updateDuration',\n    value: function updateDuration() {\n      var _this5 = this;\n\n      var oldDuration = this.mediaSource.duration;\n      var newDuration = Hls.Playlist.duration(this.masterPlaylistLoader_.media());\n      var buffered = this.tech_.buffered();\n      var setDuration = function setDuration() {\n        _this5.mediaSource.duration = newDuration;\n        _this5.tech_.trigger('durationchange');\n\n        _this5.mediaSource.removeEventListener('sourceopen', setDuration);\n      };\n\n      if (buffered.length > 0) {\n        newDuration = Math.max(newDuration, buffered.end(buffered.length - 1));\n      }\n\n      // if the duration has changed, invalidate the cached value\n      if (oldDuration !== newDuration) {\n        // update the duration\n        if (this.mediaSource.readyState !== 'open') {\n          this.mediaSource.addEventListener('sourceopen', setDuration);\n        } else {\n          setDuration();\n        }\n      }\n    }\n\n    /**\n     * dispose of the MasterPlaylistController and everything\n     * that it controls\n     */\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      var _this6 = this;\n\n      this.decrypter_.terminate();\n      this.masterPlaylistLoader_.dispose();\n      this.mainSegmentLoader_.dispose();\n\n      ['AUDIO', 'SUBTITLES'].forEach(function (type) {\n        var groups = _this6.mediaTypes_[type].groups;\n\n        for (var id in groups) {\n          groups[id].forEach(function (group) {\n            if (group.playlistLoader) {\n              group.playlistLoader.dispose();\n            }\n          });\n        }\n      });\n\n      this.audioSegmentLoader_.dispose();\n      this.subtitleSegmentLoader_.dispose();\n    }\n\n    /**\n     * return the master playlist object if we have one\n     *\n     * @return {Object} the master playlist object that we parsed\n     */\n  }, {\n    key: 'master',\n    value: function master() {\n      return this.masterPlaylistLoader_.master;\n    }\n\n    /**\n     * return the currently selected playlist\n     *\n     * @return {Object} the currently selected playlist object that we parsed\n     */\n  }, {\n    key: 'media',\n    value: function media() {\n      // playlist loader will not return media if it has not been fully loaded\n      return this.masterPlaylistLoader_.media() || this.initialMedia_;\n    }\n\n    /**\n     * setup our internal source buffers on our segment Loaders\n     *\n     * @private\n     */\n  }, {\n    key: 'setupSourceBuffers_',\n    value: function setupSourceBuffers_() {\n      var media = this.masterPlaylistLoader_.media();\n      var mimeTypes = undefined;\n\n      // wait until a media playlist is available and the Media Source is\n      // attached\n      if (!media || this.mediaSource.readyState !== 'open') {\n        return;\n      }\n\n      mimeTypes = mimeTypesForPlaylist_(this.masterPlaylistLoader_.master, media);\n      if (mimeTypes.length < 1) {\n        this.error = 'No compatible SourceBuffer configuration for the variant stream:' + media.resolvedUri;\n        return this.mediaSource.endOfStream('decode');\n      }\n      this.mainSegmentLoader_.mimeType(mimeTypes[0]);\n      if (mimeTypes[1]) {\n        this.audioSegmentLoader_.mimeType(mimeTypes[1]);\n      }\n\n      // exclude any incompatible variant streams from future playlist\n      // selection\n      this.excludeIncompatibleVariants_(media);\n    }\n\n    /**\n     * Blacklist playlists that are known to be codec or\n     * stream-incompatible with the SourceBuffer configuration. For\n     * instance, Media Source Extensions would cause the video element to\n     * stall waiting for video data if you switched from a variant with\n     * video and audio to an audio-only one.\n     *\n     * @param {Object} media a media playlist compatible with the current\n     * set of SourceBuffers. Variants in the current master playlist that\n     * do not appear to have compatible codec or stream configurations\n     * will be excluded from the default playlist selection algorithm\n     * indefinitely.\n     * @private\n     */\n  }, {\n    key: 'excludeIncompatibleVariants_',\n    value: function excludeIncompatibleVariants_(media) {\n      var master = this.masterPlaylistLoader_.master;\n      var codecCount = 2;\n      var videoCodec = null;\n      var codecs = undefined;\n\n      if (media.attributes.CODECS) {\n        codecs = (0, _utilCodecsJs.parseCodecs)(media.attributes.CODECS);\n        videoCodec = codecs.videoCodec;\n        codecCount = codecs.codecCount;\n      }\n      master.playlists.forEach(function (variant) {\n        var variantCodecs = {\n          codecCount: 2,\n          videoCodec: null\n        };\n\n        if (variant.attributes.CODECS) {\n          var codecString = variant.attributes.CODECS;\n\n          variantCodecs = (0, _utilCodecsJs.parseCodecs)(codecString);\n\n          if (window.MediaSource && window.MediaSource.isTypeSupported && !window.MediaSource.isTypeSupported('video/mp4; codecs=\"' + mapLegacyAvcCodecs_(codecString) + '\"')) {\n            variant.excludeUntil = Infinity;\n          }\n        }\n\n        // if the streams differ in the presence or absence of audio or\n        // video, they are incompatible\n        if (variantCodecs.codecCount !== codecCount) {\n          variant.excludeUntil = Infinity;\n        }\n\n        // if h.264 is specified on the current playlist, some flavor of\n        // it must be specified on all compatible variants\n        if (variantCodecs.videoCodec !== videoCodec) {\n          variant.excludeUntil = Infinity;\n        }\n      });\n    }\n  }, {\n    key: 'updateAdCues_',\n    value: function updateAdCues_(media) {\n      var offset = 0;\n      var seekable = this.seekable();\n\n      if (seekable.length) {\n        offset = seekable.start(0);\n      }\n\n      _adCueTags2['default'].updateAdCues(media, this.cueTagsTrack_, offset);\n    }\n\n    /**\n     * Calculates the desired forward buffer length based on current time\n     *\n     * @return {Number} Desired forward buffer length in seconds\n     */\n  }, {\n    key: 'goalBufferLength',\n    value: function goalBufferLength() {\n      var currentTime = this.tech_.currentTime();\n      var initial = _config2['default'].GOAL_BUFFER_LENGTH;\n      var rate = _config2['default'].GOAL_BUFFER_LENGTH_RATE;\n      var max = Math.max(initial, _config2['default'].MAX_GOAL_BUFFER_LENGTH);\n\n      return Math.min(initial + currentTime * rate, max);\n    }\n\n    /**\n     * Calculates the desired buffer low water line based on current time\n     *\n     * @return {Number} Desired buffer low water line in seconds\n     */\n  }, {\n    key: 'bufferLowWaterLine',\n    value: function bufferLowWaterLine() {\n      var currentTime = this.tech_.currentTime();\n      var initial = _config2['default'].BUFFER_LOW_WATER_LINE;\n      var rate = _config2['default'].BUFFER_LOW_WATER_LINE_RATE;\n      var max = Math.max(initial, _config2['default'].MAX_BUFFER_LOW_WATER_LINE);\n\n      return Math.min(initial + currentTime * rate, max);\n    }\n  }]);\n\n  return MasterPlaylistController;\n})(_videoJs2['default'].EventTarget);\n\nexports.MasterPlaylistController = MasterPlaylistController;\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./ad-cue-tags\":1,\"./config\":3,\"./decrypter-worker\":4,\"./media-groups\":6,\"./playlist-loader\":9,\"./playlist.js\":11,\"./ranges\":12,\"./segment-loader\":16,\"./sync-controller\":18,\"./util/codecs.js\":19,\"./vtt-segment-loader\":20,\"videojs-contrib-media-sources/es5/codec-utils\":65,\"webworkify\":76}],6:[function(require,module,exports){\n(function (global){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _playlistLoader = require('./playlist-loader');\n\nvar _playlistLoader2 = _interopRequireDefault(_playlistLoader);\n\nvar noop = function noop() {};\n\n/**\n * Convert the properties of an HLS track into an audioTrackKind.\n *\n * @private\n */\nvar audioTrackKind_ = function audioTrackKind_(properties) {\n  var kind = properties['default'] ? 'main' : 'alternative';\n\n  if (properties.characteristics && properties.characteristics.indexOf('public.accessibility.describes-video') >= 0) {\n    kind = 'main-desc';\n  }\n\n  return kind;\n};\n\n/**\n * Pause provided segment loader and playlist loader if active\n *\n * @param {SegmentLoader} segmentLoader\n *        SegmentLoader to pause\n * @param {Object} mediaType\n *        Active media type\n * @function stopLoaders\n */\nvar stopLoaders = function stopLoaders(segmentLoader, mediaType) {\n  segmentLoader.abort();\n  segmentLoader.pause();\n\n  if (mediaType && mediaType.activePlaylistLoader) {\n    mediaType.activePlaylistLoader.pause();\n    mediaType.activePlaylistLoader = null;\n  }\n};\n\nexports.stopLoaders = stopLoaders;\n/**\n * Start loading provided segment loader and playlist loader\n *\n * @param {PlaylistLoader} playlistLoader\n *        PlaylistLoader to start loading\n * @param {Object} mediaType\n *        Active media type\n * @function startLoaders\n */\nvar startLoaders = function startLoaders(playlistLoader, mediaType) {\n  // Segment loader will be started after `loadedmetadata` or `loadedplaylist` from the\n  // playlist loader\n  mediaType.activePlaylistLoader = playlistLoader;\n  playlistLoader.load();\n};\n\nexports.startLoaders = startLoaders;\n/**\n * Returns a function to be called when the media group changes. It performs a\n * non-destructive (preserve the buffer) resync of the SegmentLoader. This is because a\n * change of group is merely a rendition switch of the same content at another encoding,\n * rather than a change of content, such as switching audio from English to Spanish.\n *\n * @param {String} type\n *        MediaGroup type\n * @param {Object} settings\n *        Object containing required information for media groups\n * @return {Function}\n *         Handler for a non-destructive resync of SegmentLoader when the active media\n *         group changes.\n * @function onGroupChanged\n */\nvar onGroupChanged = function onGroupChanged(type, settings) {\n  return function () {\n    var _settings$segmentLoaders = settings.segmentLoaders;\n    var segmentLoader = _settings$segmentLoaders[type];\n    var mainSegmentLoader = _settings$segmentLoaders.main;\n    var mediaType = settings.mediaTypes[type];\n\n    var activeTrack = mediaType.activeTrack();\n    var activeGroup = mediaType.activeGroup(activeTrack);\n    var previousActiveLoader = mediaType.activePlaylistLoader;\n\n    stopLoaders(segmentLoader, mediaType);\n\n    if (!activeGroup) {\n      // there is no group active\n      return;\n    }\n\n    if (!activeGroup.playlistLoader) {\n      if (previousActiveLoader) {\n        // The previous group had a playlist loader but the new active group does not\n        // this means we are switching from demuxed to muxed audio. In this case we want to\n        // do a destructive reset of the main segment loader and not restart the audio\n        // loaders.\n        mainSegmentLoader.resetEverything();\n      }\n      return;\n    }\n\n    // Non-destructive resync\n    segmentLoader.resyncLoader();\n\n    startLoaders(activeGroup.playlistLoader, mediaType);\n  };\n};\n\nexports.onGroupChanged = onGroupChanged;\n/**\n * Returns a function to be called when the media track changes. It performs a\n * destructive reset of the SegmentLoader to ensure we start loading as close to\n * currentTime as possible.\n *\n * @param {String} type\n *        MediaGroup type\n * @param {Object} settings\n *        Object containing required information for media groups\n * @return {Function}\n *         Handler for a destructive reset of SegmentLoader when the active media\n *         track changes.\n * @function onTrackChanged\n */\nvar onTrackChanged = function onTrackChanged(type, settings) {\n  return function () {\n    var _settings$segmentLoaders2 = settings.segmentLoaders;\n    var segmentLoader = _settings$segmentLoaders2[type];\n    var mainSegmentLoader = _settings$segmentLoaders2.main;\n    var mediaType = settings.mediaTypes[type];\n\n    var activeTrack = mediaType.activeTrack();\n    var activeGroup = mediaType.activeGroup(activeTrack);\n    var previousActiveLoader = mediaType.activePlaylistLoader;\n\n    stopLoaders(segmentLoader, mediaType);\n\n    if (!activeGroup) {\n      // there is no group active so we do not want to restart loaders\n      return;\n    }\n\n    if (!activeGroup.playlistLoader) {\n      // when switching from demuxed audio/video to muxed audio/video (noted by no playlist\n      // loader for the audio group), we want to do a destructive reset of the main segment\n      // loader and not restart the audio loaders\n      mainSegmentLoader.resetEverything();\n      return;\n    }\n\n    if (previousActiveLoader === activeGroup.playlistLoader) {\n      // Nothing has actually changed. This can happen because track change events can fire\n      // multiple times for a \"single\" change. One for enabling the new active track, and\n      // one for disabling the track that was active\n      startLoaders(activeGroup.playlistLoader, mediaType);\n      return;\n    }\n\n    if (segmentLoader.track) {\n      // For WebVTT, set the new text track in the segmentloader\n      segmentLoader.track(activeTrack);\n    }\n\n    // destructive reset\n    segmentLoader.resetEverything();\n\n    startLoaders(activeGroup.playlistLoader, mediaType);\n  };\n};\n\nexports.onTrackChanged = onTrackChanged;\nvar onError = {\n  /**\n   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\n   * an error.\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Error handler. Logs warning (or error if the playlist is blacklisted) to\n   *         console and switches back to default audio track.\n   * @function onError.AUDIO\n   */\n  AUDIO: function AUDIO(type, settings) {\n    return function () {\n      var segmentLoader = settings.segmentLoaders[type];\n      var mediaType = settings.mediaTypes[type];\n      var blacklistCurrentPlaylist = settings.blacklistCurrentPlaylist;\n\n      stopLoaders(segmentLoader, mediaType);\n\n      // switch back to default audio track\n      var activeTrack = mediaType.activeTrack();\n      var activeGroup = mediaType.activeGroup();\n      var id = (activeGroup.filter(function (group) {\n        return group['default'];\n      })[0] || activeGroup[0]).id;\n      var defaultTrack = mediaType.tracks[id];\n\n      if (activeTrack === defaultTrack) {\n        // Default track encountered an error. All we can do now is blacklist the current\n        // rendition and hope another will switch audio groups\n        blacklistCurrentPlaylist({\n          message: 'Problem encountered loading the default audio track.'\n        });\n        return;\n      }\n\n      _videoJs2['default'].log.warn('Problem encountered loading the alternate audio track.' + 'Switching back to default.');\n\n      for (var trackId in mediaType.tracks) {\n        mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;\n      }\n\n      mediaType.onTrackChanged();\n    };\n  },\n  /**\n   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\n   * an error.\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Error handler. Logs warning to console and disables the active subtitle track\n   * @function onError.SUBTITLES\n   */\n  SUBTITLES: function SUBTITLES(type, settings) {\n    return function () {\n      var segmentLoader = settings.segmentLoaders[type];\n      var mediaType = settings.mediaTypes[type];\n\n      _videoJs2['default'].log.warn('Problem encountered loading the subtitle track.' + 'Disabling subtitle track.');\n\n      stopLoaders(segmentLoader, mediaType);\n\n      var track = mediaType.activeTrack();\n\n      if (track) {\n        track.mode = 'disabled';\n      }\n\n      mediaType.onTrackChanged();\n    };\n  }\n};\n\nexports.onError = onError;\nvar setupListeners = {\n  /**\n   * Setup event listeners for audio playlist loader\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {PlaylistLoader|null} playlistLoader\n   *        PlaylistLoader to register listeners on\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function setupListeners.AUDIO\n   */\n  AUDIO: function AUDIO(type, playlistLoader, settings) {\n    if (!playlistLoader) {\n      // no playlist loader means audio will be muxed with the video\n      return;\n    }\n\n    var tech = settings.tech;\n    var requestOptions = settings.requestOptions;\n    var segmentLoader = settings.segmentLoaders[type];\n\n    playlistLoader.on('loadedmetadata', function () {\n      var media = playlistLoader.media();\n\n      segmentLoader.playlist(media, requestOptions);\n\n      // if the video is already playing, or if this isn't a live video and preload\n      // permits, start downloading segments\n      if (!tech.paused() || media.endList && tech.preload() !== 'none') {\n        segmentLoader.load();\n      }\n    });\n\n    playlistLoader.on('loadedplaylist', function () {\n      segmentLoader.playlist(playlistLoader.media(), requestOptions);\n\n      // If the player isn't paused, ensure that the segment loader is running\n      if (!tech.paused()) {\n        segmentLoader.load();\n      }\n    });\n\n    playlistLoader.on('error', onError[type](type, settings));\n  },\n  /**\n   * Setup event listeners for subtitle playlist loader\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {PlaylistLoader|null} playlistLoader\n   *        PlaylistLoader to register listeners on\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function setupListeners.SUBTITLES\n   */\n  SUBTITLES: function SUBTITLES(type, playlistLoader, settings) {\n    var tech = settings.tech;\n    var requestOptions = settings.requestOptions;\n    var segmentLoader = settings.segmentLoaders[type];\n    var mediaType = settings.mediaTypes[type];\n\n    playlistLoader.on('loadedmetadata', function () {\n      var media = playlistLoader.media();\n\n      segmentLoader.playlist(media, requestOptions);\n      segmentLoader.track(mediaType.activeTrack());\n\n      // if the video is already playing, or if this isn't a live video and preload\n      // permits, start downloading segments\n      if (!tech.paused() || media.endList && tech.preload() !== 'none') {\n        segmentLoader.load();\n      }\n    });\n\n    playlistLoader.on('loadedplaylist', function () {\n      segmentLoader.playlist(playlistLoader.media(), requestOptions);\n\n      // If the player isn't paused, ensure that the segment loader is running\n      if (!tech.paused()) {\n        segmentLoader.load();\n      }\n    });\n\n    playlistLoader.on('error', onError[type](type, settings));\n  }\n};\n\nexports.setupListeners = setupListeners;\nvar initialize = {\n  /**\n   * Setup PlaylistLoaders and AudioTracks for the audio groups\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function initialize.AUDIO\n   */\n  'AUDIO': function AUDIO(type, settings) {\n    var mode = settings.mode;\n    var hls = settings.hls;\n    var segmentLoader = settings.segmentLoaders[type];\n    var withCredentials = settings.requestOptions.withCredentials;\n    var mediaGroups = settings.master.mediaGroups;\n    var _settings$mediaTypes$type = settings.mediaTypes[type];\n    var groups = _settings$mediaTypes$type.groups;\n    var tracks = _settings$mediaTypes$type.tracks;\n\n    // force a default if we have none or we are not\n    // in html5 mode (the only mode to support more than one\n    // audio track)\n    if (!mediaGroups[type] || Object.keys(mediaGroups[type]).length === 0 || mode !== 'html5') {\n      mediaGroups[type] = { main: { 'default': { 'default': true } } };\n    }\n\n    for (var groupId in mediaGroups[type]) {\n      if (!groups[groupId]) {\n        groups[groupId] = [];\n      }\n\n      for (var variantLabel in mediaGroups[type][groupId]) {\n        var properties = mediaGroups[type][groupId][variantLabel];\n        var playlistLoader = undefined;\n\n        if (properties.resolvedUri) {\n          playlistLoader = new _playlistLoader2['default'](properties.resolvedUri, hls, withCredentials);\n        } else {\n          // no resolvedUri means the audio is muxed with the video when using this\n          // audio track\n          playlistLoader = null;\n        }\n\n        properties = _videoJs2['default'].mergeOptions({ id: variantLabel, playlistLoader: playlistLoader }, properties);\n\n        setupListeners[type](type, properties.playlistLoader, settings);\n\n        groups[groupId].push(properties);\n\n        if (typeof tracks[variantLabel] === 'undefined') {\n          var track = new _videoJs2['default'].AudioTrack({\n            id: variantLabel,\n            kind: audioTrackKind_(properties),\n            enabled: false,\n            language: properties.language,\n            'default': properties['default'],\n            label: variantLabel\n          });\n\n          tracks[variantLabel] = track;\n        }\n      }\n    }\n\n    // setup single error event handler for the segment loader\n    segmentLoader.on('error', onError[type](type, settings));\n  },\n  /**\n   * Setup PlaylistLoaders and TextTracks for the subtitle groups\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function initialize.SUBTITLES\n   */\n  'SUBTITLES': function SUBTITLES(type, settings) {\n    var tech = settings.tech;\n    var hls = settings.hls;\n    var segmentLoader = settings.segmentLoaders[type];\n    var withCredentials = settings.requestOptions.withCredentials;\n    var mediaGroups = settings.master.mediaGroups;\n    var _settings$mediaTypes$type2 = settings.mediaTypes[type];\n    var groups = _settings$mediaTypes$type2.groups;\n    var tracks = _settings$mediaTypes$type2.tracks;\n\n    for (var groupId in mediaGroups[type]) {\n      if (!groups[groupId]) {\n        groups[groupId] = [];\n      }\n\n      for (var variantLabel in mediaGroups[type][groupId]) {\n        if (mediaGroups[type][groupId][variantLabel].forced) {\n          // Subtitle playlists with the forced attribute are not selectable in Safari.\n          // According to Apple's HLS Authoring Specification:\n          //   If content has forced subtitles and regular subtitles in a given language,\n          //   the regular subtitles track in that language MUST contain both the forced\n          //   subtitles and the regular subtitles for that language.\n          // Because of this requirement and that Safari does not add forced subtitles,\n          // forced subtitles are skipped here to maintain consistent experience across\n          // all platforms\n          continue;\n        }\n\n        var properties = mediaGroups[type][groupId][variantLabel];\n\n        properties = _videoJs2['default'].mergeOptions({\n          id: variantLabel,\n          playlistLoader: new _playlistLoader2['default'](properties.resolvedUri, hls, withCredentials)\n        }, properties);\n\n        setupListeners[type](type, properties.playlistLoader, settings);\n\n        groups[groupId].push(properties);\n\n        if (typeof tracks[variantLabel] === 'undefined') {\n          var track = tech.addRemoteTextTrack({\n            id: variantLabel,\n            kind: 'subtitles',\n            enabled: false,\n            language: properties.language,\n            label: variantLabel\n          }, false).track;\n\n          tracks[variantLabel] = track;\n        }\n      }\n    }\n\n    // setup single error event handler for the segment loader\n    segmentLoader.on('error', onError[type](type, settings));\n  },\n  /**\n   * Setup TextTracks for the closed-caption groups\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @function initialize['CLOSED-CAPTIONS']\n   */\n  'CLOSED-CAPTIONS': function CLOSEDCAPTIONS(type, settings) {\n    var tech = settings.tech;\n    var mediaGroups = settings.master.mediaGroups;\n    var _settings$mediaTypes$type3 = settings.mediaTypes[type];\n    var groups = _settings$mediaTypes$type3.groups;\n    var tracks = _settings$mediaTypes$type3.tracks;\n\n    for (var groupId in mediaGroups[type]) {\n      if (!groups[groupId]) {\n        groups[groupId] = [];\n      }\n\n      for (var variantLabel in mediaGroups[type][groupId]) {\n        var properties = mediaGroups[type][groupId][variantLabel];\n\n        // We only support CEA608 captions for now, so ignore anything that\n        // doesn't use a CCx INSTREAM-ID\n        if (!properties.instreamId.match(/CC\\d/)) {\n          continue;\n        }\n\n        // No PlaylistLoader is required for Closed-Captions because the captions are\n        // embedded within the video stream\n        groups[groupId].push(_videoJs2['default'].mergeOptions({ id: variantLabel }, properties));\n\n        if (typeof tracks[variantLabel] === 'undefined') {\n          var track = tech.addRemoteTextTrack({\n            id: properties.instreamId,\n            kind: 'captions',\n            enabled: false,\n            language: properties.language,\n            label: variantLabel\n          }, false).track;\n\n          tracks[variantLabel] = track;\n        }\n      }\n    }\n  }\n};\n\nexports.initialize = initialize;\n/**\n * Returns a function used to get the active group of the provided type\n *\n * @param {String} type\n *        MediaGroup type\n * @param {Object} settings\n *        Object containing required information for media groups\n * @return {Function}\n *         Function that returns the active media group for the provided type. Takes an\n *         optional parameter {TextTrack} track. If no track is provided, a list of all\n *         variants in the group, otherwise the variant corresponding to the provided\n *         track is returned.\n * @function activeGroup\n */\nvar activeGroup = function activeGroup(type, settings) {\n  return function (track) {\n    var masterPlaylistLoader = settings.masterPlaylistLoader;\n    var groups = settings.mediaTypes[type].groups;\n\n    var media = masterPlaylistLoader.media();\n\n    if (!media) {\n      return null;\n    }\n\n    var variants = null;\n\n    if (media.attributes[type]) {\n      variants = groups[media.attributes[type]];\n    }\n\n    variants = variants || groups.main;\n\n    if (typeof track === 'undefined') {\n      return variants;\n    }\n\n    if (track === null) {\n      // An active track was specified so a corresponding group is expected. track === null\n      // means no track is currently active so there is no corresponding group\n      return null;\n    }\n\n    return variants.filter(function (props) {\n      return props.id === track.id;\n    })[0] || null;\n  };\n};\n\nexports.activeGroup = activeGroup;\nvar activeTrack = {\n  /**\n   * Returns a function used to get the active track of type provided\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Function that returns the active media track for the provided type. Returns\n   *         null if no track is active\n   * @function activeTrack.AUDIO\n   */\n  AUDIO: function AUDIO(type, settings) {\n    return function () {\n      var tracks = settings.mediaTypes[type].tracks;\n\n      for (var id in tracks) {\n        if (tracks[id].enabled) {\n          return tracks[id];\n        }\n      }\n\n      return null;\n    };\n  },\n  /**\n   * Returns a function used to get the active track of type provided\n   *\n   * @param {String} type\n   *        MediaGroup type\n   * @param {Object} settings\n   *        Object containing required information for media groups\n   * @return {Function}\n   *         Function that returns the active media track for the provided type. Returns\n   *         null if no track is active\n   * @function activeTrack.SUBTITLES\n   */\n  SUBTITLES: function SUBTITLES(type, settings) {\n    return function () {\n      var tracks = settings.mediaTypes[type].tracks;\n\n      for (var id in tracks) {\n        if (tracks[id].mode === 'showing') {\n          return tracks[id];\n        }\n      }\n\n      return null;\n    };\n  }\n};\n\nexports.activeTrack = activeTrack;\n/**\n * Setup PlaylistLoaders and Tracks for media groups (Audio, Subtitles,\n * Closed-Captions) specified in the master manifest.\n *\n * @param {Object} settings\n *        Object containing required information for setting up the media groups\n * @param {SegmentLoader} settings.segmentLoaders.AUDIO\n *        Audio segment loader\n * @param {SegmentLoader} settings.segmentLoaders.SUBTITLES\n *        Subtitle segment loader\n * @param {SegmentLoader} settings.segmentLoaders.main\n *        Main segment loader\n * @param {Tech} settings.tech\n *        The tech of the player\n * @param {Object} settings.requestOptions\n *        XHR request options used by the segment loaders\n * @param {PlaylistLoader} settings.masterPlaylistLoader\n *        PlaylistLoader for the master source\n * @param {String} mode\n *        Mode of the hls source handler. Can be 'auto', 'html5', or 'flash'\n * @param {HlsHandler} settings.hls\n *        HLS SourceHandler\n * @param {Object} settings.master\n *        The parsed master manifest\n * @param {Object} settings.mediaTypes\n *        Object to store the loaders, tracks, and utility methods for each media type\n * @param {Function} settings.blacklistCurrentPlaylist\n *        Blacklists the current rendition and forces a rendition switch.\n * @function setupMediaGroups\n */\nvar setupMediaGroups = function setupMediaGroups(settings) {\n  ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(function (type) {\n    initialize[type](type, settings);\n  });\n\n  var mediaTypes = settings.mediaTypes;\n  var masterPlaylistLoader = settings.masterPlaylistLoader;\n  var tech = settings.tech;\n  var hls = settings.hls;\n\n  // setup active group and track getters and change event handlers\n  ['AUDIO', 'SUBTITLES'].forEach(function (type) {\n    mediaTypes[type].activeGroup = activeGroup(type, settings);\n    mediaTypes[type].activeTrack = activeTrack[type](type, settings);\n    mediaTypes[type].onGroupChanged = onGroupChanged(type, settings);\n    mediaTypes[type].onTrackChanged = onTrackChanged(type, settings);\n  });\n\n  // DO NOT enable the default subtitle or caption track.\n  // DO enable the default audio track\n  var audioGroup = mediaTypes.AUDIO.activeGroup();\n  var groupId = (audioGroup.filter(function (group) {\n    return group['default'];\n  })[0] || audioGroup[0]).id;\n\n  mediaTypes.AUDIO.tracks[groupId].enabled = true;\n  mediaTypes.AUDIO.onTrackChanged();\n\n  masterPlaylistLoader.on('mediachange', function () {\n    ['AUDIO', 'SUBTITLES'].forEach(function (type) {\n      return mediaTypes[type].onGroupChanged();\n    });\n  });\n\n  // custom audio track change event handler for usage event\n  var onAudioTrackChanged = function onAudioTrackChanged() {\n    mediaTypes.AUDIO.onTrackChanged();\n    tech.trigger({ type: 'usage', name: 'hls-audio-change' });\n  };\n\n  tech.audioTracks().addEventListener('change', onAudioTrackChanged);\n  tech.remoteTextTracks().addEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\n\n  hls.on('dispose', function () {\n    tech.audioTracks().removeEventListener('change', onAudioTrackChanged);\n    tech.remoteTextTracks().removeEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\n  });\n\n  // clear existing audio tracks and add the ones we just created\n  tech.clearTracks('audio');\n\n  for (var id in mediaTypes.AUDIO.tracks) {\n    tech.audioTracks().addTrack(mediaTypes.AUDIO.tracks[id]);\n  }\n};\n\nexports.setupMediaGroups = setupMediaGroups;\n/**\n * Creates skeleton object used to store the loaders, tracks, and utility methods for each\n * media type\n *\n * @return {Object}\n *         Object to store the loaders, tracks, and utility methods for each media type\n * @function createMediaTypes\n */\nvar createMediaTypes = function createMediaTypes() {\n  var mediaTypes = {};\n\n  ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(function (type) {\n    mediaTypes[type] = {\n      groups: {},\n      tracks: {},\n      activePlaylistLoader: null,\n      activeGroup: noop,\n      activeTrack: noop,\n      onGroupChanged: noop,\n      onTrackChanged: noop\n    };\n  });\n\n  return mediaTypes;\n};\nexports.createMediaTypes = createMediaTypes;\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./playlist-loader\":9}],7:[function(require,module,exports){\n(function (global){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _binUtils = require('./bin-utils');\n\nvar REQUEST_ERRORS = {\n  FAILURE: 2,\n  TIMEOUT: -101,\n  ABORTED: -102\n};\n\nexports.REQUEST_ERRORS = REQUEST_ERRORS;\n/**\n * Turns segment byterange into a string suitable for use in\n * HTTP Range requests\n *\n * @param {Object} byterange - an object with two values defining the start and end\n *                             of a byte-range\n */\nvar byterangeStr = function byterangeStr(byterange) {\n  var byterangeStart = undefined;\n  var byterangeEnd = undefined;\n\n  // `byterangeEnd` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  byterangeEnd = byterange.offset + byterange.length - 1;\n  byterangeStart = byterange.offset;\n  return 'bytes=' + byterangeStart + '-' + byterangeEnd;\n};\n\n/**\n * Defines headers for use in the xhr request for a particular segment.\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n */\nvar segmentXhrHeaders = function segmentXhrHeaders(segment) {\n  var headers = {};\n\n  if (segment.byterange) {\n    headers.Range = byterangeStr(segment.byterange);\n  }\n  return headers;\n};\n\n/**\n * Abort all requests\n *\n * @param {Object} activeXhrs - an object that tracks all XHR requests\n */\nvar abortAll = function abortAll(activeXhrs) {\n  activeXhrs.forEach(function (xhr) {\n    xhr.abort();\n  });\n};\n\n/**\n * Gather important bandwidth stats once a request has completed\n *\n * @param {Object} request - the XHR request from which to gather stats\n */\nvar getRequestStats = function getRequestStats(request) {\n  return {\n    bandwidth: request.bandwidth,\n    bytesReceived: request.bytesReceived || 0,\n    roundTripTime: request.roundTripTime || 0\n  };\n};\n\n/**\n * If possible gather bandwidth stats as a request is in\n * progress\n *\n * @param {Event} progressEvent - an event object from an XHR's progress event\n */\nvar getProgressStats = function getProgressStats(progressEvent) {\n  var request = progressEvent.target;\n  var roundTripTime = Date.now() - request.requestTime;\n  var stats = {\n    bandwidth: Infinity,\n    bytesReceived: 0,\n    roundTripTime: roundTripTime || 0\n  };\n\n  stats.bytesReceived = progressEvent.loaded;\n  // This can result in Infinity if stats.roundTripTime is 0 but that is ok\n  // because we should only use bandwidth stats on progress to determine when\n  // abort a request early due to insufficient bandwidth\n  stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1000);\n\n  return stats;\n};\n\n/**\n * Handle all error conditions in one place and return an object\n * with all the information\n *\n * @param {Error|null} error - if non-null signals an error occured with the XHR\n * @param {Object} request -  the XHR request that possibly generated the error\n */\nvar handleErrors = function handleErrors(error, request) {\n  if (request.timedout) {\n    return {\n      status: request.status,\n      message: 'HLS request timed-out at URL: ' + request.uri,\n      code: REQUEST_ERRORS.TIMEOUT,\n      xhr: request\n    };\n  }\n\n  if (request.aborted) {\n    return {\n      status: request.status,\n      message: 'HLS request aborted at URL: ' + request.uri,\n      code: REQUEST_ERRORS.ABORTED,\n      xhr: request\n    };\n  }\n\n  if (error) {\n    return {\n      status: request.status,\n      message: 'HLS request errored at URL: ' + request.uri,\n      code: REQUEST_ERRORS.FAILURE,\n      xhr: request\n    };\n  }\n\n  return null;\n};\n\n/**\n * Handle responses for key data and convert the key data to the correct format\n * for the decryption step later\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} finishProcessingFn - a callback to execute to continue processing\n *                                        this request\n */\nvar handleKeyResponse = function handleKeyResponse(segment, finishProcessingFn) {\n  return function (error, request) {\n    var response = request.response;\n    var errorObj = handleErrors(error, request);\n\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n\n    if (response.byteLength !== 16) {\n      return finishProcessingFn({\n        status: request.status,\n        message: 'Invalid HLS key at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      }, segment);\n    }\n\n    var view = new DataView(response);\n\n    segment.key.bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);\n    return finishProcessingFn(null, segment);\n  };\n};\n\n/**\n * Handle init-segment responses\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} finishProcessingFn - a callback to execute to continue processing\n *                                        this request\n */\nvar handleInitSegmentResponse = function handleInitSegmentResponse(segment, finishProcessingFn) {\n  return function (error, request) {\n    var response = request.response;\n    var errorObj = handleErrors(error, request);\n\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n\n    // stop processing if received empty content\n    if (response.byteLength === 0) {\n      return finishProcessingFn({\n        status: request.status,\n        message: 'Empty HLS segment content at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      }, segment);\n    }\n\n    segment.map.bytes = new Uint8Array(request.response);\n    return finishProcessingFn(null, segment);\n  };\n};\n\n/**\n * Response handler for segment-requests being sure to set the correct\n * property depending on whether the segment is encryped or not\n * Also records and keeps track of stats that are used for ABR purposes\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} finishProcessingFn - a callback to execute to continue processing\n *                                        this request\n */\nvar handleSegmentResponse = function handleSegmentResponse(segment, finishProcessingFn) {\n  return function (error, request) {\n    var response = request.response;\n    var errorObj = handleErrors(error, request);\n\n    if (errorObj) {\n      return finishProcessingFn(errorObj, segment);\n    }\n\n    // stop processing if received empty content\n    if (response.byteLength === 0) {\n      return finishProcessingFn({\n        status: request.status,\n        message: 'Empty HLS segment content at URL: ' + request.uri,\n        code: REQUEST_ERRORS.FAILURE,\n        xhr: request\n      }, segment);\n    }\n\n    segment.stats = getRequestStats(request);\n\n    if (segment.key) {\n      segment.encryptedBytes = new Uint8Array(request.response);\n    } else {\n      segment.bytes = new Uint8Array(request.response);\n    }\n\n    return finishProcessingFn(null, segment);\n  };\n};\n\n/**\n * Decrypt the segment via the decryption web worker\n *\n * @param {WebWorker} decrypter - a WebWorker interface to AES-128 decryption routines\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} doneFn - a callback that is executed after decryption has completed\n */\nvar decryptSegment = function decryptSegment(decrypter, segment, doneFn) {\n  var decryptionHandler = function decryptionHandler(event) {\n    if (event.data.source === segment.requestId) {\n      decrypter.removeEventListener('message', decryptionHandler);\n      var decrypted = event.data.decrypted;\n\n      segment.bytes = new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength);\n      return doneFn(null, segment);\n    }\n  };\n\n  decrypter.addEventListener('message', decryptionHandler);\n\n  // this is an encrypted segment\n  // incrementally decrypt the segment\n  decrypter.postMessage((0, _binUtils.createTransferableMessage)({\n    source: segment.requestId,\n    encrypted: segment.encryptedBytes,\n    key: segment.key.bytes,\n    iv: segment.key.iv\n  }), [segment.encryptedBytes.buffer, segment.key.bytes.buffer]);\n};\n\n/**\n * The purpose of this function is to get the most pertinent error from the\n * array of errors.\n * For instance if a timeout and two aborts occur, then the aborts were\n * likely triggered by the timeout so return that error object.\n */\nvar getMostImportantError = function getMostImportantError(errors) {\n  return errors.reduce(function (prev, err) {\n    return err.code > prev.code ? err : prev;\n  });\n};\n\n/**\n * This function waits for all XHRs to finish (with either success or failure)\n * before continueing processing via it's callback. The function gathers errors\n * from each request into a single errors array so that the error status for\n * each request can be examined later.\n *\n * @param {Object} activeXhrs - an object that tracks all XHR requests\n * @param {WebWorker} decrypter - a WebWorker interface to AES-128 decryption routines\n * @param {Function} doneFn - a callback that is executed after all resources have been\n *                            downloaded and any decryption completed\n */\nvar waitForCompletion = function waitForCompletion(activeXhrs, decrypter, doneFn) {\n  var errors = [];\n  var count = 0;\n\n  return function (error, segment) {\n    if (error) {\n      // If there are errors, we have to abort any outstanding requests\n      abortAll(activeXhrs);\n      errors.push(error);\n    }\n    count += 1;\n\n    if (count === activeXhrs.length) {\n      // Keep track of when *all* of the requests have completed\n      segment.endOfAllRequests = Date.now();\n\n      if (errors.length > 0) {\n        var worstError = getMostImportantError(errors);\n\n        return doneFn(worstError, segment);\n      }\n      if (segment.encryptedBytes) {\n        return decryptSegment(decrypter, segment, doneFn);\n      }\n      // Otherwise, everything is ready just continue\n      return doneFn(null, segment);\n    }\n  };\n};\n\n/**\n * Simple progress event callback handler that gathers some stats before\n * executing a provided callback with the `segment` object\n *\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} progressFn - a callback that is executed each time a progress event\n *                                is received\n * @param {Event} event - the progress event object from XMLHttpRequest\n */\nvar handleProgress = function handleProgress(segment, progressFn) {\n  return function (event) {\n    segment.stats = _videoJs2['default'].mergeOptions(segment.stats, getProgressStats(event));\n\n    // record the time that we receive the first byte of data\n    if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) {\n      segment.stats.firstBytesReceivedAt = Date.now();\n    }\n\n    return progressFn(event, segment);\n  };\n};\n\n/**\n * Load all resources and does any processing necessary for a media-segment\n *\n * Features:\n *   decrypts the media-segment if it has a key uri and an iv\n *   aborts *all* requests if *any* one request fails\n *\n * The segment object, at minimum, has the following format:\n * {\n *   resolvedUri: String,\n *   [byterange]: {\n *     offset: Number,\n *     length: Number\n *   },\n *   [key]: {\n *     resolvedUri: String\n *     [byterange]: {\n *       offset: Number,\n *       length: Number\n *     },\n *     iv: {\n *       bytes: Uint32Array\n *     }\n *   },\n *   [map]: {\n *     resolvedUri: String,\n *     [byterange]: {\n *       offset: Number,\n *       length: Number\n *     },\n *     [bytes]: Uint8Array\n *   }\n * }\n * ...where [name] denotes optional properties\n *\n * @param {Function} xhr - an instance of the xhr wrapper in xhr.js\n * @param {Object} xhrOptions - the base options to provide to all xhr requests\n * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128\n *                                       decryption routines\n * @param {Object} segment - a simplified copy of the segmentInfo object\n *                           from SegmentLoader\n * @param {Function} progressFn - a callback that receives progress events from the main\n *                                segment's xhr request\n * @param {Function} doneFn - a callback that is executed only once all requests have\n *                            succeeded or failed\n * @returns {Function} a function that, when invoked, immediately aborts all\n *                     outstanding requests\n */\nvar mediaSegmentRequest = function mediaSegmentRequest(xhr, xhrOptions, decryptionWorker, segment, progressFn, doneFn) {\n  var activeXhrs = [];\n  var finishProcessingFn = waitForCompletion(activeXhrs, decryptionWorker, doneFn);\n\n  // optionally, request the decryption key\n  if (segment.key) {\n    var keyRequestOptions = _videoJs2['default'].mergeOptions(xhrOptions, {\n      uri: segment.key.resolvedUri,\n      responseType: 'arraybuffer'\n    });\n    var keyRequestCallback = handleKeyResponse(segment, finishProcessingFn);\n    var keyXhr = xhr(keyRequestOptions, keyRequestCallback);\n\n    activeXhrs.push(keyXhr);\n  }\n\n  // optionally, request the associated media init segment\n  if (segment.map && !segment.map.bytes) {\n    var initSegmentOptions = _videoJs2['default'].mergeOptions(xhrOptions, {\n      uri: segment.map.resolvedUri,\n      responseType: 'arraybuffer',\n      headers: segmentXhrHeaders(segment.map)\n    });\n    var initSegmentRequestCallback = handleInitSegmentResponse(segment, finishProcessingFn);\n    var initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);\n\n    activeXhrs.push(initSegmentXhr);\n  }\n\n  var segmentRequestOptions = _videoJs2['default'].mergeOptions(xhrOptions, {\n    uri: segment.resolvedUri,\n    responseType: 'arraybuffer',\n    headers: segmentXhrHeaders(segment)\n  });\n  var segmentRequestCallback = handleSegmentResponse(segment, finishProcessingFn);\n  var segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);\n\n  segmentXhr.addEventListener('progress', handleProgress(segment, progressFn));\n  activeXhrs.push(segmentXhr);\n\n  return function () {\n    return abortAll(activeXhrs);\n  };\n};\nexports.mediaSegmentRequest = mediaSegmentRequest;\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./bin-utils\":2}],8:[function(require,module,exports){\n(function (global){\n/**\n * @file playback-watcher.js\n *\n * Playback starts, and now my watch begins. It shall not end until my death. I shall\n * take no wait, hold no uncleared timeouts, father no bad seeks. I shall wear no crowns\n * and win no glory. I shall live and die at my post. I am the corrector of the underflow.\n * I am the watcher of gaps. I am the shield that guards the realms of seekable. I pledge\n * my life and honor to the Playback Watch, for this Player and all the Players to come.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _ranges = require('./ranges');\n\nvar _ranges2 = _interopRequireDefault(_ranges);\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\n// Set of events that reset the playback-watcher time check logic and clear the timeout\nvar timerCancelEvents = ['seeking', 'seeked', 'pause', 'playing', 'error'];\n\n/**\n * @class PlaybackWatcher\n */\n\nvar PlaybackWatcher = (function () {\n  /**\n   * Represents an PlaybackWatcher object.\n   * @constructor\n   * @param {object} options an object that includes the tech and settings\n   */\n\n  function PlaybackWatcher(options) {\n    var _this = this;\n\n    _classCallCheck(this, PlaybackWatcher);\n\n    this.tech_ = options.tech;\n    this.seekable = options.seekable;\n\n    this.consecutiveUpdates = 0;\n    this.lastRecordedTime = null;\n    this.timer_ = null;\n    this.checkCurrentTimeTimeout_ = null;\n\n    if (options.debug) {\n      this.logger_ = _videoJs2['default'].log.bind(_videoJs2['default'], 'playback-watcher ->');\n    }\n    this.logger_('initialize');\n\n    var canPlayHandler = function canPlayHandler() {\n      return _this.monitorCurrentTime_();\n    };\n    var waitingHandler = function waitingHandler() {\n      return _this.techWaiting_();\n    };\n    var cancelTimerHandler = function cancelTimerHandler() {\n      return _this.cancelTimer_();\n    };\n    var fixesBadSeeksHandler = function fixesBadSeeksHandler() {\n      return _this.fixesBadSeeks_();\n    };\n\n    this.tech_.on('seekablechanged', fixesBadSeeksHandler);\n    this.tech_.on('waiting', waitingHandler);\n    this.tech_.on(timerCancelEvents, cancelTimerHandler);\n    this.tech_.on('canplay', canPlayHandler);\n\n    // Define the dispose function to clean up our events\n    this.dispose = function () {\n      _this.logger_('dispose');\n      _this.tech_.off('seekablechanged', fixesBadSeeksHandler);\n      _this.tech_.off('waiting', waitingHandler);\n      _this.tech_.off(timerCancelEvents, cancelTimerHandler);\n      _this.tech_.off('canplay', canPlayHandler);\n      if (_this.checkCurrentTimeTimeout_) {\n        _globalWindow2['default'].clearTimeout(_this.checkCurrentTimeTimeout_);\n      }\n      _this.cancelTimer_();\n    };\n  }\n\n  /**\n   * Periodically check current time to see if playback stopped\n   *\n   * @private\n   */\n\n  _createClass(PlaybackWatcher, [{\n    key: 'monitorCurrentTime_',\n    value: function monitorCurrentTime_() {\n      this.checkCurrentTime_();\n\n      if (this.checkCurrentTimeTimeout_) {\n        _globalWindow2['default'].clearTimeout(this.checkCurrentTimeTimeout_);\n      }\n\n      // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\n      this.checkCurrentTimeTimeout_ = _globalWindow2['default'].setTimeout(this.monitorCurrentTime_.bind(this), 250);\n    }\n\n    /**\n     * The purpose of this function is to emulate the \"waiting\" event on\n     * browsers that do not emit it when they are waiting for more\n     * data to continue playback\n     *\n     * @private\n     */\n  }, {\n    key: 'checkCurrentTime_',\n    value: function checkCurrentTime_() {\n      if (this.tech_.seeking() && this.fixesBadSeeks_()) {\n        this.consecutiveUpdates = 0;\n        this.lastRecordedTime = this.tech_.currentTime();\n        return;\n      }\n\n      if (this.tech_.paused() || this.tech_.seeking()) {\n        return;\n      }\n\n      var currentTime = this.tech_.currentTime();\n      var buffered = this.tech_.buffered();\n\n      if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + _ranges2['default'].SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) {\n        // If current time is at the end of the final buffered region, then any playback\n        // stall is most likely caused by buffering in a low bandwidth environment. The tech\n        // should fire a `waiting` event in this scenario, but due to browser and tech\n        // inconsistencies (e.g. The Flash tech does not fire a `waiting` event when the end\n        // of the buffer is reached and has fallen off the live window). Calling\n        // `techWaiting_` here allows us to simulate responding to a native `waiting` event\n        // when the tech fails to emit one.\n        return this.techWaiting_();\n      }\n\n      if (this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime) {\n        this.consecutiveUpdates++;\n        this.waiting_();\n      } else if (currentTime === this.lastRecordedTime) {\n        this.consecutiveUpdates++;\n      } else {\n        this.consecutiveUpdates = 0;\n        this.lastRecordedTime = currentTime;\n      }\n    }\n\n    /**\n     * Cancels any pending timers and resets the 'timeupdate' mechanism\n     * designed to detect that we are stalled\n     *\n     * @private\n     */\n  }, {\n    key: 'cancelTimer_',\n    value: function cancelTimer_() {\n      this.consecutiveUpdates = 0;\n\n      if (this.timer_) {\n        this.logger_('cancelTimer_');\n        clearTimeout(this.timer_);\n      }\n\n      this.timer_ = null;\n    }\n\n    /**\n     * Fixes situations where there's a bad seek\n     *\n     * @return {Boolean} whether an action was taken to fix the seek\n     * @private\n     */\n  }, {\n    key: 'fixesBadSeeks_',\n    value: function fixesBadSeeks_() {\n      var seeking = this.tech_.seeking();\n      var seekable = this.seekable();\n      var currentTime = this.tech_.currentTime();\n      var seekTo = undefined;\n\n      if (seeking && this.afterSeekableWindow_(seekable, currentTime)) {\n        var seekableEnd = seekable.end(seekable.length - 1);\n\n        // sync to live point (if VOD, our seekable was updated and we're simply adjusting)\n        seekTo = seekableEnd;\n      }\n\n      if (seeking && this.beforeSeekableWindow_(seekable, currentTime)) {\n        var seekableStart = seekable.start(0);\n\n        // sync to the beginning of the live window\n        // provide a buffer of .1 seconds to handle rounding/imprecise numbers\n        seekTo = seekableStart + _ranges2['default'].SAFE_TIME_DELTA;\n      }\n\n      if (typeof seekTo !== 'undefined') {\n        this.logger_('Trying to seek outside of seekable at time ' + currentTime + ' with ' + ('seekable range ' + _ranges2['default'].printableRange(seekable) + '. Seeking to ') + (seekTo + '.'));\n\n        this.tech_.setCurrentTime(seekTo);\n        return true;\n      }\n\n      return false;\n    }\n\n    /**\n     * Handler for situations when we determine the player is waiting.\n     *\n     * @private\n     */\n  }, {\n    key: 'waiting_',\n    value: function waiting_() {\n      if (this.techWaiting_()) {\n        return;\n      }\n\n      // All tech waiting checks failed. Use last resort correction\n      var currentTime = this.tech_.currentTime();\n      var buffered = this.tech_.buffered();\n      var currentRange = _ranges2['default'].findRange(buffered, currentTime);\n\n      // Sometimes the player can stall for unknown reasons within a contiguous buffered\n      // region with no indication that anything is amiss (seen in Firefox). Seeking to\n      // currentTime is usually enough to kickstart the player. This checks that the player\n      // is currently within a buffered region before attempting a corrective seek.\n      // Chrome does not appear to continue `timeupdate` events after a `waiting` event\n      // until there is ~ 3 seconds of forward buffer available. PlaybackWatcher should also\n      // make sure there is ~3 seconds of forward buffer before taking any corrective action\n      // to avoid triggering an `unknownwaiting` event when the network is slow.\n      if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {\n        this.cancelTimer_();\n        this.tech_.setCurrentTime(currentTime);\n\n        this.logger_('Stopped at ' + currentTime + ' while inside a buffered region ' + ('[' + currentRange.start(0) + ' -> ' + currentRange.end(0) + ']. Attempting to resume ') + 'playback by seeking to the current time.');\n\n        // unknown waiting corrections may be useful for monitoring QoS\n        this.tech_.trigger({ type: 'usage', name: 'hls-unknown-waiting' });\n        return;\n      }\n    }\n\n    /**\n     * Handler for situations when the tech fires a `waiting` event\n     *\n     * @return {Boolean}\n     *         True if an action (or none) was needed to correct the waiting. False if no\n     *         checks passed\n     * @private\n     */\n  }, {\n    key: 'techWaiting_',\n    value: function techWaiting_() {\n      var seekable = this.seekable();\n      var currentTime = this.tech_.currentTime();\n\n      if (this.tech_.seeking() && this.fixesBadSeeks_()) {\n        // Tech is seeking or bad seek fixed, no action needed\n        return true;\n      }\n\n      if (this.tech_.seeking() || this.timer_ !== null) {\n        // Tech is seeking or already waiting on another action, no action needed\n        return true;\n      }\n\n      if (this.beforeSeekableWindow_(seekable, currentTime)) {\n        var livePoint = seekable.end(seekable.length - 1);\n\n        this.logger_('Fell out of live window at time ' + currentTime + '. Seeking to ' + ('live point (seekable end) ' + livePoint));\n        this.cancelTimer_();\n        this.tech_.setCurrentTime(livePoint);\n\n        // live window resyncs may be useful for monitoring QoS\n        this.tech_.trigger({ type: 'usage', name: 'hls-live-resync' });\n        return true;\n      }\n\n      var buffered = this.tech_.buffered();\n      var nextRange = _ranges2['default'].findNextRange(buffered, currentTime);\n\n      if (this.videoUnderflow_(nextRange, buffered, currentTime)) {\n        // Even though the video underflowed and was stuck in a gap, the audio overplayed\n        // the gap, leading currentTime into a buffered range. Seeking to currentTime\n        // allows the video to catch up to the audio position without losing any audio\n        // (only suffering ~3 seconds of frozen video and a pause in audio playback).\n        this.cancelTimer_();\n        this.tech_.setCurrentTime(currentTime);\n\n        // video underflow may be useful for monitoring QoS\n        this.tech_.trigger({ type: 'usage', name: 'hls-video-underflow' });\n        return true;\n      }\n\n      // check for gap\n      if (nextRange.length > 0) {\n        var difference = nextRange.start(0) - currentTime;\n\n        this.logger_('Stopped at ' + currentTime + ', setting timer for ' + difference + ', seeking ' + ('to ' + nextRange.start(0)));\n\n        this.timer_ = setTimeout(this.skipTheGap_.bind(this), difference * 1000, currentTime);\n        return true;\n      }\n\n      // All checks failed. Returning false to indicate failure to correct waiting\n      return false;\n    }\n  }, {\n    key: 'afterSeekableWindow_',\n    value: function afterSeekableWindow_(seekable, currentTime) {\n      if (!seekable.length) {\n        // we can't make a solid case if there's no seekable, default to false\n        return false;\n      }\n\n      if (currentTime > seekable.end(seekable.length - 1) + _ranges2['default'].SAFE_TIME_DELTA) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: 'beforeSeekableWindow_',\n    value: function beforeSeekableWindow_(seekable, currentTime) {\n      if (seekable.length &&\n      // can't fall before 0 and 0 seekable start identifies VOD stream\n      seekable.start(0) > 0 && currentTime < seekable.start(0) - _ranges2['default'].SAFE_TIME_DELTA) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: 'videoUnderflow_',\n    value: function videoUnderflow_(nextRange, buffered, currentTime) {\n      if (nextRange.length === 0) {\n        // Even if there is no available next range, there is still a possibility we are\n        // stuck in a gap due to video underflow.\n        var gap = this.gapFromVideoUnderflow_(buffered, currentTime);\n\n        if (gap) {\n          this.logger_('Encountered a gap in video from ' + gap.start + ' to ' + gap.end + '. ' + ('Seeking to current time ' + currentTime));\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Timer callback. If playback still has not proceeded, then we seek\n     * to the start of the next buffered region.\n     *\n     * @private\n     */\n  }, {\n    key: 'skipTheGap_',\n    value: function skipTheGap_(scheduledCurrentTime) {\n      var buffered = this.tech_.buffered();\n      var currentTime = this.tech_.currentTime();\n      var nextRange = _ranges2['default'].findNextRange(buffered, currentTime);\n\n      this.cancelTimer_();\n\n      if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) {\n        return;\n      }\n\n      this.logger_('skipTheGap_:', 'currentTime:', currentTime, 'scheduled currentTime:', scheduledCurrentTime, 'nextRange start:', nextRange.start(0));\n\n      // only seek if we still have not played\n      this.tech_.setCurrentTime(nextRange.start(0) + _ranges2['default'].TIME_FUDGE_FACTOR);\n\n      this.tech_.trigger({ type: 'usage', name: 'hls-gap-skip' });\n    }\n  }, {\n    key: 'gapFromVideoUnderflow_',\n    value: function gapFromVideoUnderflow_(buffered, currentTime) {\n      // At least in Chrome, if there is a gap in the video buffer, the audio will continue\n      // playing for ~3 seconds after the video gap starts. This is done to account for\n      // video buffer underflow/underrun (note that this is not done when there is audio\n      // buffer underflow/underrun -- in that case the video will stop as soon as it\n      // encounters the gap, as audio stalls are more noticeable/jarring to a user than\n      // video stalls). The player's time will reflect the playthrough of audio, so the\n      // time will appear as if we are in a buffered region, even if we are stuck in a\n      // \"gap.\"\n      //\n      // Example:\n      // video buffer:   0 => 10.1, 10.2 => 20\n      // audio buffer:   0 => 20\n      // overall buffer: 0 => 10.1, 10.2 => 20\n      // current time: 13\n      //\n      // Chrome's video froze at 10 seconds, where the video buffer encountered the gap,\n      // however, the audio continued playing until it reached ~3 seconds past the gap\n      // (13 seconds), at which point it stops as well. Since current time is past the\n      // gap, findNextRange will return no ranges.\n      //\n      // To check for this issue, we see if there is a gap that starts somewhere within\n      // a 3 second range (3 seconds +/- 1 second) back from our current time.\n      var gaps = _ranges2['default'].findGaps(buffered);\n\n      for (var i = 0; i < gaps.length; i++) {\n        var start = gaps.start(i);\n        var end = gaps.end(i);\n\n        // gap is starts no more than 4 seconds back\n        if (currentTime - start < 4 && currentTime - start > 2) {\n          return {\n            start: start,\n            end: end\n          };\n        }\n      }\n\n      return null;\n    }\n\n    /**\n     * A debugging logger noop that is set to console.log only if debugging\n     * is enabled globally\n     *\n     * @private\n     */\n  }, {\n    key: 'logger_',\n    value: function logger_() {}\n  }]);\n\n  return PlaybackWatcher;\n})();\n\nexports['default'] = PlaybackWatcher;\nmodule.exports = exports['default'];\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./ranges\":12,\"global/window\":32}],9:[function(require,module,exports){\n(function (global){\n/**\n * @file playlist-loader.js\n *\n * A state machine that manages the loading, caching, and updating of\n * M3U8 playlists.\n *\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _resolveUrl = require('./resolve-url');\n\nvar _resolveUrl2 = _interopRequireDefault(_resolveUrl);\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _m3u8Parser = require('m3u8-parser');\n\nvar _m3u8Parser2 = _interopRequireDefault(_m3u8Parser);\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\n/**\n  * Returns a new array of segments that is the result of merging\n  * properties from an older list of segments onto an updated\n  * list. No properties on the updated playlist will be overridden.\n  *\n  * @param {Array} original the outdated list of segments\n  * @param {Array} update the updated list of segments\n  * @param {Number=} offset the index of the first update\n  * segment in the original segment list. For non-live playlists,\n  * this should always be zero and does not need to be\n  * specified. For live playlists, it should be the difference\n  * between the media sequence numbers in the original and updated\n  * playlists.\n  * @return a list of merged segment objects\n  */\nvar updateSegments = function updateSegments(original, update, offset) {\n  var result = update.slice();\n\n  offset = offset || 0;\n  var length = Math.min(original.length, update.length + offset);\n\n  for (var i = offset; i < length; i++) {\n    result[i - offset] = (0, _videoJs.mergeOptions)(original[i], result[i - offset]);\n  }\n  return result;\n};\n\nexports.updateSegments = updateSegments;\nvar resolveSegmentUris = function resolveSegmentUris(segment, baseUri) {\n  if (!segment.resolvedUri) {\n    segment.resolvedUri = (0, _resolveUrl2['default'])(baseUri, segment.uri);\n  }\n  if (segment.key && !segment.key.resolvedUri) {\n    segment.key.resolvedUri = (0, _resolveUrl2['default'])(baseUri, segment.key.uri);\n  }\n  if (segment.map && !segment.map.resolvedUri) {\n    segment.map.resolvedUri = (0, _resolveUrl2['default'])(baseUri, segment.map.uri);\n  }\n};\n\nexports.resolveSegmentUris = resolveSegmentUris;\n/**\n  * Returns a new master playlist that is the result of merging an\n  * updated media playlist into the original version. If the\n  * updated media playlist does not match any of the playlist\n  * entries in the original master playlist, null is returned.\n  *\n  * @param {Object} master a parsed master M3U8 object\n  * @param {Object} media a parsed media M3U8 object\n  * @return {Object} a new object that represents the original\n  * master playlist with the updated media playlist merged in, or\n  * null if the merge produced no change.\n  */\nvar updateMaster = function updateMaster(master, media) {\n  var result = (0, _videoJs.mergeOptions)(master, {});\n  var playlist = result.playlists.filter(function (p) {\n    return p.uri === media.uri;\n  })[0];\n\n  if (!playlist) {\n    return null;\n  }\n\n  // consider the playlist unchanged if the number of segments is equal and the media\n  // sequence number is unchanged\n  if (playlist.segments && media.segments && playlist.segments.length === media.segments.length && playlist.mediaSequence === media.mediaSequence) {\n    return null;\n  }\n\n  var mergedPlaylist = (0, _videoJs.mergeOptions)(playlist, media);\n\n  // if the update could overlap existing segment information, merge the two segment lists\n  if (playlist.segments) {\n    mergedPlaylist.segments = updateSegments(playlist.segments, media.segments, media.mediaSequence - playlist.mediaSequence);\n  }\n\n  // resolve any segment URIs to prevent us from having to do it later\n  mergedPlaylist.segments.forEach(function (segment) {\n    resolveSegmentUris(segment, mergedPlaylist.resolvedUri);\n  });\n\n  // TODO Right now in the playlists array there are two references to each playlist, one\n  // that is referenced by index, and one by URI. The index reference may no longer be\n  // necessary.\n  for (var i = 0; i < result.playlists.length; i++) {\n    if (result.playlists[i].uri === media.uri) {\n      result.playlists[i] = mergedPlaylist;\n    }\n  }\n  result.playlists[media.uri] = mergedPlaylist;\n\n  return result;\n};\n\nexports.updateMaster = updateMaster;\nvar setupMediaPlaylists = function setupMediaPlaylists(master) {\n  // setup by-URI lookups and resolve media playlist URIs\n  var i = master.playlists.length;\n\n  while (i--) {\n    var playlist = master.playlists[i];\n\n    master.playlists[playlist.uri] = playlist;\n    playlist.resolvedUri = (0, _resolveUrl2['default'])(master.uri, playlist.uri);\n\n    if (!playlist.attributes) {\n      // Although the spec states an #EXT-X-STREAM-INF tag MUST have a\n      // BANDWIDTH attribute, we can play the stream without it. This means a poorly\n      // formatted master playlist may not have an attribute list. An attributes\n      // property is added here to prevent undefined references when we encounter\n      // this scenario.\n      playlist.attributes = {};\n\n      _videoJs.log.warn('Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.');\n    }\n  }\n};\n\nexports.setupMediaPlaylists = setupMediaPlaylists;\nvar resolveMediaGroupUris = function resolveMediaGroupUris(master) {\n  ['AUDIO', 'SUBTITLES'].forEach(function (mediaType) {\n    for (var groupKey in master.mediaGroups[mediaType]) {\n      for (var labelKey in master.mediaGroups[mediaType][groupKey]) {\n        var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];\n\n        if (mediaProperties.uri) {\n          mediaProperties.resolvedUri = (0, _resolveUrl2['default'])(master.uri, mediaProperties.uri);\n        }\n      }\n    }\n  });\n};\n\nexports.resolveMediaGroupUris = resolveMediaGroupUris;\n/**\n * Calculates the time to wait before refreshing a live playlist\n *\n * @param {Object} media\n *        The current media\n * @param {Boolean} update\n *        True if there were any updates from the last refresh, false otherwise\n * @return {Number}\n *         The time in ms to wait before refreshing the live playlist\n */\nvar refreshDelay = function refreshDelay(media, update) {\n  var lastSegment = media.segments[media.segments.length - 1];\n  var delay = undefined;\n\n  if (update && lastSegment && lastSegment.duration) {\n    delay = lastSegment.duration * 1000;\n  } else {\n    // if the playlist is unchanged since the last reload or last segment duration\n    // cannot be determined, try again after half the target duration\n    delay = (media.targetDuration || 10) * 500;\n  }\n  return delay;\n};\n\nexports.refreshDelay = refreshDelay;\n/**\n * Load a playlist from a remote location\n *\n * @class PlaylistLoader\n * @extends Stream\n * @param {String} srcUrl the url to start with\n * @param {Boolean} withCredentials the withCredentials xhr option\n * @constructor\n */\n\nvar PlaylistLoader = (function (_EventTarget) {\n  _inherits(PlaylistLoader, _EventTarget);\n\n  function PlaylistLoader(srcUrl, hls, withCredentials) {\n    var _this = this;\n\n    _classCallCheck(this, PlaylistLoader);\n\n    _get(Object.getPrototypeOf(PlaylistLoader.prototype), 'constructor', this).call(this);\n\n    this.srcUrl = srcUrl;\n    this.hls_ = hls;\n    this.withCredentials = withCredentials;\n\n    if (!this.srcUrl) {\n      throw new Error('A non-empty playlist URL is required');\n    }\n\n    // initialize the loader state\n    this.state = 'HAVE_NOTHING';\n\n    // live playlist staleness timeout\n    this.on('mediaupdatetimeout', function () {\n      if (_this.state !== 'HAVE_METADATA') {\n        // only refresh the media playlist if no other activity is going on\n        return;\n      }\n\n      _this.state = 'HAVE_CURRENT_METADATA';\n\n      _this.request = _this.hls_.xhr({\n        uri: (0, _resolveUrl2['default'])(_this.master.uri, _this.media().uri),\n        withCredentials: _this.withCredentials\n      }, function (error, req) {\n        // disposed\n        if (!_this.request) {\n          return;\n        }\n\n        if (error) {\n          return _this.playlistRequestError(_this.request, _this.media().uri, 'HAVE_METADATA');\n        }\n\n        _this.haveMetadata(_this.request, _this.media().uri);\n      });\n    });\n  }\n\n  _createClass(PlaylistLoader, [{\n    key: 'playlistRequestError',\n    value: function playlistRequestError(xhr, url, startingState) {\n      // any in-flight request is now finished\n      this.request = null;\n\n      if (startingState) {\n        this.state = startingState;\n      }\n\n      this.error = {\n        playlist: this.master.playlists[url],\n        status: xhr.status,\n        message: 'HLS playlist request error at URL: ' + url,\n        responseText: xhr.responseText,\n        code: xhr.status >= 500 ? 4 : 2\n      };\n\n      this.trigger('error');\n    }\n\n    // update the playlist loader's state in response to a new or\n    // updated playlist.\n  }, {\n    key: 'haveMetadata',\n    value: function haveMetadata(xhr, url) {\n      var _this2 = this;\n\n      // any in-flight request is now finished\n      this.request = null;\n      this.state = 'HAVE_METADATA';\n\n      var parser = new _m3u8Parser2['default'].Parser();\n\n      parser.push(xhr.responseText);\n      parser.end();\n      parser.manifest.uri = url;\n      // m3u8-parser does not attach an attributes property to media playlists so make\n      // sure that the property is attached to avoid undefined reference errors\n      parser.manifest.attributes = parser.manifest.attributes || {};\n\n      // merge this playlist into the master\n      var update = updateMaster(this.master, parser.manifest);\n\n      this.targetDuration = parser.manifest.targetDuration;\n\n      if (update) {\n        this.master = update;\n        this.media_ = this.master.playlists[parser.manifest.uri];\n      } else {\n        this.trigger('playlistunchanged');\n      }\n\n      // refresh live playlists after a target duration passes\n      if (!this.media().endList) {\n        _globalWindow2['default'].clearTimeout(this.mediaUpdateTimeout);\n        this.mediaUpdateTimeout = _globalWindow2['default'].setTimeout(function () {\n          _this2.trigger('mediaupdatetimeout');\n        }, refreshDelay(this.media(), !!update));\n      }\n\n      this.trigger('loadedplaylist');\n    }\n\n    /**\n     * Abort any outstanding work and clean up.\n     */\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.stopRequest();\n      _globalWindow2['default'].clearTimeout(this.mediaUpdateTimeout);\n    }\n  }, {\n    key: 'stopRequest',\n    value: function stopRequest() {\n      if (this.request) {\n        var oldRequest = this.request;\n\n        this.request = null;\n        oldRequest.onreadystatechange = null;\n        oldRequest.abort();\n      }\n    }\n\n    /**\n     * When called without any arguments, returns the currently\n     * active media playlist. When called with a single argument,\n     * triggers the playlist loader to asynchronously switch to the\n     * specified media playlist. Calling this method while the\n     * loader is in the HAVE_NOTHING causes an error to be emitted\n     * but otherwise has no effect.\n     *\n     * @param {Object=} playlist the parsed media playlist\n     * object to switch to\n     * @return {Playlist} the current loaded media\n     */\n  }, {\n    key: 'media',\n    value: function media(playlist) {\n      var _this3 = this;\n\n      // getter\n      if (!playlist) {\n        return this.media_;\n      }\n\n      // setter\n      if (this.state === 'HAVE_NOTHING') {\n        throw new Error('Cannot switch media playlist from ' + this.state);\n      }\n\n      var startingState = this.state;\n\n      // find the playlist object if the target playlist has been\n      // specified by URI\n      if (typeof playlist === 'string') {\n        if (!this.master.playlists[playlist]) {\n          throw new Error('Unknown playlist URI: ' + playlist);\n        }\n        playlist = this.master.playlists[playlist];\n      }\n\n      var mediaChange = !this.media_ || playlist.uri !== this.media_.uri;\n\n      // switch to fully loaded playlists immediately\n      if (this.master.playlists[playlist.uri].endList) {\n        // abort outstanding playlist requests\n        if (this.request) {\n          this.request.onreadystatechange = null;\n          this.request.abort();\n          this.request = null;\n        }\n        this.state = 'HAVE_METADATA';\n        this.media_ = playlist;\n\n        // trigger media change if the active media has been updated\n        if (mediaChange) {\n          this.trigger('mediachanging');\n          this.trigger('mediachange');\n        }\n        return;\n      }\n\n      // switching to the active playlist is a no-op\n      if (!mediaChange) {\n        return;\n      }\n\n      this.state = 'SWITCHING_MEDIA';\n\n      // there is already an outstanding playlist request\n      if (this.request) {\n        if ((0, _resolveUrl2['default'])(this.master.uri, playlist.uri) === this.request.url) {\n          // requesting to switch to the same playlist multiple times\n          // has no effect after the first\n          return;\n        }\n        this.request.onreadystatechange = null;\n        this.request.abort();\n        this.request = null;\n      }\n\n      // request the new playlist\n      if (this.media_) {\n        this.trigger('mediachanging');\n      }\n\n      this.request = this.hls_.xhr({\n        uri: (0, _resolveUrl2['default'])(this.master.uri, playlist.uri),\n        withCredentials: this.withCredentials\n      }, function (error, req) {\n        // disposed\n        if (!_this3.request) {\n          return;\n        }\n\n        if (error) {\n          return _this3.playlistRequestError(_this3.request, playlist.uri, startingState);\n        }\n\n        _this3.haveMetadata(req, playlist.uri);\n\n        // fire loadedmetadata the first time a media playlist is loaded\n        if (startingState === 'HAVE_MASTER') {\n          _this3.trigger('loadedmetadata');\n        } else {\n          _this3.trigger('mediachange');\n        }\n      });\n    }\n\n    /**\n     * pause loading of the playlist\n     */\n  }, {\n    key: 'pause',\n    value: function pause() {\n      this.stopRequest();\n      _globalWindow2['default'].clearTimeout(this.mediaUpdateTimeout);\n      if (this.state === 'HAVE_NOTHING') {\n        // If we pause the loader before any data has been retrieved, its as if we never\n        // started, so reset to an unstarted state.\n        this.started = false;\n      }\n      // Need to restore state now that no activity is happening\n      if (this.state === 'SWITCHING_MEDIA') {\n        // if the loader was in the process of switching media, it should either return to\n        // HAVE_MASTER or HAVE_METADATA depending on if the loader has loaded a media\n        // playlist yet. This is determined by the existence of loader.media_\n        if (this.media_) {\n          this.state = 'HAVE_METADATA';\n        } else {\n          this.state = 'HAVE_MASTER';\n        }\n      } else if (this.state === 'HAVE_CURRENT_METADATA') {\n        this.state = 'HAVE_METADATA';\n      }\n    }\n\n    /**\n     * start loading of the playlist\n     */\n  }, {\n    key: 'load',\n    value: function load(isFinalRendition) {\n      var _this4 = this;\n\n      _globalWindow2['default'].clearTimeout(this.mediaUpdateTimeout);\n\n      var media = this.media();\n\n      if (isFinalRendition) {\n        var delay = media ? media.targetDuration / 2 * 1000 : 5 * 1000;\n\n        this.mediaUpdateTimeout = _globalWindow2['default'].setTimeout(function () {\n          return _this4.load();\n        }, delay);\n        return;\n      }\n\n      if (!this.started) {\n        this.start();\n        return;\n      }\n\n      if (media && !media.endList) {\n        this.trigger('mediaupdatetimeout');\n      } else {\n        this.trigger('loadedplaylist');\n      }\n    }\n\n    /**\n     * start loading of the playlist\n     */\n  }, {\n    key: 'start',\n    value: function start() {\n      var _this5 = this;\n\n      this.started = true;\n\n      // request the specified URL\n      this.request = this.hls_.xhr({\n        uri: this.srcUrl,\n        withCredentials: this.withCredentials\n      }, function (error, req) {\n        // disposed\n        if (!_this5.request) {\n          return;\n        }\n\n        // clear the loader's request reference\n        _this5.request = null;\n\n        if (error) {\n          _this5.error = {\n            status: req.status,\n            message: 'HLS playlist request error at URL: ' + _this5.srcUrl,\n            responseText: req.responseText,\n            // MEDIA_ERR_NETWORK\n            code: 2\n          };\n          if (_this5.state === 'HAVE_NOTHING') {\n            _this5.started = false;\n          }\n          return _this5.trigger('error');\n        }\n\n        var parser = new _m3u8Parser2['default'].Parser();\n\n        parser.push(req.responseText);\n        parser.end();\n\n        _this5.state = 'HAVE_MASTER';\n\n        parser.manifest.uri = _this5.srcUrl;\n\n        // loaded a master playlist\n        if (parser.manifest.playlists) {\n          _this5.master = parser.manifest;\n\n          setupMediaPlaylists(_this5.master);\n          resolveMediaGroupUris(_this5.master);\n\n          _this5.trigger('loadedplaylist');\n          if (!_this5.request) {\n            // no media playlist was specifically selected so start\n            // from the first listed one\n            _this5.media(parser.manifest.playlists[0]);\n          }\n          return;\n        }\n\n        // loaded a media playlist\n        // infer a master playlist if none was previously requested\n        _this5.master = {\n          mediaGroups: {\n            'AUDIO': {},\n            'VIDEO': {},\n            'CLOSED-CAPTIONS': {},\n            'SUBTITLES': {}\n          },\n          uri: _globalWindow2['default'].location.href,\n          playlists: [{\n            uri: _this5.srcUrl\n          }]\n        };\n        _this5.master.playlists[_this5.srcUrl] = _this5.master.playlists[0];\n        _this5.master.playlists[0].resolvedUri = _this5.srcUrl;\n        // m3u8-parser does not attach an attributes property to media playlists so make\n        // sure that the property is attached to avoid undefined reference errors\n        _this5.master.playlists[0].attributes = _this5.master.playlists[0].attributes || {};\n        _this5.haveMetadata(req, _this5.srcUrl);\n        return _this5.trigger('loadedmetadata');\n      });\n    }\n  }]);\n\n  return PlaylistLoader;\n})(_videoJs.EventTarget);\n\nexports['default'] = PlaylistLoader;\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./resolve-url\":15,\"global/window\":32,\"m3u8-parser\":33}],10:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _playlist = require('./playlist');\n\nvar _playlist2 = _interopRequireDefault(_playlist);\n\nvar _utilCodecsJs = require('./util/codecs.js');\n\n// Utilities\n\n/**\n * Returns the CSS value for the specified property on an element\n * using `getComputedStyle`. Firefox has a long-standing issue where\n * getComputedStyle() may return null when running in an iframe with\n * `display: none`.\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n * @param {HTMLElement} el the htmlelement to work on\n * @param {string} the proprety to get the style for\n */\nvar safeGetComputedStyle = function safeGetComputedStyle(el, property) {\n  var result = undefined;\n\n  if (!el) {\n    return '';\n  }\n\n  result = window.getComputedStyle(el);\n  if (!result) {\n    return '';\n  }\n\n  return result[property];\n};\n\n/**\n * Resuable stable sort function\n *\n * @param {Playlists} array\n * @param {Function} sortFn Different comparators\n * @function stableSort\n */\nvar stableSort = function stableSort(array, sortFn) {\n  var newArray = array.slice();\n\n  array.sort(function (left, right) {\n    var cmp = sortFn(left, right);\n\n    if (cmp === 0) {\n      return newArray.indexOf(left) - newArray.indexOf(right);\n    }\n    return cmp;\n  });\n};\n\n/**\n * A comparator function to sort two playlist object by bandwidth.\n *\n * @param {Object} left a media playlist object\n * @param {Object} right a media playlist object\n * @return {Number} Greater than zero if the bandwidth attribute of\n * left is greater than the corresponding attribute of right. Less\n * than zero if the bandwidth of right is greater than left and\n * exactly zero if the two are equal.\n */\nvar comparePlaylistBandwidth = function comparePlaylistBandwidth(left, right) {\n  var leftBandwidth = undefined;\n  var rightBandwidth = undefined;\n\n  if (left.attributes.BANDWIDTH) {\n    leftBandwidth = left.attributes.BANDWIDTH;\n  }\n  leftBandwidth = leftBandwidth || window.Number.MAX_VALUE;\n  if (right.attributes.BANDWIDTH) {\n    rightBandwidth = right.attributes.BANDWIDTH;\n  }\n  rightBandwidth = rightBandwidth || window.Number.MAX_VALUE;\n\n  return leftBandwidth - rightBandwidth;\n};\n\nexports.comparePlaylistBandwidth = comparePlaylistBandwidth;\n/**\n * A comparator function to sort two playlist object by resolution (width).\n * @param {Object} left a media playlist object\n * @param {Object} right a media playlist object\n * @return {Number} Greater than zero if the resolution.width attribute of\n * left is greater than the corresponding attribute of right. Less\n * than zero if the resolution.width of right is greater than left and\n * exactly zero if the two are equal.\n */\nvar comparePlaylistResolution = function comparePlaylistResolution(left, right) {\n  var leftWidth = undefined;\n  var rightWidth = undefined;\n\n  if (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) {\n    leftWidth = left.attributes.RESOLUTION.width;\n  }\n\n  leftWidth = leftWidth || window.Number.MAX_VALUE;\n\n  if (right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) {\n    rightWidth = right.attributes.RESOLUTION.width;\n  }\n\n  rightWidth = rightWidth || window.Number.MAX_VALUE;\n\n  // NOTE - Fallback to bandwidth sort as appropriate in cases where multiple renditions\n  // have the same media dimensions/ resolution\n  if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) {\n    return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;\n  }\n  return leftWidth - rightWidth;\n};\n\nexports.comparePlaylistResolution = comparePlaylistResolution;\n/**\n * Chooses the appropriate media playlist based on bandwidth and player size\n *\n * @param {Object} master\n *        Object representation of the master manifest\n * @param {Number} playerBandwidth\n *        Current calculated bandwidth of the player\n * @param {Number} playerWidth\n *        Current width of the player element\n * @param {Number} playerHeight\n *        Current height of the player element\n * @return {Playlist} the highest bitrate playlist less than the\n * currently detected bandwidth, accounting for some amount of\n * bandwidth variance\n */\nvar simpleSelector = function simpleSelector(master, playerBandwidth, playerWidth, playerHeight) {\n  // convert the playlists to an intermediary representation to make comparisons easier\n  var sortedPlaylistReps = master.playlists.map(function (playlist) {\n    var width = undefined;\n    var height = undefined;\n    var bandwidth = undefined;\n\n    width = playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;\n    height = playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;\n    bandwidth = playlist.attributes.BANDWIDTH;\n\n    bandwidth = bandwidth || window.Number.MAX_VALUE;\n\n    return {\n      bandwidth: bandwidth,\n      width: width,\n      height: height,\n      playlist: playlist\n    };\n  });\n\n  stableSort(sortedPlaylistReps, function (left, right) {\n    return left.bandwidth - right.bandwidth;\n  });\n\n  // filter out any playlists that have been excluded due to\n  // incompatible configurations\n  sortedPlaylistReps = sortedPlaylistReps.filter(function (rep) {\n    return !_playlist2['default'].isIncompatible(rep.playlist);\n  });\n\n  // filter out any playlists that have been disabled manually through the representations\n  // api or blacklisted temporarily due to playback errors.\n  var enabledPlaylistReps = sortedPlaylistReps.filter(function (rep) {\n    return _playlist2['default'].isEnabled(rep.playlist);\n  });\n\n  if (!enabledPlaylistReps.length) {\n    // if there are no enabled playlists, then they have all been blacklisted or disabled\n    // by the user through the representations api. In this case, ignore blacklisting and\n    // fallback to what the user wants by using playlists the user has not disabled.\n    enabledPlaylistReps = sortedPlaylistReps.filter(function (rep) {\n      return !_playlist2['default'].isDisabled(rep.playlist);\n    });\n  }\n\n  // filter out any variant that has greater effective bitrate\n  // than the current estimated bandwidth\n  var bandwidthPlaylistReps = enabledPlaylistReps.filter(function (rep) {\n    return rep.bandwidth * _config2['default'].BANDWIDTH_VARIANCE < playerBandwidth;\n  });\n\n  var highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1];\n\n  // get all of the renditions with the same (highest) bandwidth\n  // and then taking the very first element\n  var bandwidthBestRep = bandwidthPlaylistReps.filter(function (rep) {\n    return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\n  })[0];\n\n  // filter out playlists without resolution information\n  var haveResolution = bandwidthPlaylistReps.filter(function (rep) {\n    return rep.width && rep.height;\n  });\n\n  // sort variants by resolution\n  stableSort(haveResolution, function (left, right) {\n    return left.width - right.width;\n  });\n\n  // if we have the exact resolution as the player use it\n  var resolutionBestRepList = haveResolution.filter(function (rep) {\n    return rep.width === playerWidth && rep.height === playerHeight;\n  });\n\n  highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1];\n  // ensure that we pick the highest bandwidth variant that have exact resolution\n  var resolutionBestRep = resolutionBestRepList.filter(function (rep) {\n    return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\n  })[0];\n\n  var resolutionPlusOneList = undefined;\n  var resolutionPlusOneSmallest = undefined;\n  var resolutionPlusOneRep = undefined;\n\n  // find the smallest variant that is larger than the player\n  // if there is no match of exact resolution\n  if (!resolutionBestRep) {\n    resolutionPlusOneList = haveResolution.filter(function (rep) {\n      return rep.width > playerWidth || rep.height > playerHeight;\n    });\n\n    // find all the variants have the same smallest resolution\n    resolutionPlusOneSmallest = resolutionPlusOneList.filter(function (rep) {\n      return rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height;\n    });\n\n    // ensure that we also pick the highest bandwidth variant that\n    // is just-larger-than the video player\n    highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];\n    resolutionPlusOneRep = resolutionPlusOneSmallest.filter(function (rep) {\n      return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;\n    })[0];\n  }\n\n  // fallback chain of variants\n  var chosenRep = resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];\n\n  return chosenRep ? chosenRep.playlist : null;\n};\n\nexports.simpleSelector = simpleSelector;\n// Playlist Selectors\n\n/**\n * Chooses the appropriate media playlist based on the most recent\n * bandwidth estimate and the player size.\n *\n * Expects to be called within the context of an instance of HlsHandler\n *\n * @return {Playlist} the highest bitrate playlist less than the\n * currently detected bandwidth, accounting for some amount of\n * bandwidth variance\n */\nvar lastBandwidthSelector = function lastBandwidthSelector() {\n  return simpleSelector(this.playlists.master, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10), parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10));\n};\n\nexports.lastBandwidthSelector = lastBandwidthSelector;\n/**\n * Chooses the appropriate media playlist based on an\n * exponential-weighted moving average of the bandwidth after\n * filtering for player size.\n *\n * Expects to be called within the context of an instance of HlsHandler\n *\n * @param {Number} decay - a number between 0 and 1. Higher values of\n * this parameter will cause previous bandwidth estimates to lose\n * significance more quickly.\n * @return {Function} a function which can be invoked to create a new\n * playlist selector function.\n * @see https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n */\nvar movingAverageBandwidthSelector = function movingAverageBandwidthSelector(decay) {\n  var average = -1;\n\n  if (decay < 0 || decay > 1) {\n    throw new Error('Moving average bandwidth decay must be between 0 and 1.');\n  }\n\n  return function () {\n    if (average < 0) {\n      average = this.systemBandwidth;\n    }\n\n    average = decay * this.systemBandwidth + (1 - decay) * average;\n    return simpleSelector(this.playlists.master, average, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10), parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10));\n  };\n};\n\nexports.movingAverageBandwidthSelector = movingAverageBandwidthSelector;\n/**\n * Chooses the appropriate media playlist based on the potential to rebuffer\n *\n * @param {Object} settings\n *        Object of information required to use this selector\n * @param {Object} settings.master\n *        Object representation of the master manifest\n * @param {Number} settings.currentTime\n *        The current time of the player\n * @param {Number} settings.bandwidth\n *        Current measured bandwidth\n * @param {Number} settings.duration\n *        Duration of the media\n * @param {Number} settings.segmentDuration\n *        Segment duration to be used in round trip time calculations\n * @param {Number} settings.timeUntilRebuffer\n *        Time left in seconds until the player has to rebuffer\n * @param {Number} settings.currentTimeline\n *        The current timeline segments are being loaded from\n * @param {SyncController} settings.syncController\n *        SyncController for determining if we have a sync point for a given playlist\n * @return {Object|null}\n *         {Object} return.playlist\n *         The highest bandwidth playlist with the least amount of rebuffering\n *         {Number} return.rebufferingImpact\n *         The amount of time in seconds switching to this playlist will rebuffer. A\n *         negative value means that switching will cause zero rebuffering.\n */\nvar minRebufferMaxBandwidthSelector = function minRebufferMaxBandwidthSelector(settings) {\n  var master = settings.master;\n  var currentTime = settings.currentTime;\n  var bandwidth = settings.bandwidth;\n  var duration = settings.duration;\n  var segmentDuration = settings.segmentDuration;\n  var timeUntilRebuffer = settings.timeUntilRebuffer;\n  var currentTimeline = settings.currentTimeline;\n  var syncController = settings.syncController;\n\n  // filter out any playlists that have been excluded due to\n  // incompatible configurations\n  var compatiblePlaylists = master.playlists.filter(function (playlist) {\n    return !_playlist2['default'].isIncompatible(playlist);\n  });\n\n  // filter out any playlists that have been disabled manually through the representations\n  // api or blacklisted temporarily due to playback errors.\n  var enabledPlaylists = compatiblePlaylists.filter(_playlist2['default'].isEnabled);\n\n  if (!enabledPlaylists.length) {\n    // if there are no enabled playlists, then they have all been blacklisted or disabled\n    // by the user through the representations api. In this case, ignore blacklisting and\n    // fallback to what the user wants by using playlists the user has not disabled.\n    enabledPlaylists = compatiblePlaylists.filter(function (playlist) {\n      return !_playlist2['default'].isDisabled(playlist);\n    });\n  }\n\n  var bandwidthPlaylists = enabledPlaylists.filter(_playlist2['default'].hasAttribute.bind(null, 'BANDWIDTH'));\n\n  var rebufferingEstimates = bandwidthPlaylists.map(function (playlist) {\n    var syncPoint = syncController.getSyncPoint(playlist, duration, currentTimeline, currentTime);\n    // If there is no sync point for this playlist, switching to it will require a\n    // sync request first. This will double the request time\n    var numRequests = syncPoint ? 1 : 2;\n    var requestTimeEstimate = _playlist2['default'].estimateSegmentRequestTime(segmentDuration, bandwidth, playlist);\n    var rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer;\n\n    return {\n      playlist: playlist,\n      rebufferingImpact: rebufferingImpact\n    };\n  });\n\n  var noRebufferingPlaylists = rebufferingEstimates.filter(function (estimate) {\n    return estimate.rebufferingImpact <= 0;\n  });\n\n  // Sort by bandwidth DESC\n  stableSort(noRebufferingPlaylists, function (a, b) {\n    return comparePlaylistBandwidth(b.playlist, a.playlist);\n  });\n\n  if (noRebufferingPlaylists.length) {\n    return noRebufferingPlaylists[0];\n  }\n\n  stableSort(rebufferingEstimates, function (a, b) {\n    return a.rebufferingImpact - b.rebufferingImpact;\n  });\n\n  return rebufferingEstimates[0] || null;\n};\n\nexports.minRebufferMaxBandwidthSelector = minRebufferMaxBandwidthSelector;\n/**\n * Chooses the appropriate media playlist, which in this case is the lowest bitrate\n * one with video.  If no renditions with video exist, return the lowest audio rendition.\n *\n * Expects to be called within the context of an instance of HlsHandler\n *\n * @return {Object|null}\n *         {Object} return.playlist\n *         The lowest bitrate playlist that contains a video codec.  If no such rendition\n *         exists pick the lowest audio rendition.\n */\nvar lowestBitrateCompatibleVariantSelector = function lowestBitrateCompatibleVariantSelector() {\n  // filter out any playlists that have been excluded due to\n  // incompatible configurations or playback errors\n  var playlists = this.playlists.master.playlists.filter(_playlist2['default'].isEnabled);\n\n  // Sort ascending by bitrate\n  stableSort(playlists, function (a, b) {\n    return comparePlaylistBandwidth(a, b);\n  });\n\n  // Parse and assume that playlists with no video codec have no video\n  // (this is not necessarily true, although it is generally true).\n  //\n  // If an entire manifest has no valid videos everything will get filtered\n  // out.\n  var playlistsWithVideo = playlists.filter(function (playlist) {\n    return (0, _utilCodecsJs.parseCodecs)(playlist.attributes.CODECS).videoCodec;\n  });\n\n  return playlistsWithVideo[0] || null;\n};\nexports.lowestBitrateCompatibleVariantSelector = lowestBitrateCompatibleVariantSelector;\n},{\"./config\":3,\"./playlist\":11,\"./util/codecs.js\":19}],11:[function(require,module,exports){\n(function (global){\n/**\n * @file playlist.js\n *\n * Playlist related utilities.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\n/**\n * walk backward until we find a duration we can use\n * or return a failure\n *\n * @param {Playlist} playlist the playlist to walk through\n * @param {Number} endSequence the mediaSequence to stop walking on\n */\n\nvar backwardDuration = function backwardDuration(playlist, endSequence) {\n  var result = 0;\n  var i = endSequence - playlist.mediaSequence;\n  // if a start time is available for segment immediately following\n  // the interval, use it\n  var segment = playlist.segments[i];\n\n  // Walk backward until we find the latest segment with timeline\n  // information that is earlier than endSequence\n  if (segment) {\n    if (typeof segment.start !== 'undefined') {\n      return { result: segment.start, precise: true };\n    }\n    if (typeof segment.end !== 'undefined') {\n      return {\n        result: segment.end - segment.duration,\n        precise: true\n      };\n    }\n  }\n  while (i--) {\n    segment = playlist.segments[i];\n    if (typeof segment.end !== 'undefined') {\n      return { result: result + segment.end, precise: true };\n    }\n\n    result += segment.duration;\n\n    if (typeof segment.start !== 'undefined') {\n      return { result: result + segment.start, precise: true };\n    }\n  }\n  return { result: result, precise: false };\n};\n\n/**\n * walk forward until we find a duration we can use\n * or return a failure\n *\n * @param {Playlist} playlist the playlist to walk through\n * @param {Number} endSequence the mediaSequence to stop walking on\n */\nvar forwardDuration = function forwardDuration(playlist, endSequence) {\n  var result = 0;\n  var segment = undefined;\n  var i = endSequence - playlist.mediaSequence;\n  // Walk forward until we find the earliest segment with timeline\n  // information\n\n  for (; i < playlist.segments.length; i++) {\n    segment = playlist.segments[i];\n    if (typeof segment.start !== 'undefined') {\n      return {\n        result: segment.start - result,\n        precise: true\n      };\n    }\n\n    result += segment.duration;\n\n    if (typeof segment.end !== 'undefined') {\n      return {\n        result: segment.end - result,\n        precise: true\n      };\n    }\n  }\n  // indicate we didn't find a useful duration estimate\n  return { result: -1, precise: false };\n};\n\n/**\n  * Calculate the media duration from the segments associated with a\n  * playlist. The duration of a subinterval of the available segments\n  * may be calculated by specifying an end index.\n  *\n  * @param {Object} playlist a media playlist object\n  * @param {Number=} endSequence an exclusive upper boundary\n  * for the playlist.  Defaults to playlist length.\n  * @param {Number} expired the amount of time that has dropped\n  * off the front of the playlist in a live scenario\n  * @return {Number} the duration between the first available segment\n  * and end index.\n  */\nvar intervalDuration = function intervalDuration(playlist, endSequence, expired) {\n  var backward = undefined;\n  var forward = undefined;\n\n  if (typeof endSequence === 'undefined') {\n    endSequence = playlist.mediaSequence + playlist.segments.length;\n  }\n\n  if (endSequence < playlist.mediaSequence) {\n    return 0;\n  }\n\n  // do a backward walk to estimate the duration\n  backward = backwardDuration(playlist, endSequence);\n  if (backward.precise) {\n    // if we were able to base our duration estimate on timing\n    // information provided directly from the Media Source, return\n    // it\n    return backward.result;\n  }\n\n  // walk forward to see if a precise duration estimate can be made\n  // that way\n  forward = forwardDuration(playlist, endSequence);\n  if (forward.precise) {\n    // we found a segment that has been buffered and so it's\n    // position is known precisely\n    return forward.result;\n  }\n\n  // return the less-precise, playlist-based duration estimate\n  return backward.result + expired;\n};\n\n/**\n  * Calculates the duration of a playlist. If a start and end index\n  * are specified, the duration will be for the subset of the media\n  * timeline between those two indices. The total duration for live\n  * playlists is always Infinity.\n  *\n  * @param {Object} playlist a media playlist object\n  * @param {Number=} endSequence an exclusive upper\n  * boundary for the playlist. Defaults to the playlist media\n  * sequence number plus its length.\n  * @param {Number=} expired the amount of time that has\n  * dropped off the front of the playlist in a live scenario\n  * @return {Number} the duration between the start index and end\n  * index.\n  */\nvar duration = function duration(playlist, endSequence, expired) {\n  if (!playlist) {\n    return 0;\n  }\n\n  if (typeof expired !== 'number') {\n    expired = 0;\n  }\n\n  // if a slice of the total duration is not requested, use\n  // playlist-level duration indicators when they're present\n  if (typeof endSequence === 'undefined') {\n    // if present, use the duration specified in the playlist\n    if (playlist.totalDuration) {\n      return playlist.totalDuration;\n    }\n\n    // duration should be Infinity for live playlists\n    if (!playlist.endList) {\n      return _globalWindow2['default'].Infinity;\n    }\n  }\n\n  // calculate the total duration based on the segment durations\n  return intervalDuration(playlist, endSequence, expired);\n};\n\nexports.duration = duration;\n/**\n  * Calculate the time between two indexes in the current playlist\n  * neight the start- nor the end-index need to be within the current\n  * playlist in which case, the targetDuration of the playlist is used\n  * to approximate the durations of the segments\n  *\n  * @param {Object} playlist a media playlist object\n  * @param {Number} startIndex\n  * @param {Number} endIndex\n  * @return {Number} the number of seconds between startIndex and endIndex\n  */\nvar sumDurations = function sumDurations(playlist, startIndex, endIndex) {\n  var durations = 0;\n\n  if (startIndex > endIndex) {\n    var _ref = [endIndex, startIndex];\n    startIndex = _ref[0];\n    endIndex = _ref[1];\n  }\n\n  if (startIndex < 0) {\n    for (var i = startIndex; i < Math.min(0, endIndex); i++) {\n      durations += playlist.targetDuration;\n    }\n    startIndex = 0;\n  }\n\n  for (var i = startIndex; i < endIndex; i++) {\n    durations += playlist.segments[i].duration;\n  }\n\n  return durations;\n};\n\nexports.sumDurations = sumDurations;\n/**\n * Determines the media index of the segment corresponding to the safe edge of the live\n * window which is the duration of the last segment plus 2 target durations from the end\n * of the playlist.\n *\n * @param {Object} playlist\n *        a media playlist object\n * @return {Number}\n *         The media index of the segment at the safe live point. 0 if there is no \"safe\"\n *         point.\n * @function safeLiveIndex\n */\nvar safeLiveIndex = function safeLiveIndex(playlist) {\n  if (!playlist.segments.length) {\n    return 0;\n  }\n\n  var i = playlist.segments.length - 1;\n  var distanceFromEnd = playlist.segments[i].duration || playlist.targetDuration;\n  var safeDistance = distanceFromEnd + playlist.targetDuration * 2;\n\n  while (i--) {\n    distanceFromEnd += playlist.segments[i].duration;\n\n    if (distanceFromEnd >= safeDistance) {\n      break;\n    }\n  }\n\n  return Math.max(0, i);\n};\n\nexports.safeLiveIndex = safeLiveIndex;\n/**\n * Calculates the playlist end time\n *\n * @param {Object} playlist a media playlist object\n * @param {Number=} expired the amount of time that has\n *                  dropped off the front of the playlist in a live scenario\n * @param {Boolean|false} useSafeLiveEnd a boolean value indicating whether or not the\n *                        playlist end calculation should consider the safe live end\n *                        (truncate the playlist end by three segments). This is normally\n *                        used for calculating the end of the playlist's seekable range.\n * @returns {Number} the end time of playlist\n * @function playlistEnd\n */\nvar playlistEnd = function playlistEnd(playlist, expired, useSafeLiveEnd) {\n  if (!playlist || !playlist.segments) {\n    return null;\n  }\n  if (playlist.endList) {\n    return duration(playlist);\n  }\n\n  if (expired === null) {\n    return null;\n  }\n\n  expired = expired || 0;\n\n  var endSequence = useSafeLiveEnd ? safeLiveIndex(playlist) : playlist.segments.length;\n\n  return intervalDuration(playlist, playlist.mediaSequence + endSequence, expired);\n};\n\nexports.playlistEnd = playlistEnd;\n/**\n  * Calculates the interval of time that is currently seekable in a\n  * playlist. The returned time ranges are relative to the earliest\n  * moment in the specified playlist that is still available. A full\n  * seekable implementation for live streams would need to offset\n  * these values by the duration of content that has expired from the\n  * stream.\n  *\n  * @param {Object} playlist a media playlist object\n  * dropped off the front of the playlist in a live scenario\n  * @param {Number=} expired the amount of time that has\n  * dropped off the front of the playlist in a live scenario\n  * @return {TimeRanges} the periods of time that are valid targets\n  * for seeking\n  */\nvar seekable = function seekable(playlist, expired) {\n  var useSafeLiveEnd = true;\n  var seekableStart = expired || 0;\n  var seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd);\n\n  if (seekableEnd === null) {\n    return (0, _videoJs.createTimeRange)();\n  }\n  return (0, _videoJs.createTimeRange)(seekableStart, seekableEnd);\n};\n\nexports.seekable = seekable;\nvar isWholeNumber = function isWholeNumber(num) {\n  return num - Math.floor(num) === 0;\n};\n\nvar roundSignificantDigit = function roundSignificantDigit(increment, num) {\n  // If we have a whole number, just add 1 to it\n  if (isWholeNumber(num)) {\n    return num + increment * 0.1;\n  }\n\n  var numDecimalDigits = num.toString().split('.')[1].length;\n\n  for (var i = 1; i <= numDecimalDigits; i++) {\n    var scale = Math.pow(10, i);\n    var temp = num * scale;\n\n    if (isWholeNumber(temp) || i === numDecimalDigits) {\n      return (temp + increment) / scale;\n    }\n  }\n};\n\nvar ceilLeastSignificantDigit = roundSignificantDigit.bind(null, 1);\nvar floorLeastSignificantDigit = roundSignificantDigit.bind(null, -1);\n\n/**\n * Determine the index and estimated starting time of the segment that\n * contains a specified playback position in a media playlist.\n *\n * @param {Object} playlist the media playlist to query\n * @param {Number} currentTime The number of seconds since the earliest\n * possible position to determine the containing segment for\n * @param {Number} startIndex\n * @param {Number} startTime\n * @return {Object}\n */\nvar getMediaInfoForTime = function getMediaInfoForTime(playlist, currentTime, startIndex, startTime) {\n  var i = undefined;\n  var segment = undefined;\n  var numSegments = playlist.segments.length;\n\n  var time = currentTime - startTime;\n\n  if (time < 0) {\n    // Walk backward from startIndex in the playlist, adding durations\n    // until we find a segment that contains `time` and return it\n    if (startIndex > 0) {\n      for (i = startIndex - 1; i >= 0; i--) {\n        segment = playlist.segments[i];\n        time += floorLeastSignificantDigit(segment.duration);\n        if (time > 0) {\n          return {\n            mediaIndex: i,\n            startTime: startTime - sumDurations(playlist, startIndex, i)\n          };\n        }\n      }\n    }\n    // We were unable to find a good segment within the playlist\n    // so select the first segment\n    return {\n      mediaIndex: 0,\n      startTime: currentTime\n    };\n  }\n\n  // When startIndex is negative, we first walk forward to first segment\n  // adding target durations. If we \"run out of time\" before getting to\n  // the first segment, return the first segment\n  if (startIndex < 0) {\n    for (i = startIndex; i < 0; i++) {\n      time -= playlist.targetDuration;\n      if (time < 0) {\n        return {\n          mediaIndex: 0,\n          startTime: currentTime\n        };\n      }\n    }\n    startIndex = 0;\n  }\n\n  // Walk forward from startIndex in the playlist, subtracting durations\n  // until we find a segment that contains `time` and return it\n  for (i = startIndex; i < numSegments; i++) {\n    segment = playlist.segments[i];\n    time -= ceilLeastSignificantDigit(segment.duration);\n    if (time < 0) {\n      return {\n        mediaIndex: i,\n        startTime: startTime + sumDurations(playlist, startIndex, i)\n      };\n    }\n  }\n\n  // We are out of possible candidates so load the last one...\n  return {\n    mediaIndex: numSegments - 1,\n    startTime: currentTime\n  };\n};\n\nexports.getMediaInfoForTime = getMediaInfoForTime;\n/**\n * Check whether the playlist is blacklisted or not.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is blacklisted or not\n * @function isBlacklisted\n */\nvar isBlacklisted = function isBlacklisted(playlist) {\n  return playlist.excludeUntil && playlist.excludeUntil > Date.now();\n};\n\nexports.isBlacklisted = isBlacklisted;\n/**\n * Check whether the playlist is compatible with current playback configuration or has\n * been blacklisted permanently for being incompatible.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is incompatible or not\n * @function isIncompatible\n */\nvar isIncompatible = function isIncompatible(playlist) {\n  return playlist.excludeUntil && playlist.excludeUntil === Infinity;\n};\n\nexports.isIncompatible = isIncompatible;\n/**\n * Check whether the playlist is enabled or not.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is enabled or not\n * @function isEnabled\n */\nvar isEnabled = function isEnabled(playlist) {\n  var blacklisted = isBlacklisted(playlist);\n\n  return !playlist.disabled && !blacklisted;\n};\n\nexports.isEnabled = isEnabled;\n/**\n * Check whether the playlist has been manually disabled through the representations api.\n *\n * @param {Object} playlist the media playlist object\n * @return {boolean} whether the playlist is disabled manually or not\n * @function isDisabled\n */\nvar isDisabled = function isDisabled(playlist) {\n  return playlist.disabled;\n};\n\nexports.isDisabled = isDisabled;\n/**\n * Returns whether the current playlist is an AES encrypted HLS stream\n *\n * @return {Boolean} true if it's an AES encrypted HLS stream\n */\nvar isAes = function isAes(media) {\n  for (var i = 0; i < media.segments.length; i++) {\n    if (media.segments[i].key) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexports.isAes = isAes;\n/**\n * Returns whether the current playlist contains fMP4\n *\n * @return {Boolean} true if the playlist contains fMP4\n */\nvar isFmp4 = function isFmp4(media) {\n  for (var i = 0; i < media.segments.length; i++) {\n    if (media.segments[i].map) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexports.isFmp4 = isFmp4;\n/**\n * Checks if the playlist has a value for the specified attribute\n *\n * @param {String} attr\n *        Attribute to check for\n * @param {Object} playlist\n *        The media playlist object\n * @return {Boolean}\n *         Whether the playlist contains a value for the attribute or not\n * @function hasAttribute\n */\nvar hasAttribute = function hasAttribute(attr, playlist) {\n  return playlist.attributes && playlist.attributes[attr];\n};\n\nexports.hasAttribute = hasAttribute;\n/**\n * Estimates the time required to complete a segment download from the specified playlist\n *\n * @param {Number} segmentDuration\n *        Duration of requested segment\n * @param {Number} bandwidth\n *        Current measured bandwidth of the player\n * @param {Object} playlist\n *        The media playlist object\n * @param {Number=} bytesReceived\n *        Number of bytes already received for the request. Defaults to 0\n * @return {Number|NaN}\n *         The estimated time to request the segment. NaN if bandwidth information for\n *         the given playlist is unavailable\n * @function estimateSegmentRequestTime\n */\nvar estimateSegmentRequestTime = function estimateSegmentRequestTime(segmentDuration, bandwidth, playlist) {\n  var bytesReceived = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];\n\n  if (!hasAttribute('BANDWIDTH', playlist)) {\n    return NaN;\n  }\n\n  var size = segmentDuration * playlist.attributes.BANDWIDTH;\n\n  return (size - bytesReceived * 8) / bandwidth;\n};\n\nexports.estimateSegmentRequestTime = estimateSegmentRequestTime;\n/*\n * Returns whether the current playlist is the lowest rendition\n *\n * @return {Boolean} true if on lowest rendition\n */\nvar isLowestEnabledRendition = function isLowestEnabledRendition(master, media) {\n  if (master.playlists.length === 1) {\n    return true;\n  }\n\n  var currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;\n\n  return master.playlists.filter(function (playlist) {\n    if (!isEnabled(playlist)) {\n      return false;\n    }\n\n    return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;\n  }).length === 0;\n};\n\nexports.isLowestEnabledRendition = isLowestEnabledRendition;\n// exports\nexports['default'] = {\n  duration: duration,\n  seekable: seekable,\n  safeLiveIndex: safeLiveIndex,\n  getMediaInfoForTime: getMediaInfoForTime,\n  isEnabled: isEnabled,\n  isDisabled: isDisabled,\n  isBlacklisted: isBlacklisted,\n  isIncompatible: isIncompatible,\n  playlistEnd: playlistEnd,\n  isAes: isAes,\n  isFmp4: isFmp4,\n  hasAttribute: hasAttribute,\n  estimateSegmentRequestTime: estimateSegmentRequestTime,\n  isLowestEnabledRendition: isLowestEnabledRendition\n};\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"global/window\":32}],12:[function(require,module,exports){\n(function (global){\n/**\n * ranges\n *\n * Utilities for working with TimeRanges.\n *\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\n// Fudge factor to account for TimeRanges rounding\nvar TIME_FUDGE_FACTOR = 1 / 30;\n// Comparisons between time values such as current time and the end of the buffered range\n// can be misleading because of precision differences or when the current media has poorly\n// aligned audio and video, which can cause values to be slightly off from what you would\n// expect. This value is what we consider to be safe to use in such comparisons to account\n// for these scenarios.\nvar SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;\n\n/**\n * Clamps a value to within a range\n * @param {Number} num - the value to clamp\n * @param {Number} start - the start of the range to clamp within, inclusive\n * @param {Number} end - the end of the range to clamp within, inclusive\n * @return {Number}\n */\nvar clamp = function clamp(num, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2);\n\n  var start = _ref2[0];\n  var end = _ref2[1];\n\n  return Math.min(Math.max(start, num), end);\n};\nvar filterRanges = function filterRanges(timeRanges, predicate) {\n  var results = [];\n  var i = undefined;\n\n  if (timeRanges && timeRanges.length) {\n    // Search for ranges that match the predicate\n    for (i = 0; i < timeRanges.length; i++) {\n      if (predicate(timeRanges.start(i), timeRanges.end(i))) {\n        results.push([timeRanges.start(i), timeRanges.end(i)]);\n      }\n    }\n  }\n\n  return _videoJs2['default'].createTimeRanges(results);\n};\n\n/**\n * Attempts to find the buffered TimeRange that contains the specified\n * time.\n * @param {TimeRanges} buffered - the TimeRanges object to query\n * @param {number} time  - the time to filter on.\n * @returns {TimeRanges} a new TimeRanges object\n */\nvar findRange = function findRange(buffered, time) {\n  return filterRanges(buffered, function (start, end) {\n    return start - TIME_FUDGE_FACTOR <= time && end + TIME_FUDGE_FACTOR >= time;\n  });\n};\n\n/**\n * Returns the TimeRanges that begin later than the specified time.\n * @param {TimeRanges} timeRanges - the TimeRanges object to query\n * @param {number} time - the time to filter on.\n * @returns {TimeRanges} a new TimeRanges object.\n */\nvar findNextRange = function findNextRange(timeRanges, time) {\n  return filterRanges(timeRanges, function (start) {\n    return start - TIME_FUDGE_FACTOR >= time;\n  });\n};\n\n/**\n * Returns gaps within a list of TimeRanges\n * @param {TimeRanges} buffered - the TimeRanges object\n * @return {TimeRanges} a TimeRanges object of gaps\n */\nvar findGaps = function findGaps(buffered) {\n  if (buffered.length < 2) {\n    return _videoJs2['default'].createTimeRanges();\n  }\n\n  var ranges = [];\n\n  for (var i = 1; i < buffered.length; i++) {\n    var start = buffered.end(i - 1);\n    var end = buffered.start(i);\n\n    ranges.push([start, end]);\n  }\n\n  return _videoJs2['default'].createTimeRanges(ranges);\n};\n\n/**\n * Search for a likely end time for the segment that was just appened\n * based on the state of the `buffered` property before and after the\n * append. If we fin only one such uncommon end-point return it.\n * @param {TimeRanges} original - the buffered time ranges before the update\n * @param {TimeRanges} update - the buffered time ranges after the update\n * @returns {Number|null} the end time added between `original` and `update`,\n * or null if one cannot be unambiguously determined.\n */\nvar findSoleUncommonTimeRangesEnd = function findSoleUncommonTimeRangesEnd(original, update) {\n  var i = undefined;\n  var start = undefined;\n  var end = undefined;\n  var result = [];\n  var edges = [];\n\n  // In order to qualify as a possible candidate, the end point must:\n  //  1) Not have already existed in the `original` ranges\n  //  2) Not result from the shrinking of a range that already existed\n  //     in the `original` ranges\n  //  3) Not be contained inside of a range that existed in `original`\n  var overlapsCurrentEnd = function overlapsCurrentEnd(span) {\n    return span[0] <= end && span[1] >= end;\n  };\n\n  if (original) {\n    // Save all the edges in the `original` TimeRanges object\n    for (i = 0; i < original.length; i++) {\n      start = original.start(i);\n      end = original.end(i);\n\n      edges.push([start, end]);\n    }\n  }\n\n  if (update) {\n    // Save any end-points in `update` that are not in the `original`\n    // TimeRanges object\n    for (i = 0; i < update.length; i++) {\n      start = update.start(i);\n      end = update.end(i);\n\n      if (edges.some(overlapsCurrentEnd)) {\n        continue;\n      }\n\n      // at this point it must be a unique non-shrinking end edge\n      result.push(end);\n    }\n  }\n\n  // we err on the side of caution and return null if didn't find\n  // exactly *one* differing end edge in the search above\n  if (result.length !== 1) {\n    return null;\n  }\n\n  return result[0];\n};\n\n/**\n * Calculate the intersection of two TimeRanges\n * @param {TimeRanges} bufferA\n * @param {TimeRanges} bufferB\n * @returns {TimeRanges} The interesection of `bufferA` with `bufferB`\n */\nvar bufferIntersection = function bufferIntersection(bufferA, bufferB) {\n  var start = null;\n  var end = null;\n  var arity = 0;\n  var extents = [];\n  var ranges = [];\n\n  if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {\n    return _videoJs2['default'].createTimeRange();\n  }\n\n  // Handle the case where we have both buffers and create an\n  // intersection of the two\n  var count = bufferA.length;\n\n  // A) Gather up all start and end times\n  while (count--) {\n    extents.push({ time: bufferA.start(count), type: 'start' });\n    extents.push({ time: bufferA.end(count), type: 'end' });\n  }\n  count = bufferB.length;\n  while (count--) {\n    extents.push({ time: bufferB.start(count), type: 'start' });\n    extents.push({ time: bufferB.end(count), type: 'end' });\n  }\n  // B) Sort them by time\n  extents.sort(function (a, b) {\n    return a.time - b.time;\n  });\n\n  // C) Go along one by one incrementing arity for start and decrementing\n  //    arity for ends\n  for (count = 0; count < extents.length; count++) {\n    if (extents[count].type === 'start') {\n      arity++;\n\n      // D) If arity is ever incremented to 2 we are entering an\n      //    overlapping range\n      if (arity === 2) {\n        start = extents[count].time;\n      }\n    } else if (extents[count].type === 'end') {\n      arity--;\n\n      // E) If arity is ever decremented to 1 we leaving an\n      //    overlapping range\n      if (arity === 1) {\n        end = extents[count].time;\n      }\n    }\n\n    // F) Record overlapping ranges\n    if (start !== null && end !== null) {\n      ranges.push([start, end]);\n      start = null;\n      end = null;\n    }\n  }\n\n  return _videoJs2['default'].createTimeRanges(ranges);\n};\n\n/**\n * Calculates the percentage of `segmentRange` that overlaps the\n * `buffered` time ranges.\n * @param {TimeRanges} segmentRange - the time range that the segment\n * covers adjusted according to currentTime\n * @param {TimeRanges} referenceRange - the original time range that the\n * segment covers\n * @param {Number} currentTime - time in seconds where the current playback\n * is at\n * @param {TimeRanges} buffered - the currently buffered time ranges\n * @returns {Number} percent of the segment currently buffered\n */\nvar calculateBufferedPercent = function calculateBufferedPercent(adjustedRange, referenceRange, currentTime, buffered) {\n  var referenceDuration = referenceRange.end(0) - referenceRange.start(0);\n  var adjustedDuration = adjustedRange.end(0) - adjustedRange.start(0);\n  var bufferMissingFromAdjusted = referenceDuration - adjustedDuration;\n  var adjustedIntersection = bufferIntersection(adjustedRange, buffered);\n  var referenceIntersection = bufferIntersection(referenceRange, buffered);\n  var adjustedOverlap = 0;\n  var referenceOverlap = 0;\n\n  var count = adjustedIntersection.length;\n\n  while (count--) {\n    adjustedOverlap += adjustedIntersection.end(count) - adjustedIntersection.start(count);\n\n    // If the current overlap segment starts at currentTime, then increase the\n    // overlap duration so that it actually starts at the beginning of referenceRange\n    // by including the difference between the two Range's durations\n    // This is a work around for the way Flash has no buffer before currentTime\n    if (adjustedIntersection.start(count) === currentTime) {\n      adjustedOverlap += bufferMissingFromAdjusted;\n    }\n  }\n\n  count = referenceIntersection.length;\n\n  while (count--) {\n    referenceOverlap += referenceIntersection.end(count) - referenceIntersection.start(count);\n  }\n\n  // Use whichever value is larger for the percentage-buffered since that value\n  // is likely more accurate because the only way\n  return Math.max(adjustedOverlap, referenceOverlap) / referenceDuration * 100;\n};\n\n/**\n * Return the amount of a range specified by the startOfSegment and segmentDuration\n * overlaps the current buffered content.\n *\n * @param {Number} startOfSegment - the time where the segment begins\n * @param {Number} segmentDuration - the duration of the segment in seconds\n * @param {Number} currentTime - time in seconds where the current playback\n * is at\n * @param {TimeRanges} buffered - the state of the buffer\n * @returns {Number} percentage of the segment's time range that is\n * already in `buffered`\n */\nvar getSegmentBufferedPercent = function getSegmentBufferedPercent(startOfSegment, segmentDuration, currentTime, buffered) {\n  var endOfSegment = startOfSegment + segmentDuration;\n\n  // The entire time range of the segment\n  var originalSegmentRange = _videoJs2['default'].createTimeRanges([[startOfSegment, endOfSegment]]);\n\n  // The adjusted segment time range that is setup such that it starts\n  // no earlier than currentTime\n  // Flash has no notion of a back-buffer so adjustedSegmentRange adjusts\n  // for that and the function will still return 100% if a only half of a\n  // segment is actually in the buffer as long as the currentTime is also\n  // half-way through the segment\n  var adjustedSegmentRange = _videoJs2['default'].createTimeRanges([[clamp(startOfSegment, [currentTime, endOfSegment]), endOfSegment]]);\n\n  // This condition happens when the currentTime is beyond the segment's\n  // end time\n  if (adjustedSegmentRange.start(0) === adjustedSegmentRange.end(0)) {\n    return 0;\n  }\n\n  var percent = calculateBufferedPercent(adjustedSegmentRange, originalSegmentRange, currentTime, buffered);\n\n  // If the segment is reported as having a zero duration, return 0%\n  // since it is likely that we will need to fetch the segment\n  if (isNaN(percent) || percent === Infinity || percent === -Infinity) {\n    return 0;\n  }\n\n  return percent;\n};\n\n/**\n * Gets a human readable string for a TimeRange\n *\n * @param {TimeRange} range\n * @returns {String} a human readable string\n */\nvar printableRange = function printableRange(range) {\n  var strArr = [];\n\n  if (!range || !range.length) {\n    return '';\n  }\n\n  for (var i = 0; i < range.length; i++) {\n    strArr.push(range.start(i) + ' => ' + range.end(i));\n  }\n\n  return strArr.join(', ');\n};\n\n/**\n * Calculates the amount of time left in seconds until the player hits the end of the\n * buffer and causes a rebuffer\n *\n * @param {TimeRange} buffered\n *        The state of the buffer\n * @param {Numnber} currentTime\n *        The current time of the player\n * @param {Number} playbackRate\n *        The current playback rate of the player. Defaults to 1.\n * @return {Number}\n *         Time until the player has to start rebuffering in seconds.\n * @function timeUntilRebuffer\n */\nvar timeUntilRebuffer = function timeUntilRebuffer(buffered, currentTime) {\n  var playbackRate = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];\n\n  var bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;\n\n  return (bufferedEnd - currentTime) / playbackRate;\n};\n\nexports['default'] = {\n  findRange: findRange,\n  findNextRange: findNextRange,\n  findGaps: findGaps,\n  findSoleUncommonTimeRangesEnd: findSoleUncommonTimeRangesEnd,\n  getSegmentBufferedPercent: getSegmentBufferedPercent,\n  TIME_FUDGE_FACTOR: TIME_FUDGE_FACTOR,\n  SAFE_TIME_DELTA: SAFE_TIME_DELTA,\n  printableRange: printableRange,\n  timeUntilRebuffer: timeUntilRebuffer\n};\nmodule.exports = exports['default'];\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],13:[function(require,module,exports){\n(function (global){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar defaultOptions = {\n  errorInterval: 30,\n  getSource: function getSource(next) {\n    var tech = this.tech({ IWillNotUseThisInPlugins: true });\n    var sourceObj = tech.currentSource_;\n\n    return next(sourceObj);\n  }\n};\n\n/**\n * Main entry point for the plugin\n *\n * @param {Player} player a reference to a videojs Player instance\n * @param {Object} [options] an object with plugin options\n * @private\n */\nvar initPlugin = function initPlugin(player, options) {\n  var lastCalled = 0;\n  var seekTo = 0;\n  var localOptions = _videoJs2['default'].mergeOptions(defaultOptions, options);\n\n  player.ready(function () {\n    player.trigger({ type: 'usage', name: 'hls-error-reload-initialized' });\n  });\n\n  /**\n   * Player modifications to perform that must wait until `loadedmetadata`\n   * has been triggered\n   *\n   * @private\n   */\n  var loadedMetadataHandler = function loadedMetadataHandler() {\n    if (seekTo) {\n      player.currentTime(seekTo);\n    }\n  };\n\n  /**\n   * Set the source on the player element, play, and seek if necessary\n   *\n   * @param {Object} sourceObj An object specifying the source url and mime-type to play\n   * @private\n   */\n  var setSource = function setSource(sourceObj) {\n    if (sourceObj === null || sourceObj === undefined) {\n      return;\n    }\n    seekTo = player.duration() !== Infinity && player.currentTime() || 0;\n\n    player.one('loadedmetadata', loadedMetadataHandler);\n\n    player.src(sourceObj);\n    player.trigger({ type: 'usage', name: 'hls-error-reload' });\n    player.play();\n  };\n\n  /**\n   * Attempt to get a source from either the built-in getSource function\n   * or a custom function provided via the options\n   *\n   * @private\n   */\n  var errorHandler = function errorHandler() {\n    // Do not attempt to reload the source if a source-reload occurred before\n    // 'errorInterval' time has elapsed since the last source-reload\n    if (Date.now() - lastCalled < localOptions.errorInterval * 1000) {\n      player.trigger({ type: 'usage', name: 'hls-error-reload-canceled' });\n      return;\n    }\n\n    if (!localOptions.getSource || typeof localOptions.getSource !== 'function') {\n      _videoJs2['default'].log.error('ERROR: reloadSourceOnError - The option getSource must be a function!');\n      return;\n    }\n    lastCalled = Date.now();\n\n    return localOptions.getSource.call(player, setSource);\n  };\n\n  /**\n   * Unbind any event handlers that were bound by the plugin\n   *\n   * @private\n   */\n  var cleanupEvents = function cleanupEvents() {\n    player.off('loadedmetadata', loadedMetadataHandler);\n    player.off('error', errorHandler);\n    player.off('dispose', cleanupEvents);\n  };\n\n  /**\n   * Cleanup before re-initializing the plugin\n   *\n   * @param {Object} [newOptions] an object with plugin options\n   * @private\n   */\n  var reinitPlugin = function reinitPlugin(newOptions) {\n    cleanupEvents();\n    initPlugin(player, newOptions);\n  };\n\n  player.on('error', errorHandler);\n  player.on('dispose', cleanupEvents);\n\n  // Overwrite the plugin function so that we can correctly cleanup before\n  // initializing the plugin\n  player.reloadSourceOnError = reinitPlugin;\n};\n\n/**\n * Reload the source when an error is detected as long as there\n * wasn't an error previously within the last 30 seconds\n *\n * @param {Object} [options] an object with plugin options\n */\nvar reloadSourceOnError = function reloadSourceOnError(options) {\n  initPlugin(this, options);\n};\n\nexports['default'] = reloadSourceOnError;\nmodule.exports = exports['default'];\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],14:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _playlistJs = require('./playlist.js');\n\n/**\n * Returns a function that acts as the Enable/disable playlist function.\n *\n * @param {PlaylistLoader} loader - The master playlist loader\n * @param {String} playlistUri - uri of the playlist\n * @param {Function} changePlaylistFn - A function to be called after a\n * playlist's enabled-state has been changed. Will NOT be called if a\n * playlist's enabled-state is unchanged\n * @param {Boolean=} enable - Value to set the playlist enabled-state to\n * or if undefined returns the current enabled-state for the playlist\n * @return {Function} Function for setting/getting enabled\n */\nvar enableFunction = function enableFunction(loader, playlistUri, changePlaylistFn) {\n  return function (enable) {\n    var playlist = loader.master.playlists[playlistUri];\n    var incompatible = (0, _playlistJs.isIncompatible)(playlist);\n    var currentlyEnabled = (0, _playlistJs.isEnabled)(playlist);\n\n    if (typeof enable === 'undefined') {\n      return currentlyEnabled;\n    }\n\n    if (enable) {\n      delete playlist.disabled;\n    } else {\n      playlist.disabled = true;\n    }\n\n    if (enable !== currentlyEnabled && !incompatible) {\n      // Ensure the outside world knows about our changes\n      changePlaylistFn();\n      if (enable) {\n        loader.trigger('renditionenabled');\n      } else {\n        loader.trigger('renditiondisabled');\n      }\n    }\n    return enable;\n  };\n};\n\n/**\n * The representation object encapsulates the publicly visible information\n * in a media playlist along with a setter/getter-type function (enabled)\n * for changing the enabled-state of a particular playlist entry\n *\n * @class Representation\n */\n\nvar Representation = function Representation(hlsHandler, playlist, id) {\n  _classCallCheck(this, Representation);\n\n  // Get a reference to a bound version of fastQualityChange_\n  var fastChangeFunction = hlsHandler.masterPlaylistController_.fastQualityChange_.bind(hlsHandler.masterPlaylistController_);\n\n  // some playlist attributes are optional\n  if (playlist.attributes.RESOLUTION) {\n    var resolution = playlist.attributes.RESOLUTION;\n\n    this.width = resolution.width;\n    this.height = resolution.height;\n  }\n\n  this.bandwidth = playlist.attributes.BANDWIDTH;\n\n  // The id is simply the ordinality of the media playlist\n  // within the master playlist\n  this.id = id;\n\n  // Partially-apply the enableFunction to create a playlist-\n  // specific variant\n  this.enabled = enableFunction(hlsHandler.playlists, playlist.uri, fastChangeFunction);\n}\n\n/**\n * A mixin function that adds the `representations` api to an instance\n * of the HlsHandler class\n * @param {HlsHandler} hlsHandler - An instance of HlsHandler to add the\n * representation API into\n */\n;\n\nvar renditionSelectionMixin = function renditionSelectionMixin(hlsHandler) {\n  var playlists = hlsHandler.playlists;\n\n  // Add a single API-specific function to the HlsHandler instance\n  hlsHandler.representations = function () {\n    return playlists.master.playlists.filter(function (media) {\n      return !(0, _playlistJs.isIncompatible)(media);\n    }).map(function (e, i) {\n      return new Representation(hlsHandler, e, e.uri);\n    });\n  };\n};\n\nexports['default'] = renditionSelectionMixin;\nmodule.exports = exports['default'];\n},{\"./playlist.js\":11}],15:[function(require,module,exports){\n/**\n * @file resolve-url.js\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _urlToolkit = require('url-toolkit');\n\nvar _urlToolkit2 = _interopRequireDefault(_urlToolkit);\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar resolveUrl = function resolveUrl(baseURL, relativeURL) {\n  // return early if we don't need to resolve\n  if (/^[a-z]+:/i.test(relativeURL)) {\n    return relativeURL;\n  }\n\n  // if the base URL is relative then combine with the current location\n  if (!/\\/\\//i.test(baseURL)) {\n    baseURL = _urlToolkit2['default'].buildAbsoluteURL(_globalWindow2['default'].location.href, baseURL);\n  }\n\n  return _urlToolkit2['default'].buildAbsoluteURL(baseURL, relativeURL);\n};\n\nexports['default'] = resolveUrl;\nmodule.exports = exports['default'];\n},{\"global/window\":32,\"url-toolkit\":63}],16:[function(require,module,exports){\n(function (global){\n/**\n * @file segment-loader.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x4, _x5, _x6) { var _again = true; _function: while (_again) { var object = _x4, property = _x5, receiver = _x6; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x4 = parent; _x5 = property; _x6 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _playlist = require('./playlist');\n\nvar _playlist2 = _interopRequireDefault(_playlist);\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _sourceUpdater = require('./source-updater');\n\nvar _sourceUpdater2 = _interopRequireDefault(_sourceUpdater);\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs = require('videojs-contrib-media-sources/es5/remove-cues-from-track.js');\n\nvar _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2 = _interopRequireDefault(_videojsContribMediaSourcesEs5RemoveCuesFromTrackJs);\n\nvar _binUtils = require('./bin-utils');\n\nvar _mediaSegmentRequest = require('./media-segment-request');\n\nvar _ranges = require('./ranges');\n\nvar _playlistSelectors = require('./playlist-selectors');\n\n// in ms\nvar CHECK_BUFFER_DELAY = 500;\n\n/**\n * Determines if we should call endOfStream on the media source based\n * on the state of the buffer or if appened segment was the final\n * segment in the playlist.\n *\n * @param {Object} playlist a media playlist object\n * @param {Object} mediaSource the MediaSource object\n * @param {Number} segmentIndex the index of segment we last appended\n * @returns {Boolean} do we need to call endOfStream on the MediaSource\n */\nvar detectEndOfStream = function detectEndOfStream(playlist, mediaSource, segmentIndex) {\n  if (!playlist || !mediaSource) {\n    return false;\n  }\n\n  var segments = playlist.segments;\n\n  // determine a few boolean values to help make the branch below easier\n  // to read\n  var appendedLastSegment = segmentIndex === segments.length;\n\n  // if we've buffered to the end of the video, we need to call endOfStream\n  // so that MediaSources can trigger the `ended` event when it runs out of\n  // buffered data instead of waiting for me\n  return playlist.endList && mediaSource.readyState === 'open' && appendedLastSegment;\n};\n\nvar finite = function finite(num) {\n  return typeof num === 'number' && isFinite(num);\n};\n\nvar illegalMediaSwitch = function illegalMediaSwitch(loaderType, startingMedia, newSegmentMedia) {\n  // Although these checks should most likely cover non 'main' types, for now it narrows\n  // the scope of our checks.\n  if (loaderType !== 'main' || !startingMedia || !newSegmentMedia) {\n    return null;\n  }\n\n  if (!newSegmentMedia.containsAudio && !newSegmentMedia.containsVideo) {\n    return 'Neither audio nor video found in segment.';\n  }\n\n  if (startingMedia.containsVideo && !newSegmentMedia.containsVideo) {\n    return 'Only audio found in segment when we expected video.' + ' We can\\'t switch to audio only from a stream that had video.' + ' To get rid of this message, please add codec information to the manifest.';\n  }\n\n  if (!startingMedia.containsVideo && newSegmentMedia.containsVideo) {\n    return 'Video found in segment when we expected only audio.' + ' We can\\'t switch to a stream with video from an audio only stream.' + ' To get rid of this message, please add codec information to the manifest.';\n  }\n\n  return null;\n};\n\nexports.illegalMediaSwitch = illegalMediaSwitch;\n/**\n * Calculates a time value that is safe to remove from the back buffer without interupting\n * playback.\n *\n * @param {TimeRange} seekable\n *        The current seekable range\n * @param {Number} currentTime\n *        The current time of the player\n * @param {Number} targetDuration\n *        The target duration of the current playlist\n * @return {Number}\n *         Time that is safe to remove from the back buffer without interupting playback\n */\nvar safeBackBufferTrimTime = function safeBackBufferTrimTime(seekable, currentTime, targetDuration) {\n  var removeToTime = undefined;\n\n  if (seekable.length && seekable.start(0) > 0 && seekable.start(0) < currentTime) {\n    // If we have a seekable range use that as the limit for what can be removed safely\n    removeToTime = seekable.start(0);\n  } else {\n    // otherwise remove anything older than 30 seconds before the current play head\n    removeToTime = currentTime - 30;\n  }\n\n  // Don't allow removing from the buffer within target duration of current time\n  // to avoid the possibility of removing the GOP currently being played which could\n  // cause playback stalls.\n  return Math.min(removeToTime, currentTime - targetDuration);\n};\n\nexports.safeBackBufferTrimTime = safeBackBufferTrimTime;\n/**\n * An object that manages segment loading and appending.\n *\n * @class SegmentLoader\n * @param {Object} options required and optional options\n * @extends videojs.EventTarget\n */\n\nvar SegmentLoader = (function (_videojs$EventTarget) {\n  _inherits(SegmentLoader, _videojs$EventTarget);\n\n  function SegmentLoader(settings) {\n    var _this = this;\n\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, SegmentLoader);\n\n    _get(Object.getPrototypeOf(SegmentLoader.prototype), 'constructor', this).call(this);\n    // check pre-conditions\n    if (!settings) {\n      throw new TypeError('Initialization settings are required');\n    }\n    if (typeof settings.currentTime !== 'function') {\n      throw new TypeError('No currentTime getter specified');\n    }\n    if (!settings.mediaSource) {\n      throw new TypeError('No MediaSource specified');\n    }\n    // public properties\n    this.state = 'INIT';\n    this.bandwidth = settings.bandwidth;\n    this.throughput = { rate: 0, count: 0 };\n    this.roundTrip = NaN;\n    this.resetStats_();\n    this.mediaIndex = null;\n\n    // private settings\n    this.hasPlayed_ = settings.hasPlayed;\n    this.currentTime_ = settings.currentTime;\n    this.seekable_ = settings.seekable;\n    this.seeking_ = settings.seeking;\n    this.duration_ = settings.duration;\n    this.mediaSource_ = settings.mediaSource;\n    this.hls_ = settings.hls;\n    this.loaderType_ = settings.loaderType;\n    this.startingMedia_ = void 0;\n    this.segmentMetadataTrack_ = settings.segmentMetadataTrack;\n    this.goalBufferLength_ = settings.goalBufferLength;\n\n    // private instance variables\n    this.checkBufferTimeout_ = null;\n    this.error_ = void 0;\n    this.currentTimeline_ = -1;\n    this.pendingSegment_ = null;\n    this.mimeType_ = null;\n    this.sourceUpdater_ = null;\n    this.xhrOptions_ = null;\n\n    // Fragmented mp4 playback\n    this.activeInitSegmentId_ = null;\n    this.initSegments_ = {};\n\n    this.decrypter_ = settings.decrypter;\n\n    // Manages the tracking and generation of sync-points, mappings\n    // between a time in the display time and a segment index within\n    // a playlist\n    this.syncController_ = settings.syncController;\n    this.syncPoint_ = {\n      segmentIndex: 0,\n      time: 0\n    };\n\n    this.syncController_.on('syncinfoupdate', function () {\n      return _this.trigger('syncinfoupdate');\n    });\n\n    this.mediaSource_.addEventListener('sourceopen', function () {\n      return _this.ended_ = false;\n    });\n\n    // ...for determining the fetch location\n    this.fetchAtBuffer_ = false;\n\n    if (options.debug) {\n      this.logger_ = _videoJs2['default'].log.bind(_videoJs2['default'], 'segment-loader', this.loaderType_, '->');\n    }\n  }\n\n  /**\n   * reset all of our media stats\n   *\n   * @private\n   */\n\n  _createClass(SegmentLoader, [{\n    key: 'resetStats_',\n    value: function resetStats_() {\n      this.mediaBytesTransferred = 0;\n      this.mediaRequests = 0;\n      this.mediaRequestsAborted = 0;\n      this.mediaRequestsTimedout = 0;\n      this.mediaRequestsErrored = 0;\n      this.mediaTransferDuration = 0;\n      this.mediaSecondsLoaded = 0;\n    }\n\n    /**\n     * dispose of the SegmentLoader and reset to the default state\n     */\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.state = 'DISPOSED';\n      this.pause();\n      this.abort_();\n      if (this.sourceUpdater_) {\n        this.sourceUpdater_.dispose();\n      }\n      this.resetStats_();\n    }\n\n    /**\n     * abort anything that is currently doing on with the SegmentLoader\n     * and reset to a default state\n     */\n  }, {\n    key: 'abort',\n    value: function abort() {\n      if (this.state !== 'WAITING') {\n        if (this.pendingSegment_) {\n          this.pendingSegment_ = null;\n        }\n        return;\n      }\n\n      this.abort_();\n\n      // We aborted the requests we were waiting on, so reset the loader's state to READY\n      // since we are no longer \"waiting\" on any requests. XHR callback is not always run\n      // when the request is aborted. This will prevent the loader from being stuck in the\n      // WAITING state indefinitely.\n      this.state = 'READY';\n\n      // don't wait for buffer check timeouts to begin fetching the\n      // next segment\n      if (!this.paused()) {\n        this.monitorBuffer_();\n      }\n    }\n\n    /**\n     * abort all pending xhr requests and null any pending segements\n     *\n     * @private\n     */\n  }, {\n    key: 'abort_',\n    value: function abort_() {\n      if (this.pendingSegment_) {\n        this.pendingSegment_.abortRequests();\n      }\n\n      // clear out the segment being processed\n      this.pendingSegment_ = null;\n    }\n\n    /**\n     * set an error on the segment loader and null out any pending segements\n     *\n     * @param {Error} error the error to set on the SegmentLoader\n     * @return {Error} the error that was set or that is currently set\n     */\n  }, {\n    key: 'error',\n    value: function error(_error) {\n      if (typeof _error !== 'undefined') {\n        this.error_ = _error;\n      }\n\n      this.pendingSegment_ = null;\n      return this.error_;\n    }\n  }, {\n    key: 'endOfStream',\n    value: function endOfStream() {\n      this.ended_ = true;\n      this.pause();\n      this.trigger('ended');\n    }\n\n    /**\n     * Indicates which time ranges are buffered\n     *\n     * @return {TimeRange}\n     *         TimeRange object representing the current buffered ranges\n     */\n  }, {\n    key: 'buffered_',\n    value: function buffered_() {\n      if (!this.sourceUpdater_) {\n        return _videoJs2['default'].createTimeRanges();\n      }\n\n      return this.sourceUpdater_.buffered();\n    }\n\n    /**\n     * Gets and sets init segment for the provided map\n     *\n     * @param {Object} map\n     *        The map object representing the init segment to get or set\n     * @param {Boolean=} set\n     *        If true, the init segment for the provided map should be saved\n     * @return {Object}\n     *         map object for desired init segment\n     */\n  }, {\n    key: 'initSegment',\n    value: function initSegment(map) {\n      var set = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n      if (!map) {\n        return null;\n      }\n\n      var id = (0, _binUtils.initSegmentId)(map);\n      var storedMap = this.initSegments_[id];\n\n      if (set && !storedMap && map.bytes) {\n        this.initSegments_[id] = storedMap = {\n          resolvedUri: map.resolvedUri,\n          byterange: map.byterange,\n          bytes: map.bytes\n        };\n      }\n\n      return storedMap || map;\n    }\n\n    /**\n     * Returns true if all configuration required for loading is present, otherwise false.\n     *\n     * @return {Boolean} True if the all configuration is ready for loading\n     * @private\n     */\n  }, {\n    key: 'couldBeginLoading_',\n    value: function couldBeginLoading_() {\n      return this.playlist_ && (\n      // the source updater is created when init_ is called, so either having a\n      // source updater or being in the INIT state with a mimeType is enough\n      // to say we have all the needed configuration to start loading.\n      this.sourceUpdater_ || this.mimeType_ && this.state === 'INIT') && !this.paused();\n    }\n\n    /**\n     * load a playlist and start to fill the buffer\n     */\n  }, {\n    key: 'load',\n    value: function load() {\n      // un-pause\n      this.monitorBuffer_();\n\n      // if we don't have a playlist yet, keep waiting for one to be\n      // specified\n      if (!this.playlist_) {\n        return;\n      }\n\n      // not sure if this is the best place for this\n      this.syncController_.setDateTimeMapping(this.playlist_);\n\n      // if all the configuration is ready, initialize and begin loading\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        return this.init_();\n      }\n\n      // if we're in the middle of processing a segment already, don't\n      // kick off an additional segment request\n      if (!this.couldBeginLoading_() || this.state !== 'READY' && this.state !== 'INIT') {\n        return;\n      }\n\n      this.state = 'READY';\n    }\n\n    /**\n     * Once all the starting parameters have been specified, begin\n     * operation. This method should only be invoked from the INIT\n     * state.\n     *\n     * @private\n     */\n  }, {\n    key: 'init_',\n    value: function init_() {\n      this.state = 'READY';\n      this.sourceUpdater_ = new _sourceUpdater2['default'](this.mediaSource_, this.mimeType_);\n      this.resetEverything();\n      return this.monitorBuffer_();\n    }\n\n    /**\n     * set a playlist on the segment loader\n     *\n     * @param {PlaylistLoader} media the playlist to set on the segment loader\n     */\n  }, {\n    key: 'playlist',\n    value: function playlist(newPlaylist) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      if (!newPlaylist) {\n        return;\n      }\n\n      var oldPlaylist = this.playlist_;\n      var segmentInfo = this.pendingSegment_;\n\n      this.playlist_ = newPlaylist;\n      this.xhrOptions_ = options;\n\n      // when we haven't started playing yet, the start of a live playlist\n      // is always our zero-time so force a sync update each time the playlist\n      // is refreshed from the server\n      if (!this.hasPlayed_()) {\n        newPlaylist.syncInfo = {\n          mediaSequence: newPlaylist.mediaSequence,\n          time: 0\n        };\n      }\n\n      // in VOD, this is always a rendition switch (or we updated our syncInfo above)\n      // in LIVE, we always want to update with new playlists (including refreshes)\n      this.trigger('syncinfoupdate');\n\n      // if we were unpaused but waiting for a playlist, start\n      // buffering now\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        return this.init_();\n      }\n\n      if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {\n        if (this.mediaIndex !== null) {\n          // we must \"resync\" the segment loader when we switch renditions and\n          // the segment loader is already synced to the previous rendition\n          this.resyncLoader();\n        }\n\n        // the rest of this function depends on `oldPlaylist` being defined\n        return;\n      }\n\n      // we reloaded the same playlist so we are in a live scenario\n      // and we will likely need to adjust the mediaIndex\n      var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;\n\n      this.logger_('mediaSequenceDiff', mediaSequenceDiff);\n\n      // update the mediaIndex on the SegmentLoader\n      // this is important because we can abort a request and this value must be\n      // equal to the last appended mediaIndex\n      if (this.mediaIndex !== null) {\n        this.mediaIndex -= mediaSequenceDiff;\n      }\n\n      // update the mediaIndex on the SegmentInfo object\n      // this is important because we will update this.mediaIndex with this value\n      // in `handleUpdateEnd_` after the segment has been successfully appended\n      if (segmentInfo) {\n        segmentInfo.mediaIndex -= mediaSequenceDiff;\n\n        // we need to update the referenced segment so that timing information is\n        // saved for the new playlist's segment, however, if the segment fell off the\n        // playlist, we can leave the old reference and just lose the timing info\n        if (segmentInfo.mediaIndex >= 0) {\n          segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];\n        }\n      }\n\n      this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);\n    }\n\n    /**\n     * Prevent the loader from fetching additional segments. If there\n     * is a segment request outstanding, it will finish processing\n     * before the loader halts. A segment loader can be unpaused by\n     * calling load().\n     */\n  }, {\n    key: 'pause',\n    value: function pause() {\n      if (this.checkBufferTimeout_) {\n        _globalWindow2['default'].clearTimeout(this.checkBufferTimeout_);\n\n        this.checkBufferTimeout_ = null;\n      }\n    }\n\n    /**\n     * Returns whether the segment loader is fetching additional\n     * segments when given the opportunity. This property can be\n     * modified through calls to pause() and load().\n     */\n  }, {\n    key: 'paused',\n    value: function paused() {\n      return this.checkBufferTimeout_ === null;\n    }\n\n    /**\n     * create/set the following mimetype on the SourceBuffer through a\n     * SourceUpdater\n     *\n     * @param {String} mimeType the mime type string to use\n     */\n  }, {\n    key: 'mimeType',\n    value: function mimeType(_mimeType) {\n      if (this.mimeType_) {\n        return;\n      }\n\n      this.mimeType_ = _mimeType;\n      // if we were unpaused but waiting for a sourceUpdater, start\n      // buffering now\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        this.init_();\n      }\n    }\n\n    /**\n     * Delete all the buffered data and reset the SegmentLoader\n     */\n  }, {\n    key: 'resetEverything',\n    value: function resetEverything() {\n      this.ended_ = false;\n      this.resetLoader();\n      this.remove(0, this.duration_());\n      this.trigger('reseteverything');\n    }\n\n    /**\n     * Force the SegmentLoader to resync and start loading around the currentTime instead\n     * of starting at the end of the buffer\n     *\n     * Useful for fast quality changes\n     */\n  }, {\n    key: 'resetLoader',\n    value: function resetLoader() {\n      this.fetchAtBuffer_ = false;\n      this.resyncLoader();\n    }\n\n    /**\n     * Force the SegmentLoader to restart synchronization and make a conservative guess\n     * before returning to the simple walk-forward method\n     */\n  }, {\n    key: 'resyncLoader',\n    value: function resyncLoader() {\n      this.mediaIndex = null;\n      this.syncPoint_ = null;\n      this.abort();\n    }\n\n    /**\n     * Remove any data in the source buffer between start and end times\n     * @param {Number} start - the start time of the region to remove from the buffer\n     * @param {Number} end - the end time of the region to remove from the buffer\n     */\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      if (this.sourceUpdater_) {\n        this.sourceUpdater_.remove(start, end);\n      }\n      (0, _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2['default'])(start, end, this.segmentMetadataTrack_);\n    }\n\n    /**\n     * (re-)schedule monitorBufferTick_ to run as soon as possible\n     *\n     * @private\n     */\n  }, {\n    key: 'monitorBuffer_',\n    value: function monitorBuffer_() {\n      if (this.checkBufferTimeout_) {\n        _globalWindow2['default'].clearTimeout(this.checkBufferTimeout_);\n      }\n\n      this.checkBufferTimeout_ = _globalWindow2['default'].setTimeout(this.monitorBufferTick_.bind(this), 1);\n    }\n\n    /**\n     * As long as the SegmentLoader is in the READY state, periodically\n     * invoke fillBuffer_().\n     *\n     * @private\n     */\n  }, {\n    key: 'monitorBufferTick_',\n    value: function monitorBufferTick_() {\n      if (this.state === 'READY') {\n        this.fillBuffer_();\n      }\n\n      if (this.checkBufferTimeout_) {\n        _globalWindow2['default'].clearTimeout(this.checkBufferTimeout_);\n      }\n\n      this.checkBufferTimeout_ = _globalWindow2['default'].setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);\n    }\n\n    /**\n     * fill the buffer with segements unless the sourceBuffers are\n     * currently updating\n     *\n     * Note: this function should only ever be called by monitorBuffer_\n     * and never directly\n     *\n     * @private\n     */\n  }, {\n    key: 'fillBuffer_',\n    value: function fillBuffer_() {\n      if (this.sourceUpdater_.updating()) {\n        return;\n      }\n\n      if (!this.syncPoint_) {\n        this.syncPoint_ = this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());\n      }\n\n      // see if we need to begin loading immediately\n      var segmentInfo = this.checkBuffer_(this.buffered_(), this.playlist_, this.mediaIndex, this.hasPlayed_(), this.currentTime_(), this.syncPoint_);\n\n      if (!segmentInfo) {\n        return;\n      }\n\n      var isEndOfStream = detectEndOfStream(this.playlist_, this.mediaSource_, segmentInfo.mediaIndex);\n\n      if (isEndOfStream) {\n        this.endOfStream();\n        return;\n      }\n\n      if (segmentInfo.mediaIndex === this.playlist_.segments.length - 1 && this.mediaSource_.readyState === 'ended' && !this.seeking_()) {\n        return;\n      }\n\n      // We will need to change timestampOffset of the sourceBuffer if either of\n      // the following conditions are true:\n      // - The segment.timeline !== this.currentTimeline\n      //   (we are crossing a discontinuity somehow)\n      // - The \"timestampOffset\" for the start of this segment is less than\n      //   the currently set timestampOffset\n      if (segmentInfo.timeline !== this.currentTimeline_ || segmentInfo.startOfSegment !== null && segmentInfo.startOfSegment < this.sourceUpdater_.timestampOffset()) {\n        this.syncController_.reset();\n        segmentInfo.timestampOffset = segmentInfo.startOfSegment;\n      }\n\n      this.loadSegment_(segmentInfo);\n    }\n\n    /**\n     * Determines what segment request should be made, given current playback\n     * state.\n     *\n     * @param {TimeRanges} buffered - the state of the buffer\n     * @param {Object} playlist - the playlist object to fetch segments from\n     * @param {Number} mediaIndex - the previous mediaIndex fetched or null\n     * @param {Boolean} hasPlayed - a flag indicating whether we have played or not\n     * @param {Number} currentTime - the playback position in seconds\n     * @param {Object} syncPoint - a segment info object that describes the\n     * @returns {Object} a segment request object that describes the segment to load\n     */\n  }, {\n    key: 'checkBuffer_',\n    value: function checkBuffer_(buffered, playlist, mediaIndex, hasPlayed, currentTime, syncPoint) {\n      var lastBufferedEnd = 0;\n      var startOfSegment = undefined;\n\n      if (buffered.length) {\n        lastBufferedEnd = buffered.end(buffered.length - 1);\n      }\n\n      var bufferedTime = Math.max(0, lastBufferedEnd - currentTime);\n\n      if (!playlist.segments.length) {\n        return null;\n      }\n\n      // if there is plenty of content buffered, and the video has\n      // been played before relax for awhile\n      if (bufferedTime >= this.goalBufferLength_()) {\n        return null;\n      }\n\n      // if the video has not yet played once, and we already have\n      // one segment downloaded do nothing\n      if (!hasPlayed && bufferedTime >= 1) {\n        return null;\n      }\n\n      this.logger_('checkBuffer_', 'mediaIndex:', mediaIndex, 'hasPlayed:', hasPlayed, 'currentTime:', currentTime, 'syncPoint:', syncPoint, 'fetchAtBuffer:', this.fetchAtBuffer_, 'bufferedTime:', bufferedTime);\n\n      // When the syncPoint is null, there is no way of determining a good\n      // conservative segment index to fetch from\n      // The best thing to do here is to get the kind of sync-point data by\n      // making a request\n      if (syncPoint === null) {\n        mediaIndex = this.getSyncSegmentCandidate_(playlist);\n        this.logger_('getSync', 'mediaIndex:', mediaIndex);\n        return this.generateSegmentInfo_(playlist, mediaIndex, null, true);\n      }\n\n      // Under normal playback conditions fetching is a simple walk forward\n      if (mediaIndex !== null) {\n        this.logger_('walkForward', 'mediaIndex:', mediaIndex + 1);\n        var segment = playlist.segments[mediaIndex];\n\n        if (segment && segment.end) {\n          startOfSegment = segment.end;\n        } else {\n          startOfSegment = lastBufferedEnd;\n        }\n        return this.generateSegmentInfo_(playlist, mediaIndex + 1, startOfSegment, false);\n      }\n\n      // There is a sync-point but the lack of a mediaIndex indicates that\n      // we need to make a good conservative guess about which segment to\n      // fetch\n      if (this.fetchAtBuffer_) {\n        // Find the segment containing the end of the buffer\n        var mediaSourceInfo = _playlist2['default'].getMediaInfoForTime(playlist, lastBufferedEnd, syncPoint.segmentIndex, syncPoint.time);\n\n        mediaIndex = mediaSourceInfo.mediaIndex;\n        startOfSegment = mediaSourceInfo.startTime;\n      } else {\n        // Find the segment containing currentTime\n        var mediaSourceInfo = _playlist2['default'].getMediaInfoForTime(playlist, currentTime, syncPoint.segmentIndex, syncPoint.time);\n\n        mediaIndex = mediaSourceInfo.mediaIndex;\n        startOfSegment = mediaSourceInfo.startTime;\n      }\n      this.logger_('getMediaIndexForTime', 'mediaIndex:', mediaIndex, 'startOfSegment:', startOfSegment);\n\n      return this.generateSegmentInfo_(playlist, mediaIndex, startOfSegment, false);\n    }\n\n    /**\n     * The segment loader has no recourse except to fetch a segment in the\n     * current playlist and use the internal timestamps in that segment to\n     * generate a syncPoint. This function returns a good candidate index\n     * for that process.\n     *\n     * @param {Object} playlist - the playlist object to look for a\n     * @returns {Number} An index of a segment from the playlist to load\n     */\n  }, {\n    key: 'getSyncSegmentCandidate_',\n    value: function getSyncSegmentCandidate_(playlist) {\n      var _this2 = this;\n\n      if (this.currentTimeline_ === -1) {\n        return 0;\n      }\n\n      var segmentIndexArray = playlist.segments.map(function (s, i) {\n        return {\n          timeline: s.timeline,\n          segmentIndex: i\n        };\n      }).filter(function (s) {\n        return s.timeline === _this2.currentTimeline_;\n      });\n\n      if (segmentIndexArray.length) {\n        return segmentIndexArray[Math.min(segmentIndexArray.length - 1, 1)].segmentIndex;\n      }\n\n      return Math.max(playlist.segments.length - 1, 0);\n    }\n  }, {\n    key: 'generateSegmentInfo_',\n    value: function generateSegmentInfo_(playlist, mediaIndex, startOfSegment, isSyncRequest) {\n      if (mediaIndex < 0 || mediaIndex >= playlist.segments.length) {\n        return null;\n      }\n\n      var segment = playlist.segments[mediaIndex];\n\n      return {\n        requestId: 'segment-loader-' + Math.random(),\n        // resolve the segment URL relative to the playlist\n        uri: segment.resolvedUri,\n        // the segment's mediaIndex at the time it was requested\n        mediaIndex: mediaIndex,\n        // whether or not to update the SegmentLoader's state with this\n        // segment's mediaIndex\n        isSyncRequest: isSyncRequest,\n        startOfSegment: startOfSegment,\n        // the segment's playlist\n        playlist: playlist,\n        // unencrypted bytes of the segment\n        bytes: null,\n        // when a key is defined for this segment, the encrypted bytes\n        encryptedBytes: null,\n        // The target timestampOffset for this segment when we append it\n        // to the source buffer\n        timestampOffset: null,\n        // The timeline that the segment is in\n        timeline: segment.timeline,\n        // The expected duration of the segment in seconds\n        duration: segment.duration,\n        // retain the segment in case the playlist updates while doing an async process\n        segment: segment\n      };\n    }\n\n    /**\n     * Determines if the network has enough bandwidth to complete the current segment\n     * request in a timely manner. If not, the request will be aborted early and bandwidth\n     * updated to trigger a playlist switch.\n     *\n     * @param {Object} stats\n     *        Object containing stats about the request timing and size\n     * @return {Boolean} True if the request was aborted, false otherwise\n     * @private\n     */\n  }, {\n    key: 'abortRequestEarly_',\n    value: function abortRequestEarly_(stats) {\n      if (this.hls_.tech_.paused() ||\n      // Don't abort if the current playlist is on the lowestEnabledRendition\n      // TODO: Replace using timeout with a boolean indicating whether this playlist is\n      //       the lowestEnabledRendition.\n      !this.xhrOptions_.timeout ||\n      // Don't abort if we have no bandwidth information to estimate segment sizes\n      !this.playlist_.attributes.BANDWIDTH) {\n        return false;\n      }\n\n      // Wait at least 1 second since the first byte of data has been received before\n      // using the calculated bandwidth from the progress event to allow the bitrate\n      // to stabilize\n      if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1000) {\n        return false;\n      }\n\n      var currentTime = this.currentTime_();\n      var measuredBandwidth = stats.bandwidth;\n      var segmentDuration = this.pendingSegment_.duration;\n\n      var requestTimeRemaining = _playlist2['default'].estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived);\n\n      // Subtract 1 from the timeUntilRebuffer so we still consider an early abort\n      // if we are only left with less than 1 second when the request completes.\n      // A negative timeUntilRebuffering indicates we are already rebuffering\n      var timeUntilRebuffer = (0, _ranges.timeUntilRebuffer)(this.buffered_(), currentTime, this.hls_.tech_.playbackRate()) - 1;\n\n      // Only consider aborting early if the estimated time to finish the download\n      // is larger than the estimated time until the player runs out of forward buffer\n      if (requestTimeRemaining <= timeUntilRebuffer) {\n        return false;\n      }\n\n      var switchCandidate = (0, _playlistSelectors.minRebufferMaxBandwidthSelector)({\n        master: this.hls_.playlists.master,\n        currentTime: currentTime,\n        bandwidth: measuredBandwidth,\n        duration: this.duration_(),\n        segmentDuration: segmentDuration,\n        timeUntilRebuffer: timeUntilRebuffer,\n        currentTimeline: this.currentTimeline_,\n        syncController: this.syncController_\n      });\n\n      if (!switchCandidate) {\n        return;\n      }\n\n      var rebufferingImpact = requestTimeRemaining - timeUntilRebuffer;\n\n      var timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;\n\n      var minimumTimeSaving = 0.5;\n\n      // If we are already rebuffering, increase the amount of variance we add to the\n      // potential round trip time of the new request so that we are not too aggressive\n      // with switching to a playlist that might save us a fraction of a second.\n      if (timeUntilRebuffer <= _ranges.TIME_FUDGE_FACTOR) {\n        minimumTimeSaving = 1;\n      }\n\n      if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) {\n        return false;\n      }\n\n      // set the bandwidth to that of the desired playlist being sure to scale by\n      // BANDWIDTH_VARIANCE and add one so the playlist selector does not exclude it\n      // don't trigger a bandwidthupdate as the bandwidth is artifial\n      this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * _config2['default'].BANDWIDTH_VARIANCE + 1;\n      this.abort();\n      this.trigger('earlyabort');\n      return true;\n    }\n\n    /**\n     * XHR `progress` event handler\n     *\n     * @param {Event}\n     *        The XHR `progress` event\n     * @param {Object} simpleSegment\n     *        A simplified segment object copy\n     * @private\n     */\n  }, {\n    key: 'handleProgress_',\n    value: function handleProgress_(event, simpleSegment) {\n      if (!this.pendingSegment_ || simpleSegment.requestId !== this.pendingSegment_.requestId || this.abortRequestEarly_(simpleSegment.stats)) {\n        return;\n      }\n\n      this.trigger('progress');\n    }\n\n    /**\n     * load a specific segment from a request into the buffer\n     *\n     * @private\n     */\n  }, {\n    key: 'loadSegment_',\n    value: function loadSegment_(segmentInfo) {\n      this.state = 'WAITING';\n      this.pendingSegment_ = segmentInfo;\n      this.trimBackBuffer_(segmentInfo);\n\n      segmentInfo.abortRequests = (0, _mediaSegmentRequest.mediaSegmentRequest)(this.hls_.xhr, this.xhrOptions_, this.decrypter_, this.createSimplifiedSegmentObj_(segmentInfo),\n      // progress callback\n      this.handleProgress_.bind(this), this.segmentRequestFinished_.bind(this));\n    }\n\n    /**\n     * trim the back buffer so that we don't have too much data\n     * in the source buffer\n     *\n     * @private\n     *\n     * @param {Object} segmentInfo - the current segment\n     */\n  }, {\n    key: 'trimBackBuffer_',\n    value: function trimBackBuffer_(segmentInfo) {\n      var removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);\n\n      // Chrome has a hard limit of 150MB of\n      // buffer and a very conservative \"garbage collector\"\n      // We manually clear out the old buffer to ensure\n      // we don't trigger the QuotaExceeded error\n      // on the source buffer during subsequent appends\n\n      if (removeToTime > 0) {\n        this.remove(0, removeToTime);\n      }\n    }\n\n    /**\n     * created a simplified copy of the segment object with just the\n     * information necessary to perform the XHR and decryption\n     *\n     * @private\n     *\n     * @param {Object} segmentInfo - the current segment\n     * @returns {Object} a simplified segment object copy\n     */\n  }, {\n    key: 'createSimplifiedSegmentObj_',\n    value: function createSimplifiedSegmentObj_(segmentInfo) {\n      var segment = segmentInfo.segment;\n      var simpleSegment = {\n        resolvedUri: segment.resolvedUri,\n        byterange: segment.byterange,\n        requestId: segmentInfo.requestId\n      };\n\n      if (segment.key) {\n        // if the media sequence is greater than 2^32, the IV will be incorrect\n        // assuming 10s segments, that would be about 1300 years\n        var iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);\n\n        simpleSegment.key = {\n          resolvedUri: segment.key.resolvedUri,\n          iv: iv\n        };\n      }\n\n      if (segment.map) {\n        simpleSegment.map = this.initSegment(segment.map);\n      }\n\n      return simpleSegment;\n    }\n\n    /**\n     * Handle the callback from the segmentRequest function and set the\n     * associated SegmentLoader state and errors if necessary\n     *\n     * @private\n     */\n  }, {\n    key: 'segmentRequestFinished_',\n    value: function segmentRequestFinished_(error, simpleSegment) {\n      // every request counts as a media request even if it has been aborted\n      // or canceled due to a timeout\n      this.mediaRequests += 1;\n\n      if (simpleSegment.stats) {\n        this.mediaBytesTransferred += simpleSegment.stats.bytesReceived;\n        this.mediaTransferDuration += simpleSegment.stats.roundTripTime;\n      }\n\n      // The request was aborted and the SegmentLoader has already been reset\n      if (!this.pendingSegment_) {\n        this.mediaRequestsAborted += 1;\n        return;\n      }\n\n      // the request was aborted and the SegmentLoader has already started\n      // another request. this can happen when the timeout for an aborted\n      // request triggers due to a limitation in the XHR library\n      // do not count this as any sort of request or we risk double-counting\n      if (simpleSegment.requestId !== this.pendingSegment_.requestId) {\n        return;\n      }\n\n      // an error occurred from the active pendingSegment_ so reset everything\n      if (error) {\n        this.pendingSegment_ = null;\n        this.state = 'READY';\n\n        // the requests were aborted just record the aborted stat and exit\n        // this is not a true error condition and nothing corrective needs\n        // to be done\n        if (error.code === _mediaSegmentRequest.REQUEST_ERRORS.ABORTED) {\n          this.mediaRequestsAborted += 1;\n          return;\n        }\n\n        this.pause();\n\n        // the error is really just that at least one of the requests timed-out\n        // set the bandwidth to a very low value and trigger an ABR switch to\n        // take emergency action\n        if (error.code === _mediaSegmentRequest.REQUEST_ERRORS.TIMEOUT) {\n          this.mediaRequestsTimedout += 1;\n          this.bandwidth = 1;\n          this.roundTrip = NaN;\n          this.trigger('bandwidthupdate');\n          return;\n        }\n\n        // if control-flow has arrived here, then the error is real\n        // emit an error event to blacklist the current playlist\n        this.mediaRequestsErrored += 1;\n        this.error(error);\n        this.trigger('error');\n        return;\n      }\n\n      // the response was a success so set any bandwidth stats the request\n      // generated for ABR purposes\n      this.bandwidth = simpleSegment.stats.bandwidth;\n      this.roundTrip = simpleSegment.stats.roundTripTime;\n\n      // if this request included an initialization segment, save that data\n      // to the initSegment cache\n      if (simpleSegment.map) {\n        simpleSegment.map = this.initSegment(simpleSegment.map, true);\n      }\n\n      this.processSegmentResponse_(simpleSegment);\n    }\n\n    /**\n     * Move any important data from the simplified segment object\n     * back to the real segment object for future phases\n     *\n     * @private\n     */\n  }, {\n    key: 'processSegmentResponse_',\n    value: function processSegmentResponse_(simpleSegment) {\n      var segmentInfo = this.pendingSegment_;\n\n      segmentInfo.bytes = simpleSegment.bytes;\n      if (simpleSegment.map) {\n        segmentInfo.segment.map.bytes = simpleSegment.map.bytes;\n      }\n\n      segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;\n      this.handleSegment_();\n    }\n\n    /**\n     * append a decrypted segement to the SourceBuffer through a SourceUpdater\n     *\n     * @private\n     */\n  }, {\n    key: 'handleSegment_',\n    value: function handleSegment_() {\n      var _this3 = this;\n\n      if (!this.pendingSegment_) {\n        this.state = 'READY';\n        return;\n      }\n\n      var segmentInfo = this.pendingSegment_;\n      var segment = segmentInfo.segment;\n      var timingInfo = this.syncController_.probeSegmentInfo(segmentInfo);\n\n      // When we have our first timing info, determine what media types this loader is\n      // dealing with. Although we're maintaining extra state, it helps to preserve the\n      // separation of segment loader from the actual source buffers.\n      if (typeof this.startingMedia_ === 'undefined' && timingInfo && (\n      // Guard against cases where we're not getting timing info at all until we are\n      // certain that all streams will provide it.\n      timingInfo.containsAudio || timingInfo.containsVideo)) {\n        this.startingMedia_ = {\n          containsAudio: timingInfo.containsAudio,\n          containsVideo: timingInfo.containsVideo\n        };\n      }\n\n      var illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.startingMedia_, timingInfo);\n\n      if (illegalMediaSwitchError) {\n        this.error({\n          message: illegalMediaSwitchError,\n          blacklistDuration: Infinity\n        });\n        this.trigger('error');\n        return;\n      }\n\n      if (segmentInfo.isSyncRequest) {\n        this.trigger('syncinfoupdate');\n        this.pendingSegment_ = null;\n        this.state = 'READY';\n        return;\n      }\n\n      if (segmentInfo.timestampOffset !== null && segmentInfo.timestampOffset !== this.sourceUpdater_.timestampOffset()) {\n        this.sourceUpdater_.timestampOffset(segmentInfo.timestampOffset);\n        // fired when a timestamp offset is set in HLS (can also identify discontinuities)\n        this.trigger('timestampoffset');\n      }\n\n      var timelineMapping = this.syncController_.mappingForTimeline(segmentInfo.timeline);\n\n      if (timelineMapping !== null) {\n        this.trigger({\n          type: 'segmenttimemapping',\n          mapping: timelineMapping\n        });\n      }\n\n      this.state = 'APPENDING';\n\n      // if the media initialization segment is changing, append it\n      // before the content segment\n      if (segment.map) {\n        (function () {\n          var initId = (0, _binUtils.initSegmentId)(segment.map);\n\n          if (!_this3.activeInitSegmentId_ || _this3.activeInitSegmentId_ !== initId) {\n            var initSegment = _this3.initSegment(segment.map);\n\n            _this3.sourceUpdater_.appendBuffer(initSegment.bytes, function () {\n              _this3.activeInitSegmentId_ = initId;\n            });\n          }\n        })();\n      }\n\n      segmentInfo.byteLength = segmentInfo.bytes.byteLength;\n      if (typeof segment.start === 'number' && typeof segment.end === 'number') {\n        this.mediaSecondsLoaded += segment.end - segment.start;\n      } else {\n        this.mediaSecondsLoaded += segment.duration;\n      }\n\n      this.sourceUpdater_.appendBuffer(segmentInfo.bytes, this.handleUpdateEnd_.bind(this));\n    }\n\n    /**\n     * callback to run when appendBuffer is finished. detects if we are\n     * in a good state to do things with the data we got, or if we need\n     * to wait for more\n     *\n     * @private\n     */\n  }, {\n    key: 'handleUpdateEnd_',\n    value: function handleUpdateEnd_() {\n      this.logger_('handleUpdateEnd_', 'segmentInfo:', this.pendingSegment_);\n\n      if (!this.pendingSegment_) {\n        this.state = 'READY';\n        if (!this.paused()) {\n          this.monitorBuffer_();\n        }\n        return;\n      }\n\n      var segmentInfo = this.pendingSegment_;\n      var segment = segmentInfo.segment;\n      var isWalkingForward = this.mediaIndex !== null;\n\n      this.pendingSegment_ = null;\n      this.recordThroughput_(segmentInfo);\n      this.addSegmentMetadataCue_(segmentInfo);\n\n      this.state = 'READY';\n\n      this.mediaIndex = segmentInfo.mediaIndex;\n      this.fetchAtBuffer_ = true;\n      this.currentTimeline_ = segmentInfo.timeline;\n\n      // We must update the syncinfo to recalculate the seekable range before\n      // the following conditional otherwise it may consider this a bad \"guess\"\n      // and attempt to resync when the post-update seekable window and live\n      // point would mean that this was the perfect segment to fetch\n      this.trigger('syncinfoupdate');\n\n      // If we previously appended a segment that ends more than 3 targetDurations before\n      // the currentTime_ that means that our conservative guess was too conservative.\n      // In that case, reset the loader state so that we try to use any information gained\n      // from the previous request to create a new, more accurate, sync-point.\n      if (segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3) {\n        this.resetEverything();\n        return;\n      }\n\n      // Don't do a rendition switch unless we have enough time to get a sync segment\n      // and conservatively guess\n      if (isWalkingForward) {\n        this.trigger('bandwidthupdate');\n      }\n      this.trigger('progress');\n\n      // any time an update finishes and the last segment is in the\n      // buffer, end the stream. this ensures the \"ended\" event will\n      // fire if playback reaches that point.\n      var isEndOfStream = detectEndOfStream(segmentInfo.playlist, this.mediaSource_, segmentInfo.mediaIndex + 1);\n\n      if (isEndOfStream) {\n        this.endOfStream();\n      }\n\n      if (!this.paused()) {\n        this.monitorBuffer_();\n      }\n    }\n\n    /**\n     * Records the current throughput of the decrypt, transmux, and append\n     * portion of the semgment pipeline. `throughput.rate` is a the cumulative\n     * moving average of the throughput. `throughput.count` is the number of\n     * data points in the average.\n     *\n     * @private\n     * @param {Object} segmentInfo the object returned by loadSegment\n     */\n  }, {\n    key: 'recordThroughput_',\n    value: function recordThroughput_(segmentInfo) {\n      var rate = this.throughput.rate;\n      // Add one to the time to ensure that we don't accidentally attempt to divide\n      // by zero in the case where the throughput is ridiculously high\n      var segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1;\n      // Multiply by 8000 to convert from bytes/millisecond to bits/second\n      var segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1000);\n\n      // This is just a cumulative moving average calculation:\n      //   newAvg = oldAvg + (sample - oldAvg) / (sampleCount + 1)\n      this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;\n    }\n\n    /**\n     * A debugging logger noop that is set to console.log only if debugging\n     * is enabled globally\n     *\n     * @private\n     */\n  }, {\n    key: 'logger_',\n    value: function logger_() {}\n\n    /**\n     * Adds a cue to the segment-metadata track with some metadata information about the\n     * segment\n     *\n     * @private\n     * @param {Object} segmentInfo\n     *        the object returned by loadSegment\n     * @method addSegmentMetadataCue_\n     */\n  }, {\n    key: 'addSegmentMetadataCue_',\n    value: function addSegmentMetadataCue_(segmentInfo) {\n      if (!this.segmentMetadataTrack_) {\n        return;\n      }\n\n      var segment = segmentInfo.segment;\n      var start = segment.start;\n      var end = segment.end;\n\n      // Do not try adding the cue if the start and end times are invalid.\n      if (!finite(start) || !finite(end)) {\n        return;\n      }\n\n      (0, _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2['default'])(start, end, this.segmentMetadataTrack_);\n\n      var Cue = _globalWindow2['default'].WebKitDataCue || _globalWindow2['default'].VTTCue;\n      var value = {\n        uri: segmentInfo.uri,\n        timeline: segmentInfo.timeline,\n        playlist: segmentInfo.playlist.uri,\n        start: start,\n        end: end\n      };\n      var data = JSON.stringify(value);\n      var cue = new Cue(start, end, data);\n\n      // Attach the metadata to the value property of the cue to keep consistency between\n      // the differences of WebKitDataCue in safari and VTTCue in other browsers\n      cue.value = value;\n\n      this.segmentMetadataTrack_.addCue(cue);\n    }\n  }]);\n\n  return SegmentLoader;\n})(_videoJs2['default'].EventTarget);\n\nexports['default'] = SegmentLoader;\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./bin-utils\":2,\"./config\":3,\"./media-segment-request\":7,\"./playlist\":11,\"./playlist-selectors\":10,\"./ranges\":12,\"./source-updater\":17,\"global/window\":32,\"videojs-contrib-media-sources/es5/remove-cues-from-track.js\":72}],17:[function(require,module,exports){\n(function (global){\n/**\n * @file source-updater.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar noop = function noop() {};\n\n/**\n * A queue of callbacks to be serialized and applied when a\n * MediaSource and its associated SourceBuffers are not in the\n * updating state. It is used by the segment loader to update the\n * underlying SourceBuffers when new data is loaded, for instance.\n *\n * @class SourceUpdater\n * @param {MediaSource} mediaSource the MediaSource to create the\n * SourceBuffer from\n * @param {String} mimeType the desired MIME type of the underlying\n * SourceBuffer\n */\n\nvar SourceUpdater = (function () {\n  function SourceUpdater(mediaSource, mimeType) {\n    var _this = this;\n\n    _classCallCheck(this, SourceUpdater);\n\n    var createSourceBuffer = function createSourceBuffer() {\n      _this.sourceBuffer_ = mediaSource.addSourceBuffer(mimeType);\n\n      // run completion handlers and process callbacks as updateend\n      // events fire\n      _this.onUpdateendCallback_ = function () {\n        var pendingCallback = _this.pendingCallback_;\n\n        _this.pendingCallback_ = null;\n\n        if (pendingCallback) {\n          pendingCallback();\n        }\n\n        _this.runCallback_();\n      };\n\n      _this.sourceBuffer_.addEventListener('updateend', _this.onUpdateendCallback_);\n\n      _this.runCallback_();\n    };\n\n    this.callbacks_ = [];\n    this.pendingCallback_ = null;\n    this.timestampOffset_ = 0;\n    this.mediaSource = mediaSource;\n    this.processedAppend_ = false;\n\n    if (mediaSource.readyState === 'closed') {\n      mediaSource.addEventListener('sourceopen', createSourceBuffer);\n    } else {\n      createSourceBuffer();\n    }\n  }\n\n  /**\n   * Aborts the current segment and resets the segment parser.\n   *\n   * @param {Function} done function to call when done\n   * @see http://w3c.github.io/media-source/#widl-SourceBuffer-abort-void\n   */\n\n  _createClass(SourceUpdater, [{\n    key: 'abort',\n    value: function abort(done) {\n      var _this2 = this;\n\n      if (this.processedAppend_) {\n        this.queueCallback_(function () {\n          _this2.sourceBuffer_.abort();\n        }, done);\n      }\n    }\n\n    /**\n     * Queue an update to append an ArrayBuffer.\n     *\n     * @param {ArrayBuffer} bytes\n     * @param {Function} done the function to call when done\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-appendBuffer-void-ArrayBuffer-data\n     */\n  }, {\n    key: 'appendBuffer',\n    value: function appendBuffer(bytes, done) {\n      var _this3 = this;\n\n      this.processedAppend_ = true;\n      this.queueCallback_(function () {\n        _this3.sourceBuffer_.appendBuffer(bytes);\n      }, done);\n    }\n\n    /**\n     * Indicates what TimeRanges are buffered in the managed SourceBuffer.\n     *\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-buffered\n     */\n  }, {\n    key: 'buffered',\n    value: function buffered() {\n      if (!this.sourceBuffer_) {\n        return _videoJs2['default'].createTimeRanges();\n      }\n      return this.sourceBuffer_.buffered;\n    }\n\n    /**\n     * Queue an update to remove a time range from the buffer.\n     *\n     * @param {Number} start where to start the removal\n     * @param {Number} end where to end the removal\n     * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end\n     */\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      var _this4 = this;\n\n      if (this.processedAppend_) {\n        this.queueCallback_(function () {\n          _this4.sourceBuffer_.remove(start, end);\n        }, noop);\n      }\n    }\n\n    /**\n     * Whether the underlying sourceBuffer is updating or not\n     *\n     * @return {Boolean} the updating status of the SourceBuffer\n     */\n  }, {\n    key: 'updating',\n    value: function updating() {\n      return !this.sourceBuffer_ || this.sourceBuffer_.updating || this.pendingCallback_;\n    }\n\n    /**\n     * Set/get the timestampoffset on the SourceBuffer\n     *\n     * @return {Number} the timestamp offset\n     */\n  }, {\n    key: 'timestampOffset',\n    value: function timestampOffset(offset) {\n      var _this5 = this;\n\n      if (typeof offset !== 'undefined') {\n        this.queueCallback_(function () {\n          _this5.sourceBuffer_.timestampOffset = offset;\n        });\n        this.timestampOffset_ = offset;\n      }\n      return this.timestampOffset_;\n    }\n\n    /**\n     * Queue a callback to run\n     */\n  }, {\n    key: 'queueCallback_',\n    value: function queueCallback_(callback, done) {\n      this.callbacks_.push([callback.bind(this), done]);\n      this.runCallback_();\n    }\n\n    /**\n     * Run a queued callback\n     */\n  }, {\n    key: 'runCallback_',\n    value: function runCallback_() {\n      var callbacks = undefined;\n\n      if (!this.updating() && this.callbacks_.length) {\n        callbacks = this.callbacks_.shift();\n        this.pendingCallback_ = callbacks[1];\n        callbacks[0]();\n      }\n    }\n\n    /**\n     * dispose of the source updater and the underlying sourceBuffer\n     */\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.sourceBuffer_.removeEventListener('updateend', this.onUpdateendCallback_);\n      if (this.sourceBuffer_ && this.mediaSource.readyState === 'open') {\n        this.sourceBuffer_.abort();\n      }\n    }\n  }]);\n\n  return SourceUpdater;\n})();\n\nexports['default'] = SourceUpdater;\nmodule.exports = exports['default'];\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],18:[function(require,module,exports){\n(function (global){\n/**\n * @file sync-controller.js\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _muxJsLibMp4Probe = require('mux.js/lib/mp4/probe');\n\nvar _muxJsLibMp4Probe2 = _interopRequireDefault(_muxJsLibMp4Probe);\n\nvar _muxJsLibToolsTsInspectorJs = require('mux.js/lib/tools/ts-inspector.js');\n\nvar _playlist = require('./playlist');\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar syncPointStrategies = [\n// Stategy \"VOD\": Handle the VOD-case where the sync-point is *always*\n//                the equivalence display-time 0 === segment-index 0\n{\n  name: 'VOD',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    if (duration !== Infinity) {\n      var syncPoint = {\n        time: 0,\n        segmentIndex: 0\n      };\n\n      return syncPoint;\n    }\n    return null;\n  }\n},\n// Stategy \"ProgramDateTime\": We have a program-date-time tag in this playlist\n{\n  name: 'ProgramDateTime',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    if (syncController.datetimeToDisplayTime && playlist.dateTimeObject) {\n      var playlistTime = playlist.dateTimeObject.getTime() / 1000;\n      var playlistStart = playlistTime + syncController.datetimeToDisplayTime;\n      var syncPoint = {\n        time: playlistStart,\n        segmentIndex: 0\n      };\n\n      return syncPoint;\n    }\n    return null;\n  }\n},\n// Stategy \"Segment\": We have a known time mapping for a timeline and a\n//                    segment in the current timeline with timing data\n{\n  name: 'Segment',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    var segments = playlist.segments || [];\n    var syncPoint = null;\n    var lastDistance = null;\n\n    currentTime = currentTime || 0;\n\n    for (var i = 0; i < segments.length; i++) {\n      var segment = segments[i];\n\n      if (segment.timeline === currentTimeline && typeof segment.start !== 'undefined') {\n        var distance = Math.abs(currentTime - segment.start);\n\n        // Once the distance begins to increase, we have passed\n        // currentTime and can stop looking for better candidates\n        if (lastDistance !== null && lastDistance < distance) {\n          break;\n        }\n\n        if (!syncPoint || lastDistance === null || lastDistance >= distance) {\n          lastDistance = distance;\n          syncPoint = {\n            time: segment.start,\n            segmentIndex: i\n          };\n        }\n      }\n    }\n    return syncPoint;\n  }\n},\n// Stategy \"Discontinuity\": We have a discontinuity with a known\n//                          display-time\n{\n  name: 'Discontinuity',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    var syncPoint = null;\n\n    currentTime = currentTime || 0;\n\n    if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {\n      var lastDistance = null;\n\n      for (var i = 0; i < playlist.discontinuityStarts.length; i++) {\n        var segmentIndex = playlist.discontinuityStarts[i];\n        var discontinuity = playlist.discontinuitySequence + i + 1;\n        var discontinuitySync = syncController.discontinuities[discontinuity];\n\n        if (discontinuitySync) {\n          var distance = Math.abs(currentTime - discontinuitySync.time);\n\n          // Once the distance begins to increase, we have passed\n          // currentTime and can stop looking for better candidates\n          if (lastDistance !== null && lastDistance < distance) {\n            break;\n          }\n\n          if (!syncPoint || lastDistance === null || lastDistance >= distance) {\n            lastDistance = distance;\n            syncPoint = {\n              time: discontinuitySync.time,\n              segmentIndex: segmentIndex\n            };\n          }\n        }\n      }\n    }\n    return syncPoint;\n  }\n},\n// Stategy \"Playlist\": We have a playlist with a known mapping of\n//                     segment index to display time\n{\n  name: 'Playlist',\n  run: function run(syncController, playlist, duration, currentTimeline, currentTime) {\n    if (playlist.syncInfo) {\n      var syncPoint = {\n        time: playlist.syncInfo.time,\n        segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence\n      };\n\n      return syncPoint;\n    }\n    return null;\n  }\n}];\n\nexports.syncPointStrategies = syncPointStrategies;\n\nvar SyncController = (function (_videojs$EventTarget) {\n  _inherits(SyncController, _videojs$EventTarget);\n\n  function SyncController() {\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    _classCallCheck(this, SyncController);\n\n    _get(Object.getPrototypeOf(SyncController.prototype), 'constructor', this).call(this);\n    // Segment Loader state variables...\n    // ...for synching across variants\n    this.inspectCache_ = undefined;\n\n    // ...for synching across variants\n    this.timelines = [];\n    this.discontinuities = [];\n    this.datetimeToDisplayTime = null;\n\n    if (options.debug) {\n      this.logger_ = _videoJs2['default'].log.bind(_videoJs2['default'], 'sync-controller ->');\n    }\n  }\n\n  /**\n   * Find a sync-point for the playlist specified\n   *\n   * A sync-point is defined as a known mapping from display-time to\n   * a segment-index in the current playlist.\n   *\n   * @param {Playlist} playlist\n   *        The playlist that needs a sync-point\n   * @param {Number} duration\n   *        Duration of the MediaSource (Infinite if playing a live source)\n   * @param {Number} currentTimeline\n   *        The last timeline from which a segment was loaded\n   * @returns {Object}\n   *          A sync-point object\n   */\n\n  _createClass(SyncController, [{\n    key: 'getSyncPoint',\n    value: function getSyncPoint(playlist, duration, currentTimeline, currentTime) {\n      var syncPoints = this.runStrategies_(playlist, duration, currentTimeline, currentTime);\n\n      if (!syncPoints.length) {\n        // Signal that we need to attempt to get a sync-point manually\n        // by fetching a segment in the playlist and constructing\n        // a sync-point from that information\n        return null;\n      }\n\n      // Now find the sync-point that is closest to the currentTime because\n      // that should result in the most accurate guess about which segment\n      // to fetch\n      return this.selectSyncPoint_(syncPoints, { key: 'time', value: currentTime });\n    }\n\n    /**\n     * Calculate the amount of time that has expired off the playlist during playback\n     *\n     * @param {Playlist} playlist\n     *        Playlist object to calculate expired from\n     * @param {Number} duration\n     *        Duration of the MediaSource (Infinity if playling a live source)\n     * @returns {Number|null}\n     *          The amount of time that has expired off the playlist during playback. Null\n     *          if no sync-points for the playlist can be found.\n     */\n  }, {\n    key: 'getExpiredTime',\n    value: function getExpiredTime(playlist, duration) {\n      if (!playlist || !playlist.segments) {\n        return null;\n      }\n\n      var syncPoints = this.runStrategies_(playlist, duration, playlist.discontinuitySequence, 0);\n\n      // Without sync-points, there is not enough information to determine the expired time\n      if (!syncPoints.length) {\n        return null;\n      }\n\n      var syncPoint = this.selectSyncPoint_(syncPoints, {\n        key: 'segmentIndex',\n        value: 0\n      });\n\n      // If the sync-point is beyond the start of the playlist, we want to subtract the\n      // duration from index 0 to syncPoint.segmentIndex instead of adding.\n      if (syncPoint.segmentIndex > 0) {\n        syncPoint.time *= -1;\n      }\n\n      return Math.abs(syncPoint.time + (0, _playlist.sumDurations)(playlist, syncPoint.segmentIndex, 0));\n    }\n\n    /**\n     * Runs each sync-point strategy and returns a list of sync-points returned by the\n     * strategies\n     *\n     * @private\n     * @param {Playlist} playlist\n     *        The playlist that needs a sync-point\n     * @param {Number} duration\n     *        Duration of the MediaSource (Infinity if playing a live source)\n     * @param {Number} currentTimeline\n     *        The last timeline from which a segment was loaded\n     * @returns {Array}\n     *          A list of sync-point objects\n     */\n  }, {\n    key: 'runStrategies_',\n    value: function runStrategies_(playlist, duration, currentTimeline, currentTime) {\n      var syncPoints = [];\n\n      // Try to find a sync-point in by utilizing various strategies...\n      for (var i = 0; i < syncPointStrategies.length; i++) {\n        var strategy = syncPointStrategies[i];\n        var syncPoint = strategy.run(this, playlist, duration, currentTimeline, currentTime);\n\n        if (syncPoint) {\n          syncPoint.strategy = strategy.name;\n          syncPoints.push({\n            strategy: strategy.name,\n            syncPoint: syncPoint\n          });\n          this.logger_('syncPoint found via <' + strategy.name + '>:', syncPoint);\n        }\n      }\n\n      return syncPoints;\n    }\n\n    /**\n     * Selects the sync-point nearest the specified target\n     *\n     * @private\n     * @param {Array} syncPoints\n     *        List of sync-points to select from\n     * @param {Object} target\n     *        Object specifying the property and value we are targeting\n     * @param {String} target.key\n     *        Specifies the property to target. Must be either 'time' or 'segmentIndex'\n     * @param {Number} target.value\n     *        The value to target for the specified key.\n     * @returns {Object}\n     *          The sync-point nearest the target\n     */\n  }, {\n    key: 'selectSyncPoint_',\n    value: function selectSyncPoint_(syncPoints, target) {\n      var bestSyncPoint = syncPoints[0].syncPoint;\n      var bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);\n      var bestStrategy = syncPoints[0].strategy;\n\n      for (var i = 1; i < syncPoints.length; i++) {\n        var newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);\n\n        if (newDistance < bestDistance) {\n          bestDistance = newDistance;\n          bestSyncPoint = syncPoints[i].syncPoint;\n          bestStrategy = syncPoints[i].strategy;\n        }\n      }\n\n      this.logger_('syncPoint with strategy <' + bestStrategy + '> chosen: ', bestSyncPoint);\n      return bestSyncPoint;\n    }\n\n    /**\n     * Save any meta-data present on the segments when segments leave\n     * the live window to the playlist to allow for synchronization at the\n     * playlist level later.\n     *\n     * @param {Playlist} oldPlaylist - The previous active playlist\n     * @param {Playlist} newPlaylist - The updated and most current playlist\n     */\n  }, {\n    key: 'saveExpiredSegmentInfo',\n    value: function saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {\n      var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;\n\n      // When a segment expires from the playlist and it has a start time\n      // save that information as a possible sync-point reference in future\n      for (var i = mediaSequenceDiff - 1; i >= 0; i--) {\n        var lastRemovedSegment = oldPlaylist.segments[i];\n\n        if (lastRemovedSegment && typeof lastRemovedSegment.start !== 'undefined') {\n          newPlaylist.syncInfo = {\n            mediaSequence: oldPlaylist.mediaSequence + i,\n            time: lastRemovedSegment.start\n          };\n          this.logger_('playlist sync:', newPlaylist.syncInfo);\n          this.trigger('syncinfoupdate');\n          break;\n        }\n      }\n    }\n\n    /**\n     * Save the mapping from playlist's ProgramDateTime to display. This should\n     * only ever happen once at the start of playback.\n     *\n     * @param {Playlist} playlist - The currently active playlist\n     */\n  }, {\n    key: 'setDateTimeMapping',\n    value: function setDateTimeMapping(playlist) {\n      if (!this.datetimeToDisplayTime && playlist.dateTimeObject) {\n        var playlistTimestamp = playlist.dateTimeObject.getTime() / 1000;\n\n        this.datetimeToDisplayTime = -playlistTimestamp;\n      }\n    }\n\n    /**\n     * Reset the state of the inspection cache when we do a rendition\n     * switch\n     */\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.inspectCache_ = undefined;\n    }\n\n    /**\n     * Probe or inspect a fmp4 or an mpeg2-ts segment to determine the start\n     * and end of the segment in it's internal \"media time\". Used to generate\n     * mappings from that internal \"media time\" to the display time that is\n     * shown on the player.\n     *\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     */\n  }, {\n    key: 'probeSegmentInfo',\n    value: function probeSegmentInfo(segmentInfo) {\n      var segment = segmentInfo.segment;\n      var playlist = segmentInfo.playlist;\n      var timingInfo = undefined;\n\n      if (segment.map) {\n        timingInfo = this.probeMp4Segment_(segmentInfo);\n      } else {\n        timingInfo = this.probeTsSegment_(segmentInfo);\n      }\n\n      if (timingInfo) {\n        if (this.calculateSegmentTimeMapping_(segmentInfo, timingInfo)) {\n          this.saveDiscontinuitySyncInfo_(segmentInfo);\n\n          // If the playlist does not have sync information yet, record that information\n          // now with segment timing information\n          if (!playlist.syncInfo) {\n            playlist.syncInfo = {\n              mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,\n              time: segment.start\n            };\n          }\n        }\n      }\n\n      return timingInfo;\n    }\n\n    /**\n     * Probe an fmp4 or an mpeg2-ts segment to determine the start of the segment\n     * in it's internal \"media time\".\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     * @return {object} The start and end time of the current segment in \"media time\"\n     */\n  }, {\n    key: 'probeMp4Segment_',\n    value: function probeMp4Segment_(segmentInfo) {\n      var segment = segmentInfo.segment;\n      var timescales = _muxJsLibMp4Probe2['default'].timescale(segment.map.bytes);\n      var startTime = _muxJsLibMp4Probe2['default'].startTime(timescales, segmentInfo.bytes);\n\n      if (segmentInfo.timestampOffset !== null) {\n        segmentInfo.timestampOffset -= startTime;\n      }\n\n      return {\n        start: startTime,\n        end: startTime + segment.duration\n      };\n    }\n\n    /**\n     * Probe an mpeg2-ts segment to determine the start and end of the segment\n     * in it's internal \"media time\".\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     * @return {object} The start and end time of the current segment in \"media time\"\n     */\n  }, {\n    key: 'probeTsSegment_',\n    value: function probeTsSegment_(segmentInfo) {\n      var timeInfo = (0, _muxJsLibToolsTsInspectorJs.inspect)(segmentInfo.bytes, this.inspectCache_);\n      var segmentStartTime = undefined;\n      var segmentEndTime = undefined;\n\n      if (!timeInfo) {\n        return null;\n      }\n\n      if (timeInfo.video && timeInfo.video.length === 2) {\n        this.inspectCache_ = timeInfo.video[1].dts;\n        segmentStartTime = timeInfo.video[0].dtsTime;\n        segmentEndTime = timeInfo.video[1].dtsTime;\n      } else if (timeInfo.audio && timeInfo.audio.length === 2) {\n        this.inspectCache_ = timeInfo.audio[1].dts;\n        segmentStartTime = timeInfo.audio[0].dtsTime;\n        segmentEndTime = timeInfo.audio[1].dtsTime;\n      }\n\n      return {\n        start: segmentStartTime,\n        end: segmentEndTime,\n        containsVideo: timeInfo.video && timeInfo.video.length === 2,\n        containsAudio: timeInfo.audio && timeInfo.audio.length === 2\n      };\n    }\n  }, {\n    key: 'timestampOffsetForTimeline',\n    value: function timestampOffsetForTimeline(timeline) {\n      if (typeof this.timelines[timeline] === 'undefined') {\n        return null;\n      }\n      return this.timelines[timeline].time;\n    }\n  }, {\n    key: 'mappingForTimeline',\n    value: function mappingForTimeline(timeline) {\n      if (typeof this.timelines[timeline] === 'undefined') {\n        return null;\n      }\n      return this.timelines[timeline].mapping;\n    }\n\n    /**\n     * Use the \"media time\" for a segment to generate a mapping to \"display time\" and\n     * save that display time to the segment.\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo\n     *        The current active request information\n     * @param {object} timingInfo\n     *        The start and end time of the current segment in \"media time\"\n     * @returns {Boolean}\n     *          Returns false if segment time mapping could not be calculated\n     */\n  }, {\n    key: 'calculateSegmentTimeMapping_',\n    value: function calculateSegmentTimeMapping_(segmentInfo, timingInfo) {\n      var segment = segmentInfo.segment;\n      var mappingObj = this.timelines[segmentInfo.timeline];\n\n      if (segmentInfo.timestampOffset !== null) {\n        this.logger_('tsO:', segmentInfo.timestampOffset);\n\n        mappingObj = {\n          time: segmentInfo.startOfSegment,\n          mapping: segmentInfo.startOfSegment - timingInfo.start\n        };\n        this.timelines[segmentInfo.timeline] = mappingObj;\n        this.trigger('timestampoffset');\n\n        segment.start = segmentInfo.startOfSegment;\n        segment.end = timingInfo.end + mappingObj.mapping;\n      } else if (mappingObj) {\n        segment.start = timingInfo.start + mappingObj.mapping;\n        segment.end = timingInfo.end + mappingObj.mapping;\n      } else {\n        return false;\n      }\n\n      return true;\n    }\n\n    /**\n     * Each time we have discontinuity in the playlist, attempt to calculate the location\n     * in display of the start of the discontinuity and save that. We also save an accuracy\n     * value so that we save values with the most accuracy (closest to 0.)\n     *\n     * @private\n     * @param {SegmentInfo} segmentInfo - The current active request information\n     */\n  }, {\n    key: 'saveDiscontinuitySyncInfo_',\n    value: function saveDiscontinuitySyncInfo_(segmentInfo) {\n      var playlist = segmentInfo.playlist;\n      var segment = segmentInfo.segment;\n\n      // If the current segment is a discontinuity then we know exactly where\n      // the start of the range and it's accuracy is 0 (greater accuracy values\n      // mean more approximation)\n      if (segment.discontinuity) {\n        this.discontinuities[segment.timeline] = {\n          time: segment.start,\n          accuracy: 0\n        };\n      } else if (playlist.discontinuityStarts.length) {\n        // Search for future discontinuities that we can provide better timing\n        // information for and save that information for sync purposes\n        for (var i = 0; i < playlist.discontinuityStarts.length; i++) {\n          var segmentIndex = playlist.discontinuityStarts[i];\n          var discontinuity = playlist.discontinuitySequence + i + 1;\n          var mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;\n          var accuracy = Math.abs(mediaIndexDiff);\n\n          if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {\n            var time = undefined;\n\n            if (mediaIndexDiff < 0) {\n              time = segment.start - (0, _playlist.sumDurations)(playlist, segmentInfo.mediaIndex, segmentIndex);\n            } else {\n              time = segment.end + (0, _playlist.sumDurations)(playlist, segmentInfo.mediaIndex + 1, segmentIndex);\n            }\n\n            this.discontinuities[discontinuity] = {\n              time: time,\n              accuracy: accuracy\n            };\n          }\n        }\n      }\n    }\n\n    /**\n     * A debugging logger noop that is set to console.log only if debugging\n     * is enabled globally\n     *\n     * @private\n     */\n  }, {\n    key: 'logger_',\n    value: function logger_() {}\n  }]);\n\n  return SyncController;\n})(_videoJs2['default'].EventTarget);\n\nexports['default'] = SyncController;\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./playlist\":11,\"mux.js/lib/mp4/probe\":57,\"mux.js/lib/tools/ts-inspector.js\":59}],19:[function(require,module,exports){\n\n/**\n * @file - codecs.js - Handles tasks regarding codec strings such as translating them to\n * codec strings, or translating codec strings into objects that can be examined.\n */\n\n/**\n * Parses a codec string to retrieve the number of codecs specified,\n * the video codec and object type indicator, and the audio profile.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar parseCodecs = function parseCodecs() {\n  var codecs = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\n  var result = {\n    codecCount: 0\n  };\n  var parsed = undefined;\n\n  result.codecCount = codecs.split(',').length;\n  result.codecCount = result.codecCount || 2;\n\n  // parse the video codec\n  parsed = /(^|\\s|,)+(avc1)([^ ,]*)/i.exec(codecs);\n  if (parsed) {\n    result.videoCodec = parsed[2];\n    result.videoObjectTypeIndicator = parsed[3];\n  }\n\n  // parse the last field of the audio codec\n  result.audioProfile = /(^|\\s|,)+mp4a.[0-9A-Fa-f]+\\.([0-9A-Fa-f]+)/i.exec(codecs);\n  result.audioProfile = result.audioProfile && result.audioProfile[2];\n\n  return result;\n};\nexports.parseCodecs = parseCodecs;\n},{}],20:[function(require,module,exports){\n(function (global){\n/**\n * @file vtt-segment-loader.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _segmentLoader = require('./segment-loader');\n\nvar _segmentLoader2 = _interopRequireDefault(_segmentLoader);\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs = require('videojs-contrib-media-sources/es5/remove-cues-from-track.js');\n\nvar _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2 = _interopRequireDefault(_videojsContribMediaSourcesEs5RemoveCuesFromTrackJs);\n\nvar _binUtils = require('./bin-utils');\n\nvar VTT_LINE_TERMINATORS = new Uint8Array('\\n\\n'.split('').map(function (char) {\n  return char.charCodeAt(0);\n}));\n\nvar uintToString = function uintToString(uintArray) {\n  return String.fromCharCode.apply(null, uintArray);\n};\n\n/**\n * An object that manages segment loading and appending.\n *\n * @class VTTSegmentLoader\n * @param {Object} options required and optional options\n * @extends videojs.EventTarget\n */\n\nvar VTTSegmentLoader = (function (_SegmentLoader) {\n  _inherits(VTTSegmentLoader, _SegmentLoader);\n\n  function VTTSegmentLoader(settings) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, VTTSegmentLoader);\n\n    _get(Object.getPrototypeOf(VTTSegmentLoader.prototype), 'constructor', this).call(this, settings, options);\n\n    // SegmentLoader requires a MediaSource be specified or it will throw an error;\n    // however, VTTSegmentLoader has no need of a media source, so delete the reference\n    this.mediaSource_ = null;\n\n    this.subtitlesTrack_ = null;\n  }\n\n  /**\n   * Indicates which time ranges are buffered\n   *\n   * @return {TimeRange}\n   *         TimeRange object representing the current buffered ranges\n   */\n\n  _createClass(VTTSegmentLoader, [{\n    key: 'buffered_',\n    value: function buffered_() {\n      if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues.length) {\n        return _videoJs2['default'].createTimeRanges();\n      }\n\n      var cues = this.subtitlesTrack_.cues;\n      var start = cues[0].startTime;\n      var end = cues[cues.length - 1].startTime;\n\n      return _videoJs2['default'].createTimeRanges([[start, end]]);\n    }\n\n    /**\n     * Gets and sets init segment for the provided map\n     *\n     * @param {Object} map\n     *        The map object representing the init segment to get or set\n     * @param {Boolean=} set\n     *        If true, the init segment for the provided map should be saved\n     * @return {Object}\n     *         map object for desired init segment\n     */\n  }, {\n    key: 'initSegment',\n    value: function initSegment(map) {\n      var set = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n      if (!map) {\n        return null;\n      }\n\n      var id = (0, _binUtils.initSegmentId)(map);\n      var storedMap = this.initSegments_[id];\n\n      if (set && !storedMap && map.bytes) {\n        // append WebVTT line terminators to the media initialization segment if it exists\n        // to follow the WebVTT spec (https://w3c.github.io/webvtt/#file-structure) that\n        // requires two or more WebVTT line terminators between the WebVTT header and the\n        // rest of the file\n        var combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;\n        var combinedSegment = new Uint8Array(combinedByteLength);\n\n        combinedSegment.set(map.bytes);\n        combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength);\n\n        this.initSegments_[id] = storedMap = {\n          resolvedUri: map.resolvedUri,\n          byterange: map.byterange,\n          bytes: combinedSegment\n        };\n      }\n\n      return storedMap || map;\n    }\n\n    /**\n     * Returns true if all configuration required for loading is present, otherwise false.\n     *\n     * @return {Boolean} True if the all configuration is ready for loading\n     * @private\n     */\n  }, {\n    key: 'couldBeginLoading_',\n    value: function couldBeginLoading_() {\n      return this.playlist_ && this.subtitlesTrack_ && !this.paused();\n    }\n\n    /**\n     * Once all the starting parameters have been specified, begin\n     * operation. This method should only be invoked from the INIT\n     * state.\n     *\n     * @private\n     */\n  }, {\n    key: 'init_',\n    value: function init_() {\n      this.state = 'READY';\n      this.resetEverything();\n      return this.monitorBuffer_();\n    }\n\n    /**\n     * Set a subtitle track on the segment loader to add subtitles to\n     *\n     * @param {TextTrack=} track\n     *        The text track to add loaded subtitles to\n     * @return {TextTrack}\n     *        Returns the subtitles track\n     */\n  }, {\n    key: 'track',\n    value: function track(_track) {\n      if (typeof _track === 'undefined') {\n        return this.subtitlesTrack_;\n      }\n\n      this.subtitlesTrack_ = _track;\n\n      // if we were unpaused but waiting for a sourceUpdater, start\n      // buffering now\n      if (this.state === 'INIT' && this.couldBeginLoading_()) {\n        this.init_();\n      }\n\n      return this.subtitlesTrack_;\n    }\n\n    /**\n     * Remove any data in the source buffer between start and end times\n     * @param {Number} start - the start time of the region to remove from the buffer\n     * @param {Number} end - the end time of the region to remove from the buffer\n     */\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      (0, _videojsContribMediaSourcesEs5RemoveCuesFromTrackJs2['default'])(start, end, this.subtitlesTrack_);\n    }\n\n    /**\n     * fill the buffer with segements unless the sourceBuffers are\n     * currently updating\n     *\n     * Note: this function should only ever be called by monitorBuffer_\n     * and never directly\n     *\n     * @private\n     */\n  }, {\n    key: 'fillBuffer_',\n    value: function fillBuffer_() {\n      var _this = this;\n\n      if (!this.syncPoint_) {\n        this.syncPoint_ = this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());\n      }\n\n      // see if we need to begin loading immediately\n      var segmentInfo = this.checkBuffer_(this.buffered_(), this.playlist_, this.mediaIndex, this.hasPlayed_(), this.currentTime_(), this.syncPoint_);\n\n      segmentInfo = this.skipEmptySegments_(segmentInfo);\n\n      if (!segmentInfo) {\n        return;\n      }\n\n      if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {\n        // We don't have the timestamp offset that we need to sync subtitles.\n        // Rerun on a timestamp offset or user interaction.\n        var checkTimestampOffset = function checkTimestampOffset() {\n          _this.state = 'READY';\n          if (!_this.paused()) {\n            // if not paused, queue a buffer check as soon as possible\n            _this.monitorBuffer_();\n          }\n        };\n\n        this.syncController_.one('timestampoffset', checkTimestampOffset);\n        this.state = 'WAITING_ON_TIMELINE';\n        return;\n      }\n\n      this.loadSegment_(segmentInfo);\n    }\n\n    /**\n     * Prevents the segment loader from requesting segments we know contain no subtitles\n     * by walking forward until we find the next segment that we don't know whether it is\n     * empty or not.\n     *\n     * @param {Object} segmentInfo\n     *        a segment info object that describes the current segment\n     * @return {Object}\n     *         a segment info object that describes the current segment\n     */\n  }, {\n    key: 'skipEmptySegments_',\n    value: function skipEmptySegments_(segmentInfo) {\n      while (segmentInfo && segmentInfo.segment.empty) {\n        segmentInfo = this.generateSegmentInfo_(segmentInfo.playlist, segmentInfo.mediaIndex + 1, segmentInfo.startOfSegment + segmentInfo.duration, segmentInfo.isSyncRequest);\n      }\n      return segmentInfo;\n    }\n\n    /**\n     * append a decrypted segement to the SourceBuffer through a SourceUpdater\n     *\n     * @private\n     */\n  }, {\n    key: 'handleSegment_',\n    value: function handleSegment_() {\n      var _this2 = this;\n\n      if (!this.pendingSegment_ || !this.subtitlesTrack_) {\n        this.state = 'READY';\n        return;\n      }\n\n      this.state = 'APPENDING';\n\n      var segmentInfo = this.pendingSegment_;\n      var segment = segmentInfo.segment;\n\n      // Make sure that vttjs has loaded, otherwise, wait till it finished loading\n      if (typeof _globalWindow2['default'].WebVTT !== 'function' && this.subtitlesTrack_ && this.subtitlesTrack_.tech_) {\n        var _ret = (function () {\n\n          var loadHandler = function loadHandler() {\n            _this2.handleSegment_();\n          };\n\n          _this2.state = 'WAITING_ON_VTTJS';\n          _this2.subtitlesTrack_.tech_.one('vttjsloaded', loadHandler);\n          _this2.subtitlesTrack_.tech_.one('vttjserror', function () {\n            _this2.subtitlesTrack_.tech_.off('vttjsloaded', loadHandler);\n            _this2.error({\n              message: 'Error loading vtt.js'\n            });\n            _this2.state = 'READY';\n            _this2.pause();\n            _this2.trigger('error');\n          });\n\n          return {\n            v: undefined\n          };\n        })();\n\n        if (typeof _ret === 'object') return _ret.v;\n      }\n\n      segment.requested = true;\n\n      try {\n        this.parseVTTCues_(segmentInfo);\n      } catch (e) {\n        this.error({\n          message: e.message\n        });\n        this.state = 'READY';\n        this.pause();\n        return this.trigger('error');\n      }\n\n      this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);\n\n      if (segmentInfo.isSyncRequest) {\n        this.trigger('syncinfoupdate');\n        this.pendingSegment_ = null;\n        this.state = 'READY';\n        return;\n      }\n\n      segmentInfo.byteLength = segmentInfo.bytes.byteLength;\n\n      this.mediaSecondsLoaded += segment.duration;\n\n      if (segmentInfo.cues.length) {\n        // remove any overlapping cues to prevent doubling\n        this.remove(segmentInfo.cues[0].endTime, segmentInfo.cues[segmentInfo.cues.length - 1].endTime);\n      }\n\n      segmentInfo.cues.forEach(function (cue) {\n        _this2.subtitlesTrack_.addCue(cue);\n      });\n\n      this.handleUpdateEnd_();\n    }\n\n    /**\n     * Uses the WebVTT parser to parse the segment response\n     *\n     * @param {Object} segmentInfo\n     *        a segment info object that describes the current segment\n     * @private\n     */\n  }, {\n    key: 'parseVTTCues_',\n    value: function parseVTTCues_(segmentInfo) {\n      var decoder = undefined;\n      var decodeBytesToString = false;\n\n      if (typeof _globalWindow2['default'].TextDecoder === 'function') {\n        decoder = new _globalWindow2['default'].TextDecoder('utf8');\n      } else {\n        decoder = _globalWindow2['default'].WebVTT.StringDecoder();\n        decodeBytesToString = true;\n      }\n\n      var parser = new _globalWindow2['default'].WebVTT.Parser(_globalWindow2['default'], _globalWindow2['default'].vttjs, decoder);\n\n      segmentInfo.cues = [];\n      segmentInfo.timestampmap = { MPEGTS: 0, LOCAL: 0 };\n\n      parser.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);\n      parser.ontimestampmap = function (map) {\n        return segmentInfo.timestampmap = map;\n      };\n      parser.onparsingerror = function (error) {\n        _videoJs2['default'].log.warn('Error encountered when parsing cues: ' + error.message);\n      };\n\n      if (segmentInfo.segment.map) {\n        var mapData = segmentInfo.segment.map.bytes;\n\n        if (decodeBytesToString) {\n          mapData = uintToString(mapData);\n        }\n\n        parser.parse(mapData);\n      }\n\n      var segmentData = segmentInfo.bytes;\n\n      if (decodeBytesToString) {\n        segmentData = uintToString(segmentData);\n      }\n\n      parser.parse(segmentData);\n      parser.flush();\n    }\n\n    /**\n     * Updates the start and end times of any cues parsed by the WebVTT parser using\n     * the information parsed from the X-TIMESTAMP-MAP header and a TS to media time mapping\n     * from the SyncController\n     *\n     * @param {Object} segmentInfo\n     *        a segment info object that describes the current segment\n     * @param {Object} mappingObj\n     *        object containing a mapping from TS to media time\n     * @param {Object} playlist\n     *        the playlist object containing the segment\n     * @private\n     */\n  }, {\n    key: 'updateTimeMapping_',\n    value: function updateTimeMapping_(segmentInfo, mappingObj, playlist) {\n      var segment = segmentInfo.segment;\n\n      if (!mappingObj) {\n        // If the sync controller does not have a mapping of TS to Media Time for the\n        // timeline, then we don't have enough information to update the cue\n        // start/end times\n        return;\n      }\n\n      if (!segmentInfo.cues.length) {\n        // If there are no cues, we also do not have enough information to figure out\n        // segment timing. Mark that the segment contains no cues so we don't re-request\n        // an empty segment.\n        segment.empty = true;\n        return;\n      }\n\n      var timestampmap = segmentInfo.timestampmap;\n      var diff = timestampmap.MPEGTS / 90000 - timestampmap.LOCAL + mappingObj.mapping;\n\n      segmentInfo.cues.forEach(function (cue) {\n        // First convert cue time to TS time using the timestamp-map provided within the vtt\n        cue.startTime += diff;\n        cue.endTime += diff;\n      });\n\n      if (!playlist.syncInfo) {\n        var firstStart = segmentInfo.cues[0].startTime;\n        var lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;\n\n        playlist.syncInfo = {\n          mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,\n          time: Math.min(firstStart, lastStart - segment.duration)\n        };\n      }\n    }\n  }]);\n\n  return VTTSegmentLoader;\n})(_segmentLoader2['default']);\n\nexports['default'] = VTTSegmentLoader;\nmodule.exports = exports['default'];\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./bin-utils\":2,\"./segment-loader\":16,\"global/window\":32,\"videojs-contrib-media-sources/es5/remove-cues-from-track.js\":72}],21:[function(require,module,exports){\n(function (global){\n/**\n * @file xhr.js\n */\n\n/**\n * A wrapper for videojs.xhr that tracks bandwidth.\n *\n * @param {Object} options options for the XHR\n * @param {Function} callback the callback to call when done\n * @return {Request} the xhr request that is going to be made\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar xhrFactory = function xhrFactory() {\n  var xhr = function XhrFunction(options, callback) {\n    // Add a default timeout for all hls requests\n    options = (0, _videoJs.mergeOptions)({\n      timeout: 45e3\n    }, options);\n\n    // Allow an optional user-specified function to modify the option\n    // object before we construct the xhr request\n    var beforeRequest = XhrFunction.beforeRequest || _videoJs2['default'].Hls.xhr.beforeRequest;\n\n    if (beforeRequest && typeof beforeRequest === 'function') {\n      var newOptions = beforeRequest(options);\n\n      if (newOptions) {\n        options = newOptions;\n      }\n    }\n\n    var request = (0, _videoJs.xhr)(options, function (error, response) {\n      var reqResponse = request.response;\n\n      if (!error && reqResponse) {\n        request.responseTime = Date.now();\n        request.roundTripTime = request.responseTime - request.requestTime;\n        request.bytesReceived = reqResponse.byteLength || reqResponse.length;\n        if (!request.bandwidth) {\n          request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1000);\n        }\n      }\n\n      // videojs.xhr now uses a specific code on the error\n      // object to signal that a request has timed out instead\n      // of setting a boolean on the request object\n      if (error && error.code === 'ETIMEDOUT') {\n        request.timedout = true;\n      }\n\n      // videojs.xhr no longer considers status codes outside of 200 and 0\n      // (for file uris) to be errors, but the old XHR did, so emulate that\n      // behavior. Status 206 may be used in response to byterange requests.\n      if (!error && !request.aborted && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) {\n        error = new Error('XHR Failed with a response of: ' + (request && (reqResponse || request.responseText)));\n      }\n\n      callback(error, request);\n    });\n    var originalAbort = request.abort;\n\n    request.abort = function () {\n      request.aborted = true;\n      return originalAbort.apply(request, arguments);\n    };\n    request.uri = options.uri;\n    request.requestTime = Date.now();\n    return request;\n  };\n\n  return xhr;\n};\n\nexports['default'] = xhrFactory;\nmodule.exports = exports['default'];\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],22:[function(require,module,exports){\n/**\n * @file aes.js\n *\n * This file contains an adaptation of the AES decryption algorithm\n * from the Standford Javascript Cryptography Library. That work is\n * covered by the following copyright and permissions notice:\n *\n * Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation\n * are those of the authors and should not be interpreted as representing\n * official policies, either expressed or implied, of the authors.\n */\n\n/**\n * Expand the S-box tables.\n *\n * @private\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar precompute = function precompute() {\n  var tables = [[[], [], [], [], []], [[], [], [], [], []]];\n  var encTable = tables[0];\n  var decTable = tables[1];\n  var sbox = encTable[4];\n  var sboxInv = decTable[4];\n  var i = undefined;\n  var x = undefined;\n  var xInv = undefined;\n  var d = [];\n  var th = [];\n  var x2 = undefined;\n  var x4 = undefined;\n  var x8 = undefined;\n  var s = undefined;\n  var tEnc = undefined;\n  var tDec = undefined;\n\n  // Compute double and third tables\n  for (i = 0; i < 256; i++) {\n    th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;\n  }\n\n  for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n    // Compute sbox\n    s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\n    s = s >> 8 ^ s & 255 ^ 99;\n    sbox[x] = s;\n    sboxInv[s] = x;\n\n    // Compute MixColumns\n    x8 = d[x4 = d[x2 = d[x]]];\n    tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n    tEnc = d[s] * 0x101 ^ s * 0x1010100;\n\n    for (i = 0; i < 4; i++) {\n      encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n      decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;\n    }\n  }\n\n  // Compactify. Considerable speedup on Firefox.\n  for (i = 0; i < 5; i++) {\n    encTable[i] = encTable[i].slice(0);\n    decTable[i] = decTable[i].slice(0);\n  }\n  return tables;\n};\nvar aesTables = null;\n\n/**\n * Schedule out an AES key for both encryption and decryption. This\n * is a low-level class. Use a cipher mode to do bulk encryption.\n *\n * @class AES\n * @param key {Array} The key as an array of 4, 6 or 8 words.\n */\n\nvar AES = (function () {\n  function AES(key) {\n    _classCallCheck(this, AES);\n\n    /**\n     * The expanded S-box and inverse S-box tables. These will be computed\n     * on the client so that we don't have to send them down the wire.\n     *\n     * There are two tables, _tables[0] is for encryption and\n     * _tables[1] is for decryption.\n     *\n     * The first 4 sub-tables are the expanded S-box with MixColumns. The\n     * last (_tables[01][4]) is the S-box itself.\n     *\n     * @private\n     */\n    // if we have yet to precompute the S-box tables\n    // do so now\n    if (!aesTables) {\n      aesTables = precompute();\n    }\n    // then make a copy of that object for use\n    this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];\n    var i = undefined;\n    var j = undefined;\n    var tmp = undefined;\n    var encKey = undefined;\n    var decKey = undefined;\n    var sbox = this._tables[0][4];\n    var decTable = this._tables[1];\n    var keyLen = key.length;\n    var rcon = 1;\n\n    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n      throw new Error('Invalid aes key size');\n    }\n\n    encKey = key.slice(0);\n    decKey = [];\n    this._key = [encKey, decKey];\n\n    // schedule encryption keys\n    for (i = keyLen; i < 4 * keyLen + 28; i++) {\n      tmp = encKey[i - 1];\n\n      // apply sbox\n      if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {\n        tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];\n\n        // shift rows and add rcon\n        if (i % keyLen === 0) {\n          tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;\n          rcon = rcon << 1 ^ (rcon >> 7) * 283;\n        }\n      }\n\n      encKey[i] = encKey[i - keyLen] ^ tmp;\n    }\n\n    // schedule decryption keys\n    for (j = 0; i; j++, i--) {\n      tmp = encKey[j & 3 ? i : i - 4];\n      if (i <= 4 || j < 4) {\n        decKey[j] = tmp;\n      } else {\n        decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];\n      }\n    }\n  }\n\n  /**\n   * Decrypt 16 bytes, specified as four 32-bit words.\n   *\n   * @param {Number} encrypted0 the first word to decrypt\n   * @param {Number} encrypted1 the second word to decrypt\n   * @param {Number} encrypted2 the third word to decrypt\n   * @param {Number} encrypted3 the fourth word to decrypt\n   * @param {Int32Array} out the array to write the decrypted words\n   * into\n   * @param {Number} offset the offset into the output array to start\n   * writing results\n   * @return {Array} The plaintext.\n   */\n\n  _createClass(AES, [{\n    key: 'decrypt',\n    value: function decrypt(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {\n      var key = this._key[1];\n      // state variables a,b,c,d are loaded with pre-whitened data\n      var a = encrypted0 ^ key[0];\n      var b = encrypted3 ^ key[1];\n      var c = encrypted2 ^ key[2];\n      var d = encrypted1 ^ key[3];\n      var a2 = undefined;\n      var b2 = undefined;\n      var c2 = undefined;\n\n      // key.length === 2 ?\n      var nInnerRounds = key.length / 4 - 2;\n      var i = undefined;\n      var kIndex = 4;\n      var table = this._tables[1];\n\n      // load up the tables\n      var table0 = table[0];\n      var table1 = table[1];\n      var table2 = table[2];\n      var table3 = table[3];\n      var sbox = table[4];\n\n      // Inner rounds. Cribbed from OpenSSL.\n      for (i = 0; i < nInnerRounds; i++) {\n        a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];\n        b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];\n        c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];\n        d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];\n        kIndex += 4;\n        a = a2;b = b2;c = c2;\n      }\n\n      // Last round.\n      for (i = 0; i < 4; i++) {\n        out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];\n        a2 = a;a = b;b = c;c = d;d = a2;\n      }\n    }\n  }]);\n\n  return AES;\n})();\n\nexports['default'] = AES;\nmodule.exports = exports['default'];\n},{}],23:[function(require,module,exports){\n/**\n * @file async-stream.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _stream = require('./stream');\n\nvar _stream2 = _interopRequireDefault(_stream);\n\n/**\n * A wrapper around the Stream class to use setTiemout\n * and run stream \"jobs\" Asynchronously\n *\n * @class AsyncStream\n * @extends Stream\n */\n\nvar AsyncStream = (function (_Stream) {\n  _inherits(AsyncStream, _Stream);\n\n  function AsyncStream() {\n    _classCallCheck(this, AsyncStream);\n\n    _get(Object.getPrototypeOf(AsyncStream.prototype), 'constructor', this).call(this, _stream2['default']);\n    this.jobs = [];\n    this.delay = 1;\n    this.timeout_ = null;\n  }\n\n  /**\n   * process an async job\n   *\n   * @private\n   */\n\n  _createClass(AsyncStream, [{\n    key: 'processJob_',\n    value: function processJob_() {\n      this.jobs.shift()();\n      if (this.jobs.length) {\n        this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\n      } else {\n        this.timeout_ = null;\n      }\n    }\n\n    /**\n     * push a job into the stream\n     *\n     * @param {Function} job the job to push into the stream\n     */\n  }, {\n    key: 'push',\n    value: function push(job) {\n      this.jobs.push(job);\n      if (!this.timeout_) {\n        this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\n      }\n    }\n  }]);\n\n  return AsyncStream;\n})(_stream2['default']);\n\nexports['default'] = AsyncStream;\nmodule.exports = exports['default'];\n},{\"./stream\":26}],24:[function(require,module,exports){\n/**\n * @file decrypter.js\n *\n * An asynchronous implementation of AES-128 CBC decryption with\n * PKCS#7 padding.\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _aes = require('./aes');\n\nvar _aes2 = _interopRequireDefault(_aes);\n\nvar _asyncStream = require('./async-stream');\n\nvar _asyncStream2 = _interopRequireDefault(_asyncStream);\n\nvar _pkcs7 = require('pkcs7');\n\n/**\n * Convert network-order (big-endian) bytes into their little-endian\n * representation.\n */\nvar ntoh = function ntoh(word) {\n  return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n};\n\n/**\n * Decrypt bytes using AES-128 with CBC and PKCS#7 padding.\n *\n * @param {Uint8Array} encrypted the encrypted bytes\n * @param {Uint32Array} key the bytes of the decryption key\n * @param {Uint32Array} initVector the initialization vector (IV) to\n * use for the first round of CBC.\n * @return {Uint8Array} the decrypted bytes\n *\n * @see http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n * @see http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29\n * @see https://tools.ietf.org/html/rfc2315\n */\nvar decrypt = function decrypt(encrypted, key, initVector) {\n  // word-level access to the encrypted bytes\n  var encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);\n\n  var decipher = new _aes2['default'](Array.prototype.slice.call(key));\n\n  // byte and word-level access for the decrypted output\n  var decrypted = new Uint8Array(encrypted.byteLength);\n  var decrypted32 = new Int32Array(decrypted.buffer);\n\n  // temporary variables for working with the IV, encrypted, and\n  // decrypted data\n  var init0 = undefined;\n  var init1 = undefined;\n  var init2 = undefined;\n  var init3 = undefined;\n  var encrypted0 = undefined;\n  var encrypted1 = undefined;\n  var encrypted2 = undefined;\n  var encrypted3 = undefined;\n\n  // iteration variable\n  var wordIx = undefined;\n\n  // pull out the words of the IV to ensure we don't modify the\n  // passed-in reference and easier access\n  init0 = initVector[0];\n  init1 = initVector[1];\n  init2 = initVector[2];\n  init3 = initVector[3];\n\n  // decrypt four word sequences, applying cipher-block chaining (CBC)\n  // to each decrypted block\n  for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {\n    // convert big-endian (network order) words into little-endian\n    // (javascript order)\n    encrypted0 = ntoh(encrypted32[wordIx]);\n    encrypted1 = ntoh(encrypted32[wordIx + 1]);\n    encrypted2 = ntoh(encrypted32[wordIx + 2]);\n    encrypted3 = ntoh(encrypted32[wordIx + 3]);\n\n    // decrypt the block\n    decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx);\n\n    // XOR with the IV, and restore network byte-order to obtain the\n    // plaintext\n    decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);\n    decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);\n    decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);\n    decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3);\n\n    // setup the IV for the next round\n    init0 = encrypted0;\n    init1 = encrypted1;\n    init2 = encrypted2;\n    init3 = encrypted3;\n  }\n\n  return decrypted;\n};\n\nexports.decrypt = decrypt;\n/**\n * The `Decrypter` class that manages decryption of AES\n * data through `AsyncStream` objects and the `decrypt`\n * function\n *\n * @param {Uint8Array} encrypted the encrypted bytes\n * @param {Uint32Array} key the bytes of the decryption key\n * @param {Uint32Array} initVector the initialization vector (IV) to\n * @param {Function} done the function to run when done\n * @class Decrypter\n */\n\nvar Decrypter = (function () {\n  function Decrypter(encrypted, key, initVector, done) {\n    _classCallCheck(this, Decrypter);\n\n    var step = Decrypter.STEP;\n    var encrypted32 = new Int32Array(encrypted.buffer);\n    var decrypted = new Uint8Array(encrypted.byteLength);\n    var i = 0;\n\n    this.asyncStream_ = new _asyncStream2['default']();\n\n    // split up the encryption job and do the individual chunks asynchronously\n    this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\n    for (i = step; i < encrypted32.length; i += step) {\n      initVector = new Uint32Array([ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1])]);\n      this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\n    }\n    // invoke the done() callback when everything is finished\n    this.asyncStream_.push(function () {\n      // remove pkcs#7 padding from the decrypted bytes\n      done(null, (0, _pkcs7.unpad)(decrypted));\n    });\n  }\n\n  /**\n   * a getter for step the maximum number of bytes to process at one time\n   *\n   * @return {Number} the value of step 32000\n   */\n\n  _createClass(Decrypter, [{\n    key: 'decryptChunk_',\n\n    /**\n     * @private\n     */\n    value: function decryptChunk_(encrypted, key, initVector, decrypted) {\n      return function () {\n        var bytes = decrypt(encrypted, key, initVector);\n\n        decrypted.set(bytes, encrypted.byteOffset);\n      };\n    }\n  }], [{\n    key: 'STEP',\n    get: function get() {\n      // 4 * 8000;\n      return 32000;\n    }\n  }]);\n\n  return Decrypter;\n})();\n\nexports.Decrypter = Decrypter;\nexports['default'] = {\n  Decrypter: Decrypter,\n  decrypt: decrypt\n};\n},{\"./aes\":22,\"./async-stream\":23,\"pkcs7\":28}],25:[function(require,module,exports){\n/**\n * @file index.js\n *\n * Index module to easily import the primary components of AES-128\n * decryption. Like this:\n *\n * ```js\n * import {Decrypter, decrypt, AsyncStream} from 'aes-decrypter';\n * ```\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _decrypter = require('./decrypter');\n\nvar _asyncStream = require('./async-stream');\n\nvar _asyncStream2 = _interopRequireDefault(_asyncStream);\n\nexports['default'] = {\n  decrypt: _decrypter.decrypt,\n  Decrypter: _decrypter.Decrypter,\n  AsyncStream: _asyncStream2['default']\n};\nmodule.exports = exports['default'];\n},{\"./async-stream\":23,\"./decrypter\":24}],26:[function(require,module,exports){\n/**\n * @file stream.js\n */\n/**\n * A lightweight readable stream implemention that handles event dispatching.\n *\n * @class Stream\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar Stream = (function () {\n  function Stream() {\n    _classCallCheck(this, Stream);\n\n    this.listeners = {};\n  }\n\n  /**\n   * Add a listener for a specified event type.\n   *\n   * @param {String} type the event name\n   * @param {Function} listener the callback to be invoked when an event of\n   * the specified type occurs\n   */\n\n  _createClass(Stream, [{\n    key: 'on',\n    value: function on(type, listener) {\n      if (!this.listeners[type]) {\n        this.listeners[type] = [];\n      }\n      this.listeners[type].push(listener);\n    }\n\n    /**\n     * Remove a listener for a specified event type.\n     *\n     * @param {String} type the event name\n     * @param {Function} listener  a function previously registered for this\n     * type of event through `on`\n     * @return {Boolean} if we could turn it off or not\n     */\n  }, {\n    key: 'off',\n    value: function off(type, listener) {\n      var index = undefined;\n\n      if (!this.listeners[type]) {\n        return false;\n      }\n      index = this.listeners[type].indexOf(listener);\n      this.listeners[type].splice(index, 1);\n      return index > -1;\n    }\n\n    /**\n     * Trigger an event of the specified type on this stream. Any additional\n     * arguments to this function are passed as parameters to event listeners.\n     *\n     * @param {String} type the event name\n     */\n  }, {\n    key: 'trigger',\n    value: function trigger(type) {\n      var callbacks = undefined;\n      var i = undefined;\n      var length = undefined;\n      var args = undefined;\n\n      callbacks = this.listeners[type];\n      if (!callbacks) {\n        return;\n      }\n      // Slicing the arguments on every invocation of this method\n      // can add a significant amount of overhead. Avoid the\n      // intermediate object creation for the common case of a\n      // single callback argument\n      if (arguments.length === 2) {\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].call(this, arguments[1]);\n        }\n      } else {\n        args = Array.prototype.slice.call(arguments, 1);\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].apply(this, args);\n        }\n      }\n    }\n\n    /**\n     * Destroys the stream and cleans up.\n     */\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.listeners = {};\n    }\n\n    /**\n     * Forwards all `data` events on this stream to the destination stream. The\n     * destination stream should provide a method `push` to receive the data\n     * events as they arrive.\n     *\n     * @param {Stream} destination the stream that will receive all `data` events\n     * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n     */\n  }, {\n    key: 'pipe',\n    value: function pipe(destination) {\n      this.on('data', function (data) {\n        destination.push(data);\n      });\n    }\n  }]);\n\n  return Stream;\n})();\n\nexports['default'] = Stream;\nmodule.exports = exports['default'];\n},{}],27:[function(require,module,exports){\n/*\n * pkcs7.pad\n * https://github.com/brightcove/pkcs7\n *\n * Copyright (c) 2014 Brightcove\n * Licensed under the apache2 license.\n */\n\n'use strict';\n\nvar PADDING;\n\n/**\n * Returns a new Uint8Array that is padded with PKCS#7 padding.\n * @param plaintext {Uint8Array} the input bytes before encryption\n * @return {Uint8Array} the padded bytes\n * @see http://tools.ietf.org/html/rfc5652\n */\nmodule.exports = function pad(plaintext) {\n  var padding = PADDING[(plaintext.byteLength % 16) || 0],\n      result = new Uint8Array(plaintext.byteLength + padding.length);\n  result.set(plaintext);\n  result.set(padding, plaintext.byteLength);\n  return result;\n};\n\n// pre-define the padding values\nPADDING = [\n  [16, 16, 16, 16,\n   16, 16, 16, 16,\n   16, 16, 16, 16,\n   16, 16, 16, 16],\n\n  [15, 15, 15, 15,\n   15, 15, 15, 15,\n   15, 15, 15, 15,\n   15, 15, 15],\n\n  [14, 14, 14, 14,\n   14, 14, 14, 14,\n   14, 14, 14, 14,\n   14, 14],\n\n  [13, 13, 13, 13,\n   13, 13, 13, 13,\n   13, 13, 13, 13,\n   13],\n\n  [12, 12, 12, 12,\n   12, 12, 12, 12,\n   12, 12, 12, 12],\n\n  [11, 11, 11, 11,\n   11, 11, 11, 11,\n   11, 11, 11],\n\n  [10, 10, 10, 10,\n   10, 10, 10, 10,\n   10, 10],\n\n  [9, 9, 9, 9,\n   9, 9, 9, 9,\n   9],\n\n  [8, 8, 8, 8,\n   8, 8, 8, 8],\n\n  [7, 7, 7, 7,\n   7, 7, 7],\n\n  [6, 6, 6, 6,\n   6, 6],\n\n  [5, 5, 5, 5,\n   5],\n\n  [4, 4, 4, 4],\n\n  [3, 3, 3],\n\n  [2, 2],\n\n  [1]\n];\n\n},{}],28:[function(require,module,exports){\n/*\n * pkcs7\n * https://github.com/brightcove/pkcs7\n *\n * Copyright (c) 2014 Brightcove\n * Licensed under the apache2 license.\n */\n\n'use strict';\n\nexports.pad = require('./pad.js');\nexports.unpad = require('./unpad.js');\n\n},{\"./pad.js\":27,\"./unpad.js\":29}],29:[function(require,module,exports){\n/*\n * pkcs7.unpad\n * https://github.com/brightcove/pkcs7\n *\n * Copyright (c) 2014 Brightcove\n * Licensed under the apache2 license.\n */\n\n'use strict';\n\n/**\n * Returns the subarray of a Uint8Array without PKCS#7 padding.\n * @param padded {Uint8Array} unencrypted bytes that have been padded\n * @return {Uint8Array} the unpadded bytes\n * @see http://tools.ietf.org/html/rfc5652\n */\nmodule.exports = function unpad(padded) {\n  return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);\n};\n\n},{}],30:[function(require,module,exports){\n\n},{}],31:[function(require,module,exports){\n(function (global){\nvar topLevel = typeof global !== 'undefined' ? global :\n    typeof window !== 'undefined' ? window : {}\nvar minDoc = require('min-document');\n\nvar doccy;\n\nif (typeof document !== 'undefined') {\n    doccy = document;\n} else {\n    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n\n    if (!doccy) {\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n    }\n}\n\nmodule.exports = doccy;\n\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"min-document\":30}],32:[function(require,module,exports){\n(function (global){\nvar win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],33:[function(require,module,exports){\n'use strict';\n\nvar _lineStream = require('./line-stream');\n\nvar _lineStream2 = _interopRequireDefault(_lineStream);\n\nvar _parseStream = require('./parse-stream');\n\nvar _parseStream2 = _interopRequireDefault(_parseStream);\n\nvar _parser = require('./parser');\n\nvar _parser2 = _interopRequireDefault(_parser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nmodule.exports = {\n  LineStream: _lineStream2['default'],\n  ParseStream: _parseStream2['default'],\n  Parser: _parser2['default']\n}; /**\n    * @file m3u8/index.js\n    *\n    * Utilities for parsing M3U8 files. If the entire manifest is available,\n    * `Parser` will create an object representation with enough detail for managing\n    * playback. `ParseStream` and `LineStream` are lower-level parsing primitives\n    * that do not assume the entirety of the manifest is ready and expose a\n    * ReadableStream-like interface.\n    */\n},{\"./line-stream\":34,\"./parse-stream\":35,\"./parser\":36}],34:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _stream = require('./stream');\n\nvar _stream2 = _interopRequireDefault(_stream);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file m3u8/line-stream.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\n/**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */\nvar LineStream = function (_Stream) {\n  _inherits(LineStream, _Stream);\n\n  function LineStream() {\n    _classCallCheck(this, LineStream);\n\n    var _this = _possibleConstructorReturn(this, (LineStream.__proto__ || Object.getPrototypeOf(LineStream)).call(this));\n\n    _this.buffer = '';\n    return _this;\n  }\n\n  /**\n   * Add new data to be parsed.\n   *\n   * @param {String} data the text to process\n   */\n\n\n  _createClass(LineStream, [{\n    key: 'push',\n    value: function push(data) {\n      var nextNewline = void 0;\n\n      this.buffer += data;\n      nextNewline = this.buffer.indexOf('\\n');\n\n      for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n        this.trigger('data', this.buffer.substring(0, nextNewline));\n        this.buffer = this.buffer.substring(nextNewline + 1);\n      }\n    }\n  }]);\n\n  return LineStream;\n}(_stream2['default']);\n\nexports['default'] = LineStream;\n},{\"./stream\":37}],35:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _stream = require('./stream');\n\nvar _stream2 = _interopRequireDefault(_stream);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file m3u8/parse-stream.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */\nvar attributeSeparator = function attributeSeparator() {\n  var key = '[^=]*';\n  var value = '\"[^\"]*\"|[^,]*';\n  var keyvalue = '(?:' + key + ')=(?:' + value + ')';\n\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\n};\n\n/**\n * Parse attributes from a line given the seperator\n *\n * @param {String} attributes the attibute line to parse\n */\nvar parseAttributes = function parseAttributes(attributes) {\n  // split the string using attributes as the separator\n  var attrs = attributes.split(attributeSeparator());\n  var result = {};\n  var i = attrs.length;\n  var attr = void 0;\n\n  while (i--) {\n    // filter out unmatched portions of the string\n    if (attrs[i] === '') {\n      continue;\n    }\n\n    // split the key and value\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1);\n    // trim whitespace and remove optional quotes around the value\n    attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n    result[attr[0]] = attr[1];\n  }\n  return result;\n};\n\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */\n\nvar ParseStream = function (_Stream) {\n  _inherits(ParseStream, _Stream);\n\n  function ParseStream() {\n    _classCallCheck(this, ParseStream);\n\n    return _possibleConstructorReturn(this, (ParseStream.__proto__ || Object.getPrototypeOf(ParseStream)).call(this));\n  }\n\n  /**\n   * Parses an additional line of input.\n   *\n   * @param {String} line a single line of an M3U8 file to parse\n   */\n\n\n  _createClass(ParseStream, [{\n    key: 'push',\n    value: function push(line) {\n      var match = void 0;\n      var event = void 0;\n\n      // strip whitespace\n      line = line.replace(/^[\\u0000\\s]+|[\\u0000\\s]+$/g, '');\n      if (line.length === 0) {\n        // ignore empty lines\n        return;\n      }\n\n      // URIs\n      if (line[0] !== '#') {\n        this.trigger('data', {\n          type: 'uri',\n          uri: line\n        });\n        return;\n      }\n\n      // Comments\n      if (line.indexOf('#EXT') !== 0) {\n        this.trigger('data', {\n          type: 'comment',\n          text: line.slice(1)\n        });\n        return;\n      }\n\n      // strip off any carriage returns here so the regex matching\n      // doesn't have to account for them.\n      line = line.replace('\\r', '');\n\n      // Tags\n      match = /^#EXTM3U/.exec(line);\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'm3u'\n        });\n        return;\n      }\n      match = /^#EXTINF:?([0-9\\.]*)?,?(.*)?$/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'inf'\n        };\n        if (match[1]) {\n          event.duration = parseFloat(match[1]);\n        }\n        if (match[2]) {\n          event.title = match[2];\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'targetduration'\n        };\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#ZEN-TOTAL-DURATION:?([0-9.]*)?/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'totalduration'\n        };\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'version'\n        };\n        if (match[1]) {\n          event.version = parseInt(match[1], 10);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-MEDIA-SEQUENCE:?(\\-?[0-9.]*)?/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media-sequence'\n        };\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\\-?[0-9.]*)?/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'discontinuity-sequence'\n        };\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'playlist-type'\n        };\n        if (match[1]) {\n          event.playlistType = match[1];\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-BYTERANGE:?([0-9.]*)?@?([0-9.]*)?/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'byterange'\n        };\n        if (match[1]) {\n          event.length = parseInt(match[1], 10);\n        }\n        if (match[2]) {\n          event.offset = parseInt(match[2], 10);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'allow-cache'\n        };\n        if (match[1]) {\n          event.allowed = !/NO/.test(match[1]);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-MAP:?(.*)$/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'map'\n        };\n\n        if (match[1]) {\n          var attributes = parseAttributes(match[1]);\n\n          if (attributes.URI) {\n            event.uri = attributes.URI;\n          }\n          if (attributes.BYTERANGE) {\n            var _attributes$BYTERANGE = attributes.BYTERANGE.split('@'),\n                _attributes$BYTERANGE2 = _slicedToArray(_attributes$BYTERANGE, 2),\n                length = _attributes$BYTERANGE2[0],\n                offset = _attributes$BYTERANGE2[1];\n\n            event.byterange = {};\n            if (length) {\n              event.byterange.length = parseInt(length, 10);\n            }\n            if (offset) {\n              event.byterange.offset = parseInt(offset, 10);\n            }\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'stream-inf'\n        };\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n\n          if (event.attributes.RESOLUTION) {\n            var split = event.attributes.RESOLUTION.split('x');\n            var resolution = {};\n\n            if (split[0]) {\n              resolution.width = parseInt(split[0], 10);\n            }\n            if (split[1]) {\n              resolution.height = parseInt(split[1], 10);\n            }\n            event.attributes.RESOLUTION = resolution;\n          }\n          if (event.attributes.BANDWIDTH) {\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n          }\n          if (event.attributes['PROGRAM-ID']) {\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n          }\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-MEDIA:?(.*)$/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media'\n        };\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-ENDLIST/.exec(line);\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'endlist'\n        });\n        return;\n      }\n      match = /^#EXT-X-DISCONTINUITY/.exec(line);\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'discontinuity'\n        });\n        return;\n      }\n      match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'program-date-time'\n        };\n        if (match[1]) {\n          event.dateTimeString = match[1];\n          event.dateTimeObject = new Date(match[1]);\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-KEY:?(.*)$/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'key'\n        };\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n          // parse the IV string into a Uint32Array\n          if (event.attributes.IV) {\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n              event.attributes.IV = event.attributes.IV.substring(2);\n            }\n\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\n          }\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out-cont'\n        };\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out'\n        };\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n        this.trigger('data', event);\n        return;\n      }\n      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(line);\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-in'\n        };\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n        this.trigger('data', event);\n        return;\n      }\n\n      // unknown tag type\n      this.trigger('data', {\n        type: 'tag',\n        data: line.slice(4)\n      });\n    }\n  }]);\n\n  return ParseStream;\n}(_stream2['default']);\n\nexports['default'] = ParseStream;\n},{\"./stream\":37}],36:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _stream = require('./stream');\n\nvar _stream2 = _interopRequireDefault(_stream);\n\nvar _lineStream = require('./line-stream');\n\nvar _lineStream2 = _interopRequireDefault(_lineStream);\n\nvar _parseStream = require('./parse-stream');\n\nvar _parseStream2 = _interopRequireDefault(_parseStream);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @file m3u8/parser.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @extends Stream\n */\nvar Parser = function (_Stream) {\n  _inherits(Parser, _Stream);\n\n  function Parser() {\n    _classCallCheck(this, Parser);\n\n    var _this = _possibleConstructorReturn(this, (Parser.__proto__ || Object.getPrototypeOf(Parser)).call(this));\n\n    _this.lineStream = new _lineStream2['default']();\n    _this.parseStream = new _parseStream2['default']();\n    _this.lineStream.pipe(_this.parseStream);\n    /* eslint-disable consistent-this */\n    var self = _this;\n    /* eslint-enable consistent-this */\n    var uris = [];\n    var currentUri = {};\n    // if specified, the active EXT-X-MAP definition\n    var currentMap = void 0;\n    // if specified, the active decryption key\n    var _key = void 0;\n    var noop = function noop() {};\n    var defaultMediaGroups = {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    };\n    // group segments into numbered timelines delineated by discontinuities\n    var currentTimeline = 0;\n\n    // the manifest is empty until the parse stream begins delivering data\n    _this.manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      segments: []\n    };\n\n    // update the manifest with the m3u8 entry from the parse stream\n    _this.parseStream.on('data', function (entry) {\n      var mediaGroup = void 0;\n      var rendition = void 0;\n\n      ({\n        tag: function tag() {\n          // switch based on the tag type\n          (({\n            'allow-cache': function allowCache() {\n              this.manifest.allowCache = entry.allowed;\n              if (!('allowed' in entry)) {\n                this.trigger('info', {\n                  message: 'defaulting allowCache to YES'\n                });\n                this.manifest.allowCache = true;\n              }\n            },\n            byterange: function byterange() {\n              var byterange = {};\n\n              if ('length' in entry) {\n                currentUri.byterange = byterange;\n                byterange.length = entry.length;\n\n                if (!('offset' in entry)) {\n                  this.trigger('info', {\n                    message: 'defaulting offset to zero'\n                  });\n                  entry.offset = 0;\n                }\n              }\n              if ('offset' in entry) {\n                currentUri.byterange = byterange;\n                byterange.offset = entry.offset;\n              }\n            },\n            endlist: function endlist() {\n              this.manifest.endList = true;\n            },\n            inf: function inf() {\n              if (!('mediaSequence' in this.manifest)) {\n                this.manifest.mediaSequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting media sequence to zero'\n                });\n              }\n              if (!('discontinuitySequence' in this.manifest)) {\n                this.manifest.discontinuitySequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting discontinuity sequence to zero'\n                });\n              }\n              if (entry.duration > 0) {\n                currentUri.duration = entry.duration;\n              }\n\n              if (entry.duration === 0) {\n                currentUri.duration = 0.01;\n                this.trigger('info', {\n                  message: 'updating zero segment duration to a small value'\n                });\n              }\n\n              this.manifest.segments = uris;\n            },\n            key: function key() {\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without attribute list'\n                });\n                return;\n              }\n              // clear the active encryption key\n              if (entry.attributes.METHOD === 'NONE') {\n                _key = null;\n                return;\n              }\n              if (!entry.attributes.URI) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without URI'\n                });\n                return;\n              }\n              if (!entry.attributes.METHOD) {\n                this.trigger('warn', {\n                  message: 'defaulting key method to AES-128'\n                });\n              }\n\n              // setup an encryption key for upcoming segments\n              _key = {\n                method: entry.attributes.METHOD || 'AES-128',\n                uri: entry.attributes.URI\n              };\n\n              if (typeof entry.attributes.IV !== 'undefined') {\n                _key.iv = entry.attributes.IV;\n              }\n            },\n            'media-sequence': function mediaSequence() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid media sequence: ' + entry.number\n                });\n                return;\n              }\n              this.manifest.mediaSequence = entry.number;\n            },\n            'discontinuity-sequence': function discontinuitySequence() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                });\n                return;\n              }\n              this.manifest.discontinuitySequence = entry.number;\n              currentTimeline = entry.number;\n            },\n            'playlist-type': function playlistType() {\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\n                this.trigger('warn', {\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\n                });\n                return;\n              }\n              this.manifest.playlistType = entry.playlistType;\n            },\n            map: function map() {\n              currentMap = {};\n              if (entry.uri) {\n                currentMap.uri = entry.uri;\n              }\n              if (entry.byterange) {\n                currentMap.byterange = entry.byterange;\n              }\n            },\n            'stream-inf': function streamInf() {\n              this.manifest.playlists = uris;\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring empty stream-inf attributes'\n                });\n                return;\n              }\n\n              if (!currentUri.attributes) {\n                currentUri.attributes = {};\n              }\n              _extends(currentUri.attributes, entry.attributes);\n            },\n            media: function media() {\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                this.trigger('warn', {\n                  message: 'ignoring incomplete or missing media group'\n                });\n                return;\n              }\n\n              // find the media group, creating defaults as necessary\n              var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']];\n\n              // collect the rendition metadata\n              rendition = {\n                'default': /yes/i.test(entry.attributes.DEFAULT)\n              };\n              if (rendition['default']) {\n                rendition.autoselect = true;\n              } else {\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n              }\n              if (entry.attributes.LANGUAGE) {\n                rendition.language = entry.attributes.LANGUAGE;\n              }\n              if (entry.attributes.URI) {\n                rendition.uri = entry.attributes.URI;\n              }\n              if (entry.attributes['INSTREAM-ID']) {\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\n              }\n              if (entry.attributes.CHARACTERISTICS) {\n                rendition.characteristics = entry.attributes.CHARACTERISTICS;\n              }\n              if (entry.attributes.FORCED) {\n                rendition.forced = /yes/i.test(entry.attributes.FORCED);\n              }\n\n              // insert the new rendition\n              mediaGroup[entry.attributes.NAME] = rendition;\n            },\n            discontinuity: function discontinuity() {\n              currentTimeline += 1;\n              currentUri.discontinuity = true;\n              this.manifest.discontinuityStarts.push(uris.length);\n            },\n            'program-date-time': function programDateTime() {\n              this.manifest.dateTimeString = entry.dateTimeString;\n              this.manifest.dateTimeObject = entry.dateTimeObject;\n            },\n            targetduration: function targetduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid target duration: ' + entry.duration\n                });\n                return;\n              }\n              this.manifest.targetDuration = entry.duration;\n            },\n            totalduration: function totalduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid total duration: ' + entry.duration\n                });\n                return;\n              }\n              this.manifest.totalDuration = entry.duration;\n            },\n            'cue-out': function cueOut() {\n              currentUri.cueOut = entry.data;\n            },\n            'cue-out-cont': function cueOutCont() {\n              currentUri.cueOutCont = entry.data;\n            },\n            'cue-in': function cueIn() {\n              currentUri.cueIn = entry.data;\n            }\n          })[entry.tagType] || noop).call(self);\n        },\n        uri: function uri() {\n          currentUri.uri = entry.uri;\n          uris.push(currentUri);\n\n          // if no explicit duration was declared, use the target duration\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\n            this.trigger('warn', {\n              message: 'defaulting segment duration to the target duration'\n            });\n            currentUri.duration = this.manifest.targetDuration;\n          }\n          // annotate with encryption information, if necessary\n          if (_key) {\n            currentUri.key = _key;\n          }\n          currentUri.timeline = currentTimeline;\n          // annotate with initialization segment information, if necessary\n          if (currentMap) {\n            currentUri.map = currentMap;\n          }\n\n          // prepare for the next URI\n          currentUri = {};\n        },\n        comment: function comment() {\n          // comments are not important for playback\n        }\n      })[entry.type].call(self);\n    });\n\n    return _this;\n  }\n\n  /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {String} chunk a potentially incomplete portion of the manifest\n   */\n\n\n  _createClass(Parser, [{\n    key: 'push',\n    value: function push(chunk) {\n      this.lineStream.push(chunk);\n    }\n\n    /**\n     * Flush any remaining input. This can be handy if the last line of an M3U8\n     * manifest did not contain a trailing newline but the file has been\n     * completely received.\n     */\n\n  }, {\n    key: 'end',\n    value: function end() {\n      // flush any buffered input\n      this.lineStream.push('\\n');\n    }\n  }]);\n\n  return Parser;\n}(_stream2['default']);\n\nexports['default'] = Parser;\n},{\"./line-stream\":34,\"./parse-stream\":35,\"./stream\":37}],37:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @file stream.js\n */\n/**\n * A lightweight readable stream implemention that handles event dispatching.\n *\n * @class Stream\n */\nvar Stream = function () {\n  function Stream() {\n    _classCallCheck(this, Stream);\n\n    this.listeners = {};\n  }\n\n  /**\n   * Add a listener for a specified event type.\n   *\n   * @param {String} type the event name\n   * @param {Function} listener the callback to be invoked when an event of\n   * the specified type occurs\n   */\n\n\n  _createClass(Stream, [{\n    key: 'on',\n    value: function on(type, listener) {\n      if (!this.listeners[type]) {\n        this.listeners[type] = [];\n      }\n      this.listeners[type].push(listener);\n    }\n\n    /**\n     * Remove a listener for a specified event type.\n     *\n     * @param {String} type the event name\n     * @param {Function} listener  a function previously registered for this\n     * type of event through `on`\n     * @return {Boolean} if we could turn it off or not\n     */\n\n  }, {\n    key: 'off',\n    value: function off(type, listener) {\n      if (!this.listeners[type]) {\n        return false;\n      }\n\n      var index = this.listeners[type].indexOf(listener);\n\n      this.listeners[type].splice(index, 1);\n      return index > -1;\n    }\n\n    /**\n     * Trigger an event of the specified type on this stream. Any additional\n     * arguments to this function are passed as parameters to event listeners.\n     *\n     * @param {String} type the event name\n     */\n\n  }, {\n    key: 'trigger',\n    value: function trigger(type) {\n      var callbacks = this.listeners[type];\n      var i = void 0;\n      var length = void 0;\n      var args = void 0;\n\n      if (!callbacks) {\n        return;\n      }\n      // Slicing the arguments on every invocation of this method\n      // can add a significant amount of overhead. Avoid the\n      // intermediate object creation for the common case of a\n      // single callback argument\n      if (arguments.length === 2) {\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].call(this, arguments[1]);\n        }\n      } else {\n        args = Array.prototype.slice.call(arguments, 1);\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].apply(this, args);\n        }\n      }\n    }\n\n    /**\n     * Destroys the stream and cleans up.\n     */\n\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.listeners = {};\n    }\n    /**\n     * Forwards all `data` events on this stream to the destination stream. The\n     * destination stream should provide a method `push` to receive the data\n     * events as they arrive.\n     *\n     * @param {Stream} destination the stream that will receive all `data` events\n     * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n     */\n\n  }, {\n    key: 'pipe',\n    value: function pipe(destination) {\n      this.on('data', function (data) {\n        destination.push(data);\n      });\n    }\n  }]);\n\n  return Stream;\n}();\n\nexports['default'] = Stream;\n},{}],38:[function(require,module,exports){\n/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * A stream-based aac to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\nvar Stream = require('../utils/stream.js');\n\n// Constants\nvar AacStream;\n\n/**\n * Splits an incoming stream of binary data into ADTS and ID3 Frames.\n */\n\nAacStream = function() {\n  var\n    everything = new Uint8Array(),\n    timeStamp = 0;\n\n  AacStream.prototype.init.call(this);\n\n  this.setTimestamp = function(timestamp) {\n    timeStamp = timestamp;\n  };\n\n  this.parseId3TagSize = function(header, byteIndex) {\n    var\n      returnSize = (header[byteIndex + 6] << 21) |\n                   (header[byteIndex + 7] << 14) |\n                   (header[byteIndex + 8] << 7) |\n                   (header[byteIndex + 9]),\n      flags = header[byteIndex + 5],\n      footerPresent = (flags & 16) >> 4;\n\n    if (footerPresent) {\n      return returnSize + 20;\n    }\n    return returnSize + 10;\n  };\n\n  this.parseAdtsSize = function(header, byteIndex) {\n    var\n      lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n      middle = header[byteIndex + 4] << 3,\n      highTwo = header[byteIndex + 3] & 0x3 << 11;\n\n    return (highTwo | middle) | lowThree;\n  };\n\n  this.push = function(bytes) {\n    var\n      frameSize = 0,\n      byteIndex = 0,\n      bytesLeft,\n      chunk,\n      packet,\n      tempLength;\n\n    // If there are bytes remaining from the last segment, prepend them to the\n    // bytes that were pushed in\n    if (everything.length) {\n      tempLength = everything.length;\n      everything = new Uint8Array(bytes.byteLength + tempLength);\n      everything.set(everything.subarray(0, tempLength));\n      everything.set(bytes, tempLength);\n    } else {\n      everything = bytes;\n    }\n\n    while (everything.length - byteIndex >= 3) {\n      if ((everything[byteIndex] === 'I'.charCodeAt(0)) &&\n          (everything[byteIndex + 1] === 'D'.charCodeAt(0)) &&\n          (everything[byteIndex + 2] === '3'.charCodeAt(0))) {\n\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (everything.length - byteIndex < 10) {\n          break;\n        }\n\n        // check framesize\n        frameSize = this.parseId3TagSize(everything, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > everything.length) {\n          break;\n        }\n        chunk = {\n          type: 'timed-metadata',\n          data: everything.subarray(byteIndex, byteIndex + frameSize)\n        };\n        this.trigger('data', chunk);\n        byteIndex += frameSize;\n        continue;\n      } else if ((everything[byteIndex] & 0xff === 0xff) &&\n                 ((everything[byteIndex + 1] & 0xf0) === 0xf0)) {\n\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (everything.length - byteIndex < 7) {\n          break;\n        }\n\n        frameSize = this.parseAdtsSize(everything, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > everything.length) {\n          break;\n        }\n\n        packet = {\n          type: 'audio',\n          data: everything.subarray(byteIndex, byteIndex + frameSize),\n          pts: timeStamp,\n          dts: timeStamp\n        };\n        this.trigger('data', packet);\n        byteIndex += frameSize;\n        continue;\n      }\n      byteIndex++;\n    }\n    bytesLeft = everything.length - byteIndex;\n\n    if (bytesLeft > 0) {\n      everything = everything.subarray(byteIndex);\n    } else {\n      everything = new Uint8Array();\n    }\n  };\n};\n\nAacStream.prototype = new Stream();\n\nmodule.exports = AacStream;\n\n},{\"../utils/stream.js\":62}],39:[function(require,module,exports){\n/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Utilities to detect basic properties and metadata about Aac data.\n */\n'use strict';\n\nvar ADTS_SAMPLING_FREQUENCIES = [\n  96000,\n  88200,\n  64000,\n  48000,\n  44100,\n  32000,\n  24000,\n  22050,\n  16000,\n  12000,\n  11025,\n  8000,\n  7350\n];\n\nvar parseSyncSafeInteger = function(data) {\n  return (data[0] << 21) |\n          (data[1] << 14) |\n          (data[2] << 7) |\n          (data[3]);\n};\n\n// return a percent-encoded representation of the specified byte range\n// @see http://en.wikipedia.org/wiki/Percent-encoding\nvar percentEncode = function(bytes, start, end) {\n  var i, result = '';\n  for (i = start; i < end; i++) {\n    result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n  }\n  return result;\n};\n\n// return the string representation of the specified byte range,\n// interpreted as ISO-8859-1.\nvar parseIso88591 = function(bytes, start, end) {\n  return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n};\n\nvar parseId3TagSize = function(header, byteIndex) {\n  var\n    returnSize = (header[byteIndex + 6] << 21) |\n                 (header[byteIndex + 7] << 14) |\n                 (header[byteIndex + 8] << 7) |\n                 (header[byteIndex + 9]),\n    flags = header[byteIndex + 5],\n    footerPresent = (flags & 16) >> 4;\n\n  if (footerPresent) {\n    return returnSize + 20;\n  }\n  return returnSize + 10;\n};\n\nvar parseAdtsSize = function(header, byteIndex) {\n  var\n    lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n    middle = header[byteIndex + 4] << 3,\n    highTwo = header[byteIndex + 3] & 0x3 << 11;\n\n  return (highTwo | middle) | lowThree;\n};\n\nvar parseType = function(header, byteIndex) {\n  if ((header[byteIndex] === 'I'.charCodeAt(0)) &&\n      (header[byteIndex + 1] === 'D'.charCodeAt(0)) &&\n      (header[byteIndex + 2] === '3'.charCodeAt(0))) {\n    return 'timed-metadata';\n  } else if ((header[byteIndex] & 0xff === 0xff) &&\n             ((header[byteIndex + 1] & 0xf0) === 0xf0)) {\n    return 'audio';\n  }\n  return null;\n};\n\nvar parseSampleRate = function(packet) {\n  var i = 0;\n\n  while (i + 5 < packet.length) {\n    if (packet[i] !== 0xFF || (packet[i + 1] & 0xF6) !== 0xF0) {\n      // If a valid header was not found,  jump one forward and attempt to\n      // find a valid ADTS header starting at the next byte\n      i++;\n      continue;\n    }\n    return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 0x3c) >>> 2];\n  }\n\n  return null;\n};\n\nvar parseAacTimestamp = function(packet) {\n  var frameStart, frameSize, frame, frameHeader;\n\n  // find the start of the first frame and the end of the tag\n  frameStart = 10;\n  if (packet[5] & 0x40) {\n    // advance the frame start past the extended header\n    frameStart += 4; // header size field\n    frameStart += parseSyncSafeInteger(packet.subarray(10, 14));\n  }\n\n  // parse one or more ID3 frames\n  // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n  do {\n    // determine the number of bytes in this frame\n    frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));\n    if (frameSize < 1) {\n      return null;\n    }\n    frameHeader = String.fromCharCode(packet[frameStart],\n                                      packet[frameStart + 1],\n                                      packet[frameStart + 2],\n                                      packet[frameStart + 3]);\n\n    if (frameHeader === 'PRIV') {\n      frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);\n\n      for (var i = 0; i < frame.byteLength; i++) {\n        if (frame[i] === 0) {\n          var owner = parseIso88591(frame, 0, i);\n          if (owner === 'com.apple.streaming.transportStreamTimestamp') {\n            var d = frame.subarray(i + 1);\n            var size = ((d[3] & 0x01)  << 30) |\n                       (d[4]  << 22) |\n                       (d[5] << 14) |\n                       (d[6] << 6) |\n                       (d[7] >>> 2);\n            size *= 4;\n            size += d[7] & 0x03;\n\n            return size;\n          }\n          break;\n        }\n      }\n    }\n\n    frameStart += 10; // advance past the frame header\n    frameStart += frameSize; // advance past the frame body\n  } while (frameStart < packet.byteLength);\n  return null;\n};\n\nmodule.exports = {\n  parseId3TagSize: parseId3TagSize,\n  parseAdtsSize: parseAdtsSize,\n  parseType: parseType,\n  parseSampleRate: parseSampleRate,\n  parseAacTimestamp: parseAacTimestamp\n};\n\n},{}],40:[function(require,module,exports){\n'use strict';\n\nvar Stream = require('../utils/stream.js');\n\nvar AdtsStream;\n\nvar\n  ADTS_SAMPLING_FREQUENCIES = [\n    96000,\n    88200,\n    64000,\n    48000,\n    44100,\n    32000,\n    24000,\n    22050,\n    16000,\n    12000,\n    11025,\n    8000,\n    7350\n  ];\n\n/*\n * Accepts a ElementaryStream and emits data events with parsed\n * AAC Audio Frames of the individual packets. Input audio in ADTS\n * format is unpacked and re-emitted as AAC frames.\n *\n * @see http://wiki.multimedia.cx/index.php?title=ADTS\n * @see http://wiki.multimedia.cx/?title=Understanding_AAC\n */\nAdtsStream = function() {\n  var buffer;\n\n  AdtsStream.prototype.init.call(this);\n\n  this.push = function(packet) {\n    var\n      i = 0,\n      frameNum = 0,\n      frameLength,\n      protectionSkipBytes,\n      frameEnd,\n      oldBuffer,\n      sampleCount,\n      adtsFrameDuration;\n\n    if (packet.type !== 'audio') {\n      // ignore non-audio data\n      return;\n    }\n\n    // Prepend any data in the buffer to the input data so that we can parse\n    // aac frames the cross a PES packet boundary\n    if (buffer) {\n      oldBuffer = buffer;\n      buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\n      buffer.set(oldBuffer);\n      buffer.set(packet.data, oldBuffer.byteLength);\n    } else {\n      buffer = packet.data;\n    }\n\n    // unpack any ADTS frames which have been fully received\n    // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\n    while (i + 5 < buffer.length) {\n\n      // Loook for the start of an ADTS header..\n      if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\n        // If a valid header was not found,  jump one forward and attempt to\n        // find a valid ADTS header starting at the next byte\n        i++;\n        continue;\n      }\n\n      // The protection skip bit tells us if we have 2 bytes of CRC data at the\n      // end of the ADTS header\n      protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2;\n\n      // Frame length is a 13 bit integer starting 16 bits from the\n      // end of the sync sequence\n      frameLength = ((buffer[i + 3] & 0x03) << 11) |\n        (buffer[i + 4] << 3) |\n        ((buffer[i + 5] & 0xe0) >> 5);\n\n      sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\n      adtsFrameDuration = (sampleCount * 90000) /\n        ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2];\n\n      frameEnd = i + frameLength;\n\n      // If we don't have enough data to actually finish this ADTS frame, return\n      // and wait for more data\n      if (buffer.byteLength < frameEnd) {\n        return;\n      }\n\n      // Otherwise, deliver the complete AAC frame\n      this.trigger('data', {\n        pts: packet.pts + (frameNum * adtsFrameDuration),\n        dts: packet.dts + (frameNum * adtsFrameDuration),\n        sampleCount: sampleCount,\n        audioobjecttype: ((buffer[i + 2] >>> 6) & 0x03) + 1,\n        channelcount: ((buffer[i + 2] & 1) << 2) |\n          ((buffer[i + 3] & 0xc0) >>> 6),\n        samplerate: ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2],\n        samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\n        // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\n        samplesize: 16,\n        data: buffer.subarray(i + 7 + protectionSkipBytes, frameEnd)\n      });\n\n      // If the buffer is empty, clear it and return\n      if (buffer.byteLength === frameEnd) {\n        buffer = undefined;\n        return;\n      }\n\n      frameNum++;\n\n      // Remove the finished frame from the buffer and start the process again\n      buffer = buffer.subarray(frameEnd);\n    }\n  };\n  this.flush = function() {\n    this.trigger('done');\n  };\n};\n\nAdtsStream.prototype = new Stream();\n\nmodule.exports = AdtsStream;\n\n},{\"../utils/stream.js\":62}],41:[function(require,module,exports){\n'use strict';\n\nvar Stream = require('../utils/stream.js');\nvar ExpGolomb = require('../utils/exp-golomb.js');\n\nvar H264Stream, NalByteStream;\nvar PROFILES_WITH_OPTIONAL_SPS_DATA;\n\n/**\n * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\n */\nNalByteStream = function() {\n  var\n    syncPoint = 0,\n    i,\n    buffer;\n  NalByteStream.prototype.init.call(this);\n\n  this.push = function(data) {\n    var swapBuffer;\n\n    if (!buffer) {\n      buffer = data.data;\n    } else {\n      swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\n      swapBuffer.set(buffer);\n      swapBuffer.set(data.data, buffer.byteLength);\n      buffer = swapBuffer;\n    }\n\n    // Rec. ITU-T H.264, Annex B\n    // scan for NAL unit boundaries\n\n    // a match looks like this:\n    // 0 0 1 .. NAL .. 0 0 1\n    // ^ sync point        ^ i\n    // or this:\n    // 0 0 1 .. NAL .. 0 0 0\n    // ^ sync point        ^ i\n\n    // advance the sync point to a NAL start, if necessary\n    for (; syncPoint < buffer.byteLength - 3; syncPoint++) {\n      if (buffer[syncPoint + 2] === 1) {\n        // the sync point is properly aligned\n        i = syncPoint + 5;\n        break;\n      }\n    }\n\n    while (i < buffer.byteLength) {\n      // look at the current byte to determine if we've hit the end of\n      // a NAL unit boundary\n      switch (buffer[i]) {\n      case 0:\n        // skip past non-sync sequences\n        if (buffer[i - 1] !== 0) {\n          i += 2;\n          break;\n        } else if (buffer[i - 2] !== 0) {\n          i++;\n          break;\n        }\n\n        // deliver the NAL unit if it isn't empty\n        if (syncPoint + 3 !== i - 2) {\n          this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n        }\n\n        // drop trailing zeroes\n        do {\n          i++;\n        } while (buffer[i] !== 1 && i < buffer.length);\n        syncPoint = i - 2;\n        i += 3;\n        break;\n      case 1:\n        // skip past non-sync sequences\n        if (buffer[i - 1] !== 0 ||\n            buffer[i - 2] !== 0) {\n          i += 3;\n          break;\n        }\n\n        // deliver the NAL unit\n        this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n        syncPoint = i - 2;\n        i += 3;\n        break;\n      default:\n        // the current byte isn't a one or zero, so it cannot be part\n        // of a sync sequence\n        i += 3;\n        break;\n      }\n    }\n    // filter out the NAL units that were delivered\n    buffer = buffer.subarray(syncPoint);\n    i -= syncPoint;\n    syncPoint = 0;\n  };\n\n  this.flush = function() {\n    // deliver the last buffered NAL unit\n    if (buffer && buffer.byteLength > 3) {\n      this.trigger('data', buffer.subarray(syncPoint + 3));\n    }\n    // reset the stream state\n    buffer = null;\n    syncPoint = 0;\n    this.trigger('done');\n  };\n};\nNalByteStream.prototype = new Stream();\n\n// values of profile_idc that indicate additional fields are included in the SPS\n// see Recommendation ITU-T H.264 (4/2013),\n// 7.3.2.1.1 Sequence parameter set data syntax\nPROFILES_WITH_OPTIONAL_SPS_DATA = {\n  100: true,\n  110: true,\n  122: true,\n  244: true,\n  44: true,\n  83: true,\n  86: true,\n  118: true,\n  128: true,\n  138: true,\n  139: true,\n  134: true\n};\n\n/**\n * Accepts input from a ElementaryStream and produces H.264 NAL unit data\n * events.\n */\nH264Stream = function() {\n  var\n    nalByteStream = new NalByteStream(),\n    self,\n    trackId,\n    currentPts,\n    currentDts,\n\n    discardEmulationPreventionBytes,\n    readSequenceParameterSet,\n    skipScalingList;\n\n  H264Stream.prototype.init.call(this);\n  self = this;\n\n  this.push = function(packet) {\n    if (packet.type !== 'video') {\n      return;\n    }\n    trackId = packet.trackId;\n    currentPts = packet.pts;\n    currentDts = packet.dts;\n\n    nalByteStream.push(packet);\n  };\n\n  nalByteStream.on('data', function(data) {\n    var\n      event = {\n        trackId: trackId,\n        pts: currentPts,\n        dts: currentDts,\n        data: data\n      };\n\n    switch (data[0] & 0x1f) {\n    case 0x05:\n      event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\n      break;\n    case 0x06:\n      event.nalUnitType = 'sei_rbsp';\n      event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n      break;\n    case 0x07:\n      event.nalUnitType = 'seq_parameter_set_rbsp';\n      event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n      event.config = readSequenceParameterSet(event.escapedRBSP);\n      break;\n    case 0x08:\n      event.nalUnitType = 'pic_parameter_set_rbsp';\n      break;\n    case 0x09:\n      event.nalUnitType = 'access_unit_delimiter_rbsp';\n      break;\n\n    default:\n      break;\n    }\n    self.trigger('data', event);\n  });\n  nalByteStream.on('done', function() {\n    self.trigger('done');\n  });\n\n  this.flush = function() {\n    nalByteStream.flush();\n  };\n\n  /**\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\n   * list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count {number} the number of entries in this scaling list\n   * @param expGolombDecoder {object} an ExpGolomb pointed to the\n   * start of a scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n  skipScalingList = function(count, expGolombDecoder) {\n    var\n      lastScale = 8,\n      nextScale = 8,\n      j,\n      deltaScale;\n\n    for (j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = expGolombDecoder.readExpGolomb();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n\n      lastScale = (nextScale === 0) ? lastScale : nextScale;\n    }\n  };\n\n  /**\n   * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n   * Sequence Payload\"\n   * @param data {Uint8Array} the bytes of a RBSP from a NAL\n   * unit\n   * @return {Uint8Array} the RBSP without any Emulation\n   * Prevention Bytes\n   */\n  discardEmulationPreventionBytes = function(data) {\n    var\n      length = data.byteLength,\n      emulationPreventionBytesPositions = [],\n      i = 1,\n      newLength, newData;\n\n    // Find all `Emulation Prevention Bytes`\n    while (i < length - 2) {\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2);\n        i += 2;\n      } else {\n        i++;\n      }\n    }\n\n    // If no Emulation Prevention Bytes were found just return the original\n    // array\n    if (emulationPreventionBytesPositions.length === 0) {\n      return data;\n    }\n\n    // Create a new array to hold the NAL unit data\n    newLength = length - emulationPreventionBytesPositions.length;\n    newData = new Uint8Array(newLength);\n    var sourceIndex = 0;\n\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        // Skip this byte\n        sourceIndex++;\n        // Remove this position index\n        emulationPreventionBytesPositions.shift();\n      }\n      newData[i] = data[sourceIndex];\n    }\n\n    return newData;\n  };\n\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @param data {Uint8Array} the bytes of a sequence parameter set\n   * @return {object} an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n  readSequenceParameterSet = function(data) {\n    var\n      frameCropLeftOffset = 0,\n      frameCropRightOffset = 0,\n      frameCropTopOffset = 0,\n      frameCropBottomOffset = 0,\n      sarScale = 1,\n      expGolombDecoder, profileIdc, levelIdc, profileCompatibility,\n      chromaFormatIdc, picOrderCntType,\n      numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1,\n      picHeightInMapUnitsMinus1,\n      frameMbsOnlyFlag,\n      scalingListCount,\n      sarRatio,\n      aspectRatioIdc,\n      i;\n\n    expGolombDecoder = new ExpGolomb(data);\n    profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\n    profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\n    levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\n    expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\n\n    // some profiles have more optional data we don't need\n    if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\n      chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\n      if (chromaFormatIdc === 3) {\n        expGolombDecoder.skipBits(1); // separate_colour_plane_flag\n      }\n      expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\n      expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\n      expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n      if (expGolombDecoder.readBoolean()) { // seq_scaling_matrix_present_flag\n        scalingListCount = (chromaFormatIdc !== 3) ? 8 : 12;\n        for (i = 0; i < scalingListCount; i++) {\n          if (expGolombDecoder.readBoolean()) { // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16, expGolombDecoder);\n            } else {\n              skipScalingList(64, expGolombDecoder);\n            }\n          }\n        }\n      }\n    }\n\n    expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\n    picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\n\n    if (picOrderCntType === 0) {\n      expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\n      expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\n      expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\n      numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\n      }\n    }\n\n    expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\n    expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n\n    picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n    picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n\n    frameMbsOnlyFlag = expGolombDecoder.readBits(1);\n    if (frameMbsOnlyFlag === 0) {\n      expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\n    }\n\n    expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\n    if (expGolombDecoder.readBoolean()) { // frame_cropping_flag\n      frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\n    }\n    if (expGolombDecoder.readBoolean()) {\n      // vui_parameters_present_flag\n      if (expGolombDecoder.readBoolean()) {\n        // aspect_ratio_info_present_flag\n        aspectRatioIdc = expGolombDecoder.readUnsignedByte();\n        switch (aspectRatioIdc) {\n          case 1: sarRatio = [1, 1]; break;\n          case 2: sarRatio = [12, 11]; break;\n          case 3: sarRatio = [10, 11]; break;\n          case 4: sarRatio = [16, 11]; break;\n          case 5: sarRatio = [40, 33]; break;\n          case 6: sarRatio = [24, 11]; break;\n          case 7: sarRatio = [20, 11]; break;\n          case 8: sarRatio = [32, 11]; break;\n          case 9: sarRatio = [80, 33]; break;\n          case 10: sarRatio = [18, 11]; break;\n          case 11: sarRatio = [15, 11]; break;\n          case 12: sarRatio = [64, 33]; break;\n          case 13: sarRatio = [160, 99]; break;\n          case 14: sarRatio = [4, 3]; break;\n          case 15: sarRatio = [3, 2]; break;\n          case 16: sarRatio = [2, 1]; break;\n          case 255: {\n            sarRatio = [expGolombDecoder.readUnsignedByte() << 8 |\n                        expGolombDecoder.readUnsignedByte(),\n                        expGolombDecoder.readUnsignedByte() << 8 |\n                        expGolombDecoder.readUnsignedByte() ];\n            break;\n          }\n        }\n        if (sarRatio) {\n          sarScale = sarRatio[0] / sarRatio[1];\n        }\n      }\n    }\n    return {\n      profileIdc: profileIdc,\n      levelIdc: levelIdc,\n      profileCompatibility: profileCompatibility,\n      width: Math.ceil((((picWidthInMbsMinus1 + 1) * 16) - frameCropLeftOffset * 2 - frameCropRightOffset * 2) * sarScale),\n      height: ((2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16) - (frameCropTopOffset * 2) - (frameCropBottomOffset * 2)\n    };\n  };\n\n};\nH264Stream.prototype = new Stream();\n\nmodule.exports = {\n  H264Stream: H264Stream,\n  NalByteStream: NalByteStream\n};\n\n},{\"../utils/exp-golomb.js\":61,\"../utils/stream.js\":62}],42:[function(require,module,exports){\nvar highPrefix = [33, 16, 5, 32, 164, 27];\nvar lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];\nvar zeroFill = function(count) {\n  var a = [];\n  while (count--) {\n    a.push(0);\n  }\n  return a;\n};\n\nvar makeTable = function(metaTable) {\n  return Object.keys(metaTable).reduce(function(obj, key) {\n    obj[key] = new Uint8Array(metaTable[key].reduce(function(arr, part) {\n      return arr.concat(part);\n    }, []));\n    return obj;\n  }, {});\n};\n\n// Frames-of-silence to use for filling in missing AAC frames\nvar coneOfSilence = {\n  96000: [highPrefix, [227, 64], zeroFill(154), [56]],\n  88200: [highPrefix, [231], zeroFill(170), [56]],\n  64000: [highPrefix, [248, 192], zeroFill(240), [56]],\n  48000: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],\n  44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],\n  32000: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],\n  24000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],\n  16000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],\n  12000: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],\n  11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],\n  8000: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]\n};\n\nmodule.exports = makeTable(coneOfSilence);\n\n},{}],43:[function(require,module,exports){\n'use strict';\n\nvar Stream = require('../utils/stream.js');\n\n/**\n * The final stage of the transmuxer that emits the flv tags\n * for audio, video, and metadata. Also tranlates in time and\n * outputs caption data and id3 cues.\n */\nvar CoalesceStream = function(options) {\n  // Number of Tracks per output segment\n  // If greater than 1, we combine multiple\n  // tracks into a single segment\n  this.numberOfTracks = 0;\n  this.metadataStream = options.metadataStream;\n\n  this.videoTags = [];\n  this.audioTags = [];\n  this.videoTrack = null;\n  this.audioTrack = null;\n  this.pendingCaptions = [];\n  this.pendingMetadata = [];\n  this.pendingTracks = 0;\n  this.processedTracks = 0;\n\n  CoalesceStream.prototype.init.call(this);\n\n  // Take output from multiple\n  this.push = function(output) {\n    // buffer incoming captions until the associated video segment\n    // finishes\n    if (output.text) {\n      return this.pendingCaptions.push(output);\n    }\n    // buffer incoming id3 tags until the final flush\n    if (output.frames) {\n      return this.pendingMetadata.push(output);\n    }\n\n    if (output.track.type === 'video') {\n      this.videoTrack = output.track;\n      this.videoTags = output.tags;\n      this.pendingTracks++;\n    }\n    if (output.track.type === 'audio') {\n      this.audioTrack = output.track;\n      this.audioTags = output.tags;\n      this.pendingTracks++;\n    }\n  };\n};\n\nCoalesceStream.prototype = new Stream();\nCoalesceStream.prototype.flush = function(flushSource) {\n  var\n    id3,\n    caption,\n    i,\n    timelineStartPts,\n    event = {\n      tags: {},\n      captions: [],\n      captionStreams: {},\n      metadata: []\n    };\n\n  if (this.pendingTracks < this.numberOfTracks) {\n    if (flushSource !== 'VideoSegmentStream' &&\n        flushSource !== 'AudioSegmentStream') {\n      // Return because we haven't received a flush from a data-generating\n      // portion of the segment (meaning that we have only recieved meta-data\n      // or captions.)\n      return;\n    } else if (this.pendingTracks === 0) {\n      // In the case where we receive a flush without any data having been\n      // received we consider it an emitted track for the purposes of coalescing\n      // `done` events.\n      // We do this for the case where there is an audio and video track in the\n      // segment but no audio data. (seen in several playlists with alternate\n      // audio tracks and no audio present in the main TS segments.)\n      this.processedTracks++;\n\n      if (this.processedTracks < this.numberOfTracks) {\n        return;\n      }\n    }\n  }\n\n  this.processedTracks += this.pendingTracks;\n  this.pendingTracks = 0;\n\n  if (this.processedTracks < this.numberOfTracks) {\n    return;\n  }\n\n  if (this.videoTrack) {\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n  } else if (this.audioTrack) {\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n  }\n\n  event.tags.videoTags = this.videoTags;\n  event.tags.audioTags = this.audioTags;\n\n  // Translate caption PTS times into second offsets into the\n  // video timeline for the segment, and add track info\n  for (i = 0; i < this.pendingCaptions.length; i++) {\n    caption = this.pendingCaptions[i];\n    caption.startTime = caption.startPts - timelineStartPts;\n    caption.startTime /= 90e3;\n    caption.endTime = caption.endPts - timelineStartPts;\n    caption.endTime /= 90e3;\n    event.captionStreams[caption.stream] = true;\n    event.captions.push(caption);\n  }\n\n  // Translate ID3 frame PTS times into second offsets into the\n  // video timeline for the segment\n  for (i = 0; i < this.pendingMetadata.length; i++) {\n    id3 = this.pendingMetadata[i];\n    id3.cueTime = id3.pts - timelineStartPts;\n    id3.cueTime /= 90e3;\n    event.metadata.push(id3);\n  }\n  // We add this to every single emitted segment even though we only need\n  // it for the first\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\n\n  // Reset stream state\n  this.videoTrack = null;\n  this.audioTrack = null;\n  this.videoTags = [];\n  this.audioTags = [];\n  this.pendingCaptions.length = 0;\n  this.pendingMetadata.length = 0;\n  this.pendingTracks = 0;\n  this.processedTracks = 0;\n\n  // Emit the final segment\n  this.trigger('data', event);\n\n  this.trigger('done');\n};\n\nmodule.exports = CoalesceStream;\n\n},{\"../utils/stream.js\":62}],44:[function(require,module,exports){\n'use strict';\n\nvar FlvTag = require('./flv-tag.js');\n\n// For information on the FLV format, see\n// http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf.\n// Technically, this function returns the header and a metadata FLV tag\n// if duration is greater than zero\n// duration in seconds\n// @return {object} the bytes of the FLV header as a Uint8Array\nvar getFlvHeader = function(duration, audio, video) { // :ByteArray {\n  var\n    headBytes = new Uint8Array(3 + 1 + 1 + 4),\n    head = new DataView(headBytes.buffer),\n    metadata,\n    result,\n    metadataLength;\n\n  // default arguments\n  duration = duration || 0;\n  audio = audio === undefined ? true : audio;\n  video = video === undefined ? true : video;\n\n  // signature\n  head.setUint8(0, 0x46); // 'F'\n  head.setUint8(1, 0x4c); // 'L'\n  head.setUint8(2, 0x56); // 'V'\n\n  // version\n  head.setUint8(3, 0x01);\n\n  // flags\n  head.setUint8(4, (audio ? 0x04 : 0x00) | (video ? 0x01 : 0x00));\n\n  // data offset, should be 9 for FLV v1\n  head.setUint32(5, headBytes.byteLength);\n\n  // init the first FLV tag\n  if (duration <= 0) {\n    // no duration available so just write the first field of the first\n    // FLV tag\n    result = new Uint8Array(headBytes.byteLength + 4);\n    result.set(headBytes);\n    result.set([0, 0, 0, 0], headBytes.byteLength);\n    return result;\n  }\n\n  // write out the duration metadata tag\n  metadata = new FlvTag(FlvTag.METADATA_TAG);\n  metadata.pts = metadata.dts = 0;\n  metadata.writeMetaDataDouble('duration', duration);\n  metadataLength = metadata.finalize().length;\n  result = new Uint8Array(headBytes.byteLength + metadataLength);\n  result.set(headBytes);\n  result.set(head.byteLength, metadataLength);\n\n  return result;\n};\n\nmodule.exports = getFlvHeader;\n\n},{\"./flv-tag.js\":45}],45:[function(require,module,exports){\n/**\n * An object that stores the bytes of an FLV tag and methods for\n * querying and manipulating that data.\n * @see http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf\n */\n'use strict';\n\nvar FlvTag;\n\n// (type:uint, extraData:Boolean = false) extends ByteArray\nFlvTag = function(type, extraData) {\n  var\n    // Counter if this is a metadata tag, nal start marker if this is a video\n    // tag. unused if this is an audio tag\n    adHoc = 0, // :uint\n\n    // The default size is 16kb but this is not enough to hold iframe\n    // data and the resizing algorithm costs a bit so we create a larger\n    // starting buffer for video tags\n    bufferStartSize = 16384,\n\n    // checks whether the FLV tag has enough capacity to accept the proposed\n    // write and re-allocates the internal buffers if necessary\n    prepareWrite = function(flv, count) {\n      var\n        bytes,\n        minLength = flv.position + count;\n      if (minLength < flv.bytes.byteLength) {\n        // there's enough capacity so do nothing\n        return;\n      }\n\n      // allocate a new buffer and copy over the data that will not be modified\n      bytes = new Uint8Array(minLength * 2);\n      bytes.set(flv.bytes.subarray(0, flv.position), 0);\n      flv.bytes = bytes;\n      flv.view = new DataView(flv.bytes.buffer);\n    },\n\n    // commonly used metadata properties\n    widthBytes = FlvTag.widthBytes || new Uint8Array('width'.length),\n    heightBytes = FlvTag.heightBytes || new Uint8Array('height'.length),\n    videocodecidBytes = FlvTag.videocodecidBytes || new Uint8Array('videocodecid'.length),\n    i;\n\n  if (!FlvTag.widthBytes) {\n    // calculating the bytes of common metadata names ahead of time makes the\n    // corresponding writes faster because we don't have to loop over the\n    // characters\n    // re-test with test/perf.html if you're planning on changing this\n    for (i = 0; i < 'width'.length; i++) {\n      widthBytes[i] = 'width'.charCodeAt(i);\n    }\n    for (i = 0; i < 'height'.length; i++) {\n      heightBytes[i] = 'height'.charCodeAt(i);\n    }\n    for (i = 0; i < 'videocodecid'.length; i++) {\n      videocodecidBytes[i] = 'videocodecid'.charCodeAt(i);\n    }\n\n    FlvTag.widthBytes = widthBytes;\n    FlvTag.heightBytes = heightBytes;\n    FlvTag.videocodecidBytes = videocodecidBytes;\n  }\n\n  this.keyFrame = false; // :Boolean\n\n  switch (type) {\n  case FlvTag.VIDEO_TAG:\n    this.length = 16;\n    // Start the buffer at 256k\n    bufferStartSize *= 6;\n    break;\n  case FlvTag.AUDIO_TAG:\n    this.length = 13;\n    this.keyFrame = true;\n    break;\n  case FlvTag.METADATA_TAG:\n    this.length = 29;\n    this.keyFrame = true;\n    break;\n  default:\n    throw new Error('Unknown FLV tag type');\n  }\n\n  this.bytes = new Uint8Array(bufferStartSize);\n  this.view = new DataView(this.bytes.buffer);\n  this.bytes[0] = type;\n  this.position = this.length;\n  this.keyFrame = extraData; // Defaults to false\n\n  // presentation timestamp\n  this.pts = 0;\n  // decoder timestamp\n  this.dts = 0;\n\n  // ByteArray#writeBytes(bytes:ByteArray, offset:uint = 0, length:uint = 0)\n  this.writeBytes = function(bytes, offset, length) {\n    var\n      start = offset || 0,\n      end;\n    length = length || bytes.byteLength;\n    end = start + length;\n\n    prepareWrite(this, length);\n    this.bytes.set(bytes.subarray(start, end), this.position);\n\n    this.position += length;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // ByteArray#writeByte(value:int):void\n  this.writeByte = function(byte) {\n    prepareWrite(this, 1);\n    this.bytes[this.position] = byte;\n    this.position++;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // ByteArray#writeShort(value:int):void\n  this.writeShort = function(short) {\n    prepareWrite(this, 2);\n    this.view.setUint16(this.position, short);\n    this.position += 2;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // Negative index into array\n  // (pos:uint):int\n  this.negIndex = function(pos) {\n    return this.bytes[this.length - pos];\n  };\n\n  // The functions below ONLY work when this[0] == VIDEO_TAG.\n  // We are not going to check for that because we dont want the overhead\n  // (nal:ByteArray = null):int\n  this.nalUnitSize = function() {\n    if (adHoc === 0) {\n      return 0;\n    }\n\n    return this.length - (adHoc + 4);\n  };\n\n  this.startNalUnit = function() {\n    // remember position and add 4 bytes\n    if (adHoc > 0) {\n      throw new Error('Attempted to create new NAL wihout closing the old one');\n    }\n\n    // reserve 4 bytes for nal unit size\n    adHoc = this.length;\n    this.length += 4;\n    this.position = this.length;\n  };\n\n  // (nal:ByteArray = null):void\n  this.endNalUnit = function(nalContainer) {\n    var\n      nalStart, // :uint\n      nalLength; // :uint\n\n    // Rewind to the marker and write the size\n    if (this.length === adHoc + 4) {\n      // we started a nal unit, but didnt write one, so roll back the 4 byte size value\n      this.length -= 4;\n    } else if (adHoc > 0) {\n      nalStart = adHoc + 4;\n      nalLength = this.length - nalStart;\n\n      this.position = adHoc;\n      this.view.setUint32(this.position, nalLength);\n      this.position = this.length;\n\n      if (nalContainer) {\n        // Add the tag to the NAL unit\n        nalContainer.push(this.bytes.subarray(nalStart, nalStart + nalLength));\n      }\n    }\n\n    adHoc = 0;\n  };\n\n  /**\n   * Write out a 64-bit floating point valued metadata property. This method is\n   * called frequently during a typical parse and needs to be fast.\n   */\n  // (key:String, val:Number):void\n  this.writeMetaDataDouble = function(key, val) {\n    var i;\n    prepareWrite(this, 2 + key.length + 9);\n\n    // write size of property name\n    this.view.setUint16(this.position, key.length);\n    this.position += 2;\n\n    // this next part looks terrible but it improves parser throughput by\n    // 10kB/s in my testing\n\n    // write property name\n    if (key === 'width') {\n      this.bytes.set(widthBytes, this.position);\n      this.position += 5;\n    } else if (key === 'height') {\n      this.bytes.set(heightBytes, this.position);\n      this.position += 6;\n    } else if (key === 'videocodecid') {\n      this.bytes.set(videocodecidBytes, this.position);\n      this.position += 12;\n    } else {\n      for (i = 0; i < key.length; i++) {\n        this.bytes[this.position] = key.charCodeAt(i);\n        this.position++;\n      }\n    }\n\n    // skip null byte\n    this.position++;\n\n    // write property value\n    this.view.setFloat64(this.position, val);\n    this.position += 8;\n\n    // update flv tag length\n    this.length = Math.max(this.length, this.position);\n    ++adHoc;\n  };\n\n  // (key:String, val:Boolean):void\n  this.writeMetaDataBoolean = function(key, val) {\n    var i;\n    prepareWrite(this, 2);\n    this.view.setUint16(this.position, key.length);\n    this.position += 2;\n    for (i = 0; i < key.length; i++) {\n      // if key.charCodeAt(i) >= 255, handle error\n      prepareWrite(this, 1);\n      this.bytes[this.position] = key.charCodeAt(i);\n      this.position++;\n    }\n    prepareWrite(this, 2);\n    this.view.setUint8(this.position, 0x01);\n    this.position++;\n    this.view.setUint8(this.position, val ? 0x01 : 0x00);\n    this.position++;\n    this.length = Math.max(this.length, this.position);\n    ++adHoc;\n  };\n\n  // ():ByteArray\n  this.finalize = function() {\n    var\n      dtsDelta, // :int\n      len; // :int\n\n    switch (this.bytes[0]) {\n      // Video Data\n    case FlvTag.VIDEO_TAG:\n       // We only support AVC, 1 = key frame (for AVC, a seekable\n       // frame), 2 = inter frame (for AVC, a non-seekable frame)\n      this.bytes[11] = ((this.keyFrame || extraData) ? 0x10 : 0x20) | 0x07;\n      this.bytes[12] = extraData ?  0x00 : 0x01;\n\n      dtsDelta = this.pts - this.dts;\n      this.bytes[13] = (dtsDelta & 0x00FF0000) >>> 16;\n      this.bytes[14] = (dtsDelta & 0x0000FF00) >>>  8;\n      this.bytes[15] = (dtsDelta & 0x000000FF) >>>  0;\n      break;\n\n    case FlvTag.AUDIO_TAG:\n      this.bytes[11] = 0xAF; // 44 kHz, 16-bit stereo\n      this.bytes[12] = extraData ? 0x00 : 0x01;\n      break;\n\n    case FlvTag.METADATA_TAG:\n      this.position = 11;\n      this.view.setUint8(this.position, 0x02); // String type\n      this.position++;\n      this.view.setUint16(this.position, 0x0A); // 10 Bytes\n      this.position += 2;\n      // set \"onMetaData\"\n      this.bytes.set([0x6f, 0x6e, 0x4d, 0x65,\n                      0x74, 0x61, 0x44, 0x61,\n                      0x74, 0x61], this.position);\n      this.position += 10;\n      this.bytes[this.position] = 0x08; // Array type\n      this.position++;\n      this.view.setUint32(this.position, adHoc);\n      this.position = this.length;\n      this.bytes.set([0, 0, 9], this.position);\n      this.position += 3; // End Data Tag\n      this.length = this.position;\n      break;\n    }\n\n    len = this.length - 11;\n\n    // write the DataSize field\n    this.bytes[ 1] = (len & 0x00FF0000) >>> 16;\n    this.bytes[ 2] = (len & 0x0000FF00) >>>  8;\n    this.bytes[ 3] = (len & 0x000000FF) >>>  0;\n    // write the Timestamp\n    this.bytes[ 4] = (this.dts & 0x00FF0000) >>> 16;\n    this.bytes[ 5] = (this.dts & 0x0000FF00) >>>  8;\n    this.bytes[ 6] = (this.dts & 0x000000FF) >>>  0;\n    this.bytes[ 7] = (this.dts & 0xFF000000) >>> 24;\n    // write the StreamID\n    this.bytes[ 8] = 0;\n    this.bytes[ 9] = 0;\n    this.bytes[10] = 0;\n\n    // Sometimes we're at the end of the view and have one slot to write a\n    // uint32, so, prepareWrite of count 4, since, view is uint8\n    prepareWrite(this, 4);\n    this.view.setUint32(this.length, this.length);\n    this.length += 4;\n    this.position += 4;\n\n    // trim down the byte buffer to what is actually being used\n    this.bytes = this.bytes.subarray(0, this.length);\n    this.frameTime = FlvTag.frameTime(this.bytes);\n    // if bytes.bytelength isn't equal to this.length, handle error\n    return this;\n  };\n};\n\nFlvTag.AUDIO_TAG = 0x08; // == 8, :uint\nFlvTag.VIDEO_TAG = 0x09; // == 9, :uint\nFlvTag.METADATA_TAG = 0x12; // == 18, :uint\n\n// (tag:ByteArray):Boolean {\nFlvTag.isAudioFrame = function(tag) {\n  return FlvTag.AUDIO_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isVideoFrame = function(tag) {\n  return FlvTag.VIDEO_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isMetaData = function(tag) {\n  return FlvTag.METADATA_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isKeyFrame = function(tag) {\n  if (FlvTag.isVideoFrame(tag)) {\n    return tag[11] === 0x17;\n  }\n\n  if (FlvTag.isAudioFrame(tag)) {\n    return true;\n  }\n\n  if (FlvTag.isMetaData(tag)) {\n    return true;\n  }\n\n  return false;\n};\n\n// (tag:ByteArray):uint {\nFlvTag.frameTime = function(tag) {\n  var pts = tag[ 4] << 16; // :uint\n  pts |= tag[ 5] <<  8;\n  pts |= tag[ 6] <<  0;\n  pts |= tag[ 7] << 24;\n  return pts;\n};\n\nmodule.exports = FlvTag;\n\n},{}],46:[function(require,module,exports){\nmodule.exports = {\n  tag: require('./flv-tag'),\n  Transmuxer: require('./transmuxer'),\n  getFlvHeader: require('./flv-header')\n};\n\n},{\"./flv-header\":44,\"./flv-tag\":45,\"./transmuxer\":48}],47:[function(require,module,exports){\n'use strict';\n\nvar TagList = function() {\n  var self = this;\n\n  this.list = [];\n\n  this.push = function(tag) {\n    this.list.push({\n      bytes: tag.bytes,\n      dts: tag.dts,\n      pts: tag.pts,\n      keyFrame: tag.keyFrame,\n      metaDataTag: tag.metaDataTag\n    });\n  };\n\n  Object.defineProperty(this, 'length', {\n    get: function() {\n      return self.list.length;\n    }\n  });\n};\n\nmodule.exports = TagList;\n\n},{}],48:[function(require,module,exports){\n'use strict';\n\nvar Stream = require('../utils/stream.js');\nvar FlvTag = require('./flv-tag.js');\nvar m2ts = require('../m2ts/m2ts.js');\nvar AdtsStream = require('../codecs/adts.js');\nvar H264Stream = require('../codecs/h264').H264Stream;\nvar CoalesceStream = require('./coalesce-stream.js');\nvar TagList = require('./tag-list.js');\n\nvar\n  Transmuxer,\n  VideoSegmentStream,\n  AudioSegmentStream,\n  collectTimelineInfo,\n  metaDataTag,\n  extraDataTag;\n\n/**\n * Store information about the start and end of the tracka and the\n * duration for each frame/sample we process in order to calculate\n * the baseMediaDecodeTime\n */\ncollectTimelineInfo = function(track, data) {\n  if (typeof data.pts === 'number') {\n    if (track.timelineStartInfo.pts === undefined) {\n      track.timelineStartInfo.pts = data.pts;\n    } else {\n      track.timelineStartInfo.pts =\n        Math.min(track.timelineStartInfo.pts, data.pts);\n    }\n  }\n\n  if (typeof data.dts === 'number') {\n    if (track.timelineStartInfo.dts === undefined) {\n      track.timelineStartInfo.dts = data.dts;\n    } else {\n      track.timelineStartInfo.dts =\n        Math.min(track.timelineStartInfo.dts, data.dts);\n    }\n  }\n};\n\nmetaDataTag = function(track, pts) {\n  var\n    tag = new FlvTag(FlvTag.METADATA_TAG); // :FlvTag\n\n  tag.dts = pts;\n  tag.pts = pts;\n\n  tag.writeMetaDataDouble('videocodecid', 7);\n  tag.writeMetaDataDouble('width', track.width);\n  tag.writeMetaDataDouble('height', track.height);\n\n  return tag;\n};\n\nextraDataTag = function(track, pts) {\n  var\n    i,\n    tag = new FlvTag(FlvTag.VIDEO_TAG, true);\n\n  tag.dts = pts;\n  tag.pts = pts;\n\n  tag.writeByte(0x01);// version\n  tag.writeByte(track.profileIdc);// profile\n  tag.writeByte(track.profileCompatibility);// compatibility\n  tag.writeByte(track.levelIdc);// level\n  tag.writeByte(0xFC | 0x03); // reserved (6 bits), NULA length size - 1 (2 bits)\n  tag.writeByte(0xE0 | 0x01); // reserved (3 bits), num of SPS (5 bits)\n  tag.writeShort(track.sps[0].length); // data of SPS\n  tag.writeBytes(track.sps[0]); // SPS\n\n  tag.writeByte(track.pps.length); // num of PPS (will there ever be more that 1 PPS?)\n  for (i = 0; i < track.pps.length; ++i) {\n    tag.writeShort(track.pps[i].length); // 2 bytes for length of PPS\n    tag.writeBytes(track.pps[i]); // data of PPS\n  }\n\n  return tag;\n};\n\n/**\n * Constructs a single-track, media segment from AAC data\n * events. The output of this stream can be fed to flash.\n */\nAudioSegmentStream = function(track) {\n  var\n    adtsFrames = [],\n    videoKeyFrames = [],\n    oldExtraData;\n\n  AudioSegmentStream.prototype.init.call(this);\n\n  this.push = function(data) {\n    collectTimelineInfo(track, data);\n\n    if (track) {\n      track.audioobjecttype = data.audioobjecttype;\n      track.channelcount = data.channelcount;\n      track.samplerate = data.samplerate;\n      track.samplingfrequencyindex = data.samplingfrequencyindex;\n      track.samplesize = data.samplesize;\n      track.extraData = (track.audioobjecttype << 11) |\n                        (track.samplingfrequencyindex << 7) |\n                        (track.channelcount << 3);\n    }\n\n    data.pts = Math.round(data.pts / 90);\n    data.dts = Math.round(data.dts / 90);\n\n    // buffer audio data until end() is called\n    adtsFrames.push(data);\n  };\n\n  this.flush = function() {\n    var currentFrame, adtsFrame, lastMetaPts, tags = new TagList();\n    // return early if no audio data has been observed\n    if (adtsFrames.length === 0) {\n      this.trigger('done', 'AudioSegmentStream');\n      return;\n    }\n\n    lastMetaPts = -Infinity;\n\n    while (adtsFrames.length) {\n      currentFrame = adtsFrames.shift();\n\n      // write out a metadata frame at every video key frame\n      if (videoKeyFrames.length && currentFrame.pts >= videoKeyFrames[0]) {\n        lastMetaPts = videoKeyFrames.shift();\n        this.writeMetaDataTags(tags, lastMetaPts);\n      }\n\n      // also write out metadata tags every 1 second so that the decoder\n      // is re-initialized quickly after seeking into a different\n      // audio configuration.\n      if (track.extraData !== oldExtraData || currentFrame.pts - lastMetaPts >= 1000) {\n        this.writeMetaDataTags(tags, currentFrame.pts);\n        oldExtraData = track.extraData;\n        lastMetaPts = currentFrame.pts;\n      }\n\n      adtsFrame = new FlvTag(FlvTag.AUDIO_TAG);\n      adtsFrame.pts = currentFrame.pts;\n      adtsFrame.dts = currentFrame.dts;\n\n      adtsFrame.writeBytes(currentFrame.data);\n\n      tags.push(adtsFrame.finalize());\n    }\n\n    videoKeyFrames.length = 0;\n    oldExtraData = null;\n    this.trigger('data', {track: track, tags: tags.list});\n\n    this.trigger('done', 'AudioSegmentStream');\n  };\n\n  this.writeMetaDataTags = function(tags, pts) {\n    var adtsFrame;\n\n    adtsFrame = new FlvTag(FlvTag.METADATA_TAG);\n    // For audio, DTS is always the same as PTS. We want to set the DTS\n    // however so we can compare with video DTS to determine approximate\n    // packet order\n    adtsFrame.pts = pts;\n    adtsFrame.dts = pts;\n\n    // AAC is always 10\n    adtsFrame.writeMetaDataDouble('audiocodecid', 10);\n    adtsFrame.writeMetaDataBoolean('stereo', track.channelcount === 2);\n    adtsFrame.writeMetaDataDouble('audiosamplerate', track.samplerate);\n    // Is AAC always 16 bit?\n    adtsFrame.writeMetaDataDouble('audiosamplesize', 16);\n\n    tags.push(adtsFrame.finalize());\n\n    adtsFrame = new FlvTag(FlvTag.AUDIO_TAG, true);\n    // For audio, DTS is always the same as PTS. We want to set the DTS\n    // however so we can compare with video DTS to determine approximate\n    // packet order\n    adtsFrame.pts = pts;\n    adtsFrame.dts = pts;\n\n    adtsFrame.view.setUint16(adtsFrame.position, track.extraData);\n    adtsFrame.position += 2;\n    adtsFrame.length = Math.max(adtsFrame.length, adtsFrame.position);\n\n    tags.push(adtsFrame.finalize());\n  };\n\n  this.onVideoKeyFrame = function(pts) {\n    videoKeyFrames.push(pts);\n  };\n};\nAudioSegmentStream.prototype = new Stream();\n\n/**\n * Store FlvTags for the h264 stream\n * @param track {object} track metadata configuration\n */\nVideoSegmentStream = function(track) {\n  var\n    nalUnits = [],\n    config,\n    h264Frame;\n  VideoSegmentStream.prototype.init.call(this);\n\n  this.finishFrame = function(tags, frame) {\n    if (!frame) {\n      return;\n    }\n    // Check if keyframe and the length of tags.\n    // This makes sure we write metadata on the first frame of a segment.\n    if (config && track && track.newMetadata &&\n        (frame.keyFrame || tags.length === 0)) {\n      // Push extra data on every IDR frame in case we did a stream change + seek\n      var metaTag = metaDataTag(config, frame.dts).finalize();\n      var extraTag = extraDataTag(track, frame.dts).finalize();\n\n      metaTag.metaDataTag = extraTag.metaDataTag = true;\n\n      tags.push(metaTag);\n      tags.push(extraTag);\n      track.newMetadata = false;\n\n      this.trigger('keyframe', frame.dts);\n    }\n\n    frame.endNalUnit();\n    tags.push(frame.finalize());\n    h264Frame = null;\n  };\n\n  this.push = function(data) {\n    collectTimelineInfo(track, data);\n\n    data.pts = Math.round(data.pts / 90);\n    data.dts = Math.round(data.dts / 90);\n\n    // buffer video until flush() is called\n    nalUnits.push(data);\n  };\n\n  this.flush = function() {\n    var\n      currentNal,\n      tags = new TagList();\n\n    // Throw away nalUnits at the start of the byte stream until we find\n    // the first AUD\n    while (nalUnits.length) {\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n        break;\n      }\n      nalUnits.shift();\n    }\n\n    // return early if no video data has been observed\n    if (nalUnits.length === 0) {\n      this.trigger('done', 'VideoSegmentStream');\n      return;\n    }\n\n    while (nalUnits.length) {\n      currentNal = nalUnits.shift();\n\n      // record the track config\n      if (currentNal.nalUnitType === 'seq_parameter_set_rbsp') {\n        track.newMetadata = true;\n        config = currentNal.config;\n        track.width = config.width;\n        track.height = config.height;\n        track.sps = [currentNal.data];\n        track.profileIdc = config.profileIdc;\n        track.levelIdc = config.levelIdc;\n        track.profileCompatibility = config.profileCompatibility;\n        h264Frame.endNalUnit();\n      } else if (currentNal.nalUnitType === 'pic_parameter_set_rbsp') {\n        track.newMetadata = true;\n        track.pps = [currentNal.data];\n        h264Frame.endNalUnit();\n      } else if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n        if (h264Frame) {\n          this.finishFrame(tags, h264Frame);\n        }\n        h264Frame = new FlvTag(FlvTag.VIDEO_TAG);\n        h264Frame.pts = currentNal.pts;\n        h264Frame.dts = currentNal.dts;\n      } else {\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n          // the current sample is a key frame\n          h264Frame.keyFrame = true;\n        }\n        h264Frame.endNalUnit();\n      }\n      h264Frame.startNalUnit();\n      h264Frame.writeBytes(currentNal.data);\n    }\n    if (h264Frame) {\n      this.finishFrame(tags, h264Frame);\n    }\n\n    this.trigger('data', {track: track, tags: tags.list});\n\n    // Continue with the flush process now\n    this.trigger('done', 'VideoSegmentStream');\n  };\n};\n\nVideoSegmentStream.prototype = new Stream();\n\n/**\n * An object that incrementally transmuxes MPEG2 Trasport Stream\n * chunks into an FLV.\n */\nTransmuxer = function(options) {\n  var\n    self = this,\n\n    packetStream, parseStream, elementaryStream,\n    videoTimestampRolloverStream, audioTimestampRolloverStream,\n    timedMetadataTimestampRolloverStream,\n    adtsStream, h264Stream,\n    videoSegmentStream, audioSegmentStream, captionStream,\n    coalesceStream;\n\n  Transmuxer.prototype.init.call(this);\n\n  options = options || {};\n\n  // expose the metadata stream\n  this.metadataStream = new m2ts.MetadataStream();\n\n  options.metadataStream = this.metadataStream;\n\n  // set up the parsing pipeline\n  packetStream = new m2ts.TransportPacketStream();\n  parseStream = new m2ts.TransportParseStream();\n  elementaryStream = new m2ts.ElementaryStream();\n  videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\n  audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n  timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n\n  adtsStream = new AdtsStream();\n  h264Stream = new H264Stream();\n  coalesceStream = new CoalesceStream(options);\n\n  // disassemble MPEG2-TS packets into elementary streams\n  packetStream\n    .pipe(parseStream)\n    .pipe(elementaryStream);\n\n  // !!THIS ORDER IS IMPORTANT!!\n  // demux the streams\n  elementaryStream\n    .pipe(videoTimestampRolloverStream)\n    .pipe(h264Stream);\n  elementaryStream\n    .pipe(audioTimestampRolloverStream)\n    .pipe(adtsStream);\n\n  elementaryStream\n    .pipe(timedMetadataTimestampRolloverStream)\n    .pipe(this.metadataStream)\n    .pipe(coalesceStream);\n  // if CEA-708 parsing is available, hook up a caption stream\n  captionStream = new m2ts.CaptionStream();\n  h264Stream.pipe(captionStream)\n    .pipe(coalesceStream);\n\n  // hook up the segment streams once track metadata is delivered\n  elementaryStream.on('data', function(data) {\n    var i, videoTrack, audioTrack;\n\n    if (data.type === 'metadata') {\n      i = data.tracks.length;\n\n      // scan the tracks listed in the metadata\n      while (i--) {\n        if (data.tracks[i].type === 'video') {\n          videoTrack = data.tracks[i];\n        } else if (data.tracks[i].type === 'audio') {\n          audioTrack = data.tracks[i];\n        }\n      }\n\n      // hook up the video segment stream to the first track with h264 data\n      if (videoTrack && !videoSegmentStream) {\n        coalesceStream.numberOfTracks++;\n        videoSegmentStream = new VideoSegmentStream(videoTrack);\n\n        // Set up the final part of the video pipeline\n        h264Stream\n          .pipe(videoSegmentStream)\n          .pipe(coalesceStream);\n      }\n\n      if (audioTrack && !audioSegmentStream) {\n        // hook up the audio segment stream to the first track with aac data\n        coalesceStream.numberOfTracks++;\n        audioSegmentStream = new AudioSegmentStream(audioTrack);\n\n        // Set up the final part of the audio pipeline\n        adtsStream\n          .pipe(audioSegmentStream)\n          .pipe(coalesceStream);\n\n        if (videoSegmentStream) {\n          videoSegmentStream.on('keyframe', audioSegmentStream.onVideoKeyFrame);\n        }\n      }\n    }\n  });\n\n  // feed incoming data to the front of the parsing pipeline\n  this.push = function(data) {\n    packetStream.push(data);\n  };\n\n  // flush any buffered data\n  this.flush = function() {\n    // Start at the top of the pipeline and flush all pending work\n    packetStream.flush();\n  };\n\n  // Caption data has to be reset when seeking outside buffered range\n  this.resetCaptions = function() {\n    captionStream.reset();\n  };\n\n  // Re-emit any data coming from the coalesce stream to the outside world\n  coalesceStream.on('data', function(event) {\n    self.trigger('data', event);\n  });\n\n  // Let the consumer know we have finished flushing the entire pipeline\n  coalesceStream.on('done', function() {\n    self.trigger('done');\n  });\n};\nTransmuxer.prototype = new Stream();\n\n// forward compatibility\nmodule.exports = Transmuxer;\n\n},{\"../codecs/adts.js\":40,\"../codecs/h264\":41,\"../m2ts/m2ts.js\":50,\"../utils/stream.js\":62,\"./coalesce-stream.js\":43,\"./flv-tag.js\":45,\"./tag-list.js\":47}],49:[function(require,module,exports){\n/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Reads in-band caption information from a video elementary\n * stream. Captions must follow the CEA-708 standard for injection\n * into an MPEG-2 transport streams.\n * @see https://en.wikipedia.org/wiki/CEA-708\n * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n */\n\n'use strict';\n\n// -----------------\n// Link To Transport\n// -----------------\n\n// Supplemental enhancement information (SEI) NAL units have a\n// payload type field to indicate how they are to be\n// interpreted. CEAS-708 caption content is always transmitted with\n// payload type 0x04.\nvar USER_DATA_REGISTERED_ITU_T_T35 = 4,\n    RBSP_TRAILING_BITS = 128,\n    Stream = require('../utils/stream');\n\n/**\n  * Parse a supplemental enhancement information (SEI) NAL unit.\n  * Stops parsing once a message of type ITU T T35 has been found.\n  *\n  * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n  * @return {object} the parsed SEI payload\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\n  */\nvar parseSei = function(bytes) {\n  var\n    i = 0,\n    result = {\n      payloadType: -1,\n      payloadSize: 0\n    },\n    payloadType = 0,\n    payloadSize = 0;\n\n  // go through the sei_rbsp parsing each each individual sei_message\n  while (i < bytes.byteLength) {\n    // stop once we have hit the end of the sei_rbsp\n    if (bytes[i] === RBSP_TRAILING_BITS) {\n      break;\n    }\n\n    // Parse payload type\n    while (bytes[i] === 0xFF) {\n      payloadType += 255;\n      i++;\n    }\n    payloadType += bytes[i++];\n\n    // Parse payload size\n    while (bytes[i] === 0xFF) {\n      payloadSize += 255;\n      i++;\n    }\n    payloadSize += bytes[i++];\n\n    // this sei_message is a 608/708 caption so save it and break\n    // there can only ever be one caption message in a frame's sei\n    if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n      result.payloadType = payloadType;\n      result.payloadSize = payloadSize;\n      result.payload = bytes.subarray(i, i + payloadSize);\n      break;\n    }\n\n    // skip the payload and parse the next message\n    i += payloadSize;\n    payloadType = 0;\n    payloadSize = 0;\n  }\n\n  return result;\n};\n\n// see ANSI/SCTE 128-1 (2013), section 8.1\nvar parseUserData = function(sei) {\n  // itu_t_t35_contry_code must be 181 (United States) for\n  // captions\n  if (sei.payload[0] !== 181) {\n    return null;\n  }\n\n  // itu_t_t35_provider_code should be 49 (ATSC) for captions\n  if (((sei.payload[1] << 8) | sei.payload[2]) !== 49) {\n    return null;\n  }\n\n  // the user_identifier should be \"GA94\" to indicate ATSC1 data\n  if (String.fromCharCode(sei.payload[3],\n                          sei.payload[4],\n                          sei.payload[5],\n                          sei.payload[6]) !== 'GA94') {\n    return null;\n  }\n\n  // finally, user_data_type_code should be 0x03 for caption data\n  if (sei.payload[7] !== 0x03) {\n    return null;\n  }\n\n  // return the user_data_type_structure and strip the trailing\n  // marker bits\n  return sei.payload.subarray(8, sei.payload.length - 1);\n};\n\n// see CEA-708-D, section 4.4\nvar parseCaptionPackets = function(pts, userData) {\n  var results = [], i, count, offset, data;\n\n  // if this is just filler, return immediately\n  if (!(userData[0] & 0x40)) {\n    return results;\n  }\n\n  // parse out the cc_data_1 and cc_data_2 fields\n  count = userData[0] & 0x1f;\n  for (i = 0; i < count; i++) {\n    offset = i * 3;\n    data = {\n      type: userData[offset + 2] & 0x03,\n      pts: pts\n    };\n\n    // capture cc data when cc_valid is 1\n    if (userData[offset + 2] & 0x04) {\n      data.ccData = (userData[offset + 3] << 8) | userData[offset + 4];\n      results.push(data);\n    }\n  }\n  return results;\n};\n\nvar CaptionStream = function() {\n\n  CaptionStream.prototype.init.call(this);\n\n  this.captionPackets_ = [];\n\n  this.ccStreams_ = [\n    new Cea608Stream(0, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(0, 1), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\n  ];\n\n  this.reset();\n\n  // forward data and done events from CCs to this CaptionStream\n  this.ccStreams_.forEach(function(cc) {\n    cc.on('data', this.trigger.bind(this, 'data'));\n    cc.on('done', this.trigger.bind(this, 'done'));\n  }, this);\n\n};\n\nCaptionStream.prototype = new Stream();\nCaptionStream.prototype.push = function(event) {\n  var sei, userData;\n\n  // only examine SEI NALs\n  if (event.nalUnitType !== 'sei_rbsp') {\n    return;\n  }\n\n  // parse the sei\n  sei = parseSei(event.escapedRBSP);\n\n  // ignore everything but user_data_registered_itu_t_t35\n  if (sei.payloadType !== USER_DATA_REGISTERED_ITU_T_T35) {\n    return;\n  }\n\n  // parse out the user data payload\n  userData = parseUserData(sei);\n\n  // ignore unrecognized userData\n  if (!userData) {\n    return;\n  }\n\n  // Sometimes, the same segment # will be downloaded twice. To stop the\n  // caption data from being processed twice, we track the latest dts we've\n  // received and ignore everything with a dts before that. However, since\n  // data for a specific dts can be split across 2 packets on either side of\n  // a segment boundary, we need to make sure we *don't* ignore the second\n  // dts packet we receive that has dts === this.latestDts_. And thus, the\n  // ignoreNextEqualDts_ flag was born.\n  if (event.dts < this.latestDts_) {\n    // We've started getting older data, so set the flag.\n    this.ignoreNextEqualDts_ = true;\n    return;\n  } else if ((event.dts === this.latestDts_) && (this.ignoreNextEqualDts_)) {\n    // We've received the last duplicate packet, time to start processing again\n    this.ignoreNextEqualDts_ = false;\n    return;\n  }\n\n  // parse out CC data packets and save them for later\n  this.captionPackets_ = this.captionPackets_.concat(parseCaptionPackets(event.pts, userData));\n  this.latestDts_ = event.dts;\n};\n\nCaptionStream.prototype.flush = function() {\n  // make sure we actually parsed captions before proceeding\n  if (!this.captionPackets_.length) {\n    this.ccStreams_.forEach(function(cc) {\n      cc.flush();\n    }, this);\n    return;\n  }\n\n  // In Chrome, the Array#sort function is not stable so add a\n  // presortIndex that we can use to ensure we get a stable-sort\n  this.captionPackets_.forEach(function(elem, idx) {\n    elem.presortIndex = idx;\n  });\n\n  // sort caption byte-pairs based on their PTS values\n  this.captionPackets_.sort(function(a, b) {\n    if (a.pts === b.pts) {\n      return a.presortIndex - b.presortIndex;\n    }\n    return a.pts - b.pts;\n  });\n\n  this.captionPackets_.forEach(function(packet) {\n    if (packet.type < 2) {\n      // Dispatch packet to the right Cea608Stream\n      this.dispatchCea608Packet(packet);\n    }\n    // this is where an 'else' would go for a dispatching packets\n    // to a theoretical Cea708Stream that handles SERVICEn data\n  }, this);\n\n  this.captionPackets_.length = 0;\n  this.ccStreams_.forEach(function(cc) {\n    cc.flush();\n  }, this);\n  return;\n};\n\nCaptionStream.prototype.reset = function() {\n  this.latestDts_ = null;\n  this.ignoreNextEqualDts_ = false;\n  this.activeCea608Channel_ = [null, null];\n  this.ccStreams_.forEach(function(ccStream) {\n    ccStream.reset();\n  });\n};\n\nCaptionStream.prototype.dispatchCea608Packet = function(packet) {\n  // NOTE: packet.type is the CEA608 field\n  if (this.setsChannel1Active(packet)) {\n    this.activeCea608Channel_[packet.type] = 0;\n  } else if (this.setsChannel2Active(packet)) {\n    this.activeCea608Channel_[packet.type] = 1;\n  }\n  if (this.activeCea608Channel_[packet.type] === null) {\n    // If we haven't received anything to set the active channel, discard the\n    // data; we don't want jumbled captions\n    return;\n  }\n  this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\n};\n\nCaptionStream.prototype.setsChannel1Active = function(packet) {\n  return ((packet.ccData & 0x7800) === 0x1000);\n};\nCaptionStream.prototype.setsChannel2Active = function(packet) {\n  return ((packet.ccData & 0x7800) === 0x1800);\n};\n\n// ----------------------\n// Session to Application\n// ----------------------\n\nvar CHARACTER_TRANSLATION = {\n  0x2a: 0xe1,     // á\n  0x5c: 0xe9,     // é\n  0x5e: 0xed,     // í\n  0x5f: 0xf3,     // ó\n  0x60: 0xfa,     // ú\n  0x7b: 0xe7,     // ç\n  0x7c: 0xf7,     // ÷\n  0x7d: 0xd1,     // Ñ\n  0x7e: 0xf1,     // ñ\n  0x7f: 0x2588,   // █\n  0x0130: 0xae,   // ®\n  0x0131: 0xb0,   // °\n  0x0132: 0xbd,   // ½\n  0x0133: 0xbf,   // ¿\n  0x0134: 0x2122, // ™\n  0x0135: 0xa2,   // ¢\n  0x0136: 0xa3,   // £\n  0x0137: 0x266a, // ♪\n  0x0138: 0xe0,   // à\n  0x0139: 0xa0,   //\n  0x013a: 0xe8,   // è\n  0x013b: 0xe2,   // â\n  0x013c: 0xea,   // ê\n  0x013d: 0xee,   // î\n  0x013e: 0xf4,   // ô\n  0x013f: 0xfb,   // û\n  0x0220: 0xc1,   // Á\n  0x0221: 0xc9,   // É\n  0x0222: 0xd3,   // Ó\n  0x0223: 0xda,   // Ú\n  0x0224: 0xdc,   // Ü\n  0x0225: 0xfc,   // ü\n  0x0226: 0x2018, // ‘\n  0x0227: 0xa1,   // ¡\n  0x0228: 0x2a,   // *\n  0x0229: 0x27,   // '\n  0x022a: 0x2014, // —\n  0x022b: 0xa9,   // ©\n  0x022c: 0x2120, // ℠\n  0x022d: 0x2022, // •\n  0x022e: 0x201c, // “\n  0x022f: 0x201d, // ”\n  0x0230: 0xc0,   // À\n  0x0231: 0xc2,   // Â\n  0x0232: 0xc7,   // Ç\n  0x0233: 0xc8,   // È\n  0x0234: 0xca,   // Ê\n  0x0235: 0xcb,   // Ë\n  0x0236: 0xeb,   // ë\n  0x0237: 0xce,   // Î\n  0x0238: 0xcf,   // Ï\n  0x0239: 0xef,   // ï\n  0x023a: 0xd4,   // Ô\n  0x023b: 0xd9,   // Ù\n  0x023c: 0xf9,   // ù\n  0x023d: 0xdb,   // Û\n  0x023e: 0xab,   // «\n  0x023f: 0xbb,   // »\n  0x0320: 0xc3,   // Ã\n  0x0321: 0xe3,   // ã\n  0x0322: 0xcd,   // Í\n  0x0323: 0xcc,   // Ì\n  0x0324: 0xec,   // ì\n  0x0325: 0xd2,   // Ò\n  0x0326: 0xf2,   // ò\n  0x0327: 0xd5,   // Õ\n  0x0328: 0xf5,   // õ\n  0x0329: 0x7b,   // {\n  0x032a: 0x7d,   // }\n  0x032b: 0x5c,   // \\\n  0x032c: 0x5e,   // ^\n  0x032d: 0x5f,   // _\n  0x032e: 0x7c,   // |\n  0x032f: 0x7e,   // ~\n  0x0330: 0xc4,   // Ä\n  0x0331: 0xe4,   // ä\n  0x0332: 0xd6,   // Ö\n  0x0333: 0xf6,   // ö\n  0x0334: 0xdf,   // ß\n  0x0335: 0xa5,   // ¥\n  0x0336: 0xa4,   // ¤\n  0x0337: 0x2502, // │\n  0x0338: 0xc5,   // Å\n  0x0339: 0xe5,   // å\n  0x033a: 0xd8,   // Ø\n  0x033b: 0xf8,   // ø\n  0x033c: 0x250c, // ┌\n  0x033d: 0x2510, // ┐\n  0x033e: 0x2514, // └\n  0x033f: 0x2518  // ┘\n};\n\nvar getCharFromCode = function(code) {\n  if (code === null) {\n    return '';\n  }\n  code = CHARACTER_TRANSLATION[code] || code;\n  return String.fromCharCode(code);\n};\n\n// the index of the last row in a CEA-608 display buffer\nvar BOTTOM_ROW = 14;\n\n// This array is used for mapping PACs -> row #, since there's no way of\n// getting it through bit logic.\nvar ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620,\n            0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420];\n\n// CEA-608 captions are rendered onto a 34x15 matrix of character\n// cells. The \"bottom\" row is the last element in the outer array.\nvar createDisplayBuffer = function() {\n  var result = [], i = BOTTOM_ROW + 1;\n  while (i--) {\n    result.push('');\n  }\n  return result;\n};\n\nvar Cea608Stream = function(field, dataChannel) {\n  Cea608Stream.prototype.init.call(this);\n\n  this.field_ = field || 0;\n  this.dataChannel_ = dataChannel || 0;\n\n  this.name_ = 'CC' + (((this.field_ << 1) | this.dataChannel_) + 1);\n\n  this.setConstants();\n  this.reset();\n\n  this.push = function(packet) {\n    var data, swap, char0, char1, text;\n    // remove the parity bits\n    data = packet.ccData & 0x7f7f;\n\n    // ignore duplicate control codes; the spec demands they're sent twice\n    if (data === this.lastControlCode_) {\n      this.lastControlCode_ = null;\n      return;\n    }\n\n    // Store control codes\n    if ((data & 0xf000) === 0x1000) {\n      this.lastControlCode_ = data;\n    } else if (data !== this.PADDING_) {\n      this.lastControlCode_ = null;\n    }\n\n    char0 = data >>> 8;\n    char1 = data & 0xff;\n\n    if (data === this.PADDING_) {\n      return;\n\n    } else if (data === this.RESUME_CAPTION_LOADING_) {\n      this.mode_ = 'popOn';\n\n    } else if (data === this.END_OF_CAPTION_) {\n      this.clearFormatting(packet.pts);\n      // if a caption was being displayed, it's gone now\n      this.flushDisplayed(packet.pts);\n\n      // flip memory\n      swap = this.displayed_;\n      this.displayed_ = this.nonDisplayed_;\n      this.nonDisplayed_ = swap;\n\n      // start measuring the time to display the caption\n      this.startPts_ = packet.pts;\n\n    } else if (data === this.ROLL_UP_2_ROWS_) {\n      this.topRow_ = BOTTOM_ROW - 1;\n      this.mode_ = 'rollUp';\n    } else if (data === this.ROLL_UP_3_ROWS_) {\n      this.topRow_ = BOTTOM_ROW - 2;\n      this.mode_ = 'rollUp';\n    } else if (data === this.ROLL_UP_4_ROWS_) {\n      this.topRow_ = BOTTOM_ROW - 3;\n      this.mode_ = 'rollUp';\n    } else if (data === this.CARRIAGE_RETURN_) {\n      this.clearFormatting(packet.pts);\n      this.flushDisplayed(packet.pts);\n      this.shiftRowsUp_();\n      this.startPts_ = packet.pts;\n\n    } else if (data === this.BACKSPACE_) {\n      if (this.mode_ === 'popOn') {\n        this.nonDisplayed_[BOTTOM_ROW] = this.nonDisplayed_[BOTTOM_ROW].slice(0, -1);\n      } else {\n        this.displayed_[BOTTOM_ROW] = this.displayed_[BOTTOM_ROW].slice(0, -1);\n      }\n    } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\n      this.flushDisplayed(packet.pts);\n      this.displayed_ = createDisplayBuffer();\n    } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\n      this.nonDisplayed_ = createDisplayBuffer();\n\n    } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\n      this.mode_ = 'paintOn';\n\n    // Append special characters to caption text\n    } else if (this.isSpecialCharacter(char0, char1)) {\n      // Bitmask char0 so that we can apply character transformations\n      // regardless of field and data channel.\n      // Then byte-shift to the left and OR with char1 so we can pass the\n      // entire character code to `getCharFromCode`.\n      char0 = (char0 & 0x03) << 8;\n      text = getCharFromCode(char0 | char1);\n      this[this.mode_](packet.pts, text);\n      this.column_++;\n\n    // Append extended characters to caption text\n    } else if (this.isExtCharacter(char0, char1)) {\n      // Extended characters always follow their \"non-extended\" equivalents.\n      // IE if a \"è\" is desired, you'll always receive \"eè\"; non-compliant\n      // decoders are supposed to drop the \"è\", while compliant decoders\n      // backspace the \"e\" and insert \"è\".\n\n      // Delete the previous character\n      if (this.mode_ === 'popOn') {\n        this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n      } else {\n        this.displayed_[BOTTOM_ROW] = this.displayed_[BOTTOM_ROW].slice(0, -1);\n      }\n\n      // Bitmask char0 so that we can apply character transformations\n      // regardless of field and data channel.\n      // Then byte-shift to the left and OR with char1 so we can pass the\n      // entire character code to `getCharFromCode`.\n      char0 = (char0 & 0x03) << 8;\n      text = getCharFromCode(char0 | char1);\n      this[this.mode_](packet.pts, text);\n      this.column_++;\n\n    // Process mid-row codes\n    } else if (this.isMidRowCode(char0, char1)) {\n      // Attributes are not additive, so clear all formatting\n      this.clearFormatting(packet.pts);\n\n      // According to the standard, mid-row codes\n      // should be replaced with spaces, so add one now\n      this[this.mode_](packet.pts, ' ');\n      this.column_++;\n\n      if ((char1 & 0xe) === 0xe) {\n        this.addFormatting(packet.pts, ['i']);\n      }\n\n      if ((char1 & 0x1) === 0x1) {\n        this.addFormatting(packet.pts, ['u']);\n      }\n\n    // Detect offset control codes and adjust cursor\n    } else if (this.isOffsetControlCode(char0, char1)) {\n      // Cursor position is set by indent PAC (see below) in 4-column\n      // increments, with an additional offset code of 1-3 to reach any\n      // of the 32 columns specified by CEA-608. So all we need to do\n      // here is increment the column cursor by the given offset.\n      this.column_ += (char1 & 0x03);\n\n    // Detect PACs (Preamble Address Codes)\n    } else if (this.isPAC(char0, char1)) {\n\n      // There's no logic for PAC -> row mapping, so we have to just\n      // find the row code in an array and use its index :(\n      var row = ROWS.indexOf(data & 0x1f20);\n\n      if (row !== this.row_) {\n        // formatting is only persistent for current row\n        this.clearFormatting(packet.pts);\n        this.row_ = row;\n      }\n      // All PACs can apply underline, so detect and apply\n      // (All odd-numbered second bytes set underline)\n      if ((char1 & 0x1) && (this.formatting_.indexOf('u') === -1)) {\n          this.addFormatting(packet.pts, ['u']);\n      }\n\n      if ((data & 0x10) === 0x10) {\n        // We've got an indent level code. Each successive even number\n        // increments the column cursor by 4, so we can get the desired\n        // column position by bit-shifting to the right (to get n/2)\n        // and multiplying by 4.\n        this.column_ = ((data & 0xe) >> 1) * 4;\n      }\n\n      if (this.isColorPAC(char1)) {\n        // it's a color code, though we only support white, which\n        // can be either normal or italicized. white italics can be\n        // either 0x4e or 0x6e depending on the row, so we just\n        // bitwise-and with 0xe to see if italics should be turned on\n        if ((char1 & 0xe) === 0xe) {\n          this.addFormatting(packet.pts, ['i']);\n        }\n      }\n\n    // We have a normal character in char0, and possibly one in char1\n    } else if (this.isNormalChar(char0)) {\n      if (char1 === 0x00) {\n        char1 = null;\n      }\n      text = getCharFromCode(char0);\n      text += getCharFromCode(char1);\n      this[this.mode_](packet.pts, text);\n      this.column_ += text.length;\n\n    } // finish data processing\n\n  };\n};\nCea608Stream.prototype = new Stream();\n// Trigger a cue point that captures the current state of the\n// display buffer\nCea608Stream.prototype.flushDisplayed = function(pts) {\n  var content = this.displayed_\n    // remove spaces from the start and end of the string\n    .map(function(row) {\n      return row.trim();\n    })\n    // combine all text rows to display in one cue\n    .join('\\n')\n    // and remove blank rows from the start and end, but not the middle\n    .replace(/^\\n+|\\n+$/g, '');\n\n  if (content.length) {\n    this.trigger('data', {\n      startPts: this.startPts_,\n      endPts: pts,\n      text: content,\n      stream: this.name_\n    });\n  }\n};\n\n/**\n * Zero out the data, used for startup and on seek\n */\nCea608Stream.prototype.reset = function() {\n  this.mode_ = 'popOn';\n  // When in roll-up mode, the index of the last row that will\n  // actually display captions. If a caption is shifted to a row\n  // with a lower index than this, it is cleared from the display\n  // buffer\n  this.topRow_ = 0;\n  this.startPts_ = 0;\n  this.displayed_ = createDisplayBuffer();\n  this.nonDisplayed_ = createDisplayBuffer();\n  this.lastControlCode_ = null;\n\n  // Track row and column for proper line-breaking and spacing\n  this.column_ = 0;\n  this.row_ = BOTTOM_ROW;\n\n  // This variable holds currently-applied formatting\n  this.formatting_ = [];\n};\n\n/**\n * Sets up control code and related constants for this instance\n */\nCea608Stream.prototype.setConstants = function() {\n  // The following attributes have these uses:\n  // ext_ :    char0 for mid-row codes, and the base for extended\n  //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\n  //           extended codes)\n  // control_: char0 for control codes, except byte-shifted to the\n  //           left so that we can do this.control_ | CONTROL_CODE\n  // offset_:  char0 for tab offset codes\n  //\n  // It's also worth noting that control codes, and _only_ control codes,\n  // differ between field 1 and field2. Field 2 control codes are always\n  // their field 1 value plus 1. That's why there's the \"| field\" on the\n  // control value.\n  if (this.dataChannel_ === 0) {\n    this.BASE_     = 0x10;\n    this.EXT_      = 0x11;\n    this.CONTROL_  = (0x14 | this.field_) << 8;\n    this.OFFSET_   = 0x17;\n  } else if (this.dataChannel_ === 1) {\n    this.BASE_     = 0x18;\n    this.EXT_      = 0x19;\n    this.CONTROL_  = (0x1c | this.field_) << 8;\n    this.OFFSET_   = 0x1f;\n  }\n\n  // Constants for the LSByte command codes recognized by Cea608Stream. This\n  // list is not exhaustive. For a more comprehensive listing and semantics see\n  // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\n  // Padding\n  this.PADDING_                    = 0x0000;\n  // Pop-on Mode\n  this.RESUME_CAPTION_LOADING_     = this.CONTROL_ | 0x20;\n  this.END_OF_CAPTION_             = this.CONTROL_ | 0x2f;\n  // Roll-up Mode\n  this.ROLL_UP_2_ROWS_             = this.CONTROL_ | 0x25;\n  this.ROLL_UP_3_ROWS_             = this.CONTROL_ | 0x26;\n  this.ROLL_UP_4_ROWS_             = this.CONTROL_ | 0x27;\n  this.CARRIAGE_RETURN_            = this.CONTROL_ | 0x2d;\n  // paint-on mode (not supported)\n  this.RESUME_DIRECT_CAPTIONING_   = this.CONTROL_ | 0x29;\n  // Erasure\n  this.BACKSPACE_                  = this.CONTROL_ | 0x21;\n  this.ERASE_DISPLAYED_MEMORY_     = this.CONTROL_ | 0x2c;\n  this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\n};\n\n/**\n * Detects if the 2-byte packet data is a special character\n *\n * Special characters have a second byte in the range 0x30 to 0x3f,\n * with the first byte being 0x11 (for data channel 1) or 0x19 (for\n * data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an special character\n */\nCea608Stream.prototype.isSpecialCharacter = function(char0, char1) {\n  return (char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f);\n};\n\n/**\n * Detects if the 2-byte packet data is an extended character\n *\n * Extended characters have a second byte in the range 0x20 to 0x3f,\n * with the first byte being 0x12 or 0x13 (for data channel 1) or\n * 0x1a or 0x1b (for data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an extended character\n */\nCea608Stream.prototype.isExtCharacter = function(char0, char1) {\n  return ((char0 === (this.EXT_ + 1) || char0 === (this.EXT_ + 2)) &&\n    (char1 >= 0x20 && char1 <= 0x3f));\n};\n\n/**\n * Detects if the 2-byte packet is a mid-row code\n *\n * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\n * the first byte being 0x11 (for data channel 1) or 0x19 (for data\n * channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are a mid-row code\n */\nCea608Stream.prototype.isMidRowCode = function(char0, char1) {\n  return (char0 === this.EXT_ && (char1 >= 0x20 && char1 <= 0x2f));\n};\n\n/**\n * Detects if the 2-byte packet is an offset control code\n *\n * Offset control codes have a second byte in the range 0x21 to 0x23,\n * with the first byte being 0x17 (for data channel 1) or 0x1f (for\n * data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an offset control code\n */\nCea608Stream.prototype.isOffsetControlCode = function(char0, char1) {\n  return (char0 === this.OFFSET_ && (char1 >= 0x21 && char1 <= 0x23));\n};\n\n/**\n * Detects if the 2-byte packet is a Preamble Address Code\n *\n * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\n * or 0x18 to 0x1f (for data channel 2), with the second byte in the\n * range 0x40 to 0x7f.\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are a PAC\n */\nCea608Stream.prototype.isPAC = function(char0, char1) {\n  return (char0 >= this.BASE_ && char0 < (this.BASE_ + 8) &&\n    (char1 >= 0x40 && char1 <= 0x7f));\n};\n\n/**\n * Detects if a packet's second byte is in the range of a PAC color code\n *\n * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\n * 0x60 to 0x6f.\n *\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the byte is a color PAC\n */\nCea608Stream.prototype.isColorPAC = function(char1) {\n  return ((char1 >= 0x40 && char1 <= 0x4f) || (char1 >= 0x60 && char1 <= 0x7f));\n};\n\n/**\n * Detects if a single byte is in the range of a normal character\n *\n * Normal text bytes are in the range 0x20 to 0x7f.\n *\n * @param  {Integer} char  The byte\n * @return {Boolean}       Whether the byte is a normal character\n */\nCea608Stream.prototype.isNormalChar = function(char) {\n  return (char >= 0x20 && char <= 0x7f);\n};\n\n// Adds the opening HTML tag for the passed character to the caption text,\n// and keeps track of it for later closing\nCea608Stream.prototype.addFormatting = function(pts, format) {\n  this.formatting_ = this.formatting_.concat(format);\n  var text = format.reduce(function(text, format) {\n    return text + '<' + format + '>';\n  }, '');\n  this[this.mode_](pts, text);\n};\n\n// Adds HTML closing tags for current formatting to caption text and\n// clears remembered formatting\nCea608Stream.prototype.clearFormatting = function(pts) {\n  if (!this.formatting_.length) {\n    return;\n  }\n  var text = this.formatting_.reverse().reduce(function(text, format) {\n    return text + '</' + format + '>';\n  }, '');\n  this.formatting_ = [];\n  this[this.mode_](pts, text);\n};\n\n// Mode Implementations\nCea608Stream.prototype.popOn = function(pts, text) {\n  var baseRow = this.nonDisplayed_[this.row_];\n\n  // buffer characters\n  baseRow += text;\n  this.nonDisplayed_[this.row_] = baseRow;\n};\n\nCea608Stream.prototype.rollUp = function(pts, text) {\n  var baseRow = this.displayed_[BOTTOM_ROW];\n\n  baseRow += text;\n  this.displayed_[BOTTOM_ROW] = baseRow;\n\n};\n\nCea608Stream.prototype.shiftRowsUp_ = function() {\n  var i;\n  // clear out inactive rows\n  for (i = 0; i < this.topRow_; i++) {\n    this.displayed_[i] = '';\n  }\n  // shift displayed rows up\n  for (i = this.topRow_; i < BOTTOM_ROW; i++) {\n    this.displayed_[i] = this.displayed_[i + 1];\n  }\n  // clear out the bottom row\n  this.displayed_[BOTTOM_ROW] = '';\n};\n\n// paintOn mode is not implemented\nCea608Stream.prototype.paintOn = function() {};\n\n// exports\nmodule.exports = {\n  CaptionStream: CaptionStream,\n  Cea608Stream: Cea608Stream\n};\n\n},{\"../utils/stream\":62}],50:[function(require,module,exports){\n/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * A stream-based mp2t to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\nvar Stream = require('../utils/stream.js'),\n  CaptionStream = require('./caption-stream'),\n  StreamTypes = require('./stream-types'),\n  TimestampRolloverStream = require('./timestamp-rollover-stream').TimestampRolloverStream;\n\nvar m2tsStreamTypes = require('./stream-types.js');\n\n// object types\nvar TransportPacketStream, TransportParseStream, ElementaryStream;\n\n// constants\nvar\n  MP2T_PACKET_LENGTH = 188, // bytes\n  SYNC_BYTE = 0x47;\n\n/**\n * Splits an incoming stream of binary data into MPEG-2 Transport\n * Stream packets.\n */\nTransportPacketStream = function() {\n  var\n    buffer = new Uint8Array(MP2T_PACKET_LENGTH),\n    bytesInBuffer = 0;\n\n  TransportPacketStream.prototype.init.call(this);\n\n   // Deliver new bytes to the stream.\n\n  this.push = function(bytes) {\n    var\n      startIndex = 0,\n      endIndex = MP2T_PACKET_LENGTH,\n      everything;\n\n    // If there are bytes remaining from the last segment, prepend them to the\n    // bytes that were pushed in\n    if (bytesInBuffer) {\n      everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\n      everything.set(buffer.subarray(0, bytesInBuffer));\n      everything.set(bytes, bytesInBuffer);\n      bytesInBuffer = 0;\n    } else {\n      everything = bytes;\n    }\n\n    // While we have enough data for a packet\n    while (endIndex < everything.byteLength) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (everything[startIndex] === SYNC_BYTE && everything[endIndex] === SYNC_BYTE) {\n        // We found a packet so emit it and jump one whole packet forward in\n        // the stream\n        this.trigger('data', everything.subarray(startIndex, endIndex));\n        startIndex += MP2T_PACKET_LENGTH;\n        endIndex += MP2T_PACKET_LENGTH;\n        continue;\n      }\n      // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n      startIndex++;\n      endIndex++;\n    }\n\n    // If there was some data left over at the end of the segment that couldn't\n    // possibly be a whole packet, keep it because it might be the start of a packet\n    // that continues in the next segment\n    if (startIndex < everything.byteLength) {\n      buffer.set(everything.subarray(startIndex), 0);\n      bytesInBuffer = everything.byteLength - startIndex;\n    }\n  };\n\n  this.flush = function() {\n    // If the buffer contains a whole packet when we are being flushed, emit it\n    // and empty the buffer. Otherwise hold onto the data because it may be\n    // important for decoding the next segment\n    if (bytesInBuffer === MP2T_PACKET_LENGTH && buffer[0] === SYNC_BYTE) {\n      this.trigger('data', buffer);\n      bytesInBuffer = 0;\n    }\n    this.trigger('done');\n  };\n};\nTransportPacketStream.prototype = new Stream();\n\n/**\n * Accepts an MP2T TransportPacketStream and emits data events with parsed\n * forms of the individual transport stream packets.\n */\nTransportParseStream = function() {\n  var parsePsi, parsePat, parsePmt, self;\n  TransportParseStream.prototype.init.call(this);\n  self = this;\n\n  this.packetsWaitingForPmt = [];\n  this.programMapTable = undefined;\n\n  parsePsi = function(payload, psi) {\n    var offset = 0;\n\n    // PSI packets may be split into multiple sections and those\n    // sections may be split into multiple packets. If a PSI\n    // section starts in this packet, the payload_unit_start_indicator\n    // will be true and the first byte of the payload will indicate\n    // the offset from the current position to the start of the\n    // section.\n    if (psi.payloadUnitStartIndicator) {\n      offset += payload[offset] + 1;\n    }\n\n    if (psi.type === 'pat') {\n      parsePat(payload.subarray(offset), psi);\n    } else {\n      parsePmt(payload.subarray(offset), psi);\n    }\n  };\n\n  parsePat = function(payload, pat) {\n    pat.section_number = payload[7]; // eslint-disable-line camelcase\n    pat.last_section_number = payload[8]; // eslint-disable-line camelcase\n\n    // skip the PSI header and parse the first PMT entry\n    self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\n    pat.pmtPid = self.pmtPid;\n  };\n\n  /**\n   * Parse out the relevant fields of a Program Map Table (PMT).\n   * @param payload {Uint8Array} the PMT-specific portion of an MP2T\n   * packet. The first byte in this array should be the table_id\n   * field.\n   * @param pmt {object} the object that should be decorated with\n   * fields parsed from the PMT.\n   */\n  parsePmt = function(payload, pmt) {\n    var sectionLength, tableEnd, programInfoLength, offset;\n\n    // PMTs can be sent ahead of the time when they should actually\n    // take effect. We don't believe this should ever be the case\n    // for HLS but we'll ignore \"forward\" PMT declarations if we see\n    // them. Future PMT declarations have the current_next_indicator\n    // set to zero.\n    if (!(payload[5] & 0x01)) {\n      return;\n    }\n\n    // overwrite any existing program map table\n    self.programMapTable = {\n      video: null,\n      audio: null,\n      'timed-metadata': {}\n    };\n\n    // the mapping table ends at the end of the current section\n    sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\n    tableEnd = 3 + sectionLength - 4;\n\n    // to determine where the table is, we have to figure out how\n    // long the program info descriptors are\n    programInfoLength = (payload[10] & 0x0f) << 8 | payload[11];\n\n    // advance the offset to the first entry in the mapping table\n    offset = 12 + programInfoLength;\n    while (offset < tableEnd) {\n      var streamType = payload[offset];\n      var pid = (payload[offset + 1] & 0x1F) << 8 | payload[offset + 2];\n\n      // only map a single elementary_pid for audio and video stream types\n      // TODO: should this be done for metadata too? for now maintain behavior of\n      //       multiple metadata streams\n      if (streamType === StreamTypes.H264_STREAM_TYPE &&\n          self.programMapTable.video === null) {\n        self.programMapTable.video = pid;\n      } else if (streamType === StreamTypes.ADTS_STREAM_TYPE &&\n                 self.programMapTable.audio === null) {\n        self.programMapTable.audio = pid;\n      } else if (streamType === StreamTypes.METADATA_STREAM_TYPE) {\n        // map pid to stream type for metadata streams\n        self.programMapTable['timed-metadata'][pid] = streamType;\n      }\n\n      // move to the next table entry\n      // skip past the elementary stream descriptors, if present\n      offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\n    }\n\n    // record the map on the packet as well\n    pmt.programMapTable = self.programMapTable;\n  };\n\n  /**\n   * Deliver a new MP2T packet to the stream.\n   */\n  this.push = function(packet) {\n    var\n      result = {},\n      offset = 4;\n\n    result.payloadUnitStartIndicator = !!(packet[1] & 0x40);\n\n    // pid is a 13-bit field starting at the last bit of packet[1]\n    result.pid = packet[1] & 0x1f;\n    result.pid <<= 8;\n    result.pid |= packet[2];\n\n    // if an adaption field is present, its length is specified by the\n    // fifth byte of the TS packet header. The adaptation field is\n    // used to add stuffing to PES packets that don't fill a complete\n    // TS packet, and to specify some forms of timing and control data\n    // that we do not currently use.\n    if (((packet[3] & 0x30) >>> 4) > 0x01) {\n      offset += packet[offset] + 1;\n    }\n\n    // parse the rest of the packet based on the type\n    if (result.pid === 0) {\n      result.type = 'pat';\n      parsePsi(packet.subarray(offset), result);\n      this.trigger('data', result);\n    } else if (result.pid === this.pmtPid) {\n      result.type = 'pmt';\n      parsePsi(packet.subarray(offset), result);\n      this.trigger('data', result);\n\n      // if there are any packets waiting for a PMT to be found, process them now\n      while (this.packetsWaitingForPmt.length) {\n        this.processPes_.apply(this, this.packetsWaitingForPmt.shift());\n      }\n    } else if (this.programMapTable === undefined) {\n      // When we have not seen a PMT yet, defer further processing of\n      // PES packets until one has been parsed\n      this.packetsWaitingForPmt.push([packet, offset, result]);\n    } else {\n      this.processPes_(packet, offset, result);\n    }\n  };\n\n  this.processPes_ = function(packet, offset, result) {\n    // set the appropriate stream type\n    if (result.pid === this.programMapTable.video) {\n      result.streamType = StreamTypes.H264_STREAM_TYPE;\n    } else if (result.pid === this.programMapTable.audio) {\n      result.streamType = StreamTypes.ADTS_STREAM_TYPE;\n    } else {\n      // if not video or audio, it is timed-metadata or unknown\n      // if unknown, streamType will be undefined\n      result.streamType = this.programMapTable['timed-metadata'][result.pid];\n    }\n\n    result.type = 'pes';\n    result.data = packet.subarray(offset);\n\n    this.trigger('data', result);\n  };\n\n};\nTransportParseStream.prototype = new Stream();\nTransportParseStream.STREAM_TYPES  = {\n  h264: 0x1b,\n  adts: 0x0f\n};\n\n/**\n * Reconsistutes program elementary stream (PES) packets from parsed\n * transport stream packets. That is, if you pipe an\n * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\n * events will be events which capture the bytes for individual PES\n * packets plus relevant metadata that has been extracted from the\n * container.\n */\nElementaryStream = function() {\n  var\n    self = this,\n    // PES packet fragments\n    video = {\n      data: [],\n      size: 0\n    },\n    audio = {\n      data: [],\n      size: 0\n    },\n    timedMetadata = {\n      data: [],\n      size: 0\n    },\n    parsePes = function(payload, pes) {\n      var ptsDtsFlags;\n\n      // get the packet length, this will be 0 for video\n      pes.packetLength = 6 + ((payload[4] << 8) | payload[5]);\n\n      // find out if this packets starts a new keyframe\n      pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0;\n      // PES packets may be annotated with a PTS value, or a PTS value\n      // and a DTS value. Determine what combination of values is\n      // available to work with.\n      ptsDtsFlags = payload[7];\n\n      // PTS and DTS are normally stored as a 33-bit number.  Javascript\n      // performs all bitwise operations on 32-bit integers but javascript\n      // supports a much greater range (52-bits) of integer using standard\n      // mathematical operations.\n      // We construct a 31-bit value using bitwise operators over the 31\n      // most significant bits and then multiply by 4 (equal to a left-shift\n      // of 2) before we add the final 2 least significant bits of the\n      // timestamp (equal to an OR.)\n      if (ptsDtsFlags & 0xC0) {\n        // the PTS and DTS are not written out directly. For information\n        // on how they are encoded, see\n        // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n        pes.pts = (payload[9] & 0x0E) << 27 |\n          (payload[10] & 0xFF) << 20 |\n          (payload[11] & 0xFE) << 12 |\n          (payload[12] & 0xFF) <<  5 |\n          (payload[13] & 0xFE) >>>  3;\n        pes.pts *= 4; // Left shift by 2\n        pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\n        pes.dts = pes.pts;\n        if (ptsDtsFlags & 0x40) {\n          pes.dts = (payload[14] & 0x0E) << 27 |\n            (payload[15] & 0xFF) << 20 |\n            (payload[16] & 0xFE) << 12 |\n            (payload[17] & 0xFF) << 5 |\n            (payload[18] & 0xFE) >>> 3;\n          pes.dts *= 4; // Left shift by 2\n          pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\n        }\n      }\n      // the data section starts immediately after the PES header.\n      // pes_header_data_length specifies the number of header bytes\n      // that follow the last byte of the field.\n      pes.data = payload.subarray(9 + payload[8]);\n    },\n    flushStream = function(stream, type, forceFlush) {\n      var\n        packetData = new Uint8Array(stream.size),\n        event = {\n          type: type\n        },\n        i = 0,\n        offset = 0,\n        packetFlushable = false,\n        fragment;\n\n      // do nothing if there is not enough buffered data for a complete\n      // PES header\n      if (!stream.data.length || stream.size < 9) {\n        return;\n      }\n      event.trackId = stream.data[0].pid;\n\n      // reassemble the packet\n      for (i = 0; i < stream.data.length; i++) {\n        fragment = stream.data[i];\n\n        packetData.set(fragment.data, offset);\n        offset += fragment.data.byteLength;\n      }\n\n      // parse assembled packet's PES header\n      parsePes(packetData, event);\n\n      // non-video PES packets MUST have a non-zero PES_packet_length\n      // check that there is enough stream data to fill the packet\n      packetFlushable = type === 'video' || event.packetLength <= stream.size;\n\n      // flush pending packets if the conditions are right\n      if (forceFlush || packetFlushable) {\n        stream.size = 0;\n        stream.data.length = 0;\n      }\n\n      // only emit packets that are complete. this is to avoid assembling\n      // incomplete PES packets due to poor segmentation\n      if (packetFlushable) {\n        self.trigger('data', event);\n      }\n    };\n\n  ElementaryStream.prototype.init.call(this);\n\n  this.push = function(data) {\n    ({\n      pat: function() {\n        // we have to wait for the PMT to arrive as well before we\n        // have any meaningful metadata\n      },\n      pes: function() {\n        var stream, streamType;\n\n        switch (data.streamType) {\n        case StreamTypes.H264_STREAM_TYPE:\n        case m2tsStreamTypes.H264_STREAM_TYPE:\n          stream = video;\n          streamType = 'video';\n          break;\n        case StreamTypes.ADTS_STREAM_TYPE:\n          stream = audio;\n          streamType = 'audio';\n          break;\n        case StreamTypes.METADATA_STREAM_TYPE:\n          stream = timedMetadata;\n          streamType = 'timed-metadata';\n          break;\n        default:\n          // ignore unknown stream types\n          return;\n        }\n\n        // if a new packet is starting, we can flush the completed\n        // packet\n        if (data.payloadUnitStartIndicator) {\n          flushStream(stream, streamType, true);\n        }\n\n        // buffer this fragment until we are sure we've received the\n        // complete payload\n        stream.data.push(data);\n        stream.size += data.data.byteLength;\n      },\n      pmt: function() {\n        var\n          event = {\n            type: 'metadata',\n            tracks: []\n          },\n          programMapTable = data.programMapTable;\n\n        // translate audio and video streams to tracks\n        if (programMapTable.video !== null) {\n          event.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.video,\n            codec: 'avc',\n            type: 'video'\n          });\n        }\n        if (programMapTable.audio !== null) {\n          event.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.audio,\n            codec: 'adts',\n            type: 'audio'\n          });\n        }\n\n        self.trigger('data', event);\n      }\n    })[data.type]();\n  };\n\n  /**\n   * Flush any remaining input. Video PES packets may be of variable\n   * length. Normally, the start of a new video packet can trigger the\n   * finalization of the previous packet. That is not possible if no\n   * more video is forthcoming, however. In that case, some other\n   * mechanism (like the end of the file) has to be employed. When it is\n   * clear that no additional data is forthcoming, calling this method\n   * will flush the buffered packets.\n   */\n  this.flush = function() {\n    // !!THIS ORDER IS IMPORTANT!!\n    // video first then audio\n    flushStream(video, 'video');\n    flushStream(audio, 'audio');\n    flushStream(timedMetadata, 'timed-metadata');\n    this.trigger('done');\n  };\n};\nElementaryStream.prototype = new Stream();\n\nvar m2ts = {\n  PAT_PID: 0x0000,\n  MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH,\n  TransportPacketStream: TransportPacketStream,\n  TransportParseStream: TransportParseStream,\n  ElementaryStream: ElementaryStream,\n  TimestampRolloverStream: TimestampRolloverStream,\n  CaptionStream: CaptionStream.CaptionStream,\n  Cea608Stream: CaptionStream.Cea608Stream,\n  MetadataStream: require('./metadata-stream')\n};\n\nfor (var type in StreamTypes) {\n  if (StreamTypes.hasOwnProperty(type)) {\n    m2ts[type] = StreamTypes[type];\n  }\n}\n\nmodule.exports = m2ts;\n\n},{\"../utils/stream.js\":62,\"./caption-stream\":49,\"./metadata-stream\":51,\"./stream-types\":53,\"./stream-types.js\":53,\"./timestamp-rollover-stream\":54}],51:[function(require,module,exports){\n/**\n * Accepts program elementary stream (PES) data events and parses out\n * ID3 metadata from them, if present.\n * @see http://id3.org/id3v2.3.0\n */\n'use strict';\nvar\n  Stream = require('../utils/stream'),\n  StreamTypes = require('./stream-types'),\n  // return a percent-encoded representation of the specified byte range\n  // @see http://en.wikipedia.org/wiki/Percent-encoding\n  percentEncode = function(bytes, start, end) {\n    var i, result = '';\n    for (i = start; i < end; i++) {\n      result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n    }\n    return result;\n  },\n  // return the string representation of the specified byte range,\n  // interpreted as UTf-8.\n  parseUtf8 = function(bytes, start, end) {\n    return decodeURIComponent(percentEncode(bytes, start, end));\n  },\n  // return the string representation of the specified byte range,\n  // interpreted as ISO-8859-1.\n  parseIso88591 = function(bytes, start, end) {\n    return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n  },\n  parseSyncSafeInteger = function(data) {\n    return (data[0] << 21) |\n            (data[1] << 14) |\n            (data[2] << 7) |\n            (data[3]);\n  },\n  tagParsers = {\n    TXXX: function(tag) {\n      var i;\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the text fields\n          tag.description = parseUtf8(tag.data, 1, i);\n          // do not include the null terminator in the tag value\n          tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\\0*$/, '');\n          break;\n        }\n      }\n      tag.data = tag.value;\n    },\n    WXXX: function(tag) {\n      var i;\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.description = parseUtf8(tag.data, 1, i);\n          tag.url = parseUtf8(tag.data, i + 1, tag.data.length);\n          break;\n        }\n      }\n    },\n    PRIV: function(tag) {\n      var i;\n\n      for (i = 0; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.owner = parseIso88591(tag.data, 0, i);\n          break;\n        }\n      }\n      tag.privateData = tag.data.subarray(i + 1);\n      tag.data = tag.privateData;\n    }\n  },\n  MetadataStream;\n\nMetadataStream = function(options) {\n  var\n    settings = {\n      debug: !!(options && options.debug),\n\n      // the bytes of the program-level descriptor field in MP2T\n      // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\n      // program element descriptors\"\n      descriptor: options && options.descriptor\n    },\n    // the total size in bytes of the ID3 tag being parsed\n    tagSize = 0,\n    // tag data that is not complete enough to be parsed\n    buffer = [],\n    // the total number of bytes currently in the buffer\n    bufferSize = 0,\n    i;\n\n  MetadataStream.prototype.init.call(this);\n\n  // calculate the text track in-band metadata track dispatch type\n  // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\n  this.dispatchType = StreamTypes.METADATA_STREAM_TYPE.toString(16);\n  if (settings.descriptor) {\n    for (i = 0; i < settings.descriptor.length; i++) {\n      this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\n    }\n  }\n\n  this.push = function(chunk) {\n    var tag, frameStart, frameSize, frame, i, frameHeader;\n    if (chunk.type !== 'timed-metadata') {\n      return;\n    }\n\n    // if data_alignment_indicator is set in the PES header,\n    // we must have the start of a new ID3 tag. Assume anything\n    // remaining in the buffer was malformed and throw it out\n    if (chunk.dataAlignmentIndicator) {\n      bufferSize = 0;\n      buffer.length = 0;\n    }\n\n    // ignore events that don't look like ID3 data\n    if (buffer.length === 0 &&\n        (chunk.data.length < 10 ||\n          chunk.data[0] !== 'I'.charCodeAt(0) ||\n          chunk.data[1] !== 'D'.charCodeAt(0) ||\n          chunk.data[2] !== '3'.charCodeAt(0))) {\n      if (settings.debug) {\n        // eslint-disable-next-line no-console\n        console.log('Skipping unrecognized metadata packet');\n      }\n      return;\n    }\n\n    // add this chunk to the data we've collected so far\n\n    buffer.push(chunk);\n    bufferSize += chunk.data.byteLength;\n\n    // grab the size of the entire frame from the ID3 header\n    if (buffer.length === 1) {\n      // the frame size is transmitted as a 28-bit integer in the\n      // last four bytes of the ID3 header.\n      // The most significant bit of each byte is dropped and the\n      // results concatenated to recover the actual value.\n      tagSize = parseSyncSafeInteger(chunk.data.subarray(6, 10));\n\n      // ID3 reports the tag size excluding the header but it's more\n      // convenient for our comparisons to include it\n      tagSize += 10;\n    }\n\n    // if the entire frame has not arrived, wait for more data\n    if (bufferSize < tagSize) {\n      return;\n    }\n\n    // collect the entire frame so it can be parsed\n    tag = {\n      data: new Uint8Array(tagSize),\n      frames: [],\n      pts: buffer[0].pts,\n      dts: buffer[0].dts\n    };\n    for (i = 0; i < tagSize;) {\n      tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\n      i += buffer[0].data.byteLength;\n      bufferSize -= buffer[0].data.byteLength;\n      buffer.shift();\n    }\n\n    // find the start of the first frame and the end of the tag\n    frameStart = 10;\n    if (tag.data[5] & 0x40) {\n      // advance the frame start past the extended header\n      frameStart += 4; // header size field\n      frameStart += parseSyncSafeInteger(tag.data.subarray(10, 14));\n\n      // clip any padding off the end\n      tagSize -= parseSyncSafeInteger(tag.data.subarray(16, 20));\n    }\n\n    // parse one or more ID3 frames\n    // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n    do {\n      // determine the number of bytes in this frame\n      frameSize = parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));\n      if (frameSize < 1) {\n         // eslint-disable-next-line no-console\n        return console.log('Malformed ID3 frame encountered. Skipping metadata parsing.');\n      }\n      frameHeader = String.fromCharCode(tag.data[frameStart],\n                                        tag.data[frameStart + 1],\n                                        tag.data[frameStart + 2],\n                                        tag.data[frameStart + 3]);\n\n\n      frame = {\n        id: frameHeader,\n        data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\n      };\n      frame.key = frame.id;\n      if (tagParsers[frame.id]) {\n        tagParsers[frame.id](frame);\n\n        // handle the special PRIV frame used to indicate the start\n        // time for raw AAC data\n        if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\n          var\n            d = frame.data,\n            size = ((d[3] & 0x01)  << 30) |\n                   (d[4]  << 22) |\n                   (d[5] << 14) |\n                   (d[6] << 6) |\n                   (d[7] >>> 2);\n\n          size *= 4;\n          size += d[7] & 0x03;\n          frame.timeStamp = size;\n          // in raw AAC, all subsequent data will be timestamped based\n          // on the value of this frame\n          // we couldn't have known the appropriate pts and dts before\n          // parsing this ID3 tag so set those values now\n          if (tag.pts === undefined && tag.dts === undefined) {\n            tag.pts = frame.timeStamp;\n            tag.dts = frame.timeStamp;\n          }\n          this.trigger('timestamp', frame);\n        }\n      }\n      tag.frames.push(frame);\n\n      frameStart += 10; // advance past the frame header\n      frameStart += frameSize; // advance past the frame body\n    } while (frameStart < tagSize);\n    this.trigger('data', tag);\n  };\n};\nMetadataStream.prototype = new Stream();\n\nmodule.exports = MetadataStream;\n\n},{\"../utils/stream\":62,\"./stream-types\":53}],52:[function(require,module,exports){\n/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Utilities to detect basic properties and metadata about TS Segments.\n */\n'use strict';\n\nvar StreamTypes = require('./stream-types.js');\n\nvar parsePid = function(packet) {\n  var pid = packet[1] & 0x1f;\n  pid <<= 8;\n  pid |= packet[2];\n  return pid;\n};\n\nvar parsePayloadUnitStartIndicator = function(packet) {\n  return !!(packet[1] & 0x40);\n};\n\nvar parseAdaptionField = function(packet) {\n  var offset = 0;\n  // if an adaption field is present, its length is specified by the\n  // fifth byte of the TS packet header. The adaptation field is\n  // used to add stuffing to PES packets that don't fill a complete\n  // TS packet, and to specify some forms of timing and control data\n  // that we do not currently use.\n  if (((packet[3] & 0x30) >>> 4) > 0x01) {\n    offset += packet[4] + 1;\n  }\n  return offset;\n};\n\nvar parseType = function(packet, pmtPid) {\n  var pid = parsePid(packet);\n  if (pid === 0) {\n    return 'pat';\n  } else if (pid === pmtPid) {\n    return 'pmt';\n  } else if (pmtPid) {\n    return 'pes';\n  }\n  return null;\n};\n\nvar parsePat = function(packet) {\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  var offset = 4 + parseAdaptionField(packet);\n\n  if (pusi) {\n    offset += packet[offset] + 1;\n  }\n\n  return (packet[offset + 10] & 0x1f) << 8 | packet[offset + 11];\n};\n\nvar parsePmt = function(packet) {\n  var programMapTable = {};\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  var payloadOffset = 4 + parseAdaptionField(packet);\n\n  if (pusi) {\n    payloadOffset += packet[payloadOffset] + 1;\n  }\n\n  // PMTs can be sent ahead of the time when they should actually\n  // take effect. We don't believe this should ever be the case\n  // for HLS but we'll ignore \"forward\" PMT declarations if we see\n  // them. Future PMT declarations have the current_next_indicator\n  // set to zero.\n  if (!(packet[payloadOffset + 5] & 0x01)) {\n    return;\n  }\n\n  var sectionLength, tableEnd, programInfoLength;\n  // the mapping table ends at the end of the current section\n  sectionLength = (packet[payloadOffset + 1] & 0x0f) << 8 | packet[payloadOffset + 2];\n  tableEnd = 3 + sectionLength - 4;\n\n  // to determine where the table is, we have to figure out how\n  // long the program info descriptors are\n  programInfoLength = (packet[payloadOffset + 10] & 0x0f) << 8 | packet[payloadOffset + 11];\n\n  // advance the offset to the first entry in the mapping table\n  var offset = 12 + programInfoLength;\n  while (offset < tableEnd) {\n    var i = payloadOffset + offset;\n    // add an entry that maps the elementary_pid to the stream_type\n    programMapTable[(packet[i + 1] & 0x1F) << 8 | packet[i + 2]] = packet[i];\n\n    // move to the next table entry\n    // skip past the elementary stream descriptors, if present\n    offset += ((packet[i + 3] & 0x0F) << 8 | packet[i + 4]) + 5;\n  }\n  return programMapTable;\n};\n\nvar parsePesType = function(packet, programMapTable) {\n  var pid = parsePid(packet);\n  var type = programMapTable[pid];\n  switch (type) {\n    case StreamTypes.H264_STREAM_TYPE:\n      return 'video';\n    case StreamTypes.ADTS_STREAM_TYPE:\n      return 'audio';\n    case StreamTypes.METADATA_STREAM_TYPE:\n      return 'timed-metadata';\n    default:\n      return null;\n  }\n};\n\nvar parsePesTime = function(packet) {\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  if (!pusi) {\n    return null;\n  }\n\n  var offset = 4 + parseAdaptionField(packet);\n\n  if (offset >= packet.byteLength) {\n    // From the H 222.0 MPEG-TS spec\n    // \"For transport stream packets carrying PES packets, stuffing is needed when there\n    //  is insufficient PES packet data to completely fill the transport stream packet\n    //  payload bytes. Stuffing is accomplished by defining an adaptation field longer than\n    //  the sum of the lengths of the data elements in it, so that the payload bytes\n    //  remaining after the adaptation field exactly accommodates the available PES packet\n    //  data.\"\n    //\n    // If the offset is >= the length of the packet, then the packet contains no data\n    // and instead is just adaption field stuffing bytes\n    return null;\n  }\n\n  var pes = null;\n  var ptsDtsFlags;\n\n  // PES packets may be annotated with a PTS value, or a PTS value\n  // and a DTS value. Determine what combination of values is\n  // available to work with.\n  ptsDtsFlags = packet[offset + 7];\n\n  // PTS and DTS are normally stored as a 33-bit number.  Javascript\n  // performs all bitwise operations on 32-bit integers but javascript\n  // supports a much greater range (52-bits) of integer using standard\n  // mathematical operations.\n  // We construct a 31-bit value using bitwise operators over the 31\n  // most significant bits and then multiply by 4 (equal to a left-shift\n  // of 2) before we add the final 2 least significant bits of the\n  // timestamp (equal to an OR.)\n  if (ptsDtsFlags & 0xC0) {\n    pes = {};\n    // the PTS and DTS are not written out directly. For information\n    // on how they are encoded, see\n    // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n    pes.pts = (packet[offset + 9] & 0x0E) << 27 |\n      (packet[offset + 10] & 0xFF) << 20 |\n      (packet[offset + 11] & 0xFE) << 12 |\n      (packet[offset + 12] & 0xFF) <<  5 |\n      (packet[offset + 13] & 0xFE) >>>  3;\n    pes.pts *= 4; // Left shift by 2\n    pes.pts += (packet[offset + 13] & 0x06) >>> 1; // OR by the two LSBs\n    pes.dts = pes.pts;\n    if (ptsDtsFlags & 0x40) {\n      pes.dts = (packet[offset + 14] & 0x0E) << 27 |\n        (packet[offset + 15] & 0xFF) << 20 |\n        (packet[offset + 16] & 0xFE) << 12 |\n        (packet[offset + 17] & 0xFF) << 5 |\n        (packet[offset + 18] & 0xFE) >>> 3;\n      pes.dts *= 4; // Left shift by 2\n      pes.dts += (packet[offset + 18] & 0x06) >>> 1; // OR by the two LSBs\n    }\n  }\n  return pes;\n};\n\nvar parseNalUnitType = function(type) {\n  switch (type) {\n    case 0x05:\n      return 'slice_layer_without_partitioning_rbsp_idr';\n    case 0x06:\n      return 'sei_rbsp';\n    case 0x07:\n      return 'seq_parameter_set_rbsp';\n    case 0x08:\n      return 'pic_parameter_set_rbsp';\n    case 0x09:\n      return 'access_unit_delimiter_rbsp';\n    default:\n      return null;\n  }\n};\n\nvar videoPacketContainsKeyFrame = function(packet) {\n  var offset = 4 + parseAdaptionField(packet);\n  var frameBuffer = packet.subarray(offset);\n  var frameI = 0;\n  var frameSyncPoint = 0;\n  var foundKeyFrame = false;\n  var nalType;\n\n  // advance the sync point to a NAL start, if necessary\n  for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {\n    if (frameBuffer[frameSyncPoint + 2] === 1) {\n      // the sync point is properly aligned\n      frameI = frameSyncPoint + 5;\n      break;\n    }\n  }\n\n  while (frameI < frameBuffer.byteLength) {\n    // look at the current byte to determine if we've hit the end of\n    // a NAL unit boundary\n    switch (frameBuffer[frameI]) {\n    case 0:\n      // skip past non-sync sequences\n      if (frameBuffer[frameI - 1] !== 0) {\n        frameI += 2;\n        break;\n      } else if (frameBuffer[frameI - 2] !== 0) {\n        frameI++;\n        break;\n      }\n\n      if (frameSyncPoint + 3 !== frameI - 2) {\n        nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n        if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n          foundKeyFrame = true;\n        }\n      }\n\n      // drop trailing zeroes\n      do {\n        frameI++;\n      } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);\n      frameSyncPoint = frameI - 2;\n      frameI += 3;\n      break;\n    case 1:\n      // skip past non-sync sequences\n      if (frameBuffer[frameI - 1] !== 0 ||\n          frameBuffer[frameI - 2] !== 0) {\n        frameI += 3;\n        break;\n      }\n\n      nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n      if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n        foundKeyFrame = true;\n      }\n      frameSyncPoint = frameI - 2;\n      frameI += 3;\n      break;\n    default:\n      // the current byte isn't a one or zero, so it cannot be part\n      // of a sync sequence\n      frameI += 3;\n      break;\n    }\n  }\n  frameBuffer = frameBuffer.subarray(frameSyncPoint);\n  frameI -= frameSyncPoint;\n  frameSyncPoint = 0;\n  // parse the final nal\n  if (frameBuffer && frameBuffer.byteLength > 3) {\n    nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n    if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n      foundKeyFrame = true;\n    }\n  }\n\n  return foundKeyFrame;\n};\n\n\nmodule.exports = {\n  parseType: parseType,\n  parsePat: parsePat,\n  parsePmt: parsePmt,\n  parsePayloadUnitStartIndicator: parsePayloadUnitStartIndicator,\n  parsePesType: parsePesType,\n  parsePesTime: parsePesTime,\n  videoPacketContainsKeyFrame: videoPacketContainsKeyFrame\n};\n\n},{\"./stream-types.js\":53}],53:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  H264_STREAM_TYPE: 0x1B,\n  ADTS_STREAM_TYPE: 0x0F,\n  METADATA_STREAM_TYPE: 0x15\n};\n\n},{}],54:[function(require,module,exports){\n/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Accepts program elementary stream (PES) data events and corrects\n * decode and presentation time stamps to account for a rollover\n * of the 33 bit value.\n */\n\n'use strict';\n\nvar Stream = require('../utils/stream');\n\nvar MAX_TS = 8589934592;\n\nvar RO_THRESH = 4294967296;\n\nvar handleRollover = function(value, reference) {\n  var direction = 1;\n\n  if (value > reference) {\n    // If the current timestamp value is greater than our reference timestamp and we detect a\n    // timestamp rollover, this means the roll over is happening in the opposite direction.\n    // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\n    // point will be set to a small number, e.g. 1. The user then seeks backwards over the\n    // rollover point. In loading this segment, the timestamp values will be very large,\n    // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\n    // the time stamp to be `value - 2^33`.\n    direction = -1;\n  }\n\n  // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\n  // cause an incorrect adjustment.\n  while (Math.abs(reference - value) > RO_THRESH) {\n    value += (direction * MAX_TS);\n  }\n\n  return value;\n};\n\nvar TimestampRolloverStream = function(type) {\n  var lastDTS, referenceDTS;\n\n  TimestampRolloverStream.prototype.init.call(this);\n\n  this.type_ = type;\n\n  this.push = function(data) {\n    if (data.type !== this.type_) {\n      return;\n    }\n\n    if (referenceDTS === undefined) {\n      referenceDTS = data.dts;\n    }\n\n    data.dts = handleRollover(data.dts, referenceDTS);\n    data.pts = handleRollover(data.pts, referenceDTS);\n\n    lastDTS = data.dts;\n\n    this.trigger('data', data);\n  };\n\n  this.flush = function() {\n    referenceDTS = lastDTS;\n    this.trigger('done');\n  };\n\n  this.discontinuity = function() {\n    referenceDTS = void 0;\n    lastDTS = void 0;\n  };\n\n};\n\nTimestampRolloverStream.prototype = new Stream();\n\nmodule.exports = {\n  TimestampRolloverStream: TimestampRolloverStream,\n  handleRollover: handleRollover\n};\n\n},{\"../utils/stream\":62}],55:[function(require,module,exports){\nmodule.exports = {\n  generator: require('./mp4-generator'),\n  Transmuxer: require('./transmuxer').Transmuxer,\n  AudioSegmentStream: require('./transmuxer').AudioSegmentStream,\n  VideoSegmentStream: require('./transmuxer').VideoSegmentStream\n};\n\n},{\"./mp4-generator\":56,\"./transmuxer\":58}],56:[function(require,module,exports){\n/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Functions that generate fragmented MP4s suitable for use with Media\n * Source Extensions.\n */\n'use strict';\n\nvar UINT32_MAX = Math.pow(2, 32) - 1;\n\nvar box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd,\n    trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex,\n    trun, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR,\n    AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;\n\n// pre-calculate constants\n(function() {\n  var i;\n  types = {\n    avc1: [], // codingname\n    avcC: [],\n    btrt: [],\n    dinf: [],\n    dref: [],\n    esds: [],\n    ftyp: [],\n    hdlr: [],\n    mdat: [],\n    mdhd: [],\n    mdia: [],\n    mfhd: [],\n    minf: [],\n    moof: [],\n    moov: [],\n    mp4a: [], // codingname\n    mvex: [],\n    mvhd: [],\n    sdtp: [],\n    smhd: [],\n    stbl: [],\n    stco: [],\n    stsc: [],\n    stsd: [],\n    stsz: [],\n    stts: [],\n    styp: [],\n    tfdt: [],\n    tfhd: [],\n    traf: [],\n    trak: [],\n    trun: [],\n    trex: [],\n    tkhd: [],\n    vmhd: []\n  };\n\n  // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\n  // don't throw an error\n  if (typeof Uint8Array === 'undefined') {\n    return;\n  }\n\n  for (i in types) {\n    if (types.hasOwnProperty(i)) {\n      types[i] = [\n        i.charCodeAt(0),\n        i.charCodeAt(1),\n        i.charCodeAt(2),\n        i.charCodeAt(3)\n      ];\n    }\n  }\n\n  MAJOR_BRAND = new Uint8Array([\n    'i'.charCodeAt(0),\n    's'.charCodeAt(0),\n    'o'.charCodeAt(0),\n    'm'.charCodeAt(0)\n  ]);\n  AVC1_BRAND = new Uint8Array([\n    'a'.charCodeAt(0),\n    'v'.charCodeAt(0),\n    'c'.charCodeAt(0),\n    '1'.charCodeAt(0)\n  ]);\n  MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\n  VIDEO_HDLR = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x56, 0x69, 0x64, 0x65,\n    0x6f, 0x48, 0x61, 0x6e,\n    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n  ]);\n  AUDIO_HDLR = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x53, 0x6f, 0x75, 0x6e,\n    0x64, 0x48, 0x61, 0x6e,\n    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n  ]);\n  HDLR_TYPES = {\n    video: VIDEO_HDLR,\n    audio: AUDIO_HDLR\n  };\n  DREF = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version 0\n    0x00, 0x00, 0x01 // entry_flags\n  ]);\n  SMHD = new Uint8Array([\n    0x00,             // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00,       // balance, 0 means centered\n    0x00, 0x00        // reserved\n  ]);\n  STCO = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n  ]);\n  STSC = STCO;\n  STSZ = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n  ]);\n  STTS = STCO;\n  VMHD = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphicsmode\n    0x00, 0x00,\n    0x00, 0x00,\n    0x00, 0x00 // opcolor\n  ]);\n}());\n\nbox = function(type) {\n  var\n    payload = [],\n    size = 0,\n    i,\n    result,\n    view;\n\n  for (i = 1; i < arguments.length; i++) {\n    payload.push(arguments[i]);\n  }\n\n  i = payload.length;\n\n  // calculate the total size we need to allocate\n  while (i--) {\n    size += payload[i].byteLength;\n  }\n  result = new Uint8Array(size + 8);\n  view = new DataView(result.buffer, result.byteOffset, result.byteLength);\n  view.setUint32(0, result.byteLength);\n  result.set(type, 4);\n\n  // copy the payload into the result\n  for (i = 0, size = 8; i < payload.length; i++) {\n    result.set(payload[i], size);\n    size += payload[i].byteLength;\n  }\n  return result;\n};\n\ndinf = function() {\n  return box(types.dinf, box(types.dref, DREF));\n};\n\nesds = function(track) {\n  return box(types.esds, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n\n    // ES_Descriptor\n    0x03, // tag, ES_DescrTag\n    0x19, // length\n    0x00, 0x00, // ES_ID\n    0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\n\n    // DecoderConfigDescriptor\n    0x04, // tag, DecoderConfigDescrTag\n    0x11, // length\n    0x40, // object type\n    0x15,  // streamType\n    0x00, 0x06, 0x00, // bufferSizeDB\n    0x00, 0x00, 0xda, 0xc0, // maxBitrate\n    0x00, 0x00, 0xda, 0xc0, // avgBitrate\n\n    // DecoderSpecificInfo\n    0x05, // tag, DecoderSpecificInfoTag\n    0x02, // length\n    // ISO/IEC 14496-3, AudioSpecificConfig\n    // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\n    (track.audioobjecttype << 3) | (track.samplingfrequencyindex >>> 1),\n    (track.samplingfrequencyindex << 7) | (track.channelcount << 3),\n    0x06, 0x01, 0x02 // GASpecificConfig\n  ]));\n};\n\nftyp = function() {\n  return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\n};\n\nhdlr = function(type) {\n  return box(types.hdlr, HDLR_TYPES[type]);\n};\nmdat = function(data) {\n  return box(types.mdat, data);\n};\nmdhd = function(track) {\n  var result = new Uint8Array([\n    0x00,                   // version 0\n    0x00, 0x00, 0x00,       // flags\n    0x00, 0x00, 0x00, 0x02, // creation_time\n    0x00, 0x00, 0x00, 0x03, // modification_time\n    0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n\n    (track.duration >>> 24) & 0xFF,\n    (track.duration >>> 16) & 0xFF,\n    (track.duration >>>  8) & 0xFF,\n    track.duration & 0xFF,  // duration\n    0x55, 0xc4,             // 'und' language (undetermined)\n    0x00, 0x00\n  ]);\n\n  // Use the sample rate from the track metadata, when it is\n  // defined. The sample rate can be parsed out of an ADTS header, for\n  // instance.\n  if (track.samplerate) {\n    result[12] = (track.samplerate >>> 24) & 0xFF;\n    result[13] = (track.samplerate >>> 16) & 0xFF;\n    result[14] = (track.samplerate >>>  8) & 0xFF;\n    result[15] = (track.samplerate)        & 0xFF;\n  }\n\n  return box(types.mdhd, result);\n};\nmdia = function(track) {\n  return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\n};\nmfhd = function(sequenceNumber) {\n  return box(types.mfhd, new Uint8Array([\n    0x00,\n    0x00, 0x00, 0x00, // flags\n    (sequenceNumber & 0xFF000000) >> 24,\n    (sequenceNumber & 0xFF0000) >> 16,\n    (sequenceNumber & 0xFF00) >> 8,\n    sequenceNumber & 0xFF // sequence_number\n  ]));\n};\nminf = function(track) {\n  return box(types.minf,\n             track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD),\n             dinf(),\n             stbl(track));\n};\nmoof = function(sequenceNumber, tracks) {\n  var\n    trackFragments = [],\n    i = tracks.length;\n  // build traf boxes for each track fragment\n  while (i--) {\n    trackFragments[i] = traf(tracks[i]);\n  }\n  return box.apply(null, [\n    types.moof,\n    mfhd(sequenceNumber)\n  ].concat(trackFragments));\n};\n/**\n * Returns a movie box.\n * @param tracks {array} the tracks associated with this movie\n * @see ISO/IEC 14496-12:2012(E), section 8.2.1\n */\nmoov = function(tracks) {\n  var\n    i = tracks.length,\n    boxes = [];\n\n  while (i--) {\n    boxes[i] = trak(tracks[i]);\n  }\n\n  return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\n};\nmvex = function(tracks) {\n  var\n    i = tracks.length,\n    boxes = [];\n\n  while (i--) {\n    boxes[i] = trex(tracks[i]);\n  }\n  return box.apply(null, [types.mvex].concat(boxes));\n};\nmvhd = function(duration) {\n  var\n    bytes = new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01, // creation_time\n      0x00, 0x00, 0x00, 0x02, // modification_time\n      0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n      (duration & 0xFF000000) >> 24,\n      (duration & 0xFF0000) >> 16,\n      (duration & 0xFF00) >> 8,\n      duration & 0xFF, // duration\n      0x00, 0x01, 0x00, 0x00, // 1.0 rate\n      0x01, 0x00, // 1.0 volume\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n  return box(types.mvhd, bytes);\n};\n\nsdtp = function(track) {\n  var\n    samples = track.samples || [],\n    bytes = new Uint8Array(4 + samples.length),\n    flags,\n    i;\n\n  // leave the full box header (4 bytes) all zero\n\n  // write the sample table\n  for (i = 0; i < samples.length; i++) {\n    flags = samples[i].flags;\n\n    bytes[i + 4] = (flags.dependsOn << 4) |\n      (flags.isDependedOn << 2) |\n      (flags.hasRedundancy);\n  }\n\n  return box(types.sdtp,\n             bytes);\n};\n\nstbl = function(track) {\n  return box(types.stbl,\n             stsd(track),\n             box(types.stts, STTS),\n             box(types.stsc, STSC),\n             box(types.stsz, STSZ),\n             box(types.stco, STCO));\n};\n\n(function() {\n  var videoSample, audioSample;\n\n  stsd = function(track) {\n\n    return box(types.stsd, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01\n    ]), track.type === 'video' ? videoSample(track) : audioSample(track));\n  };\n\n  videoSample = function(track) {\n    var\n      sps = track.sps || [],\n      pps = track.pps || [],\n      sequenceParameterSets = [],\n      pictureParameterSets = [],\n      i;\n\n    // assemble the SPSs\n    for (i = 0; i < sps.length; i++) {\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF)); // sequenceParameterSetLength\n      sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < pps.length; i++) {\n      pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\n      pictureParameterSets.push((pps[i].byteLength & 0xFF));\n      pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\n    }\n\n    return box(types.avc1, new Uint8Array([\n      0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      (track.width & 0xff00) >> 8,\n      track.width & 0xff, // width\n      (track.height & 0xff00) >> 8,\n      track.height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n      0x13,\n      0x76, 0x69, 0x64, 0x65,\n      0x6f, 0x6a, 0x73, 0x2d,\n      0x63, 0x6f, 0x6e, 0x74,\n      0x72, 0x69, 0x62, 0x2d,\n      0x68, 0x6c, 0x73, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11 // pre_defined = -1\n    ]), box(types.avcC, new Uint8Array([\n      0x01, // configurationVersion\n      track.profileIdc, // AVCProfileIndication\n      track.profileCompatibility, // profile_compatibility\n      track.levelIdc, // AVCLevelIndication\n      0xff // lengthSizeMinusOne, hard-coded to 4 bytes\n    ].concat([\n      sps.length // numOfSequenceParameterSets\n    ]).concat(sequenceParameterSets).concat([\n      pps.length // numOfPictureParameterSets\n    ]).concat(pictureParameterSets))), // \"PPS\"\n            box(types.btrt, new Uint8Array([\n              0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n              0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n              0x00, 0x2d, 0xc6, 0xc0\n            ])) // avgBitrate\n              );\n  };\n\n  audioSample = function(track) {\n    return box(types.mp4a, new Uint8Array([\n\n      // SampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n\n      // AudioSampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      (track.channelcount & 0xff00) >> 8,\n      (track.channelcount & 0xff), // channelcount\n\n      (track.samplesize & 0xff00) >> 8,\n      (track.samplesize & 0xff), // samplesize\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n\n      (track.samplerate & 0xff00) >> 8,\n      (track.samplerate & 0xff),\n      0x00, 0x00 // samplerate, 16.16\n\n      // MP4AudioSampleEntry, ISO/IEC 14496-14\n    ]), esds(track));\n  };\n}());\n\ntkhd = function(track) {\n  var result = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x07, // flags\n    0x00, 0x00, 0x00, 0x00, // creation_time\n    0x00, 0x00, 0x00, 0x00, // modification_time\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    track.id & 0xFF, // track_ID\n    0x00, 0x00, 0x00, 0x00, // reserved\n    (track.duration & 0xFF000000) >> 24,\n    (track.duration & 0xFF0000) >> 16,\n    (track.duration & 0xFF00) >> 8,\n    track.duration & 0xFF, // duration\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, // layer\n    0x00, 0x00, // alternate_group\n    0x01, 0x00, // non-audio track volume\n    0x00, 0x00, // reserved\n    0x00, 0x01, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x01, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n    (track.width & 0xFF00) >> 8,\n    track.width & 0xFF,\n    0x00, 0x00, // width\n    (track.height & 0xFF00) >> 8,\n    track.height & 0xFF,\n    0x00, 0x00 // height\n  ]);\n\n  return box(types.tkhd, result);\n};\n\n/**\n * Generate a track fragment (traf) box. A traf box collects metadata\n * about tracks in a movie fragment (moof) box.\n */\ntraf = function(track) {\n  var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun,\n      sampleDependencyTable, dataOffset,\n      upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\n\n  trackFragmentHeader = box(types.tfhd, new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x3a, // flags\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    (track.id & 0xFF), // track_ID\n    0x00, 0x00, 0x00, 0x01, // sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x00, 0x00, 0x00  // default_sample_flags\n  ]));\n\n  upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / (UINT32_MAX + 1));\n  lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % (UINT32_MAX + 1));\n\n  trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([\n    0x01, // version 1\n    0x00, 0x00, 0x00, // flags\n    // baseMediaDecodeTime\n    (upperWordBaseMediaDecodeTime >>> 24) & 0xFF,\n    (upperWordBaseMediaDecodeTime >>> 16) & 0xFF,\n    (upperWordBaseMediaDecodeTime >>>  8) & 0xFF,\n    upperWordBaseMediaDecodeTime & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>> 24) & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>> 16) & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>>  8) & 0xFF,\n    lowerWordBaseMediaDecodeTime & 0xFF\n  ]));\n\n  // the data offset specifies the number of bytes from the start of\n  // the containing moof to the first payload byte of the associated\n  // mdat\n  dataOffset = (32 + // tfhd\n                20 + // tfdt\n                8 +  // traf header\n                16 + // mfhd\n                8 +  // moof header\n                8);  // mdat header\n\n  // audio tracks require less metadata\n  if (track.type === 'audio') {\n    trackFragmentRun = trun(track, dataOffset);\n    return box(types.traf,\n               trackFragmentHeader,\n               trackFragmentDecodeTime,\n               trackFragmentRun);\n  }\n\n  // video tracks should contain an independent and disposable samples\n  // box (sdtp)\n  // generate one and adjust offsets to match\n  sampleDependencyTable = sdtp(track);\n  trackFragmentRun = trun(track,\n                          sampleDependencyTable.length + dataOffset);\n  return box(types.traf,\n             trackFragmentHeader,\n             trackFragmentDecodeTime,\n             trackFragmentRun,\n             sampleDependencyTable);\n};\n\n/**\n * Generate a track box.\n * @param track {object} a track definition\n * @return {Uint8Array} the track box\n */\ntrak = function(track) {\n  track.duration = track.duration || 0xffffffff;\n  return box(types.trak,\n             tkhd(track),\n             mdia(track));\n};\n\ntrex = function(track) {\n  var result = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    (track.id & 0xFF), // track_ID\n    0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n  ]);\n  // the last two bytes of default_sample_flags is the sample\n  // degradation priority, a hint about the importance of this sample\n  // relative to others. Lower the degradation priority for all sample\n  // types other than video.\n  if (track.type !== 'video') {\n    result[result.length - 1] = 0x00;\n  }\n\n  return box(types.trex, result);\n};\n\n(function() {\n  var audioTrun, videoTrun, trunHeader;\n\n  // This method assumes all samples are uniform. That is, if a\n  // duration is present for the first sample, it will be present for\n  // all subsequent samples.\n  // see ISO/IEC 14496-12:2012, Section 8.8.8.1\n  trunHeader = function(samples, offset) {\n    var durationPresent = 0, sizePresent = 0,\n        flagsPresent = 0, compositionTimeOffset = 0;\n\n    // trun flag constants\n    if (samples.length) {\n      if (samples[0].duration !== undefined) {\n        durationPresent = 0x1;\n      }\n      if (samples[0].size !== undefined) {\n        sizePresent = 0x2;\n      }\n      if (samples[0].flags !== undefined) {\n        flagsPresent = 0x4;\n      }\n      if (samples[0].compositionTimeOffset !== undefined) {\n        compositionTimeOffset = 0x8;\n      }\n    }\n\n    return [\n      0x00, // version 0\n      0x00,\n      durationPresent | sizePresent | flagsPresent | compositionTimeOffset,\n      0x01, // flags\n      (samples.length & 0xFF000000) >>> 24,\n      (samples.length & 0xFF0000) >>> 16,\n      (samples.length & 0xFF00) >>> 8,\n      samples.length & 0xFF, // sample_count\n      (offset & 0xFF000000) >>> 24,\n      (offset & 0xFF0000) >>> 16,\n      (offset & 0xFF00) >>> 8,\n      offset & 0xFF // data_offset\n    ];\n  };\n\n  videoTrun = function(track, offset) {\n    var bytes, samples, sample, i;\n\n    samples = track.samples || [];\n    offset += 8 + 12 + (16 * samples.length);\n\n    bytes = trunHeader(samples, offset);\n\n    for (i = 0; i < samples.length; i++) {\n      sample = samples[i];\n      bytes = bytes.concat([\n        (sample.duration & 0xFF000000) >>> 24,\n        (sample.duration & 0xFF0000) >>> 16,\n        (sample.duration & 0xFF00) >>> 8,\n        sample.duration & 0xFF, // sample_duration\n        (sample.size & 0xFF000000) >>> 24,\n        (sample.size & 0xFF0000) >>> 16,\n        (sample.size & 0xFF00) >>> 8,\n        sample.size & 0xFF, // sample_size\n        (sample.flags.isLeading << 2) | sample.flags.dependsOn,\n        (sample.flags.isDependedOn << 6) |\n          (sample.flags.hasRedundancy << 4) |\n          (sample.flags.paddingValue << 1) |\n          sample.flags.isNonSyncSample,\n        sample.flags.degradationPriority & 0xF0 << 8,\n        sample.flags.degradationPriority & 0x0F, // sample_flags\n        (sample.compositionTimeOffset & 0xFF000000) >>> 24,\n        (sample.compositionTimeOffset & 0xFF0000) >>> 16,\n        (sample.compositionTimeOffset & 0xFF00) >>> 8,\n        sample.compositionTimeOffset & 0xFF // sample_composition_time_offset\n      ]);\n    }\n    return box(types.trun, new Uint8Array(bytes));\n  };\n\n  audioTrun = function(track, offset) {\n    var bytes, samples, sample, i;\n\n    samples = track.samples || [];\n    offset += 8 + 12 + (8 * samples.length);\n\n    bytes = trunHeader(samples, offset);\n\n    for (i = 0; i < samples.length; i++) {\n      sample = samples[i];\n      bytes = bytes.concat([\n        (sample.duration & 0xFF000000) >>> 24,\n        (sample.duration & 0xFF0000) >>> 16,\n        (sample.duration & 0xFF00) >>> 8,\n        sample.duration & 0xFF, // sample_duration\n        (sample.size & 0xFF000000) >>> 24,\n        (sample.size & 0xFF0000) >>> 16,\n        (sample.size & 0xFF00) >>> 8,\n        sample.size & 0xFF]); // sample_size\n    }\n\n    return box(types.trun, new Uint8Array(bytes));\n  };\n\n  trun = function(track, offset) {\n    if (track.type === 'audio') {\n      return audioTrun(track, offset);\n    }\n\n    return videoTrun(track, offset);\n  };\n}());\n\nmodule.exports = {\n  ftyp: ftyp,\n  mdat: mdat,\n  moof: moof,\n  moov: moov,\n  initSegment: function(tracks) {\n    var\n      fileType = ftyp(),\n      movie = moov(tracks),\n      result;\n\n    result = new Uint8Array(fileType.byteLength + movie.byteLength);\n    result.set(fileType);\n    result.set(movie, fileType.byteLength);\n    return result;\n  }\n};\n\n},{}],57:[function(require,module,exports){\n/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Utilities to detect basic properties and metadata about MP4s.\n */\n'use strict';\n\nvar findBox, parseType, timescale, startTime;\n\n// Find the data for a box specified by its path\nfindBox = function(data, path) {\n  var results = [],\n      i, size, type, end, subresults;\n\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return null;\n  }\n\n  for (i = 0; i < data.byteLength;) {\n    size  = data[i]     << 24;\n    size |= data[i + 1] << 16;\n    size |= data[i + 2] << 8;\n    size |= data[i + 3];\n\n    type = parseType(data.subarray(i + 4, i + 8));\n\n    end = size > 1 ? i + size : data.byteLength;\n\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, end));\n      } else {\n        // recursively search for the next box along the path\n        subresults = findBox(data.subarray(i + 8, end), path.slice(1));\n        if (subresults.length) {\n          results = results.concat(subresults);\n        }\n      }\n    }\n    i = end;\n  }\n\n  // we've finished searching all of data\n  return results;\n};\n\n/**\n * Returns the string representation of an ASCII encoded four byte buffer.\n * @param buffer {Uint8Array} a four-byte buffer to translate\n * @return {string} the corresponding string\n */\nparseType = function(buffer) {\n  var result = '';\n  result += String.fromCharCode(buffer[0]);\n  result += String.fromCharCode(buffer[1]);\n  result += String.fromCharCode(buffer[2]);\n  result += String.fromCharCode(buffer[3]);\n  return result;\n};\n\n/**\n * Parses an MP4 initialization segment and extracts the timescale\n * values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * ```\n * @param init {Uint8Array} the bytes of the init segment\n * @return {object} a hash of track ids to timescale values or null if\n * the init segment is malformed.\n */\ntimescale = function(init) {\n  var\n    result = {},\n    traks = findBox(init, ['moov', 'trak']);\n\n  // mdhd timescale\n  return traks.reduce(function(result, trak) {\n    var tkhd, version, index, id, mdhd;\n\n    tkhd = findBox(trak, ['tkhd'])[0];\n    if (!tkhd) {\n      return null;\n    }\n    version = tkhd[0];\n    index = version === 0 ? 12 : 20;\n    id = tkhd[index]     << 24 |\n         tkhd[index + 1] << 16 |\n         tkhd[index + 2] <<  8 |\n         tkhd[index + 3];\n\n    mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n    if (!mdhd) {\n      return null;\n    }\n    version = mdhd[0];\n    index = version === 0 ? 12 : 20;\n    result[id] = mdhd[index]     << 24 |\n                 mdhd[index + 1] << 16 |\n                 mdhd[index + 2] <<  8 |\n                 mdhd[index + 3];\n    return result;\n  }, result);\n};\n\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param timescale {object} a hash of track ids to timescale values.\n * @return {number} the earliest base media decode start time for the\n * fragment, in seconds\n */\nstartTime = function(timescale, fragment) {\n  var trafs, baseTimes, result;\n\n  // we need info from two childrend of each track fragment box\n  trafs = findBox(fragment, ['moof', 'traf']);\n\n  // determine the start times for each track\n  baseTimes = [].concat.apply([], trafs.map(function(traf) {\n    return findBox(traf, ['tfhd']).map(function(tfhd) {\n      var id, scale, baseTime;\n\n      // get the track id from the tfhd\n      id = tfhd[4] << 24 |\n           tfhd[5] << 16 |\n           tfhd[6] << 8 |\n           tfhd[7];\n      // assume a 90kHz clock if no timescale was specified\n      scale = timescale[id] || 90e3;\n\n      // get the base media decode time from the tfdt\n      baseTime = findBox(traf, ['tfdt']).map(function(tfdt) {\n        var version, result;\n\n        version = tfdt[0];\n        result = tfdt[4] << 24 |\n                 tfdt[5] << 16 |\n                 tfdt[6] <<  8 |\n                 tfdt[7];\n        if (version ===  1) {\n          result *= Math.pow(2, 32);\n          result += tfdt[8]  << 24 |\n                    tfdt[9]  << 16 |\n                    tfdt[10] <<  8 |\n                    tfdt[11];\n        }\n        return result;\n      })[0];\n      baseTime = baseTime || Infinity;\n\n      // convert base time to seconds\n      return baseTime / scale;\n    });\n  }));\n\n  // return the minimum\n  result = Math.min.apply(null, baseTimes);\n  return isFinite(result) ? result : 0;\n};\n\nmodule.exports = {\n  parseType: parseType,\n  timescale: timescale,\n  startTime: startTime\n};\n\n},{}],58:[function(require,module,exports){\n/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * A stream-based mp2t to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\nvar mp4 = require('./mp4-generator.js');\nvar m2ts = require('../m2ts/m2ts.js');\nvar AdtsStream = require('../codecs/adts.js');\nvar H264Stream = require('../codecs/h264').H264Stream;\nvar AacStream = require('../aac');\nvar coneOfSilence = require('../data/silence');\nvar clock = require('../utils/clock');\n\n// constants\nvar AUDIO_PROPERTIES = [\n  'audioobjecttype',\n  'channelcount',\n  'samplerate',\n  'samplingfrequencyindex',\n  'samplesize'\n];\n\nvar VIDEO_PROPERTIES = [\n  'width',\n  'height',\n  'profileIdc',\n  'levelIdc',\n  'profileCompatibility'\n];\n\nvar ONE_SECOND_IN_TS = 90000; // 90kHz clock\n\n// object types\nvar VideoSegmentStream, AudioSegmentStream, Transmuxer, CoalesceStream;\n\n// Helper functions\nvar\n  createDefaultSample,\n  isLikelyAacData,\n  collectDtsInfo,\n  clearDtsInfo,\n  calculateTrackBaseMediaDecodeTime,\n  arrayEquals,\n  sumFrameByteLengths;\n\n/**\n * Default sample object\n * see ISO/IEC 14496-12:2012, section 8.6.4.3\n */\ncreateDefaultSample = function() {\n  return {\n    size: 0,\n    flags: {\n      isLeading: 0,\n      dependsOn: 1,\n      isDependedOn: 0,\n      hasRedundancy: 0,\n      degradationPriority: 0\n    }\n  };\n};\n\nisLikelyAacData = function(data) {\n  if ((data[0] === 'I'.charCodeAt(0)) &&\n      (data[1] === 'D'.charCodeAt(0)) &&\n      (data[2] === '3'.charCodeAt(0))) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Compare two arrays (even typed) for same-ness\n */\narrayEquals = function(a, b) {\n  var\n    i;\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  // compare the value of each element in the array\n  for (i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Sum the `byteLength` properties of the data in each AAC frame\n */\nsumFrameByteLengths = function(array) {\n  var\n    i,\n    currentObj,\n    sum = 0;\n\n  // sum the byteLength's all each nal unit in the frame\n  for (i = 0; i < array.length; i++) {\n    currentObj = array[i];\n    sum += currentObj.data.byteLength;\n  }\n\n  return sum;\n};\n\n/**\n * Constructs a single-track, ISO BMFF media segment from AAC data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n */\nAudioSegmentStream = function(track) {\n  var\n    adtsFrames = [],\n    sequenceNumber = 0,\n    earliestAllowedDts = 0,\n    audioAppendStartTs = 0,\n    videoBaseMediaDecodeTime = Infinity;\n\n  AudioSegmentStream.prototype.init.call(this);\n\n  this.push = function(data) {\n    collectDtsInfo(track, data);\n\n    if (track) {\n      AUDIO_PROPERTIES.forEach(function(prop) {\n        track[prop] = data[prop];\n      });\n    }\n\n    // buffer audio data until end() is called\n    adtsFrames.push(data);\n  };\n\n  this.setEarliestDts = function(earliestDts) {\n    earliestAllowedDts = earliestDts - track.timelineStartInfo.baseMediaDecodeTime;\n  };\n\n  this.setVideoBaseMediaDecodeTime = function(baseMediaDecodeTime) {\n    videoBaseMediaDecodeTime = baseMediaDecodeTime;\n  };\n\n  this.setAudioAppendStart = function(timestamp) {\n    audioAppendStartTs = timestamp;\n  };\n\n  this.flush = function() {\n    var\n      frames,\n      moof,\n      mdat,\n      boxes;\n\n    // return early if no audio data has been observed\n    if (adtsFrames.length === 0) {\n      this.trigger('done', 'AudioSegmentStream');\n      return;\n    }\n\n    frames = this.trimAdtsFramesByEarliestDts_(adtsFrames);\n    track.baseMediaDecodeTime = calculateTrackBaseMediaDecodeTime(track);\n\n    this.prefixWithSilence_(track, frames);\n\n    // we have to build the index from byte locations to\n    // samples (that is, adts frames) in the audio data\n    track.samples = this.generateSampleTable_(frames);\n\n    // concatenate the audio data to constuct the mdat\n    mdat = mp4.mdat(this.concatenateFrameData_(frames));\n\n    adtsFrames = [];\n\n    moof = mp4.moof(sequenceNumber, [track]);\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n\n    // bump the sequence number for next time\n    sequenceNumber++;\n\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n\n    clearDtsInfo(track);\n\n    this.trigger('data', {track: track, boxes: boxes});\n    this.trigger('done', 'AudioSegmentStream');\n  };\n\n  // Possibly pad (prefix) the audio track with silence if appending this track\n  // would lead to the introduction of a gap in the audio buffer\n  this.prefixWithSilence_ = function(track, frames) {\n    var\n      baseMediaDecodeTimeTs,\n      frameDuration = 0,\n      audioGapDuration = 0,\n      audioFillFrameCount = 0,\n      audioFillDuration = 0,\n      silentFrame,\n      i;\n\n    if (!frames.length) {\n      return;\n    }\n\n    baseMediaDecodeTimeTs = clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);\n    // determine frame clock duration based on sample rate, round up to avoid overfills\n    frameDuration = Math.ceil(ONE_SECOND_IN_TS / (track.samplerate / 1024));\n\n    if (audioAppendStartTs && videoBaseMediaDecodeTime) {\n      // insert the shortest possible amount (audio gap or audio to video gap)\n      audioGapDuration =\n        baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);\n      // number of full frames in the audio gap\n      audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\n      audioFillDuration = audioFillFrameCount * frameDuration;\n    }\n\n    // don't attempt to fill gaps smaller than a single frame or larger\n    // than a half second\n    if (audioFillFrameCount < 1 || audioFillDuration > ONE_SECOND_IN_TS / 2) {\n      return;\n    }\n\n    silentFrame = coneOfSilence[track.samplerate];\n\n    if (!silentFrame) {\n      // we don't have a silent frame pregenerated for the sample rate, so use a frame\n      // from the content instead\n      silentFrame = frames[0].data;\n    }\n\n    for (i = 0; i < audioFillFrameCount; i++) {\n      frames.splice(i, 0, {\n        data: silentFrame\n      });\n    }\n\n    track.baseMediaDecodeTime -=\n      Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));\n  };\n\n  // If the audio segment extends before the earliest allowed dts\n  // value, remove AAC frames until starts at or after the earliest\n  // allowed DTS so that we don't end up with a negative baseMedia-\n  // DecodeTime for the audio track\n  this.trimAdtsFramesByEarliestDts_ = function(adtsFrames) {\n    if (track.minSegmentDts >= earliestAllowedDts) {\n      return adtsFrames;\n    }\n\n    // We will need to recalculate the earliest segment Dts\n    track.minSegmentDts = Infinity;\n\n    return adtsFrames.filter(function(currentFrame) {\n      // If this is an allowed frame, keep it and record it's Dts\n      if (currentFrame.dts >= earliestAllowedDts) {\n        track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\n        track.minSegmentPts = track.minSegmentDts;\n        return true;\n      }\n      // Otherwise, discard it\n      return false;\n    });\n  };\n\n  // generate the track's raw mdat data from an array of frames\n  this.generateSampleTable_ = function(frames) {\n    var\n      i,\n      currentFrame,\n      samples = [];\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n      samples.push({\n        size: currentFrame.data.byteLength,\n        duration: 1024 // For AAC audio, all samples contain 1024 samples\n      });\n    }\n    return samples;\n  };\n\n  // generate the track's sample table from an array of frames\n  this.concatenateFrameData_ = function(frames) {\n    var\n      i,\n      currentFrame,\n      dataOffset = 0,\n      data = new Uint8Array(sumFrameByteLengths(frames));\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n\n      data.set(currentFrame.data, dataOffset);\n      dataOffset += currentFrame.data.byteLength;\n    }\n    return data;\n  };\n};\n\nAudioSegmentStream.prototype = new Stream();\n\n/**\n * Constructs a single-track, ISO BMFF media segment from H264 data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n * @param track {object} track metadata configuration\n * @param options {object} transmuxer options object\n * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n *        gopsToAlignWith list when attempting to align gop pts\n */\nVideoSegmentStream = function(track, options) {\n  var\n    sequenceNumber = 0,\n    nalUnits = [],\n    gopsToAlignWith = [],\n    config,\n    pps;\n\n  options = options || {};\n\n  VideoSegmentStream.prototype.init.call(this);\n\n  delete track.minPTS;\n\n  this.gopCache_ = [];\n\n  this.push = function(nalUnit) {\n    collectDtsInfo(track, nalUnit);\n\n    // record the track config\n    if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n      config = nalUnit.config;\n      track.sps = [nalUnit.data];\n\n      VIDEO_PROPERTIES.forEach(function(prop) {\n        track[prop] = config[prop];\n      }, this);\n    }\n\n    if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' &&\n        !pps) {\n      pps = nalUnit.data;\n      track.pps = [nalUnit.data];\n    }\n\n    // buffer video until flush() is called\n    nalUnits.push(nalUnit);\n  };\n\n  this.flush = function() {\n    var\n      frames,\n      gopForFusion,\n      gops,\n      moof,\n      mdat,\n      boxes;\n\n    // Throw away nalUnits at the start of the byte stream until\n    // we find the first AUD\n    while (nalUnits.length) {\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n        break;\n      }\n      nalUnits.shift();\n    }\n\n    // Return early if no video data has been observed\n    if (nalUnits.length === 0) {\n      this.resetStream_();\n      this.trigger('done', 'VideoSegmentStream');\n      return;\n    }\n\n    // Organize the raw nal-units into arrays that represent\n    // higher-level constructs such as frames and gops\n    // (group-of-pictures)\n    frames = this.groupNalsIntoFrames_(nalUnits);\n    gops = this.groupFramesIntoGops_(frames);\n\n    // If the first frame of this fragment is not a keyframe we have\n    // a problem since MSE (on Chrome) requires a leading keyframe.\n    //\n    // We have two approaches to repairing this situation:\n    // 1) GOP-FUSION:\n    //    This is where we keep track of the GOPS (group-of-pictures)\n    //    from previous fragments and attempt to find one that we can\n    //    prepend to the current fragment in order to create a valid\n    //    fragment.\n    // 2) KEYFRAME-PULLING:\n    //    Here we search for the first keyframe in the fragment and\n    //    throw away all the frames between the start of the fragment\n    //    and that keyframe. We then extend the duration and pull the\n    //    PTS of the keyframe forward so that it covers the time range\n    //    of the frames that were disposed of.\n    //\n    // #1 is far prefereable over #2 which can cause \"stuttering\" but\n    // requires more things to be just right.\n    if (!gops[0][0].keyFrame) {\n      // Search for a gop for fusion from our gopCache\n      gopForFusion = this.getGopForFusion_(nalUnits[0], track);\n\n      if (gopForFusion) {\n        gops.unshift(gopForFusion);\n        // Adjust Gops' metadata to account for the inclusion of the\n        // new gop at the beginning\n        gops.byteLength += gopForFusion.byteLength;\n        gops.nalCount += gopForFusion.nalCount;\n        gops.pts = gopForFusion.pts;\n        gops.dts = gopForFusion.dts;\n        gops.duration += gopForFusion.duration;\n      } else {\n        // If we didn't find a candidate gop fall back to keyrame-pulling\n        gops = this.extendFirstKeyFrame_(gops);\n      }\n    }\n\n    // Trim gops to align with gopsToAlignWith\n    if (gopsToAlignWith.length) {\n      var alignedGops;\n\n      if (options.alignGopsAtEnd) {\n        alignedGops = this.alignGopsAtEnd_(gops);\n      } else {\n        alignedGops = this.alignGopsAtStart_(gops);\n      }\n\n      if (!alignedGops) {\n        // save all the nals in the last GOP into the gop cache\n        this.gopCache_.unshift({\n          gop: gops.pop(),\n          pps: track.pps,\n          sps: track.sps\n        });\n\n        // Keep a maximum of 6 GOPs in the cache\n        this.gopCache_.length = Math.min(6, this.gopCache_.length);\n\n        // Clear nalUnits\n        nalUnits = [];\n\n        // return early no gops can be aligned with desired gopsToAlignWith\n        this.resetStream_();\n        this.trigger('done', 'VideoSegmentStream');\n        return;\n      }\n\n      // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\n      // when recalculated before sending off to CoalesceStream\n      clearDtsInfo(track);\n\n      gops = alignedGops;\n    }\n\n    collectDtsInfo(track, gops);\n\n    // First, we have to build the index from byte locations to\n    // samples (that is, frames) in the video data\n    track.samples = this.generateSampleTable_(gops);\n\n    // Concatenate the video data and construct the mdat\n    mdat = mp4.mdat(this.concatenateNalData_(gops));\n\n    track.baseMediaDecodeTime = calculateTrackBaseMediaDecodeTime(track);\n\n    this.trigger('processedGopsInfo', gops.map(function(gop) {\n      return {\n        pts: gop.pts,\n        dts: gop.dts,\n        byteLength: gop.byteLength\n      };\n    }));\n\n    // save all the nals in the last GOP into the gop cache\n    this.gopCache_.unshift({\n      gop: gops.pop(),\n      pps: track.pps,\n      sps: track.sps\n    });\n\n    // Keep a maximum of 6 GOPs in the cache\n    this.gopCache_.length = Math.min(6, this.gopCache_.length);\n\n    // Clear nalUnits\n    nalUnits = [];\n\n    this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\n    this.trigger('timelineStartInfo', track.timelineStartInfo);\n\n    moof = mp4.moof(sequenceNumber, [track]);\n\n    // it would be great to allocate this array up front instead of\n    // throwing away hundreds of media segment fragments\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n\n    // Bump the sequence number for next time\n    sequenceNumber++;\n\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n\n    this.trigger('data', {track: track, boxes: boxes});\n\n    this.resetStream_();\n\n    // Continue with the flush process now\n    this.trigger('done', 'VideoSegmentStream');\n  };\n\n  this.resetStream_ = function() {\n    clearDtsInfo(track);\n\n    // reset config and pps because they may differ across segments\n    // for instance, when we are rendition switching\n    config = undefined;\n    pps = undefined;\n  };\n\n  // Search for a candidate Gop for gop-fusion from the gop cache and\n  // return it or return null if no good candidate was found\n  this.getGopForFusion_ = function(nalUnit) {\n    var\n      halfSecond = 45000, // Half-a-second in a 90khz clock\n      allowableOverlap = 10000, // About 3 frames @ 30fps\n      nearestDistance = Infinity,\n      dtsDistance,\n      nearestGopObj,\n      currentGop,\n      currentGopObj,\n      i;\n\n    // Search for the GOP nearest to the beginning of this nal unit\n    for (i = 0; i < this.gopCache_.length; i++) {\n      currentGopObj = this.gopCache_[i];\n      currentGop = currentGopObj.gop;\n\n      // Reject Gops with different SPS or PPS\n      if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) ||\n          !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\n        continue;\n      }\n\n      // Reject Gops that would require a negative baseMediaDecodeTime\n      if (currentGop.dts < track.timelineStartInfo.dts) {\n        continue;\n      }\n\n      // The distance between the end of the gop and the start of the nalUnit\n      dtsDistance = (nalUnit.dts - currentGop.dts) - currentGop.duration;\n\n      // Only consider GOPS that start before the nal unit and end within\n      // a half-second of the nal unit\n      if (dtsDistance >= -allowableOverlap &&\n          dtsDistance <= halfSecond) {\n\n        // Always use the closest GOP we found if there is more than\n        // one candidate\n        if (!nearestGopObj ||\n            nearestDistance > dtsDistance) {\n          nearestGopObj = currentGopObj;\n          nearestDistance = dtsDistance;\n        }\n      }\n    }\n\n    if (nearestGopObj) {\n      return nearestGopObj.gop;\n    }\n    return null;\n  };\n\n  this.extendFirstKeyFrame_ = function(gops) {\n    var currentGop;\n\n    if (!gops[0][0].keyFrame && gops.length > 1) {\n      // Remove the first GOP\n      currentGop = gops.shift();\n\n      gops.byteLength -=  currentGop.byteLength;\n      gops.nalCount -= currentGop.nalCount;\n\n      // Extend the first frame of what is now the\n      // first gop to cover the time period of the\n      // frames we just removed\n      gops[0][0].dts = currentGop.dts;\n      gops[0][0].pts = currentGop.pts;\n      gops[0][0].duration += currentGop.duration;\n    }\n\n    return gops;\n  };\n\n  // Convert an array of nal units into an array of frames with each frame being\n  // composed of the nal units that make up that frame\n  // Also keep track of cummulative data about the frame from the nal units such\n  // as the frame duration, starting pts, etc.\n  this.groupNalsIntoFrames_ = function(nalUnits) {\n    var\n      i,\n      currentNal,\n      currentFrame = [],\n      frames = [];\n\n    currentFrame.byteLength = 0;\n\n    for (i = 0; i < nalUnits.length; i++) {\n      currentNal = nalUnits[i];\n\n      // Split on 'aud'-type nal units\n      if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n        // Since the very first nal unit is expected to be an AUD\n        // only push to the frames array when currentFrame is not empty\n        if (currentFrame.length) {\n          currentFrame.duration = currentNal.dts - currentFrame.dts;\n          frames.push(currentFrame);\n        }\n        currentFrame = [currentNal];\n        currentFrame.byteLength = currentNal.data.byteLength;\n        currentFrame.pts = currentNal.pts;\n        currentFrame.dts = currentNal.dts;\n      } else {\n        // Specifically flag key frames for ease of use later\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n          currentFrame.keyFrame = true;\n        }\n        currentFrame.duration = currentNal.dts - currentFrame.dts;\n        currentFrame.byteLength += currentNal.data.byteLength;\n        currentFrame.push(currentNal);\n      }\n    }\n\n    // For the last frame, use the duration of the previous frame if we\n    // have nothing better to go on\n    if (frames.length &&\n        (!currentFrame.duration ||\n         currentFrame.duration <= 0)) {\n      currentFrame.duration = frames[frames.length - 1].duration;\n    }\n\n    // Push the final frame\n    frames.push(currentFrame);\n    return frames;\n  };\n\n  // Convert an array of frames into an array of Gop with each Gop being composed\n  // of the frames that make up that Gop\n  // Also keep track of cummulative data about the Gop from the frames such as the\n  // Gop duration, starting pts, etc.\n  this.groupFramesIntoGops_ = function(frames) {\n    var\n      i,\n      currentFrame,\n      currentGop = [],\n      gops = [];\n\n    // We must pre-set some of the values on the Gop since we\n    // keep running totals of these values\n    currentGop.byteLength = 0;\n    currentGop.nalCount = 0;\n    currentGop.duration = 0;\n    currentGop.pts = frames[0].pts;\n    currentGop.dts = frames[0].dts;\n\n    // store some metadata about all the Gops\n    gops.byteLength = 0;\n    gops.nalCount = 0;\n    gops.duration = 0;\n    gops.pts = frames[0].pts;\n    gops.dts = frames[0].dts;\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n\n      if (currentFrame.keyFrame) {\n        // Since the very first frame is expected to be an keyframe\n        // only push to the gops array when currentGop is not empty\n        if (currentGop.length) {\n          gops.push(currentGop);\n          gops.byteLength += currentGop.byteLength;\n          gops.nalCount += currentGop.nalCount;\n          gops.duration += currentGop.duration;\n        }\n\n        currentGop = [currentFrame];\n        currentGop.nalCount = currentFrame.length;\n        currentGop.byteLength = currentFrame.byteLength;\n        currentGop.pts = currentFrame.pts;\n        currentGop.dts = currentFrame.dts;\n        currentGop.duration = currentFrame.duration;\n      } else {\n        currentGop.duration += currentFrame.duration;\n        currentGop.nalCount += currentFrame.length;\n        currentGop.byteLength += currentFrame.byteLength;\n        currentGop.push(currentFrame);\n      }\n    }\n\n    if (gops.length && currentGop.duration <= 0) {\n      currentGop.duration = gops[gops.length - 1].duration;\n    }\n    gops.byteLength += currentGop.byteLength;\n    gops.nalCount += currentGop.nalCount;\n    gops.duration += currentGop.duration;\n\n    // push the final Gop\n    gops.push(currentGop);\n    return gops;\n  };\n\n  // generate the track's sample table from an array of gops\n  this.generateSampleTable_ = function(gops, baseDataOffset) {\n    var\n      h, i,\n      sample,\n      currentGop,\n      currentFrame,\n      dataOffset = baseDataOffset || 0,\n      samples = [];\n\n    for (h = 0; h < gops.length; h++) {\n      currentGop = gops[h];\n\n      for (i = 0; i < currentGop.length; i++) {\n        currentFrame = currentGop[i];\n\n        sample = createDefaultSample();\n\n        sample.dataOffset = dataOffset;\n        sample.compositionTimeOffset = currentFrame.pts - currentFrame.dts;\n        sample.duration = currentFrame.duration;\n        sample.size = 4 * currentFrame.length; // Space for nal unit size\n        sample.size += currentFrame.byteLength;\n\n        if (currentFrame.keyFrame) {\n          sample.flags.dependsOn = 2;\n        }\n\n        dataOffset += sample.size;\n\n        samples.push(sample);\n      }\n    }\n    return samples;\n  };\n\n  // generate the track's raw mdat data from an array of gops\n  this.concatenateNalData_ = function(gops) {\n    var\n      h, i, j,\n      currentGop,\n      currentFrame,\n      currentNal,\n      dataOffset = 0,\n      nalsByteLength = gops.byteLength,\n      numberOfNals = gops.nalCount,\n      totalByteLength = nalsByteLength + 4 * numberOfNals,\n      data = new Uint8Array(totalByteLength),\n      view = new DataView(data.buffer);\n\n    // For each Gop..\n    for (h = 0; h < gops.length; h++) {\n      currentGop = gops[h];\n\n      // For each Frame..\n      for (i = 0; i < currentGop.length; i++) {\n        currentFrame = currentGop[i];\n\n        // For each NAL..\n        for (j = 0; j < currentFrame.length; j++) {\n          currentNal = currentFrame[j];\n\n          view.setUint32(dataOffset, currentNal.data.byteLength);\n          dataOffset += 4;\n          data.set(currentNal.data, dataOffset);\n          dataOffset += currentNal.data.byteLength;\n        }\n      }\n    }\n    return data;\n  };\n\n  // trim gop list to the first gop found that has a matching pts with a gop in the list\n  // of gopsToAlignWith starting from the START of the list\n  this.alignGopsAtStart_ = function(gops) {\n    var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\n\n    byteLength = gops.byteLength;\n    nalCount = gops.nalCount;\n    duration = gops.duration;\n    alignIndex = gopIndex = 0;\n\n    while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\n      align = gopsToAlignWith[alignIndex];\n      gop = gops[gopIndex];\n\n      if (align.pts === gop.pts) {\n        break;\n      }\n\n      if (gop.pts > align.pts) {\n        // this current gop starts after the current gop we want to align on, so increment\n        // align index\n        alignIndex++;\n        continue;\n      }\n\n      // current gop starts before the current gop we want to align on. so increment gop\n      // index\n      gopIndex++;\n      byteLength -= gop.byteLength;\n      nalCount -= gop.nalCount;\n      duration -= gop.duration;\n    }\n\n    if (gopIndex === 0) {\n      // no gops to trim\n      return gops;\n    }\n\n    if (gopIndex === gops.length) {\n      // all gops trimmed, skip appending all gops\n      return null;\n    }\n\n    alignedGops = gops.slice(gopIndex);\n    alignedGops.byteLength = byteLength;\n    alignedGops.duration = duration;\n    alignedGops.nalCount = nalCount;\n    alignedGops.pts = alignedGops[0].pts;\n    alignedGops.dts = alignedGops[0].dts;\n\n    return alignedGops;\n  };\n\n  // trim gop list to the first gop found that has a matching pts with a gop in the list\n  // of gopsToAlignWith starting from the END of the list\n  this.alignGopsAtEnd_ = function(gops) {\n    var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\n\n    alignIndex = gopsToAlignWith.length - 1;\n    gopIndex = gops.length - 1;\n    alignEndIndex = null;\n    matchFound = false;\n\n    while (alignIndex >= 0 && gopIndex >= 0) {\n      align = gopsToAlignWith[alignIndex];\n      gop = gops[gopIndex];\n\n      if (align.pts === gop.pts) {\n        matchFound = true;\n        break;\n      }\n\n      if (align.pts > gop.pts) {\n        alignIndex--;\n        continue;\n      }\n\n      if (alignIndex === gopsToAlignWith.length - 1) {\n        // gop.pts is greater than the last alignment candidate. If no match is found\n        // by the end of this loop, we still want to append gops that come after this\n        // point\n        alignEndIndex = gopIndex;\n      }\n\n      gopIndex--;\n    }\n\n    if (!matchFound && alignEndIndex === null) {\n      return null;\n    }\n\n    var trimIndex;\n\n    if (matchFound) {\n      trimIndex = gopIndex;\n    } else {\n      trimIndex = alignEndIndex;\n    }\n\n    if (trimIndex === 0) {\n      return gops;\n    }\n\n    var alignedGops = gops.slice(trimIndex);\n    var metadata = alignedGops.reduce(function(total, gop) {\n      total.byteLength += gop.byteLength;\n      total.duration += gop.duration;\n      total.nalCount += gop.nalCount;\n      return total;\n    }, { byteLength: 0, duration: 0, nalCount: 0 });\n\n    alignedGops.byteLength = metadata.byteLength;\n    alignedGops.duration = metadata.duration;\n    alignedGops.nalCount = metadata.nalCount;\n    alignedGops.pts = alignedGops[0].pts;\n    alignedGops.dts = alignedGops[0].dts;\n\n    return alignedGops;\n  };\n\n  this.alignGopsWith = function(newGopsToAlignWith) {\n    gopsToAlignWith = newGopsToAlignWith;\n  };\n};\n\nVideoSegmentStream.prototype = new Stream();\n\n/**\n * Store information about the start and end of the track and the\n * duration for each frame/sample we process in order to calculate\n * the baseMediaDecodeTime\n */\ncollectDtsInfo = function(track, data) {\n  if (typeof data.pts === 'number') {\n    if (track.timelineStartInfo.pts === undefined) {\n      track.timelineStartInfo.pts = data.pts;\n    }\n\n    if (track.minSegmentPts === undefined) {\n      track.minSegmentPts = data.pts;\n    } else {\n      track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\n    }\n\n    if (track.maxSegmentPts === undefined) {\n      track.maxSegmentPts = data.pts;\n    } else {\n      track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\n    }\n  }\n\n  if (typeof data.dts === 'number') {\n    if (track.timelineStartInfo.dts === undefined) {\n      track.timelineStartInfo.dts = data.dts;\n    }\n\n    if (track.minSegmentDts === undefined) {\n      track.minSegmentDts = data.dts;\n    } else {\n      track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\n    }\n\n    if (track.maxSegmentDts === undefined) {\n      track.maxSegmentDts = data.dts;\n    } else {\n      track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\n    }\n  }\n};\n\n/**\n * Clear values used to calculate the baseMediaDecodeTime between\n * tracks\n */\nclearDtsInfo = function(track) {\n  delete track.minSegmentDts;\n  delete track.maxSegmentDts;\n  delete track.minSegmentPts;\n  delete track.maxSegmentPts;\n};\n\n/**\n * Calculate the track's baseMediaDecodeTime based on the earliest\n * DTS the transmuxer has ever seen and the minimum DTS for the\n * current track\n */\ncalculateTrackBaseMediaDecodeTime = function(track) {\n  var\n    baseMediaDecodeTime,\n    scale,\n    // Calculate the distance, in time, that this segment starts from the start\n    // of the timeline (earliest time seen since the transmuxer initialized)\n    timeSinceStartOfTimeline = track.minSegmentDts - track.timelineStartInfo.dts;\n\n  // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\n  // we want the start of the first segment to be placed\n  baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;\n\n  // Add to that the distance this segment is from the very first\n  baseMediaDecodeTime += timeSinceStartOfTimeline;\n\n  // baseMediaDecodeTime must not become negative\n  baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\n\n  if (track.type === 'audio') {\n    // Audio has a different clock equal to the sampling_rate so we need to\n    // scale the PTS values into the clock rate of the track\n    scale = track.samplerate / ONE_SECOND_IN_TS;\n    baseMediaDecodeTime *= scale;\n    baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\n  }\n\n  return baseMediaDecodeTime;\n};\n\n/**\n * A Stream that can combine multiple streams (ie. audio & video)\n * into a single output segment for MSE. Also supports audio-only\n * and video-only streams.\n */\nCoalesceStream = function(options, metadataStream) {\n  // Number of Tracks per output segment\n  // If greater than 1, we combine multiple\n  // tracks into a single segment\n  this.numberOfTracks = 0;\n  this.metadataStream = metadataStream;\n\n  if (typeof options.remux !== 'undefined') {\n    this.remuxTracks = !!options.remux;\n  } else {\n    this.remuxTracks = true;\n  }\n\n  this.pendingTracks = [];\n  this.videoTrack = null;\n  this.pendingBoxes = [];\n  this.pendingCaptions = [];\n  this.pendingMetadata = [];\n  this.pendingBytes = 0;\n  this.emittedTracks = 0;\n\n  CoalesceStream.prototype.init.call(this);\n\n  // Take output from multiple\n  this.push = function(output) {\n    // buffer incoming captions until the associated video segment\n    // finishes\n    if (output.text) {\n      return this.pendingCaptions.push(output);\n    }\n    // buffer incoming id3 tags until the final flush\n    if (output.frames) {\n      return this.pendingMetadata.push(output);\n    }\n\n    // Add this track to the list of pending tracks and store\n    // important information required for the construction of\n    // the final segment\n    this.pendingTracks.push(output.track);\n    this.pendingBoxes.push(output.boxes);\n    this.pendingBytes += output.boxes.byteLength;\n\n    if (output.track.type === 'video') {\n      this.videoTrack = output.track;\n    }\n    if (output.track.type === 'audio') {\n      this.audioTrack = output.track;\n    }\n  };\n};\n\nCoalesceStream.prototype = new Stream();\nCoalesceStream.prototype.flush = function(flushSource) {\n  var\n    offset = 0,\n    event = {\n      captions: [],\n      captionStreams: {},\n      metadata: [],\n      info: {}\n    },\n    caption,\n    id3,\n    initSegment,\n    timelineStartPts = 0,\n    i;\n\n  if (this.pendingTracks.length < this.numberOfTracks) {\n    if (flushSource !== 'VideoSegmentStream' &&\n        flushSource !== 'AudioSegmentStream') {\n      // Return because we haven't received a flush from a data-generating\n      // portion of the segment (meaning that we have only recieved meta-data\n      // or captions.)\n      return;\n    } else if (this.remuxTracks) {\n      // Return until we have enough tracks from the pipeline to remux (if we\n      // are remuxing audio and video into a single MP4)\n      return;\n    } else if (this.pendingTracks.length === 0) {\n      // In the case where we receive a flush without any data having been\n      // received we consider it an emitted track for the purposes of coalescing\n      // `done` events.\n      // We do this for the case where there is an audio and video track in the\n      // segment but no audio data. (seen in several playlists with alternate\n      // audio tracks and no audio present in the main TS segments.)\n      this.emittedTracks++;\n\n      if (this.emittedTracks >= this.numberOfTracks) {\n        this.trigger('done');\n        this.emittedTracks = 0;\n      }\n      return;\n    }\n  }\n\n  if (this.videoTrack) {\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n    VIDEO_PROPERTIES.forEach(function(prop) {\n      event.info[prop] = this.videoTrack[prop];\n    }, this);\n  } else if (this.audioTrack) {\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n    AUDIO_PROPERTIES.forEach(function(prop) {\n      event.info[prop] = this.audioTrack[prop];\n    }, this);\n  }\n\n  if (this.pendingTracks.length === 1) {\n    event.type = this.pendingTracks[0].type;\n  } else {\n    event.type = 'combined';\n  }\n\n  this.emittedTracks += this.pendingTracks.length;\n\n  initSegment = mp4.initSegment(this.pendingTracks);\n\n  // Create a new typed array to hold the init segment\n  event.initSegment = new Uint8Array(initSegment.byteLength);\n\n  // Create an init segment containing a moov\n  // and track definitions\n  event.initSegment.set(initSegment);\n\n  // Create a new typed array to hold the moof+mdats\n  event.data = new Uint8Array(this.pendingBytes);\n\n  // Append each moof+mdat (one per track) together\n  for (i = 0; i < this.pendingBoxes.length; i++) {\n    event.data.set(this.pendingBoxes[i], offset);\n    offset += this.pendingBoxes[i].byteLength;\n  }\n\n  // Translate caption PTS times into second offsets into the\n  // video timeline for the segment, and add track info\n  for (i = 0; i < this.pendingCaptions.length; i++) {\n    caption = this.pendingCaptions[i];\n    caption.startTime = (caption.startPts - timelineStartPts);\n    caption.startTime /= 90e3;\n    caption.endTime = (caption.endPts - timelineStartPts);\n    caption.endTime /= 90e3;\n    event.captionStreams[caption.stream] = true;\n    event.captions.push(caption);\n  }\n\n  // Translate ID3 frame PTS times into second offsets into the\n  // video timeline for the segment\n  for (i = 0; i < this.pendingMetadata.length; i++) {\n    id3 = this.pendingMetadata[i];\n    id3.cueTime = (id3.pts - timelineStartPts);\n    id3.cueTime /= 90e3;\n    event.metadata.push(id3);\n  }\n  // We add this to every single emitted segment even though we only need\n  // it for the first\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\n\n  // Reset stream state\n  this.pendingTracks.length = 0;\n  this.videoTrack = null;\n  this.pendingBoxes.length = 0;\n  this.pendingCaptions.length = 0;\n  this.pendingBytes = 0;\n  this.pendingMetadata.length = 0;\n\n  // Emit the built segment\n  this.trigger('data', event);\n\n  // Only emit `done` if all tracks have been flushed and emitted\n  if (this.emittedTracks >= this.numberOfTracks) {\n    this.trigger('done');\n    this.emittedTracks = 0;\n  }\n};\n/**\n * A Stream that expects MP2T binary data as input and produces\n * corresponding media segments, suitable for use with Media Source\n * Extension (MSE) implementations that support the ISO BMFF byte\n * stream format, like Chrome.\n */\nTransmuxer = function(options) {\n  var\n    self = this,\n    hasFlushed = true,\n    videoTrack,\n    audioTrack;\n\n  Transmuxer.prototype.init.call(this);\n\n  options = options || {};\n  this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n  this.transmuxPipeline_ = {};\n\n  this.setupAacPipeline = function() {\n    var pipeline = {};\n    this.transmuxPipeline_ = pipeline;\n\n    pipeline.type = 'aac';\n    pipeline.metadataStream = new m2ts.MetadataStream();\n\n    // set up the parsing pipeline\n    pipeline.aacStream = new AacStream();\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n    pipeline.adtsStream = new AdtsStream();\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n    pipeline.headOfPipeline = pipeline.aacStream;\n\n    pipeline.aacStream\n      .pipe(pipeline.audioTimestampRolloverStream)\n      .pipe(pipeline.adtsStream);\n    pipeline.aacStream\n      .pipe(pipeline.timedMetadataTimestampRolloverStream)\n      .pipe(pipeline.metadataStream)\n      .pipe(pipeline.coalesceStream);\n\n    pipeline.metadataStream.on('timestamp', function(frame) {\n      pipeline.aacStream.setTimestamp(frame.timeStamp);\n    });\n\n    pipeline.aacStream.on('data', function(data) {\n      if (data.type === 'timed-metadata' && !pipeline.audioSegmentStream) {\n        audioTrack = audioTrack || {\n          timelineStartInfo: {\n            baseMediaDecodeTime: self.baseMediaDecodeTime\n          },\n          codec: 'adts',\n          type: 'audio'\n        };\n        // hook up the audio segment stream to the first track with aac data\n        pipeline.coalesceStream.numberOfTracks++;\n        pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack);\n        // Set up the final part of the audio pipeline\n        pipeline.adtsStream\n          .pipe(pipeline.audioSegmentStream)\n          .pipe(pipeline.coalesceStream);\n      }\n    });\n\n    // Re-emit any data coming from the coalesce stream to the outside world\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n    // Let the consumer know we have finished flushing the entire pipeline\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n  };\n\n  this.setupTsPipeline = function() {\n    var pipeline = {};\n    this.transmuxPipeline_ = pipeline;\n\n    pipeline.type = 'ts';\n    pipeline.metadataStream = new m2ts.MetadataStream();\n\n    // set up the parsing pipeline\n    pipeline.packetStream = new m2ts.TransportPacketStream();\n    pipeline.parseStream = new m2ts.TransportParseStream();\n    pipeline.elementaryStream = new m2ts.ElementaryStream();\n    pipeline.videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n    pipeline.adtsStream = new AdtsStream();\n    pipeline.h264Stream = new H264Stream();\n    pipeline.captionStream = new m2ts.CaptionStream();\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n    pipeline.headOfPipeline = pipeline.packetStream;\n\n    // disassemble MPEG2-TS packets into elementary streams\n    pipeline.packetStream\n      .pipe(pipeline.parseStream)\n      .pipe(pipeline.elementaryStream);\n\n    // !!THIS ORDER IS IMPORTANT!!\n    // demux the streams\n    pipeline.elementaryStream\n      .pipe(pipeline.videoTimestampRolloverStream)\n      .pipe(pipeline.h264Stream);\n    pipeline.elementaryStream\n      .pipe(pipeline.audioTimestampRolloverStream)\n      .pipe(pipeline.adtsStream);\n\n    pipeline.elementaryStream\n      .pipe(pipeline.timedMetadataTimestampRolloverStream)\n      .pipe(pipeline.metadataStream)\n      .pipe(pipeline.coalesceStream);\n\n    // Hook up CEA-608/708 caption stream\n    pipeline.h264Stream.pipe(pipeline.captionStream)\n      .pipe(pipeline.coalesceStream);\n\n    pipeline.elementaryStream.on('data', function(data) {\n      var i;\n\n      if (data.type === 'metadata') {\n        i = data.tracks.length;\n\n        // scan the tracks listed in the metadata\n        while (i--) {\n          if (!videoTrack && data.tracks[i].type === 'video') {\n            videoTrack = data.tracks[i];\n            videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n          } else if (!audioTrack && data.tracks[i].type === 'audio') {\n            audioTrack = data.tracks[i];\n            audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n          }\n        }\n\n        // hook up the video segment stream to the first track with h264 data\n        if (videoTrack && !pipeline.videoSegmentStream) {\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.videoSegmentStream = new VideoSegmentStream(videoTrack, options);\n\n          pipeline.videoSegmentStream.on('timelineStartInfo', function(timelineStartInfo) {\n          // When video emits timelineStartInfo data after a flush, we forward that\n          // info to the AudioSegmentStream, if it exists, because video timeline\n          // data takes precedence.\n            if (audioTrack) {\n              audioTrack.timelineStartInfo = timelineStartInfo;\n              // On the first segment we trim AAC frames that exist before the\n              // very earliest DTS we have seen in video because Chrome will\n              // interpret any video track with a baseMediaDecodeTime that is\n              // non-zero as a gap.\n              pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts);\n            }\n          });\n\n          pipeline.videoSegmentStream.on('processedGopsInfo',\n            self.trigger.bind(self, 'gopInfo'));\n\n          pipeline.videoSegmentStream.on('baseMediaDecodeTime', function(baseMediaDecodeTime) {\n            if (audioTrack) {\n              pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\n            }\n          });\n\n          // Set up the final part of the video pipeline\n          pipeline.h264Stream\n            .pipe(pipeline.videoSegmentStream)\n            .pipe(pipeline.coalesceStream);\n        }\n\n        if (audioTrack && !pipeline.audioSegmentStream) {\n          // hook up the audio segment stream to the first track with aac data\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack);\n\n          // Set up the final part of the audio pipeline\n          pipeline.adtsStream\n            .pipe(pipeline.audioSegmentStream)\n            .pipe(pipeline.coalesceStream);\n        }\n      }\n    });\n\n    // Re-emit any data coming from the coalesce stream to the outside world\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n    // Let the consumer know we have finished flushing the entire pipeline\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n  };\n\n  // hook up the segment streams once track metadata is delivered\n  this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {\n    var pipeline = this.transmuxPipeline_;\n\n    this.baseMediaDecodeTime = baseMediaDecodeTime;\n    if (audioTrack) {\n      audioTrack.timelineStartInfo.dts = undefined;\n      audioTrack.timelineStartInfo.pts = undefined;\n      clearDtsInfo(audioTrack);\n      audioTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\n      if (pipeline.audioTimestampRolloverStream) {\n        pipeline.audioTimestampRolloverStream.discontinuity();\n      }\n    }\n    if (videoTrack) {\n      if (pipeline.videoSegmentStream) {\n        pipeline.videoSegmentStream.gopCache_ = [];\n        pipeline.videoTimestampRolloverStream.discontinuity();\n      }\n      videoTrack.timelineStartInfo.dts = undefined;\n      videoTrack.timelineStartInfo.pts = undefined;\n      clearDtsInfo(videoTrack);\n      pipeline.captionStream.reset();\n      videoTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\n    }\n\n    if (pipeline.timedMetadataTimestampRolloverStream) {\n      pipeline.timedMetadataTimestampRolloverStream.discontinuity();\n    }\n  };\n\n  this.setAudioAppendStart = function(timestamp) {\n    if (audioTrack) {\n      this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\n    }\n  };\n\n  this.alignGopsWith = function(gopsToAlignWith) {\n    if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\n      this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\n    }\n  };\n\n  // feed incoming data to the front of the parsing pipeline\n  this.push = function(data) {\n    if (hasFlushed) {\n      var isAac = isLikelyAacData(data);\n\n      if (isAac && this.transmuxPipeline_.type !== 'aac') {\n        this.setupAacPipeline();\n      } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\n        this.setupTsPipeline();\n      }\n      hasFlushed = false;\n    }\n    this.transmuxPipeline_.headOfPipeline.push(data);\n  };\n\n  // flush any buffered data\n  this.flush = function() {\n      hasFlushed = true;\n    // Start at the top of the pipeline and flush all pending work\n    this.transmuxPipeline_.headOfPipeline.flush();\n  };\n\n  // Caption data has to be reset when seeking outside buffered range\n  this.resetCaptions = function() {\n    if (this.transmuxPipeline_.captionStream) {\n      this.transmuxPipeline_.captionStream.reset();\n    }\n  };\n\n};\nTransmuxer.prototype = new Stream();\n\nmodule.exports = {\n  Transmuxer: Transmuxer,\n  VideoSegmentStream: VideoSegmentStream,\n  AudioSegmentStream: AudioSegmentStream,\n  AUDIO_PROPERTIES: AUDIO_PROPERTIES,\n  VIDEO_PROPERTIES: VIDEO_PROPERTIES\n};\n\n},{\"../aac\":38,\"../codecs/adts.js\":40,\"../codecs/h264\":41,\"../data/silence\":42,\"../m2ts/m2ts.js\":50,\"../utils/clock\":60,\"../utils/stream.js\":62,\"./mp4-generator.js\":56}],59:[function(require,module,exports){\n/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Parse mpeg2 transport stream packets to extract basic timing information\n */\n'use strict';\n\nvar StreamTypes = require('../m2ts/stream-types.js');\nvar handleRollover = require('../m2ts/timestamp-rollover-stream.js').handleRollover;\nvar probe = {};\nprobe.ts = require('../m2ts/probe.js');\nprobe.aac = require('../aac/probe.js');\n\n\nvar\n  PES_TIMESCALE = 90000,\n  MP2T_PACKET_LENGTH = 188, // bytes\n  SYNC_BYTE = 0x47;\n\nvar isLikelyAacData = function(data) {\n  if ((data[0] === 'I'.charCodeAt(0)) &&\n      (data[1] === 'D'.charCodeAt(0)) &&\n      (data[2] === '3'.charCodeAt(0))) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * walks through segment data looking for pat and pmt packets to parse out\n * program map table information\n */\nvar parsePsi_ = function(bytes, pmt) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type;\n\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pat':\n          if (!pmt.pid) {\n            pmt.pid = probe.ts.parsePat(packet);\n          }\n          break;\n        case 'pmt':\n          if (!pmt.table) {\n            pmt.table = probe.ts.parsePmt(packet);\n          }\n          break;\n        default:\n          break;\n      }\n\n      // Found the pat and pmt, we can stop walking the segment\n      if (pmt.pid && pmt.table) {\n        return;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n};\n\n/**\n * walks through the segment data from the start and end to get timing information\n * for the first and last audio pes packets\n */\nvar parseAudioPes_ = function(bytes, pmt, result) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type, pesType, pusi, parsed;\n\n  var endLoop = false;\n\n  // Start walking from start of segment to get first audio packet\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n\n  // Start walking from end of segment to get last audio packet\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex--;\n    endIndex--;\n  }\n};\n\n/**\n * walks through the segment data from the start and end to get timing information\n * for the first and last video pes packets as well as timing information for the first\n * key frame.\n */\nvar parseVideoPes_ = function(bytes, pmt, result) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type, pesType, pusi, parsed, frame, i, pes;\n\n  var endLoop = false;\n\n  var currentFrame = {\n    data: [],\n    size: 0\n  };\n\n  // Start walking from start of segment to get first video packet\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'video') {\n            if (pusi && !endLoop) {\n              parsed = probe.ts.parsePesTime(packet);\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n            }\n            if (!result.firstKeyFrame) {\n              if (pusi) {\n                if (currentFrame.size !== 0) {\n                  frame = new Uint8Array(currentFrame.size);\n                  i = 0;\n                  while (currentFrame.data.length) {\n                    pes = currentFrame.data.shift();\n                    frame.set(pes, i);\n                    i += pes.byteLength;\n                  }\n                  if (probe.ts.videoPacketContainsKeyFrame(frame)) {\n                    result.firstKeyFrame = probe.ts.parsePesTime(frame);\n                    result.firstKeyFrame.type = 'video';\n                  }\n                  currentFrame.size = 0;\n                }\n              }\n              currentFrame.data.push(packet);\n              currentFrame.size += packet.byteLength;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop && result.firstKeyFrame) {\n        break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n\n  // Start walking from end of segment to get last video packet\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'video' && pusi) {\n              parsed = probe.ts.parsePesTime(packet);\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex--;\n    endIndex--;\n  }\n};\n\n/**\n * Adjusts the timestamp information for the segment to account for\n * rollover and convert to seconds based on pes packet timescale (90khz clock)\n */\nvar adjustTimestamp_ = function(segmentInfo, baseTimestamp) {\n  if (segmentInfo.audio && segmentInfo.audio.length) {\n    var audioBaseTimestamp = baseTimestamp;\n    if (typeof audioBaseTimestamp === 'undefined') {\n      audioBaseTimestamp = segmentInfo.audio[0].dts;\n    }\n    segmentInfo.audio.forEach(function(info) {\n      info.dts = handleRollover(info.dts, audioBaseTimestamp);\n      info.pts = handleRollover(info.pts, audioBaseTimestamp);\n      // time in seconds\n      info.dtsTime = info.dts / PES_TIMESCALE;\n      info.ptsTime = info.pts / PES_TIMESCALE;\n    });\n  }\n\n  if (segmentInfo.video && segmentInfo.video.length) {\n    var videoBaseTimestamp = baseTimestamp;\n    if (typeof videoBaseTimestamp === 'undefined') {\n      videoBaseTimestamp = segmentInfo.video[0].dts;\n    }\n    segmentInfo.video.forEach(function(info) {\n      info.dts = handleRollover(info.dts, videoBaseTimestamp);\n      info.pts = handleRollover(info.pts, videoBaseTimestamp);\n      // time in seconds\n      info.dtsTime = info.dts / PES_TIMESCALE;\n      info.ptsTime = info.pts / PES_TIMESCALE;\n    });\n    if (segmentInfo.firstKeyFrame) {\n      var frame = segmentInfo.firstKeyFrame;\n      frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\n      frame.pts = handleRollover(frame.pts, videoBaseTimestamp);\n      // time in seconds\n      frame.dtsTime = frame.dts / PES_TIMESCALE;\n      frame.ptsTime = frame.dts / PES_TIMESCALE;\n    }\n  }\n};\n\n/**\n * inspects the aac data stream for start and end time information\n */\nvar inspectAac_ = function(bytes) {\n  var\n    endLoop = false,\n    audioCount = 0,\n    sampleRate = null,\n    timestamp = null,\n    frameSize = 0,\n    byteIndex = 0,\n    packet;\n\n  while (bytes.length - byteIndex >= 3) {\n    var type = probe.aac.parseType(bytes, byteIndex);\n    switch (type) {\n      case 'timed-metadata':\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (bytes.length - byteIndex < 10) {\n          endLoop = true;\n          break;\n        }\n\n        frameSize = probe.aac.parseId3TagSize(bytes, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n        if (timestamp === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          timestamp = probe.aac.parseAacTimestamp(packet);\n        }\n        byteIndex += frameSize;\n        break;\n      case 'audio':\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (bytes.length - byteIndex < 7) {\n          endLoop = true;\n          break;\n        }\n\n        frameSize = probe.aac.parseAdtsSize(bytes, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n        if (sampleRate === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          sampleRate = probe.aac.parseSampleRate(packet);\n        }\n        audioCount++;\n        byteIndex += frameSize;\n        break;\n      default:\n        byteIndex++;\n        break;\n    }\n    if (endLoop) {\n      return null;\n    }\n  }\n  if (sampleRate === null || timestamp === null) {\n    return null;\n  }\n\n  var audioTimescale = PES_TIMESCALE / sampleRate;\n\n  var result = {\n    audio: [\n      {\n        type: 'audio',\n        dts: timestamp,\n        pts: timestamp\n      },\n      {\n        type: 'audio',\n        dts: timestamp + (audioCount * 1024 * audioTimescale),\n        pts: timestamp + (audioCount * 1024 * audioTimescale)\n      }\n    ]\n  };\n\n  return result;\n};\n\n/**\n * inspects the transport stream segment data for start and end time information\n * of the audio and video tracks (when present) as well as the first key frame's\n * start time.\n */\nvar inspectTs_ = function(bytes) {\n  var pmt = {\n    pid: null,\n    table: null\n  };\n\n  var result = {};\n\n  parsePsi_(bytes, pmt);\n\n  for (var pid in pmt.table) {\n    if (pmt.table.hasOwnProperty(pid)) {\n      var type = pmt.table[pid];\n      switch (type) {\n        case StreamTypes.H264_STREAM_TYPE:\n          result.video = [];\n          parseVideoPes_(bytes, pmt, result);\n          if (result.video.length === 0) {\n            delete result.video;\n          }\n          break;\n        case StreamTypes.ADTS_STREAM_TYPE:\n          result.audio = [];\n          parseAudioPes_(bytes, pmt, result);\n          if (result.audio.length === 0) {\n            delete result.audio;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Inspects segment byte data and returns an object with start and end timing information\n *\n * @param {Uint8Array} bytes The segment byte data\n * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\n *  timestamps for rollover. This value must be in 90khz clock.\n * @return {Object} Object containing start and end frame timing info of segment.\n */\nvar inspect = function(bytes, baseTimestamp) {\n  var isAacData = isLikelyAacData(bytes);\n\n  var result;\n\n  if (isAacData) {\n    result = inspectAac_(bytes);\n  } else {\n    result = inspectTs_(bytes);\n  }\n\n  if (!result || (!result.audio && !result.video)) {\n    return null;\n  }\n\n  adjustTimestamp_(result, baseTimestamp);\n\n  return result;\n};\n\nmodule.exports = {\n  inspect: inspect\n};\n\n},{\"../aac/probe.js\":39,\"../m2ts/probe.js\":52,\"../m2ts/stream-types.js\":53,\"../m2ts/timestamp-rollover-stream.js\":54}],60:[function(require,module,exports){\nvar\n  ONE_SECOND_IN_TS = 90000, // 90kHz clock\n  secondsToVideoTs,\n  secondsToAudioTs,\n  videoTsToSeconds,\n  audioTsToSeconds,\n  audioTsToVideoTs,\n  videoTsToAudioTs;\n\nsecondsToVideoTs = function(seconds) {\n  return seconds * ONE_SECOND_IN_TS;\n};\n\nsecondsToAudioTs = function(seconds, sampleRate) {\n  return seconds * sampleRate;\n};\n\nvideoTsToSeconds = function(timestamp) {\n  return timestamp / ONE_SECOND_IN_TS;\n};\n\naudioTsToSeconds = function(timestamp, sampleRate) {\n  return timestamp / sampleRate;\n};\n\naudioTsToVideoTs = function(timestamp, sampleRate) {\n  return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n};\n\nvideoTsToAudioTs = function(timestamp, sampleRate) {\n  return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n};\n\nmodule.exports = {\n  secondsToVideoTs: secondsToVideoTs,\n  secondsToAudioTs: secondsToAudioTs,\n  videoTsToSeconds: videoTsToSeconds,\n  audioTsToSeconds: audioTsToSeconds,\n  audioTsToVideoTs: audioTsToVideoTs,\n  videoTsToAudioTs: videoTsToAudioTs\n};\n\n},{}],61:[function(require,module,exports){\n'use strict';\n\nvar ExpGolomb;\n\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding\n * scheme used by h264.\n */\nExpGolomb = function(workingData) {\n  var\n    // the number of bytes left to examine in workingData\n    workingBytesAvailable = workingData.byteLength,\n\n    // the current word being examined\n    workingWord = 0, // :uint\n\n    // the number of bits left to examine in the current word\n    workingBitsAvailable = 0; // :uint;\n\n  // ():uint\n  this.length = function() {\n    return (8 * workingBytesAvailable);\n  };\n\n  // ():uint\n  this.bitsAvailable = function() {\n    return (8 * workingBytesAvailable) + workingBitsAvailable;\n  };\n\n  // ():void\n  this.loadWord = function() {\n    var\n      position = workingData.byteLength - workingBytesAvailable,\n      workingBytes = new Uint8Array(4),\n      availableBytes = Math.min(4, workingBytesAvailable);\n\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n\n    workingBytes.set(workingData.subarray(position,\n                                          position + availableBytes));\n    workingWord = new DataView(workingBytes.buffer).getUint32(0);\n\n    // track the amount of workingData that has been processed\n    workingBitsAvailable = availableBytes * 8;\n    workingBytesAvailable -= availableBytes;\n  };\n\n  // (count:int):void\n  this.skipBits = function(count) {\n    var skipBytes; // :int\n    if (workingBitsAvailable > count) {\n      workingWord          <<= count;\n      workingBitsAvailable -= count;\n    } else {\n      count -= workingBitsAvailable;\n      skipBytes = Math.floor(count / 8);\n\n      count -= (skipBytes * 8);\n      workingBytesAvailable -= skipBytes;\n\n      this.loadWord();\n\n      workingWord <<= count;\n      workingBitsAvailable -= count;\n    }\n  };\n\n  // (size:int):uint\n  this.readBits = function(size) {\n    var\n      bits = Math.min(workingBitsAvailable, size), // :uint\n      valu = workingWord >>> (32 - bits); // :uint\n    // if size > 31, handle error\n    workingBitsAvailable -= bits;\n    if (workingBitsAvailable > 0) {\n      workingWord <<= bits;\n    } else if (workingBytesAvailable > 0) {\n      this.loadWord();\n    }\n\n    bits = size - bits;\n    if (bits > 0) {\n      return valu << bits | this.readBits(bits);\n    }\n    return valu;\n  };\n\n  // ():uint\n  this.skipLeadingZeros = function() {\n    var leadingZeroCount; // :uint\n    for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\n      if ((workingWord & (0x80000000 >>> leadingZeroCount)) !== 0) {\n        // the first bit of working word is 1\n        workingWord <<= leadingZeroCount;\n        workingBitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n\n    // we exhausted workingWord and still have not found a 1\n    this.loadWord();\n    return leadingZeroCount + this.skipLeadingZeros();\n  };\n\n  // ():void\n  this.skipUnsignedExpGolomb = function() {\n    this.skipBits(1 + this.skipLeadingZeros());\n  };\n\n  // ():void\n  this.skipExpGolomb = function() {\n    this.skipBits(1 + this.skipLeadingZeros());\n  };\n\n  // ():uint\n  this.readUnsignedExpGolomb = function() {\n    var clz = this.skipLeadingZeros(); // :uint\n    return this.readBits(clz + 1) - 1;\n  };\n\n  // ():int\n  this.readExpGolomb = function() {\n    var valu = this.readUnsignedExpGolomb(); // :int\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return (1 + valu) >>> 1; // add 1 to make it even, and divide by 2\n    }\n    return -1 * (valu >>> 1); // divide by two then make it negative\n  };\n\n  // Some convenience functions\n  // :Boolean\n  this.readBoolean = function() {\n    return this.readBits(1) === 1;\n  };\n\n  // ():int\n  this.readUnsignedByte = function() {\n    return this.readBits(8);\n  };\n\n  this.loadWord();\n};\n\nmodule.exports = ExpGolomb;\n\n},{}],62:[function(require,module,exports){\n/**\n * mux.js\n *\n * Copyright (c) 2014 Brightcove\n * All rights reserved.\n *\n * A lightweight readable stream implemention that handles event dispatching.\n * Objects that inherit from streams should call init in their constructors.\n */\n'use strict';\n\nvar Stream = function() {\n  this.init = function() {\n    var listeners = {};\n    /**\n     * Add a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} the callback to be invoked when an event of\n     * the specified type occurs\n     */\n    this.on = function(type, listener) {\n      if (!listeners[type]) {\n        listeners[type] = [];\n      }\n      listeners[type] = listeners[type].concat(listener);\n    };\n    /**\n     * Remove a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} a function previously registered for this\n     * type of event through `on`\n     */\n    this.off = function(type, listener) {\n      var index;\n      if (!listeners[type]) {\n        return false;\n      }\n      index = listeners[type].indexOf(listener);\n      listeners[type] = listeners[type].slice();\n      listeners[type].splice(index, 1);\n      return index > -1;\n    };\n    /**\n     * Trigger an event of the specified type on this stream. Any additional\n     * arguments to this function are passed as parameters to event listeners.\n     * @param type {string} the event name\n     */\n    this.trigger = function(type) {\n      var callbacks, i, length, args;\n      callbacks = listeners[type];\n      if (!callbacks) {\n        return;\n      }\n      // Slicing the arguments on every invocation of this method\n      // can add a significant amount of overhead. Avoid the\n      // intermediate object creation for the common case of a\n      // single callback argument\n      if (arguments.length === 2) {\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].call(this, arguments[1]);\n        }\n      } else {\n        args = [];\n        i = arguments.length;\n        for (i = 1; i < arguments.length; ++i) {\n          args.push(arguments[i]);\n        }\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].apply(this, args);\n        }\n      }\n    };\n    /**\n     * Destroys the stream and cleans up.\n     */\n    this.dispose = function() {\n      listeners = {};\n    };\n  };\n};\n\n/**\n * Forwards all `data` events on this stream to the destination stream. The\n * destination stream should provide a method `push` to receive the data\n * events as they arrive.\n * @param destination {stream} the stream that will receive all `data` events\n * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n *                            when the current stream emits a 'done' event\n * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n */\nStream.prototype.pipe = function(destination) {\n  this.on('data', function(data) {\n    destination.push(data);\n  });\n\n  this.on('done', function(flushSource) {\n    destination.flush(flushSource);\n  });\n\n  return destination;\n};\n\n// Default stream functions that are expected to be overridden to perform\n// actual work. These are provided by the prototype as a sort of no-op\n// implementation so that we don't have to check for their existence in the\n// `pipe` function above.\nStream.prototype.push = function(data) {\n  this.trigger('data', data);\n};\n\nStream.prototype.flush = function(flushSource) {\n  this.trigger('done', flushSource);\n};\n\nmodule.exports = Stream;\n\n},{}],63:[function(require,module,exports){\n/* jshint ignore:start */\r\n(function(root) { \r\n/* jshint ignore:end */\r\n  var URLToolkit = {\r\n    // build an absolute URL from a relative one using the provided baseURL\r\n    // if relativeURL is an absolute URL it will be returned as is.\r\n    buildAbsoluteURL: function(baseURL, relativeURL) {\r\n      // remove any remaining space and CRLF\r\n      relativeURL = relativeURL.trim();\r\n      if (/^[a-z]+:/i.test(relativeURL)) {\r\n        // complete url, not relative\r\n        return relativeURL;\r\n      }\r\n\r\n      var relativeURLQuery = null;\r\n      var relativeURLHash = null;\r\n\r\n      var relativeURLHashSplit = /^([^#]*)(.*)$/.exec(relativeURL);\r\n      if (relativeURLHashSplit) {\r\n        relativeURLHash = relativeURLHashSplit[2];\r\n        relativeURL = relativeURLHashSplit[1];\r\n      }\r\n      var relativeURLQuerySplit = /^([^\\?]*)(.*)$/.exec(relativeURL);\r\n      if (relativeURLQuerySplit) {\r\n        relativeURLQuery = relativeURLQuerySplit[2];\r\n        relativeURL = relativeURLQuerySplit[1];\r\n      }\r\n\r\n      var baseURLHashSplit = /^([^#]*)(.*)$/.exec(baseURL);\r\n      if (baseURLHashSplit) {\r\n        baseURL = baseURLHashSplit[1];\r\n      }\r\n      var baseURLQuerySplit = /^([^\\?]*)(.*)$/.exec(baseURL);\r\n      if (baseURLQuerySplit) {\r\n        baseURL = baseURLQuerySplit[1];\r\n      }\r\n\r\n      var baseURLDomainSplit = /^(([a-z]+:)?\\/\\/[^:\\/]+(:[0-9]+)?)?(\\/?.*)$/i.exec(baseURL);\r\n      if (!baseURLDomainSplit) {\r\n        throw new Error('Error trying to parse base URL.');\r\n      }\r\n      \r\n      // e.g. 'http:', 'https:', ''\r\n      var baseURLProtocol = baseURLDomainSplit[2] || '';\r\n      // e.g. 'http://example.com', '//example.com', ''\r\n      var baseURLProtocolDomain = baseURLDomainSplit[1] || '';\r\n      // e.g. '/a/b/c/playlist.m3u8', 'a/b/c/playlist.m3u8'\r\n      var baseURLPath = baseURLDomainSplit[4];\r\n      if (baseURLPath.indexOf('/') !== 0 && baseURLProtocolDomain !== '') {\r\n        // this handles a base url of http://example.com (missing last slash)\r\n        baseURLPath = '/'+baseURLPath;\r\n      }\r\n\r\n      var builtURL = null;\r\n      if (/^\\/\\//.test(relativeURL)) {\r\n        // relative url starts wth '//' so copy protocol (which may be '' if baseUrl didn't provide one)\r\n        builtURL = baseURLProtocol+'//'+URLToolkit.buildAbsolutePath('', relativeURL.substring(2));\r\n      }\r\n      else if (/^\\//.test(relativeURL)) {\r\n        // relative url starts with '/' so start from root of domain\r\n        builtURL = baseURLProtocolDomain+'/'+URLToolkit.buildAbsolutePath('', relativeURL.substring(1));\r\n      }\r\n      else {\r\n        builtURL = URLToolkit.buildAbsolutePath(baseURLProtocolDomain+baseURLPath, relativeURL);\r\n      }\r\n\r\n      // put the query and hash parts back\r\n      if (relativeURLQuery) {\r\n        builtURL += relativeURLQuery;\r\n      }\r\n      if (relativeURLHash) {\r\n        builtURL += relativeURLHash;\r\n      }\r\n      return builtURL;\r\n    },\r\n\r\n    // build an absolute path using the provided basePath\r\n    // adapted from https://developer.mozilla.org/en-US/docs/Web/API/document/cookie#Using_relative_URLs_in_the_path_parameter\r\n    // this does not handle the case where relativePath is \"/\" or \"//\". These cases should be handled outside this.\r\n    buildAbsolutePath: function(basePath, relativePath) {\r\n      var sRelPath = relativePath;\r\n      var nUpLn, sDir = '', sPath = basePath.replace(/[^\\/]*$/, sRelPath.replace(/(\\/|^)(?:\\.?\\/+)+/g, '$1'));\r\n      for (var nEnd, nStart = 0; nEnd = sPath.indexOf('/../', nStart), nEnd > -1; nStart = nEnd + nUpLn) {\r\n        nUpLn = /^\\/(?:\\.\\.\\/)*/.exec(sPath.slice(nEnd))[0].length;\r\n        sDir = (sDir + sPath.substring(nStart, nEnd)).replace(new RegExp('(?:\\\\\\/+[^\\\\\\/]*){0,' + ((nUpLn - 1) / 3) + '}$'), '/');\r\n      }\r\n      return sDir + sPath.substr(nStart);\r\n    }\r\n  };\r\n\r\n/* jshint ignore:start */\r\n  if(typeof exports === 'object' && typeof module === 'object')\r\n    module.exports = URLToolkit;\r\n  else if(typeof define === 'function' && define.amd)\r\n    define([], function() { return URLToolkit; });\r\n  else if(typeof exports === 'object')\r\n    exports[\"URLToolkit\"] = URLToolkit;\r\n  else\r\n    root[\"URLToolkit\"] = URLToolkit;\r\n})(this);\r\n/* jshint ignore:end */\r\n\n},{}],64:[function(require,module,exports){\n(function (global){\n/**\n * @file add-text-track-data.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\n/**\n * Define properties on a cue for backwards compatability,\n * but warn the user that the way that they are using it\n * is depricated and will be removed at a later date.\n *\n * @param {Cue} cue the cue to add the properties on\n * @private\n */\nvar deprecateOldCue = function deprecateOldCue(cue) {\n  Object.defineProperties(cue.frame, {\n    id: {\n      get: function get() {\n        _videoJs2['default'].log.warn('cue.frame.id is deprecated. Use cue.value.key instead.');\n        return cue.value.key;\n      }\n    },\n    value: {\n      get: function get() {\n        _videoJs2['default'].log.warn('cue.frame.value is deprecated. Use cue.value.data instead.');\n        return cue.value.data;\n      }\n    },\n    privateData: {\n      get: function get() {\n        _videoJs2['default'].log.warn('cue.frame.privateData is deprecated. Use cue.value.data instead.');\n        return cue.value.data;\n      }\n    }\n  });\n};\n\nvar durationOfVideo = function durationOfVideo(duration) {\n  var dur = undefined;\n\n  if (isNaN(duration) || Math.abs(duration) === Infinity) {\n    dur = Number.MAX_VALUE;\n  } else {\n    dur = duration;\n  }\n  return dur;\n};\n/**\n * Add text track data to a source handler given the captions and\n * metadata from the buffer.\n *\n * @param {Object} sourceHandler the flash or virtual source buffer\n * @param {Array} captionArray an array of caption data\n * @param {Array} metadataArray an array of meta data\n * @private\n */\nvar addTextTrackData = function addTextTrackData(sourceHandler, captionArray, metadataArray) {\n  var Cue = _globalWindow2['default'].WebKitDataCue || _globalWindow2['default'].VTTCue;\n\n  if (captionArray) {\n    captionArray.forEach(function (caption) {\n      var track = caption.stream;\n\n      this.inbandTextTracks_[track].addCue(new Cue(caption.startTime + this.timestampOffset, caption.endTime + this.timestampOffset, caption.text));\n    }, sourceHandler);\n  }\n\n  if (metadataArray) {\n    (function () {\n      var videoDuration = durationOfVideo(sourceHandler.mediaSource_.duration);\n\n      metadataArray.forEach(function (metadata) {\n        var time = metadata.cueTime + this.timestampOffset;\n\n        metadata.frames.forEach(function (frame) {\n          var cue = new Cue(time, time, frame.value || frame.url || frame.data || '');\n\n          cue.frame = frame;\n          cue.value = frame;\n          deprecateOldCue(cue);\n\n          this.metadataTrack_.addCue(cue);\n        }, this);\n      }, sourceHandler);\n\n      // Updating the metadeta cues so that\n      // the endTime of each cue is the startTime of the next cue\n      // the endTime of last cue is the duration of the video\n      if (sourceHandler.metadataTrack_ && sourceHandler.metadataTrack_.cues && sourceHandler.metadataTrack_.cues.length) {\n        (function () {\n          var cues = sourceHandler.metadataTrack_.cues;\n          var cuesArray = [];\n\n          // Create a copy of the TextTrackCueList...\n          // ...disregarding cues with a falsey value\n          for (var i = 0; i < cues.length; i++) {\n            if (cues[i]) {\n              cuesArray.push(cues[i]);\n            }\n          }\n\n          // Group cues by their startTime value\n          var cuesGroupedByStartTime = cuesArray.reduce(function (obj, cue) {\n            var timeSlot = obj[cue.startTime] || [];\n\n            timeSlot.push(cue);\n            obj[cue.startTime] = timeSlot;\n\n            return obj;\n          }, {});\n\n          // Sort startTimes by ascending order\n          var sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort(function (a, b) {\n            return Number(a) - Number(b);\n          });\n\n          // Map each cue group's endTime to the next group's startTime\n          sortedStartTimes.forEach(function (startTime, idx) {\n            var cueGroup = cuesGroupedByStartTime[startTime];\n            var nextTime = Number(sortedStartTimes[idx + 1]) || videoDuration;\n\n            // Map each cue's endTime the next group's startTime\n            cueGroup.forEach(function (cue) {\n              cue.endTime = nextTime;\n            });\n          });\n        })();\n      }\n    })();\n  }\n};\n\nexports['default'] = {\n  addTextTrackData: addTextTrackData,\n  durationOfVideo: durationOfVideo\n};\nmodule.exports = exports['default'];\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"global/window\":32}],65:[function(require,module,exports){\n/**\n * @file codec-utils.js\n */\n\n/**\n * Check if a codec string refers to an audio codec.\n *\n * @param {String} codec codec string to check\n * @return {Boolean} if this is an audio codec\n * @private\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar isAudioCodec = function isAudioCodec(codec) {\n  return (/mp4a\\.\\d+.\\d+/i.test(codec)\n  );\n};\n\n/**\n * Check if a codec string refers to a video codec.\n *\n * @param {String} codec codec string to check\n * @return {Boolean} if this is a video codec\n * @private\n */\nvar isVideoCodec = function isVideoCodec(codec) {\n  return (/avc1\\.[\\da-f]+/i.test(codec)\n  );\n};\n\n/**\n * Parse a content type header into a type and parameters\n * object\n *\n * @param {String} type the content type header\n * @return {Object} the parsed content-type\n * @private\n */\nvar parseContentType = function parseContentType(type) {\n  var object = { type: '', parameters: {} };\n  var parameters = type.trim().split(';');\n\n  // first parameter should always be content-type\n  object.type = parameters.shift().trim();\n  parameters.forEach(function (parameter) {\n    var pair = parameter.trim().split('=');\n\n    if (pair.length > 1) {\n      var _name = pair[0].replace(/\"/g, '').trim();\n      var value = pair[1].replace(/\"/g, '').trim();\n\n      object.parameters[_name] = value;\n    }\n  });\n\n  return object;\n};\n\n/**\n * Replace the old apple-style `avc1.<dd>.<dd>` codec string with the standard\n * `avc1.<hhhhhh>`\n *\n * @param {Array} codecs an array of codec strings to fix\n * @return {Array} the translated codec array\n * @private\n */\nvar translateLegacyCodecs = function translateLegacyCodecs(codecs) {\n  return codecs.map(function (codec) {\n    return codec.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (orig, profile, avcLevel) {\n      var profileHex = ('00' + Number(profile).toString(16)).slice(-2);\n      var avcLevelHex = ('00' + Number(avcLevel).toString(16)).slice(-2);\n\n      return 'avc1.' + profileHex + '00' + avcLevelHex;\n    });\n  });\n};\n\nexports['default'] = {\n  isAudioCodec: isAudioCodec,\n  parseContentType: parseContentType,\n  isVideoCodec: isVideoCodec,\n  translateLegacyCodecs: translateLegacyCodecs\n};\nmodule.exports = exports['default'];\n},{}],66:[function(require,module,exports){\n/**\n * @file create-text-tracks-if-necessary.js\n */\n\n/**\n * Create text tracks on video.js if they exist on a segment.\n *\n * @param {Object} sourceBuffer the VSB or FSB\n * @param {Object} mediaSource the HTML or Flash media source\n * @param {Object} segment the segment that may contain the text track\n * @private\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar createTextTracksIfNecessary = function createTextTracksIfNecessary(sourceBuffer, mediaSource, segment) {\n  var player = mediaSource.player_;\n\n  // create an in-band caption track if one is present in the segment\n  if (segment.captions && segment.captions.length) {\n    if (!sourceBuffer.inbandTextTracks_) {\n      sourceBuffer.inbandTextTracks_ = {};\n    }\n\n    for (var trackId in segment.captionStreams) {\n      if (!sourceBuffer.inbandTextTracks_[trackId]) {\n        player.tech_.trigger({ type: 'usage', name: 'hls-608' });\n        var track = player.textTracks().getTrackById(trackId);\n\n        if (track) {\n          // Resuse an existing track with a CC# id because this was\n          // very likely created by videojs-contrib-hls from information\n          // in the m3u8 for us to use\n          sourceBuffer.inbandTextTracks_[trackId] = track;\n        } else {\n          // Otherwise, create a track with the default `CC#` label and\n          // without a language\n          sourceBuffer.inbandTextTracks_[trackId] = player.addRemoteTextTrack({\n            kind: 'captions',\n            id: trackId,\n            label: trackId\n          }, false).track;\n        }\n      }\n    }\n  }\n\n  if (segment.metadata && segment.metadata.length && !sourceBuffer.metadataTrack_) {\n    sourceBuffer.metadataTrack_ = player.addRemoteTextTrack({\n      kind: 'metadata',\n      label: 'Timed Metadata'\n    }, false).track;\n    sourceBuffer.metadataTrack_.inBandMetadataTrackDispatchType = segment.metadata.dispatchType;\n  }\n};\n\nexports['default'] = createTextTracksIfNecessary;\nmodule.exports = exports['default'];\n},{}],67:[function(require,module,exports){\n/**\n * @file flash-constants.js\n */\n/**\n * The maximum size in bytes for append operations to the video.js\n * SWF. Calling through to Flash blocks and can be expensive so\n * we chunk data and pass through 4KB at a time, yielding to the\n * browser between chunks. This gives a theoretical maximum rate of\n * 1MB/s into Flash. Any higher and we begin to drop frames and UI\n * responsiveness suffers.\n *\n * @private\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar flashConstants = {\n  // times in milliseconds\n  TIME_BETWEEN_CHUNKS: 1,\n  BYTES_PER_CHUNK: 1024 * 32\n};\n\nexports[\"default\"] = flashConstants;\nmodule.exports = exports[\"default\"];\n},{}],68:[function(require,module,exports){\n(function (global){\n/**\n * @file flash-media-source.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _globalDocument = require('global/document');\n\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _flashSourceBuffer = require('./flash-source-buffer');\n\nvar _flashSourceBuffer2 = _interopRequireDefault(_flashSourceBuffer);\n\nvar _flashConstants = require('./flash-constants');\n\nvar _flashConstants2 = _interopRequireDefault(_flashConstants);\n\nvar _codecUtils = require('./codec-utils');\n\n/**\n * A flash implmentation of HTML MediaSources and a polyfill\n * for browsers that don't support native or HTML MediaSources..\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource\n * @class FlashMediaSource\n * @extends videojs.EventTarget\n */\n\nvar FlashMediaSource = (function (_videojs$EventTarget) {\n  _inherits(FlashMediaSource, _videojs$EventTarget);\n\n  function FlashMediaSource() {\n    var _this = this;\n\n    _classCallCheck(this, FlashMediaSource);\n\n    _get(Object.getPrototypeOf(FlashMediaSource.prototype), 'constructor', this).call(this);\n    this.sourceBuffers = [];\n    this.readyState = 'closed';\n\n    this.on(['sourceopen', 'webkitsourceopen'], function (event) {\n      // find the swf where we will push media data\n      _this.swfObj = _globalDocument2['default'].getElementById(event.swfId);\n      _this.player_ = (0, _videoJs2['default'])(_this.swfObj.parentNode);\n      _this.tech_ = _this.swfObj.tech;\n      _this.readyState = 'open';\n\n      _this.tech_.on('seeking', function () {\n        var i = _this.sourceBuffers.length;\n\n        while (i--) {\n          _this.sourceBuffers[i].abort();\n        }\n      });\n\n      // trigger load events\n      if (_this.swfObj) {\n        _this.swfObj.vjs_load();\n      }\n    });\n  }\n\n  /**\n    * Set or return the presentation duration.\n    *\n    * @param {Double} value the duration of the media in seconds\n    * @param {Double} the current presentation duration\n    * @link http://www.w3.org/TR/media-source/#widl-MediaSource-duration\n    */\n\n  /**\n   * We have this function so that the html and flash interfaces\n   * are the same.\n   *\n   * @private\n   */\n\n  _createClass(FlashMediaSource, [{\n    key: 'addSeekableRange_',\n    value: function addSeekableRange_() {}\n    // intentional no-op\n\n    /**\n     * Create a new flash source buffer and add it to our flash media source.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/addSourceBuffer\n     * @param {String} type the content-type of the source\n     * @return {Object} the flash source buffer\n     */\n\n  }, {\n    key: 'addSourceBuffer',\n    value: function addSourceBuffer(type) {\n      var parsedType = (0, _codecUtils.parseContentType)(type);\n      var sourceBuffer = undefined;\n\n      // if this is an FLV type, we'll push data to flash\n      if (parsedType.type === 'video/mp2t' || parsedType.type === 'audio/mp2t') {\n        // Flash source buffers\n        sourceBuffer = new _flashSourceBuffer2['default'](this);\n      } else {\n        throw new Error('NotSupportedError (Video.js)');\n      }\n\n      this.sourceBuffers.push(sourceBuffer);\n      return sourceBuffer;\n    }\n\n    /**\n     * Signals the end of the stream.\n     *\n     * @link https://w3c.github.io/media-source/#widl-MediaSource-endOfStream-void-EndOfStreamError-error\n     * @param {String=} error Signals that a playback error\n     * has occurred. If specified, it must be either \"network\" or\n     * \"decode\".\n     */\n  }, {\n    key: 'endOfStream',\n    value: function endOfStream(error) {\n      if (error === 'network') {\n        // MEDIA_ERR_NETWORK\n        this.tech_.error(2);\n      } else if (error === 'decode') {\n        // MEDIA_ERR_DECODE\n        this.tech_.error(3);\n      }\n      if (this.readyState !== 'ended') {\n        this.readyState = 'ended';\n        this.swfObj.vjs_endOfStream();\n      }\n    }\n  }]);\n\n  return FlashMediaSource;\n})(_videoJs2['default'].EventTarget);\n\nexports['default'] = FlashMediaSource;\ntry {\n  Object.defineProperty(FlashMediaSource.prototype, 'duration', {\n    /**\n     * Return the presentation duration.\n     *\n     * @return {Double} the duration of the media in seconds\n     * @link http://www.w3.org/TR/media-source/#widl-MediaSource-duration\n     */\n    get: function get() {\n      if (!this.swfObj) {\n        return NaN;\n      }\n      // get the current duration from the SWF\n      return this.swfObj.vjs_getProperty('duration');\n    },\n    /**\n     * Set the presentation duration.\n     *\n     * @param {Double} value the duration of the media in seconds\n     * @return {Double} the duration of the media in seconds\n     * @link http://www.w3.org/TR/media-source/#widl-MediaSource-duration\n     */\n    set: function set(value) {\n      var i = undefined;\n      var oldDuration = this.swfObj.vjs_getProperty('duration');\n\n      this.swfObj.vjs_setProperty('duration', value);\n\n      if (value < oldDuration) {\n        // In MSE, this triggers the range removal algorithm which causes\n        // an update to occur\n        for (i = 0; i < this.sourceBuffers.length; i++) {\n          this.sourceBuffers[i].remove(value, oldDuration);\n        }\n      }\n\n      return value;\n    }\n  });\n} catch (e) {\n  // IE8 throws if defineProperty is called on a non-DOM node. We\n  // don't support IE8 but we shouldn't throw an error if loaded\n  // there.\n  FlashMediaSource.prototype.duration = NaN;\n}\n\nfor (var property in _flashConstants2['default']) {\n  FlashMediaSource[property] = _flashConstants2['default'][property];\n}\nmodule.exports = exports['default'];\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./codec-utils\":65,\"./flash-constants\":67,\"./flash-source-buffer\":69,\"global/document\":31}],69:[function(require,module,exports){\n(function (global){\n/**\n * @file flash-source-buffer.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _muxJsLibFlv = require('mux.js/lib/flv');\n\nvar _muxJsLibFlv2 = _interopRequireDefault(_muxJsLibFlv);\n\nvar _removeCuesFromTrack = require('./remove-cues-from-track');\n\nvar _removeCuesFromTrack2 = _interopRequireDefault(_removeCuesFromTrack);\n\nvar _createTextTracksIfNecessary = require('./create-text-tracks-if-necessary');\n\nvar _createTextTracksIfNecessary2 = _interopRequireDefault(_createTextTracksIfNecessary);\n\nvar _addTextTrackData = require('./add-text-track-data');\n\nvar _flashTransmuxerWorker = require('./flash-transmuxer-worker');\n\nvar _flashTransmuxerWorker2 = _interopRequireDefault(_flashTransmuxerWorker);\n\nvar _webworkify = require('webworkify');\n\nvar _webworkify2 = _interopRequireDefault(_webworkify);\n\nvar _flashConstants = require('./flash-constants');\n\nvar _flashConstants2 = _interopRequireDefault(_flashConstants);\n\n/**\n * A wrapper around the setTimeout function that uses\n * the flash constant time between ticks value.\n *\n * @param {Function} func the function callback to run\n * @private\n */\nvar scheduleTick = function scheduleTick(func) {\n  // Chrome doesn't invoke requestAnimationFrame callbacks\n  // in background tabs, so use setTimeout.\n  _globalWindow2['default'].setTimeout(func, _flashConstants2['default'].TIME_BETWEEN_CHUNKS);\n};\n\n/**\n * Generates a random string of max length 6\n *\n * @return {String} the randomly generated string\n * @function generateRandomString\n * @private\n */\nvar generateRandomString = function generateRandomString() {\n  return Math.random().toString(36).slice(2, 8);\n};\n\n/**\n * Round a number to a specified number of places much like\n * toFixed but return a number instead of a string representation.\n *\n * @param {Number} num A number\n * @param {Number} places The number of decimal places which to\n * round\n * @private\n */\nvar toDecimalPlaces = function toDecimalPlaces(num, places) {\n  if (typeof places !== 'number' || places < 0) {\n    places = 0;\n  }\n\n  var scale = Math.pow(10, places);\n\n  return Math.round(num * scale) / scale;\n};\n\n/**\n * A SourceBuffer implementation for Flash rather than HTML.\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource\n * @param {Object} mediaSource the flash media source\n * @class FlashSourceBuffer\n * @extends videojs.EventTarget\n */\n\nvar FlashSourceBuffer = (function (_videojs$EventTarget) {\n  _inherits(FlashSourceBuffer, _videojs$EventTarget);\n\n  function FlashSourceBuffer(mediaSource) {\n    var _this = this;\n\n    _classCallCheck(this, FlashSourceBuffer);\n\n    _get(Object.getPrototypeOf(FlashSourceBuffer.prototype), 'constructor', this).call(this);\n    var encodedHeader = undefined;\n\n    // Start off using the globally defined value but refine\n    // as we append data into flash\n    this.chunkSize_ = _flashConstants2['default'].BYTES_PER_CHUNK;\n\n    // byte arrays queued to be appended\n    this.buffer_ = [];\n\n    // the total number of queued bytes\n    this.bufferSize_ = 0;\n\n    // to be able to determine the correct position to seek to, we\n    // need to retain information about the mapping between the\n    // media timeline and PTS values\n    this.basePtsOffset_ = NaN;\n\n    this.mediaSource_ = mediaSource;\n\n    this.audioBufferEnd_ = NaN;\n    this.videoBufferEnd_ = NaN;\n\n    // indicates whether the asynchronous continuation of an operation\n    // is still being processed\n    // see https://w3c.github.io/media-source/#widl-SourceBuffer-updating\n    this.updating = false;\n    this.timestampOffset_ = 0;\n\n    encodedHeader = _globalWindow2['default'].btoa(String.fromCharCode.apply(null, Array.prototype.slice.call(_muxJsLibFlv2['default'].getFlvHeader())));\n\n    // create function names with added randomness for the global callbacks flash will use\n    // to get data from javascript into the swf. Random strings are added as a safety\n    // measure for pages with multiple players since these functions will be global\n    // instead of per instance. When making a call to the swf, the browser generates a\n    // try catch code snippet, but just takes the function name and writes out an unquoted\n    // call to that function. If the player id has any special characters, this will result\n    // in an error, so safePlayerId replaces all special characters to '_'\n    var safePlayerId = this.mediaSource_.player_.id().replace(/[^a-zA-Z0-9]/g, '_');\n\n    this.flashEncodedHeaderName_ = 'vjs_flashEncodedHeader_' + safePlayerId + generateRandomString();\n    this.flashEncodedDataName_ = 'vjs_flashEncodedData_' + safePlayerId + generateRandomString();\n\n    _globalWindow2['default'][this.flashEncodedHeaderName_] = function () {\n      delete _globalWindow2['default'][_this.flashEncodedHeaderName_];\n      return encodedHeader;\n    };\n\n    this.mediaSource_.swfObj.vjs_appendChunkReady(this.flashEncodedHeaderName_);\n\n    this.transmuxer_ = (0, _webworkify2['default'])(_flashTransmuxerWorker2['default']);\n    this.transmuxer_.postMessage({ action: 'init', options: {} });\n    this.transmuxer_.onmessage = function (event) {\n      if (event.data.action === 'data') {\n        _this.receiveBuffer_(event.data.segment);\n      }\n    };\n\n    this.one('updateend', function () {\n      _this.mediaSource_.tech_.trigger('loadedmetadata');\n    });\n\n    Object.defineProperty(this, 'timestampOffset', {\n      get: function get() {\n        return this.timestampOffset_;\n      },\n      set: function set(val) {\n        if (typeof val === 'number' && val >= 0) {\n          this.timestampOffset_ = val;\n          // We have to tell flash to expect a discontinuity\n          this.mediaSource_.swfObj.vjs_discontinuity();\n          // the media <-> PTS mapping must be re-established after\n          // the discontinuity\n          this.basePtsOffset_ = NaN;\n          this.audioBufferEnd_ = NaN;\n          this.videoBufferEnd_ = NaN;\n\n          this.transmuxer_.postMessage({ action: 'reset' });\n        }\n      }\n    });\n\n    Object.defineProperty(this, 'buffered', {\n      get: function get() {\n        if (!this.mediaSource_ || !this.mediaSource_.swfObj || !('vjs_getProperty' in this.mediaSource_.swfObj)) {\n          return _videoJs2['default'].createTimeRange();\n        }\n\n        var buffered = this.mediaSource_.swfObj.vjs_getProperty('buffered');\n\n        if (buffered && buffered.length) {\n          buffered[0][0] = toDecimalPlaces(buffered[0][0], 3);\n          buffered[0][1] = toDecimalPlaces(buffered[0][1], 3);\n        }\n        return _videoJs2['default'].createTimeRanges(buffered);\n      }\n    });\n\n    // On a seek we remove all text track data since flash has no concept\n    // of a buffered-range and everything else is reset on seek\n    this.mediaSource_.player_.on('seeked', function () {\n      (0, _removeCuesFromTrack2['default'])(0, Infinity, _this.metadataTrack_);\n      if (_this.inbandTextTracks_) {\n        for (var track in _this.inbandTextTracks_) {\n          (0, _removeCuesFromTrack2['default'])(0, Infinity, _this.inbandTextTracks_[track]);\n        }\n      }\n    });\n\n    var onHlsReset = this.onHlsReset_.bind(this);\n\n    // hls-reset is fired by videojs.Hls on to the tech after the main SegmentLoader\n    // resets its state and flushes the buffer\n    this.mediaSource_.player_.tech_.on('hls-reset', onHlsReset);\n\n    this.mediaSource_.player_.tech_.hls.on('dispose', function () {\n      _this.transmuxer_.terminate();\n      _this.mediaSource_.player_.tech_.off('hls-reset', onHlsReset);\n    });\n  }\n\n  /**\n   * Append bytes to the sourcebuffers buffer, in this case we\n   * have to append it to swf object.\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/appendBuffer\n   * @param {Array} bytes\n   */\n\n  _createClass(FlashSourceBuffer, [{\n    key: 'appendBuffer',\n    value: function appendBuffer(bytes) {\n      var error = undefined;\n\n      if (this.updating) {\n        error = new Error('SourceBuffer.append() cannot be called ' + 'while an update is in progress');\n        error.name = 'InvalidStateError';\n        error.code = 11;\n        throw error;\n      }\n      this.updating = true;\n      this.mediaSource_.readyState = 'open';\n      this.trigger({ type: 'update' });\n\n      this.transmuxer_.postMessage({\n        action: 'push',\n        data: bytes.buffer,\n        byteOffset: bytes.byteOffset,\n        byteLength: bytes.byteLength\n      }, [bytes.buffer]);\n      this.transmuxer_.postMessage({ action: 'flush' });\n    }\n\n    /**\n     * Reset the parser and remove any data queued to be sent to the SWF.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/abort\n     */\n  }, {\n    key: 'abort',\n    value: function abort() {\n      this.buffer_ = [];\n      this.bufferSize_ = 0;\n      this.mediaSource_.swfObj.vjs_abort();\n\n      // report any outstanding updates have ended\n      if (this.updating) {\n        this.updating = false;\n        this.trigger({ type: 'updateend' });\n      }\n    }\n\n    /**\n     * Flash cannot remove ranges already buffered in the NetStream\n     * but seeking clears the buffer entirely. For most purposes,\n     * having this operation act as a no-op is acceptable.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/remove\n     * @param {Double} start start of the section to remove\n     * @param {Double} end end of the section to remove\n     */\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      (0, _removeCuesFromTrack2['default'])(start, end, this.metadataTrack_);\n      if (this.inbandTextTracks_) {\n        for (var track in this.inbandTextTracks_) {\n          (0, _removeCuesFromTrack2['default'])(start, end, this.inbandTextTracks_[track]);\n        }\n      }\n      this.trigger({ type: 'update' });\n      this.trigger({ type: 'updateend' });\n    }\n\n    /**\n     * Receive a buffer from the flv.\n     *\n     * @param {Object} segment\n     * @private\n     */\n  }, {\n    key: 'receiveBuffer_',\n    value: function receiveBuffer_(segment) {\n      var _this2 = this;\n\n      // create an in-band caption track if one is present in the segment\n      (0, _createTextTracksIfNecessary2['default'])(this, this.mediaSource_, segment);\n      (0, _addTextTrackData.addTextTrackData)(this, segment.captions, segment.metadata);\n\n      // Do this asynchronously since convertTagsToData_ can be time consuming\n      scheduleTick(function () {\n        var flvBytes = _this2.convertTagsToData_(segment);\n\n        if (_this2.buffer_.length === 0) {\n          scheduleTick(_this2.processBuffer_.bind(_this2));\n        }\n\n        if (flvBytes) {\n          _this2.buffer_.push(flvBytes);\n          _this2.bufferSize_ += flvBytes.byteLength;\n        }\n      });\n    }\n\n    /**\n     * Append a portion of the current buffer to the SWF.\n     *\n     * @private\n     */\n  }, {\n    key: 'processBuffer_',\n    value: function processBuffer_() {\n      var _this3 = this;\n\n      var chunkSize = _flashConstants2['default'].BYTES_PER_CHUNK;\n\n      if (!this.buffer_.length) {\n        if (this.updating !== false) {\n          this.updating = false;\n          this.trigger({ type: 'updateend' });\n        }\n        // do nothing if the buffer is empty\n        return;\n      }\n\n      // concatenate appends up to the max append size\n      var chunk = this.buffer_[0].subarray(0, chunkSize);\n\n      // requeue any bytes that won't make it this round\n      if (chunk.byteLength < chunkSize || this.buffer_[0].byteLength === chunkSize) {\n        this.buffer_.shift();\n      } else {\n        this.buffer_[0] = this.buffer_[0].subarray(chunkSize);\n      }\n\n      this.bufferSize_ -= chunk.byteLength;\n\n      // base64 encode the bytes\n      var binary = [];\n      var length = chunk.byteLength;\n\n      for (var i = 0; i < length; i++) {\n        binary.push(String.fromCharCode(chunk[i]));\n      }\n      var b64str = _globalWindow2['default'].btoa(binary.join(''));\n\n      _globalWindow2['default'][this.flashEncodedDataName_] = function () {\n        // schedule another processBuffer to process any left over data or to\n        // trigger updateend\n        scheduleTick(_this3.processBuffer_.bind(_this3));\n        delete _globalWindow2['default'][_this3.flashEncodedDataName_];\n        return b64str;\n      };\n\n      // Notify the swf that segment data is ready to be appended\n      this.mediaSource_.swfObj.vjs_appendChunkReady(this.flashEncodedDataName_);\n    }\n\n    /**\n     * Turns an array of flv tags into a Uint8Array representing the\n     * flv data. Also removes any tags that are before the current\n     * time so that playback begins at or slightly after the right\n     * place on a seek\n     *\n     * @private\n     * @param {Object} segmentData object of segment data\n     */\n  }, {\n    key: 'convertTagsToData_',\n    value: function convertTagsToData_(segmentData) {\n      var segmentByteLength = 0;\n      var tech = this.mediaSource_.tech_;\n      var videoTargetPts = 0;\n      var segment = undefined;\n      var videoTags = segmentData.tags.videoTags;\n      var audioTags = segmentData.tags.audioTags;\n\n      // Establish the media timeline to PTS translation if we don't\n      // have one already\n      if (isNaN(this.basePtsOffset_) && (videoTags.length || audioTags.length)) {\n        // We know there is at least one video or audio tag, but since we may not have both,\n        // we use pts: Infinity for the missing tag. The will force the following Math.min\n        // call will to use the proper pts value since it will always be less than Infinity\n        var firstVideoTag = videoTags[0] || { pts: Infinity };\n        var firstAudioTag = audioTags[0] || { pts: Infinity };\n\n        this.basePtsOffset_ = Math.min(firstAudioTag.pts, firstVideoTag.pts);\n      }\n\n      if (tech.seeking()) {\n        // Do not use previously saved buffer end values while seeking since buffer\n        // is cleared on all seeks\n        this.videoBufferEnd_ = NaN;\n        this.audioBufferEnd_ = NaN;\n      }\n\n      if (isNaN(this.videoBufferEnd_)) {\n        if (tech.buffered().length) {\n          videoTargetPts = tech.buffered().end(0) - this.timestampOffset;\n        }\n\n        // Trim to currentTime if seeking\n        if (tech.seeking()) {\n          videoTargetPts = Math.max(videoTargetPts, tech.currentTime() - this.timestampOffset);\n        }\n\n        // PTS values are represented in milliseconds\n        videoTargetPts *= 1e3;\n        videoTargetPts += this.basePtsOffset_;\n      } else {\n        // Add a fudge factor of 0.1 to the last video pts appended since a rendition change\n        // could append an overlapping segment, in which case there is a high likelyhood\n        // a tag could have a matching pts to videoBufferEnd_, which would cause\n        // that tag to get appended by the tag.pts >= targetPts check below even though it\n        // is a duplicate of what was previously appended\n        videoTargetPts = this.videoBufferEnd_ + 0.1;\n      }\n\n      // filter complete GOPs with a presentation time less than the seek target/end of buffer\n      var currentIndex = videoTags.length;\n\n      // if the last tag is beyond videoTargetPts, then do not search the list for a GOP\n      // since our videoTargetPts lies in a future segment\n      if (currentIndex && videoTags[currentIndex - 1].pts >= videoTargetPts) {\n        // Start by walking backwards from the end of the list until we reach a tag that\n        // is equal to or less than videoTargetPts\n        while (--currentIndex) {\n          var currentTag = videoTags[currentIndex];\n\n          if (currentTag.pts > videoTargetPts) {\n            continue;\n          }\n\n          // if we see a keyFrame or metadata tag once we've gone below videoTargetPts,\n          // exit the loop as this is the start of the GOP that we want to append\n          if (currentTag.keyFrame || currentTag.metaDataTag) {\n            break;\n          }\n        }\n\n        // We need to check if there are any metadata tags that come before currentIndex\n        // as those will be metadata tags associated with the GOP we are appending\n        // There could be 0 to 2 metadata tags that come before the currentIndex depending\n        // on what videoTargetPts is and whether the transmuxer prepended metadata tags to this\n        // key frame\n        while (currentIndex) {\n          var nextTag = videoTags[currentIndex - 1];\n\n          if (!nextTag.metaDataTag) {\n            break;\n          }\n\n          currentIndex--;\n        }\n      }\n\n      var filteredVideoTags = videoTags.slice(currentIndex);\n\n      var audioTargetPts = undefined;\n\n      if (isNaN(this.audioBufferEnd_)) {\n        audioTargetPts = videoTargetPts;\n      } else {\n        // Add a fudge factor of 0.1 to the last video pts appended since a rendition change\n        // could append an overlapping segment, in which case there is a high likelyhood\n        // a tag could have a matching pts to videoBufferEnd_, which would cause\n        // that tag to get appended by the tag.pts >= targetPts check below even though it\n        // is a duplicate of what was previously appended\n        audioTargetPts = this.audioBufferEnd_ + 0.1;\n      }\n\n      if (filteredVideoTags.length) {\n        // If targetPts intersects a GOP and we appended the tags for the GOP that came\n        // before targetPts, we want to make sure to trim audio tags at the pts\n        // of the first video tag to avoid brief moments of silence\n        audioTargetPts = Math.min(audioTargetPts, filteredVideoTags[0].pts);\n      }\n\n      // skip tags with a presentation time less than the seek target/end of buffer\n      currentIndex = 0;\n\n      while (currentIndex < audioTags.length) {\n        if (audioTags[currentIndex].pts >= audioTargetPts) {\n          break;\n        }\n\n        currentIndex++;\n      }\n\n      var filteredAudioTags = audioTags.slice(currentIndex);\n\n      // update the audio and video buffer ends\n      if (filteredAudioTags.length) {\n        this.audioBufferEnd_ = filteredAudioTags[filteredAudioTags.length - 1].pts;\n      }\n      if (filteredVideoTags.length) {\n        this.videoBufferEnd_ = filteredVideoTags[filteredVideoTags.length - 1].pts;\n      }\n\n      var tags = this.getOrderedTags_(filteredVideoTags, filteredAudioTags);\n\n      if (tags.length === 0) {\n        return;\n      }\n\n      // If we are appending data that comes before our target pts, we want to tell\n      // the swf to adjust its notion of current time to account for the extra tags\n      // we are appending to complete the GOP that intersects with targetPts\n      if (tags[0].pts < videoTargetPts && tech.seeking()) {\n        var fudgeFactor = 1 / 30;\n        var currentTime = tech.currentTime();\n        var diff = (videoTargetPts - tags[0].pts) / 1e3;\n        var adjustedTime = currentTime - diff;\n\n        if (adjustedTime < fudgeFactor) {\n          adjustedTime = 0;\n        }\n\n        try {\n          this.mediaSource_.swfObj.vjs_adjustCurrentTime(adjustedTime);\n        } catch (e) {\n          // no-op for backwards compatability of swf. If adjustCurrentTime fails,\n          // the swf may incorrectly report currentTime and buffered ranges\n          // but should not affect playback over than the time displayed on the\n          // progress bar is inaccurate\n        }\n      }\n\n      // concatenate the bytes into a single segment\n      for (var i = 0; i < tags.length; i++) {\n        segmentByteLength += tags[i].bytes.byteLength;\n      }\n      segment = new Uint8Array(segmentByteLength);\n      for (var i = 0, j = 0; i < tags.length; i++) {\n        segment.set(tags[i].bytes, j);\n        j += tags[i].bytes.byteLength;\n      }\n\n      return segment;\n    }\n\n    /**\n     * Assemble the FLV tags in decoder order.\n     *\n     * @private\n     * @param {Array} videoTags list of video tags\n     * @param {Array} audioTags list of audio tags\n     */\n  }, {\n    key: 'getOrderedTags_',\n    value: function getOrderedTags_(videoTags, audioTags) {\n      var tag = undefined;\n      var tags = [];\n\n      while (videoTags.length || audioTags.length) {\n        if (!videoTags.length) {\n          // only audio tags remain\n          tag = audioTags.shift();\n        } else if (!audioTags.length) {\n          // only video tags remain\n          tag = videoTags.shift();\n        } else if (audioTags[0].dts < videoTags[0].dts) {\n          // audio should be decoded next\n          tag = audioTags.shift();\n        } else {\n          // video should be decoded next\n          tag = videoTags.shift();\n        }\n\n        tags.push(tag);\n      }\n\n      return tags;\n    }\n  }, {\n    key: 'onHlsReset_',\n    value: function onHlsReset_() {\n      this.transmuxer_.postMessage({ action: 'resetCaptions' });\n    }\n  }]);\n\n  return FlashSourceBuffer;\n})(_videoJs2['default'].EventTarget);\n\nexports['default'] = FlashSourceBuffer;\nmodule.exports = exports['default'];\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./add-text-track-data\":64,\"./create-text-tracks-if-necessary\":66,\"./flash-constants\":67,\"./flash-transmuxer-worker\":70,\"./remove-cues-from-track\":72,\"global/window\":32,\"mux.js/lib/flv\":46,\"webworkify\":76}],70:[function(require,module,exports){\n/**\n * @file flash-transmuxer-worker.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _muxJsLibFlv = require('mux.js/lib/flv');\n\nvar _muxJsLibFlv2 = _interopRequireDefault(_muxJsLibFlv);\n\n/**\n * Re-emits transmuxer events by converting them into messages to the\n * world outside the worker.\n *\n * @param {Object} transmuxer the transmuxer to wire events on\n * @private\n */\nvar wireTransmuxerEvents = function wireTransmuxerEvents(transmuxer) {\n  transmuxer.on('data', function (segment) {\n    _globalWindow2['default'].postMessage({\n      action: 'data',\n      segment: segment\n    });\n  });\n\n  transmuxer.on('done', function (data) {\n    _globalWindow2['default'].postMessage({ action: 'done' });\n  });\n};\n\n/**\n * All incoming messages route through this hash. If no function exists\n * to handle an incoming message, then we ignore the message.\n *\n * @class MessageHandlers\n * @param {Object} options the options to initialize with\n */\n\nvar MessageHandlers = (function () {\n  function MessageHandlers(options) {\n    _classCallCheck(this, MessageHandlers);\n\n    this.options = options || {};\n    this.init();\n  }\n\n  /**\n   * Our web wroker interface so that things can talk to mux.js\n   * that will be running in a web worker. The scope is passed to this by\n   * webworkify.\n   *\n   * @param {Object} self the scope for the web worker\n   */\n\n  /**\n   * initialize our web worker and wire all the events.\n   */\n\n  _createClass(MessageHandlers, [{\n    key: 'init',\n    value: function init() {\n      if (this.transmuxer) {\n        this.transmuxer.dispose();\n      }\n      this.transmuxer = new _muxJsLibFlv2['default'].Transmuxer(this.options);\n      wireTransmuxerEvents(this.transmuxer);\n    }\n\n    /**\n     * Adds data (a ts segment) to the start of the transmuxer pipeline for\n     * processing.\n     *\n     * @param {ArrayBuffer} data data to push into the muxer\n     */\n  }, {\n    key: 'push',\n    value: function push(data) {\n      // Cast array buffer to correct type for transmuxer\n      var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\n\n      this.transmuxer.push(segment);\n    }\n\n    /**\n     * Recreate the transmuxer so that the next segment added via `push`\n     * start with a fresh transmuxer.\n     */\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.init();\n    }\n\n    /**\n     * Forces the pipeline to finish processing the last segment and emit its\n     * results.\n     */\n  }, {\n    key: 'flush',\n    value: function flush() {\n      this.transmuxer.flush();\n    }\n  }, {\n    key: 'resetCaptions',\n    value: function resetCaptions() {\n      this.transmuxer.resetCaptions();\n    }\n  }]);\n\n  return MessageHandlers;\n})();\n\nvar FlashTransmuxerWorker = function FlashTransmuxerWorker(self) {\n  self.onmessage = function (event) {\n    if (event.data.action === 'init' && event.data.options) {\n      this.messageHandlers = new MessageHandlers(event.data.options);\n      return;\n    }\n\n    if (!this.messageHandlers) {\n      this.messageHandlers = new MessageHandlers();\n    }\n\n    if (event.data && event.data.action && event.data.action !== 'init') {\n      if (this.messageHandlers[event.data.action]) {\n        this.messageHandlers[event.data.action](event.data);\n      }\n    }\n  };\n};\n\nexports['default'] = function (self) {\n  return new FlashTransmuxerWorker(self);\n};\n\nmodule.exports = exports['default'];\n},{\"global/window\":32,\"mux.js/lib/flv\":46}],71:[function(require,module,exports){\n(function (global){\n/**\n * @file html-media-source.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _globalDocument = require('global/document');\n\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _virtualSourceBuffer = require('./virtual-source-buffer');\n\nvar _virtualSourceBuffer2 = _interopRequireDefault(_virtualSourceBuffer);\n\nvar _addTextTrackData = require('./add-text-track-data');\n\nvar _codecUtils = require('./codec-utils');\n\n/**\n * Our MediaSource implementation in HTML, mimics native\n * MediaSource where/if possible.\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource\n * @class HtmlMediaSource\n * @extends videojs.EventTarget\n */\n\nvar HtmlMediaSource = (function (_videojs$EventTarget) {\n  _inherits(HtmlMediaSource, _videojs$EventTarget);\n\n  function HtmlMediaSource() {\n    var _this = this;\n\n    _classCallCheck(this, HtmlMediaSource);\n\n    _get(Object.getPrototypeOf(HtmlMediaSource.prototype), 'constructor', this).call(this);\n    var property = undefined;\n\n    this.nativeMediaSource_ = new _globalWindow2['default'].MediaSource();\n    // delegate to the native MediaSource's methods by default\n    for (property in this.nativeMediaSource_) {\n      if (!(property in HtmlMediaSource.prototype) && typeof this.nativeMediaSource_[property] === 'function') {\n        this[property] = this.nativeMediaSource_[property].bind(this.nativeMediaSource_);\n      }\n    }\n\n    // emulate `duration` and `seekable` until seeking can be\n    // handled uniformly for live streams\n    // see https://github.com/w3c/media-source/issues/5\n    this.duration_ = NaN;\n    Object.defineProperty(this, 'duration', {\n      get: function get() {\n        if (this.duration_ === Infinity) {\n          return this.duration_;\n        }\n        return this.nativeMediaSource_.duration;\n      },\n      set: function set(duration) {\n        this.duration_ = duration;\n        if (duration !== Infinity) {\n          this.nativeMediaSource_.duration = duration;\n          return;\n        }\n      }\n    });\n    Object.defineProperty(this, 'seekable', {\n      get: function get() {\n        if (this.duration_ === Infinity) {\n          return _videoJs2['default'].createTimeRanges([[0, this.nativeMediaSource_.duration]]);\n        }\n        return this.nativeMediaSource_.seekable;\n      }\n    });\n\n    Object.defineProperty(this, 'readyState', {\n      get: function get() {\n        return this.nativeMediaSource_.readyState;\n      }\n    });\n\n    Object.defineProperty(this, 'activeSourceBuffers', {\n      get: function get() {\n        return this.activeSourceBuffers_;\n      }\n    });\n\n    // the list of virtual and native SourceBuffers created by this\n    // MediaSource\n    this.sourceBuffers = [];\n\n    this.activeSourceBuffers_ = [];\n\n    /**\n     * update the list of active source buffers based upon various\n     * imformation from HLS and video.js\n     *\n     * @private\n     */\n    this.updateActiveSourceBuffers_ = function () {\n      // Retain the reference but empty the array\n      _this.activeSourceBuffers_.length = 0;\n\n      // If there is only one source buffer, then it will always be active and audio will\n      // be disabled based on the codec of the source buffer\n      if (_this.sourceBuffers.length === 1) {\n        var sourceBuffer = _this.sourceBuffers[0];\n\n        sourceBuffer.appendAudioInitSegment_ = true;\n        sourceBuffer.audioDisabled_ = !sourceBuffer.audioCodec_;\n        _this.activeSourceBuffers_.push(sourceBuffer);\n        return;\n      }\n\n      // There are 2 source buffers, a combined (possibly video only) source buffer and\n      // and an audio only source buffer.\n      // By default, the audio in the combined virtual source buffer is enabled\n      // and the audio-only source buffer (if it exists) is disabled.\n      var disableCombined = false;\n      var disableAudioOnly = true;\n\n      // TODO: maybe we can store the sourcebuffers on the track objects?\n      // safari may do something like this\n      for (var i = 0; i < _this.player_.audioTracks().length; i++) {\n        var track = _this.player_.audioTracks()[i];\n\n        if (track.enabled && track.kind !== 'main') {\n          // The enabled track is an alternate audio track so disable the audio in\n          // the combined source buffer and enable the audio-only source buffer.\n          disableCombined = true;\n          disableAudioOnly = false;\n          break;\n        }\n      }\n\n      _this.sourceBuffers.forEach(function (sourceBuffer) {\n        /* eslinst-disable */\n        // TODO once codecs are required, we can switch to using the codecs to determine\n        //      what stream is the video stream, rather than relying on videoTracks\n        /* eslinst-enable */\n\n        sourceBuffer.appendAudioInitSegment_ = true;\n\n        if (sourceBuffer.videoCodec_ && sourceBuffer.audioCodec_) {\n          // combined\n          sourceBuffer.audioDisabled_ = disableCombined;\n        } else if (sourceBuffer.videoCodec_ && !sourceBuffer.audioCodec_) {\n          // If the \"combined\" source buffer is video only, then we do not want\n          // disable the audio-only source buffer (this is mostly for demuxed\n          // audio and video hls)\n          sourceBuffer.audioDisabled_ = true;\n          disableAudioOnly = false;\n        } else if (!sourceBuffer.videoCodec_ && sourceBuffer.audioCodec_) {\n          // audio only\n          sourceBuffer.audioDisabled_ = disableAudioOnly;\n          if (disableAudioOnly) {\n            return;\n          }\n        }\n\n        _this.activeSourceBuffers_.push(sourceBuffer);\n      });\n    };\n\n    this.onPlayerMediachange_ = function () {\n      _this.sourceBuffers.forEach(function (sourceBuffer) {\n        sourceBuffer.appendAudioInitSegment_ = true;\n      });\n    };\n\n    this.onHlsReset_ = function () {\n      _this.sourceBuffers.forEach(function (sourceBuffer) {\n        if (sourceBuffer.transmuxer_) {\n          sourceBuffer.transmuxer_.postMessage({ action: 'resetCaptions' });\n        }\n      });\n    };\n\n    this.onHlsSegmentTimeMapping_ = function (event) {\n      _this.sourceBuffers.forEach(function (buffer) {\n        return buffer.timeMapping_ = event.mapping;\n      });\n    };\n\n    // Re-emit MediaSource events on the polyfill\n    ['sourceopen', 'sourceclose', 'sourceended'].forEach(function (eventName) {\n      this.nativeMediaSource_.addEventListener(eventName, this.trigger.bind(this));\n    }, this);\n\n    // capture the associated player when the MediaSource is\n    // successfully attached\n    this.on('sourceopen', function (event) {\n      // Get the player this MediaSource is attached to\n      var video = _globalDocument2['default'].querySelector('[src=\"' + _this.url_ + '\"]');\n\n      if (!video) {\n        return;\n      }\n\n      _this.player_ = (0, _videoJs2['default'])(video.parentNode);\n\n      // hls-reset is fired by videojs.Hls on to the tech after the main SegmentLoader\n      // resets its state and flushes the buffer\n      _this.player_.tech_.on('hls-reset', _this.onHlsReset_);\n      // hls-segment-time-mapping is fired by videojs.Hls on to the tech after the main\n      // SegmentLoader inspects an MTS segment and has an accurate stream to display\n      // time mapping\n      _this.player_.tech_.on('hls-segment-time-mapping', _this.onHlsSegmentTimeMapping_);\n\n      if (_this.player_.audioTracks && _this.player_.audioTracks()) {\n        _this.player_.audioTracks().on('change', _this.updateActiveSourceBuffers_);\n        _this.player_.audioTracks().on('addtrack', _this.updateActiveSourceBuffers_);\n        _this.player_.audioTracks().on('removetrack', _this.updateActiveSourceBuffers_);\n      }\n\n      _this.player_.on('mediachange', _this.onPlayerMediachange_);\n    });\n\n    this.on('sourceended', function (event) {\n      var duration = (0, _addTextTrackData.durationOfVideo)(_this.duration);\n\n      for (var i = 0; i < _this.sourceBuffers.length; i++) {\n        var sourcebuffer = _this.sourceBuffers[i];\n        var cues = sourcebuffer.metadataTrack_ && sourcebuffer.metadataTrack_.cues;\n\n        if (cues && cues.length) {\n          cues[cues.length - 1].endTime = duration;\n        }\n      }\n    });\n\n    // explicitly terminate any WebWorkers that were created\n    // by SourceHandlers\n    this.on('sourceclose', function (event) {\n      this.sourceBuffers.forEach(function (sourceBuffer) {\n        if (sourceBuffer.transmuxer_) {\n          sourceBuffer.transmuxer_.terminate();\n        }\n      });\n\n      this.sourceBuffers.length = 0;\n      if (!this.player_) {\n        return;\n      }\n\n      if (this.player_.audioTracks && this.player_.audioTracks()) {\n        this.player_.audioTracks().off('change', this.updateActiveSourceBuffers_);\n        this.player_.audioTracks().off('addtrack', this.updateActiveSourceBuffers_);\n        this.player_.audioTracks().off('removetrack', this.updateActiveSourceBuffers_);\n      }\n\n      // We can only change this if the player hasn't been disposed of yet\n      // because `off` eventually tries to use the el_ property. If it has\n      // been disposed of, then don't worry about it because there are no\n      // event handlers left to unbind anyway\n      if (this.player_.el_) {\n        this.player_.off('mediachange', this.onPlayerMediachange_);\n        this.player_.tech_.off('hls-reset', this.onHlsReset_);\n        this.player_.tech_.off('hls-segment-time-mapping', this.onHlsSegmentTimeMapping_);\n      }\n    });\n  }\n\n  /**\n   * Add a range that that can now be seeked to.\n   *\n   * @param {Double} start where to start the addition\n   * @param {Double} end where to end the addition\n   * @private\n   */\n\n  _createClass(HtmlMediaSource, [{\n    key: 'addSeekableRange_',\n    value: function addSeekableRange_(start, end) {\n      var error = undefined;\n\n      if (this.duration !== Infinity) {\n        error = new Error('MediaSource.addSeekableRange() can only be invoked ' + 'when the duration is Infinity');\n        error.name = 'InvalidStateError';\n        error.code = 11;\n        throw error;\n      }\n\n      if (end > this.nativeMediaSource_.duration || isNaN(this.nativeMediaSource_.duration)) {\n        this.nativeMediaSource_.duration = end;\n      }\n    }\n\n    /**\n     * Add a source buffer to the media source.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/addSourceBuffer\n     * @param {String} type the content-type of the content\n     * @return {Object} the created source buffer\n     */\n  }, {\n    key: 'addSourceBuffer',\n    value: function addSourceBuffer(type) {\n      var buffer = undefined;\n      var parsedType = (0, _codecUtils.parseContentType)(type);\n\n      // Create a VirtualSourceBuffer to transmux MPEG-2 transport\n      // stream segments into fragmented MP4s\n      if (/^(video|audio)\\/mp2t$/i.test(parsedType.type)) {\n        var codecs = [];\n\n        if (parsedType.parameters && parsedType.parameters.codecs) {\n          codecs = parsedType.parameters.codecs.split(',');\n          codecs = (0, _codecUtils.translateLegacyCodecs)(codecs);\n          codecs = codecs.filter(function (codec) {\n            return (0, _codecUtils.isAudioCodec)(codec) || (0, _codecUtils.isVideoCodec)(codec);\n          });\n        }\n\n        if (codecs.length === 0) {\n          codecs = ['avc1.4d400d', 'mp4a.40.2'];\n        }\n\n        buffer = new _virtualSourceBuffer2['default'](this, codecs);\n\n        if (this.sourceBuffers.length !== 0) {\n          // If another VirtualSourceBuffer already exists, then we are creating a\n          // SourceBuffer for an alternate audio track and therefore we know that\n          // the source has both an audio and video track.\n          // That means we should trigger the manual creation of the real\n          // SourceBuffers instead of waiting for the transmuxer to return data\n          this.sourceBuffers[0].createRealSourceBuffers_();\n          buffer.createRealSourceBuffers_();\n\n          // Automatically disable the audio on the first source buffer if\n          // a second source buffer is ever created\n          this.sourceBuffers[0].audioDisabled_ = true;\n        }\n      } else {\n        // delegate to the native implementation\n        buffer = this.nativeMediaSource_.addSourceBuffer(type);\n      }\n\n      this.sourceBuffers.push(buffer);\n      return buffer;\n    }\n  }]);\n\n  return HtmlMediaSource;\n})(_videoJs2['default'].EventTarget);\n\nexports['default'] = HtmlMediaSource;\nmodule.exports = exports['default'];\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./add-text-track-data\":64,\"./codec-utils\":65,\"./virtual-source-buffer\":75,\"global/document\":31,\"global/window\":32}],72:[function(require,module,exports){\n/**\n * @file remove-cues-from-track.js\n */\n\n/**\n * Remove cues from a track on video.js.\n *\n * @param {Double} start start of where we should remove the cue\n * @param {Double} end end of where the we should remove the cue\n * @param {Object} track the text track to remove the cues from\n * @private\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar removeCuesFromTrack = function removeCuesFromTrack(start, end, track) {\n  var i = undefined;\n  var cue = undefined;\n\n  if (!track) {\n    return;\n  }\n\n  if (!track.cues) {\n    return;\n  }\n\n  i = track.cues.length;\n\n  while (i--) {\n    cue = track.cues[i];\n\n    // Remove any overlapping cue\n    if (cue.startTime <= end && cue.endTime >= start) {\n      track.removeCue(cue);\n    }\n  }\n};\n\nexports[\"default\"] = removeCuesFromTrack;\nmodule.exports = exports[\"default\"];\n},{}],73:[function(require,module,exports){\n/**\n * @file transmuxer-worker.js\n */\n\n/**\n * videojs-contrib-media-sources\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Handles communication between the browser-world and the mux.js\n * transmuxer running inside of a WebWorker by exposing a simple\n * message-based interface to a Transmuxer object.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _muxJsLibMp4 = require('mux.js/lib/mp4');\n\nvar _muxJsLibMp42 = _interopRequireDefault(_muxJsLibMp4);\n\n/**\n * Re-emits transmuxer events by converting them into messages to the\n * world outside the worker.\n *\n * @param {Object} transmuxer the transmuxer to wire events on\n * @private\n */\nvar wireTransmuxerEvents = function wireTransmuxerEvents(transmuxer) {\n  transmuxer.on('data', function (segment) {\n    // transfer ownership of the underlying ArrayBuffer\n    // instead of doing a copy to save memory\n    // ArrayBuffers are transferable but generic TypedArrays are not\n    // @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers#Passing_data_by_transferring_ownership_(transferable_objects)\n    var initArray = segment.initSegment;\n\n    segment.initSegment = {\n      data: initArray.buffer,\n      byteOffset: initArray.byteOffset,\n      byteLength: initArray.byteLength\n    };\n\n    var typedArray = segment.data;\n\n    segment.data = typedArray.buffer;\n    _globalWindow2['default'].postMessage({\n      action: 'data',\n      segment: segment,\n      byteOffset: typedArray.byteOffset,\n      byteLength: typedArray.byteLength\n    }, [segment.data]);\n  });\n\n  if (transmuxer.captionStream) {\n    transmuxer.captionStream.on('data', function (caption) {\n      _globalWindow2['default'].postMessage({\n        action: 'caption',\n        data: caption\n      });\n    });\n  }\n\n  transmuxer.on('done', function (data) {\n    _globalWindow2['default'].postMessage({ action: 'done' });\n  });\n\n  transmuxer.on('gopInfo', function (gopInfo) {\n    _globalWindow2['default'].postMessage({\n      action: 'gopInfo',\n      gopInfo: gopInfo\n    });\n  });\n};\n\n/**\n * All incoming messages route through this hash. If no function exists\n * to handle an incoming message, then we ignore the message.\n *\n * @class MessageHandlers\n * @param {Object} options the options to initialize with\n */\n\nvar MessageHandlers = (function () {\n  function MessageHandlers(options) {\n    _classCallCheck(this, MessageHandlers);\n\n    this.options = options || {};\n    this.init();\n  }\n\n  /**\n   * Our web wroker interface so that things can talk to mux.js\n   * that will be running in a web worker. the scope is passed to this by\n   * webworkify.\n   *\n   * @param {Object} self the scope for the web worker\n   */\n\n  /**\n   * initialize our web worker and wire all the events.\n   */\n\n  _createClass(MessageHandlers, [{\n    key: 'init',\n    value: function init() {\n      if (this.transmuxer) {\n        this.transmuxer.dispose();\n      }\n      this.transmuxer = new _muxJsLibMp42['default'].Transmuxer(this.options);\n      wireTransmuxerEvents(this.transmuxer);\n    }\n\n    /**\n     * Adds data (a ts segment) to the start of the transmuxer pipeline for\n     * processing.\n     *\n     * @param {ArrayBuffer} data data to push into the muxer\n     */\n  }, {\n    key: 'push',\n    value: function push(data) {\n      // Cast array buffer to correct type for transmuxer\n      var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\n\n      this.transmuxer.push(segment);\n    }\n\n    /**\n     * Recreate the transmuxer so that the next segment added via `push`\n     * start with a fresh transmuxer.\n     */\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.init();\n    }\n\n    /**\n     * Set the value that will be used as the `baseMediaDecodeTime` time for the\n     * next segment pushed in. Subsequent segments will have their `baseMediaDecodeTime`\n     * set relative to the first based on the PTS values.\n     *\n     * @param {Object} data used to set the timestamp offset in the muxer\n     */\n  }, {\n    key: 'setTimestampOffset',\n    value: function setTimestampOffset(data) {\n      var timestampOffset = data.timestampOffset || 0;\n\n      this.transmuxer.setBaseMediaDecodeTime(Math.round(timestampOffset * 90000));\n    }\n  }, {\n    key: 'setAudioAppendStart',\n    value: function setAudioAppendStart(data) {\n      this.transmuxer.setAudioAppendStart(Math.ceil(data.appendStart * 90000));\n    }\n\n    /**\n     * Forces the pipeline to finish processing the last segment and emit it's\n     * results.\n     *\n     * @param {Object} data event data, not really used\n     */\n  }, {\n    key: 'flush',\n    value: function flush(data) {\n      this.transmuxer.flush();\n    }\n  }, {\n    key: 'resetCaptions',\n    value: function resetCaptions() {\n      this.transmuxer.resetCaptions();\n    }\n  }, {\n    key: 'alignGopsWith',\n    value: function alignGopsWith(data) {\n      this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());\n    }\n  }]);\n\n  return MessageHandlers;\n})();\n\nvar TransmuxerWorker = function TransmuxerWorker(self) {\n  self.onmessage = function (event) {\n    if (event.data.action === 'init' && event.data.options) {\n      this.messageHandlers = new MessageHandlers(event.data.options);\n      return;\n    }\n\n    if (!this.messageHandlers) {\n      this.messageHandlers = new MessageHandlers();\n    }\n\n    if (event.data && event.data.action && event.data.action !== 'init') {\n      if (this.messageHandlers[event.data.action]) {\n        this.messageHandlers[event.data.action](event.data);\n      }\n    }\n  };\n};\n\nexports['default'] = function (self) {\n  return new TransmuxerWorker(self);\n};\n\nmodule.exports = exports['default'];\n},{\"global/window\":32,\"mux.js/lib/mp4\":55}],74:[function(require,module,exports){\n(function (global){\n/**\n * @file videojs-contrib-media-sources.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _flashMediaSource = require('./flash-media-source');\n\nvar _flashMediaSource2 = _interopRequireDefault(_flashMediaSource);\n\nvar _htmlMediaSource = require('./html-media-source');\n\nvar _htmlMediaSource2 = _interopRequireDefault(_htmlMediaSource);\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar urlCount = 0;\n\n// ------------\n// Media Source\n// ------------\n\nvar defaults = {\n  // how to determine the MediaSource implementation to use. There\n  // are three available modes:\n  // - auto: use native MediaSources where available and Flash\n  //   everywhere else\n  // - html5: always use native MediaSources\n  // - flash: always use the Flash MediaSource polyfill\n  mode: 'auto'\n};\n\n// store references to the media sources so they can be connected\n// to a video element (a swf object)\n// TODO: can we store this somewhere local to this module?\n_videoJs2['default'].mediaSources = {};\n\n/**\n * Provide a method for a swf object to notify JS that a\n * media source is now open.\n *\n * @param {String} msObjectURL string referencing the MSE Object URL\n * @param {String} swfId the swf id\n */\nvar open = function open(msObjectURL, swfId) {\n  var mediaSource = _videoJs2['default'].mediaSources[msObjectURL];\n\n  if (mediaSource) {\n    mediaSource.trigger({ type: 'sourceopen', swfId: swfId });\n  } else {\n    throw new Error('Media Source not found (Video.js)');\n  }\n};\n\n/**\n * Check to see if the native MediaSource object exists and supports\n * an MP4 container with both H.264 video and AAC-LC audio.\n *\n * @return {Boolean} if  native media sources are supported\n */\nvar supportsNativeMediaSources = function supportsNativeMediaSources() {\n  return !!_globalWindow2['default'].MediaSource && !!_globalWindow2['default'].MediaSource.isTypeSupported && _globalWindow2['default'].MediaSource.isTypeSupported('video/mp4;codecs=\"avc1.4d400d,mp4a.40.2\"');\n};\n\n/**\n * An emulation of the MediaSource API so that we can support\n * native and non-native functionality such as flash and\n * video/mp2t videos. returns an instance of HtmlMediaSource or\n * FlashMediaSource depending on what is supported and what options\n * are passed in.\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/MediaSource\n * @param {Object} options options to use during setup.\n */\nvar MediaSource = function MediaSource(options) {\n  var settings = _videoJs2['default'].mergeOptions(defaults, options);\n\n  this.MediaSource = {\n    open: open,\n    supportsNativeMediaSources: supportsNativeMediaSources\n  };\n\n  // determine whether HTML MediaSources should be used\n  if (settings.mode === 'html5' || settings.mode === 'auto' && supportsNativeMediaSources()) {\n    return new _htmlMediaSource2['default']();\n  } else if (_videoJs2['default'].getTech('Flash')) {\n    return new _flashMediaSource2['default']();\n  }\n\n  throw new Error('Cannot use Flash or Html5 to create a MediaSource for this video');\n};\n\nexports.MediaSource = MediaSource;\nMediaSource.open = open;\nMediaSource.supportsNativeMediaSources = supportsNativeMediaSources;\n\n/**\n * A wrapper around the native URL for our MSE object\n * implementation, this object is exposed under videojs.URL\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/API/URL/URL\n */\nvar URL = {\n  /**\n   * A wrapper around the native createObjectURL for our objects.\n   * This function maps a native or emulated mediaSource to a blob\n   * url so that it can be loaded into video.js\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\n   * @param {MediaSource} object the object to create a blob url to\n   */\n  createObjectURL: function createObjectURL(object) {\n    var objectUrlPrefix = 'blob:vjs-media-source/';\n    var url = undefined;\n\n    // use the native MediaSource to generate an object URL\n    if (object instanceof _htmlMediaSource2['default']) {\n      url = _globalWindow2['default'].URL.createObjectURL(object.nativeMediaSource_);\n      object.url_ = url;\n      return url;\n    }\n    // if the object isn't an emulated MediaSource, delegate to the\n    // native implementation\n    if (!(object instanceof _flashMediaSource2['default'])) {\n      url = _globalWindow2['default'].URL.createObjectURL(object);\n      object.url_ = url;\n      return url;\n    }\n\n    // build a URL that can be used to map back to the emulated\n    // MediaSource\n    url = objectUrlPrefix + urlCount;\n\n    urlCount++;\n\n    // setup the mapping back to object\n    _videoJs2['default'].mediaSources[url] = object;\n\n    return url;\n  }\n};\n\nexports.URL = URL;\n_videoJs2['default'].MediaSource = MediaSource;\n_videoJs2['default'].URL = URL;\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./flash-media-source\":68,\"./html-media-source\":71,\"global/window\":32}],75:[function(require,module,exports){\n(function (global){\n/**\n * @file virtual-source-buffer.js\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _createTextTracksIfNecessary = require('./create-text-tracks-if-necessary');\n\nvar _createTextTracksIfNecessary2 = _interopRequireDefault(_createTextTracksIfNecessary);\n\nvar _removeCuesFromTrack = require('./remove-cues-from-track');\n\nvar _removeCuesFromTrack2 = _interopRequireDefault(_removeCuesFromTrack);\n\nvar _addTextTrackData = require('./add-text-track-data');\n\nvar _webworkify = require('webworkify');\n\nvar _webworkify2 = _interopRequireDefault(_webworkify);\n\nvar _transmuxerWorker = require('./transmuxer-worker');\n\nvar _transmuxerWorker2 = _interopRequireDefault(_transmuxerWorker);\n\nvar _codecUtils = require('./codec-utils');\n\n// We create a wrapper around the SourceBuffer so that we can manage the\n// state of the `updating` property manually. We have to do this because\n// Firefox changes `updating` to false long before triggering `updateend`\n// events and that was causing strange problems in videojs-contrib-hls\nvar makeWrappedSourceBuffer = function makeWrappedSourceBuffer(mediaSource, mimeType) {\n  var sourceBuffer = mediaSource.addSourceBuffer(mimeType);\n  var wrapper = Object.create(null);\n\n  wrapper.updating = false;\n  wrapper.realBuffer_ = sourceBuffer;\n\n  var _loop = function (key) {\n    if (typeof sourceBuffer[key] === 'function') {\n      wrapper[key] = function () {\n        return sourceBuffer[key].apply(sourceBuffer, arguments);\n      };\n    } else if (typeof wrapper[key] === 'undefined') {\n      Object.defineProperty(wrapper, key, {\n        get: function get() {\n          return sourceBuffer[key];\n        },\n        set: function set(v) {\n          return sourceBuffer[key] = v;\n        }\n      });\n    }\n  };\n\n  for (var key in sourceBuffer) {\n    _loop(key);\n  }\n\n  return wrapper;\n};\n\n/**\n * Returns a list of gops in the buffer that have a pts value of 3 seconds or more in\n * front of current time.\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Player} player\n *        The player instance\n * @param {Double} mapping\n *        Offset to map display time to stream presentation time\n * @return {Array}\n *         List of gops considered safe to append over\n */\nvar gopsSafeToAlignWith = function gopsSafeToAlignWith(buffer, player, mapping) {\n  if (!player || !buffer.length) {\n    return [];\n  }\n\n  // pts value for current time + 3 seconds to give a bit more wiggle room\n  var currentTimePts = Math.ceil((player.currentTime() - mapping + 3) * 90000);\n\n  var i = undefined;\n\n  for (i = 0; i < buffer.length; i++) {\n    if (buffer[i].pts > currentTimePts) {\n      break;\n    }\n  }\n\n  return buffer.slice(i);\n};\n\nexports.gopsSafeToAlignWith = gopsSafeToAlignWith;\n/**\n * Appends gop information (timing and byteLength) received by the transmuxer for the\n * gops appended in the last call to appendBuffer\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Array} gops\n *        List of new gop information\n * @param {boolean} replace\n *        If true, replace the buffer with the new gop information. If false, append the\n *        new gop information to the buffer in the right location of time.\n * @return {Array}\n *         Updated list of gop information\n */\nvar updateGopBuffer = function updateGopBuffer(buffer, gops, replace) {\n  if (!gops.length) {\n    return buffer;\n  }\n\n  if (replace) {\n    // If we are in safe append mode, then completely overwrite the gop buffer\n    // with the most recent appeneded data. This will make sure that when appending\n    // future segments, we only try to align with gops that are both ahead of current\n    // time and in the last segment appended.\n    return gops.slice();\n  }\n\n  var start = gops[0].pts;\n\n  var i = 0;\n\n  for (i; i < buffer.length; i++) {\n    if (buffer[i].pts >= start) {\n      break;\n    }\n  }\n\n  return buffer.slice(0, i).concat(gops);\n};\n\nexports.updateGopBuffer = updateGopBuffer;\n/**\n * Removes gop information in buffer that overlaps with provided start and end\n *\n * @param {Array} buffer\n *        The current buffer of gop information\n * @param {Double} start\n *        position to start the remove at\n * @param {Double} end\n *        position to end the remove at\n * @param {Double} mapping\n *        Offset to map display time to stream presentation time\n */\nvar removeGopBuffer = function removeGopBuffer(buffer, start, end, mapping) {\n  var startPts = Math.ceil((start - mapping) * 90000);\n  var endPts = Math.ceil((end - mapping) * 90000);\n  var updatedBuffer = buffer.slice();\n\n  var i = buffer.length;\n\n  while (i--) {\n    if (buffer[i].pts <= endPts) {\n      break;\n    }\n  }\n\n  if (i === -1) {\n    // no removal because end of remove range is before start of buffer\n    return updatedBuffer;\n  }\n\n  var j = i + 1;\n\n  while (j--) {\n    if (buffer[j].pts <= startPts) {\n      break;\n    }\n  }\n\n  // clamp remove range start to 0 index\n  j = Math.max(j, 0);\n\n  updatedBuffer.splice(j, i - j + 1);\n\n  return updatedBuffer;\n};\n\nexports.removeGopBuffer = removeGopBuffer;\n/**\n * VirtualSourceBuffers exist so that we can transmux non native formats\n * into a native format, but keep the same api as a native source buffer.\n * It creates a transmuxer, that works in its own thread (a web worker) and\n * that transmuxer muxes the data into a native format. VirtualSourceBuffer will\n * then send all of that data to the naive sourcebuffer so that it is\n * indestinguishable from a natively supported format.\n *\n * @param {HtmlMediaSource} mediaSource the parent mediaSource\n * @param {Array} codecs array of codecs that we will be dealing with\n * @class VirtualSourceBuffer\n * @extends video.js.EventTarget\n */\n\nvar VirtualSourceBuffer = (function (_videojs$EventTarget) {\n  _inherits(VirtualSourceBuffer, _videojs$EventTarget);\n\n  function VirtualSourceBuffer(mediaSource, codecs) {\n    var _this = this;\n\n    _classCallCheck(this, VirtualSourceBuffer);\n\n    _get(Object.getPrototypeOf(VirtualSourceBuffer.prototype), 'constructor', this).call(this, _videoJs2['default'].EventTarget);\n    this.timestampOffset_ = 0;\n    this.pendingBuffers_ = [];\n    this.bufferUpdating_ = false;\n\n    this.mediaSource_ = mediaSource;\n    this.codecs_ = codecs;\n    this.audioCodec_ = null;\n    this.videoCodec_ = null;\n    this.audioDisabled_ = false;\n    this.appendAudioInitSegment_ = true;\n    this.gopBuffer_ = [];\n    this.timeMapping_ = 0;\n    this.safeAppend_ = _videoJs2['default'].browser.IE_VERSION >= 11;\n\n    var options = {\n      remux: false,\n      alignGopsAtEnd: this.safeAppend_\n    };\n\n    this.codecs_.forEach(function (codec) {\n      if ((0, _codecUtils.isAudioCodec)(codec)) {\n        _this.audioCodec_ = codec;\n      } else if ((0, _codecUtils.isVideoCodec)(codec)) {\n        _this.videoCodec_ = codec;\n      }\n    });\n\n    // append muxed segments to their respective native buffers as\n    // soon as they are available\n    this.transmuxer_ = (0, _webworkify2['default'])(_transmuxerWorker2['default']);\n    this.transmuxer_.postMessage({ action: 'init', options: options });\n\n    this.transmuxer_.onmessage = function (event) {\n      if (event.data.action === 'data') {\n        return _this.data_(event);\n      }\n\n      if (event.data.action === 'done') {\n        return _this.done_(event);\n      }\n\n      if (event.data.action === 'gopInfo') {\n        return _this.appendGopInfo_(event);\n      }\n    };\n\n    // this timestampOffset is a property with the side-effect of resetting\n    // baseMediaDecodeTime in the transmuxer on the setter\n    Object.defineProperty(this, 'timestampOffset', {\n      get: function get() {\n        return this.timestampOffset_;\n      },\n      set: function set(val) {\n        if (typeof val === 'number' && val >= 0) {\n          this.timestampOffset_ = val;\n          this.appendAudioInitSegment_ = true;\n\n          // reset gop buffer on timestampoffset as this signals a change in timeline\n          this.gopBuffer_.length = 0;\n          this.timeMapping_ = 0;\n\n          // We have to tell the transmuxer to set the baseMediaDecodeTime to\n          // the desired timestampOffset for the next segment\n          this.transmuxer_.postMessage({\n            action: 'setTimestampOffset',\n            timestampOffset: val\n          });\n        }\n      }\n    });\n\n    // setting the append window affects both source buffers\n    Object.defineProperty(this, 'appendWindowStart', {\n      get: function get() {\n        return (this.videoBuffer_ || this.audioBuffer_).appendWindowStart;\n      },\n      set: function set(start) {\n        if (this.videoBuffer_) {\n          this.videoBuffer_.appendWindowStart = start;\n        }\n        if (this.audioBuffer_) {\n          this.audioBuffer_.appendWindowStart = start;\n        }\n      }\n    });\n\n    // this buffer is \"updating\" if either of its native buffers are\n    Object.defineProperty(this, 'updating', {\n      get: function get() {\n        return !!(this.bufferUpdating_ || !this.audioDisabled_ && this.audioBuffer_ && this.audioBuffer_.updating || this.videoBuffer_ && this.videoBuffer_.updating);\n      }\n    });\n\n    // the buffered property is the intersection of the buffered\n    // ranges of the native source buffers\n    Object.defineProperty(this, 'buffered', {\n      get: function get() {\n        var start = null;\n        var end = null;\n        var arity = 0;\n        var extents = [];\n        var ranges = [];\n\n        // neither buffer has been created yet\n        if (!this.videoBuffer_ && !this.audioBuffer_) {\n          return _videoJs2['default'].createTimeRange();\n        }\n\n        // only one buffer is configured\n        if (!this.videoBuffer_) {\n          return this.audioBuffer_.buffered;\n        }\n        if (!this.audioBuffer_) {\n          return this.videoBuffer_.buffered;\n        }\n\n        // both buffers are configured\n        if (this.audioDisabled_) {\n          return this.videoBuffer_.buffered;\n        }\n\n        // both buffers are empty\n        if (this.videoBuffer_.buffered.length === 0 && this.audioBuffer_.buffered.length === 0) {\n          return _videoJs2['default'].createTimeRange();\n        }\n\n        // Handle the case where we have both buffers and create an\n        // intersection of the two\n        var videoBuffered = this.videoBuffer_.buffered;\n        var audioBuffered = this.audioBuffer_.buffered;\n        var count = videoBuffered.length;\n\n        // A) Gather up all start and end times\n        while (count--) {\n          extents.push({ time: videoBuffered.start(count), type: 'start' });\n          extents.push({ time: videoBuffered.end(count), type: 'end' });\n        }\n        count = audioBuffered.length;\n        while (count--) {\n          extents.push({ time: audioBuffered.start(count), type: 'start' });\n          extents.push({ time: audioBuffered.end(count), type: 'end' });\n        }\n        // B) Sort them by time\n        extents.sort(function (a, b) {\n          return a.time - b.time;\n        });\n\n        // C) Go along one by one incrementing arity for start and decrementing\n        //    arity for ends\n        for (count = 0; count < extents.length; count++) {\n          if (extents[count].type === 'start') {\n            arity++;\n\n            // D) If arity is ever incremented to 2 we are entering an\n            //    overlapping range\n            if (arity === 2) {\n              start = extents[count].time;\n            }\n          } else if (extents[count].type === 'end') {\n            arity--;\n\n            // E) If arity is ever decremented to 1 we leaving an\n            //    overlapping range\n            if (arity === 1) {\n              end = extents[count].time;\n            }\n          }\n\n          // F) Record overlapping ranges\n          if (start !== null && end !== null) {\n            ranges.push([start, end]);\n            start = null;\n            end = null;\n          }\n        }\n\n        return _videoJs2['default'].createTimeRanges(ranges);\n      }\n    });\n  }\n\n  /**\n   * When we get a data event from the transmuxer\n   * we call this function and handle the data that\n   * was sent to us\n   *\n   * @private\n   * @param {Event} event the data event from the transmuxer\n   */\n\n  _createClass(VirtualSourceBuffer, [{\n    key: 'data_',\n    value: function data_(event) {\n      var segment = event.data.segment;\n\n      // Cast ArrayBuffer to TypedArray\n      segment.data = new Uint8Array(segment.data, event.data.byteOffset, event.data.byteLength);\n\n      segment.initSegment = new Uint8Array(segment.initSegment.data, segment.initSegment.byteOffset, segment.initSegment.byteLength);\n\n      (0, _createTextTracksIfNecessary2['default'])(this, this.mediaSource_, segment);\n\n      // Add the segments to the pendingBuffers array\n      this.pendingBuffers_.push(segment);\n      return;\n    }\n\n    /**\n     * When we get a done event from the transmuxer\n     * we call this function and we process all\n     * of the pending data that we have been saving in the\n     * data_ function\n     *\n     * @private\n     * @param {Event} event the done event from the transmuxer\n     */\n  }, {\n    key: 'done_',\n    value: function done_(event) {\n      // Don't process and append data if the mediaSource is closed\n      if (this.mediaSource_.readyState === 'closed') {\n        this.pendingBuffers_.length = 0;\n        return;\n      }\n\n      // All buffers should have been flushed from the muxer\n      // start processing anything we have received\n      this.processPendingSegments_();\n      return;\n    }\n\n    /**\n     * Create our internal native audio/video source buffers and add\n     * event handlers to them with the following conditions:\n     * 1. they do not already exist on the mediaSource\n     * 2. this VSB has a codec for them\n     *\n     * @private\n     */\n  }, {\n    key: 'createRealSourceBuffers_',\n    value: function createRealSourceBuffers_() {\n      var _this2 = this;\n\n      var types = ['audio', 'video'];\n\n      types.forEach(function (type) {\n        // Don't create a SourceBuffer of this type if we don't have a\n        // codec for it\n        if (!_this2[type + 'Codec_']) {\n          return;\n        }\n\n        // Do nothing if a SourceBuffer of this type already exists\n        if (_this2[type + 'Buffer_']) {\n          return;\n        }\n\n        var buffer = null;\n\n        // If the mediasource already has a SourceBuffer for the codec\n        // use that\n        if (_this2.mediaSource_[type + 'Buffer_']) {\n          buffer = _this2.mediaSource_[type + 'Buffer_'];\n          // In multiple audio track cases, the audio source buffer is disabled\n          // on the main VirtualSourceBuffer by the HTMLMediaSource much earlier\n          // than createRealSourceBuffers_ is called to create the second\n          // VirtualSourceBuffer because that happens as a side-effect of\n          // videojs-contrib-hls starting the audioSegmentLoader. As a result,\n          // the audioBuffer is essentially \"ownerless\" and no one will toggle\n          // the `updating` state back to false once the `updateend` event is received\n          //\n          // Setting `updating` to false manually will work around this\n          // situation and allow work to continue\n          buffer.updating = false;\n        } else {\n          var codecProperty = type + 'Codec_';\n          var mimeType = type + '/mp4;codecs=\"' + _this2[codecProperty] + '\"';\n\n          buffer = makeWrappedSourceBuffer(_this2.mediaSource_.nativeMediaSource_, mimeType);\n\n          _this2.mediaSource_[type + 'Buffer_'] = buffer;\n        }\n\n        _this2[type + 'Buffer_'] = buffer;\n\n        // Wire up the events to the SourceBuffer\n        ['update', 'updatestart', 'updateend'].forEach(function (event) {\n          buffer.addEventListener(event, function () {\n            // if audio is disabled\n            if (type === 'audio' && _this2.audioDisabled_) {\n              return;\n            }\n\n            if (event === 'updateend') {\n              _this2[type + 'Buffer_'].updating = false;\n            }\n\n            var shouldTrigger = types.every(function (t) {\n              // skip checking audio's updating status if audio\n              // is not enabled\n              if (t === 'audio' && _this2.audioDisabled_) {\n                return true;\n              }\n              // if the other type if updating we don't trigger\n              if (type !== t && _this2[t + 'Buffer_'] && _this2[t + 'Buffer_'].updating) {\n                return false;\n              }\n              return true;\n            });\n\n            if (shouldTrigger) {\n              return _this2.trigger(event);\n            }\n          });\n        });\n      });\n    }\n\n    /**\n     * Emulate the native mediasource function, but our function will\n     * send all of the proposed segments to the transmuxer so that we\n     * can transmux them before we append them to our internal\n     * native source buffers in the correct format.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/appendBuffer\n     * @param {Uint8Array} segment the segment to append to the buffer\n     */\n  }, {\n    key: 'appendBuffer',\n    value: function appendBuffer(segment) {\n      // Start the internal \"updating\" state\n      this.bufferUpdating_ = true;\n\n      if (this.audioBuffer_ && this.audioBuffer_.buffered.length) {\n        var audioBuffered = this.audioBuffer_.buffered;\n\n        this.transmuxer_.postMessage({\n          action: 'setAudioAppendStart',\n          appendStart: audioBuffered.end(audioBuffered.length - 1)\n        });\n      }\n\n      if (this.videoBuffer_) {\n        this.transmuxer_.postMessage({\n          action: 'alignGopsWith',\n          gopsToAlignWith: gopsSafeToAlignWith(this.gopBuffer_, this.mediaSource_.player_, this.timeMapping_)\n        });\n      }\n\n      this.transmuxer_.postMessage({\n        action: 'push',\n        // Send the typed-array of data as an ArrayBuffer so that\n        // it can be sent as a \"Transferable\" and avoid the costly\n        // memory copy\n        data: segment.buffer,\n\n        // To recreate the original typed-array, we need information\n        // about what portion of the ArrayBuffer it was a view into\n        byteOffset: segment.byteOffset,\n        byteLength: segment.byteLength\n      }, [segment.buffer]);\n      this.transmuxer_.postMessage({ action: 'flush' });\n    }\n\n    /**\n     * Appends gop information (timing and byteLength) received by the transmuxer for the\n     * gops appended in the last call to appendBuffer\n     *\n     * @param {Event} event\n     *        The gopInfo event from the transmuxer\n     * @param {Array} event.data.gopInfo\n     *        List of gop info to append\n     */\n  }, {\n    key: 'appendGopInfo_',\n    value: function appendGopInfo_(event) {\n      this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, event.data.gopInfo, this.safeAppend_);\n    }\n\n    /**\n     * Emulate the native mediasource function and remove parts\n     * of the buffer from any of our internal buffers that exist\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/remove\n     * @param {Double} start position to start the remove at\n     * @param {Double} end position to end the remove at\n     */\n  }, {\n    key: 'remove',\n    value: function remove(start, end) {\n      if (this.videoBuffer_) {\n        this.videoBuffer_.updating = true;\n        this.videoBuffer_.remove(start, end);\n        this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start, end, this.timeMapping_);\n      }\n      if (!this.audioDisabled_ && this.audioBuffer_) {\n        this.audioBuffer_.updating = true;\n        this.audioBuffer_.remove(start, end);\n      }\n\n      // Remove Metadata Cues (id3)\n      (0, _removeCuesFromTrack2['default'])(start, end, this.metadataTrack_);\n\n      // Remove Any Captions\n      if (this.inbandTextTracks_) {\n        for (var track in this.inbandTextTracks_) {\n          (0, _removeCuesFromTrack2['default'])(start, end, this.inbandTextTracks_[track]);\n        }\n      }\n    }\n\n    /**\n     * Process any segments that the muxer has output\n     * Concatenate segments together based on type and append them into\n     * their respective sourceBuffers\n     *\n     * @private\n     */\n  }, {\n    key: 'processPendingSegments_',\n    value: function processPendingSegments_() {\n      var sortedSegments = {\n        video: {\n          segments: [],\n          bytes: 0\n        },\n        audio: {\n          segments: [],\n          bytes: 0\n        },\n        captions: [],\n        metadata: []\n      };\n\n      // Sort segments into separate video/audio arrays and\n      // keep track of their total byte lengths\n      sortedSegments = this.pendingBuffers_.reduce(function (segmentObj, segment) {\n        var type = segment.type;\n        var data = segment.data;\n        var initSegment = segment.initSegment;\n\n        segmentObj[type].segments.push(data);\n        segmentObj[type].bytes += data.byteLength;\n\n        segmentObj[type].initSegment = initSegment;\n\n        // Gather any captions into a single array\n        if (segment.captions) {\n          segmentObj.captions = segmentObj.captions.concat(segment.captions);\n        }\n\n        if (segment.info) {\n          segmentObj[type].info = segment.info;\n        }\n\n        // Gather any metadata into a single array\n        if (segment.metadata) {\n          segmentObj.metadata = segmentObj.metadata.concat(segment.metadata);\n        }\n\n        return segmentObj;\n      }, sortedSegments);\n\n      // Create the real source buffers if they don't exist by now since we\n      // finally are sure what tracks are contained in the source\n      if (!this.videoBuffer_ && !this.audioBuffer_) {\n        // Remove any codecs that may have been specified by default but\n        // are no longer applicable now\n        if (sortedSegments.video.bytes === 0) {\n          this.videoCodec_ = null;\n        }\n        if (sortedSegments.audio.bytes === 0) {\n          this.audioCodec_ = null;\n        }\n\n        this.createRealSourceBuffers_();\n      }\n\n      if (sortedSegments.audio.info) {\n        this.mediaSource_.trigger({ type: 'audioinfo', info: sortedSegments.audio.info });\n      }\n      if (sortedSegments.video.info) {\n        this.mediaSource_.trigger({ type: 'videoinfo', info: sortedSegments.video.info });\n      }\n\n      if (this.appendAudioInitSegment_) {\n        if (!this.audioDisabled_ && this.audioBuffer_) {\n          sortedSegments.audio.segments.unshift(sortedSegments.audio.initSegment);\n          sortedSegments.audio.bytes += sortedSegments.audio.initSegment.byteLength;\n        }\n        this.appendAudioInitSegment_ = false;\n      }\n\n      var triggerUpdateend = false;\n\n      // Merge multiple video and audio segments into one and append\n      if (this.videoBuffer_ && sortedSegments.video.bytes) {\n        sortedSegments.video.segments.unshift(sortedSegments.video.initSegment);\n        sortedSegments.video.bytes += sortedSegments.video.initSegment.byteLength;\n        this.concatAndAppendSegments_(sortedSegments.video, this.videoBuffer_);\n        // TODO: are video tracks the only ones with text tracks?\n        (0, _addTextTrackData.addTextTrackData)(this, sortedSegments.captions, sortedSegments.metadata);\n      } else if (this.videoBuffer_ && (this.audioDisabled_ || !this.audioBuffer_)) {\n        // The transmuxer did not return any bytes of video, meaning it was all trimmed\n        // for gop alignment. Since we have a video buffer and audio is disabled, updateend\n        // will never be triggered by this source buffer, which will cause contrib-hls\n        // to be stuck forever waiting for updateend. If audio is not disabled, updateend\n        // will be triggered by the audio buffer, which will be sent upwards since the video\n        // buffer will not be in an updating state.\n        triggerUpdateend = true;\n      }\n\n      if (!this.audioDisabled_ && this.audioBuffer_) {\n        this.concatAndAppendSegments_(sortedSegments.audio, this.audioBuffer_);\n      }\n\n      this.pendingBuffers_.length = 0;\n\n      if (triggerUpdateend) {\n        this.trigger('updateend');\n      }\n\n      // We are no longer in the internal \"updating\" state\n      this.bufferUpdating_ = false;\n    }\n\n    /**\n     * Combine all segments into a single Uint8Array and then append them\n     * to the destination buffer\n     *\n     * @param {Object} segmentObj\n     * @param {SourceBuffer} destinationBuffer native source buffer to append data to\n     * @private\n     */\n  }, {\n    key: 'concatAndAppendSegments_',\n    value: function concatAndAppendSegments_(segmentObj, destinationBuffer) {\n      var offset = 0;\n      var tempBuffer = undefined;\n\n      if (segmentObj.bytes) {\n        tempBuffer = new Uint8Array(segmentObj.bytes);\n\n        // Combine the individual segments into one large typed-array\n        segmentObj.segments.forEach(function (segment) {\n          tempBuffer.set(segment, offset);\n          offset += segment.byteLength;\n        });\n\n        try {\n          destinationBuffer.updating = true;\n          destinationBuffer.appendBuffer(tempBuffer);\n        } catch (error) {\n          if (this.mediaSource_.player_) {\n            this.mediaSource_.player_.error({\n              code: -3,\n              type: 'APPEND_BUFFER_ERR',\n              message: error.message,\n              originalError: error\n            });\n          }\n        }\n      }\n    }\n\n    /**\n     * Emulate the native mediasource function. abort any soureBuffer\n     * actions and throw out any un-appended data.\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer/abort\n     */\n  }, {\n    key: 'abort',\n    value: function abort() {\n      if (this.videoBuffer_) {\n        this.videoBuffer_.abort();\n      }\n      if (!this.audioDisabled_ && this.audioBuffer_) {\n        this.audioBuffer_.abort();\n      }\n      if (this.transmuxer_) {\n        this.transmuxer_.postMessage({ action: 'reset' });\n      }\n      this.pendingBuffers_.length = 0;\n      this.bufferUpdating_ = false;\n    }\n  }]);\n\n  return VirtualSourceBuffer;\n})(_videoJs2['default'].EventTarget);\n\nexports['default'] = VirtualSourceBuffer;\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./add-text-track-data\":64,\"./codec-utils\":65,\"./create-text-tracks-if-necessary\":66,\"./remove-cues-from-track\":72,\"./transmuxer-worker\":73,\"webworkify\":76}],76:[function(require,module,exports){\nvar bundleFn = arguments[3];\nvar sources = arguments[4];\nvar cache = arguments[5];\n\nvar stringify = JSON.stringify;\n\nmodule.exports = function (fn) {\n    var keys = [];\n    var wkey;\n    var cacheKeys = Object.keys(cache);\n    \n    for (var i = 0, l = cacheKeys.length; i < l; i++) {\n        var key = cacheKeys[i];\n        if (cache[key].exports === fn) {\n            wkey = key;\n            break;\n        }\n    }\n    \n    if (!wkey) {\n        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n        var wcache = {};\n        for (var i = 0, l = cacheKeys.length; i < l; i++) {\n            var key = cacheKeys[i];\n            wcache[key] = key;\n        }\n        sources[wkey] = [\n            Function(['require','module','exports'], '(' + fn + ')(self)'),\n            wcache\n        ];\n    }\n    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n    \n    var scache = {}; scache[wkey] = wkey;\n    sources[skey] = [\n        Function(['require'],'require(' + stringify(wkey) + ')(self)'),\n        scache\n    ];\n    \n    var src = '(' + bundleFn + ')({'\n        + Object.keys(sources).map(function (key) {\n            return stringify(key) + ':['\n                + sources[key][0]\n                + ',' + stringify(sources[key][1]) + ']'\n            ;\n        }).join(',')\n        + '},{},[' + stringify(skey) + '])'\n    ;\n    \n    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n    \n    return new Worker(URL.createObjectURL(\n        new Blob([src], { type: 'text/javascript' })\n    ));\n};\n\n},{}],77:[function(require,module,exports){\n(function (global){\n/**\n * @file videojs-contrib-hls.js\n *\n * The main file for the HLS project.\n * License: https://github.com/videojs/videojs-contrib-hls/blob/master/LICENSE\n */\n'use strict';\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x4, _x5, _x6) { var _again = true; _function: while (_again) { var object = _x4, property = _x5, receiver = _x6; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x4 = parent; _x5 = property; _x6 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _globalDocument = require('global/document');\n\nvar _globalDocument2 = _interopRequireDefault(_globalDocument);\n\nvar _playlistLoader = require('./playlist-loader');\n\nvar _playlistLoader2 = _interopRequireDefault(_playlistLoader);\n\nvar _playlist = require('./playlist');\n\nvar _playlist2 = _interopRequireDefault(_playlist);\n\nvar _xhr = require('./xhr');\n\nvar _xhr2 = _interopRequireDefault(_xhr);\n\nvar _aesDecrypter = require('aes-decrypter');\n\nvar _binUtils = require('./bin-utils');\n\nvar _binUtils2 = _interopRequireDefault(_binUtils);\n\nvar _videojsContribMediaSources = require('videojs-contrib-media-sources');\n\nvar _m3u8Parser = require('m3u8-parser');\n\nvar _m3u8Parser2 = _interopRequireDefault(_m3u8Parser);\n\nvar _videoJs = (typeof window !== \"undefined\" ? window['videojs'] : typeof global !== \"undefined\" ? global['videojs'] : null);\n\nvar _videoJs2 = _interopRequireDefault(_videoJs);\n\nvar _masterPlaylistController = require('./master-playlist-controller');\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _renditionMixin = require('./rendition-mixin');\n\nvar _renditionMixin2 = _interopRequireDefault(_renditionMixin);\n\nvar _globalWindow = require('global/window');\n\nvar _globalWindow2 = _interopRequireDefault(_globalWindow);\n\nvar _playbackWatcher = require('./playback-watcher');\n\nvar _playbackWatcher2 = _interopRequireDefault(_playbackWatcher);\n\nvar _reloadSourceOnError = require('./reload-source-on-error');\n\nvar _reloadSourceOnError2 = _interopRequireDefault(_reloadSourceOnError);\n\nvar _playlistSelectorsJs = require('./playlist-selectors.js');\n\nvar Hls = {\n  PlaylistLoader: _playlistLoader2['default'],\n  Playlist: _playlist2['default'],\n  Decrypter: _aesDecrypter.Decrypter,\n  AsyncStream: _aesDecrypter.AsyncStream,\n  decrypt: _aesDecrypter.decrypt,\n  utils: _binUtils2['default'],\n\n  STANDARD_PLAYLIST_SELECTOR: _playlistSelectorsJs.lastBandwidthSelector,\n  INITIAL_PLAYLIST_SELECTOR: _playlistSelectorsJs.lowestBitrateCompatibleVariantSelector,\n  comparePlaylistBandwidth: _playlistSelectorsJs.comparePlaylistBandwidth,\n  comparePlaylistResolution: _playlistSelectorsJs.comparePlaylistResolution,\n\n  xhr: (0, _xhr2['default'])()\n};\n\n// 0.5 MB/s\nvar INITIAL_BANDWIDTH = 4194304;\n\n// Define getter/setters for config properites\n['GOAL_BUFFER_LENGTH', 'MAX_GOAL_BUFFER_LENGTH', 'GOAL_BUFFER_LENGTH_RATE', 'BUFFER_LOW_WATER_LINE', 'MAX_BUFFER_LOW_WATER_LINE', 'BUFFER_LOW_WATER_LINE_RATE', 'BANDWIDTH_VARIANCE'].forEach(function (prop) {\n  Object.defineProperty(Hls, prop, {\n    get: function get() {\n      _videoJs2['default'].log.warn('using Hls.' + prop + ' is UNSAFE be sure you know what you are doing');\n      return _config2['default'][prop];\n    },\n    set: function set(value) {\n      _videoJs2['default'].log.warn('using Hls.' + prop + ' is UNSAFE be sure you know what you are doing');\n\n      if (typeof value !== 'number' || value < 0) {\n        _videoJs2['default'].log.warn('value of Hls.' + prop + ' must be greater than or equal to 0');\n        return;\n      }\n\n      _config2['default'][prop] = value;\n    }\n  });\n});\n\n/**\n * Updates the selectedIndex of the QualityLevelList when a mediachange happens in hls.\n *\n * @param {QualityLevelList} qualityLevels The QualityLevelList to update.\n * @param {PlaylistLoader} playlistLoader PlaylistLoader containing the new media info.\n * @function handleHlsMediaChange\n */\nvar handleHlsMediaChange = function handleHlsMediaChange(qualityLevels, playlistLoader) {\n  var newPlaylist = playlistLoader.media();\n  var selectedIndex = -1;\n\n  for (var i = 0; i < qualityLevels.length; i++) {\n    if (qualityLevels[i].id === newPlaylist.uri) {\n      selectedIndex = i;\n      break;\n    }\n  }\n\n  qualityLevels.selectedIndex_ = selectedIndex;\n  qualityLevels.trigger({\n    selectedIndex: selectedIndex,\n    type: 'change'\n  });\n};\n\n/**\n * Adds quality levels to list once playlist metadata is available\n *\n * @param {QualityLevelList} qualityLevels The QualityLevelList to attach events to.\n * @param {Object} hls Hls object to listen to for media events.\n * @function handleHlsLoadedMetadata\n */\nvar handleHlsLoadedMetadata = function handleHlsLoadedMetadata(qualityLevels, hls) {\n  hls.representations().forEach(function (rep) {\n    qualityLevels.addQualityLevel(rep);\n  });\n  handleHlsMediaChange(qualityLevels, hls.playlists);\n};\n\n// HLS is a source handler, not a tech. Make sure attempts to use it\n// as one do not cause exceptions.\nHls.canPlaySource = function () {\n  return _videoJs2['default'].log.warn('HLS is no longer a tech. Please remove it from ' + 'your player\\'s techOrder.');\n};\n\n/**\n * Whether the browser has built-in HLS support.\n */\nHls.supportsNativeHls = (function () {\n  var video = _globalDocument2['default'].createElement('video');\n\n  // native HLS is definitely not supported if HTML5 video isn't\n  if (!_videoJs2['default'].getTech('Html5').isSupported()) {\n    return false;\n  }\n\n  // HLS manifests can go by many mime-types\n  var canPlay = [\n  // Apple santioned\n  'application/vnd.apple.mpegurl',\n  // Apple sanctioned for backwards compatibility\n  'audio/mpegurl',\n  // Very common\n  'audio/x-mpegurl',\n  // Very common\n  'application/x-mpegurl',\n  // Included for completeness\n  'video/x-mpegurl', 'video/mpegurl', 'application/mpegurl'];\n\n  return canPlay.some(function (canItPlay) {\n    return (/maybe|probably/i.test(video.canPlayType(canItPlay))\n    );\n  });\n})();\n\n/**\n * HLS is a source handler, not a tech. Make sure attempts to use it\n * as one do not cause exceptions.\n */\nHls.isSupported = function () {\n  return _videoJs2['default'].log.warn('HLS is no longer a tech. Please remove it from ' + 'your player\\'s techOrder.');\n};\n\nvar Component = _videoJs2['default'].getComponent('Component');\n\n/**\n * The Hls Handler object, where we orchestrate all of the parts\n * of HLS to interact with video.js\n *\n * @class HlsHandler\n * @extends videojs.Component\n * @param {Object} source the soruce object\n * @param {Tech} tech the parent tech object\n * @param {Object} options optional and required options\n */\n\nvar HlsHandler = (function (_Component) {\n  _inherits(HlsHandler, _Component);\n\n  function HlsHandler(source, tech, options) {\n    var _this = this;\n\n    _classCallCheck(this, HlsHandler);\n\n    _get(Object.getPrototypeOf(HlsHandler.prototype), 'constructor', this).call(this, tech, options.hls);\n\n    // tech.player() is deprecated but setup a reference to HLS for\n    // backwards-compatibility\n    if (tech.options_ && tech.options_.playerId) {\n      var _player = (0, _videoJs2['default'])(tech.options_.playerId);\n\n      if (!_player.hasOwnProperty('hls')) {\n        Object.defineProperty(_player, 'hls', {\n          get: function get() {\n            _videoJs2['default'].log.warn('player.hls is deprecated. Use player.tech_.hls instead.');\n            tech.trigger({ type: 'usage', name: 'hls-player-access' });\n            return _this;\n          }\n        });\n      }\n    }\n\n    this.tech_ = tech;\n    this.source_ = source;\n    this.stats = {};\n    this.ignoreNextSeekingEvent_ = false;\n    this.setOptions_();\n\n    // overriding native HLS only works if audio tracks have been emulated\n    // error early if we're misconfigured:\n    if (this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) {\n      throw new Error('Overriding native HLS requires emulated tracks. ' + 'See https://git.io/vMpjB');\n    }\n\n    // listen for fullscreenchange events for this player so that we\n    // can adjust our quality selection quickly\n    this.on(_globalDocument2['default'], ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'], function (event) {\n      var fullscreenElement = _globalDocument2['default'].fullscreenElement || _globalDocument2['default'].webkitFullscreenElement || _globalDocument2['default'].mozFullScreenElement || _globalDocument2['default'].msFullscreenElement;\n\n      if (fullscreenElement && fullscreenElement.contains(_this.tech_.el())) {\n        _this.masterPlaylistController_.fastQualityChange_();\n      }\n    });\n\n    this.on(this.tech_, 'seeking', function () {\n      if (this.ignoreNextSeekingEvent_) {\n        this.ignoreNextSeekingEvent_ = false;\n        return;\n      }\n\n      this.setCurrentTime(this.tech_.currentTime());\n    });\n    this.on(this.tech_, 'error', function () {\n      if (this.masterPlaylistController_) {\n        this.masterPlaylistController_.pauseLoading();\n      }\n    });\n\n    this.on(this.tech_, 'play', this.play);\n  }\n\n  /**\n   * The Source Handler object, which informs video.js what additional\n   * MIME types are supported and sets up playback. It is registered\n   * automatically to the appropriate tech based on the capabilities of\n   * the browser it is running in. It is not necessary to use or modify\n   * this object in normal usage.\n   */\n\n  _createClass(HlsHandler, [{\n    key: 'setOptions_',\n    value: function setOptions_() {\n      var _this2 = this;\n\n      // defaults\n      this.options_.withCredentials = this.options_.withCredentials || false;\n\n      if (typeof this.options_.blacklistDuration !== 'number') {\n        this.options_.blacklistDuration = 5 * 60;\n      }\n\n      // start playlist selection at a reasonable bandwidth for\n      // broadband internet (0.5 MB/s) or mobile (0.0625 MB/s)\n      if (typeof this.options_.bandwidth !== 'number') {\n        this.options_.bandwidth = INITIAL_BANDWIDTH;\n      }\n\n      // If the bandwidth number is unchanged from the initial setting\n      // then this takes precedence over the enableLowInitialPlaylist option\n      this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === INITIAL_BANDWIDTH;\n\n      // grab options passed to player.src\n      ['withCredentials', 'bandwidth'].forEach(function (option) {\n        if (typeof _this2.source_[option] !== 'undefined') {\n          _this2.options_[option] = _this2.source_[option];\n        }\n      });\n\n      this.bandwidth = this.options_.bandwidth;\n    }\n\n    /**\n     * called when player.src gets called, handle a new source\n     *\n     * @param {Object} src the source object to handle\n     */\n  }, {\n    key: 'src',\n    value: function src(_src) {\n      var _this3 = this;\n\n      // do nothing if the src is falsey\n      if (!_src) {\n        return;\n      }\n      this.setOptions_();\n      // add master playlist controller options\n      this.options_.url = this.source_.src;\n      this.options_.tech = this.tech_;\n      this.options_.externHls = Hls;\n\n      this.masterPlaylistController_ = new _masterPlaylistController.MasterPlaylistController(this.options_);\n      this.playbackWatcher_ = new _playbackWatcher2['default'](_videoJs2['default'].mergeOptions(this.options_, {\n        seekable: function seekable() {\n          return _this3.seekable();\n        }\n      }));\n\n      this.masterPlaylistController_.on('error', function () {\n        var player = _videoJs2['default'].players[_this3.tech_.options_.playerId];\n\n        player.error(_this3.masterPlaylistController_.error);\n      });\n\n      // `this` in selectPlaylist should be the HlsHandler for backwards\n      // compatibility with < v2\n      this.masterPlaylistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : Hls.STANDARD_PLAYLIST_SELECTOR.bind(this);\n\n      this.masterPlaylistController_.selectInitialPlaylist = Hls.INITIAL_PLAYLIST_SELECTOR.bind(this);\n\n      // re-expose some internal objects for backwards compatibility with < v2\n      this.playlists = this.masterPlaylistController_.masterPlaylistLoader_;\n      this.mediaSource = this.masterPlaylistController_.mediaSource;\n\n      // Proxy assignment of some properties to the master playlist\n      // controller. Using a custom property for backwards compatibility\n      // with < v2\n      Object.defineProperties(this, {\n        selectPlaylist: {\n          get: function get() {\n            return this.masterPlaylistController_.selectPlaylist;\n          },\n          set: function set(selectPlaylist) {\n            this.masterPlaylistController_.selectPlaylist = selectPlaylist.bind(this);\n          }\n        },\n        throughput: {\n          get: function get() {\n            return this.masterPlaylistController_.mainSegmentLoader_.throughput.rate;\n          },\n          set: function set(throughput) {\n            this.masterPlaylistController_.mainSegmentLoader_.throughput.rate = throughput;\n            // By setting `count` to 1 the throughput value becomes the starting value\n            // for the cumulative average\n            this.masterPlaylistController_.mainSegmentLoader_.throughput.count = 1;\n          }\n        },\n        bandwidth: {\n          get: function get() {\n            return this.masterPlaylistController_.mainSegmentLoader_.bandwidth;\n          },\n          set: function set(bandwidth) {\n            this.masterPlaylistController_.mainSegmentLoader_.bandwidth = bandwidth;\n            // setting the bandwidth manually resets the throughput counter\n            // `count` is set to zero that current value of `rate` isn't included\n            // in the cumulative average\n            this.masterPlaylistController_.mainSegmentLoader_.throughput = {\n              rate: 0,\n              count: 0\n            };\n          }\n        },\n        /**\n         * `systemBandwidth` is a combination of two serial processes bit-rates. The first\n         * is the network bitrate provided by `bandwidth` and the second is the bitrate of\n         * the entire process after that - decryption, transmuxing, and appending - provided\n         * by `throughput`.\n         *\n         * Since the two process are serial, the overall system bandwidth is given by:\n         *   sysBandwidth = 1 / (1 / bandwidth + 1 / throughput)\n         */\n        systemBandwidth: {\n          get: function get() {\n            var invBandwidth = 1 / (this.bandwidth || 1);\n            var invThroughput = undefined;\n\n            if (this.throughput > 0) {\n              invThroughput = 1 / this.throughput;\n            } else {\n              invThroughput = 0;\n            }\n\n            var systemBitrate = Math.floor(1 / (invBandwidth + invThroughput));\n\n            return systemBitrate;\n          },\n          set: function set() {\n            _videoJs2['default'].log.error('The \"systemBandwidth\" property is read-only');\n          }\n        }\n      });\n\n      Object.defineProperties(this.stats, {\n        bandwidth: {\n          get: function get() {\n            return _this3.bandwidth || 0;\n          },\n          enumerable: true\n        },\n        mediaRequests: {\n          get: function get() {\n            return _this3.masterPlaylistController_.mediaRequests_() || 0;\n          },\n          enumerable: true\n        },\n        mediaRequestsAborted: {\n          get: function get() {\n            return _this3.masterPlaylistController_.mediaRequestsAborted_() || 0;\n          },\n          enumerable: true\n        },\n        mediaRequestsTimedout: {\n          get: function get() {\n            return _this3.masterPlaylistController_.mediaRequestsTimedout_() || 0;\n          },\n          enumerable: true\n        },\n        mediaRequestsErrored: {\n          get: function get() {\n            return _this3.masterPlaylistController_.mediaRequestsErrored_() || 0;\n          },\n          enumerable: true\n        },\n        mediaTransferDuration: {\n          get: function get() {\n            return _this3.masterPlaylistController_.mediaTransferDuration_() || 0;\n          },\n          enumerable: true\n        },\n        mediaBytesTransferred: {\n          get: function get() {\n            return _this3.masterPlaylistController_.mediaBytesTransferred_() || 0;\n          },\n          enumerable: true\n        },\n        mediaSecondsLoaded: {\n          get: function get() {\n            return _this3.masterPlaylistController_.mediaSecondsLoaded_() || 0;\n          },\n          enumerable: true\n        }\n      });\n\n      this.tech_.one('canplay', this.masterPlaylistController_.setupFirstPlay.bind(this.masterPlaylistController_));\n\n      this.masterPlaylistController_.on('selectedinitialmedia', function () {\n        // Add the manual rendition mix-in to HlsHandler\n        (0, _renditionMixin2['default'])(_this3);\n      });\n\n      // the bandwidth of the primary segment loader is our best\n      // estimate of overall bandwidth\n      this.on(this.masterPlaylistController_, 'progress', function () {\n        this.tech_.trigger('progress');\n      });\n\n      // In the live case, we need to ignore the very first `seeking` event since\n      // that will be the result of the seek-to-live behavior\n      this.on(this.masterPlaylistController_, 'firstplay', function () {\n        this.ignoreNextSeekingEvent_ = true;\n      });\n\n      this.tech_.ready(function () {\n        return _this3.setupQualityLevels_();\n      });\n\n      // do nothing if the tech has been disposed already\n      // this can occur if someone sets the src in player.ready(), for instance\n      if (!this.tech_.el()) {\n        return;\n      }\n\n      this.tech_.src(_videoJs2['default'].URL.createObjectURL(this.masterPlaylistController_.mediaSource));\n    }\n\n    /**\n     * Initializes the quality levels and sets listeners to update them.\n     *\n     * @method setupQualityLevels_\n     * @private\n     */\n  }, {\n    key: 'setupQualityLevels_',\n    value: function setupQualityLevels_() {\n      var _this4 = this;\n\n      var player = _videoJs2['default'].players[this.tech_.options_.playerId];\n\n      if (player && player.qualityLevels) {\n        this.qualityLevels_ = player.qualityLevels();\n\n        this.masterPlaylistController_.on('selectedinitialmedia', function () {\n          handleHlsLoadedMetadata(_this4.qualityLevels_, _this4);\n        });\n\n        this.playlists.on('mediachange', function () {\n          handleHlsMediaChange(_this4.qualityLevels_, _this4.playlists);\n        });\n      }\n    }\n\n    /**\n     * Begin playing the video.\n     */\n  }, {\n    key: 'play',\n    value: function play() {\n      this.masterPlaylistController_.play();\n    }\n\n    /**\n     * a wrapper around the function in MasterPlaylistController\n     */\n  }, {\n    key: 'setCurrentTime',\n    value: function setCurrentTime(currentTime) {\n      this.masterPlaylistController_.setCurrentTime(currentTime);\n    }\n\n    /**\n     * a wrapper around the function in MasterPlaylistController\n     */\n  }, {\n    key: 'duration',\n    value: function duration() {\n      return this.masterPlaylistController_.duration();\n    }\n\n    /**\n     * a wrapper around the function in MasterPlaylistController\n     */\n  }, {\n    key: 'seekable',\n    value: function seekable() {\n      return this.masterPlaylistController_.seekable();\n    }\n\n    /**\n    * Abort all outstanding work and cleanup.\n    */\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      if (this.playbackWatcher_) {\n        this.playbackWatcher_.dispose();\n      }\n      if (this.masterPlaylistController_) {\n        this.masterPlaylistController_.dispose();\n      }\n      if (this.qualityLevels_) {\n        this.qualityLevels_.dispose();\n      }\n      _get(Object.getPrototypeOf(HlsHandler.prototype), 'dispose', this).call(this);\n    }\n  }]);\n\n  return HlsHandler;\n})(Component);\n\nvar HlsSourceHandler = function HlsSourceHandler(mode) {\n  return {\n    canHandleSource: function canHandleSource(srcObj) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var localOptions = _videoJs2['default'].mergeOptions(_videoJs2['default'].options, options);\n\n      // this forces video.js to skip this tech/mode if its not the one we have been\n      // overriden to use, by returing that we cannot handle the source.\n      if (localOptions.hls && localOptions.hls.mode && localOptions.hls.mode !== mode) {\n        return false;\n      }\n      return HlsSourceHandler.canPlayType(srcObj.type, localOptions);\n    },\n    handleSource: function handleSource(source, tech) {\n      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n      var localOptions = _videoJs2['default'].mergeOptions(_videoJs2['default'].options, options, { hls: { mode: mode } });\n\n      if (mode === 'flash') {\n        // We need to trigger this asynchronously to give others the chance\n        // to bind to the event when a source is set at player creation\n        tech.setTimeout(function () {\n          tech.trigger('loadstart');\n        }, 1);\n      }\n\n      tech.hls = new HlsHandler(source, tech, localOptions);\n      tech.hls.xhr = (0, _xhr2['default'])();\n\n      tech.hls.src(source.src);\n      return tech.hls;\n    },\n    canPlayType: function canPlayType(type) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var localOptions = _videoJs2['default'].mergeOptions(_videoJs2['default'].options, options);\n\n      if (HlsSourceHandler.canPlayType(type, localOptions)) {\n        return 'maybe';\n      }\n      return '';\n    }\n  };\n};\n\nHlsSourceHandler.canPlayType = function (type, options) {\n  // No support for IE 10 or below\n  if (_videoJs2['default'].browser.IE_VERSION && _videoJs2['default'].browser.IE_VERSION <= 10) {\n    return false;\n  }\n\n  var mpegurlRE = /^(audio|video|application)\\/(x-|vnd\\.apple\\.)?mpegurl/i;\n\n  // favor native HLS support if it's available\n  if (!options.hls.overrideNative && Hls.supportsNativeHls) {\n    return false;\n  }\n  return mpegurlRE.test(type);\n};\n\nif (typeof _videoJs2['default'].MediaSource === 'undefined' || typeof _videoJs2['default'].URL === 'undefined') {\n  _videoJs2['default'].MediaSource = _videojsContribMediaSources.MediaSource;\n  _videoJs2['default'].URL = _videojsContribMediaSources.URL;\n}\n\nvar flashTech = _videoJs2['default'].getTech('Flash');\n\n// register source handlers with the appropriate techs\nif (_videojsContribMediaSources.MediaSource.supportsNativeMediaSources()) {\n  _videoJs2['default'].getTech('Html5').registerSourceHandler(HlsSourceHandler('html5'), 0);\n}\nif (_globalWindow2['default'].Uint8Array && flashTech) {\n  flashTech.registerSourceHandler(HlsSourceHandler('flash'));\n}\n\n_videoJs2['default'].HlsHandler = HlsHandler;\n_videoJs2['default'].HlsSourceHandler = HlsSourceHandler;\n_videoJs2['default'].Hls = Hls;\nif (!_videoJs2['default'].use) {\n  _videoJs2['default'].registerComponent('Hls', Hls);\n}\n_videoJs2['default'].m3u8 = _m3u8Parser2['default'];\n_videoJs2['default'].options.hls = _videoJs2['default'].options.hls || {};\n\nif (_videoJs2['default'].registerPlugin) {\n  _videoJs2['default'].registerPlugin('reloadSourceOnError', _reloadSourceOnError2['default']);\n} else {\n  _videoJs2['default'].plugin('reloadSourceOnError', _reloadSourceOnError2['default']);\n}\n\nmodule.exports = {\n  Hls: Hls,\n  HlsHandler: HlsHandler,\n  HlsSourceHandler: HlsSourceHandler\n};\n}).call(this, false ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./bin-utils\":2,\"./config\":3,\"./master-playlist-controller\":5,\"./playback-watcher\":8,\"./playlist\":11,\"./playlist-loader\":9,\"./playlist-selectors.js\":10,\"./reload-source-on-error\":13,\"./rendition-mixin\":14,\"./xhr\":21,\"aes-decrypter\":25,\"global/document\":31,\"global/window\":32,\"m3u8-parser\":33,\"videojs-contrib-media-sources\":74}]},{},[77])(77)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLWhscy9kaXN0L3ZpZGVvanMtY29udHJpYi1obHMuanM/ZjUyMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiWUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQTJELG1CQUFtQixnREFBZ0QsYUFBYSxLQUFLLE1BQU0sZ0NBQWdDLFNBQVMscUNBQXFDLFNBQVMsbUNBQW1DLE9BQU8sS0FBSyxPQUFPLDJCQUEyQixhQUFhLDBCQUEwQiwwQkFBMEIsZ0JBQWdCLFVBQVUsVUFBVSwwQ0FBMEMsOEJBQXdCLG9CQUFvQiw4Q0FBOEMsa0NBQWtDLFlBQVksWUFBWSxtQ0FBbUMsaUJBQWlCLGdCQUFnQixzQkFBc0Isb0JBQW9CLDBDQUEwQyxZQUFZLFdBQVcsWUFBWSxTQUFTLEdBQUc7QUFDcnpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELG1DQUFtQyxpQ0FBaUMsZUFBZSxlQUFlLGdCQUFnQixvQkFBb0IsTUFBTSwwQ0FBMEMsK0JBQStCLGFBQWEscUJBQXFCLG1DQUFtQyxFQUFFLEVBQUUsY0FBYyxXQUFXLFVBQVUsRUFBRSxVQUFVLE1BQU0seUNBQXlDLEVBQUUsVUFBVSxrQkFBa0IsRUFBRSxFQUFFLGFBQWEsRUFBRSwyQkFBMkIsMEJBQTBCLFlBQVksRUFBRSwyQ0FBMkMsOEJBQThCLEVBQUUsT0FBTyw2RUFBNkUsRUFBRSxHQUFHLEVBQUU7O0FBRXRwQixzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2REFBNkQsYUFBYTs7QUFFMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1EQUFtRDs7QUFFN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseUhBQXlIO0FBQ3pIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLENBQUMsOEdBQXFJO0FBQ3RJLENBQUMsRUFBRSxnU0FBZ1M7QUFDblM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0Y7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTRCLDZDQUE2QztBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHlDQUF5QztBQUNyRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsNkNBQTZDO0FBQ3pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsaUNBQWlDO0FBQ2pDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxDQUFDLDhHQUFxSTtBQUN0SSxDQUFDLEVBQUUsdURBQXVEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHNDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEVBQTBFOztBQUUxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDRFQUE0RTs7QUFFNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7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QUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFF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QUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SCxFQUFFO0FBQzllO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0RBQStELEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLENBQUMsRUFBRSxjQUFjO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELG1EQUFtRCxnQkFBZ0Isc0JBQXNCLE9BQU8sMkJBQTJCLDBCQUEwQix5REFBeUQsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLGVBQWU7O0FBRTlQLGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUU7O0FBRWpqQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosaURBQWlELGFBQWEsdUZBQXVGLEVBQUUsdUZBQXVGOztBQUU5TywwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVILEVBQUU7QUFDOWU7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0EsQ0FBQyxFQUFFLHFEQUFxRDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVqakIsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsd0JBQXdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLDRCQUE0QjtBQUM1QixHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsRUFBRSx3QkFBd0I7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsbUNBQW1DO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLG1EQUFtRDtBQUN0RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLGtDQUFrQztBQUNsQyw0Q0FBNEM7QUFDNUMsZ0NBQWdDO0FBQ2hDLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0Isc0NBQXNDO0FBQ3RDLCtCQUErQjs7QUFFL0Isa0NBQWtDO0FBQ2xDLGFBQWEsc0JBQXNCO0FBQ25DLHdDQUF3QztBQUN4QyxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLDhCQUE4Qjs7QUFFeEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQiw4QkFBOEI7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLHVKQUF1SjtBQUMxSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSztBQUNMOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLHFCQUFxQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQyx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsaUpBQWlKO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUseUNBQXlDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLDZDQUE2QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLHVCQUF1QjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUscUJBQXFCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsdUNBQXVDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQSw2REFBNkQ7QUFDN0QsK0ZBQStGO0FBQy9GOztBQUVBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBbUI7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsbUJBQW1CLE9BQU87QUFDMUIsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQiwyQkFBMkI7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUscUJBQXFCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsbUJBQW1CO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxpQkFBaUI7QUFDaEM7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQzs7QUFFQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7O0FBRUE7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHLDBDQUEwQzs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsOEJBQThCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQ0FBaUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQ0FBaUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUscUtBQXFLO0FBQ3hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsa0hBQWtIO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDhCQUE4Qix5Q0FBeUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7QUFDQSxpQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaURBQWlEO0FBQ2pGO0FBQ0EsNEZBQTRGLDRCQUE0QjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUIsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHNDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLElBQUk7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhHQUFxSTtBQUN0SSxDQUFDLEVBQUUsbUJBQW1CO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixpQ0FBaUM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxpQ0FBaUMsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVsakIsdUNBQXVDLG1CQUFtQiw0QkFBNEIsaURBQWlELGdCQUFnQixrREFBa0QsOERBQThELDBCQUEwQiw0Q0FBNEMsdUJBQXVCLGtCQUFrQixFQUFFLE9BQU8sYUFBYSxnQkFBZ0IsZ0JBQWdCLGVBQWUsMkJBQTJCLG9CQUFvQixFQUFFLEVBQUUsNEJBQTRCLG1CQUFtQixFQUFFLE9BQU8sdUJBQXVCLDRCQUE0QixrQkFBa0IsRUFBRSw4QkFBOEIsRUFBRSxFQUFFOztBQUUvb0Isc0NBQXNDLHVDQUF1QyxrQkFBa0I7O0FBRS9GLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDBDQUEwQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUg7O0FBRTVlOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhHQUFxSTtBQUN0SSxDQUFDLEVBQUUsMEZBQTBGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsaUNBQWlDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFbGpCLHVDQUF1QyxtQkFBbUIsNEJBQTRCLGlEQUFpRCxnQkFBZ0Isa0RBQWtELDhEQUE4RCwwQkFBMEIsNENBQTRDLHVCQUF1QixrQkFBa0IsRUFBRSxPQUFPLGFBQWEsZ0JBQWdCLGdCQUFnQixlQUFlLDJCQUEyQixvQkFBb0IsRUFBRSxFQUFFLDRCQUE0QixtQkFBbUIsRUFBRSxPQUFPLHVCQUF1Qiw0QkFBNEIsa0JBQWtCLEVBQUUsOEJBQThCLEVBQUUsRUFBRTs7QUFFL29CLHNDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0MsNEJBQTRCLEVBQUU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asb0NBQW9DLGtCQUFrQjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckMsb0JBQW9CLG9CQUFvQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLDZDQUE2Qzs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQ0FBb0MsMEJBQTBCO0FB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QUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQix3Q0FBd0M7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDBCQUEwQjtBQUMxRTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0NBQXNDOztBQUV0Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asb0NBQW9DLGtCQUFrQjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxxREFBcUQ7QUFDeEY7QUFDQTtBQUNBLG1DQUFtQyxxREFBcUQ7QUFDeEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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NUIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyQ0FBMkM7QUFDckU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTs7QUFFNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEVBQTRFOztBQUU1RSxtR0FBbUcsT0FBTyxhQUFhLEVBQUU7O0FBRXpIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEVBQTRFOztBQUU1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4R0FBcUk7QUFDdEksQ0FBQyxFQUFFLHVVQUF1VSxFQUFFLEdBQUc7QUFDL1UsQ0FBQyIsImZpbGUiOiIzMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdmlkZW9qcy1jb250cmliLWhsc1xuICogQHZlcnNpb24gNS4xMi4yXG4gKiBAY29weXJpZ2h0IDIwMTcgQnJpZ2h0Y292ZSwgSW5jXG4gKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4gKi9cbihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLnZpZGVvanNDb250cmliSGxzID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBhZC1jdWUtdGFncy5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10pIF9pWydyZXR1cm4nXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7IH0gfTsgfSkoKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2dsb2JhbFdpbmRvdyA9IHJlcXVpcmUoJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIF9nbG9iYWxXaW5kb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsV2luZG93KTtcblxuLyoqXG4gKiBTZWFyY2hlcyBmb3IgYW4gYWQgY3VlIHRoYXQgb3ZlcmxhcHMgd2l0aCB0aGUgZ2l2ZW4gbWVkaWFUaW1lXG4gKi9cbnZhciBmaW5kQWRDdWUgPSBmdW5jdGlvbiBmaW5kQWRDdWUodHJhY2ssIG1lZGlhVGltZSkge1xuICB2YXIgY3VlcyA9IHRyYWNrLmN1ZXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN1ZSA9IGN1ZXNbaV07XG5cbiAgICBpZiAobWVkaWFUaW1lID49IGN1ZS5hZFN0YXJ0VGltZSAmJiBtZWRpYVRpbWUgPD0gY3VlLmFkRW5kVGltZSkge1xuICAgICAgcmV0dXJuIGN1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgdXBkYXRlQWRDdWVzID0gZnVuY3Rpb24gdXBkYXRlQWRDdWVzKG1lZGlhLCB0cmFjaykge1xuICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1syXTtcblxuICBpZiAoIW1lZGlhLnNlZ21lbnRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1lZGlhVGltZSA9IG9mZnNldDtcbiAgdmFyIGN1ZSA9IHVuZGVmaW5lZDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhLnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBtZWRpYS5zZWdtZW50c1tpXTtcblxuICAgIGlmICghY3VlKSB7XG4gICAgICAvLyBTaW5jZSB0aGUgY3VlcyB3aWxsIHNwYW4gZm9yIGF0IGxlYXN0IHRoZSBzZWdtZW50IGR1cmF0aW9uLCBhZGRpbmcgYSBmdWRnZVxuICAgICAgLy8gZmFjdG9yIG9mIGhhbGYgc2VnbWVudCBkdXJhdGlvbiB3aWxsIHByZXZlbnQgZHVwbGljYXRlIGN1ZXMgZnJvbSBiZWluZ1xuICAgICAgLy8gY3JlYXRlZCB3aGVuIHRpbWluZyBpbmZvIGlzIG5vdCBleGFjdCAoZS5nLiBjdWUgc3RhcnQgdGltZSBpbml0aWFsaXplZFxuICAgICAgLy8gYXQgMTAuMDA2Njc3LCBidXQgbmV4dCBjYWxsIG1lZGlhVGltZSBpcyAxMC4wMDMzMzIgKVxuICAgICAgY3VlID0gZmluZEFkQ3VlKHRyYWNrLCBtZWRpYVRpbWUgKyBzZWdtZW50LmR1cmF0aW9uIC8gMik7XG4gICAgfVxuXG4gICAgaWYgKGN1ZSkge1xuICAgICAgaWYgKCdjdWVJbicgaW4gc2VnbWVudCkge1xuICAgICAgICAvLyBGb3VuZCBhIENVRS1JTiBzbyBlbmQgdGhlIGN1ZVxuICAgICAgICBjdWUuZW5kVGltZSA9IG1lZGlhVGltZTtcbiAgICAgICAgY3VlLmFkRW5kVGltZSA9IG1lZGlhVGltZTtcbiAgICAgICAgbWVkaWFUaW1lICs9IHNlZ21lbnQuZHVyYXRpb247XG4gICAgICAgIGN1ZSA9IG51bGw7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFUaW1lIDwgY3VlLmVuZFRpbWUpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBwcm9jZXNzZWQgdGhpcyBtZWRpYVRpbWUgZm9yIHRoaXMgY3VlXG4gICAgICAgIG1lZGlhVGltZSArPSBzZWdtZW50LmR1cmF0aW9uO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXJ3aXNlIGV4dGVuZCBjdWUgdW50aWwgYSBDVUUtSU4gaXMgZm91bmRcbiAgICAgIGN1ZS5lbmRUaW1lICs9IHNlZ21lbnQuZHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgnY3VlT3V0JyBpbiBzZWdtZW50KSB7XG4gICAgICAgIGN1ZSA9IG5ldyBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLlZUVEN1ZShtZWRpYVRpbWUsIG1lZGlhVGltZSArIHNlZ21lbnQuZHVyYXRpb24sIHNlZ21lbnQuY3VlT3V0KTtcbiAgICAgICAgY3VlLmFkU3RhcnRUaW1lID0gbWVkaWFUaW1lO1xuICAgICAgICAvLyBBc3N1bWVzIHRhZyBmb3JtYXQgdG8gYmVcbiAgICAgICAgLy8gI0VYVC1YLUNVRS1PVVQ6MzBcbiAgICAgICAgY3VlLmFkRW5kVGltZSA9IG1lZGlhVGltZSArIHBhcnNlRmxvYXQoc2VnbWVudC5jdWVPdXQpO1xuICAgICAgICB0cmFjay5hZGRDdWUoY3VlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdjdWVPdXRDb250JyBpbiBzZWdtZW50KSB7XG4gICAgICAgIC8vIEVudGVyZWQgaW50byB0aGUgbWlkZGxlIG9mIGFuIGFkIGN1ZVxuICAgICAgICB2YXIgYWRPZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhZFRvdGFsID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIEFzc3VtZXMgdGFnIGZvcm1hdGUgdG8gYmVcbiAgICAgICAgLy8gI0VYVC1YLUNVRS1PVVQtQ09OVDoxMC8zMFxuXG4gICAgICAgIHZhciBfc2VnbWVudCRjdWVPdXRDb250JHNwbGl0JG1hcCA9IHNlZ21lbnQuY3VlT3V0Q29udC5zcGxpdCgnLycpLm1hcChwYXJzZUZsb2F0KTtcblxuICAgICAgICB2YXIgX3NlZ21lbnQkY3VlT3V0Q29udCRzcGxpdCRtYXAyID0gX3NsaWNlZFRvQXJyYXkoX3NlZ21lbnQkY3VlT3V0Q29udCRzcGxpdCRtYXAsIDIpO1xuXG4gICAgICAgIGFkT2Zmc2V0ID0gX3NlZ21lbnQkY3VlT3V0Q29udCRzcGxpdCRtYXAyWzBdO1xuICAgICAgICBhZFRvdGFsID0gX3NlZ21lbnQkY3VlT3V0Q29udCRzcGxpdCRtYXAyWzFdO1xuXG4gICAgICAgIGN1ZSA9IG5ldyBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLlZUVEN1ZShtZWRpYVRpbWUsIG1lZGlhVGltZSArIHNlZ21lbnQuZHVyYXRpb24sICcnKTtcbiAgICAgICAgY3VlLmFkU3RhcnRUaW1lID0gbWVkaWFUaW1lIC0gYWRPZmZzZXQ7XG4gICAgICAgIGN1ZS5hZEVuZFRpbWUgPSBjdWUuYWRTdGFydFRpbWUgKyBhZFRvdGFsO1xuICAgICAgICB0cmFjay5hZGRDdWUoY3VlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWVkaWFUaW1lICs9IHNlZ21lbnQuZHVyYXRpb247XG4gIH1cbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgdXBkYXRlQWRDdWVzOiB1cGRhdGVBZEN1ZXMsXG4gIGZpbmRBZEN1ZTogZmluZEFkQ3VlXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG59LHtcImdsb2JhbC93aW5kb3dcIjozMn1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBiaW4tdXRpbHMuanNcbiAqL1xuXG4vKipcbiAqIGNvbnZlcnQgYSBUaW1lUmFuZ2UgdG8gdGV4dFxuICpcbiAqIEBwYXJhbSB7VGltZVJhbmdlfSByYW5nZSB0aGUgdGltZXJhbmdlIHRvIHVzZSBmb3IgY29udmVyc2lvblxuICogQHBhcmFtIHtOdW1iZXJ9IGkgdGhlIGl0ZXJhdG9yIG9uIHRoZSByYW5nZSB0byBjb252ZXJ0XG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgdGV4dFJhbmdlID0gZnVuY3Rpb24gdGV4dFJhbmdlKHJhbmdlLCBpKSB7XG4gIHJldHVybiByYW5nZS5zdGFydChpKSArICctJyArIHJhbmdlLmVuZChpKTtcbn07XG5cbi8qKlxuICogZm9ybWF0IGEgbnVtYmVyIGFzIGhleCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZSBUaGUgbnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gaSB0aGUgaXRlcmF0b3JcbiAqL1xudmFyIGZvcm1hdEhleFN0cmluZyA9IGZ1bmN0aW9uIGZvcm1hdEhleFN0cmluZyhlLCBpKSB7XG4gIHZhciB2YWx1ZSA9IGUudG9TdHJpbmcoMTYpO1xuXG4gIHJldHVybiAnMDAnLnN1YnN0cmluZygwLCAyIC0gdmFsdWUubGVuZ3RoKSArIHZhbHVlICsgKGkgJSAyID8gJyAnIDogJycpO1xufTtcbnZhciBmb3JtYXRBc2NpaVN0cmluZyA9IGZ1bmN0aW9uIGZvcm1hdEFzY2lpU3RyaW5nKGUpIHtcbiAgaWYgKGUgPj0gMHgyMCAmJiBlIDwgMHg3ZSkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpO1xuICB9XG4gIHJldHVybiAnLic7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGZvciBzZW5kaW5nIHRvIGEgd2ViIHdvcmtlciBtb2RpZnlpbmcgcHJvcGVydGllcyB0aGF0IGFyZSBUeXBlZEFycmF5c1xuICogaW50byBhIG5ldyBvYmplY3Qgd2l0aCBzZXBlcmF0ZWQgcHJvcGVydGllcyBmb3IgdGhlIGJ1ZmZlciwgYnl0ZU9mZnNldCwgYW5kIGJ5dGVMZW5ndGguXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VcbiAqICAgICAgICBPYmplY3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHRvIHNlbmQgdG8gdGhlIHdlYiB3b3JrZXJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgTW9kaWZpZWQgbWVzc2FnZSB3aXRoIFR5cGVkQXJyYXkgdmFsdWVzIGV4cGFuZGVkXG4gKiBAZnVuY3Rpb24gY3JlYXRlVHJhbnNmZXJhYmxlTWVzc2FnZVxuICovXG52YXIgY3JlYXRlVHJhbnNmZXJhYmxlTWVzc2FnZSA9IGZ1bmN0aW9uIGNyZWF0ZVRyYW5zZmVyYWJsZU1lc3NhZ2UobWVzc2FnZSkge1xuICB2YXIgdHJhbnNmZXJhYmxlID0ge307XG5cbiAgT2JqZWN0LmtleXMobWVzc2FnZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbHVlID0gbWVzc2FnZVtrZXldO1xuXG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgIHRyYW5zZmVyYWJsZVtrZXldID0ge1xuICAgICAgICBieXRlczogdmFsdWUuYnVmZmVyLFxuICAgICAgICBieXRlT2Zmc2V0OiB2YWx1ZS5ieXRlT2Zmc2V0LFxuICAgICAgICBieXRlTGVuZ3RoOiB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2ZlcmFibGVba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRyYW5zZmVyYWJsZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHVuaXF1ZSBzdHJpbmcgaWRlbnRpZmllciBmb3IgYSBtZWRpYSBpbml0aWFsaXphdGlvblxuICogc2VnbWVudC5cbiAqL1xudmFyIGluaXRTZWdtZW50SWQgPSBmdW5jdGlvbiBpbml0U2VnbWVudElkKGluaXRTZWdtZW50KSB7XG4gIHZhciBieXRlcmFuZ2UgPSBpbml0U2VnbWVudC5ieXRlcmFuZ2UgfHwge1xuICAgIGxlbmd0aDogSW5maW5pdHksXG4gICAgb2Zmc2V0OiAwXG4gIH07XG5cbiAgcmV0dXJuIFtieXRlcmFuZ2UubGVuZ3RoLCBieXRlcmFuZ2Uub2Zmc2V0LCBpbml0U2VnbWVudC5yZXNvbHZlZFVyaV0uam9pbignLCcpO1xufTtcblxuLyoqXG4gKiB1dGlscyB0byBoZWxwIGR1bXAgYmluYXJ5IGRhdGEgdG8gdGhlIGNvbnNvbGVcbiAqL1xudmFyIHV0aWxzID0ge1xuICBoZXhEdW1wOiBmdW5jdGlvbiBoZXhEdW1wKGRhdGEpIHtcbiAgICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKTtcbiAgICB2YXIgc3RlcCA9IDE2O1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaGV4ID0gdW5kZWZpbmVkO1xuICAgIHZhciBhc2NpaSA9IHVuZGVmaW5lZDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYnl0ZXMubGVuZ3RoIC8gc3RlcDsgaisrKSB7XG4gICAgICBoZXggPSBieXRlcy5zbGljZShqICogc3RlcCwgaiAqIHN0ZXAgKyBzdGVwKS5tYXAoZm9ybWF0SGV4U3RyaW5nKS5qb2luKCcnKTtcbiAgICAgIGFzY2lpID0gYnl0ZXMuc2xpY2UoaiAqIHN0ZXAsIGogKiBzdGVwICsgc3RlcCkubWFwKGZvcm1hdEFzY2lpU3RyaW5nKS5qb2luKCcnKTtcbiAgICAgIHJlc3VsdCArPSBoZXggKyAnICcgKyBhc2NpaSArICdcXG4nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICB0YWdEdW1wOiBmdW5jdGlvbiB0YWdEdW1wKHRhZykge1xuICAgIHJldHVybiB1dGlscy5oZXhEdW1wKHRhZy5ieXRlcyk7XG4gIH0sXG4gIHRleHRSYW5nZXM6IGZ1bmN0aW9uIHRleHRSYW5nZXMocmFuZ2VzKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gdW5kZWZpbmVkO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0ICs9IHRleHRSYW5nZShyYW5nZXMsIGkpICsgJyAnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBjcmVhdGVUcmFuc2ZlcmFibGVNZXNzYWdlOiBjcmVhdGVUcmFuc2ZlcmFibGVNZXNzYWdlLFxuICBpbml0U2VnbWVudElkOiBpbml0U2VnbWVudElkXG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSB1dGlscztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSx7fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0ge1xuICBHT0FMX0JVRkZFUl9MRU5HVEg6IDMwLFxuICBNQVhfR09BTF9CVUZGRVJfTEVOR1RIOiA2MCxcbiAgR09BTF9CVUZGRVJfTEVOR1RIX1JBVEU6IDEsXG4gIC8vIEEgZnVkZ2UgZmFjdG9yIHRvIGFwcGx5IHRvIGFkdmVydGlzZWQgcGxheWxpc3QgYml0cmF0ZXMgdG8gYWNjb3VudCBmb3JcbiAgLy8gdGVtcG9yYXJ5IGZsdWNhdGlvbnMgaW4gY2xpZW50IGJhbmR3aWR0aFxuICBCQU5EV0lEVEhfVkFSSUFOQ0U6IDEuMixcbiAgLy8gSG93IG11Y2ggb2YgdGhlIGJ1ZmZlciBtdXN0IGJlIGZpbGxlZCBiZWZvcmUgd2UgY29uc2lkZXIgdXBzd2l0Y2hpbmdcbiAgQlVGRkVSX0xPV19XQVRFUl9MSU5FOiAwLFxuICBNQVhfQlVGRkVSX0xPV19XQVRFUl9MSU5FOiAzMCxcbiAgQlVGRkVSX0xPV19XQVRFUl9MSU5FX1JBVEU6IDFcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xufSx7fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfZ2xvYmFsV2luZG93ID0gcmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgX2dsb2JhbFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxXaW5kb3cpO1xuXG52YXIgX2Flc0RlY3J5cHRlciA9IHJlcXVpcmUoJ2Flcy1kZWNyeXB0ZXInKTtcblxudmFyIF9iaW5VdGlscyA9IHJlcXVpcmUoJy4vYmluLXV0aWxzJyk7XG5cbi8qKlxuICogT3VyIHdlYiB3b3JrZXIgaW50ZXJmYWNlIHNvIHRoYXQgdGhpbmdzIGNhbiB0YWxrIHRvIGFlcy1kZWNyeXB0ZXJcbiAqIHRoYXQgd2lsbCBiZSBydW5uaW5nIGluIGEgd2ViIHdvcmtlci4gdGhlIHNjb3BlIGlzIHBhc3NlZCB0byB0aGlzIGJ5XG4gKiB3ZWJ3b3JraWZ5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmXG4gKiAgICAgICAgdGhlIHNjb3BlIGZvciB0aGUgd2ViIHdvcmtlclxuICovXG52YXIgRGVjcnlwdGVyV29ya2VyID0gZnVuY3Rpb24gRGVjcnlwdGVyV29ya2VyKHNlbGYpIHtcbiAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgdmFyIGVuY3J5cHRlZCA9IG5ldyBVaW50OEFycmF5KGRhdGEuZW5jcnlwdGVkLmJ5dGVzLCBkYXRhLmVuY3J5cHRlZC5ieXRlT2Zmc2V0LCBkYXRhLmVuY3J5cHRlZC5ieXRlTGVuZ3RoKTtcbiAgICB2YXIga2V5ID0gbmV3IFVpbnQzMkFycmF5KGRhdGEua2V5LmJ5dGVzLCBkYXRhLmtleS5ieXRlT2Zmc2V0LCBkYXRhLmtleS5ieXRlTGVuZ3RoIC8gNCk7XG4gICAgdmFyIGl2ID0gbmV3IFVpbnQzMkFycmF5KGRhdGEuaXYuYnl0ZXMsIGRhdGEuaXYuYnl0ZU9mZnNldCwgZGF0YS5pdi5ieXRlTGVuZ3RoIC8gNCk7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcsIGhhbmRsZS1jYWxsYmFjay1lcnIgKi9cbiAgICBuZXcgX2Flc0RlY3J5cHRlci5EZWNyeXB0ZXIoZW5jcnlwdGVkLCBrZXksIGl2LCBmdW5jdGlvbiAoZXJyLCBieXRlcykge1xuICAgICAgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5wb3N0TWVzc2FnZSgoMCwgX2JpblV0aWxzLmNyZWF0ZVRyYW5zZmVyYWJsZU1lc3NhZ2UpKHtcbiAgICAgICAgc291cmNlOiBkYXRhLnNvdXJjZSxcbiAgICAgICAgZGVjcnlwdGVkOiBieXRlc1xuICAgICAgfSksIFtieXRlcy5idWZmZXJdKTtcbiAgICB9KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gIH07XG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoc2VsZikge1xuICByZXR1cm4gbmV3IERlY3J5cHRlcldvcmtlcihzZWxmKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSx7XCIuL2Jpbi11dGlsc1wiOjIsXCJhZXMtZGVjcnlwdGVyXCI6MjUsXCJnbG9iYWwvd2luZG93XCI6MzJ9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogQGZpbGUgbWFzdGVyLXBsYXlsaXN0LWNvbnRyb2xsZXIuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3BsYXlsaXN0TG9hZGVyID0gcmVxdWlyZSgnLi9wbGF5bGlzdC1sb2FkZXInKTtcblxudmFyIF9wbGF5bGlzdExvYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF5bGlzdExvYWRlcik7XG5cbnZhciBfcGxheWxpc3RKcyA9IHJlcXVpcmUoJy4vcGxheWxpc3QuanMnKTtcblxudmFyIF9zZWdtZW50TG9hZGVyID0gcmVxdWlyZSgnLi9zZWdtZW50LWxvYWRlcicpO1xuXG52YXIgX3NlZ21lbnRMb2FkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2VnbWVudExvYWRlcik7XG5cbnZhciBfdnR0U2VnbWVudExvYWRlciA9IHJlcXVpcmUoJy4vdnR0LXNlZ21lbnQtbG9hZGVyJyk7XG5cbnZhciBfdnR0U2VnbWVudExvYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92dHRTZWdtZW50TG9hZGVyKTtcblxudmFyIF9yYW5nZXMgPSByZXF1aXJlKCcuL3JhbmdlcycpO1xuXG52YXIgX3JhbmdlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yYW5nZXMpO1xuXG52YXIgX3ZpZGVvSnMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sndmlkZW9qcyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndmlkZW9qcyddIDogbnVsbCk7XG5cbnZhciBfdmlkZW9KczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aWRlb0pzKTtcblxudmFyIF9hZEN1ZVRhZ3MgPSByZXF1aXJlKCcuL2FkLWN1ZS10YWdzJyk7XG5cbnZhciBfYWRDdWVUYWdzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FkQ3VlVGFncyk7XG5cbnZhciBfc3luY0NvbnRyb2xsZXIgPSByZXF1aXJlKCcuL3N5bmMtY29udHJvbGxlcicpO1xuXG52YXIgX3N5bmNDb250cm9sbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bmNDb250cm9sbGVyKTtcblxudmFyIF92aWRlb2pzQ29udHJpYk1lZGlhU291cmNlc0VzNUNvZGVjVXRpbHMgPSByZXF1aXJlKCd2aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9lczUvY29kZWMtdXRpbHMnKTtcblxudmFyIF93ZWJ3b3JraWZ5ID0gcmVxdWlyZSgnd2Vid29ya2lmeScpO1xuXG52YXIgX3dlYndvcmtpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2Vid29ya2lmeSk7XG5cbnZhciBfZGVjcnlwdGVyV29ya2VyID0gcmVxdWlyZSgnLi9kZWNyeXB0ZXItd29ya2VyJyk7XG5cbnZhciBfZGVjcnlwdGVyV29ya2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlY3J5cHRlcldvcmtlcik7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxudmFyIF9jb25maWcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29uZmlnKTtcblxudmFyIF91dGlsQ29kZWNzSnMgPSByZXF1aXJlKCcuL3V0aWwvY29kZWNzLmpzJyk7XG5cbnZhciBfbWVkaWFHcm91cHMgPSByZXF1aXJlKCcuL21lZGlhLWdyb3VwcycpO1xuXG52YXIgQUJPUlRfRUFSTFlfQkxBQ0tMSVNUX1NFQ09ORFMgPSA2MCAqIDI7XG5cbnZhciBIbHMgPSB1bmRlZmluZWQ7XG5cbi8vIERlZmF1bHQgY29kZWMgcGFyYW1ldGVycyBpZiBub25lIHdlcmUgcHJvdmlkZWQgZm9yIHZpZGVvIGFuZC9vciBhdWRpb1xudmFyIGRlZmF1bHRDb2RlY3MgPSB7XG4gIHZpZGVvQ29kZWM6ICdhdmMxJyxcbiAgdmlkZW9PYmplY3RUeXBlSW5kaWNhdG9yOiAnLjRkNDAwZCcsXG4gIC8vIEFBQy1MQ1xuICBhdWRpb1Byb2ZpbGU6ICcyJ1xufTtcblxuLy8gU2VnbWVudExvYWRlciBzdGF0cyB0aGF0IG5lZWQgdG8gaGF2ZSBlYWNoIGxvYWRlcidzXG4vLyB2YWx1ZXMgc3VtbWVkIHRvIGNhbGN1bGF0ZSB0aGUgZmluYWwgdmFsdWVcbnZhciBsb2FkZXJTdGF0cyA9IFsnbWVkaWFSZXF1ZXN0cycsICdtZWRpYVJlcXVlc3RzQWJvcnRlZCcsICdtZWRpYVJlcXVlc3RzVGltZWRvdXQnLCAnbWVkaWFSZXF1ZXN0c0Vycm9yZWQnLCAnbWVkaWFUcmFuc2ZlckR1cmF0aW9uJywgJ21lZGlhQnl0ZXNUcmFuc2ZlcnJlZCddO1xudmFyIHN1bUxvYWRlclN0YXQgPSBmdW5jdGlvbiBzdW1Mb2FkZXJTdGF0KHN0YXQpIHtcbiAgcmV0dXJuIHRoaXMuYXVkaW9TZWdtZW50TG9hZGVyX1tzdGF0XSArIHRoaXMubWFpblNlZ21lbnRMb2FkZXJfW3N0YXRdO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlIGNvZGVjcyBpbiB0aGUgY29kZWMgc3RyaW5nIHdpdGggdGhlIG9sZCBhcHBsZS1zdHlsZSBgYXZjMS48ZGQ+LjxkZD5gIHRvIHRoZVxuICogc3RhbmRhcmQgYGF2YzEuPGhoaGhoaD5gLlxuICpcbiAqIEBwYXJhbSBjb2RlY1N0cmluZyB7U3RyaW5nfSB0aGUgY29kZWMgc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBjb2RlYyBzdHJpbmcgd2l0aCBvbGQgYXBwbGUtc3R5bGUgY29kZWNzIHJlcGxhY2VkXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIG1hcExlZ2FjeUF2Y0NvZGVjc18gPSBmdW5jdGlvbiBtYXBMZWdhY3lBdmNDb2RlY3NfKGNvZGVjU3RyaW5nKSB7XG4gIHJldHVybiBjb2RlY1N0cmluZy5yZXBsYWNlKC9hdmMxXFwuKFxcZCspXFwuKFxcZCspL2ksIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiAoMCwgX3ZpZGVvanNDb250cmliTWVkaWFTb3VyY2VzRXM1Q29kZWNVdGlscy50cmFuc2xhdGVMZWdhY3lDb2RlY3MpKFttYXRjaF0pWzBdO1xuICB9KTtcbn07XG5cbmV4cG9ydHMubWFwTGVnYWN5QXZjQ29kZWNzXyA9IG1hcExlZ2FjeUF2Y0NvZGVjc187XG4vKipcbiAqIEJ1aWxkIGEgbWVkaWEgbWltZS10eXBlIHN0cmluZyBmcm9tIGEgc2V0IG9mIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIGVpdGhlciAnYXVkaW8nIG9yICd2aWRlbydcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb250YWluZXIgZWl0aGVyICdtcDJ0JyBvciAnbXA0J1xuICogQHBhcmFtIHtBcnJheX0gY29kZWNzIGFuIGFycmF5IG9mIGNvZGVjIHN0cmluZ3MgdG8gYWRkXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGEgdmFsaWQgbWVkaWEgbWltZS10eXBlXG4gKi9cbnZhciBtYWtlTWltZVR5cGVTdHJpbmcgPSBmdW5jdGlvbiBtYWtlTWltZVR5cGVTdHJpbmcodHlwZSwgY29udGFpbmVyLCBjb2RlY3MpIHtcbiAgLy8gVGhlIGNvZGVjcyBhcnJheSBpcyBmaWx0ZXJlZCBzbyB0aGF0IGZhbHNleSB2YWx1ZXMgYXJlXG4gIC8vIGRyb3BwZWQgYW5kIGRvbid0IGNhdXNlIEFycmF5I2pvaW4gdG8gY3JlYXRlIHNwdXJpb3VzXG4gIC8vIGNvbW1hc1xuICByZXR1cm4gdHlwZSArICcvJyArIGNvbnRhaW5lciArICc7IGNvZGVjcz1cIicgKyBjb2RlY3MuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICEhYztcbiAgfSkuam9pbignLCAnKSArICdcIic7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHR5cGUgY29udGFpbmVyIGJhc2VkIG9uIGluZm9ybWF0aW9uIGluIHRoZSBwbGF5bGlzdFxuICogQHBhcmFtIHtQbGF5bGlzdH0gbWVkaWEgdGhlIGN1cnJlbnQgbWVkaWEgcGxheWxpc3RcbiAqIEByZXR1cm4ge1N0cmluZ30gYSB2YWxpZCBtZWRpYSBjb250YWluZXIgdHlwZVxuICovXG52YXIgZ2V0Q29udGFpbmVyVHlwZSA9IGZ1bmN0aW9uIGdldENvbnRhaW5lclR5cGUobWVkaWEpIHtcbiAgLy8gQW4gaW5pdGlhbGl6YXRpb24gc2VnbWVudCBtZWFucyB0aGUgbWVkaWEgcGxheWxpc3QgaXMgYW4gaWZyYW1lXG4gIC8vIHBsYXlsaXN0IG9yIGlzIHVzaW5nIHRoZSBtcDQgY29udGFpbmVyLiBXZSBkb24ndCBjdXJyZW50bHlcbiAgLy8gc3VwcG9ydCBpZnJhbWUgcGxheWxpc3RzLCBzbyBhc3N1bWUgdGhpcyBpcyBzaWduYWxsaW5nIG1wNFxuICAvLyBmcmFnbWVudHMuXG4gIGlmIChtZWRpYS5zZWdtZW50cyAmJiBtZWRpYS5zZWdtZW50cy5sZW5ndGggJiYgbWVkaWEuc2VnbWVudHNbMF0ubWFwKSB7XG4gICAgcmV0dXJuICdtcDQnO1xuICB9XG4gIHJldHVybiAnbXAydCc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzZXQgb2YgY29kZWMgc3RyaW5ncyBwYXJzZWQgZnJvbSB0aGUgcGxheWxpc3Qgb3IgdGhlIGRlZmF1bHRcbiAqIGNvZGVjIHN0cmluZ3MgaWYgbm8gY29kZWNzIHdlcmUgc3BlY2lmaWVkIGluIHRoZSBwbGF5bGlzdFxuICogQHBhcmFtIHtQbGF5bGlzdH0gbWVkaWEgdGhlIGN1cnJlbnQgbWVkaWEgcGxheWxpc3RcbiAqIEByZXR1cm4ge09iamVjdH0gYW4gb2JqZWN0IHdpdGggdGhlIHZpZGVvIGFuZCBhdWRpbyBjb2RlY3NcbiAqL1xudmFyIGdldENvZGVjcyA9IGZ1bmN0aW9uIGdldENvZGVjcyhtZWRpYSkge1xuICAvLyBpZiB0aGUgY29kZWNzIHdlcmUgZXhwbGljaXRseSBzcGVjaWZpZWQsIHVzZSB0aGVtIGluc3RlYWQgb2YgdGhlXG4gIC8vIGRlZmF1bHRzXG4gIHZhciBtZWRpYUF0dHJpYnV0ZXMgPSBtZWRpYS5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmIChtZWRpYUF0dHJpYnV0ZXMuQ09ERUNTKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbENvZGVjc0pzLnBhcnNlQ29kZWNzKShtZWRpYUF0dHJpYnV0ZXMuQ09ERUNTKTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdENvZGVjcztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgTUlNRSB0eXBlIHN0cmluZ3MgZm9yIGEgd29ya2luZyBjb25maWd1cmF0aW9uIG9mXG4gKiBTb3VyY2VCdWZmZXJzIHRvIHBsYXkgdmFyaWFudCBzdHJlYW1zIGluIGEgbWFzdGVyIHBsYXlsaXN0LiBJZlxuICogdGhlcmUgaXMgbm8gcG9zc2libGUgd29ya2luZyBjb25maWd1cmF0aW9uLCBhbiBlbXB0eSBhcnJheSB3aWxsIGJlXG4gKiByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gbWFzdGVyIHtPYmplY3R9IHRoZSBtM3U4IG9iamVjdCBmb3IgdGhlIG1hc3RlciBwbGF5bGlzdFxuICogQHBhcmFtIG1lZGlhIHtPYmplY3R9IHRoZSBtM3U4IG9iamVjdCBmb3IgdGhlIHZhcmlhbnQgcGxheWxpc3RcbiAqIEByZXR1cm4ge0FycmF5fSB0aGUgTUlNRSB0eXBlIHN0cmluZ3MuIElmIHRoZSBhcnJheSBoYXMgbW9yZSB0aGFuXG4gKiBvbmUgZW50cnksIHRoZSBmaXJzdCBlbGVtZW50IHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSB2aWRlb1xuICogU291cmNlQnVmZmVyIGFuZCB0aGUgc2Vjb25kIHRvIHRoZSBhdWRpbyBTb3VyY2VCdWZmZXIuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIG1pbWVUeXBlc0ZvclBsYXlsaXN0XyA9IGZ1bmN0aW9uIG1pbWVUeXBlc0ZvclBsYXlsaXN0XyhtYXN0ZXIsIG1lZGlhKSB7XG4gIHZhciBjb250YWluZXJUeXBlID0gZ2V0Q29udGFpbmVyVHlwZShtZWRpYSk7XG4gIHZhciBjb2RlY0luZm8gPSBnZXRDb2RlY3MobWVkaWEpO1xuICB2YXIgbWVkaWFBdHRyaWJ1dGVzID0gbWVkaWEuYXR0cmlidXRlcyB8fCB7fTtcbiAgLy8gRGVmYXVsdCBjb25kaXRpb24gZm9yIGEgdHJhZGl0aW9uYWwgSExTIChubyBkZW11eGVkIGF1ZGlvL3ZpZGVvKVxuICB2YXIgaXNNdXhlZCA9IHRydWU7XG4gIHZhciBpc01hYXQgPSBmYWxzZTtcblxuICBpZiAoIW1lZGlhKSB7XG4gICAgLy8gTm90IGVub3VnaCBpbmZvcm1hdGlvblxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmIChtYXN0ZXIubWVkaWFHcm91cHMuQVVESU8gJiYgbWVkaWFBdHRyaWJ1dGVzLkFVRElPKSB7XG4gICAgdmFyIGF1ZGlvR3JvdXAgPSBtYXN0ZXIubWVkaWFHcm91cHMuQVVESU9bbWVkaWFBdHRyaWJ1dGVzLkFVRElPXTtcblxuICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBhcmUgaW4gYSBtdWx0aXBsZS1hdWRpbyB0cmFjayBzY2VuYXJpb1xuICAgIGlmIChhdWRpb0dyb3VwKSB7XG4gICAgICBpc01hYXQgPSB0cnVlO1xuICAgICAgLy8gU3RhcnQgd2l0aCB0aGUgZXZlcnl0aGluZyBkZW11eGVkIHRoZW4uLi5cbiAgICAgIGlzTXV4ZWQgPSBmYWxzZTtcbiAgICAgIC8vIC4uLmNoZWNrIHRvIHNlZSBpZiBhbnkgYXVkaW8gZ3JvdXAgdHJhY2tzIGFyZSBtdXhlZCAoaWUuIGxhY2tpbmcgYSB1cmkpXG4gICAgICBmb3IgKHZhciBncm91cElkIGluIGF1ZGlvR3JvdXApIHtcbiAgICAgICAgaWYgKCFhdWRpb0dyb3VwW2dyb3VwSWRdLnVyaSkge1xuICAgICAgICAgIGlzTXV4ZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSExTIHdpdGggbXVsdGlwbGUtYXVkaW8gdHJhY2tzIG11c3QgYWx3YXlzIGdldCBhbiBhdWRpbyBjb2RlYy5cbiAgLy8gUHV0IGFub3RoZXIgd2F5LCB0aGVyZSBpcyBubyB3YXkgdG8gaGF2ZSBhIHZpZGVvLW9ubHkgbXVsdGlwbGUtYXVkaW8gSExTIVxuICBpZiAoaXNNYWF0ICYmICFjb2RlY0luZm8uYXVkaW9Qcm9maWxlKSB7XG4gICAgX3ZpZGVvSnMyWydkZWZhdWx0J10ubG9nLndhcm4oJ011bHRpcGxlIGF1ZGlvIHRyYWNrcyBwcmVzZW50IGJ1dCBubyBhdWRpbyBjb2RlYyBzdHJpbmcgaXMgc3BlY2lmaWVkLiAnICsgJ0F0dGVtcHRpbmcgdG8gdXNlIHRoZSBkZWZhdWx0IGF1ZGlvIGNvZGVjIChtcDRhLjQwLjIpJyk7XG4gICAgY29kZWNJbmZvLmF1ZGlvUHJvZmlsZSA9IGRlZmF1bHRDb2RlY3MuYXVkaW9Qcm9maWxlO1xuICB9XG5cbiAgLy8gR2VuZXJhdGUgdGhlIGZpbmFsIGNvZGVjIHN0cmluZ3MgZnJvbSB0aGUgY29kZWMgb2JqZWN0IGdlbmVyYXRlZCBhYm92ZVxuICB2YXIgY29kZWNTdHJpbmdzID0ge307XG5cbiAgaWYgKGNvZGVjSW5mby52aWRlb0NvZGVjKSB7XG4gICAgY29kZWNTdHJpbmdzLnZpZGVvID0gJycgKyBjb2RlY0luZm8udmlkZW9Db2RlYyArIGNvZGVjSW5mby52aWRlb09iamVjdFR5cGVJbmRpY2F0b3I7XG4gIH1cblxuICBpZiAoY29kZWNJbmZvLmF1ZGlvUHJvZmlsZSkge1xuICAgIGNvZGVjU3RyaW5ncy5hdWRpbyA9ICdtcDRhLjQwLicgKyBjb2RlY0luZm8uYXVkaW9Qcm9maWxlO1xuICB9XG5cbiAgLy8gRmluYWxseSwgbWFrZSBhbmQgcmV0dXJuIGFuIGFycmF5IHdpdGggcHJvcGVyIG1pbWUtdHlwZXMgZGVwZW5kaW5nIG9uXG4gIC8vIHRoZSBjb25maWd1cmF0aW9uXG4gIHZhciBqdXN0QXVkaW8gPSBtYWtlTWltZVR5cGVTdHJpbmcoJ2F1ZGlvJywgY29udGFpbmVyVHlwZSwgW2NvZGVjU3RyaW5ncy5hdWRpb10pO1xuICB2YXIganVzdFZpZGVvID0gbWFrZU1pbWVUeXBlU3RyaW5nKCd2aWRlbycsIGNvbnRhaW5lclR5cGUsIFtjb2RlY1N0cmluZ3MudmlkZW9dKTtcbiAgdmFyIGJvdGhWaWRlb0F1ZGlvID0gbWFrZU1pbWVUeXBlU3RyaW5nKCd2aWRlbycsIGNvbnRhaW5lclR5cGUsIFtjb2RlY1N0cmluZ3MudmlkZW8sIGNvZGVjU3RyaW5ncy5hdWRpb10pO1xuXG4gIGlmIChpc01hYXQpIHtcbiAgICBpZiAoIWlzTXV4ZWQgJiYgY29kZWNTdHJpbmdzLnZpZGVvKSB7XG4gICAgICByZXR1cm4gW2p1c3RWaWRlbywganVzdEF1ZGlvXTtcbiAgICB9XG4gICAgLy8gVGhlcmUgZXhpc3RzIHRoZSBwb3NzaWJsaXR5IHRoYXQgdGhpcyB3aWxsIHJldHVybiBhIGB2aWRlby9jb250YWluZXJgXG4gICAgLy8gbWltZS10eXBlIGZvciB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIGFycmF5IGV2ZW4gd2hlbiB0aGVyZSBpcyBvbmx5IGF1ZGlvLlxuICAgIC8vIFRoaXMgZG9lc24ndCBhcHBlYXIgdG8gYmUgYSBwcm9ibGVtIGFuZCBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICAgIHJldHVybiBbYm90aFZpZGVvQXVkaW8sIGp1c3RBdWRpb107XG4gIH1cblxuICAvLyBJZiB0aGVyZSBpcyBhbm8gdmlkZW8gY29kZWMgYXQgYWxsLCBhbHdheXMganVzdCByZXR1cm4gYSBzaW5nbGVcbiAgLy8gYXVkaW8vPGNvbnRhaW5lcj4gbWltZS10eXBlXG4gIGlmICghY29kZWNTdHJpbmdzLnZpZGVvKSB7XG4gICAgcmV0dXJuIFtqdXN0QXVkaW9dO1xuICB9XG5cbiAgLy8gV2hlbiBub3QgdXNpbmcgc2VwYXJhdGUgYXVkaW8gbWVkaWEgZ3JvdXBzLCBhdWRpbyBhbmQgdmlkZW8gaXNcbiAgLy8gKmFsd2F5cyogbXV4ZWRcbiAgcmV0dXJuIFtib3RoVmlkZW9BdWRpb107XG59O1xuXG5leHBvcnRzLm1pbWVUeXBlc0ZvclBsYXlsaXN0XyA9IG1pbWVUeXBlc0ZvclBsYXlsaXN0Xztcbi8qKlxuICogdGhlIG1hc3RlciBwbGF5bGlzdCBjb250cm9sbGVyIGNvbnRyb2xsZXIgYWxsIGludGVyYWN0b25zXG4gKiBiZXR3ZWVuIHBsYXlsaXN0cyBhbmQgc2VnbWVudGxvYWRlcnMuIEF0IHRoaXMgdGltZSB0aGlzIG1haW5seVxuICogaW52b2x2ZXMgYSBtYXN0ZXIgcGxheWxpc3QgYW5kIGEgc2VyaWVzIG9mIGF1ZGlvIHBsYXlsaXN0c1xuICogaWYgdGhleSBhcmUgYXZhaWxhYmxlXG4gKlxuICogQGNsYXNzIE1hc3RlclBsYXlsaXN0Q29udHJvbGxlclxuICogQGV4dGVuZHMgdmlkZW9qcy5FdmVudFRhcmdldFxuICovXG5cbnZhciBNYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKF92aWRlb2pzJEV2ZW50VGFyZ2V0KSB7XG4gIF9pbmhlcml0cyhNYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXIsIF92aWRlb2pzJEV2ZW50VGFyZ2V0KTtcblxuICBmdW5jdGlvbiBNYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFzdGVyUGxheWxpc3RDb250cm9sbGVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKE1hc3RlclBsYXlsaXN0Q29udHJvbGxlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHVybCA9IG9wdGlvbnMudXJsO1xuICAgIHZhciB3aXRoQ3JlZGVudGlhbHMgPSBvcHRpb25zLndpdGhDcmVkZW50aWFscztcbiAgICB2YXIgbW9kZSA9IG9wdGlvbnMubW9kZTtcbiAgICB2YXIgdGVjaCA9IG9wdGlvbnMudGVjaDtcbiAgICB2YXIgYmFuZHdpZHRoID0gb3B0aW9ucy5iYW5kd2lkdGg7XG4gICAgdmFyIGV4dGVybkhscyA9IG9wdGlvbnMuZXh0ZXJuSGxzO1xuICAgIHZhciB1c2VDdWVUYWdzID0gb3B0aW9ucy51c2VDdWVUYWdzO1xuICAgIHZhciBibGFja2xpc3REdXJhdGlvbiA9IG9wdGlvbnMuYmxhY2tsaXN0RHVyYXRpb247XG4gICAgdmFyIGVuYWJsZUxvd0luaXRpYWxQbGF5bGlzdCA9IG9wdGlvbnMuZW5hYmxlTG93SW5pdGlhbFBsYXlsaXN0O1xuXG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSBub24tZW1wdHkgcGxheWxpc3QgVVJMIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgSGxzID0gZXh0ZXJuSGxzO1xuXG4gICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHM7XG4gICAgdGhpcy50ZWNoXyA9IHRlY2g7XG4gICAgdGhpcy5obHNfID0gdGVjaC5obHM7XG4gICAgdGhpcy5tb2RlXyA9IG1vZGU7XG4gICAgdGhpcy51c2VDdWVUYWdzXyA9IHVzZUN1ZVRhZ3M7XG4gICAgdGhpcy5ibGFja2xpc3REdXJhdGlvbiA9IGJsYWNrbGlzdER1cmF0aW9uO1xuICAgIHRoaXMuZW5hYmxlTG93SW5pdGlhbFBsYXlsaXN0ID0gZW5hYmxlTG93SW5pdGlhbFBsYXlsaXN0O1xuICAgIGlmICh0aGlzLnVzZUN1ZVRhZ3NfKSB7XG4gICAgICB0aGlzLmN1ZVRhZ3NUcmFja18gPSB0aGlzLnRlY2hfLmFkZFRleHRUcmFjaygnbWV0YWRhdGEnLCAnYWQtY3VlcycpO1xuICAgICAgdGhpcy5jdWVUYWdzVHJhY2tfLmluQmFuZE1ldGFkYXRhVHJhY2tEaXNwYXRjaFR5cGUgPSAnJztcbiAgICB9XG5cbiAgICB0aGlzLnJlcXVlc3RPcHRpb25zXyA9IHtcbiAgICAgIHdpdGhDcmVkZW50aWFsczogdGhpcy53aXRoQ3JlZGVudGlhbHMsXG4gICAgICB0aW1lb3V0OiBudWxsXG4gICAgfTtcblxuICAgIHRoaXMubWVkaWFUeXBlc18gPSAoMCwgX21lZGlhR3JvdXBzLmNyZWF0ZU1lZGlhVHlwZXMpKCk7XG5cbiAgICB0aGlzLm1lZGlhU291cmNlID0gbmV3IF92aWRlb0pzMlsnZGVmYXVsdCddLk1lZGlhU291cmNlKHsgbW9kZTogbW9kZSB9KTtcblxuICAgIC8vIGxvYWQgdGhlIG1lZGlhIHNvdXJjZSBpbnRvIHRoZSBwbGF5ZXJcbiAgICB0aGlzLm1lZGlhU291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLmhhbmRsZVNvdXJjZU9wZW5fLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5zZWVrYWJsZV8gPSBfdmlkZW9KczJbJ2RlZmF1bHQnXS5jcmVhdGVUaW1lUmFuZ2VzKCk7XG4gICAgdGhpcy5oYXNQbGF5ZWRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLnN5bmNDb250cm9sbGVyXyA9IG5ldyBfc3luY0NvbnRyb2xsZXIyWydkZWZhdWx0J10ob3B0aW9ucyk7XG4gICAgdGhpcy5zZWdtZW50TWV0YWRhdGFUcmFja18gPSB0ZWNoLmFkZFJlbW90ZVRleHRUcmFjayh7XG4gICAgICBraW5kOiAnbWV0YWRhdGEnLFxuICAgICAgbGFiZWw6ICdzZWdtZW50LW1ldGFkYXRhJ1xuICAgIH0sIGZhbHNlKS50cmFjaztcblxuICAgIHRoaXMuZGVjcnlwdGVyXyA9ICgwLCBfd2Vid29ya2lmeTJbJ2RlZmF1bHQnXSkoX2RlY3J5cHRlcldvcmtlcjJbJ2RlZmF1bHQnXSk7XG5cbiAgICB2YXIgc2VnbWVudExvYWRlclNldHRpbmdzID0ge1xuICAgICAgaGxzOiB0aGlzLmhsc18sXG4gICAgICBtZWRpYVNvdXJjZTogdGhpcy5tZWRpYVNvdXJjZSxcbiAgICAgIGN1cnJlbnRUaW1lOiB0aGlzLnRlY2hfLmN1cnJlbnRUaW1lLmJpbmQodGhpcy50ZWNoXyksXG4gICAgICBzZWVrYWJsZTogZnVuY3Rpb24gc2Vla2FibGUoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5zZWVrYWJsZSgpO1xuICAgICAgfSxcbiAgICAgIHNlZWtpbmc6IGZ1bmN0aW9uIHNlZWtpbmcoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy50ZWNoXy5zZWVraW5nKCk7XG4gICAgICB9LFxuICAgICAgZHVyYXRpb246IGZ1bmN0aW9uIGR1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMubWVkaWFTb3VyY2UuZHVyYXRpb247XG4gICAgICB9LFxuICAgICAgaGFzUGxheWVkOiBmdW5jdGlvbiBoYXNQbGF5ZWQoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5oYXNQbGF5ZWRfKCk7XG4gICAgICB9LFxuICAgICAgZ29hbEJ1ZmZlckxlbmd0aDogZnVuY3Rpb24gZ29hbEJ1ZmZlckxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmdvYWxCdWZmZXJMZW5ndGgoKTtcbiAgICAgIH0sXG4gICAgICBiYW5kd2lkdGg6IGJhbmR3aWR0aCxcbiAgICAgIHN5bmNDb250cm9sbGVyOiB0aGlzLnN5bmNDb250cm9sbGVyXyxcbiAgICAgIGRlY3J5cHRlcjogdGhpcy5kZWNyeXB0ZXJfXG4gICAgfTtcblxuICAgIC8vIHNldHVwIHBsYXlsaXN0IGxvYWRlcnNcbiAgICB0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXyA9IG5ldyBfcGxheWxpc3RMb2FkZXIyWydkZWZhdWx0J10odXJsLCB0aGlzLmhsc18sIHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICB0aGlzLnNldHVwTWFzdGVyUGxheWxpc3RMb2FkZXJMaXN0ZW5lcnNfKCk7XG5cbiAgICAvLyBzZXR1cCBzZWdtZW50IGxvYWRlcnNcbiAgICAvLyBjb21iaW5lZCBhdWRpby92aWRlbyBvciBqdXN0IHZpZGVvIHdoZW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrIGlzIHNlbGVjdGVkXG4gICAgdGhpcy5tYWluU2VnbWVudExvYWRlcl8gPSBuZXcgX3NlZ21lbnRMb2FkZXIyWydkZWZhdWx0J10oX3ZpZGVvSnMyWydkZWZhdWx0J10ubWVyZ2VPcHRpb25zKHNlZ21lbnRMb2FkZXJTZXR0aW5ncywge1xuICAgICAgc2VnbWVudE1ldGFkYXRhVHJhY2s6IHRoaXMuc2VnbWVudE1ldGFkYXRhVHJhY2tfLFxuICAgICAgbG9hZGVyVHlwZTogJ21haW4nXG4gICAgfSksIG9wdGlvbnMpO1xuXG4gICAgLy8gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgdGhpcy5hdWRpb1NlZ21lbnRMb2FkZXJfID0gbmV3IF9zZWdtZW50TG9hZGVyMlsnZGVmYXVsdCddKF92aWRlb0pzMlsnZGVmYXVsdCddLm1lcmdlT3B0aW9ucyhzZWdtZW50TG9hZGVyU2V0dGluZ3MsIHtcbiAgICAgIGxvYWRlclR5cGU6ICdhdWRpbydcbiAgICB9KSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnN1YnRpdGxlU2VnbWVudExvYWRlcl8gPSBuZXcgX3Z0dFNlZ21lbnRMb2FkZXIyWydkZWZhdWx0J10oX3ZpZGVvSnMyWydkZWZhdWx0J10ubWVyZ2VPcHRpb25zKHNlZ21lbnRMb2FkZXJTZXR0aW5ncywge1xuICAgICAgbG9hZGVyVHlwZTogJ3Z0dCdcbiAgICB9KSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnNldHVwU2VnbWVudExvYWRlckxpc3RlbmVyc18oKTtcblxuICAgIC8vIENyZWF0ZSBTZWdtZW50TG9hZGVyIHN0YXQtZ2V0dGVyc1xuICAgIGxvYWRlclN0YXRzLmZvckVhY2goZnVuY3Rpb24gKHN0YXQpIHtcbiAgICAgIF90aGlzW3N0YXQgKyAnXyddID0gc3VtTG9hZGVyU3RhdC5iaW5kKF90aGlzLCBzdGF0KTtcbiAgICB9KTtcblxuICAgIHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLmxvYWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBldmVudCBoYW5kbGVycyBvbiB0aGUgbWFzdGVyIHBsYXlsaXN0IGxvYWRlci4gQSBoZWxwZXJcbiAgICogZnVuY3Rpb24gZm9yIGNvbnN0cnVjdGlvbiB0aW1lLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoTWFzdGVyUGxheWxpc3RDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ3NldHVwTWFzdGVyUGxheWxpc3RMb2FkZXJMaXN0ZW5lcnNfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBNYXN0ZXJQbGF5bGlzdExvYWRlckxpc3RlbmVyc18oKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ub24oJ2xvYWRlZG1ldGFkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWVkaWEgPSBfdGhpczIubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1lZGlhKCk7XG4gICAgICAgIHZhciByZXF1ZXN0VGltZW91dCA9IF90aGlzMi5tYXN0ZXJQbGF5bGlzdExvYWRlcl8udGFyZ2V0RHVyYXRpb24gKiAxLjUgKiAxMDAwO1xuXG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgYXZhaWxhYmxlIHBsYXlsaXN0cywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyB0aW1lb3V0IHRoZSByZXF1ZXN0LlxuICAgICAgICBpZiAoKDAsIF9wbGF5bGlzdEpzLmlzTG93ZXN0RW5hYmxlZFJlbmRpdGlvbikoX3RoaXMyLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5tYXN0ZXIsIF90aGlzMi5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKSkpIHtcbiAgICAgICAgICBfdGhpczIucmVxdWVzdE9wdGlvbnNfLnRpbWVvdXQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzMi5yZXF1ZXN0T3B0aW9uc18udGltZW91dCA9IHJlcXVlc3RUaW1lb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpc24ndCBhIGxpdmUgdmlkZW8gYW5kIHByZWxvYWQgcGVybWl0cywgc3RhcnRcbiAgICAgICAgLy8gZG93bmxvYWRpbmcgc2VnbWVudHNcbiAgICAgICAgaWYgKG1lZGlhLmVuZExpc3QgJiYgX3RoaXMyLnRlY2hfLnByZWxvYWQoKSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgX3RoaXMyLm1haW5TZWdtZW50TG9hZGVyXy5wbGF5bGlzdChtZWRpYSwgX3RoaXMyLnJlcXVlc3RPcHRpb25zXyk7XG4gICAgICAgICAgX3RoaXMyLm1haW5TZWdtZW50TG9hZGVyXy5sb2FkKCk7XG4gICAgICAgIH1cblxuICAgICAgICAoMCwgX21lZGlhR3JvdXBzLnNldHVwTWVkaWFHcm91cHMpKHtcbiAgICAgICAgICBzZWdtZW50TG9hZGVyczoge1xuICAgICAgICAgICAgQVVESU86IF90aGlzMi5hdWRpb1NlZ21lbnRMb2FkZXJfLFxuICAgICAgICAgICAgU1VCVElUTEVTOiBfdGhpczIuc3VidGl0bGVTZWdtZW50TG9hZGVyXyxcbiAgICAgICAgICAgIG1haW46IF90aGlzMi5tYWluU2VnbWVudExvYWRlcl9cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRlY2g6IF90aGlzMi50ZWNoXyxcbiAgICAgICAgICByZXF1ZXN0T3B0aW9uczogX3RoaXMyLnJlcXVlc3RPcHRpb25zXyxcbiAgICAgICAgICBtYXN0ZXJQbGF5bGlzdExvYWRlcjogX3RoaXMyLm1hc3RlclBsYXlsaXN0TG9hZGVyXyxcbiAgICAgICAgICBtb2RlOiBfdGhpczIubW9kZV8sXG4gICAgICAgICAgaGxzOiBfdGhpczIuaGxzXyxcbiAgICAgICAgICBtYXN0ZXI6IF90aGlzMi5tYXN0ZXIoKSxcbiAgICAgICAgICBtZWRpYVR5cGVzOiBfdGhpczIubWVkaWFUeXBlc18sXG4gICAgICAgICAgYmxhY2tsaXN0Q3VycmVudFBsYXlsaXN0OiBfdGhpczIuYmxhY2tsaXN0Q3VycmVudFBsYXlsaXN0LmJpbmQoX3RoaXMyKVxuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpczIudHJpZ2dlclByZXNlbmNlVXNhZ2VfKF90aGlzMi5tYXN0ZXIoKSwgbWVkaWEpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX3RoaXMyLnNldHVwU291cmNlQnVmZmVyc18oKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIF92aWRlb0pzMlsnZGVmYXVsdCddLmxvZy53YXJuKCdGYWlsZWQgdG8gY3JlYXRlIFNvdXJjZUJ1ZmZlcnMnLCBlKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLm1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCdkZWNvZGUnKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczIuc2V0dXBGaXJzdFBsYXkoKTtcblxuICAgICAgICBfdGhpczIudHJpZ2dlcignc2VsZWN0ZWRpbml0aWFsbWVkaWEnKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5vbignbG9hZGVkcGxheWxpc3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1cGRhdGVkUGxheWxpc3QgPSBfdGhpczIubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1lZGlhKCk7XG5cbiAgICAgICAgaWYgKCF1cGRhdGVkUGxheWxpc3QpIHtcbiAgICAgICAgICB2YXIgc2VsZWN0ZWRNZWRpYSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChfdGhpczIuZW5hYmxlTG93SW5pdGlhbFBsYXlsaXN0KSB7XG4gICAgICAgICAgICBzZWxlY3RlZE1lZGlhID0gX3RoaXMyLnNlbGVjdEluaXRpYWxQbGF5bGlzdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghc2VsZWN0ZWRNZWRpYSkge1xuICAgICAgICAgICAgc2VsZWN0ZWRNZWRpYSA9IF90aGlzMi5zZWxlY3RQbGF5bGlzdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzMi5pbml0aWFsTWVkaWFfID0gc2VsZWN0ZWRNZWRpYTtcbiAgICAgICAgICBfdGhpczIubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1lZGlhKF90aGlzMi5pbml0aWFsTWVkaWFfKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMyLnVzZUN1ZVRhZ3NfKSB7XG4gICAgICAgICAgX3RoaXMyLnVwZGF0ZUFkQ3Vlc18odXBkYXRlZFBsYXlsaXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IENyZWF0ZSBhIG5ldyBldmVudCBvbiB0aGUgUGxheWxpc3RMb2FkZXIgdGhhdCBzaWduYWxzXG4gICAgICAgIC8vIHRoYXQgdGhlIHNlZ21lbnRzIGhhdmUgY2hhbmdlZCBpbiBzb21lIHdheSBhbmQgdXNlIHRoYXQgdG9cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBTZWdtZW50TG9hZGVyIGluc3RlYWQgb2YgZG9pbmcgaXQgdHdpY2UgaGVyZSBhbmRcbiAgICAgICAgLy8gb24gYG1lZGlhY2hhbmdlYFxuICAgICAgICBfdGhpczIubWFpblNlZ21lbnRMb2FkZXJfLnBsYXlsaXN0KHVwZGF0ZWRQbGF5bGlzdCwgX3RoaXMyLnJlcXVlc3RPcHRpb25zXyk7XG4gICAgICAgIF90aGlzMi51cGRhdGVEdXJhdGlvbigpO1xuXG4gICAgICAgIC8vIElmIHRoZSBwbGF5ZXIgaXNuJ3QgcGF1c2VkLCBlbnN1cmUgdGhhdCB0aGUgc2VnbWVudCBsb2FkZXIgaXMgcnVubmluZyxcbiAgICAgICAgLy8gYXMgaXQgaXMgcG9zc2libGUgdGhhdCBpdCB3YXMgdGVtcG9yYXJpbHkgc3RvcHBlZCB3aGlsZSB3YWl0aW5nIGZvclxuICAgICAgICAvLyBhIHBsYXlsaXN0IChlLmcuLCBpbiBjYXNlIHRoZSBwbGF5bGlzdCBlcnJvcmVkIGFuZCB3ZSByZS1yZXF1ZXN0ZWQgaXQpLlxuICAgICAgICBpZiAoIV90aGlzMi50ZWNoXy5wYXVzZWQoKSkge1xuICAgICAgICAgIF90aGlzMi5tYWluU2VnbWVudExvYWRlcl8ubG9hZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1cGRhdGVkUGxheWxpc3QuZW5kTGlzdCkge1xuICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYWRkU2Vla2FibGVSYW5nZSA9IGZ1bmN0aW9uIGFkZFNlZWthYmxlUmFuZ2UoKSB7XG4gICAgICAgICAgICAgIHZhciBzZWVrYWJsZSA9IF90aGlzMi5zZWVrYWJsZSgpO1xuXG4gICAgICAgICAgICAgIGlmIChzZWVrYWJsZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpczIubWVkaWFTb3VyY2UuYWRkU2Vla2FibGVSYW5nZV8oc2Vla2FibGUuc3RhcnQoMCksIHNlZWthYmxlLmVuZCgwKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChfdGhpczIuZHVyYXRpb24oKSAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb25EdXJhdGlvbmNoYW5nZSA9IGZ1bmN0aW9uIG9uRHVyYXRpb25jaGFuZ2UoKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMyLmR1cmF0aW9uKCkgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFNlZWthYmxlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMi50ZWNoXy5vbmUoJ2R1cmF0aW9uY2hhbmdlJywgb25EdXJhdGlvbmNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIF90aGlzMi50ZWNoXy5vbmUoJ2R1cmF0aW9uY2hhbmdlJywgb25EdXJhdGlvbmNoYW5nZSk7XG4gICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGRTZWVrYWJsZVJhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmJsYWNrbGlzdEN1cnJlbnRQbGF5bGlzdChfdGhpczIubWFzdGVyUGxheWxpc3RMb2FkZXJfLmVycm9yKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5vbignbWVkaWFjaGFuZ2luZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLm1haW5TZWdtZW50TG9hZGVyXy5hYm9ydCgpO1xuICAgICAgICBfdGhpczIubWFpblNlZ21lbnRMb2FkZXJfLnBhdXNlKCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ub24oJ21lZGlhY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWVkaWEgPSBfdGhpczIubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1lZGlhKCk7XG4gICAgICAgIHZhciByZXF1ZXN0VGltZW91dCA9IF90aGlzMi5tYXN0ZXJQbGF5bGlzdExvYWRlcl8udGFyZ2V0RHVyYXRpb24gKiAxLjUgKiAxMDAwO1xuXG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgYXZhaWxhYmxlIHBsYXlsaXN0cywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyB0aW1lb3V0IHRoZSByZXF1ZXN0LlxuICAgICAgICBpZiAoKDAsIF9wbGF5bGlzdEpzLmlzTG93ZXN0RW5hYmxlZFJlbmRpdGlvbikoX3RoaXMyLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5tYXN0ZXIsIF90aGlzMi5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKSkpIHtcbiAgICAgICAgICBfdGhpczIucmVxdWVzdE9wdGlvbnNfLnRpbWVvdXQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzMi5yZXF1ZXN0T3B0aW9uc18udGltZW91dCA9IHJlcXVlc3RUaW1lb3V0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgbmV3IGV2ZW50IG9uIHRoZSBQbGF5bGlzdExvYWRlciB0aGF0IHNpZ25hbHNcbiAgICAgICAgLy8gdGhhdCB0aGUgc2VnbWVudHMgaGF2ZSBjaGFuZ2VkIGluIHNvbWUgd2F5IGFuZCB1c2UgdGhhdCB0b1xuICAgICAgICAvLyB1cGRhdGUgdGhlIFNlZ21lbnRMb2FkZXIgaW5zdGVhZCBvZiBkb2luZyBpdCB0d2ljZSBoZXJlIGFuZFxuICAgICAgICAvLyBvbiBgbG9hZGVkcGxheWxpc3RgXG4gICAgICAgIF90aGlzMi5tYWluU2VnbWVudExvYWRlcl8ucGxheWxpc3QobWVkaWEsIF90aGlzMi5yZXF1ZXN0T3B0aW9uc18pO1xuICAgICAgICBfdGhpczIubWFpblNlZ21lbnRMb2FkZXJfLmxvYWQoKTtcblxuICAgICAgICBfdGhpczIudGVjaF8udHJpZ2dlcih7XG4gICAgICAgICAgdHlwZTogJ21lZGlhY2hhbmdlJyxcbiAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLm9uKCdwbGF5bGlzdHVuY2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVwZGF0ZWRQbGF5bGlzdCA9IF90aGlzMi5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKTtcbiAgICAgICAgdmFyIHBsYXlsaXN0T3V0ZGF0ZWQgPSBfdGhpczIuc3R1Y2tBdFBsYXlsaXN0RW5kXyh1cGRhdGVkUGxheWxpc3QpO1xuXG4gICAgICAgIGlmIChwbGF5bGlzdE91dGRhdGVkKSB7XG4gICAgICAgICAgLy8gUGxheWxpc3QgaGFzIHN0b3BwZWQgdXBkYXRpbmcgYW5kIHdlJ3JlIHN0dWNrIGF0IGl0cyBlbmQuIFRyeSB0b1xuICAgICAgICAgIC8vIGJsYWNrbGlzdCBpdCBhbmQgc3dpdGNoIHRvIGFub3RoZXIgcGxheWxpc3QgaW4gdGhlIGhvcGUgdGhhdCB0aGF0XG4gICAgICAgICAgLy8gb25lIGlzIHVwZGF0aW5nIChhbmQgZ2l2ZSB0aGUgcGxheWVyIGEgY2hhbmNlIHRvIHJlLWFkanVzdCB0byB0aGVcbiAgICAgICAgICAvLyBzYWZlIGxpdmUgcG9pbnQpLlxuICAgICAgICAgIF90aGlzMi5ibGFja2xpc3RDdXJyZW50UGxheWxpc3Qoe1xuICAgICAgICAgICAgbWVzc2FnZTogJ1BsYXlsaXN0IG5vIGxvbmdlciB1cGRhdGluZy4nXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gdXNlZnVsIGZvciBtb25pdG9yaW5nIFFvU1xuICAgICAgICAgIF90aGlzMi50ZWNoXy50cmlnZ2VyKCdwbGF5bGlzdHN0dWNrJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5vbigncmVuZGl0aW9uZGlzYWJsZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi50ZWNoXy50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy1yZW5kaXRpb24tZGlzYWJsZWQnIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5vbigncmVuZGl0aW9uZW5hYmxlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnRlY2hfLnRyaWdnZXIoeyB0eXBlOiAndXNhZ2UnLCBuYW1lOiAnaGxzLXJlbmRpdGlvbi1lbmFibGVkJyB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIGZ1bmN0aW9uIGZvciB0cmlnZ2VycmluZyBwcmVzZW5jZSB1c2FnZSBldmVudHMgb25jZSBwZXIgc291cmNlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAndHJpZ2dlclByZXNlbmNlVXNhZ2VfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJpZ2dlclByZXNlbmNlVXNhZ2VfKG1hc3RlciwgbWVkaWEpIHtcbiAgICAgIHZhciBtZWRpYUdyb3VwcyA9IG1hc3Rlci5tZWRpYUdyb3VwcyB8fCB7fTtcbiAgICAgIHZhciBkZWZhdWx0RGVtdXhlZCA9IHRydWU7XG4gICAgICB2YXIgYXVkaW9Hcm91cEtleXMgPSBPYmplY3Qua2V5cyhtZWRpYUdyb3Vwcy5BVURJTyk7XG5cbiAgICAgIGZvciAodmFyIG1lZGlhR3JvdXAgaW4gbWVkaWFHcm91cHMuQVVESU8pIHtcbiAgICAgICAgZm9yICh2YXIgbGFiZWwgaW4gbWVkaWFHcm91cHMuQVVESU9bbWVkaWFHcm91cF0pIHtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IG1lZGlhR3JvdXBzLkFVRElPW21lZGlhR3JvdXBdW2xhYmVsXTtcblxuICAgICAgICAgIGlmICghcHJvcGVydGllcy51cmkpIHtcbiAgICAgICAgICAgIGRlZmF1bHREZW11eGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0RGVtdXhlZCkge1xuICAgICAgICB0aGlzLnRlY2hfLnRyaWdnZXIoeyB0eXBlOiAndXNhZ2UnLCBuYW1lOiAnaGxzLWRlbXV4ZWQnIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0LmtleXMobWVkaWFHcm91cHMuU1VCVElUTEVTKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy50ZWNoXy50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy13ZWJ2dHQnIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoSGxzLlBsYXlsaXN0LmlzQWVzKG1lZGlhKSkge1xuICAgICAgICB0aGlzLnRlY2hfLnRyaWdnZXIoeyB0eXBlOiAndXNhZ2UnLCBuYW1lOiAnaGxzLWFlcycgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChIbHMuUGxheWxpc3QuaXNGbXA0KG1lZGlhKSkge1xuICAgICAgICB0aGlzLnRlY2hfLnRyaWdnZXIoeyB0eXBlOiAndXNhZ2UnLCBuYW1lOiAnaGxzLWZtcDQnIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXVkaW9Hcm91cEtleXMubGVuZ3RoICYmIE9iamVjdC5rZXlzKG1lZGlhR3JvdXBzLkFVRElPW2F1ZGlvR3JvdXBLZXlzWzBdXSkubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnRlY2hfLnRyaWdnZXIoeyB0eXBlOiAndXNhZ2UnLCBuYW1lOiAnaGxzLWFsdGVybmF0ZS1hdWRpbycgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnVzZUN1ZVRhZ3NfKSB7XG4gICAgICAgIHRoaXMudGVjaF8udHJpZ2dlcih7IHR5cGU6ICd1c2FnZScsIG5hbWU6ICdobHMtcGxheWxpc3QtY3VlLXRhZ3MnIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzIG9uIHRoZSBzZWdtZW50IGxvYWRlcnMuIEEgaGVscGVyIGZ1bmN0aW9uXG4gICAgICogZm9yIGNvbnN0cnVjdGlvbiB0aW1lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldHVwU2VnbWVudExvYWRlckxpc3RlbmVyc18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cFNlZ21lbnRMb2FkZXJMaXN0ZW5lcnNfKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMubWFpblNlZ21lbnRMb2FkZXJfLm9uKCdiYW5kd2lkdGh1cGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0UGxheWxpc3QgPSBfdGhpczMuc2VsZWN0UGxheWxpc3QoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRQbGF5bGlzdCA9IF90aGlzMy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKTtcbiAgICAgICAgdmFyIGJ1ZmZlcmVkID0gX3RoaXMzLnRlY2hfLmJ1ZmZlcmVkKCk7XG4gICAgICAgIHZhciBmb3J3YXJkQnVmZmVyID0gYnVmZmVyZWQubGVuZ3RoID8gYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkLmxlbmd0aCAtIDEpIC0gX3RoaXMzLnRlY2hfLmN1cnJlbnRUaW1lKCkgOiAwO1xuXG4gICAgICAgIHZhciBidWZmZXJMb3dXYXRlckxpbmUgPSBfdGhpczMuYnVmZmVyTG93V2F0ZXJMaW5lKCk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHBsYXlsaXN0IGlzIGxpdmUsIHRoZW4gd2Ugd2FudCB0byBub3QgdGFrZSBsb3cgd2F0ZXIgbGluZSBpbnRvIGFjY291bnQuXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSBpbiBMSVZFLCB0aGUgcGxheWVyIHBsYXlzIDMgc2VnbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAvLyBwbGF5bGlzdCwgYW5kIGlmIGBCVUZGRVJfTE9XX1dBVEVSX0xJTkVgIGlzIGdyZWF0ZXIgdGhhbiB0aGUgZHVyYXRpb24gYXZhaWxibGVcbiAgICAgICAgLy8gaW4gdGhvc2Ugc2VnbWVudHMsIGEgdmlld2VyIHdpbGwgbmV2ZXIgZXhwZXJpZW5jZSBhIHJlbmRpdGlvbiB1cHN3aXRjaC5cbiAgICAgICAgaWYgKCFjdXJyZW50UGxheWxpc3QuZW5kTGlzdCB8fFxuICAgICAgICAvLyBGb3IgdGhlIHNhbWUgcmVhc29uIGFzIExJVkUsIHdlIGlnbm9yZSB0aGUgbG93IHdhdGVyIGxpbmUgd2hlbiB0aGUgVk9EXG4gICAgICAgIC8vIGR1cmF0aW9uIGlzIGJlbG93IHRoZSBtYXggcG90ZW50aWFsIGxvdyB3YXRlciBsaW5lXG4gICAgICAgIF90aGlzMy5kdXJhdGlvbigpIDwgX2NvbmZpZzJbJ2RlZmF1bHQnXS5NQVhfQlVGRkVSX0xPV19XQVRFUl9MSU5FIHx8XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gc3dpdGNoIGRvd24gdG8gbG93ZXIgcmVzb2x1dGlvbnMgcXVpY2tseSB0byBjb250aW51ZSBwbGF5YmFjaywgYnV0XG4gICAgICAgIG5leHRQbGF5bGlzdC5hdHRyaWJ1dGVzLkJBTkRXSURUSCA8IGN1cnJlbnRQbGF5bGlzdC5hdHRyaWJ1dGVzLkJBTkRXSURUSCB8fFxuICAgICAgICAvLyBlbnN1cmUgd2UgaGF2ZSBzb21lIGJ1ZmZlciBiZWZvcmUgd2Ugc3dpdGNoIHVwIHRvIHByZXZlbnQgdXMgcnVubmluZyBvdXQgb2ZcbiAgICAgICAgLy8gYnVmZmVyIHdoaWxlIGxvYWRpbmcgYSBoaWdoZXIgcmVuZGl0aW9uLlxuICAgICAgICBmb3J3YXJkQnVmZmVyID49IGJ1ZmZlckxvd1dhdGVyTGluZSkge1xuICAgICAgICAgIF90aGlzMy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEobmV4dFBsYXlsaXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMy50ZWNoXy50cmlnZ2VyKCdiYW5kd2lkdGh1cGRhdGUnKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tYWluU2VnbWVudExvYWRlcl8ub24oJ3Byb2dyZXNzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMudHJpZ2dlcigncHJvZ3Jlc3MnKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5vbignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5ibGFja2xpc3RDdXJyZW50UGxheWxpc3QoX3RoaXMzLm1haW5TZWdtZW50TG9hZGVyXy5lcnJvcigpKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5vbignc3luY2luZm91cGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5vblN5bmNJbmZvVXBkYXRlXygpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubWFpblNlZ21lbnRMb2FkZXJfLm9uKCd0aW1lc3RhbXBvZmZzZXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy50ZWNoXy50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy10aW1lc3RhbXAtb2Zmc2V0JyB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hdWRpb1NlZ21lbnRMb2FkZXJfLm9uKCdzeW5jaW5mb3VwZGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLm9uU3luY0luZm9VcGRhdGVfKCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5tYWluU2VnbWVudExvYWRlcl8ub24oJ2VuZGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMub25FbmRPZlN0cmVhbSgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubWFpblNlZ21lbnRMb2FkZXJfLm9uKCdlYXJseWFib3J0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMuYmxhY2tsaXN0Q3VycmVudFBsYXlsaXN0KHtcbiAgICAgICAgICBtZXNzYWdlOiAnQWJvcnRlZCBlYXJseSBiZWNhdXNlIHRoZXJlIGlzblxcJ3QgZW5vdWdoIGJhbmR3aWR0aCB0byBjb21wbGV0ZSB0aGUgJyArICdyZXF1ZXN0IHdpdGhvdXQgcmVidWZmZXJpbmcuJ1xuICAgICAgICB9LCBBQk9SVF9FQVJMWV9CTEFDS0xJU1RfU0VDT05EUyk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5tYWluU2VnbWVudExvYWRlcl8ub24oJ3Jlc2V0ZXZlcnl0aGluZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSWYgcGxheWluZyBhbiBNVFMgc3RyZWFtLCBhIHZpZGVvanMuTWVkaWFTb3VyY2UgaXMgbGlzdGVuaW5nIGZvclxuICAgICAgICAvLyBobHMtcmVzZXQgdG8gcmVzZXQgY2FwdGlvbiBwYXJzaW5nIHN0YXRlIGluIHRoZSB0cmFuc211eGVyXG4gICAgICAgIF90aGlzMy50ZWNoXy50cmlnZ2VyKCdobHMtcmVzZXQnKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5vbignc2VnbWVudHRpbWVtYXBwaW5nJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIElmIHBsYXlpbmcgYW4gTVRTIHN0cmVhbSBpbiBodG1sLCBhIHZpZGVvanMuTWVkaWFTb3VyY2UgaXMgbGlzdGVuaW5nIGZvclxuICAgICAgICAvLyBobHMtc2VnbWVudC10aW1lLW1hcHBpbmcgdXBkYXRlIGl0cyBpbnRlcm5hbCBtYXBwaW5nIG9mIHN0cmVhbSB0byBkaXNwbGF5IHRpbWVcbiAgICAgICAgX3RoaXMzLnRlY2hfLnRyaWdnZXIoe1xuICAgICAgICAgIHR5cGU6ICdobHMtc2VnbWVudC10aW1lLW1hcHBpbmcnLFxuICAgICAgICAgIG1hcHBpbmc6IGV2ZW50Lm1hcHBpbmdcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5hdWRpb1NlZ21lbnRMb2FkZXJfLm9uKCdlbmRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLm9uRW5kT2ZTdHJlYW0oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21lZGlhU2Vjb25kc0xvYWRlZF8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZWRpYVNlY29uZHNMb2FkZWRfKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuYXVkaW9TZWdtZW50TG9hZGVyXy5tZWRpYVNlY29uZHNMb2FkZWQgKyB0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5tZWRpYVNlY29uZHNMb2FkZWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgbG9hZCBvbiBvdXIgU2VnbWVudExvYWRlcnNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2xvYWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgdGhpcy5tYWluU2VnbWVudExvYWRlcl8ubG9hZCgpO1xuICAgICAgaWYgKHRoaXMubWVkaWFUeXBlc18uQVVESU8uYWN0aXZlUGxheWxpc3RMb2FkZXIpIHtcbiAgICAgICAgdGhpcy5hdWRpb1NlZ21lbnRMb2FkZXJfLmxvYWQoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1lZGlhVHlwZXNfLlNVQlRJVExFUy5hY3RpdmVQbGF5bGlzdExvYWRlcikge1xuICAgICAgICB0aGlzLnN1YnRpdGxlU2VnbWVudExvYWRlcl8ubG9hZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlLXR1bmUgcGxheWJhY2sgcXVhbGl0eSBsZXZlbCBmb3IgdGhlIGN1cnJlbnQgcGxheWVyXG4gICAgICogY29uZGl0aW9ucy4gVGhpcyBtZXRob2QgbWF5IHBlcmZvcm0gZGVzdHJ1Y3RpdmUgYWN0aW9ucywgbGlrZVxuICAgICAqIHJlbW92aW5nIGFscmVhZHkgYnVmZmVyZWQgY29udGVudCwgdG8gcmVhZGp1c3QgdGhlIGN1cnJlbnRseVxuICAgICAqIGFjdGl2ZSBwbGF5bGlzdCBxdWlja2x5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2Zhc3RRdWFsaXR5Q2hhbmdlXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhc3RRdWFsaXR5Q2hhbmdlXygpIHtcbiAgICAgIHZhciBtZWRpYSA9IHRoaXMuc2VsZWN0UGxheWxpc3QoKTtcblxuICAgICAgaWYgKG1lZGlhICE9PSB0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5tZWRpYSgpKSB7XG4gICAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1lZGlhKG1lZGlhKTtcblxuICAgICAgICB0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5yZXNldExvYWRlcigpO1xuICAgICAgICAvLyBkb24ndCBuZWVkIHRvIHJlc2V0IGF1ZGlvIGFzIGl0IGlzIHJlc2V0IHdoZW4gbWVkaWEgY2hhbmdlc1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJlZ2luIHBsYXliYWNrLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICBpZiAodGhpcy5zZXR1cEZpcnN0UGxheSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudGVjaF8uZW5kZWQoKSkge1xuICAgICAgICB0aGlzLnRlY2hfLnNldEN1cnJlbnRUaW1lKDApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oYXNQbGF5ZWRfKCkpIHtcbiAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWVrYWJsZSA9IHRoaXMudGVjaF8uc2Vla2FibGUoKTtcblxuICAgICAgLy8gaWYgdGhlIHZpZXdlciBoYXMgcGF1c2VkIGFuZCB3ZSBmZWxsIG91dCBvZiB0aGUgbGl2ZSB3aW5kb3csXG4gICAgICAvLyBzZWVrIGZvcndhcmQgdG8gdGhlIGxpdmUgcG9pbnRcbiAgICAgIGlmICh0aGlzLnRlY2hfLmR1cmF0aW9uKCkgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGlmICh0aGlzLnRlY2hfLmN1cnJlbnRUaW1lKCkgPCBzZWVrYWJsZS5zdGFydCgwKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRlY2hfLnNldEN1cnJlbnRUaW1lKHNlZWthYmxlLmVuZChzZWVrYWJsZS5sZW5ndGggLSAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWVrIHRvIHRoZSBsYXRlc3QgbWVkaWEgcG9zaXRpb24gaWYgdGhpcyBpcyBhIGxpdmUgdmlkZW8gYW5kIHRoZVxuICAgICAqIHBsYXllciBhbmQgdmlkZW8gYXJlIGxvYWRlZCBhbmQgaW5pdGlhbGl6ZWQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzZXR1cEZpcnN0UGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwRmlyc3RQbGF5KCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1lZGlhKCk7XG5cbiAgICAgIC8vIENoZWNrIHRoYXQgZXZlcnl0aGluZyBpcyByZWFkeSB0byBiZWdpbiBidWZmZXJpbmcgZm9yIHRoZSBmaXJzdCBjYWxsIHRvIHBsYXlcbiAgICAgIC8vICBJZiAxKSB0aGVyZSBpcyBubyBhY3RpdmUgbWVkaWFcbiAgICAgIC8vICAgICAyKSB0aGUgcGxheWVyIGlzIHBhdXNlZFxuICAgICAgLy8gICAgIDMpIHRoZSBmaXJzdCBwbGF5IGhhcyBhbHJlYWR5IGJlZW4gc2V0dXBcbiAgICAgIC8vIHRoZW4gZXhpdCBlYXJseVxuICAgICAgaWYgKCFtZWRpYSB8fCB0aGlzLnRlY2hfLnBhdXNlZCgpIHx8IHRoaXMuaGFzUGxheWVkXygpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gd2hlbiB0aGUgdmlkZW8gaXMgYSBsaXZlIHN0cmVhbVxuICAgICAgaWYgKCFtZWRpYS5lbmRMaXN0KSB7XG4gICAgICAgIHZhciBfcmV0MyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNlZWthYmxlID0gX3RoaXM0LnNlZWthYmxlKCk7XG5cbiAgICAgICAgICBpZiAoIXNlZWthYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gd2l0aG91dCBhIHNlZWthYmxlIHJhbmdlLCB0aGUgcGxheWVyIGNhbm5vdCBzZWVrIHRvIGJlZ2luIGJ1ZmZlcmluZyBhdCB0aGUgbGl2ZVxuICAgICAgICAgICAgLy8gcG9pbnRcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHY6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdmlkZW9KczJbJ2RlZmF1bHQnXS5icm93c2VyLklFX1ZFUlNJT04gJiYgX3RoaXM0Lm1vZGVfID09PSAnaHRtbDUnICYmIF90aGlzNC50ZWNoXy5yZWFkeVN0YXRlKCkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIElFMTEgdGhyb3dzIGFuIEludmFsaWRTdGF0ZUVycm9yIGlmIHlvdSB0cnkgdG8gc2V0IGN1cnJlbnRUaW1lIHdoaWxlIHRoZVxuICAgICAgICAgICAgLy8gcmVhZHlTdGF0ZSBpcyAwLCBzbyBpdCBtdXN0IGJlIGRlbGF5ZWQgdW50aWwgdGhlIHRlY2ggZmlyZXMgbG9hZGVkbWV0YWRhdGEuXG4gICAgICAgICAgICBfdGhpczQudGVjaF8ub25lKCdsb2FkZWRtZXRhZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXM0LnRyaWdnZXIoJ2ZpcnN0cGxheScpO1xuICAgICAgICAgICAgICBfdGhpczQudGVjaF8uc2V0Q3VycmVudFRpbWUoc2Vla2FibGUuZW5kKDApKTtcbiAgICAgICAgICAgICAgX3RoaXM0Lmhhc1BsYXllZF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdjogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdHJpZ2dlciBmaXJzdHBsYXkgdG8gaW5mb3JtIHRoZSBzb3VyY2UgaGFuZGxlciB0byBpZ25vcmUgdGhlIG5leHQgc2VlayBldmVudFxuICAgICAgICAgIF90aGlzNC50cmlnZ2VyKCdmaXJzdHBsYXknKTtcbiAgICAgICAgICAvLyBzZWVrIHRvIHRoZSBsaXZlIHBvaW50XG4gICAgICAgICAgX3RoaXM0LnRlY2hfLnNldEN1cnJlbnRUaW1lKHNlZWthYmxlLmVuZCgwKSk7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfcmV0MyA9PT0gJ29iamVjdCcpIHJldHVybiBfcmV0My52O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhhc1BsYXllZF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIC8vIHdlIGNhbiBiZWdpbiBsb2FkaW5nIG5vdyB0aGF0IGV2ZXJ5dGhpbmcgaXMgcmVhZHlcbiAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIHRoZSBzb3VyY2VvcGVuIGV2ZW50IG9uIHRoZSBNZWRpYVNvdXJjZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZVNvdXJjZU9wZW5fJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlU291cmNlT3Blbl8oKSB7XG4gICAgICAvLyBPbmx5IGF0dGVtcHQgdG8gY3JlYXRlIHRoZSBzb3VyY2UgYnVmZmVyIGlmIG5vbmUgYWxyZWFkeSBleGlzdC5cbiAgICAgIC8vIGhhbmRsZVNvdXJjZU9wZW4gaXMgYWxzbyBjYWxsZWQgd2hlbiB3ZSBhcmUgXCJyZS1vcGVuaW5nXCIgYSBzb3VyY2UgYnVmZmVyXG4gICAgICAvLyBhZnRlciBgZW5kT2ZTdHJlYW1gIGhhcyBiZWVuIGNhbGxlZCAoaW4gcmVzcG9uc2UgdG8gYSBzZWVrIGZvciBpbnN0YW5jZSlcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2V0dXBTb3VyY2VCdWZmZXJzXygpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBfdmlkZW9KczJbJ2RlZmF1bHQnXS5sb2cud2FybignRmFpbGVkIHRvIGNyZWF0ZSBTb3VyY2UgQnVmZmVycycsIGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgnZGVjb2RlJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGF1dG9wbGF5IGlzIGVuYWJsZWQsIGJlZ2luIHBsYXliYWNrLiBUaGlzIGlzIGR1cGxpY2F0aXZlIG9mXG4gICAgICAvLyBjb2RlIGluIHZpZGVvLmpzIGJ1dCBpcyByZXF1aXJlZCBiZWNhdXNlIHBsYXkoKSBtdXN0IGJlIGludm9rZWRcbiAgICAgIC8vICphZnRlciogdGhlIG1lZGlhIHNvdXJjZSBoYXMgb3BlbmVkLlxuICAgICAgaWYgKHRoaXMudGVjaF8uYXV0b3BsYXkoKSkge1xuICAgICAgICB0aGlzLnRlY2hfLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmlnZ2VyKCdzb3VyY2VvcGVuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgZW5kT2ZTdHJlYW0gb24gdGhlIG1lZGlhIHNvdXJjZSB3aGVuIGFsbCBhY3RpdmUgc3RyZWFtIHR5cGVzIGhhdmUgY2FsbGVkXG4gICAgICogZW5kT2ZTdHJlYW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJlYW1UeXBlXG4gICAgICogICAgICAgIFN0cmVhbSB0eXBlIG9mIHRoZSBzZWdtZW50IGxvYWRlciB0aGF0IGNhbGxlZCBlbmRPZlN0cmVhbVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdvbkVuZE9mU3RyZWFtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25FbmRPZlN0cmVhbSgpIHtcbiAgICAgIHZhciBpc0VuZE9mU3RyZWFtID0gdGhpcy5tYWluU2VnbWVudExvYWRlcl8uZW5kZWRfO1xuXG4gICAgICBpZiAodGhpcy5tZWRpYVR5cGVzXy5BVURJTy5hY3RpdmVQbGF5bGlzdExvYWRlcikge1xuICAgICAgICAvLyBpZiB0aGUgYXVkaW8gcGxheWxpc3QgbG9hZGVyIGV4aXN0cywgdGhlbiBhbHRlcm5hdGUgYXVkaW8gaXMgYWN0aXZlLCBzbyB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIHdhaXQgZm9yIGJvdGggdGhlIG1haW4gYW5kIGF1ZGlvIHNlZ21lbnQgbG9hZGVycyB0byBjYWxsIGVuZE9mU3RyZWFtXG4gICAgICAgIGlzRW5kT2ZTdHJlYW0gPSBpc0VuZE9mU3RyZWFtICYmIHRoaXMuYXVkaW9TZWdtZW50TG9hZGVyXy5lbmRlZF87XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VuZE9mU3RyZWFtKSB7XG4gICAgICAgIHRoaXMubWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHBsYXlsaXN0IGhhcyBzdG9wcGVkIGJlaW5nIHVwZGF0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgdGhlIG1lZGlhIHBsYXlsaXN0IG9iamVjdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHBsYXlsaXN0IGhhcyBzdG9wcGVkIGJlaW5nIHVwZGF0ZWQgb3Igbm90XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzdHVja0F0UGxheWxpc3RFbmRfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3R1Y2tBdFBsYXlsaXN0RW5kXyhwbGF5bGlzdCkge1xuICAgICAgdmFyIHNlZWthYmxlID0gdGhpcy5zZWVrYWJsZSgpO1xuXG4gICAgICBpZiAoIXNlZWthYmxlLmxlbmd0aCkge1xuICAgICAgICAvLyBwbGF5bGlzdCBkb2Vzbid0IGhhdmUgZW5vdWdoIGluZm9ybWF0aW9uIHRvIGRldGVybWluZSB3aGV0aGVyIHdlIGFyZSBzdHVja1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBleHBpcmVkID0gdGhpcy5zeW5jQ29udHJvbGxlcl8uZ2V0RXhwaXJlZFRpbWUocGxheWxpc3QsIHRoaXMubWVkaWFTb3VyY2UuZHVyYXRpb24pO1xuXG4gICAgICBpZiAoZXhwaXJlZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvZXMgbm90IHVzZSB0aGUgc2FmZSBsaXZlIGVuZCB0byBjYWxjdWxhdGUgcGxheWxpc3QgZW5kLCBzaW5jZSB3ZVxuICAgICAgLy8gZG9uJ3Qgd2FudCB0byBzYXkgd2UgYXJlIHN0dWNrIHdoaWxlIHRoZXJlIGlzIHN0aWxsIGNvbnRlbnRcbiAgICAgIHZhciBhYnNvbHV0ZVBsYXlsaXN0RW5kID0gSGxzLlBsYXlsaXN0LnBsYXlsaXN0RW5kKHBsYXlsaXN0LCBleHBpcmVkKTtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMudGVjaF8uY3VycmVudFRpbWUoKTtcbiAgICAgIHZhciBidWZmZXJlZCA9IHRoaXMudGVjaF8uYnVmZmVyZWQoKTtcblxuICAgICAgaWYgKCFidWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgLy8gcmV0dXJuIHRydWUgaWYgdGhlIHBsYXloZWFkIHJlYWNoZWQgdGhlIGFic29sdXRlIGVuZCBvZiB0aGUgcGxheWxpc3RcbiAgICAgICAgcmV0dXJuIGFic29sdXRlUGxheWxpc3RFbmQgLSBjdXJyZW50VGltZSA8PSBfcmFuZ2VzMlsnZGVmYXVsdCddLlNBRkVfVElNRV9ERUxUQTtcbiAgICAgIH1cbiAgICAgIHZhciBidWZmZXJlZEVuZCA9IGJ1ZmZlcmVkLmVuZChidWZmZXJlZC5sZW5ndGggLSAxKTtcblxuICAgICAgLy8gcmV0dXJuIHRydWUgaWYgdGhlcmUgaXMgdG9vIGxpdHRsZSBidWZmZXIgbGVmdCBhbmQgYnVmZmVyIGhhcyByZWFjaGVkIGFic29sdXRlXG4gICAgICAvLyBlbmQgb2YgcGxheWxpc3RcbiAgICAgIHJldHVybiBidWZmZXJlZEVuZCAtIGN1cnJlbnRUaW1lIDw9IF9yYW5nZXMyWydkZWZhdWx0J10uU0FGRV9USU1FX0RFTFRBICYmIGFic29sdXRlUGxheWxpc3RFbmQgLSBidWZmZXJlZEVuZCA8PSBfcmFuZ2VzMlsnZGVmYXVsdCddLlNBRkVfVElNRV9ERUxUQTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCbGFja2xpc3RzIGEgcGxheWxpc3Qgd2hlbiBhbiBlcnJvciBvY2N1cnMgZm9yIGEgc2V0IGFtb3VudCBvZiB0aW1lXG4gICAgICogbWFraW5nIGl0IHVuYXZhaWxhYmxlIGZvciBzZWxlY3Rpb24gYnkgdGhlIHJlbmRpdGlvbiBzZWxlY3Rpb24gYWxnb3JpdGhtXG4gICAgICogYW5kIHRoZW4gZm9yY2VzIGEgbmV3IHBsYXlsaXN0IChyZW5kaXRpb24pIHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZXJyb3IgYW4gb3B0aW9uYWwgZXJyb3IgdGhhdCBtYXkgaW5jbHVkZSB0aGUgcGxheWxpc3RcbiAgICAgKiB0byBibGFja2xpc3RcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGJsYWNrbGlzdER1cmF0aW9uIGFuIG9wdGlvbmFsIG51bWJlciBvZiBzZWNvbmRzIHRvIGJsYWNrbGlzdCB0aGVcbiAgICAgKiBwbGF5bGlzdFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnYmxhY2tsaXN0Q3VycmVudFBsYXlsaXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmxhY2tsaXN0Q3VycmVudFBsYXlsaXN0KGVycm9yLCBibGFja2xpc3REdXJhdGlvbikge1xuICAgICAgaWYgKGVycm9yID09PSB1bmRlZmluZWQpIGVycm9yID0ge307XG5cbiAgICAgIHZhciBjdXJyZW50UGxheWxpc3QgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgbmV4dFBsYXlsaXN0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBJZiB0aGUgYGVycm9yYCB3YXMgZ2VuZXJhdGVkIGJ5IHRoZSBwbGF5bGlzdCBsb2FkZXIsIGl0IHdpbGwgY29udGFpblxuICAgICAgLy8gdGhlIHBsYXlsaXN0IHdlIHdlcmUgdHJ5aW5nIHRvIGxvYWQgKGJ1dCBmYWlsZWQpIGFuZCB0aGF0IHNob3VsZCBiZVxuICAgICAgLy8gYmxhY2tsaXN0ZWQgaW5zdGVhZCBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHBsYXlsaXN0IHdoaWNoIGlzIGxpa2VseVxuICAgICAgLy8gb3V0LW9mLWRhdGUgaW4gdGhpcyBzY2VuYXJpb1xuICAgICAgY3VycmVudFBsYXlsaXN0ID0gZXJyb3IucGxheWxpc3QgfHwgdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKTtcblxuICAgICAgYmxhY2tsaXN0RHVyYXRpb24gPSBibGFja2xpc3REdXJhdGlvbiB8fCBlcnJvci5ibGFja2xpc3REdXJhdGlvbiB8fCB0aGlzLmJsYWNrbGlzdER1cmF0aW9uO1xuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBjdXJyZW50IHBsYXlsaXN0LCB0aGVuIGFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHdlIHdlcmVcbiAgICAgIC8vIHRyeWluZyB0byBsb2FkIHRoZSBtYXN0ZXIgT1Igd2hpbGUgd2Ugd2VyZSBkaXNwb3Npbmcgb2YgdGhlIHRlY2hcbiAgICAgIGlmICghY3VycmVudFBsYXlsaXN0KSB7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCduZXR3b3JrJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCdlcnJvcicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0ZpbmFsUmVuZGl0aW9uID0gdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWFzdGVyLnBsYXlsaXN0cy5maWx0ZXIoX3BsYXlsaXN0SnMuaXNFbmFibGVkKS5sZW5ndGggPT09IDE7XG5cbiAgICAgIGlmIChpc0ZpbmFsUmVuZGl0aW9uKSB7XG4gICAgICAgIC8vIE5ldmVyIGJsYWNrbGlzdGluZyB0aGlzIHBsYXlsaXN0IGJlY2F1c2UgaXQncyBmaW5hbCByZW5kaXRpb25cbiAgICAgICAgX3ZpZGVvSnMyWydkZWZhdWx0J10ubG9nLndhcm4oJ1Byb2JsZW0gZW5jb3VudGVyZWQgd2l0aCB0aGUgY3VycmVudCAnICsgJ0hMUyBwbGF5bGlzdC4gVHJ5aW5nIGFnYWluIHNpbmNlIGl0IGlzIHRoZSBmaW5hbCBwbGF5bGlzdC4nKTtcblxuICAgICAgICB0aGlzLnRlY2hfLnRyaWdnZXIoJ3JldHJ5cGxheWxpc3QnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLmxvYWQoaXNGaW5hbFJlbmRpdGlvbik7XG4gICAgICB9XG4gICAgICAvLyBCbGFja2xpc3QgdGhpcyBwbGF5bGlzdFxuICAgICAgY3VycmVudFBsYXlsaXN0LmV4Y2x1ZGVVbnRpbCA9IERhdGUubm93KCkgKyBibGFja2xpc3REdXJhdGlvbiAqIDEwMDA7XG4gICAgICB0aGlzLnRlY2hfLnRyaWdnZXIoJ2JsYWNrbGlzdHBsYXlsaXN0Jyk7XG4gICAgICB0aGlzLnRlY2hfLnRyaWdnZXIoeyB0eXBlOiAndXNhZ2UnLCBuYW1lOiAnaGxzLXJlbmRpdGlvbi1ibGFja2xpc3RlZCcgfSk7XG5cbiAgICAgIC8vIFNlbGVjdCBhIG5ldyBwbGF5bGlzdFxuICAgICAgbmV4dFBsYXlsaXN0ID0gdGhpcy5zZWxlY3RQbGF5bGlzdCgpO1xuICAgICAgX3ZpZGVvSnMyWydkZWZhdWx0J10ubG9nLndhcm4oJ1Byb2JsZW0gZW5jb3VudGVyZWQgd2l0aCB0aGUgY3VycmVudCBITFMgcGxheWxpc3QuJyArIChlcnJvci5tZXNzYWdlID8gJyAnICsgZXJyb3IubWVzc2FnZSA6ICcnKSArICcgU3dpdGNoaW5nIHRvIGFub3RoZXIgcGxheWxpc3QuJyk7XG5cbiAgICAgIHJldHVybiB0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5tZWRpYShuZXh0UGxheWxpc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdXNlIGFsbCBzZWdtZW50IGxvYWRlcnNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3BhdXNlTG9hZGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdXNlTG9hZGluZygpIHtcbiAgICAgIHRoaXMubWFpblNlZ21lbnRMb2FkZXJfLnBhdXNlKCk7XG4gICAgICBpZiAodGhpcy5tZWRpYVR5cGVzXy5BVURJTy5hY3RpdmVQbGF5bGlzdExvYWRlcikge1xuICAgICAgICB0aGlzLmF1ZGlvU2VnbWVudExvYWRlcl8ucGF1c2UoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1lZGlhVHlwZXNfLlNVQlRJVExFUy5hY3RpdmVQbGF5bGlzdExvYWRlcikge1xuICAgICAgICB0aGlzLnN1YnRpdGxlU2VnbWVudExvYWRlcl8ucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIGN1cnJlbnQgdGltZSBvbiBhbGwgc2VnbWVudCBsb2FkZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RpbWVSYW5nZX0gY3VycmVudFRpbWUgdGhlIGN1cnJlbnQgdGltZSB0byBzZXRcbiAgICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9IHRoZSBjdXJyZW50IHRpbWVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldEN1cnJlbnRUaW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3VycmVudFRpbWUoY3VycmVudFRpbWUpIHtcbiAgICAgIHZhciBidWZmZXJlZCA9IF9yYW5nZXMyWydkZWZhdWx0J10uZmluZFJhbmdlKHRoaXMudGVjaF8uYnVmZmVyZWQoKSwgY3VycmVudFRpbWUpO1xuXG4gICAgICBpZiAoISh0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXyAmJiB0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5tZWRpYSgpKSkge1xuICAgICAgICAvLyByZXR1cm4gaW1tZWRpYXRlbHkgaWYgdGhlIG1ldGFkYXRhIGlzIG5vdCByZWFkeSB5ZXRcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIGl0J3MgY2xlYXJseSBhbiBlZGdlLWNhc2UgYnV0IGRvbid0IHRocm93biBhbiBlcnJvciBpZiBhc2tlZCB0b1xuICAgICAgLy8gc2VlayB3aXRoaW4gYW4gZW1wdHkgcGxheWxpc3RcbiAgICAgIGlmICghdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKS5zZWdtZW50cykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgLy8gSW4gZmxhc2ggcGxheWJhY2ssIHRoZSBzZWdtZW50IGxvYWRlcnMgc2hvdWxkIGJlIHJlc2V0IG9uIGV2ZXJ5IHNlZWssIGV2ZW5cbiAgICAgIC8vIGluIGJ1ZmZlciBzZWVrcy4gSWYgdGhlIHNlZWsgbG9jYXRpb24gaXMgYWxyZWFkeSBidWZmZXJlZCwgY29udGludWUgYnVmZmVyaW5nIGFzXG4gICAgICAvLyB1c3VhbFxuICAgICAgaWYgKGJ1ZmZlcmVkICYmIGJ1ZmZlcmVkLmxlbmd0aCAmJiB0aGlzLm1vZGVfICE9PSAnZmxhc2gnKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50VGltZTtcbiAgICAgIH1cblxuICAgICAgLy8gY2FuY2VsIG91dHN0YW5kaW5nIHJlcXVlc3RzIHNvIHdlIGJlZ2luIGJ1ZmZlcmluZyBhdCB0aGUgbmV3XG4gICAgICAvLyBsb2NhdGlvblxuICAgICAgdGhpcy5tYWluU2VnbWVudExvYWRlcl8ucmVzZXRFdmVyeXRoaW5nKCk7XG4gICAgICB0aGlzLm1haW5TZWdtZW50TG9hZGVyXy5hYm9ydCgpO1xuICAgICAgaWYgKHRoaXMubWVkaWFUeXBlc18uQVVESU8uYWN0aXZlUGxheWxpc3RMb2FkZXIpIHtcbiAgICAgICAgdGhpcy5hdWRpb1NlZ21lbnRMb2FkZXJfLnJlc2V0RXZlcnl0aGluZygpO1xuICAgICAgICB0aGlzLmF1ZGlvU2VnbWVudExvYWRlcl8uYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1lZGlhVHlwZXNfLlNVQlRJVExFUy5hY3RpdmVQbGF5bGlzdExvYWRlcikge1xuICAgICAgICB0aGlzLnN1YnRpdGxlU2VnbWVudExvYWRlcl8ucmVzZXRFdmVyeXRoaW5nKCk7XG4gICAgICAgIHRoaXMuc3VidGl0bGVTZWdtZW50TG9hZGVyXy5hYm9ydCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBzdGFydCBzZWdtZW50IGxvYWRlciBsb2FkaW5nIGluIGNhc2UgdGhleSBhcmUgcGF1c2VkXG4gICAgICB0aGlzLmxvYWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGN1cnJlbnQgZHVyYXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1RpbWVSYW5nZX0gdGhlIGR1cmF0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdkdXJhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGR1cmF0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWVkaWFTb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWFTb3VyY2UuZHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBIbHMuUGxheWxpc3QuZHVyYXRpb24odGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2hlY2sgdGhlIHNlZWthYmxlIHJhbmdlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9IHRoZSBzZWVrYWJsZSByYW5nZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnc2Vla2FibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWVrYWJsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlZWthYmxlXztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvblN5bmNJbmZvVXBkYXRlXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3luY0luZm9VcGRhdGVfKCkge1xuICAgICAgdmFyIG1haW5TZWVrYWJsZSA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhdWRpb1NlZWthYmxlID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoIXRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKTtcblxuICAgICAgaWYgKCFtZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBleHBpcmVkID0gdGhpcy5zeW5jQ29udHJvbGxlcl8uZ2V0RXhwaXJlZFRpbWUobWVkaWEsIHRoaXMubWVkaWFTb3VyY2UuZHVyYXRpb24pO1xuXG4gICAgICBpZiAoZXhwaXJlZCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBub3QgZW5vdWdoIGluZm9ybWF0aW9uIHRvIHVwZGF0ZSBzZWVrYWJsZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1haW5TZWVrYWJsZSA9IEhscy5QbGF5bGlzdC5zZWVrYWJsZShtZWRpYSwgZXhwaXJlZCk7XG5cbiAgICAgIGlmIChtYWluU2Vla2FibGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWVkaWFUeXBlc18uQVVESU8uYWN0aXZlUGxheWxpc3RMb2FkZXIpIHtcbiAgICAgICAgbWVkaWEgPSB0aGlzLm1lZGlhVHlwZXNfLkFVRElPLmFjdGl2ZVBsYXlsaXN0TG9hZGVyLm1lZGlhKCk7XG4gICAgICAgIGV4cGlyZWQgPSB0aGlzLnN5bmNDb250cm9sbGVyXy5nZXRFeHBpcmVkVGltZShtZWRpYSwgdGhpcy5tZWRpYVNvdXJjZS5kdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGV4cGlyZWQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhdWRpb1NlZWthYmxlID0gSGxzLlBsYXlsaXN0LnNlZWthYmxlKG1lZGlhLCBleHBpcmVkKTtcblxuICAgICAgICBpZiAoYXVkaW9TZWVrYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhdWRpb1NlZWthYmxlKSB7XG4gICAgICAgIC8vIHNlZWthYmxlIGhhcyBiZWVuIGNhbGN1bGF0ZWQgYmFzZWQgb24gYnVmZmVyaW5nIHZpZGVvIGRhdGEgc28gaXRcbiAgICAgICAgLy8gY2FuIGJlIHJldHVybmVkIGRpcmVjdGx5XG4gICAgICAgIHRoaXMuc2Vla2FibGVfID0gbWFpblNlZWthYmxlO1xuICAgICAgfSBlbHNlIGlmIChhdWRpb1NlZWthYmxlLnN0YXJ0KDApID4gbWFpblNlZWthYmxlLmVuZCgwKSB8fCBtYWluU2Vla2FibGUuc3RhcnQoMCkgPiBhdWRpb1NlZWthYmxlLmVuZCgwKSkge1xuICAgICAgICAvLyBzZWVrYWJsZXMgYXJlIHByZXR0eSBmYXIgb2ZmLCByZWx5IG9uIG1haW5cbiAgICAgICAgdGhpcy5zZWVrYWJsZV8gPSBtYWluU2Vla2FibGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlZWthYmxlXyA9IF92aWRlb0pzMlsnZGVmYXVsdCddLmNyZWF0ZVRpbWVSYW5nZXMoW1thdWRpb1NlZWthYmxlLnN0YXJ0KDApID4gbWFpblNlZWthYmxlLnN0YXJ0KDApID8gYXVkaW9TZWVrYWJsZS5zdGFydCgwKSA6IG1haW5TZWVrYWJsZS5zdGFydCgwKSwgYXVkaW9TZWVrYWJsZS5lbmQoMCkgPCBtYWluU2Vla2FibGUuZW5kKDApID8gYXVkaW9TZWVrYWJsZS5lbmQoMCkgOiBtYWluU2Vla2FibGUuZW5kKDApXV0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRlY2hfLnRyaWdnZXIoJ3NlZWthYmxlY2hhbmdlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgcGxheWVyIGR1cmF0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVEdXJhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUR1cmF0aW9uKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBvbGREdXJhdGlvbiA9IHRoaXMubWVkaWFTb3VyY2UuZHVyYXRpb247XG4gICAgICB2YXIgbmV3RHVyYXRpb24gPSBIbHMuUGxheWxpc3QuZHVyYXRpb24odGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKSk7XG4gICAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLnRlY2hfLmJ1ZmZlcmVkKCk7XG4gICAgICB2YXIgc2V0RHVyYXRpb24gPSBmdW5jdGlvbiBzZXREdXJhdGlvbigpIHtcbiAgICAgICAgX3RoaXM1Lm1lZGlhU291cmNlLmR1cmF0aW9uID0gbmV3RHVyYXRpb247XG4gICAgICAgIF90aGlzNS50ZWNoXy50cmlnZ2VyKCdkdXJhdGlvbmNoYW5nZScpO1xuXG4gICAgICAgIF90aGlzNS5tZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgc2V0RHVyYXRpb24pO1xuICAgICAgfTtcblxuICAgICAgaWYgKGJ1ZmZlcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbmV3RHVyYXRpb24gPSBNYXRoLm1heChuZXdEdXJhdGlvbiwgYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkLmxlbmd0aCAtIDEpKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlIGR1cmF0aW9uIGhhcyBjaGFuZ2VkLCBpbnZhbGlkYXRlIHRoZSBjYWNoZWQgdmFsdWVcbiAgICAgIGlmIChvbGREdXJhdGlvbiAhPT0gbmV3RHVyYXRpb24pIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBkdXJhdGlvblxuICAgICAgICBpZiAodGhpcy5tZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgICAgICB0aGlzLm1lZGlhU291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCBzZXREdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0RHVyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRpc3Bvc2Ugb2YgdGhlIE1hc3RlclBsYXlsaXN0Q29udHJvbGxlciBhbmQgZXZlcnl0aGluZ1xuICAgICAqIHRoYXQgaXQgY29udHJvbHNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2Rpc3Bvc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZGVjcnlwdGVyXy50ZXJtaW5hdGUoKTtcbiAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMubWFpblNlZ21lbnRMb2FkZXJfLmRpc3Bvc2UoKTtcblxuICAgICAgWydBVURJTycsICdTVUJUSVRMRVMnXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBncm91cHMgPSBfdGhpczYubWVkaWFUeXBlc19bdHlwZV0uZ3JvdXBzO1xuXG4gICAgICAgIGZvciAodmFyIGlkIGluIGdyb3Vwcykge1xuICAgICAgICAgIGdyb3Vwc1tpZF0uZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGlmIChncm91cC5wbGF5bGlzdExvYWRlcikge1xuICAgICAgICAgICAgICBncm91cC5wbGF5bGlzdExvYWRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmF1ZGlvU2VnbWVudExvYWRlcl8uZGlzcG9zZSgpO1xuICAgICAgdGhpcy5zdWJ0aXRsZVNlZ21lbnRMb2FkZXJfLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIG1hc3RlciBwbGF5bGlzdCBvYmplY3QgaWYgd2UgaGF2ZSBvbmVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIG1hc3RlciBwbGF5bGlzdCBvYmplY3QgdGhhdCB3ZSBwYXJzZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ21hc3RlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hc3RlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5tYXN0ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcGxheWxpc3RcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBwbGF5bGlzdCBvYmplY3QgdGhhdCB3ZSBwYXJzZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ21lZGlhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVkaWEoKSB7XG4gICAgICAvLyBwbGF5bGlzdCBsb2FkZXIgd2lsbCBub3QgcmV0dXJuIG1lZGlhIGlmIGl0IGhhcyBub3QgYmVlbiBmdWxseSBsb2FkZWRcbiAgICAgIHJldHVybiB0aGlzLm1hc3RlclBsYXlsaXN0TG9hZGVyXy5tZWRpYSgpIHx8IHRoaXMuaW5pdGlhbE1lZGlhXztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXR1cCBvdXIgaW50ZXJuYWwgc291cmNlIGJ1ZmZlcnMgb24gb3VyIHNlZ21lbnQgTG9hZGVyc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldHVwU291cmNlQnVmZmVyc18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cFNvdXJjZUJ1ZmZlcnNfKCkge1xuICAgICAgdmFyIG1lZGlhID0gdGhpcy5tYXN0ZXJQbGF5bGlzdExvYWRlcl8ubWVkaWEoKTtcbiAgICAgIHZhciBtaW1lVHlwZXMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIHdhaXQgdW50aWwgYSBtZWRpYSBwbGF5bGlzdCBpcyBhdmFpbGFibGUgYW5kIHRoZSBNZWRpYSBTb3VyY2UgaXNcbiAgICAgIC8vIGF0dGFjaGVkXG4gICAgICBpZiAoIW1lZGlhIHx8IHRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWltZVR5cGVzID0gbWltZVR5cGVzRm9yUGxheWxpc3RfKHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1hc3RlciwgbWVkaWEpO1xuICAgICAgaWYgKG1pbWVUeXBlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgIHRoaXMuZXJyb3IgPSAnTm8gY29tcGF0aWJsZSBTb3VyY2VCdWZmZXIgY29uZmlndXJhdGlvbiBmb3IgdGhlIHZhcmlhbnQgc3RyZWFtOicgKyBtZWRpYS5yZXNvbHZlZFVyaTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oJ2RlY29kZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5tYWluU2VnbWVudExvYWRlcl8ubWltZVR5cGUobWltZVR5cGVzWzBdKTtcbiAgICAgIGlmIChtaW1lVHlwZXNbMV0pIHtcbiAgICAgICAgdGhpcy5hdWRpb1NlZ21lbnRMb2FkZXJfLm1pbWVUeXBlKG1pbWVUeXBlc1sxXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGV4Y2x1ZGUgYW55IGluY29tcGF0aWJsZSB2YXJpYW50IHN0cmVhbXMgZnJvbSBmdXR1cmUgcGxheWxpc3RcbiAgICAgIC8vIHNlbGVjdGlvblxuICAgICAgdGhpcy5leGNsdWRlSW5jb21wYXRpYmxlVmFyaWFudHNfKG1lZGlhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCbGFja2xpc3QgcGxheWxpc3RzIHRoYXQgYXJlIGtub3duIHRvIGJlIGNvZGVjIG9yXG4gICAgICogc3RyZWFtLWluY29tcGF0aWJsZSB3aXRoIHRoZSBTb3VyY2VCdWZmZXIgY29uZmlndXJhdGlvbi4gRm9yXG4gICAgICogaW5zdGFuY2UsIE1lZGlhIFNvdXJjZSBFeHRlbnNpb25zIHdvdWxkIGNhdXNlIHRoZSB2aWRlbyBlbGVtZW50IHRvXG4gICAgICogc3RhbGwgd2FpdGluZyBmb3IgdmlkZW8gZGF0YSBpZiB5b3Ugc3dpdGNoZWQgZnJvbSBhIHZhcmlhbnQgd2l0aFxuICAgICAqIHZpZGVvIGFuZCBhdWRpbyB0byBhbiBhdWRpby1vbmx5IG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZWRpYSBhIG1lZGlhIHBsYXlsaXN0IGNvbXBhdGlibGUgd2l0aCB0aGUgY3VycmVudFxuICAgICAqIHNldCBvZiBTb3VyY2VCdWZmZXJzLiBWYXJpYW50cyBpbiB0aGUgY3VycmVudCBtYXN0ZXIgcGxheWxpc3QgdGhhdFxuICAgICAqIGRvIG5vdCBhcHBlYXIgdG8gaGF2ZSBjb21wYXRpYmxlIGNvZGVjIG9yIHN0cmVhbSBjb25maWd1cmF0aW9uc1xuICAgICAqIHdpbGwgYmUgZXhjbHVkZWQgZnJvbSB0aGUgZGVmYXVsdCBwbGF5bGlzdCBzZWxlY3Rpb24gYWxnb3JpdGhtXG4gICAgICogaW5kZWZpbml0ZWx5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdleGNsdWRlSW5jb21wYXRpYmxlVmFyaWFudHNfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhjbHVkZUluY29tcGF0aWJsZVZhcmlhbnRzXyhtZWRpYSkge1xuICAgICAgdmFyIG1hc3RlciA9IHRoaXMubWFzdGVyUGxheWxpc3RMb2FkZXJfLm1hc3RlcjtcbiAgICAgIHZhciBjb2RlY0NvdW50ID0gMjtcbiAgICAgIHZhciB2aWRlb0NvZGVjID0gbnVsbDtcbiAgICAgIHZhciBjb2RlY3MgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChtZWRpYS5hdHRyaWJ1dGVzLkNPREVDUykge1xuICAgICAgICBjb2RlY3MgPSAoMCwgX3V0aWxDb2RlY3NKcy5wYXJzZUNvZGVjcykobWVkaWEuYXR0cmlidXRlcy5DT0RFQ1MpO1xuICAgICAgICB2aWRlb0NvZGVjID0gY29kZWNzLnZpZGVvQ29kZWM7XG4gICAgICAgIGNvZGVjQ291bnQgPSBjb2RlY3MuY29kZWNDb3VudDtcbiAgICAgIH1cbiAgICAgIG1hc3Rlci5wbGF5bGlzdHMuZm9yRWFjaChmdW5jdGlvbiAodmFyaWFudCkge1xuICAgICAgICB2YXIgdmFyaWFudENvZGVjcyA9IHtcbiAgICAgICAgICBjb2RlY0NvdW50OiAyLFxuICAgICAgICAgIHZpZGVvQ29kZWM6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodmFyaWFudC5hdHRyaWJ1dGVzLkNPREVDUykge1xuICAgICAgICAgIHZhciBjb2RlY1N0cmluZyA9IHZhcmlhbnQuYXR0cmlidXRlcy5DT0RFQ1M7XG5cbiAgICAgICAgICB2YXJpYW50Q29kZWNzID0gKDAsIF91dGlsQ29kZWNzSnMucGFyc2VDb2RlY3MpKGNvZGVjU3RyaW5nKTtcblxuICAgICAgICAgIGlmICh3aW5kb3cuTWVkaWFTb3VyY2UgJiYgd2luZG93Lk1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCAmJiAhd2luZG93Lk1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0OyBjb2RlY3M9XCInICsgbWFwTGVnYWN5QXZjQ29kZWNzXyhjb2RlY1N0cmluZykgKyAnXCInKSkge1xuICAgICAgICAgICAgdmFyaWFudC5leGNsdWRlVW50aWwgPSBJbmZpbml0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgc3RyZWFtcyBkaWZmZXIgaW4gdGhlIHByZXNlbmNlIG9yIGFic2VuY2Ugb2YgYXVkaW8gb3JcbiAgICAgICAgLy8gdmlkZW8sIHRoZXkgYXJlIGluY29tcGF0aWJsZVxuICAgICAgICBpZiAodmFyaWFudENvZGVjcy5jb2RlY0NvdW50ICE9PSBjb2RlY0NvdW50KSB7XG4gICAgICAgICAgdmFyaWFudC5leGNsdWRlVW50aWwgPSBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGguMjY0IGlzIHNwZWNpZmllZCBvbiB0aGUgY3VycmVudCBwbGF5bGlzdCwgc29tZSBmbGF2b3Igb2ZcbiAgICAgICAgLy8gaXQgbXVzdCBiZSBzcGVjaWZpZWQgb24gYWxsIGNvbXBhdGlibGUgdmFyaWFudHNcbiAgICAgICAgaWYgKHZhcmlhbnRDb2RlY3MudmlkZW9Db2RlYyAhPT0gdmlkZW9Db2RlYykge1xuICAgICAgICAgIHZhcmlhbnQuZXhjbHVkZVVudGlsID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZUFkQ3Vlc18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVBZEN1ZXNfKG1lZGlhKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciBzZWVrYWJsZSA9IHRoaXMuc2Vla2FibGUoKTtcblxuICAgICAgaWYgKHNlZWthYmxlLmxlbmd0aCkge1xuICAgICAgICBvZmZzZXQgPSBzZWVrYWJsZS5zdGFydCgwKTtcbiAgICAgIH1cblxuICAgICAgX2FkQ3VlVGFnczJbJ2RlZmF1bHQnXS51cGRhdGVBZEN1ZXMobWVkaWEsIHRoaXMuY3VlVGFnc1RyYWNrXywgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBkZXNpcmVkIGZvcndhcmQgYnVmZmVyIGxlbmd0aCBiYXNlZCBvbiBjdXJyZW50IHRpbWVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gRGVzaXJlZCBmb3J3YXJkIGJ1ZmZlciBsZW5ndGggaW4gc2Vjb25kc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZ29hbEJ1ZmZlckxlbmd0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdvYWxCdWZmZXJMZW5ndGgoKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLnRlY2hfLmN1cnJlbnRUaW1lKCk7XG4gICAgICB2YXIgaW5pdGlhbCA9IF9jb25maWcyWydkZWZhdWx0J10uR09BTF9CVUZGRVJfTEVOR1RIO1xuICAgICAgdmFyIHJhdGUgPSBfY29uZmlnMlsnZGVmYXVsdCddLkdPQUxfQlVGRkVSX0xFTkdUSF9SQVRFO1xuICAgICAgdmFyIG1heCA9IE1hdGgubWF4KGluaXRpYWwsIF9jb25maWcyWydkZWZhdWx0J10uTUFYX0dPQUxfQlVGRkVSX0xFTkdUSCk7XG5cbiAgICAgIHJldHVybiBNYXRoLm1pbihpbml0aWFsICsgY3VycmVudFRpbWUgKiByYXRlLCBtYXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGRlc2lyZWQgYnVmZmVyIGxvdyB3YXRlciBsaW5lIGJhc2VkIG9uIGN1cnJlbnQgdGltZVxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBEZXNpcmVkIGJ1ZmZlciBsb3cgd2F0ZXIgbGluZSBpbiBzZWNvbmRzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdidWZmZXJMb3dXYXRlckxpbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWZmZXJMb3dXYXRlckxpbmUoKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLnRlY2hfLmN1cnJlbnRUaW1lKCk7XG4gICAgICB2YXIgaW5pdGlhbCA9IF9jb25maWcyWydkZWZhdWx0J10uQlVGRkVSX0xPV19XQVRFUl9MSU5FO1xuICAgICAgdmFyIHJhdGUgPSBfY29uZmlnMlsnZGVmYXVsdCddLkJVRkZFUl9MT1dfV0FURVJfTElORV9SQVRFO1xuICAgICAgdmFyIG1heCA9IE1hdGgubWF4KGluaXRpYWwsIF9jb25maWcyWydkZWZhdWx0J10uTUFYX0JVRkZFUl9MT1dfV0FURVJfTElORSk7XG5cbiAgICAgIHJldHVybiBNYXRoLm1pbihpbml0aWFsICsgY3VycmVudFRpbWUgKiByYXRlLCBtYXgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXI7XG59KShfdmlkZW9KczJbJ2RlZmF1bHQnXS5FdmVudFRhcmdldCk7XG5cbmV4cG9ydHMuTWFzdGVyUGxheWxpc3RDb250cm9sbGVyID0gTWFzdGVyUGxheWxpc3RDb250cm9sbGVyO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4vYWQtY3VlLXRhZ3NcIjoxLFwiLi9jb25maWdcIjozLFwiLi9kZWNyeXB0ZXItd29ya2VyXCI6NCxcIi4vbWVkaWEtZ3JvdXBzXCI6NixcIi4vcGxheWxpc3QtbG9hZGVyXCI6OSxcIi4vcGxheWxpc3QuanNcIjoxMSxcIi4vcmFuZ2VzXCI6MTIsXCIuL3NlZ21lbnQtbG9hZGVyXCI6MTYsXCIuL3N5bmMtY29udHJvbGxlclwiOjE4LFwiLi91dGlsL2NvZGVjcy5qc1wiOjE5LFwiLi92dHQtc2VnbWVudC1sb2FkZXJcIjoyMCxcInZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzL2VzNS9jb2RlYy11dGlsc1wiOjY1LFwid2Vid29ya2lmeVwiOjc2fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfdmlkZW9KcyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2aWRlb2pzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd2aWRlb2pzJ10gOiBudWxsKTtcblxudmFyIF92aWRlb0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvSnMpO1xuXG52YXIgX3BsYXlsaXN0TG9hZGVyID0gcmVxdWlyZSgnLi9wbGF5bGlzdC1sb2FkZXInKTtcblxudmFyIF9wbGF5bGlzdExvYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF5bGlzdExvYWRlcik7XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIHByb3BlcnRpZXMgb2YgYW4gSExTIHRyYWNrIGludG8gYW4gYXVkaW9UcmFja0tpbmQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGF1ZGlvVHJhY2tLaW5kXyA9IGZ1bmN0aW9uIGF1ZGlvVHJhY2tLaW5kXyhwcm9wZXJ0aWVzKSB7XG4gIHZhciBraW5kID0gcHJvcGVydGllc1snZGVmYXVsdCddID8gJ21haW4nIDogJ2FsdGVybmF0aXZlJztcblxuICBpZiAocHJvcGVydGllcy5jaGFyYWN0ZXJpc3RpY3MgJiYgcHJvcGVydGllcy5jaGFyYWN0ZXJpc3RpY3MuaW5kZXhPZigncHVibGljLmFjY2Vzc2liaWxpdHkuZGVzY3JpYmVzLXZpZGVvJykgPj0gMCkge1xuICAgIGtpbmQgPSAnbWFpbi1kZXNjJztcbiAgfVxuXG4gIHJldHVybiBraW5kO1xufTtcblxuLyoqXG4gKiBQYXVzZSBwcm92aWRlZCBzZWdtZW50IGxvYWRlciBhbmQgcGxheWxpc3QgbG9hZGVyIGlmIGFjdGl2ZVxuICpcbiAqIEBwYXJhbSB7U2VnbWVudExvYWRlcn0gc2VnbWVudExvYWRlclxuICogICAgICAgIFNlZ21lbnRMb2FkZXIgdG8gcGF1c2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBtZWRpYVR5cGVcbiAqICAgICAgICBBY3RpdmUgbWVkaWEgdHlwZVxuICogQGZ1bmN0aW9uIHN0b3BMb2FkZXJzXG4gKi9cbnZhciBzdG9wTG9hZGVycyA9IGZ1bmN0aW9uIHN0b3BMb2FkZXJzKHNlZ21lbnRMb2FkZXIsIG1lZGlhVHlwZSkge1xuICBzZWdtZW50TG9hZGVyLmFib3J0KCk7XG4gIHNlZ21lbnRMb2FkZXIucGF1c2UoKTtcblxuICBpZiAobWVkaWFUeXBlICYmIG1lZGlhVHlwZS5hY3RpdmVQbGF5bGlzdExvYWRlcikge1xuICAgIG1lZGlhVHlwZS5hY3RpdmVQbGF5bGlzdExvYWRlci5wYXVzZSgpO1xuICAgIG1lZGlhVHlwZS5hY3RpdmVQbGF5bGlzdExvYWRlciA9IG51bGw7XG4gIH1cbn07XG5cbmV4cG9ydHMuc3RvcExvYWRlcnMgPSBzdG9wTG9hZGVycztcbi8qKlxuICogU3RhcnQgbG9hZGluZyBwcm92aWRlZCBzZWdtZW50IGxvYWRlciBhbmQgcGxheWxpc3QgbG9hZGVyXG4gKlxuICogQHBhcmFtIHtQbGF5bGlzdExvYWRlcn0gcGxheWxpc3RMb2FkZXJcbiAqICAgICAgICBQbGF5bGlzdExvYWRlciB0byBzdGFydCBsb2FkaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gbWVkaWFUeXBlXG4gKiAgICAgICAgQWN0aXZlIG1lZGlhIHR5cGVcbiAqIEBmdW5jdGlvbiBzdGFydExvYWRlcnNcbiAqL1xudmFyIHN0YXJ0TG9hZGVycyA9IGZ1bmN0aW9uIHN0YXJ0TG9hZGVycyhwbGF5bGlzdExvYWRlciwgbWVkaWFUeXBlKSB7XG4gIC8vIFNlZ21lbnQgbG9hZGVyIHdpbGwgYmUgc3RhcnRlZCBhZnRlciBgbG9hZGVkbWV0YWRhdGFgIG9yIGBsb2FkZWRwbGF5bGlzdGAgZnJvbSB0aGVcbiAgLy8gcGxheWxpc3QgbG9hZGVyXG4gIG1lZGlhVHlwZS5hY3RpdmVQbGF5bGlzdExvYWRlciA9IHBsYXlsaXN0TG9hZGVyO1xuICBwbGF5bGlzdExvYWRlci5sb2FkKCk7XG59O1xuXG5leHBvcnRzLnN0YXJ0TG9hZGVycyA9IHN0YXJ0TG9hZGVycztcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBtZWRpYSBncm91cCBjaGFuZ2VzLiBJdCBwZXJmb3JtcyBhXG4gKiBub24tZGVzdHJ1Y3RpdmUgKHByZXNlcnZlIHRoZSBidWZmZXIpIHJlc3luYyBvZiB0aGUgU2VnbWVudExvYWRlci4gVGhpcyBpcyBiZWNhdXNlIGFcbiAqIGNoYW5nZSBvZiBncm91cCBpcyBtZXJlbHkgYSByZW5kaXRpb24gc3dpdGNoIG9mIHRoZSBzYW1lIGNvbnRlbnQgYXQgYW5vdGhlciBlbmNvZGluZyxcbiAqIHJhdGhlciB0aGFuIGEgY2hhbmdlIG9mIGNvbnRlbnQsIHN1Y2ggYXMgc3dpdGNoaW5nIGF1ZGlvIGZyb20gRW5nbGlzaCB0byBTcGFuaXNoLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiAgICAgICAgTWVkaWFHcm91cCB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3NcbiAqICAgICAgICBPYmplY3QgY29udGFpbmluZyByZXF1aXJlZCBpbmZvcm1hdGlvbiBmb3IgbWVkaWEgZ3JvdXBzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqICAgICAgICAgSGFuZGxlciBmb3IgYSBub24tZGVzdHJ1Y3RpdmUgcmVzeW5jIG9mIFNlZ21lbnRMb2FkZXIgd2hlbiB0aGUgYWN0aXZlIG1lZGlhXG4gKiAgICAgICAgIGdyb3VwIGNoYW5nZXMuXG4gKiBAZnVuY3Rpb24gb25Hcm91cENoYW5nZWRcbiAqL1xudmFyIG9uR3JvdXBDaGFuZ2VkID0gZnVuY3Rpb24gb25Hcm91cENoYW5nZWQodHlwZSwgc2V0dGluZ3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3NldHRpbmdzJHNlZ21lbnRMb2FkZXJzID0gc2V0dGluZ3Muc2VnbWVudExvYWRlcnM7XG4gICAgdmFyIHNlZ21lbnRMb2FkZXIgPSBfc2V0dGluZ3Mkc2VnbWVudExvYWRlcnNbdHlwZV07XG4gICAgdmFyIG1haW5TZWdtZW50TG9hZGVyID0gX3NldHRpbmdzJHNlZ21lbnRMb2FkZXJzLm1haW47XG4gICAgdmFyIG1lZGlhVHlwZSA9IHNldHRpbmdzLm1lZGlhVHlwZXNbdHlwZV07XG5cbiAgICB2YXIgYWN0aXZlVHJhY2sgPSBtZWRpYVR5cGUuYWN0aXZlVHJhY2soKTtcbiAgICB2YXIgYWN0aXZlR3JvdXAgPSBtZWRpYVR5cGUuYWN0aXZlR3JvdXAoYWN0aXZlVHJhY2spO1xuICAgIHZhciBwcmV2aW91c0FjdGl2ZUxvYWRlciA9IG1lZGlhVHlwZS5hY3RpdmVQbGF5bGlzdExvYWRlcjtcblxuICAgIHN0b3BMb2FkZXJzKHNlZ21lbnRMb2FkZXIsIG1lZGlhVHlwZSk7XG5cbiAgICBpZiAoIWFjdGl2ZUdyb3VwKSB7XG4gICAgICAvLyB0aGVyZSBpcyBubyBncm91cCBhY3RpdmVcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWFjdGl2ZUdyb3VwLnBsYXlsaXN0TG9hZGVyKSB7XG4gICAgICBpZiAocHJldmlvdXNBY3RpdmVMb2FkZXIpIHtcbiAgICAgICAgLy8gVGhlIHByZXZpb3VzIGdyb3VwIGhhZCBhIHBsYXlsaXN0IGxvYWRlciBidXQgdGhlIG5ldyBhY3RpdmUgZ3JvdXAgZG9lcyBub3RcbiAgICAgICAgLy8gdGhpcyBtZWFucyB3ZSBhcmUgc3dpdGNoaW5nIGZyb20gZGVtdXhlZCB0byBtdXhlZCBhdWRpby4gSW4gdGhpcyBjYXNlIHdlIHdhbnQgdG9cbiAgICAgICAgLy8gZG8gYSBkZXN0cnVjdGl2ZSByZXNldCBvZiB0aGUgbWFpbiBzZWdtZW50IGxvYWRlciBhbmQgbm90IHJlc3RhcnQgdGhlIGF1ZGlvXG4gICAgICAgIC8vIGxvYWRlcnMuXG4gICAgICAgIG1haW5TZWdtZW50TG9hZGVyLnJlc2V0RXZlcnl0aGluZygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5vbi1kZXN0cnVjdGl2ZSByZXN5bmNcbiAgICBzZWdtZW50TG9hZGVyLnJlc3luY0xvYWRlcigpO1xuXG4gICAgc3RhcnRMb2FkZXJzKGFjdGl2ZUdyb3VwLnBsYXlsaXN0TG9hZGVyLCBtZWRpYVR5cGUpO1xuICB9O1xufTtcblxuZXhwb3J0cy5vbkdyb3VwQ2hhbmdlZCA9IG9uR3JvdXBDaGFuZ2VkO1xuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIG1lZGlhIHRyYWNrIGNoYW5nZXMuIEl0IHBlcmZvcm1zIGFcbiAqIGRlc3RydWN0aXZlIHJlc2V0IG9mIHRoZSBTZWdtZW50TG9hZGVyIHRvIGVuc3VyZSB3ZSBzdGFydCBsb2FkaW5nIGFzIGNsb3NlIHRvXG4gKiBjdXJyZW50VGltZSBhcyBwb3NzaWJsZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogICAgICAgIE1lZGlhR3JvdXAgdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzXG4gKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcmVxdWlyZWQgaW5mb3JtYXRpb24gZm9yIG1lZGlhIGdyb3Vwc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiAgICAgICAgIEhhbmRsZXIgZm9yIGEgZGVzdHJ1Y3RpdmUgcmVzZXQgb2YgU2VnbWVudExvYWRlciB3aGVuIHRoZSBhY3RpdmUgbWVkaWFcbiAqICAgICAgICAgdHJhY2sgY2hhbmdlcy5cbiAqIEBmdW5jdGlvbiBvblRyYWNrQ2hhbmdlZFxuICovXG52YXIgb25UcmFja0NoYW5nZWQgPSBmdW5jdGlvbiBvblRyYWNrQ2hhbmdlZCh0eXBlLCBzZXR0aW5ncykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfc2V0dGluZ3Mkc2VnbWVudExvYWRlcnMyID0gc2V0dGluZ3Muc2VnbWVudExvYWRlcnM7XG4gICAgdmFyIHNlZ21lbnRMb2FkZXIgPSBfc2V0dGluZ3Mkc2VnbWVudExvYWRlcnMyW3R5cGVdO1xuICAgIHZhciBtYWluU2VnbWVudExvYWRlciA9IF9zZXR0aW5ncyRzZWdtZW50TG9hZGVyczIubWFpbjtcbiAgICB2YXIgbWVkaWFUeXBlID0gc2V0dGluZ3MubWVkaWFUeXBlc1t0eXBlXTtcblxuICAgIHZhciBhY3RpdmVUcmFjayA9IG1lZGlhVHlwZS5hY3RpdmVUcmFjaygpO1xuICAgIHZhciBhY3RpdmVHcm91cCA9IG1lZGlhVHlwZS5hY3RpdmVHcm91cChhY3RpdmVUcmFjayk7XG4gICAgdmFyIHByZXZpb3VzQWN0aXZlTG9hZGVyID0gbWVkaWFUeXBlLmFjdGl2ZVBsYXlsaXN0TG9hZGVyO1xuXG4gICAgc3RvcExvYWRlcnMoc2VnbWVudExvYWRlciwgbWVkaWFUeXBlKTtcblxuICAgIGlmICghYWN0aXZlR3JvdXApIHtcbiAgICAgIC8vIHRoZXJlIGlzIG5vIGdyb3VwIGFjdGl2ZSBzbyB3ZSBkbyBub3Qgd2FudCB0byByZXN0YXJ0IGxvYWRlcnNcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWFjdGl2ZUdyb3VwLnBsYXlsaXN0TG9hZGVyKSB7XG4gICAgICAvLyB3aGVuIHN3aXRjaGluZyBmcm9tIGRlbXV4ZWQgYXVkaW8vdmlkZW8gdG8gbXV4ZWQgYXVkaW8vdmlkZW8gKG5vdGVkIGJ5IG5vIHBsYXlsaXN0XG4gICAgICAvLyBsb2FkZXIgZm9yIHRoZSBhdWRpbyBncm91cCksIHdlIHdhbnQgdG8gZG8gYSBkZXN0cnVjdGl2ZSByZXNldCBvZiB0aGUgbWFpbiBzZWdtZW50XG4gICAgICAvLyBsb2FkZXIgYW5kIG5vdCByZXN0YXJ0IHRoZSBhdWRpbyBsb2FkZXJzXG4gICAgICBtYWluU2VnbWVudExvYWRlci5yZXNldEV2ZXJ5dGhpbmcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJldmlvdXNBY3RpdmVMb2FkZXIgPT09IGFjdGl2ZUdyb3VwLnBsYXlsaXN0TG9hZGVyKSB7XG4gICAgICAvLyBOb3RoaW5nIGhhcyBhY3R1YWxseSBjaGFuZ2VkLiBUaGlzIGNhbiBoYXBwZW4gYmVjYXVzZSB0cmFjayBjaGFuZ2UgZXZlbnRzIGNhbiBmaXJlXG4gICAgICAvLyBtdWx0aXBsZSB0aW1lcyBmb3IgYSBcInNpbmdsZVwiIGNoYW5nZS4gT25lIGZvciBlbmFibGluZyB0aGUgbmV3IGFjdGl2ZSB0cmFjaywgYW5kXG4gICAgICAvLyBvbmUgZm9yIGRpc2FibGluZyB0aGUgdHJhY2sgdGhhdCB3YXMgYWN0aXZlXG4gICAgICBzdGFydExvYWRlcnMoYWN0aXZlR3JvdXAucGxheWxpc3RMb2FkZXIsIG1lZGlhVHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnRMb2FkZXIudHJhY2spIHtcbiAgICAgIC8vIEZvciBXZWJWVFQsIHNldCB0aGUgbmV3IHRleHQgdHJhY2sgaW4gdGhlIHNlZ21lbnRsb2FkZXJcbiAgICAgIHNlZ21lbnRMb2FkZXIudHJhY2soYWN0aXZlVHJhY2spO1xuICAgIH1cblxuICAgIC8vIGRlc3RydWN0aXZlIHJlc2V0XG4gICAgc2VnbWVudExvYWRlci5yZXNldEV2ZXJ5dGhpbmcoKTtcblxuICAgIHN0YXJ0TG9hZGVycyhhY3RpdmVHcm91cC5wbGF5bGlzdExvYWRlciwgbWVkaWFUeXBlKTtcbiAgfTtcbn07XG5cbmV4cG9ydHMub25UcmFja0NoYW5nZWQgPSBvblRyYWNrQ2hhbmdlZDtcbnZhciBvbkVycm9yID0ge1xuICAvKipcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIGEgU2VnbWVudExvYWRlciBvciBQbGF5bGlzdExvYWRlciBlbmNvdW50ZXJzXG4gICAqIGFuIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgTWVkaWFHcm91cCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xuICAgKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcmVxdWlyZWQgaW5mb3JtYXRpb24gZm9yIG1lZGlhIGdyb3Vwc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICogICAgICAgICBFcnJvciBoYW5kbGVyLiBMb2dzIHdhcm5pbmcgKG9yIGVycm9yIGlmIHRoZSBwbGF5bGlzdCBpcyBibGFja2xpc3RlZCkgdG9cbiAgICogICAgICAgICBjb25zb2xlIGFuZCBzd2l0Y2hlcyBiYWNrIHRvIGRlZmF1bHQgYXVkaW8gdHJhY2suXG4gICAqIEBmdW5jdGlvbiBvbkVycm9yLkFVRElPXG4gICAqL1xuICBBVURJTzogZnVuY3Rpb24gQVVESU8odHlwZSwgc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlZ21lbnRMb2FkZXIgPSBzZXR0aW5ncy5zZWdtZW50TG9hZGVyc1t0eXBlXTtcbiAgICAgIHZhciBtZWRpYVR5cGUgPSBzZXR0aW5ncy5tZWRpYVR5cGVzW3R5cGVdO1xuICAgICAgdmFyIGJsYWNrbGlzdEN1cnJlbnRQbGF5bGlzdCA9IHNldHRpbmdzLmJsYWNrbGlzdEN1cnJlbnRQbGF5bGlzdDtcblxuICAgICAgc3RvcExvYWRlcnMoc2VnbWVudExvYWRlciwgbWVkaWFUeXBlKTtcblxuICAgICAgLy8gc3dpdGNoIGJhY2sgdG8gZGVmYXVsdCBhdWRpbyB0cmFja1xuICAgICAgdmFyIGFjdGl2ZVRyYWNrID0gbWVkaWFUeXBlLmFjdGl2ZVRyYWNrKCk7XG4gICAgICB2YXIgYWN0aXZlR3JvdXAgPSBtZWRpYVR5cGUuYWN0aXZlR3JvdXAoKTtcbiAgICAgIHZhciBpZCA9IChhY3RpdmVHcm91cC5maWx0ZXIoZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBncm91cFsnZGVmYXVsdCddO1xuICAgICAgfSlbMF0gfHwgYWN0aXZlR3JvdXBbMF0pLmlkO1xuICAgICAgdmFyIGRlZmF1bHRUcmFjayA9IG1lZGlhVHlwZS50cmFja3NbaWRdO1xuXG4gICAgICBpZiAoYWN0aXZlVHJhY2sgPT09IGRlZmF1bHRUcmFjaykge1xuICAgICAgICAvLyBEZWZhdWx0IHRyYWNrIGVuY291bnRlcmVkIGFuIGVycm9yLiBBbGwgd2UgY2FuIGRvIG5vdyBpcyBibGFja2xpc3QgdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gcmVuZGl0aW9uIGFuZCBob3BlIGFub3RoZXIgd2lsbCBzd2l0Y2ggYXVkaW8gZ3JvdXBzXG4gICAgICAgIGJsYWNrbGlzdEN1cnJlbnRQbGF5bGlzdCh7XG4gICAgICAgICAgbWVzc2FnZTogJ1Byb2JsZW0gZW5jb3VudGVyZWQgbG9hZGluZyB0aGUgZGVmYXVsdCBhdWRpbyB0cmFjay4nXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF92aWRlb0pzMlsnZGVmYXVsdCddLmxvZy53YXJuKCdQcm9ibGVtIGVuY291bnRlcmVkIGxvYWRpbmcgdGhlIGFsdGVybmF0ZSBhdWRpbyB0cmFjay4nICsgJ1N3aXRjaGluZyBiYWNrIHRvIGRlZmF1bHQuJyk7XG5cbiAgICAgIGZvciAodmFyIHRyYWNrSWQgaW4gbWVkaWFUeXBlLnRyYWNrcykge1xuICAgICAgICBtZWRpYVR5cGUudHJhY2tzW3RyYWNrSWRdLmVuYWJsZWQgPSBtZWRpYVR5cGUudHJhY2tzW3RyYWNrSWRdID09PSBkZWZhdWx0VHJhY2s7XG4gICAgICB9XG5cbiAgICAgIG1lZGlhVHlwZS5vblRyYWNrQ2hhbmdlZCgpO1xuICAgIH07XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gYSBTZWdtZW50TG9hZGVyIG9yIFBsYXlsaXN0TG9hZGVyIGVuY291bnRlcnNcbiAgICogYW4gZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBNZWRpYUdyb3VwIHR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzXG4gICAqICAgICAgICBPYmplY3QgY29udGFpbmluZyByZXF1aXJlZCBpbmZvcm1hdGlvbiBmb3IgbWVkaWEgZ3JvdXBzXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKiAgICAgICAgIEVycm9yIGhhbmRsZXIuIExvZ3Mgd2FybmluZyB0byBjb25zb2xlIGFuZCBkaXNhYmxlcyB0aGUgYWN0aXZlIHN1YnRpdGxlIHRyYWNrXG4gICAqIEBmdW5jdGlvbiBvbkVycm9yLlNVQlRJVExFU1xuICAgKi9cbiAgU1VCVElUTEVTOiBmdW5jdGlvbiBTVUJUSVRMRVModHlwZSwgc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlZ21lbnRMb2FkZXIgPSBzZXR0aW5ncy5zZWdtZW50TG9hZGVyc1t0eXBlXTtcbiAgICAgIHZhciBtZWRpYVR5cGUgPSBzZXR0aW5ncy5tZWRpYVR5cGVzW3R5cGVdO1xuXG4gICAgICBfdmlkZW9KczJbJ2RlZmF1bHQnXS5sb2cud2FybignUHJvYmxlbSBlbmNvdW50ZXJlZCBsb2FkaW5nIHRoZSBzdWJ0aXRsZSB0cmFjay4nICsgJ0Rpc2FibGluZyBzdWJ0aXRsZSB0cmFjay4nKTtcblxuICAgICAgc3RvcExvYWRlcnMoc2VnbWVudExvYWRlciwgbWVkaWFUeXBlKTtcblxuICAgICAgdmFyIHRyYWNrID0gbWVkaWFUeXBlLmFjdGl2ZVRyYWNrKCk7XG5cbiAgICAgIGlmICh0cmFjaykge1xuICAgICAgICB0cmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgIH1cblxuICAgICAgbWVkaWFUeXBlLm9uVHJhY2tDaGFuZ2VkKCk7XG4gICAgfTtcbiAgfVxufTtcblxuZXhwb3J0cy5vbkVycm9yID0gb25FcnJvcjtcbnZhciBzZXR1cExpc3RlbmVycyA9IHtcbiAgLyoqXG4gICAqIFNldHVwIGV2ZW50IGxpc3RlbmVycyBmb3IgYXVkaW8gcGxheWxpc3QgbG9hZGVyXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBNZWRpYUdyb3VwIHR5cGVcbiAgICogQHBhcmFtIHtQbGF5bGlzdExvYWRlcnxudWxsfSBwbGF5bGlzdExvYWRlclxuICAgKiAgICAgICAgUGxheWxpc3RMb2FkZXIgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzIG9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xuICAgKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcmVxdWlyZWQgaW5mb3JtYXRpb24gZm9yIG1lZGlhIGdyb3Vwc1xuICAgKiBAZnVuY3Rpb24gc2V0dXBMaXN0ZW5lcnMuQVVESU9cbiAgICovXG4gIEFVRElPOiBmdW5jdGlvbiBBVURJTyh0eXBlLCBwbGF5bGlzdExvYWRlciwgc2V0dGluZ3MpIHtcbiAgICBpZiAoIXBsYXlsaXN0TG9hZGVyKSB7XG4gICAgICAvLyBubyBwbGF5bGlzdCBsb2FkZXIgbWVhbnMgYXVkaW8gd2lsbCBiZSBtdXhlZCB3aXRoIHRoZSB2aWRlb1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZWNoID0gc2V0dGluZ3MudGVjaDtcbiAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSBzZXR0aW5ncy5yZXF1ZXN0T3B0aW9ucztcbiAgICB2YXIgc2VnbWVudExvYWRlciA9IHNldHRpbmdzLnNlZ21lbnRMb2FkZXJzW3R5cGVdO1xuXG4gICAgcGxheWxpc3RMb2FkZXIub24oJ2xvYWRlZG1ldGFkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1lZGlhID0gcGxheWxpc3RMb2FkZXIubWVkaWEoKTtcblxuICAgICAgc2VnbWVudExvYWRlci5wbGF5bGlzdChtZWRpYSwgcmVxdWVzdE9wdGlvbnMpO1xuXG4gICAgICAvLyBpZiB0aGUgdmlkZW8gaXMgYWxyZWFkeSBwbGF5aW5nLCBvciBpZiB0aGlzIGlzbid0IGEgbGl2ZSB2aWRlbyBhbmQgcHJlbG9hZFxuICAgICAgLy8gcGVybWl0cywgc3RhcnQgZG93bmxvYWRpbmcgc2VnbWVudHNcbiAgICAgIGlmICghdGVjaC5wYXVzZWQoKSB8fCBtZWRpYS5lbmRMaXN0ICYmIHRlY2gucHJlbG9hZCgpICE9PSAnbm9uZScpIHtcbiAgICAgICAgc2VnbWVudExvYWRlci5sb2FkKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBwbGF5bGlzdExvYWRlci5vbignbG9hZGVkcGxheWxpc3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWdtZW50TG9hZGVyLnBsYXlsaXN0KHBsYXlsaXN0TG9hZGVyLm1lZGlhKCksIHJlcXVlc3RPcHRpb25zKTtcblxuICAgICAgLy8gSWYgdGhlIHBsYXllciBpc24ndCBwYXVzZWQsIGVuc3VyZSB0aGF0IHRoZSBzZWdtZW50IGxvYWRlciBpcyBydW5uaW5nXG4gICAgICBpZiAoIXRlY2gucGF1c2VkKCkpIHtcbiAgICAgICAgc2VnbWVudExvYWRlci5sb2FkKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBwbGF5bGlzdExvYWRlci5vbignZXJyb3InLCBvbkVycm9yW3R5cGVdKHR5cGUsIHNldHRpbmdzKSk7XG4gIH0sXG4gIC8qKlxuICAgKiBTZXR1cCBldmVudCBsaXN0ZW5lcnMgZm9yIHN1YnRpdGxlIHBsYXlsaXN0IGxvYWRlclxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgTWVkaWFHcm91cCB0eXBlXG4gICAqIEBwYXJhbSB7UGxheWxpc3RMb2FkZXJ8bnVsbH0gcGxheWxpc3RMb2FkZXJcbiAgICogICAgICAgIFBsYXlsaXN0TG9hZGVyIHRvIHJlZ2lzdGVyIGxpc3RlbmVycyBvblxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3NcbiAgICogICAgICAgIE9iamVjdCBjb250YWluaW5nIHJlcXVpcmVkIGluZm9ybWF0aW9uIGZvciBtZWRpYSBncm91cHNcbiAgICogQGZ1bmN0aW9uIHNldHVwTGlzdGVuZXJzLlNVQlRJVExFU1xuICAgKi9cbiAgU1VCVElUTEVTOiBmdW5jdGlvbiBTVUJUSVRMRVModHlwZSwgcGxheWxpc3RMb2FkZXIsIHNldHRpbmdzKSB7XG4gICAgdmFyIHRlY2ggPSBzZXR0aW5ncy50ZWNoO1xuICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IHNldHRpbmdzLnJlcXVlc3RPcHRpb25zO1xuICAgIHZhciBzZWdtZW50TG9hZGVyID0gc2V0dGluZ3Muc2VnbWVudExvYWRlcnNbdHlwZV07XG4gICAgdmFyIG1lZGlhVHlwZSA9IHNldHRpbmdzLm1lZGlhVHlwZXNbdHlwZV07XG5cbiAgICBwbGF5bGlzdExvYWRlci5vbignbG9hZGVkbWV0YWRhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWVkaWEgPSBwbGF5bGlzdExvYWRlci5tZWRpYSgpO1xuXG4gICAgICBzZWdtZW50TG9hZGVyLnBsYXlsaXN0KG1lZGlhLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICBzZWdtZW50TG9hZGVyLnRyYWNrKG1lZGlhVHlwZS5hY3RpdmVUcmFjaygpKTtcblxuICAgICAgLy8gaWYgdGhlIHZpZGVvIGlzIGFscmVhZHkgcGxheWluZywgb3IgaWYgdGhpcyBpc24ndCBhIGxpdmUgdmlkZW8gYW5kIHByZWxvYWRcbiAgICAgIC8vIHBlcm1pdHMsIHN0YXJ0IGRvd25sb2FkaW5nIHNlZ21lbnRzXG4gICAgICBpZiAoIXRlY2gucGF1c2VkKCkgfHwgbWVkaWEuZW5kTGlzdCAmJiB0ZWNoLnByZWxvYWQoKSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIHNlZ21lbnRMb2FkZXIubG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcGxheWxpc3RMb2FkZXIub24oJ2xvYWRlZHBsYXlsaXN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgc2VnbWVudExvYWRlci5wbGF5bGlzdChwbGF5bGlzdExvYWRlci5tZWRpYSgpLCByZXF1ZXN0T3B0aW9ucyk7XG5cbiAgICAgIC8vIElmIHRoZSBwbGF5ZXIgaXNuJ3QgcGF1c2VkLCBlbnN1cmUgdGhhdCB0aGUgc2VnbWVudCBsb2FkZXIgaXMgcnVubmluZ1xuICAgICAgaWYgKCF0ZWNoLnBhdXNlZCgpKSB7XG4gICAgICAgIHNlZ21lbnRMb2FkZXIubG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcGxheWxpc3RMb2FkZXIub24oJ2Vycm9yJywgb25FcnJvclt0eXBlXSh0eXBlLCBzZXR0aW5ncykpO1xuICB9XG59O1xuXG5leHBvcnRzLnNldHVwTGlzdGVuZXJzID0gc2V0dXBMaXN0ZW5lcnM7XG52YXIgaW5pdGlhbGl6ZSA9IHtcbiAgLyoqXG4gICAqIFNldHVwIFBsYXlsaXN0TG9hZGVycyBhbmQgQXVkaW9UcmFja3MgZm9yIHRoZSBhdWRpbyBncm91cHNcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogICAgICAgIE1lZGlhR3JvdXAgdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3NcbiAgICogICAgICAgIE9iamVjdCBjb250YWluaW5nIHJlcXVpcmVkIGluZm9ybWF0aW9uIGZvciBtZWRpYSBncm91cHNcbiAgICogQGZ1bmN0aW9uIGluaXRpYWxpemUuQVVESU9cbiAgICovXG4gICdBVURJTyc6IGZ1bmN0aW9uIEFVRElPKHR5cGUsIHNldHRpbmdzKSB7XG4gICAgdmFyIG1vZGUgPSBzZXR0aW5ncy5tb2RlO1xuICAgIHZhciBobHMgPSBzZXR0aW5ncy5obHM7XG4gICAgdmFyIHNlZ21lbnRMb2FkZXIgPSBzZXR0aW5ncy5zZWdtZW50TG9hZGVyc1t0eXBlXTtcbiAgICB2YXIgd2l0aENyZWRlbnRpYWxzID0gc2V0dGluZ3MucmVxdWVzdE9wdGlvbnMud2l0aENyZWRlbnRpYWxzO1xuICAgIHZhciBtZWRpYUdyb3VwcyA9IHNldHRpbmdzLm1hc3Rlci5tZWRpYUdyb3VwcztcbiAgICB2YXIgX3NldHRpbmdzJG1lZGlhVHlwZXMkdHlwZSA9IHNldHRpbmdzLm1lZGlhVHlwZXNbdHlwZV07XG4gICAgdmFyIGdyb3VwcyA9IF9zZXR0aW5ncyRtZWRpYVR5cGVzJHR5cGUuZ3JvdXBzO1xuICAgIHZhciB0cmFja3MgPSBfc2V0dGluZ3MkbWVkaWFUeXBlcyR0eXBlLnRyYWNrcztcblxuICAgIC8vIGZvcmNlIGEgZGVmYXVsdCBpZiB3ZSBoYXZlIG5vbmUgb3Igd2UgYXJlIG5vdFxuICAgIC8vIGluIGh0bWw1IG1vZGUgKHRoZSBvbmx5IG1vZGUgdG8gc3VwcG9ydCBtb3JlIHRoYW4gb25lXG4gICAgLy8gYXVkaW8gdHJhY2spXG4gICAgaWYgKCFtZWRpYUdyb3Vwc1t0eXBlXSB8fCBPYmplY3Qua2V5cyhtZWRpYUdyb3Vwc1t0eXBlXSkubGVuZ3RoID09PSAwIHx8IG1vZGUgIT09ICdodG1sNScpIHtcbiAgICAgIG1lZGlhR3JvdXBzW3R5cGVdID0geyBtYWluOiB7ICdkZWZhdWx0JzogeyAnZGVmYXVsdCc6IHRydWUgfSB9IH07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgZ3JvdXBJZCBpbiBtZWRpYUdyb3Vwc1t0eXBlXSkge1xuICAgICAgaWYgKCFncm91cHNbZ3JvdXBJZF0pIHtcbiAgICAgICAgZ3JvdXBzW2dyb3VwSWRdID0gW107XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHZhcmlhbnRMYWJlbCBpbiBtZWRpYUdyb3Vwc1t0eXBlXVtncm91cElkXSkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IG1lZGlhR3JvdXBzW3R5cGVdW2dyb3VwSWRdW3ZhcmlhbnRMYWJlbF07XG4gICAgICAgIHZhciBwbGF5bGlzdExvYWRlciA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAocHJvcGVydGllcy5yZXNvbHZlZFVyaSkge1xuICAgICAgICAgIHBsYXlsaXN0TG9hZGVyID0gbmV3IF9wbGF5bGlzdExvYWRlcjJbJ2RlZmF1bHQnXShwcm9wZXJ0aWVzLnJlc29sdmVkVXJpLCBobHMsIHdpdGhDcmVkZW50aWFscyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gcmVzb2x2ZWRVcmkgbWVhbnMgdGhlIGF1ZGlvIGlzIG11eGVkIHdpdGggdGhlIHZpZGVvIHdoZW4gdXNpbmcgdGhpc1xuICAgICAgICAgIC8vIGF1ZGlvIHRyYWNrXG4gICAgICAgICAgcGxheWxpc3RMb2FkZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcGVydGllcyA9IF92aWRlb0pzMlsnZGVmYXVsdCddLm1lcmdlT3B0aW9ucyh7IGlkOiB2YXJpYW50TGFiZWwsIHBsYXlsaXN0TG9hZGVyOiBwbGF5bGlzdExvYWRlciB9LCBwcm9wZXJ0aWVzKTtcblxuICAgICAgICBzZXR1cExpc3RlbmVyc1t0eXBlXSh0eXBlLCBwcm9wZXJ0aWVzLnBsYXlsaXN0TG9hZGVyLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgZ3JvdXBzW2dyb3VwSWRdLnB1c2gocHJvcGVydGllcyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0cmFja3NbdmFyaWFudExhYmVsXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YXIgdHJhY2sgPSBuZXcgX3ZpZGVvSnMyWydkZWZhdWx0J10uQXVkaW9UcmFjayh7XG4gICAgICAgICAgICBpZDogdmFyaWFudExhYmVsLFxuICAgICAgICAgICAga2luZDogYXVkaW9UcmFja0tpbmRfKHByb3BlcnRpZXMpLFxuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBsYW5ndWFnZTogcHJvcGVydGllcy5sYW5ndWFnZSxcbiAgICAgICAgICAgICdkZWZhdWx0JzogcHJvcGVydGllc1snZGVmYXVsdCddLFxuICAgICAgICAgICAgbGFiZWw6IHZhcmlhbnRMYWJlbFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdHJhY2tzW3ZhcmlhbnRMYWJlbF0gPSB0cmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldHVwIHNpbmdsZSBlcnJvciBldmVudCBoYW5kbGVyIGZvciB0aGUgc2VnbWVudCBsb2FkZXJcbiAgICBzZWdtZW50TG9hZGVyLm9uKCdlcnJvcicsIG9uRXJyb3JbdHlwZV0odHlwZSwgc2V0dGluZ3MpKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNldHVwIFBsYXlsaXN0TG9hZGVycyBhbmQgVGV4dFRyYWNrcyBmb3IgdGhlIHN1YnRpdGxlIGdyb3Vwc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgTWVkaWFHcm91cCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xuICAgKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcmVxdWlyZWQgaW5mb3JtYXRpb24gZm9yIG1lZGlhIGdyb3Vwc1xuICAgKiBAZnVuY3Rpb24gaW5pdGlhbGl6ZS5TVUJUSVRMRVNcbiAgICovXG4gICdTVUJUSVRMRVMnOiBmdW5jdGlvbiBTVUJUSVRMRVModHlwZSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgdGVjaCA9IHNldHRpbmdzLnRlY2g7XG4gICAgdmFyIGhscyA9IHNldHRpbmdzLmhscztcbiAgICB2YXIgc2VnbWVudExvYWRlciA9IHNldHRpbmdzLnNlZ21lbnRMb2FkZXJzW3R5cGVdO1xuICAgIHZhciB3aXRoQ3JlZGVudGlhbHMgPSBzZXR0aW5ncy5yZXF1ZXN0T3B0aW9ucy53aXRoQ3JlZGVudGlhbHM7XG4gICAgdmFyIG1lZGlhR3JvdXBzID0gc2V0dGluZ3MubWFzdGVyLm1lZGlhR3JvdXBzO1xuICAgIHZhciBfc2V0dGluZ3MkbWVkaWFUeXBlcyR0eXBlMiA9IHNldHRpbmdzLm1lZGlhVHlwZXNbdHlwZV07XG4gICAgdmFyIGdyb3VwcyA9IF9zZXR0aW5ncyRtZWRpYVR5cGVzJHR5cGUyLmdyb3VwcztcbiAgICB2YXIgdHJhY2tzID0gX3NldHRpbmdzJG1lZGlhVHlwZXMkdHlwZTIudHJhY2tzO1xuXG4gICAgZm9yICh2YXIgZ3JvdXBJZCBpbiBtZWRpYUdyb3Vwc1t0eXBlXSkge1xuICAgICAgaWYgKCFncm91cHNbZ3JvdXBJZF0pIHtcbiAgICAgICAgZ3JvdXBzW2dyb3VwSWRdID0gW107XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHZhcmlhbnRMYWJlbCBpbiBtZWRpYUdyb3Vwc1t0eXBlXVtncm91cElkXSkge1xuICAgICAgICBpZiAobWVkaWFHcm91cHNbdHlwZV1bZ3JvdXBJZF1bdmFyaWFudExhYmVsXS5mb3JjZWQpIHtcbiAgICAgICAgICAvLyBTdWJ0aXRsZSBwbGF5bGlzdHMgd2l0aCB0aGUgZm9yY2VkIGF0dHJpYnV0ZSBhcmUgbm90IHNlbGVjdGFibGUgaW4gU2FmYXJpLlxuICAgICAgICAgIC8vIEFjY29yZGluZyB0byBBcHBsZSdzIEhMUyBBdXRob3JpbmcgU3BlY2lmaWNhdGlvbjpcbiAgICAgICAgICAvLyAgIElmIGNvbnRlbnQgaGFzIGZvcmNlZCBzdWJ0aXRsZXMgYW5kIHJlZ3VsYXIgc3VidGl0bGVzIGluIGEgZ2l2ZW4gbGFuZ3VhZ2UsXG4gICAgICAgICAgLy8gICB0aGUgcmVndWxhciBzdWJ0aXRsZXMgdHJhY2sgaW4gdGhhdCBsYW5ndWFnZSBNVVNUIGNvbnRhaW4gYm90aCB0aGUgZm9yY2VkXG4gICAgICAgICAgLy8gICBzdWJ0aXRsZXMgYW5kIHRoZSByZWd1bGFyIHN1YnRpdGxlcyBmb3IgdGhhdCBsYW5ndWFnZS5cbiAgICAgICAgICAvLyBCZWNhdXNlIG9mIHRoaXMgcmVxdWlyZW1lbnQgYW5kIHRoYXQgU2FmYXJpIGRvZXMgbm90IGFkZCBmb3JjZWQgc3VidGl0bGVzLFxuICAgICAgICAgIC8vIGZvcmNlZCBzdWJ0aXRsZXMgYXJlIHNraXBwZWQgaGVyZSB0byBtYWludGFpbiBjb25zaXN0ZW50IGV4cGVyaWVuY2UgYWNyb3NzXG4gICAgICAgICAgLy8gYWxsIHBsYXRmb3Jtc1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBtZWRpYUdyb3Vwc1t0eXBlXVtncm91cElkXVt2YXJpYW50TGFiZWxdO1xuXG4gICAgICAgIHByb3BlcnRpZXMgPSBfdmlkZW9KczJbJ2RlZmF1bHQnXS5tZXJnZU9wdGlvbnMoe1xuICAgICAgICAgIGlkOiB2YXJpYW50TGFiZWwsXG4gICAgICAgICAgcGxheWxpc3RMb2FkZXI6IG5ldyBfcGxheWxpc3RMb2FkZXIyWydkZWZhdWx0J10ocHJvcGVydGllcy5yZXNvbHZlZFVyaSwgaGxzLCB3aXRoQ3JlZGVudGlhbHMpXG4gICAgICAgIH0sIHByb3BlcnRpZXMpO1xuXG4gICAgICAgIHNldHVwTGlzdGVuZXJzW3R5cGVdKHR5cGUsIHByb3BlcnRpZXMucGxheWxpc3RMb2FkZXIsIHNldHRpbmdzKTtcblxuICAgICAgICBncm91cHNbZ3JvdXBJZF0ucHVzaChwcm9wZXJ0aWVzKTtcblxuICAgICAgICBpZiAodHlwZW9mIHRyYWNrc1t2YXJpYW50TGFiZWxdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHZhciB0cmFjayA9IHRlY2guYWRkUmVtb3RlVGV4dFRyYWNrKHtcbiAgICAgICAgICAgIGlkOiB2YXJpYW50TGFiZWwsXG4gICAgICAgICAgICBraW5kOiAnc3VidGl0bGVzJyxcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IHByb3BlcnRpZXMubGFuZ3VhZ2UsXG4gICAgICAgICAgICBsYWJlbDogdmFyaWFudExhYmVsXG4gICAgICAgICAgfSwgZmFsc2UpLnRyYWNrO1xuXG4gICAgICAgICAgdHJhY2tzW3ZhcmlhbnRMYWJlbF0gPSB0cmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldHVwIHNpbmdsZSBlcnJvciBldmVudCBoYW5kbGVyIGZvciB0aGUgc2VnbWVudCBsb2FkZXJcbiAgICBzZWdtZW50TG9hZGVyLm9uKCdlcnJvcicsIG9uRXJyb3JbdHlwZV0odHlwZSwgc2V0dGluZ3MpKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNldHVwIFRleHRUcmFja3MgZm9yIHRoZSBjbG9zZWQtY2FwdGlvbiBncm91cHNcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogICAgICAgIE1lZGlhR3JvdXAgdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3NcbiAgICogICAgICAgIE9iamVjdCBjb250YWluaW5nIHJlcXVpcmVkIGluZm9ybWF0aW9uIGZvciBtZWRpYSBncm91cHNcbiAgICogQGZ1bmN0aW9uIGluaXRpYWxpemVbJ0NMT1NFRC1DQVBUSU9OUyddXG4gICAqL1xuICAnQ0xPU0VELUNBUFRJT05TJzogZnVuY3Rpb24gQ0xPU0VEQ0FQVElPTlModHlwZSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgdGVjaCA9IHNldHRpbmdzLnRlY2g7XG4gICAgdmFyIG1lZGlhR3JvdXBzID0gc2V0dGluZ3MubWFzdGVyLm1lZGlhR3JvdXBzO1xuICAgIHZhciBfc2V0dGluZ3MkbWVkaWFUeXBlcyR0eXBlMyA9IHNldHRpbmdzLm1lZGlhVHlwZXNbdHlwZV07XG4gICAgdmFyIGdyb3VwcyA9IF9zZXR0aW5ncyRtZWRpYVR5cGVzJHR5cGUzLmdyb3VwcztcbiAgICB2YXIgdHJhY2tzID0gX3NldHRpbmdzJG1lZGlhVHlwZXMkdHlwZTMudHJhY2tzO1xuXG4gICAgZm9yICh2YXIgZ3JvdXBJZCBpbiBtZWRpYUdyb3Vwc1t0eXBlXSkge1xuICAgICAgaWYgKCFncm91cHNbZ3JvdXBJZF0pIHtcbiAgICAgICAgZ3JvdXBzW2dyb3VwSWRdID0gW107XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHZhcmlhbnRMYWJlbCBpbiBtZWRpYUdyb3Vwc1t0eXBlXVtncm91cElkXSkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IG1lZGlhR3JvdXBzW3R5cGVdW2dyb3VwSWRdW3ZhcmlhbnRMYWJlbF07XG5cbiAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IENFQTYwOCBjYXB0aW9ucyBmb3Igbm93LCBzbyBpZ25vcmUgYW55dGhpbmcgdGhhdFxuICAgICAgICAvLyBkb2Vzbid0IHVzZSBhIENDeCBJTlNUUkVBTS1JRFxuICAgICAgICBpZiAoIXByb3BlcnRpZXMuaW5zdHJlYW1JZC5tYXRjaCgvQ0NcXGQvKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm8gUGxheWxpc3RMb2FkZXIgaXMgcmVxdWlyZWQgZm9yIENsb3NlZC1DYXB0aW9ucyBiZWNhdXNlIHRoZSBjYXB0aW9ucyBhcmVcbiAgICAgICAgLy8gZW1iZWRkZWQgd2l0aGluIHRoZSB2aWRlbyBzdHJlYW1cbiAgICAgICAgZ3JvdXBzW2dyb3VwSWRdLnB1c2goX3ZpZGVvSnMyWydkZWZhdWx0J10ubWVyZ2VPcHRpb25zKHsgaWQ6IHZhcmlhbnRMYWJlbCB9LCBwcm9wZXJ0aWVzKSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0cmFja3NbdmFyaWFudExhYmVsXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YXIgdHJhY2sgPSB0ZWNoLmFkZFJlbW90ZVRleHRUcmFjayh7XG4gICAgICAgICAgICBpZDogcHJvcGVydGllcy5pbnN0cmVhbUlkLFxuICAgICAgICAgICAga2luZDogJ2NhcHRpb25zJyxcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IHByb3BlcnRpZXMubGFuZ3VhZ2UsXG4gICAgICAgICAgICBsYWJlbDogdmFyaWFudExhYmVsXG4gICAgICAgICAgfSwgZmFsc2UpLnRyYWNrO1xuXG4gICAgICAgICAgdHJhY2tzW3ZhcmlhbnRMYWJlbF0gPSB0cmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5pbml0aWFsaXplID0gaW5pdGlhbGl6ZTtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHVzZWQgdG8gZ2V0IHRoZSBhY3RpdmUgZ3JvdXAgb2YgdGhlIHByb3ZpZGVkIHR5cGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogICAgICAgIE1lZGlhR3JvdXAgdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzXG4gKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcmVxdWlyZWQgaW5mb3JtYXRpb24gZm9yIG1lZGlhIGdyb3Vwc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiAgICAgICAgIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYWN0aXZlIG1lZGlhIGdyb3VwIGZvciB0aGUgcHJvdmlkZWQgdHlwZS4gVGFrZXMgYW5cbiAqICAgICAgICAgb3B0aW9uYWwgcGFyYW1ldGVyIHtUZXh0VHJhY2t9IHRyYWNrLiBJZiBubyB0cmFjayBpcyBwcm92aWRlZCwgYSBsaXN0IG9mIGFsbFxuICogICAgICAgICB2YXJpYW50cyBpbiB0aGUgZ3JvdXAsIG90aGVyd2lzZSB0aGUgdmFyaWFudCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZFxuICogICAgICAgICB0cmFjayBpcyByZXR1cm5lZC5cbiAqIEBmdW5jdGlvbiBhY3RpdmVHcm91cFxuICovXG52YXIgYWN0aXZlR3JvdXAgPSBmdW5jdGlvbiBhY3RpdmVHcm91cCh0eXBlLCBzZXR0aW5ncykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgdmFyIG1hc3RlclBsYXlsaXN0TG9hZGVyID0gc2V0dGluZ3MubWFzdGVyUGxheWxpc3RMb2FkZXI7XG4gICAgdmFyIGdyb3VwcyA9IHNldHRpbmdzLm1lZGlhVHlwZXNbdHlwZV0uZ3JvdXBzO1xuXG4gICAgdmFyIG1lZGlhID0gbWFzdGVyUGxheWxpc3RMb2FkZXIubWVkaWEoKTtcblxuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB2YXJpYW50cyA9IG51bGw7XG5cbiAgICBpZiAobWVkaWEuYXR0cmlidXRlc1t0eXBlXSkge1xuICAgICAgdmFyaWFudHMgPSBncm91cHNbbWVkaWEuYXR0cmlidXRlc1t0eXBlXV07XG4gICAgfVxuXG4gICAgdmFyaWFudHMgPSB2YXJpYW50cyB8fCBncm91cHMubWFpbjtcblxuICAgIGlmICh0eXBlb2YgdHJhY2sgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdmFyaWFudHM7XG4gICAgfVxuXG4gICAgaWYgKHRyYWNrID09PSBudWxsKSB7XG4gICAgICAvLyBBbiBhY3RpdmUgdHJhY2sgd2FzIHNwZWNpZmllZCBzbyBhIGNvcnJlc3BvbmRpbmcgZ3JvdXAgaXMgZXhwZWN0ZWQuIHRyYWNrID09PSBudWxsXG4gICAgICAvLyBtZWFucyBubyB0cmFjayBpcyBjdXJyZW50bHkgYWN0aXZlIHNvIHRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgZ3JvdXBcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB2YXJpYW50cy5maWx0ZXIoZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICByZXR1cm4gcHJvcHMuaWQgPT09IHRyYWNrLmlkO1xuICAgIH0pWzBdIHx8IG51bGw7XG4gIH07XG59O1xuXG5leHBvcnRzLmFjdGl2ZUdyb3VwID0gYWN0aXZlR3JvdXA7XG52YXIgYWN0aXZlVHJhY2sgPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdXNlZCB0byBnZXQgdGhlIGFjdGl2ZSB0cmFjayBvZiB0eXBlIHByb3ZpZGVkXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBNZWRpYUdyb3VwIHR5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzXG4gICAqICAgICAgICBPYmplY3QgY29udGFpbmluZyByZXF1aXJlZCBpbmZvcm1hdGlvbiBmb3IgbWVkaWEgZ3JvdXBzXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKiAgICAgICAgIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYWN0aXZlIG1lZGlhIHRyYWNrIGZvciB0aGUgcHJvdmlkZWQgdHlwZS4gUmV0dXJuc1xuICAgKiAgICAgICAgIG51bGwgaWYgbm8gdHJhY2sgaXMgYWN0aXZlXG4gICAqIEBmdW5jdGlvbiBhY3RpdmVUcmFjay5BVURJT1xuICAgKi9cbiAgQVVESU86IGZ1bmN0aW9uIEFVRElPKHR5cGUsIHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0cmFja3MgPSBzZXR0aW5ncy5tZWRpYVR5cGVzW3R5cGVdLnRyYWNrcztcblxuICAgICAgZm9yICh2YXIgaWQgaW4gdHJhY2tzKSB7XG4gICAgICAgIGlmICh0cmFja3NbaWRdLmVuYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm4gdHJhY2tzW2lkXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHVzZWQgdG8gZ2V0IHRoZSBhY3RpdmUgdHJhY2sgb2YgdHlwZSBwcm92aWRlZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgTWVkaWFHcm91cCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xuICAgKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcmVxdWlyZWQgaW5mb3JtYXRpb24gZm9yIG1lZGlhIGdyb3Vwc1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICogICAgICAgICBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGFjdGl2ZSBtZWRpYSB0cmFjayBmb3IgdGhlIHByb3ZpZGVkIHR5cGUuIFJldHVybnNcbiAgICogICAgICAgICBudWxsIGlmIG5vIHRyYWNrIGlzIGFjdGl2ZVxuICAgKiBAZnVuY3Rpb24gYWN0aXZlVHJhY2suU1VCVElUTEVTXG4gICAqL1xuICBTVUJUSVRMRVM6IGZ1bmN0aW9uIFNVQlRJVExFUyh0eXBlLCBzZXR0aW5ncykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdHJhY2tzID0gc2V0dGluZ3MubWVkaWFUeXBlc1t0eXBlXS50cmFja3M7XG5cbiAgICAgIGZvciAodmFyIGlkIGluIHRyYWNrcykge1xuICAgICAgICBpZiAodHJhY2tzW2lkXS5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICByZXR1cm4gdHJhY2tzW2lkXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG59O1xuXG5leHBvcnRzLmFjdGl2ZVRyYWNrID0gYWN0aXZlVHJhY2s7XG4vKipcbiAqIFNldHVwIFBsYXlsaXN0TG9hZGVycyBhbmQgVHJhY2tzIGZvciBtZWRpYSBncm91cHMgKEF1ZGlvLCBTdWJ0aXRsZXMsXG4gKiBDbG9zZWQtQ2FwdGlvbnMpIHNwZWNpZmllZCBpbiB0aGUgbWFzdGVyIG1hbmlmZXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xuICogICAgICAgIE9iamVjdCBjb250YWluaW5nIHJlcXVpcmVkIGluZm9ybWF0aW9uIGZvciBzZXR0aW5nIHVwIHRoZSBtZWRpYSBncm91cHNcbiAqIEBwYXJhbSB7U2VnbWVudExvYWRlcn0gc2V0dGluZ3Muc2VnbWVudExvYWRlcnMuQVVESU9cbiAqICAgICAgICBBdWRpbyBzZWdtZW50IGxvYWRlclxuICogQHBhcmFtIHtTZWdtZW50TG9hZGVyfSBzZXR0aW5ncy5zZWdtZW50TG9hZGVycy5TVUJUSVRMRVNcbiAqICAgICAgICBTdWJ0aXRsZSBzZWdtZW50IGxvYWRlclxuICogQHBhcmFtIHtTZWdtZW50TG9hZGVyfSBzZXR0aW5ncy5zZWdtZW50TG9hZGVycy5tYWluXG4gKiAgICAgICAgTWFpbiBzZWdtZW50IGxvYWRlclxuICogQHBhcmFtIHtUZWNofSBzZXR0aW5ncy50ZWNoXG4gKiAgICAgICAgVGhlIHRlY2ggb2YgdGhlIHBsYXllclxuICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLnJlcXVlc3RPcHRpb25zXG4gKiAgICAgICAgWEhSIHJlcXVlc3Qgb3B0aW9ucyB1c2VkIGJ5IHRoZSBzZWdtZW50IGxvYWRlcnNcbiAqIEBwYXJhbSB7UGxheWxpc3RMb2FkZXJ9IHNldHRpbmdzLm1hc3RlclBsYXlsaXN0TG9hZGVyXG4gKiAgICAgICAgUGxheWxpc3RMb2FkZXIgZm9yIHRoZSBtYXN0ZXIgc291cmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kZVxuICogICAgICAgIE1vZGUgb2YgdGhlIGhscyBzb3VyY2UgaGFuZGxlci4gQ2FuIGJlICdhdXRvJywgJ2h0bWw1Jywgb3IgJ2ZsYXNoJ1xuICogQHBhcmFtIHtIbHNIYW5kbGVyfSBzZXR0aW5ncy5obHNcbiAqICAgICAgICBITFMgU291cmNlSGFuZGxlclxuICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLm1hc3RlclxuICogICAgICAgIFRoZSBwYXJzZWQgbWFzdGVyIG1hbmlmZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MubWVkaWFUeXBlc1xuICogICAgICAgIE9iamVjdCB0byBzdG9yZSB0aGUgbG9hZGVycywgdHJhY2tzLCBhbmQgdXRpbGl0eSBtZXRob2RzIGZvciBlYWNoIG1lZGlhIHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRpbmdzLmJsYWNrbGlzdEN1cnJlbnRQbGF5bGlzdFxuICogICAgICAgIEJsYWNrbGlzdHMgdGhlIGN1cnJlbnQgcmVuZGl0aW9uIGFuZCBmb3JjZXMgYSByZW5kaXRpb24gc3dpdGNoLlxuICogQGZ1bmN0aW9uIHNldHVwTWVkaWFHcm91cHNcbiAqL1xudmFyIHNldHVwTWVkaWFHcm91cHMgPSBmdW5jdGlvbiBzZXR1cE1lZGlhR3JvdXBzKHNldHRpbmdzKSB7XG4gIFsnQVVESU8nLCAnU1VCVElUTEVTJywgJ0NMT1NFRC1DQVBUSU9OUyddLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpbml0aWFsaXplW3R5cGVdKHR5cGUsIHNldHRpbmdzKTtcbiAgfSk7XG5cbiAgdmFyIG1lZGlhVHlwZXMgPSBzZXR0aW5ncy5tZWRpYVR5cGVzO1xuICB2YXIgbWFzdGVyUGxheWxpc3RMb2FkZXIgPSBzZXR0aW5ncy5tYXN0ZXJQbGF5bGlzdExvYWRlcjtcbiAgdmFyIHRlY2ggPSBzZXR0aW5ncy50ZWNoO1xuICB2YXIgaGxzID0gc2V0dGluZ3MuaGxzO1xuXG4gIC8vIHNldHVwIGFjdGl2ZSBncm91cCBhbmQgdHJhY2sgZ2V0dGVycyBhbmQgY2hhbmdlIGV2ZW50IGhhbmRsZXJzXG4gIFsnQVVESU8nLCAnU1VCVElUTEVTJ10uZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIG1lZGlhVHlwZXNbdHlwZV0uYWN0aXZlR3JvdXAgPSBhY3RpdmVHcm91cCh0eXBlLCBzZXR0aW5ncyk7XG4gICAgbWVkaWFUeXBlc1t0eXBlXS5hY3RpdmVUcmFjayA9IGFjdGl2ZVRyYWNrW3R5cGVdKHR5cGUsIHNldHRpbmdzKTtcbiAgICBtZWRpYVR5cGVzW3R5cGVdLm9uR3JvdXBDaGFuZ2VkID0gb25Hcm91cENoYW5nZWQodHlwZSwgc2V0dGluZ3MpO1xuICAgIG1lZGlhVHlwZXNbdHlwZV0ub25UcmFja0NoYW5nZWQgPSBvblRyYWNrQ2hhbmdlZCh0eXBlLCBzZXR0aW5ncyk7XG4gIH0pO1xuXG4gIC8vIERPIE5PVCBlbmFibGUgdGhlIGRlZmF1bHQgc3VidGl0bGUgb3IgY2FwdGlvbiB0cmFjay5cbiAgLy8gRE8gZW5hYmxlIHRoZSBkZWZhdWx0IGF1ZGlvIHRyYWNrXG4gIHZhciBhdWRpb0dyb3VwID0gbWVkaWFUeXBlcy5BVURJTy5hY3RpdmVHcm91cCgpO1xuICB2YXIgZ3JvdXBJZCA9IChhdWRpb0dyb3VwLmZpbHRlcihmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXBbJ2RlZmF1bHQnXTtcbiAgfSlbMF0gfHwgYXVkaW9Hcm91cFswXSkuaWQ7XG5cbiAgbWVkaWFUeXBlcy5BVURJTy50cmFja3NbZ3JvdXBJZF0uZW5hYmxlZCA9IHRydWU7XG4gIG1lZGlhVHlwZXMuQVVESU8ub25UcmFja0NoYW5nZWQoKTtcblxuICBtYXN0ZXJQbGF5bGlzdExvYWRlci5vbignbWVkaWFjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgWydBVURJTycsICdTVUJUSVRMRVMnXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICByZXR1cm4gbWVkaWFUeXBlc1t0eXBlXS5vbkdyb3VwQ2hhbmdlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBjdXN0b20gYXVkaW8gdHJhY2sgY2hhbmdlIGV2ZW50IGhhbmRsZXIgZm9yIHVzYWdlIGV2ZW50XG4gIHZhciBvbkF1ZGlvVHJhY2tDaGFuZ2VkID0gZnVuY3Rpb24gb25BdWRpb1RyYWNrQ2hhbmdlZCgpIHtcbiAgICBtZWRpYVR5cGVzLkFVRElPLm9uVHJhY2tDaGFuZ2VkKCk7XG4gICAgdGVjaC50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy1hdWRpby1jaGFuZ2UnIH0pO1xuICB9O1xuXG4gIHRlY2guYXVkaW9UcmFja3MoKS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkF1ZGlvVHJhY2tDaGFuZ2VkKTtcbiAgdGVjaC5yZW1vdGVUZXh0VHJhY2tzKCkuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgbWVkaWFUeXBlcy5TVUJUSVRMRVMub25UcmFja0NoYW5nZWQpO1xuXG4gIGhscy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICB0ZWNoLmF1ZGlvVHJhY2tzKCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25BdWRpb1RyYWNrQ2hhbmdlZCk7XG4gICAgdGVjaC5yZW1vdGVUZXh0VHJhY2tzKCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgbWVkaWFUeXBlcy5TVUJUSVRMRVMub25UcmFja0NoYW5nZWQpO1xuICB9KTtcblxuICAvLyBjbGVhciBleGlzdGluZyBhdWRpbyB0cmFja3MgYW5kIGFkZCB0aGUgb25lcyB3ZSBqdXN0IGNyZWF0ZWRcbiAgdGVjaC5jbGVhclRyYWNrcygnYXVkaW8nKTtcblxuICBmb3IgKHZhciBpZCBpbiBtZWRpYVR5cGVzLkFVRElPLnRyYWNrcykge1xuICAgIHRlY2guYXVkaW9UcmFja3MoKS5hZGRUcmFjayhtZWRpYVR5cGVzLkFVRElPLnRyYWNrc1tpZF0pO1xuICB9XG59O1xuXG5leHBvcnRzLnNldHVwTWVkaWFHcm91cHMgPSBzZXR1cE1lZGlhR3JvdXBzO1xuLyoqXG4gKiBDcmVhdGVzIHNrZWxldG9uIG9iamVjdCB1c2VkIHRvIHN0b3JlIHRoZSBsb2FkZXJzLCB0cmFja3MsIGFuZCB1dGlsaXR5IG1ldGhvZHMgZm9yIGVhY2hcbiAqIG1lZGlhIHR5cGVcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIE9iamVjdCB0byBzdG9yZSB0aGUgbG9hZGVycywgdHJhY2tzLCBhbmQgdXRpbGl0eSBtZXRob2RzIGZvciBlYWNoIG1lZGlhIHR5cGVcbiAqIEBmdW5jdGlvbiBjcmVhdGVNZWRpYVR5cGVzXG4gKi9cbnZhciBjcmVhdGVNZWRpYVR5cGVzID0gZnVuY3Rpb24gY3JlYXRlTWVkaWFUeXBlcygpIHtcbiAgdmFyIG1lZGlhVHlwZXMgPSB7fTtcblxuICBbJ0FVRElPJywgJ1NVQlRJVExFUycsICdDTE9TRUQtQ0FQVElPTlMnXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgbWVkaWFUeXBlc1t0eXBlXSA9IHtcbiAgICAgIGdyb3Vwczoge30sXG4gICAgICB0cmFja3M6IHt9LFxuICAgICAgYWN0aXZlUGxheWxpc3RMb2FkZXI6IG51bGwsXG4gICAgICBhY3RpdmVHcm91cDogbm9vcCxcbiAgICAgIGFjdGl2ZVRyYWNrOiBub29wLFxuICAgICAgb25Hcm91cENoYW5nZWQ6IG5vb3AsXG4gICAgICBvblRyYWNrQ2hhbmdlZDogbm9vcFxuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiBtZWRpYVR5cGVzO1xufTtcbmV4cG9ydHMuY3JlYXRlTWVkaWFUeXBlcyA9IGNyZWF0ZU1lZGlhVHlwZXM7XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi9wbGF5bGlzdC1sb2FkZXJcIjo5fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfdmlkZW9KcyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2aWRlb2pzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd2aWRlb2pzJ10gOiBudWxsKTtcblxudmFyIF92aWRlb0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvSnMpO1xuXG52YXIgX2JpblV0aWxzID0gcmVxdWlyZSgnLi9iaW4tdXRpbHMnKTtcblxudmFyIFJFUVVFU1RfRVJST1JTID0ge1xuICBGQUlMVVJFOiAyLFxuICBUSU1FT1VUOiAtMTAxLFxuICBBQk9SVEVEOiAtMTAyXG59O1xuXG5leHBvcnRzLlJFUVVFU1RfRVJST1JTID0gUkVRVUVTVF9FUlJPUlM7XG4vKipcbiAqIFR1cm5zIHNlZ21lbnQgYnl0ZXJhbmdlIGludG8gYSBzdHJpbmcgc3VpdGFibGUgZm9yIHVzZSBpblxuICogSFRUUCBSYW5nZSByZXF1ZXN0c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBieXRlcmFuZ2UgLSBhbiBvYmplY3Qgd2l0aCB0d28gdmFsdWVzIGRlZmluaW5nIHRoZSBzdGFydCBhbmQgZW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgYSBieXRlLXJhbmdlXG4gKi9cbnZhciBieXRlcmFuZ2VTdHIgPSBmdW5jdGlvbiBieXRlcmFuZ2VTdHIoYnl0ZXJhbmdlKSB7XG4gIHZhciBieXRlcmFuZ2VTdGFydCA9IHVuZGVmaW5lZDtcbiAgdmFyIGJ5dGVyYW5nZUVuZCA9IHVuZGVmaW5lZDtcblxuICAvLyBgYnl0ZXJhbmdlRW5kYCBpcyBvbmUgbGVzcyB0aGFuIGBvZmZzZXQgKyBsZW5ndGhgIGJlY2F1c2UgdGhlIEhUVFAgcmFuZ2VcbiAgLy8gaGVhZGVyIHVzZXMgaW5jbHVzaXZlIHJhbmdlc1xuICBieXRlcmFuZ2VFbmQgPSBieXRlcmFuZ2Uub2Zmc2V0ICsgYnl0ZXJhbmdlLmxlbmd0aCAtIDE7XG4gIGJ5dGVyYW5nZVN0YXJ0ID0gYnl0ZXJhbmdlLm9mZnNldDtcbiAgcmV0dXJuICdieXRlcz0nICsgYnl0ZXJhbmdlU3RhcnQgKyAnLScgKyBieXRlcmFuZ2VFbmQ7XG59O1xuXG4vKipcbiAqIERlZmluZXMgaGVhZGVycyBmb3IgdXNlIGluIHRoZSB4aHIgcmVxdWVzdCBmb3IgYSBwYXJ0aWN1bGFyIHNlZ21lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNlZ21lbnQgLSBhIHNpbXBsaWZpZWQgY29weSBvZiB0aGUgc2VnbWVudEluZm8gb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gU2VnbWVudExvYWRlclxuICovXG52YXIgc2VnbWVudFhockhlYWRlcnMgPSBmdW5jdGlvbiBzZWdtZW50WGhySGVhZGVycyhzZWdtZW50KSB7XG4gIHZhciBoZWFkZXJzID0ge307XG5cbiAgaWYgKHNlZ21lbnQuYnl0ZXJhbmdlKSB7XG4gICAgaGVhZGVycy5SYW5nZSA9IGJ5dGVyYW5nZVN0cihzZWdtZW50LmJ5dGVyYW5nZSk7XG4gIH1cbiAgcmV0dXJuIGhlYWRlcnM7XG59O1xuXG4vKipcbiAqIEFib3J0IGFsbCByZXF1ZXN0c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3RpdmVYaHJzIC0gYW4gb2JqZWN0IHRoYXQgdHJhY2tzIGFsbCBYSFIgcmVxdWVzdHNcbiAqL1xudmFyIGFib3J0QWxsID0gZnVuY3Rpb24gYWJvcnRBbGwoYWN0aXZlWGhycykge1xuICBhY3RpdmVYaHJzLmZvckVhY2goZnVuY3Rpb24gKHhocikge1xuICAgIHhoci5hYm9ydCgpO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2F0aGVyIGltcG9ydGFudCBiYW5kd2lkdGggc3RhdHMgb25jZSBhIHJlcXVlc3QgaGFzIGNvbXBsZXRlZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IC0gdGhlIFhIUiByZXF1ZXN0IGZyb20gd2hpY2ggdG8gZ2F0aGVyIHN0YXRzXG4gKi9cbnZhciBnZXRSZXF1ZXN0U3RhdHMgPSBmdW5jdGlvbiBnZXRSZXF1ZXN0U3RhdHMocmVxdWVzdCkge1xuICByZXR1cm4ge1xuICAgIGJhbmR3aWR0aDogcmVxdWVzdC5iYW5kd2lkdGgsXG4gICAgYnl0ZXNSZWNlaXZlZDogcmVxdWVzdC5ieXRlc1JlY2VpdmVkIHx8IDAsXG4gICAgcm91bmRUcmlwVGltZTogcmVxdWVzdC5yb3VuZFRyaXBUaW1lIHx8IDBcbiAgfTtcbn07XG5cbi8qKlxuICogSWYgcG9zc2libGUgZ2F0aGVyIGJhbmR3aWR0aCBzdGF0cyBhcyBhIHJlcXVlc3QgaXMgaW5cbiAqIHByb2dyZXNzXG4gKlxuICogQHBhcmFtIHtFdmVudH0gcHJvZ3Jlc3NFdmVudCAtIGFuIGV2ZW50IG9iamVjdCBmcm9tIGFuIFhIUidzIHByb2dyZXNzIGV2ZW50XG4gKi9cbnZhciBnZXRQcm9ncmVzc1N0YXRzID0gZnVuY3Rpb24gZ2V0UHJvZ3Jlc3NTdGF0cyhwcm9ncmVzc0V2ZW50KSB7XG4gIHZhciByZXF1ZXN0ID0gcHJvZ3Jlc3NFdmVudC50YXJnZXQ7XG4gIHZhciByb3VuZFRyaXBUaW1lID0gRGF0ZS5ub3coKSAtIHJlcXVlc3QucmVxdWVzdFRpbWU7XG4gIHZhciBzdGF0cyA9IHtcbiAgICBiYW5kd2lkdGg6IEluZmluaXR5LFxuICAgIGJ5dGVzUmVjZWl2ZWQ6IDAsXG4gICAgcm91bmRUcmlwVGltZTogcm91bmRUcmlwVGltZSB8fCAwXG4gIH07XG5cbiAgc3RhdHMuYnl0ZXNSZWNlaXZlZCA9IHByb2dyZXNzRXZlbnQubG9hZGVkO1xuICAvLyBUaGlzIGNhbiByZXN1bHQgaW4gSW5maW5pdHkgaWYgc3RhdHMucm91bmRUcmlwVGltZSBpcyAwIGJ1dCB0aGF0IGlzIG9rXG4gIC8vIGJlY2F1c2Ugd2Ugc2hvdWxkIG9ubHkgdXNlIGJhbmR3aWR0aCBzdGF0cyBvbiBwcm9ncmVzcyB0byBkZXRlcm1pbmUgd2hlblxuICAvLyBhYm9ydCBhIHJlcXVlc3QgZWFybHkgZHVlIHRvIGluc3VmZmljaWVudCBiYW5kd2lkdGhcbiAgc3RhdHMuYmFuZHdpZHRoID0gTWF0aC5mbG9vcihzdGF0cy5ieXRlc1JlY2VpdmVkIC8gc3RhdHMucm91bmRUcmlwVGltZSAqIDggKiAxMDAwKTtcblxuICByZXR1cm4gc3RhdHM7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBhbGwgZXJyb3IgY29uZGl0aW9ucyBpbiBvbmUgcGxhY2UgYW5kIHJldHVybiBhbiBvYmplY3RcbiAqIHdpdGggYWxsIHRoZSBpbmZvcm1hdGlvblxuICpcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgLSBpZiBub24tbnVsbCBzaWduYWxzIGFuIGVycm9yIG9jY3VyZWQgd2l0aCB0aGUgWEhSXG4gKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCAtICB0aGUgWEhSIHJlcXVlc3QgdGhhdCBwb3NzaWJseSBnZW5lcmF0ZWQgdGhlIGVycm9yXG4gKi9cbnZhciBoYW5kbGVFcnJvcnMgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcnMoZXJyb3IsIHJlcXVlc3QpIHtcbiAgaWYgKHJlcXVlc3QudGltZWRvdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgIG1lc3NhZ2U6ICdITFMgcmVxdWVzdCB0aW1lZC1vdXQgYXQgVVJMOiAnICsgcmVxdWVzdC51cmksXG4gICAgICBjb2RlOiBSRVFVRVNUX0VSUk9SUy5USU1FT1VULFxuICAgICAgeGhyOiByZXF1ZXN0XG4gICAgfTtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LmFib3J0ZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgIG1lc3NhZ2U6ICdITFMgcmVxdWVzdCBhYm9ydGVkIGF0IFVSTDogJyArIHJlcXVlc3QudXJpLFxuICAgICAgY29kZTogUkVRVUVTVF9FUlJPUlMuQUJPUlRFRCxcbiAgICAgIHhocjogcmVxdWVzdFxuICAgIH07XG4gIH1cblxuICBpZiAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgIG1lc3NhZ2U6ICdITFMgcmVxdWVzdCBlcnJvcmVkIGF0IFVSTDogJyArIHJlcXVlc3QudXJpLFxuICAgICAgY29kZTogUkVRVUVTVF9FUlJPUlMuRkFJTFVSRSxcbiAgICAgIHhocjogcmVxdWVzdFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogSGFuZGxlIHJlc3BvbnNlcyBmb3Iga2V5IGRhdGEgYW5kIGNvbnZlcnQgdGhlIGtleSBkYXRhIHRvIHRoZSBjb3JyZWN0IGZvcm1hdFxuICogZm9yIHRoZSBkZWNyeXB0aW9uIHN0ZXAgbGF0ZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudCAtIGEgc2ltcGxpZmllZCBjb3B5IG9mIHRoZSBzZWdtZW50SW5mbyBvYmplY3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSBTZWdtZW50TG9hZGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5pc2hQcm9jZXNzaW5nRm4gLSBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgdG8gY29udGludWUgcHJvY2Vzc2luZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyByZXF1ZXN0XG4gKi9cbnZhciBoYW5kbGVLZXlSZXNwb25zZSA9IGZ1bmN0aW9uIGhhbmRsZUtleVJlc3BvbnNlKHNlZ21lbnQsIGZpbmlzaFByb2Nlc3NpbmdGbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGVycm9yLCByZXF1ZXN0KSB7XG4gICAgdmFyIHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICB2YXIgZXJyb3JPYmogPSBoYW5kbGVFcnJvcnMoZXJyb3IsIHJlcXVlc3QpO1xuXG4gICAgaWYgKGVycm9yT2JqKSB7XG4gICAgICByZXR1cm4gZmluaXNoUHJvY2Vzc2luZ0ZuKGVycm9yT2JqLCBzZWdtZW50KTtcbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2UuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIHJldHVybiBmaW5pc2hQcm9jZXNzaW5nRm4oe1xuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBITFMga2V5IGF0IFVSTDogJyArIHJlcXVlc3QudXJpLFxuICAgICAgICBjb2RlOiBSRVFVRVNUX0VSUk9SUy5GQUlMVVJFLFxuICAgICAgICB4aHI6IHJlcXVlc3RcbiAgICAgIH0sIHNlZ21lbnQpO1xuICAgIH1cblxuICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KHJlc3BvbnNlKTtcblxuICAgIHNlZ21lbnQua2V5LmJ5dGVzID0gbmV3IFVpbnQzMkFycmF5KFt2aWV3LmdldFVpbnQzMigwKSwgdmlldy5nZXRVaW50MzIoNCksIHZpZXcuZ2V0VWludDMyKDgpLCB2aWV3LmdldFVpbnQzMigxMildKTtcbiAgICByZXR1cm4gZmluaXNoUHJvY2Vzc2luZ0ZuKG51bGwsIHNlZ21lbnQpO1xuICB9O1xufTtcblxuLyoqXG4gKiBIYW5kbGUgaW5pdC1zZWdtZW50IHJlc3BvbnNlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWdtZW50IC0gYSBzaW1wbGlmaWVkIGNvcHkgb2YgdGhlIHNlZ21lbnRJbmZvIG9iamVjdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIFNlZ21lbnRMb2FkZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmlzaFByb2Nlc3NpbmdGbiAtIGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB0byBjb250aW51ZSBwcm9jZXNzaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHJlcXVlc3RcbiAqL1xudmFyIGhhbmRsZUluaXRTZWdtZW50UmVzcG9uc2UgPSBmdW5jdGlvbiBoYW5kbGVJbml0U2VnbWVudFJlc3BvbnNlKHNlZ21lbnQsIGZpbmlzaFByb2Nlc3NpbmdGbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGVycm9yLCByZXF1ZXN0KSB7XG4gICAgdmFyIHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICB2YXIgZXJyb3JPYmogPSBoYW5kbGVFcnJvcnMoZXJyb3IsIHJlcXVlc3QpO1xuXG4gICAgaWYgKGVycm9yT2JqKSB7XG4gICAgICByZXR1cm4gZmluaXNoUHJvY2Vzc2luZ0ZuKGVycm9yT2JqLCBzZWdtZW50KTtcbiAgICB9XG5cbiAgICAvLyBzdG9wIHByb2Nlc3NpbmcgaWYgcmVjZWl2ZWQgZW1wdHkgY29udGVudFxuICAgIGlmIChyZXNwb25zZS5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmluaXNoUHJvY2Vzc2luZ0ZuKHtcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgbWVzc2FnZTogJ0VtcHR5IEhMUyBzZWdtZW50IGNvbnRlbnQgYXQgVVJMOiAnICsgcmVxdWVzdC51cmksXG4gICAgICAgIGNvZGU6IFJFUVVFU1RfRVJST1JTLkZBSUxVUkUsXG4gICAgICAgIHhocjogcmVxdWVzdFxuICAgICAgfSwgc2VnbWVudCk7XG4gICAgfVxuXG4gICAgc2VnbWVudC5tYXAuYnl0ZXMgPSBuZXcgVWludDhBcnJheShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICByZXR1cm4gZmluaXNoUHJvY2Vzc2luZ0ZuKG51bGwsIHNlZ21lbnQpO1xuICB9O1xufTtcblxuLyoqXG4gKiBSZXNwb25zZSBoYW5kbGVyIGZvciBzZWdtZW50LXJlcXVlc3RzIGJlaW5nIHN1cmUgdG8gc2V0IHRoZSBjb3JyZWN0XG4gKiBwcm9wZXJ0eSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgc2VnbWVudCBpcyBlbmNyeXBlZCBvciBub3RcbiAqIEFsc28gcmVjb3JkcyBhbmQga2VlcHMgdHJhY2sgb2Ygc3RhdHMgdGhhdCBhcmUgdXNlZCBmb3IgQUJSIHB1cnBvc2VzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNlZ21lbnQgLSBhIHNpbXBsaWZpZWQgY29weSBvZiB0aGUgc2VnbWVudEluZm8gb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gU2VnbWVudExvYWRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZmluaXNoUHJvY2Vzc2luZ0ZuIC0gYSBjYWxsYmFjayB0byBleGVjdXRlIHRvIGNvbnRpbnVlIHByb2Nlc3NpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgcmVxdWVzdFxuICovXG52YXIgaGFuZGxlU2VnbWVudFJlc3BvbnNlID0gZnVuY3Rpb24gaGFuZGxlU2VnbWVudFJlc3BvbnNlKHNlZ21lbnQsIGZpbmlzaFByb2Nlc3NpbmdGbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGVycm9yLCByZXF1ZXN0KSB7XG4gICAgdmFyIHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICB2YXIgZXJyb3JPYmogPSBoYW5kbGVFcnJvcnMoZXJyb3IsIHJlcXVlc3QpO1xuXG4gICAgaWYgKGVycm9yT2JqKSB7XG4gICAgICByZXR1cm4gZmluaXNoUHJvY2Vzc2luZ0ZuKGVycm9yT2JqLCBzZWdtZW50KTtcbiAgICB9XG5cbiAgICAvLyBzdG9wIHByb2Nlc3NpbmcgaWYgcmVjZWl2ZWQgZW1wdHkgY29udGVudFxuICAgIGlmIChyZXNwb25zZS5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmluaXNoUHJvY2Vzc2luZ0ZuKHtcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgbWVzc2FnZTogJ0VtcHR5IEhMUyBzZWdtZW50IGNvbnRlbnQgYXQgVVJMOiAnICsgcmVxdWVzdC51cmksXG4gICAgICAgIGNvZGU6IFJFUVVFU1RfRVJST1JTLkZBSUxVUkUsXG4gICAgICAgIHhocjogcmVxdWVzdFxuICAgICAgfSwgc2VnbWVudCk7XG4gICAgfVxuXG4gICAgc2VnbWVudC5zdGF0cyA9IGdldFJlcXVlc3RTdGF0cyhyZXF1ZXN0KTtcblxuICAgIGlmIChzZWdtZW50LmtleSkge1xuICAgICAgc2VnbWVudC5lbmNyeXB0ZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHJlcXVlc3QucmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWdtZW50LmJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmlzaFByb2Nlc3NpbmdGbihudWxsLCBzZWdtZW50KTtcbiAgfTtcbn07XG5cbi8qKlxuICogRGVjcnlwdCB0aGUgc2VnbWVudCB2aWEgdGhlIGRlY3J5cHRpb24gd2ViIHdvcmtlclxuICpcbiAqIEBwYXJhbSB7V2ViV29ya2VyfSBkZWNyeXB0ZXIgLSBhIFdlYldvcmtlciBpbnRlcmZhY2UgdG8gQUVTLTEyOCBkZWNyeXB0aW9uIHJvdXRpbmVzXG4gKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudCAtIGEgc2ltcGxpZmllZCBjb3B5IG9mIHRoZSBzZWdtZW50SW5mbyBvYmplY3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSBTZWdtZW50TG9hZGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lRm4gLSBhIGNhbGxiYWNrIHRoYXQgaXMgZXhlY3V0ZWQgYWZ0ZXIgZGVjcnlwdGlvbiBoYXMgY29tcGxldGVkXG4gKi9cbnZhciBkZWNyeXB0U2VnbWVudCA9IGZ1bmN0aW9uIGRlY3J5cHRTZWdtZW50KGRlY3J5cHRlciwgc2VnbWVudCwgZG9uZUZuKSB7XG4gIHZhciBkZWNyeXB0aW9uSGFuZGxlciA9IGZ1bmN0aW9uIGRlY3J5cHRpb25IYW5kbGVyKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmRhdGEuc291cmNlID09PSBzZWdtZW50LnJlcXVlc3RJZCkge1xuICAgICAgZGVjcnlwdGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBkZWNyeXB0aW9uSGFuZGxlcik7XG4gICAgICB2YXIgZGVjcnlwdGVkID0gZXZlbnQuZGF0YS5kZWNyeXB0ZWQ7XG5cbiAgICAgIHNlZ21lbnQuYnl0ZXMgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWQuYnl0ZXMsIGRlY3J5cHRlZC5ieXRlT2Zmc2V0LCBkZWNyeXB0ZWQuYnl0ZUxlbmd0aCk7XG4gICAgICByZXR1cm4gZG9uZUZuKG51bGwsIHNlZ21lbnQpO1xuICAgIH1cbiAgfTtcblxuICBkZWNyeXB0ZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGRlY3J5cHRpb25IYW5kbGVyKTtcblxuICAvLyB0aGlzIGlzIGFuIGVuY3J5cHRlZCBzZWdtZW50XG4gIC8vIGluY3JlbWVudGFsbHkgZGVjcnlwdCB0aGUgc2VnbWVudFxuICBkZWNyeXB0ZXIucG9zdE1lc3NhZ2UoKDAsIF9iaW5VdGlscy5jcmVhdGVUcmFuc2ZlcmFibGVNZXNzYWdlKSh7XG4gICAgc291cmNlOiBzZWdtZW50LnJlcXVlc3RJZCxcbiAgICBlbmNyeXB0ZWQ6IHNlZ21lbnQuZW5jcnlwdGVkQnl0ZXMsXG4gICAga2V5OiBzZWdtZW50LmtleS5ieXRlcyxcbiAgICBpdjogc2VnbWVudC5rZXkuaXZcbiAgfSksIFtzZWdtZW50LmVuY3J5cHRlZEJ5dGVzLmJ1ZmZlciwgc2VnbWVudC5rZXkuYnl0ZXMuYnVmZmVyXSk7XG59O1xuXG4vKipcbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdG8gZ2V0IHRoZSBtb3N0IHBlcnRpbmVudCBlcnJvciBmcm9tIHRoZVxuICogYXJyYXkgb2YgZXJyb3JzLlxuICogRm9yIGluc3RhbmNlIGlmIGEgdGltZW91dCBhbmQgdHdvIGFib3J0cyBvY2N1ciwgdGhlbiB0aGUgYWJvcnRzIHdlcmVcbiAqIGxpa2VseSB0cmlnZ2VyZWQgYnkgdGhlIHRpbWVvdXQgc28gcmV0dXJuIHRoYXQgZXJyb3Igb2JqZWN0LlxuICovXG52YXIgZ2V0TW9zdEltcG9ydGFudEVycm9yID0gZnVuY3Rpb24gZ2V0TW9zdEltcG9ydGFudEVycm9yKGVycm9ycykge1xuICByZXR1cm4gZXJyb3JzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgZXJyKSB7XG4gICAgcmV0dXJuIGVyci5jb2RlID4gcHJldi5jb2RlID8gZXJyIDogcHJldjtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2FpdHMgZm9yIGFsbCBYSFJzIHRvIGZpbmlzaCAod2l0aCBlaXRoZXIgc3VjY2VzcyBvciBmYWlsdXJlKVxuICogYmVmb3JlIGNvbnRpbnVlaW5nIHByb2Nlc3NpbmcgdmlhIGl0J3MgY2FsbGJhY2suIFRoZSBmdW5jdGlvbiBnYXRoZXJzIGVycm9yc1xuICogZnJvbSBlYWNoIHJlcXVlc3QgaW50byBhIHNpbmdsZSBlcnJvcnMgYXJyYXkgc28gdGhhdCB0aGUgZXJyb3Igc3RhdHVzIGZvclxuICogZWFjaCByZXF1ZXN0IGNhbiBiZSBleGFtaW5lZCBsYXRlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aXZlWGhycyAtIGFuIG9iamVjdCB0aGF0IHRyYWNrcyBhbGwgWEhSIHJlcXVlc3RzXG4gKiBAcGFyYW0ge1dlYldvcmtlcn0gZGVjcnlwdGVyIC0gYSBXZWJXb3JrZXIgaW50ZXJmYWNlIHRvIEFFUy0xMjggZGVjcnlwdGlvbiByb3V0aW5lc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZUZuIC0gYSBjYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIGFmdGVyIGFsbCByZXNvdXJjZXMgaGF2ZSBiZWVuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZGVkIGFuZCBhbnkgZGVjcnlwdGlvbiBjb21wbGV0ZWRcbiAqL1xudmFyIHdhaXRGb3JDb21wbGV0aW9uID0gZnVuY3Rpb24gd2FpdEZvckNvbXBsZXRpb24oYWN0aXZlWGhycywgZGVjcnlwdGVyLCBkb25lRm4pIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgY291bnQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZXJyb3IsIHNlZ21lbnQpIHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBlcnJvcnMsIHdlIGhhdmUgdG8gYWJvcnQgYW55IG91dHN0YW5kaW5nIHJlcXVlc3RzXG4gICAgICBhYm9ydEFsbChhY3RpdmVYaHJzKTtcbiAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICB9XG4gICAgY291bnQgKz0gMTtcblxuICAgIGlmIChjb3VudCA9PT0gYWN0aXZlWGhycy5sZW5ndGgpIHtcbiAgICAgIC8vIEtlZXAgdHJhY2sgb2Ygd2hlbiAqYWxsKiBvZiB0aGUgcmVxdWVzdHMgaGF2ZSBjb21wbGV0ZWRcbiAgICAgIHNlZ21lbnQuZW5kT2ZBbGxSZXF1ZXN0cyA9IERhdGUubm93KCk7XG5cbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgd29yc3RFcnJvciA9IGdldE1vc3RJbXBvcnRhbnRFcnJvcihlcnJvcnMpO1xuXG4gICAgICAgIHJldHVybiBkb25lRm4od29yc3RFcnJvciwgc2VnbWVudCk7XG4gICAgICB9XG4gICAgICBpZiAoc2VnbWVudC5lbmNyeXB0ZWRCeXRlcykge1xuICAgICAgICByZXR1cm4gZGVjcnlwdFNlZ21lbnQoZGVjcnlwdGVyLCBzZWdtZW50LCBkb25lRm4pO1xuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlLCBldmVyeXRoaW5nIGlzIHJlYWR5IGp1c3QgY29udGludWVcbiAgICAgIHJldHVybiBkb25lRm4obnVsbCwgc2VnbWVudCk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBTaW1wbGUgcHJvZ3Jlc3MgZXZlbnQgY2FsbGJhY2sgaGFuZGxlciB0aGF0IGdhdGhlcnMgc29tZSBzdGF0cyBiZWZvcmVcbiAqIGV4ZWN1dGluZyBhIHByb3ZpZGVkIGNhbGxiYWNrIHdpdGggdGhlIGBzZWdtZW50YCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudCAtIGEgc2ltcGxpZmllZCBjb3B5IG9mIHRoZSBzZWdtZW50SW5mbyBvYmplY3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSBTZWdtZW50TG9hZGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9ncmVzc0ZuIC0gYSBjYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIGVhY2ggdGltZSBhIHByb2dyZXNzIGV2ZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgcmVjZWl2ZWRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gdGhlIHByb2dyZXNzIGV2ZW50IG9iamVjdCBmcm9tIFhNTEh0dHBSZXF1ZXN0XG4gKi9cbnZhciBoYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzKHNlZ21lbnQsIHByb2dyZXNzRm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgIHNlZ21lbnQuc3RhdHMgPSBfdmlkZW9KczJbJ2RlZmF1bHQnXS5tZXJnZU9wdGlvbnMoc2VnbWVudC5zdGF0cywgZ2V0UHJvZ3Jlc3NTdGF0cyhldmVudCkpO1xuXG4gICAgLy8gcmVjb3JkIHRoZSB0aW1lIHRoYXQgd2UgcmVjZWl2ZSB0aGUgZmlyc3QgYnl0ZSBvZiBkYXRhXG4gICAgaWYgKCFzZWdtZW50LnN0YXRzLmZpcnN0Qnl0ZXNSZWNlaXZlZEF0ICYmIHNlZ21lbnQuc3RhdHMuYnl0ZXNSZWNlaXZlZCkge1xuICAgICAgc2VnbWVudC5zdGF0cy5maXJzdEJ5dGVzUmVjZWl2ZWRBdCA9IERhdGUubm93KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2dyZXNzRm4oZXZlbnQsIHNlZ21lbnQpO1xuICB9O1xufTtcblxuLyoqXG4gKiBMb2FkIGFsbCByZXNvdXJjZXMgYW5kIGRvZXMgYW55IHByb2Nlc3NpbmcgbmVjZXNzYXJ5IGZvciBhIG1lZGlhLXNlZ21lbnRcbiAqXG4gKiBGZWF0dXJlczpcbiAqICAgZGVjcnlwdHMgdGhlIG1lZGlhLXNlZ21lbnQgaWYgaXQgaGFzIGEga2V5IHVyaSBhbmQgYW4gaXZcbiAqICAgYWJvcnRzICphbGwqIHJlcXVlc3RzIGlmICphbnkqIG9uZSByZXF1ZXN0IGZhaWxzXG4gKlxuICogVGhlIHNlZ21lbnQgb2JqZWN0LCBhdCBtaW5pbXVtLCBoYXMgdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gKiB7XG4gKiAgIHJlc29sdmVkVXJpOiBTdHJpbmcsXG4gKiAgIFtieXRlcmFuZ2VdOiB7XG4gKiAgICAgb2Zmc2V0OiBOdW1iZXIsXG4gKiAgICAgbGVuZ3RoOiBOdW1iZXJcbiAqICAgfSxcbiAqICAgW2tleV06IHtcbiAqICAgICByZXNvbHZlZFVyaTogU3RyaW5nXG4gKiAgICAgW2J5dGVyYW5nZV06IHtcbiAqICAgICAgIG9mZnNldDogTnVtYmVyLFxuICogICAgICAgbGVuZ3RoOiBOdW1iZXJcbiAqICAgICB9LFxuICogICAgIGl2OiB7XG4gKiAgICAgICBieXRlczogVWludDMyQXJyYXlcbiAqICAgICB9XG4gKiAgIH0sXG4gKiAgIFttYXBdOiB7XG4gKiAgICAgcmVzb2x2ZWRVcmk6IFN0cmluZyxcbiAqICAgICBbYnl0ZXJhbmdlXToge1xuICogICAgICAgb2Zmc2V0OiBOdW1iZXIsXG4gKiAgICAgICBsZW5ndGg6IE51bWJlclxuICogICAgIH0sXG4gKiAgICAgW2J5dGVzXTogVWludDhBcnJheVxuICogICB9XG4gKiB9XG4gKiAuLi53aGVyZSBbbmFtZV0gZGVub3RlcyBvcHRpb25hbCBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0geGhyIC0gYW4gaW5zdGFuY2Ugb2YgdGhlIHhociB3cmFwcGVyIGluIHhoci5qc1xuICogQHBhcmFtIHtPYmplY3R9IHhock9wdGlvbnMgLSB0aGUgYmFzZSBvcHRpb25zIHRvIHByb3ZpZGUgdG8gYWxsIHhociByZXF1ZXN0c1xuICogQHBhcmFtIHtXZWJXb3JrZXJ9IGRlY3J5cHRpb25Xb3JrZXIgLSBhIFdlYldvcmtlciBpbnRlcmZhY2UgdG8gQUVTLTEyOFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNyeXB0aW9uIHJvdXRpbmVzXG4gKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudCAtIGEgc2ltcGxpZmllZCBjb3B5IG9mIHRoZSBzZWdtZW50SW5mbyBvYmplY3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSBTZWdtZW50TG9hZGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9ncmVzc0ZuIC0gYSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHByb2dyZXNzIGV2ZW50cyBmcm9tIHRoZSBtYWluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudCdzIHhociByZXF1ZXN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lRm4gLSBhIGNhbGxiYWNrIHRoYXQgaXMgZXhlY3V0ZWQgb25seSBvbmNlIGFsbCByZXF1ZXN0cyBoYXZlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZWVkZWQgb3IgZmFpbGVkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBpbnZva2VkLCBpbW1lZGlhdGVseSBhYm9ydHMgYWxsXG4gKiAgICAgICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nIHJlcXVlc3RzXG4gKi9cbnZhciBtZWRpYVNlZ21lbnRSZXF1ZXN0ID0gZnVuY3Rpb24gbWVkaWFTZWdtZW50UmVxdWVzdCh4aHIsIHhock9wdGlvbnMsIGRlY3J5cHRpb25Xb3JrZXIsIHNlZ21lbnQsIHByb2dyZXNzRm4sIGRvbmVGbikge1xuICB2YXIgYWN0aXZlWGhycyA9IFtdO1xuICB2YXIgZmluaXNoUHJvY2Vzc2luZ0ZuID0gd2FpdEZvckNvbXBsZXRpb24oYWN0aXZlWGhycywgZGVjcnlwdGlvbldvcmtlciwgZG9uZUZuKTtcblxuICAvLyBvcHRpb25hbGx5LCByZXF1ZXN0IHRoZSBkZWNyeXB0aW9uIGtleVxuICBpZiAoc2VnbWVudC5rZXkpIHtcbiAgICB2YXIga2V5UmVxdWVzdE9wdGlvbnMgPSBfdmlkZW9KczJbJ2RlZmF1bHQnXS5tZXJnZU9wdGlvbnMoeGhyT3B0aW9ucywge1xuICAgICAgdXJpOiBzZWdtZW50LmtleS5yZXNvbHZlZFVyaSxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJ1xuICAgIH0pO1xuICAgIHZhciBrZXlSZXF1ZXN0Q2FsbGJhY2sgPSBoYW5kbGVLZXlSZXNwb25zZShzZWdtZW50LCBmaW5pc2hQcm9jZXNzaW5nRm4pO1xuICAgIHZhciBrZXlYaHIgPSB4aHIoa2V5UmVxdWVzdE9wdGlvbnMsIGtleVJlcXVlc3RDYWxsYmFjayk7XG5cbiAgICBhY3RpdmVYaHJzLnB1c2goa2V5WGhyKTtcbiAgfVxuXG4gIC8vIG9wdGlvbmFsbHksIHJlcXVlc3QgdGhlIGFzc29jaWF0ZWQgbWVkaWEgaW5pdCBzZWdtZW50XG4gIGlmIChzZWdtZW50Lm1hcCAmJiAhc2VnbWVudC5tYXAuYnl0ZXMpIHtcbiAgICB2YXIgaW5pdFNlZ21lbnRPcHRpb25zID0gX3ZpZGVvSnMyWydkZWZhdWx0J10ubWVyZ2VPcHRpb25zKHhock9wdGlvbnMsIHtcbiAgICAgIHVyaTogc2VnbWVudC5tYXAucmVzb2x2ZWRVcmksXG4gICAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsXG4gICAgICBoZWFkZXJzOiBzZWdtZW50WGhySGVhZGVycyhzZWdtZW50Lm1hcClcbiAgICB9KTtcbiAgICB2YXIgaW5pdFNlZ21lbnRSZXF1ZXN0Q2FsbGJhY2sgPSBoYW5kbGVJbml0U2VnbWVudFJlc3BvbnNlKHNlZ21lbnQsIGZpbmlzaFByb2Nlc3NpbmdGbik7XG4gICAgdmFyIGluaXRTZWdtZW50WGhyID0geGhyKGluaXRTZWdtZW50T3B0aW9ucywgaW5pdFNlZ21lbnRSZXF1ZXN0Q2FsbGJhY2spO1xuXG4gICAgYWN0aXZlWGhycy5wdXNoKGluaXRTZWdtZW50WGhyKTtcbiAgfVxuXG4gIHZhciBzZWdtZW50UmVxdWVzdE9wdGlvbnMgPSBfdmlkZW9KczJbJ2RlZmF1bHQnXS5tZXJnZU9wdGlvbnMoeGhyT3B0aW9ucywge1xuICAgIHVyaTogc2VnbWVudC5yZXNvbHZlZFVyaSxcbiAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsXG4gICAgaGVhZGVyczogc2VnbWVudFhockhlYWRlcnMoc2VnbWVudClcbiAgfSk7XG4gIHZhciBzZWdtZW50UmVxdWVzdENhbGxiYWNrID0gaGFuZGxlU2VnbWVudFJlc3BvbnNlKHNlZ21lbnQsIGZpbmlzaFByb2Nlc3NpbmdGbik7XG4gIHZhciBzZWdtZW50WGhyID0geGhyKHNlZ21lbnRSZXF1ZXN0T3B0aW9ucywgc2VnbWVudFJlcXVlc3RDYWxsYmFjayk7XG5cbiAgc2VnbWVudFhoci5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGhhbmRsZVByb2dyZXNzKHNlZ21lbnQsIHByb2dyZXNzRm4pKTtcbiAgYWN0aXZlWGhycy5wdXNoKHNlZ21lbnRYaHIpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFib3J0QWxsKGFjdGl2ZVhocnMpO1xuICB9O1xufTtcbmV4cG9ydHMubWVkaWFTZWdtZW50UmVxdWVzdCA9IG1lZGlhU2VnbWVudFJlcXVlc3Q7XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi9iaW4tdXRpbHNcIjoyfV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIEBmaWxlIHBsYXliYWNrLXdhdGNoZXIuanNcbiAqXG4gKiBQbGF5YmFjayBzdGFydHMsIGFuZCBub3cgbXkgd2F0Y2ggYmVnaW5zLiBJdCBzaGFsbCBub3QgZW5kIHVudGlsIG15IGRlYXRoLiBJIHNoYWxsXG4gKiB0YWtlIG5vIHdhaXQsIGhvbGQgbm8gdW5jbGVhcmVkIHRpbWVvdXRzLCBmYXRoZXIgbm8gYmFkIHNlZWtzLiBJIHNoYWxsIHdlYXIgbm8gY3Jvd25zXG4gKiBhbmQgd2luIG5vIGdsb3J5LiBJIHNoYWxsIGxpdmUgYW5kIGRpZSBhdCBteSBwb3N0LiBJIGFtIHRoZSBjb3JyZWN0b3Igb2YgdGhlIHVuZGVyZmxvdy5cbiAqIEkgYW0gdGhlIHdhdGNoZXIgb2YgZ2Fwcy4gSSBhbSB0aGUgc2hpZWxkIHRoYXQgZ3VhcmRzIHRoZSByZWFsbXMgb2Ygc2Vla2FibGUuIEkgcGxlZGdlXG4gKiBteSBsaWZlIGFuZCBob25vciB0byB0aGUgUGxheWJhY2sgV2F0Y2gsIGZvciB0aGlzIFBsYXllciBhbmQgYWxsIHRoZSBQbGF5ZXJzIHRvIGNvbWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxudmFyIF9nbG9iYWxXaW5kb3cgPSByZXF1aXJlKCdnbG9iYWwvd2luZG93Jyk7XG5cbnZhciBfZ2xvYmFsV2luZG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbFdpbmRvdyk7XG5cbnZhciBfcmFuZ2VzID0gcmVxdWlyZSgnLi9yYW5nZXMnKTtcblxudmFyIF9yYW5nZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmFuZ2VzKTtcblxudmFyIF92aWRlb0pzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ3ZpZGVvanMnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ3ZpZGVvanMnXSA6IG51bGwpO1xuXG52YXIgX3ZpZGVvSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlkZW9Kcyk7XG5cbi8vIFNldCBvZiBldmVudHMgdGhhdCByZXNldCB0aGUgcGxheWJhY2std2F0Y2hlciB0aW1lIGNoZWNrIGxvZ2ljIGFuZCBjbGVhciB0aGUgdGltZW91dFxudmFyIHRpbWVyQ2FuY2VsRXZlbnRzID0gWydzZWVraW5nJywgJ3NlZWtlZCcsICdwYXVzZScsICdwbGF5aW5nJywgJ2Vycm9yJ107XG5cbi8qKlxuICogQGNsYXNzIFBsYXliYWNrV2F0Y2hlclxuICovXG5cbnZhciBQbGF5YmFja1dhdGNoZXIgPSAoZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogUmVwcmVzZW50cyBhbiBQbGF5YmFja1dhdGNoZXIgb2JqZWN0LlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgYW4gb2JqZWN0IHRoYXQgaW5jbHVkZXMgdGhlIHRlY2ggYW5kIHNldHRpbmdzXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFBsYXliYWNrV2F0Y2hlcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5YmFja1dhdGNoZXIpO1xuXG4gICAgdGhpcy50ZWNoXyA9IG9wdGlvbnMudGVjaDtcbiAgICB0aGlzLnNlZWthYmxlID0gb3B0aW9ucy5zZWVrYWJsZTtcblxuICAgIHRoaXMuY29uc2VjdXRpdmVVcGRhdGVzID0gMDtcbiAgICB0aGlzLmxhc3RSZWNvcmRlZFRpbWUgPSBudWxsO1xuICAgIHRoaXMudGltZXJfID0gbnVsbDtcbiAgICB0aGlzLmNoZWNrQ3VycmVudFRpbWVUaW1lb3V0XyA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgdGhpcy5sb2dnZXJfID0gX3ZpZGVvSnMyWydkZWZhdWx0J10ubG9nLmJpbmQoX3ZpZGVvSnMyWydkZWZhdWx0J10sICdwbGF5YmFjay13YXRjaGVyIC0+Jyk7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyXygnaW5pdGlhbGl6ZScpO1xuXG4gICAgdmFyIGNhblBsYXlIYW5kbGVyID0gZnVuY3Rpb24gY2FuUGxheUhhbmRsZXIoKSB7XG4gICAgICByZXR1cm4gX3RoaXMubW9uaXRvckN1cnJlbnRUaW1lXygpO1xuICAgIH07XG4gICAgdmFyIHdhaXRpbmdIYW5kbGVyID0gZnVuY3Rpb24gd2FpdGluZ0hhbmRsZXIoKSB7XG4gICAgICByZXR1cm4gX3RoaXMudGVjaFdhaXRpbmdfKCk7XG4gICAgfTtcbiAgICB2YXIgY2FuY2VsVGltZXJIYW5kbGVyID0gZnVuY3Rpb24gY2FuY2VsVGltZXJIYW5kbGVyKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmNhbmNlbFRpbWVyXygpO1xuICAgIH07XG4gICAgdmFyIGZpeGVzQmFkU2Vla3NIYW5kbGVyID0gZnVuY3Rpb24gZml4ZXNCYWRTZWVrc0hhbmRsZXIoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuZml4ZXNCYWRTZWVrc18oKTtcbiAgICB9O1xuXG4gICAgdGhpcy50ZWNoXy5vbignc2Vla2FibGVjaGFuZ2VkJywgZml4ZXNCYWRTZWVrc0hhbmRsZXIpO1xuICAgIHRoaXMudGVjaF8ub24oJ3dhaXRpbmcnLCB3YWl0aW5nSGFuZGxlcik7XG4gICAgdGhpcy50ZWNoXy5vbih0aW1lckNhbmNlbEV2ZW50cywgY2FuY2VsVGltZXJIYW5kbGVyKTtcbiAgICB0aGlzLnRlY2hfLm9uKCdjYW5wbGF5JywgY2FuUGxheUhhbmRsZXIpO1xuXG4gICAgLy8gRGVmaW5lIHRoZSBkaXNwb3NlIGZ1bmN0aW9uIHRvIGNsZWFuIHVwIG91ciBldmVudHNcbiAgICB0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5sb2dnZXJfKCdkaXNwb3NlJyk7XG4gICAgICBfdGhpcy50ZWNoXy5vZmYoJ3NlZWthYmxlY2hhbmdlZCcsIGZpeGVzQmFkU2Vla3NIYW5kbGVyKTtcbiAgICAgIF90aGlzLnRlY2hfLm9mZignd2FpdGluZycsIHdhaXRpbmdIYW5kbGVyKTtcbiAgICAgIF90aGlzLnRlY2hfLm9mZih0aW1lckNhbmNlbEV2ZW50cywgY2FuY2VsVGltZXJIYW5kbGVyKTtcbiAgICAgIF90aGlzLnRlY2hfLm9mZignY2FucGxheScsIGNhblBsYXlIYW5kbGVyKTtcbiAgICAgIGlmIChfdGhpcy5jaGVja0N1cnJlbnRUaW1lVGltZW91dF8pIHtcbiAgICAgICAgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5jbGVhclRpbWVvdXQoX3RoaXMuY2hlY2tDdXJyZW50VGltZVRpbWVvdXRfKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLmNhbmNlbFRpbWVyXygpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUGVyaW9kaWNhbGx5IGNoZWNrIGN1cnJlbnQgdGltZSB0byBzZWUgaWYgcGxheWJhY2sgc3RvcHBlZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoUGxheWJhY2tXYXRjaGVyLCBbe1xuICAgIGtleTogJ21vbml0b3JDdXJyZW50VGltZV8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb25pdG9yQ3VycmVudFRpbWVfKCkge1xuICAgICAgdGhpcy5jaGVja0N1cnJlbnRUaW1lXygpO1xuXG4gICAgICBpZiAodGhpcy5jaGVja0N1cnJlbnRUaW1lVGltZW91dF8pIHtcbiAgICAgICAgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5jbGVhclRpbWVvdXQodGhpcy5jaGVja0N1cnJlbnRUaW1lVGltZW91dF8pO1xuICAgICAgfVxuXG4gICAgICAvLyA0MiA9IDI0IGZwcyAvLyAyNTAgaXMgd2hhdCBXZWJraXQgdXNlcyAvLyBGRiB1c2VzIDE1XG4gICAgICB0aGlzLmNoZWNrQ3VycmVudFRpbWVUaW1lb3V0XyA9IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uc2V0VGltZW91dCh0aGlzLm1vbml0b3JDdXJyZW50VGltZV8uYmluZCh0aGlzKSwgMjUwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHVycG9zZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGVtdWxhdGUgdGhlIFwid2FpdGluZ1wiIGV2ZW50IG9uXG4gICAgICogYnJvd3NlcnMgdGhhdCBkbyBub3QgZW1pdCBpdCB3aGVuIHRoZXkgYXJlIHdhaXRpbmcgZm9yIG1vcmVcbiAgICAgKiBkYXRhIHRvIGNvbnRpbnVlIHBsYXliYWNrXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY2hlY2tDdXJyZW50VGltZV8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0N1cnJlbnRUaW1lXygpIHtcbiAgICAgIGlmICh0aGlzLnRlY2hfLnNlZWtpbmcoKSAmJiB0aGlzLmZpeGVzQmFkU2Vla3NfKCkpIHtcbiAgICAgICAgdGhpcy5jb25zZWN1dGl2ZVVwZGF0ZXMgPSAwO1xuICAgICAgICB0aGlzLmxhc3RSZWNvcmRlZFRpbWUgPSB0aGlzLnRlY2hfLmN1cnJlbnRUaW1lKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudGVjaF8ucGF1c2VkKCkgfHwgdGhpcy50ZWNoXy5zZWVraW5nKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLnRlY2hfLmN1cnJlbnRUaW1lKCk7XG4gICAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLnRlY2hfLmJ1ZmZlcmVkKCk7XG5cbiAgICAgIGlmICh0aGlzLmxhc3RSZWNvcmRlZFRpbWUgPT09IGN1cnJlbnRUaW1lICYmICghYnVmZmVyZWQubGVuZ3RoIHx8IGN1cnJlbnRUaW1lICsgX3JhbmdlczJbJ2RlZmF1bHQnXS5TQUZFX1RJTUVfREVMVEEgPj0gYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkLmxlbmd0aCAtIDEpKSkge1xuICAgICAgICAvLyBJZiBjdXJyZW50IHRpbWUgaXMgYXQgdGhlIGVuZCBvZiB0aGUgZmluYWwgYnVmZmVyZWQgcmVnaW9uLCB0aGVuIGFueSBwbGF5YmFja1xuICAgICAgICAvLyBzdGFsbCBpcyBtb3N0IGxpa2VseSBjYXVzZWQgYnkgYnVmZmVyaW5nIGluIGEgbG93IGJhbmR3aWR0aCBlbnZpcm9ubWVudC4gVGhlIHRlY2hcbiAgICAgICAgLy8gc2hvdWxkIGZpcmUgYSBgd2FpdGluZ2AgZXZlbnQgaW4gdGhpcyBzY2VuYXJpbywgYnV0IGR1ZSB0byBicm93c2VyIGFuZCB0ZWNoXG4gICAgICAgIC8vIGluY29uc2lzdGVuY2llcyAoZS5nLiBUaGUgRmxhc2ggdGVjaCBkb2VzIG5vdCBmaXJlIGEgYHdhaXRpbmdgIGV2ZW50IHdoZW4gdGhlIGVuZFxuICAgICAgICAvLyBvZiB0aGUgYnVmZmVyIGlzIHJlYWNoZWQgYW5kIGhhcyBmYWxsZW4gb2ZmIHRoZSBsaXZlIHdpbmRvdykuIENhbGxpbmdcbiAgICAgICAgLy8gYHRlY2hXYWl0aW5nX2AgaGVyZSBhbGxvd3MgdXMgdG8gc2ltdWxhdGUgcmVzcG9uZGluZyB0byBhIG5hdGl2ZSBgd2FpdGluZ2AgZXZlbnRcbiAgICAgICAgLy8gd2hlbiB0aGUgdGVjaCBmYWlscyB0byBlbWl0IG9uZS5cbiAgICAgICAgcmV0dXJuIHRoaXMudGVjaFdhaXRpbmdfKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbnNlY3V0aXZlVXBkYXRlcyA+PSA1ICYmIGN1cnJlbnRUaW1lID09PSB0aGlzLmxhc3RSZWNvcmRlZFRpbWUpIHtcbiAgICAgICAgdGhpcy5jb25zZWN1dGl2ZVVwZGF0ZXMrKztcbiAgICAgICAgdGhpcy53YWl0aW5nXygpO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50VGltZSA9PT0gdGhpcy5sYXN0UmVjb3JkZWRUaW1lKSB7XG4gICAgICAgIHRoaXMuY29uc2VjdXRpdmVVcGRhdGVzKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnNlY3V0aXZlVXBkYXRlcyA9IDA7XG4gICAgICAgIHRoaXMubGFzdFJlY29yZGVkVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYW55IHBlbmRpbmcgdGltZXJzIGFuZCByZXNldHMgdGhlICd0aW1ldXBkYXRlJyBtZWNoYW5pc21cbiAgICAgKiBkZXNpZ25lZCB0byBkZXRlY3QgdGhhdCB3ZSBhcmUgc3RhbGxlZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2NhbmNlbFRpbWVyXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbFRpbWVyXygpIHtcbiAgICAgIHRoaXMuY29uc2VjdXRpdmVVcGRhdGVzID0gMDtcblxuICAgICAgaWYgKHRoaXMudGltZXJfKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyXygnY2FuY2VsVGltZXJfJyk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyXyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGltZXJfID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXhlcyBzaXR1YXRpb25zIHdoZXJlIHRoZXJlJ3MgYSBiYWQgc2Vla1xuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBhbiBhY3Rpb24gd2FzIHRha2VuIHRvIGZpeCB0aGUgc2Vla1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdmaXhlc0JhZFNlZWtzXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpeGVzQmFkU2Vla3NfKCkge1xuICAgICAgdmFyIHNlZWtpbmcgPSB0aGlzLnRlY2hfLnNlZWtpbmcoKTtcbiAgICAgIHZhciBzZWVrYWJsZSA9IHRoaXMuc2Vla2FibGUoKTtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMudGVjaF8uY3VycmVudFRpbWUoKTtcbiAgICAgIHZhciBzZWVrVG8gPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChzZWVraW5nICYmIHRoaXMuYWZ0ZXJTZWVrYWJsZVdpbmRvd18oc2Vla2FibGUsIGN1cnJlbnRUaW1lKSkge1xuICAgICAgICB2YXIgc2Vla2FibGVFbmQgPSBzZWVrYWJsZS5lbmQoc2Vla2FibGUubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgLy8gc3luYyB0byBsaXZlIHBvaW50IChpZiBWT0QsIG91ciBzZWVrYWJsZSB3YXMgdXBkYXRlZCBhbmQgd2UncmUgc2ltcGx5IGFkanVzdGluZylcbiAgICAgICAgc2Vla1RvID0gc2Vla2FibGVFbmQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWVraW5nICYmIHRoaXMuYmVmb3JlU2Vla2FibGVXaW5kb3dfKHNlZWthYmxlLCBjdXJyZW50VGltZSkpIHtcbiAgICAgICAgdmFyIHNlZWthYmxlU3RhcnQgPSBzZWVrYWJsZS5zdGFydCgwKTtcblxuICAgICAgICAvLyBzeW5jIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpdmUgd2luZG93XG4gICAgICAgIC8vIHByb3ZpZGUgYSBidWZmZXIgb2YgLjEgc2Vjb25kcyB0byBoYW5kbGUgcm91bmRpbmcvaW1wcmVjaXNlIG51bWJlcnNcbiAgICAgICAgc2Vla1RvID0gc2Vla2FibGVTdGFydCArIF9yYW5nZXMyWydkZWZhdWx0J10uU0FGRV9USU1FX0RFTFRBO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHNlZWtUbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5sb2dnZXJfKCdUcnlpbmcgdG8gc2VlayBvdXRzaWRlIG9mIHNlZWthYmxlIGF0IHRpbWUgJyArIGN1cnJlbnRUaW1lICsgJyB3aXRoICcgKyAoJ3NlZWthYmxlIHJhbmdlICcgKyBfcmFuZ2VzMlsnZGVmYXVsdCddLnByaW50YWJsZVJhbmdlKHNlZWthYmxlKSArICcuIFNlZWtpbmcgdG8gJykgKyAoc2Vla1RvICsgJy4nKSk7XG5cbiAgICAgICAgdGhpcy50ZWNoXy5zZXRDdXJyZW50VGltZShzZWVrVG8pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIHNpdHVhdGlvbnMgd2hlbiB3ZSBkZXRlcm1pbmUgdGhlIHBsYXllciBpcyB3YWl0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3dhaXRpbmdfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2FpdGluZ18oKSB7XG4gICAgICBpZiAodGhpcy50ZWNoV2FpdGluZ18oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbCB0ZWNoIHdhaXRpbmcgY2hlY2tzIGZhaWxlZC4gVXNlIGxhc3QgcmVzb3J0IGNvcnJlY3Rpb25cbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMudGVjaF8uY3VycmVudFRpbWUoKTtcbiAgICAgIHZhciBidWZmZXJlZCA9IHRoaXMudGVjaF8uYnVmZmVyZWQoKTtcbiAgICAgIHZhciBjdXJyZW50UmFuZ2UgPSBfcmFuZ2VzMlsnZGVmYXVsdCddLmZpbmRSYW5nZShidWZmZXJlZCwgY3VycmVudFRpbWUpO1xuXG4gICAgICAvLyBTb21ldGltZXMgdGhlIHBsYXllciBjYW4gc3RhbGwgZm9yIHVua25vd24gcmVhc29ucyB3aXRoaW4gYSBjb250aWd1b3VzIGJ1ZmZlcmVkXG4gICAgICAvLyByZWdpb24gd2l0aCBubyBpbmRpY2F0aW9uIHRoYXQgYW55dGhpbmcgaXMgYW1pc3MgKHNlZW4gaW4gRmlyZWZveCkuIFNlZWtpbmcgdG9cbiAgICAgIC8vIGN1cnJlbnRUaW1lIGlzIHVzdWFsbHkgZW5vdWdoIHRvIGtpY2tzdGFydCB0aGUgcGxheWVyLiBUaGlzIGNoZWNrcyB0aGF0IHRoZSBwbGF5ZXJcbiAgICAgIC8vIGlzIGN1cnJlbnRseSB3aXRoaW4gYSBidWZmZXJlZCByZWdpb24gYmVmb3JlIGF0dGVtcHRpbmcgYSBjb3JyZWN0aXZlIHNlZWsuXG4gICAgICAvLyBDaHJvbWUgZG9lcyBub3QgYXBwZWFyIHRvIGNvbnRpbnVlIGB0aW1ldXBkYXRlYCBldmVudHMgYWZ0ZXIgYSBgd2FpdGluZ2AgZXZlbnRcbiAgICAgIC8vIHVudGlsIHRoZXJlIGlzIH4gMyBzZWNvbmRzIG9mIGZvcndhcmQgYnVmZmVyIGF2YWlsYWJsZS4gUGxheWJhY2tXYXRjaGVyIHNob3VsZCBhbHNvXG4gICAgICAvLyBtYWtlIHN1cmUgdGhlcmUgaXMgfjMgc2Vjb25kcyBvZiBmb3J3YXJkIGJ1ZmZlciBiZWZvcmUgdGFraW5nIGFueSBjb3JyZWN0aXZlIGFjdGlvblxuICAgICAgLy8gdG8gYXZvaWQgdHJpZ2dlcmluZyBhbiBgdW5rbm93bndhaXRpbmdgIGV2ZW50IHdoZW4gdGhlIG5ldHdvcmsgaXMgc2xvdy5cbiAgICAgIGlmIChjdXJyZW50UmFuZ2UubGVuZ3RoICYmIGN1cnJlbnRUaW1lICsgMyA8PSBjdXJyZW50UmFuZ2UuZW5kKDApKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsVGltZXJfKCk7XG4gICAgICAgIHRoaXMudGVjaF8uc2V0Q3VycmVudFRpbWUoY3VycmVudFRpbWUpO1xuXG4gICAgICAgIHRoaXMubG9nZ2VyXygnU3RvcHBlZCBhdCAnICsgY3VycmVudFRpbWUgKyAnIHdoaWxlIGluc2lkZSBhIGJ1ZmZlcmVkIHJlZ2lvbiAnICsgKCdbJyArIGN1cnJlbnRSYW5nZS5zdGFydCgwKSArICcgLT4gJyArIGN1cnJlbnRSYW5nZS5lbmQoMCkgKyAnXS4gQXR0ZW1wdGluZyB0byByZXN1bWUgJykgKyAncGxheWJhY2sgYnkgc2Vla2luZyB0byB0aGUgY3VycmVudCB0aW1lLicpO1xuXG4gICAgICAgIC8vIHVua25vd24gd2FpdGluZyBjb3JyZWN0aW9ucyBtYXkgYmUgdXNlZnVsIGZvciBtb25pdG9yaW5nIFFvU1xuICAgICAgICB0aGlzLnRlY2hfLnRyaWdnZXIoeyB0eXBlOiAndXNhZ2UnLCBuYW1lOiAnaGxzLXVua25vd24td2FpdGluZycgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciBzaXR1YXRpb25zIHdoZW4gdGhlIHRlY2ggZmlyZXMgYSBgd2FpdGluZ2AgZXZlbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogICAgICAgICBUcnVlIGlmIGFuIGFjdGlvbiAob3Igbm9uZSkgd2FzIG5lZWRlZCB0byBjb3JyZWN0IHRoZSB3YWl0aW5nLiBGYWxzZSBpZiBub1xuICAgICAqICAgICAgICAgY2hlY2tzIHBhc3NlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICd0ZWNoV2FpdGluZ18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZWNoV2FpdGluZ18oKSB7XG4gICAgICB2YXIgc2Vla2FibGUgPSB0aGlzLnNlZWthYmxlKCk7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLnRlY2hfLmN1cnJlbnRUaW1lKCk7XG5cbiAgICAgIGlmICh0aGlzLnRlY2hfLnNlZWtpbmcoKSAmJiB0aGlzLmZpeGVzQmFkU2Vla3NfKCkpIHtcbiAgICAgICAgLy8gVGVjaCBpcyBzZWVraW5nIG9yIGJhZCBzZWVrIGZpeGVkLCBubyBhY3Rpb24gbmVlZGVkXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50ZWNoXy5zZWVraW5nKCkgfHwgdGhpcy50aW1lcl8gIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGVjaCBpcyBzZWVraW5nIG9yIGFscmVhZHkgd2FpdGluZyBvbiBhbm90aGVyIGFjdGlvbiwgbm8gYWN0aW9uIG5lZWRlZFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmVmb3JlU2Vla2FibGVXaW5kb3dfKHNlZWthYmxlLCBjdXJyZW50VGltZSkpIHtcbiAgICAgICAgdmFyIGxpdmVQb2ludCA9IHNlZWthYmxlLmVuZChzZWVrYWJsZS5sZW5ndGggLSAxKTtcblxuICAgICAgICB0aGlzLmxvZ2dlcl8oJ0ZlbGwgb3V0IG9mIGxpdmUgd2luZG93IGF0IHRpbWUgJyArIGN1cnJlbnRUaW1lICsgJy4gU2Vla2luZyB0byAnICsgKCdsaXZlIHBvaW50IChzZWVrYWJsZSBlbmQpICcgKyBsaXZlUG9pbnQpKTtcbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lcl8oKTtcbiAgICAgICAgdGhpcy50ZWNoXy5zZXRDdXJyZW50VGltZShsaXZlUG9pbnQpO1xuXG4gICAgICAgIC8vIGxpdmUgd2luZG93IHJlc3luY3MgbWF5IGJlIHVzZWZ1bCBmb3IgbW9uaXRvcmluZyBRb1NcbiAgICAgICAgdGhpcy50ZWNoXy50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy1saXZlLXJlc3luYycgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLnRlY2hfLmJ1ZmZlcmVkKCk7XG4gICAgICB2YXIgbmV4dFJhbmdlID0gX3JhbmdlczJbJ2RlZmF1bHQnXS5maW5kTmV4dFJhbmdlKGJ1ZmZlcmVkLCBjdXJyZW50VGltZSk7XG5cbiAgICAgIGlmICh0aGlzLnZpZGVvVW5kZXJmbG93XyhuZXh0UmFuZ2UsIGJ1ZmZlcmVkLCBjdXJyZW50VGltZSkpIHtcbiAgICAgICAgLy8gRXZlbiB0aG91Z2ggdGhlIHZpZGVvIHVuZGVyZmxvd2VkIGFuZCB3YXMgc3R1Y2sgaW4gYSBnYXAsIHRoZSBhdWRpbyBvdmVycGxheWVkXG4gICAgICAgIC8vIHRoZSBnYXAsIGxlYWRpbmcgY3VycmVudFRpbWUgaW50byBhIGJ1ZmZlcmVkIHJhbmdlLiBTZWVraW5nIHRvIGN1cnJlbnRUaW1lXG4gICAgICAgIC8vIGFsbG93cyB0aGUgdmlkZW8gdG8gY2F0Y2ggdXAgdG8gdGhlIGF1ZGlvIHBvc2l0aW9uIHdpdGhvdXQgbG9zaW5nIGFueSBhdWRpb1xuICAgICAgICAvLyAob25seSBzdWZmZXJpbmcgfjMgc2Vjb25kcyBvZiBmcm96ZW4gdmlkZW8gYW5kIGEgcGF1c2UgaW4gYXVkaW8gcGxheWJhY2spLlxuICAgICAgICB0aGlzLmNhbmNlbFRpbWVyXygpO1xuICAgICAgICB0aGlzLnRlY2hfLnNldEN1cnJlbnRUaW1lKGN1cnJlbnRUaW1lKTtcblxuICAgICAgICAvLyB2aWRlbyB1bmRlcmZsb3cgbWF5IGJlIHVzZWZ1bCBmb3IgbW9uaXRvcmluZyBRb1NcbiAgICAgICAgdGhpcy50ZWNoXy50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy12aWRlby11bmRlcmZsb3cnIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgZm9yIGdhcFxuICAgICAgaWYgKG5leHRSYW5nZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBkaWZmZXJlbmNlID0gbmV4dFJhbmdlLnN0YXJ0KDApIC0gY3VycmVudFRpbWU7XG5cbiAgICAgICAgdGhpcy5sb2dnZXJfKCdTdG9wcGVkIGF0ICcgKyBjdXJyZW50VGltZSArICcsIHNldHRpbmcgdGltZXIgZm9yICcgKyBkaWZmZXJlbmNlICsgJywgc2Vla2luZyAnICsgKCd0byAnICsgbmV4dFJhbmdlLnN0YXJ0KDApKSk7XG5cbiAgICAgICAgdGhpcy50aW1lcl8gPSBzZXRUaW1lb3V0KHRoaXMuc2tpcFRoZUdhcF8uYmluZCh0aGlzKSwgZGlmZmVyZW5jZSAqIDEwMDAsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbCBjaGVja3MgZmFpbGVkLiBSZXR1cm5pbmcgZmFsc2UgdG8gaW5kaWNhdGUgZmFpbHVyZSB0byBjb3JyZWN0IHdhaXRpbmdcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZnRlclNlZWthYmxlV2luZG93XycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFmdGVyU2Vla2FibGVXaW5kb3dfKHNlZWthYmxlLCBjdXJyZW50VGltZSkge1xuICAgICAgaWYgKCFzZWVrYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgLy8gd2UgY2FuJ3QgbWFrZSBhIHNvbGlkIGNhc2UgaWYgdGhlcmUncyBubyBzZWVrYWJsZSwgZGVmYXVsdCB0byBmYWxzZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50VGltZSA+IHNlZWthYmxlLmVuZChzZWVrYWJsZS5sZW5ndGggLSAxKSArIF9yYW5nZXMyWydkZWZhdWx0J10uU0FGRV9USU1FX0RFTFRBKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYmVmb3JlU2Vla2FibGVXaW5kb3dfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlU2Vla2FibGVXaW5kb3dfKHNlZWthYmxlLCBjdXJyZW50VGltZSkge1xuICAgICAgaWYgKHNlZWthYmxlLmxlbmd0aCAmJlxuICAgICAgLy8gY2FuJ3QgZmFsbCBiZWZvcmUgMCBhbmQgMCBzZWVrYWJsZSBzdGFydCBpZGVudGlmaWVzIFZPRCBzdHJlYW1cbiAgICAgIHNlZWthYmxlLnN0YXJ0KDApID4gMCAmJiBjdXJyZW50VGltZSA8IHNlZWthYmxlLnN0YXJ0KDApIC0gX3JhbmdlczJbJ2RlZmF1bHQnXS5TQUZFX1RJTUVfREVMVEEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd2aWRlb1VuZGVyZmxvd18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWRlb1VuZGVyZmxvd18obmV4dFJhbmdlLCBidWZmZXJlZCwgY3VycmVudFRpbWUpIHtcbiAgICAgIGlmIChuZXh0UmFuZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIEV2ZW4gaWYgdGhlcmUgaXMgbm8gYXZhaWxhYmxlIG5leHQgcmFuZ2UsIHRoZXJlIGlzIHN0aWxsIGEgcG9zc2liaWxpdHkgd2UgYXJlXG4gICAgICAgIC8vIHN0dWNrIGluIGEgZ2FwIGR1ZSB0byB2aWRlbyB1bmRlcmZsb3cuXG4gICAgICAgIHZhciBnYXAgPSB0aGlzLmdhcEZyb21WaWRlb1VuZGVyZmxvd18oYnVmZmVyZWQsIGN1cnJlbnRUaW1lKTtcblxuICAgICAgICBpZiAoZ2FwKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXJfKCdFbmNvdW50ZXJlZCBhIGdhcCBpbiB2aWRlbyBmcm9tICcgKyBnYXAuc3RhcnQgKyAnIHRvICcgKyBnYXAuZW5kICsgJy4gJyArICgnU2Vla2luZyB0byBjdXJyZW50IHRpbWUgJyArIGN1cnJlbnRUaW1lKSk7XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGltZXIgY2FsbGJhY2suIElmIHBsYXliYWNrIHN0aWxsIGhhcyBub3QgcHJvY2VlZGVkLCB0aGVuIHdlIHNlZWtcbiAgICAgKiB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHQgYnVmZmVyZWQgcmVnaW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NraXBUaGVHYXBfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2tpcFRoZUdhcF8oc2NoZWR1bGVkQ3VycmVudFRpbWUpIHtcbiAgICAgIHZhciBidWZmZXJlZCA9IHRoaXMudGVjaF8uYnVmZmVyZWQoKTtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMudGVjaF8uY3VycmVudFRpbWUoKTtcbiAgICAgIHZhciBuZXh0UmFuZ2UgPSBfcmFuZ2VzMlsnZGVmYXVsdCddLmZpbmROZXh0UmFuZ2UoYnVmZmVyZWQsIGN1cnJlbnRUaW1lKTtcblxuICAgICAgdGhpcy5jYW5jZWxUaW1lcl8oKTtcblxuICAgICAgaWYgKG5leHRSYW5nZS5sZW5ndGggPT09IDAgfHwgY3VycmVudFRpbWUgIT09IHNjaGVkdWxlZEN1cnJlbnRUaW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2dnZXJfKCdza2lwVGhlR2FwXzonLCAnY3VycmVudFRpbWU6JywgY3VycmVudFRpbWUsICdzY2hlZHVsZWQgY3VycmVudFRpbWU6Jywgc2NoZWR1bGVkQ3VycmVudFRpbWUsICduZXh0UmFuZ2Ugc3RhcnQ6JywgbmV4dFJhbmdlLnN0YXJ0KDApKTtcblxuICAgICAgLy8gb25seSBzZWVrIGlmIHdlIHN0aWxsIGhhdmUgbm90IHBsYXllZFxuICAgICAgdGhpcy50ZWNoXy5zZXRDdXJyZW50VGltZShuZXh0UmFuZ2Uuc3RhcnQoMCkgKyBfcmFuZ2VzMlsnZGVmYXVsdCddLlRJTUVfRlVER0VfRkFDVE9SKTtcblxuICAgICAgdGhpcy50ZWNoXy50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy1nYXAtc2tpcCcgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2FwRnJvbVZpZGVvVW5kZXJmbG93XycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdhcEZyb21WaWRlb1VuZGVyZmxvd18oYnVmZmVyZWQsIGN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBBdCBsZWFzdCBpbiBDaHJvbWUsIGlmIHRoZXJlIGlzIGEgZ2FwIGluIHRoZSB2aWRlbyBidWZmZXIsIHRoZSBhdWRpbyB3aWxsIGNvbnRpbnVlXG4gICAgICAvLyBwbGF5aW5nIGZvciB+MyBzZWNvbmRzIGFmdGVyIHRoZSB2aWRlbyBnYXAgc3RhcnRzLiBUaGlzIGlzIGRvbmUgdG8gYWNjb3VudCBmb3JcbiAgICAgIC8vIHZpZGVvIGJ1ZmZlciB1bmRlcmZsb3cvdW5kZXJydW4gKG5vdGUgdGhhdCB0aGlzIGlzIG5vdCBkb25lIHdoZW4gdGhlcmUgaXMgYXVkaW9cbiAgICAgIC8vIGJ1ZmZlciB1bmRlcmZsb3cvdW5kZXJydW4gLS0gaW4gdGhhdCBjYXNlIHRoZSB2aWRlbyB3aWxsIHN0b3AgYXMgc29vbiBhcyBpdFxuICAgICAgLy8gZW5jb3VudGVycyB0aGUgZ2FwLCBhcyBhdWRpbyBzdGFsbHMgYXJlIG1vcmUgbm90aWNlYWJsZS9qYXJyaW5nIHRvIGEgdXNlciB0aGFuXG4gICAgICAvLyB2aWRlbyBzdGFsbHMpLiBUaGUgcGxheWVyJ3MgdGltZSB3aWxsIHJlZmxlY3QgdGhlIHBsYXl0aHJvdWdoIG9mIGF1ZGlvLCBzbyB0aGVcbiAgICAgIC8vIHRpbWUgd2lsbCBhcHBlYXIgYXMgaWYgd2UgYXJlIGluIGEgYnVmZmVyZWQgcmVnaW9uLCBldmVuIGlmIHdlIGFyZSBzdHVjayBpbiBhXG4gICAgICAvLyBcImdhcC5cIlxuICAgICAgLy9cbiAgICAgIC8vIEV4YW1wbGU6XG4gICAgICAvLyB2aWRlbyBidWZmZXI6ICAgMCA9PiAxMC4xLCAxMC4yID0+IDIwXG4gICAgICAvLyBhdWRpbyBidWZmZXI6ICAgMCA9PiAyMFxuICAgICAgLy8gb3ZlcmFsbCBidWZmZXI6IDAgPT4gMTAuMSwgMTAuMiA9PiAyMFxuICAgICAgLy8gY3VycmVudCB0aW1lOiAxM1xuICAgICAgLy9cbiAgICAgIC8vIENocm9tZSdzIHZpZGVvIGZyb3plIGF0IDEwIHNlY29uZHMsIHdoZXJlIHRoZSB2aWRlbyBidWZmZXIgZW5jb3VudGVyZWQgdGhlIGdhcCxcbiAgICAgIC8vIGhvd2V2ZXIsIHRoZSBhdWRpbyBjb250aW51ZWQgcGxheWluZyB1bnRpbCBpdCByZWFjaGVkIH4zIHNlY29uZHMgcGFzdCB0aGUgZ2FwXG4gICAgICAvLyAoMTMgc2Vjb25kcyksIGF0IHdoaWNoIHBvaW50IGl0IHN0b3BzIGFzIHdlbGwuIFNpbmNlIGN1cnJlbnQgdGltZSBpcyBwYXN0IHRoZVxuICAgICAgLy8gZ2FwLCBmaW5kTmV4dFJhbmdlIHdpbGwgcmV0dXJuIG5vIHJhbmdlcy5cbiAgICAgIC8vXG4gICAgICAvLyBUbyBjaGVjayBmb3IgdGhpcyBpc3N1ZSwgd2Ugc2VlIGlmIHRoZXJlIGlzIGEgZ2FwIHRoYXQgc3RhcnRzIHNvbWV3aGVyZSB3aXRoaW5cbiAgICAgIC8vIGEgMyBzZWNvbmQgcmFuZ2UgKDMgc2Vjb25kcyArLy0gMSBzZWNvbmQpIGJhY2sgZnJvbSBvdXIgY3VycmVudCB0aW1lLlxuICAgICAgdmFyIGdhcHMgPSBfcmFuZ2VzMlsnZGVmYXVsdCddLmZpbmRHYXBzKGJ1ZmZlcmVkKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGdhcHMuc3RhcnQoaSk7XG4gICAgICAgIHZhciBlbmQgPSBnYXBzLmVuZChpKTtcblxuICAgICAgICAvLyBnYXAgaXMgc3RhcnRzIG5vIG1vcmUgdGhhbiA0IHNlY29uZHMgYmFja1xuICAgICAgICBpZiAoY3VycmVudFRpbWUgLSBzdGFydCA8IDQgJiYgY3VycmVudFRpbWUgLSBzdGFydCA+IDIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZGVidWdnaW5nIGxvZ2dlciBub29wIHRoYXQgaXMgc2V0IHRvIGNvbnNvbGUubG9nIG9ubHkgaWYgZGVidWdnaW5nXG4gICAgICogaXMgZW5hYmxlZCBnbG9iYWxseVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2xvZ2dlcl8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2dnZXJfKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBQbGF5YmFja1dhdGNoZXI7XG59KSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBQbGF5YmFja1dhdGNoZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuL3Jhbmdlc1wiOjEyLFwiZ2xvYmFsL3dpbmRvd1wiOjMyfV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIEBmaWxlIHBsYXlsaXN0LWxvYWRlci5qc1xuICpcbiAqIEEgc3RhdGUgbWFjaGluZSB0aGF0IG1hbmFnZXMgdGhlIGxvYWRpbmcsIGNhY2hpbmcsIGFuZCB1cGRhdGluZyBvZlxuICogTTNVOCBwbGF5bGlzdHMuXG4gKlxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVzb2x2ZVVybCA9IHJlcXVpcmUoJy4vcmVzb2x2ZS11cmwnKTtcblxudmFyIF9yZXNvbHZlVXJsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Jlc29sdmVVcmwpO1xuXG52YXIgX3ZpZGVvSnMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sndmlkZW9qcyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndmlkZW9qcyddIDogbnVsbCk7XG5cbnZhciBfbTN1OFBhcnNlciA9IHJlcXVpcmUoJ20zdTgtcGFyc2VyJyk7XG5cbnZhciBfbTN1OFBhcnNlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tM3U4UGFyc2VyKTtcblxudmFyIF9nbG9iYWxXaW5kb3cgPSByZXF1aXJlKCdnbG9iYWwvd2luZG93Jyk7XG5cbnZhciBfZ2xvYmFsV2luZG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbFdpbmRvdyk7XG5cbi8qKlxuICAqIFJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc2VnbWVudHMgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIG1lcmdpbmdcbiAgKiBwcm9wZXJ0aWVzIGZyb20gYW4gb2xkZXIgbGlzdCBvZiBzZWdtZW50cyBvbnRvIGFuIHVwZGF0ZWRcbiAgKiBsaXN0LiBObyBwcm9wZXJ0aWVzIG9uIHRoZSB1cGRhdGVkIHBsYXlsaXN0IHdpbGwgYmUgb3ZlcnJpZGRlbi5cbiAgKlxuICAqIEBwYXJhbSB7QXJyYXl9IG9yaWdpbmFsIHRoZSBvdXRkYXRlZCBsaXN0IG9mIHNlZ21lbnRzXG4gICogQHBhcmFtIHtBcnJheX0gdXBkYXRlIHRoZSB1cGRhdGVkIGxpc3Qgb2Ygc2VnbWVudHNcbiAgKiBAcGFyYW0ge051bWJlcj19IG9mZnNldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHVwZGF0ZVxuICAqIHNlZ21lbnQgaW4gdGhlIG9yaWdpbmFsIHNlZ21lbnQgbGlzdC4gRm9yIG5vbi1saXZlIHBsYXlsaXN0cyxcbiAgKiB0aGlzIHNob3VsZCBhbHdheXMgYmUgemVybyBhbmQgZG9lcyBub3QgbmVlZCB0byBiZVxuICAqIHNwZWNpZmllZC4gRm9yIGxpdmUgcGxheWxpc3RzLCBpdCBzaG91bGQgYmUgdGhlIGRpZmZlcmVuY2VcbiAgKiBiZXR3ZWVuIHRoZSBtZWRpYSBzZXF1ZW5jZSBudW1iZXJzIGluIHRoZSBvcmlnaW5hbCBhbmQgdXBkYXRlZFxuICAqIHBsYXlsaXN0cy5cbiAgKiBAcmV0dXJuIGEgbGlzdCBvZiBtZXJnZWQgc2VnbWVudCBvYmplY3RzXG4gICovXG52YXIgdXBkYXRlU2VnbWVudHMgPSBmdW5jdGlvbiB1cGRhdGVTZWdtZW50cyhvcmlnaW5hbCwgdXBkYXRlLCBvZmZzZXQpIHtcbiAgdmFyIHJlc3VsdCA9IHVwZGF0ZS5zbGljZSgpO1xuXG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4ob3JpZ2luYWwubGVuZ3RoLCB1cGRhdGUubGVuZ3RoICsgb2Zmc2V0KTtcblxuICBmb3IgKHZhciBpID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbaSAtIG9mZnNldF0gPSAoMCwgX3ZpZGVvSnMubWVyZ2VPcHRpb25zKShvcmlnaW5hbFtpXSwgcmVzdWx0W2kgLSBvZmZzZXRdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0cy51cGRhdGVTZWdtZW50cyA9IHVwZGF0ZVNlZ21lbnRzO1xudmFyIHJlc29sdmVTZWdtZW50VXJpcyA9IGZ1bmN0aW9uIHJlc29sdmVTZWdtZW50VXJpcyhzZWdtZW50LCBiYXNlVXJpKSB7XG4gIGlmICghc2VnbWVudC5yZXNvbHZlZFVyaSkge1xuICAgIHNlZ21lbnQucmVzb2x2ZWRVcmkgPSAoMCwgX3Jlc29sdmVVcmwyWydkZWZhdWx0J10pKGJhc2VVcmksIHNlZ21lbnQudXJpKTtcbiAgfVxuICBpZiAoc2VnbWVudC5rZXkgJiYgIXNlZ21lbnQua2V5LnJlc29sdmVkVXJpKSB7XG4gICAgc2VnbWVudC5rZXkucmVzb2x2ZWRVcmkgPSAoMCwgX3Jlc29sdmVVcmwyWydkZWZhdWx0J10pKGJhc2VVcmksIHNlZ21lbnQua2V5LnVyaSk7XG4gIH1cbiAgaWYgKHNlZ21lbnQubWFwICYmICFzZWdtZW50Lm1hcC5yZXNvbHZlZFVyaSkge1xuICAgIHNlZ21lbnQubWFwLnJlc29sdmVkVXJpID0gKDAsIF9yZXNvbHZlVXJsMlsnZGVmYXVsdCddKShiYXNlVXJpLCBzZWdtZW50Lm1hcC51cmkpO1xuICB9XG59O1xuXG5leHBvcnRzLnJlc29sdmVTZWdtZW50VXJpcyA9IHJlc29sdmVTZWdtZW50VXJpcztcbi8qKlxuICAqIFJldHVybnMgYSBuZXcgbWFzdGVyIHBsYXlsaXN0IHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBtZXJnaW5nIGFuXG4gICogdXBkYXRlZCBtZWRpYSBwbGF5bGlzdCBpbnRvIHRoZSBvcmlnaW5hbCB2ZXJzaW9uLiBJZiB0aGVcbiAgKiB1cGRhdGVkIG1lZGlhIHBsYXlsaXN0IGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgcGxheWxpc3RcbiAgKiBlbnRyaWVzIGluIHRoZSBvcmlnaW5hbCBtYXN0ZXIgcGxheWxpc3QsIG51bGwgaXMgcmV0dXJuZWQuXG4gICpcbiAgKiBAcGFyYW0ge09iamVjdH0gbWFzdGVyIGEgcGFyc2VkIG1hc3RlciBNM1U4IG9iamVjdFxuICAqIEBwYXJhbSB7T2JqZWN0fSBtZWRpYSBhIHBhcnNlZCBtZWRpYSBNM1U4IG9iamVjdFxuICAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgb3JpZ2luYWxcbiAgKiBtYXN0ZXIgcGxheWxpc3Qgd2l0aCB0aGUgdXBkYXRlZCBtZWRpYSBwbGF5bGlzdCBtZXJnZWQgaW4sIG9yXG4gICogbnVsbCBpZiB0aGUgbWVyZ2UgcHJvZHVjZWQgbm8gY2hhbmdlLlxuICAqL1xudmFyIHVwZGF0ZU1hc3RlciA9IGZ1bmN0aW9uIHVwZGF0ZU1hc3RlcihtYXN0ZXIsIG1lZGlhKSB7XG4gIHZhciByZXN1bHQgPSAoMCwgX3ZpZGVvSnMubWVyZ2VPcHRpb25zKShtYXN0ZXIsIHt9KTtcbiAgdmFyIHBsYXlsaXN0ID0gcmVzdWx0LnBsYXlsaXN0cy5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcC51cmkgPT09IG1lZGlhLnVyaTtcbiAgfSlbMF07XG5cbiAgaWYgKCFwbGF5bGlzdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gY29uc2lkZXIgdGhlIHBsYXlsaXN0IHVuY2hhbmdlZCBpZiB0aGUgbnVtYmVyIG9mIHNlZ21lbnRzIGlzIGVxdWFsIGFuZCB0aGUgbWVkaWFcbiAgLy8gc2VxdWVuY2UgbnVtYmVyIGlzIHVuY2hhbmdlZFxuICBpZiAocGxheWxpc3Quc2VnbWVudHMgJiYgbWVkaWEuc2VnbWVudHMgJiYgcGxheWxpc3Quc2VnbWVudHMubGVuZ3RoID09PSBtZWRpYS5zZWdtZW50cy5sZW5ndGggJiYgcGxheWxpc3QubWVkaWFTZXF1ZW5jZSA9PT0gbWVkaWEubWVkaWFTZXF1ZW5jZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1lcmdlZFBsYXlsaXN0ID0gKDAsIF92aWRlb0pzLm1lcmdlT3B0aW9ucykocGxheWxpc3QsIG1lZGlhKTtcblxuICAvLyBpZiB0aGUgdXBkYXRlIGNvdWxkIG92ZXJsYXAgZXhpc3Rpbmcgc2VnbWVudCBpbmZvcm1hdGlvbiwgbWVyZ2UgdGhlIHR3byBzZWdtZW50IGxpc3RzXG4gIGlmIChwbGF5bGlzdC5zZWdtZW50cykge1xuICAgIG1lcmdlZFBsYXlsaXN0LnNlZ21lbnRzID0gdXBkYXRlU2VnbWVudHMocGxheWxpc3Quc2VnbWVudHMsIG1lZGlhLnNlZ21lbnRzLCBtZWRpYS5tZWRpYVNlcXVlbmNlIC0gcGxheWxpc3QubWVkaWFTZXF1ZW5jZSk7XG4gIH1cblxuICAvLyByZXNvbHZlIGFueSBzZWdtZW50IFVSSXMgdG8gcHJldmVudCB1cyBmcm9tIGhhdmluZyB0byBkbyBpdCBsYXRlclxuICBtZXJnZWRQbGF5bGlzdC5zZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgcmVzb2x2ZVNlZ21lbnRVcmlzKHNlZ21lbnQsIG1lcmdlZFBsYXlsaXN0LnJlc29sdmVkVXJpKTtcbiAgfSk7XG5cbiAgLy8gVE9ETyBSaWdodCBub3cgaW4gdGhlIHBsYXlsaXN0cyBhcnJheSB0aGVyZSBhcmUgdHdvIHJlZmVyZW5jZXMgdG8gZWFjaCBwbGF5bGlzdCwgb25lXG4gIC8vIHRoYXQgaXMgcmVmZXJlbmNlZCBieSBpbmRleCwgYW5kIG9uZSBieSBVUkkuIFRoZSBpbmRleCByZWZlcmVuY2UgbWF5IG5vIGxvbmdlciBiZVxuICAvLyBuZWNlc3NhcnkuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0LnBsYXlsaXN0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyZXN1bHQucGxheWxpc3RzW2ldLnVyaSA9PT0gbWVkaWEudXJpKSB7XG4gICAgICByZXN1bHQucGxheWxpc3RzW2ldID0gbWVyZ2VkUGxheWxpc3Q7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5wbGF5bGlzdHNbbWVkaWEudXJpXSA9IG1lcmdlZFBsYXlsaXN0O1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnRzLnVwZGF0ZU1hc3RlciA9IHVwZGF0ZU1hc3RlcjtcbnZhciBzZXR1cE1lZGlhUGxheWxpc3RzID0gZnVuY3Rpb24gc2V0dXBNZWRpYVBsYXlsaXN0cyhtYXN0ZXIpIHtcbiAgLy8gc2V0dXAgYnktVVJJIGxvb2t1cHMgYW5kIHJlc29sdmUgbWVkaWEgcGxheWxpc3QgVVJJc1xuICB2YXIgaSA9IG1hc3Rlci5wbGF5bGlzdHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgcGxheWxpc3QgPSBtYXN0ZXIucGxheWxpc3RzW2ldO1xuXG4gICAgbWFzdGVyLnBsYXlsaXN0c1twbGF5bGlzdC51cmldID0gcGxheWxpc3Q7XG4gICAgcGxheWxpc3QucmVzb2x2ZWRVcmkgPSAoMCwgX3Jlc29sdmVVcmwyWydkZWZhdWx0J10pKG1hc3Rlci51cmksIHBsYXlsaXN0LnVyaSk7XG5cbiAgICBpZiAoIXBsYXlsaXN0LmF0dHJpYnV0ZXMpIHtcbiAgICAgIC8vIEFsdGhvdWdoIHRoZSBzcGVjIHN0YXRlcyBhbiAjRVhULVgtU1RSRUFNLUlORiB0YWcgTVVTVCBoYXZlIGFcbiAgICAgIC8vIEJBTkRXSURUSCBhdHRyaWJ1dGUsIHdlIGNhbiBwbGF5IHRoZSBzdHJlYW0gd2l0aG91dCBpdC4gVGhpcyBtZWFucyBhIHBvb3JseVxuICAgICAgLy8gZm9ybWF0dGVkIG1hc3RlciBwbGF5bGlzdCBtYXkgbm90IGhhdmUgYW4gYXR0cmlidXRlIGxpc3QuIEFuIGF0dHJpYnV0ZXNcbiAgICAgIC8vIHByb3BlcnR5IGlzIGFkZGVkIGhlcmUgdG8gcHJldmVudCB1bmRlZmluZWQgcmVmZXJlbmNlcyB3aGVuIHdlIGVuY291bnRlclxuICAgICAgLy8gdGhpcyBzY2VuYXJpby5cbiAgICAgIHBsYXlsaXN0LmF0dHJpYnV0ZXMgPSB7fTtcblxuICAgICAgX3ZpZGVvSnMubG9nLndhcm4oJ0ludmFsaWQgcGxheWxpc3QgU1RSRUFNLUlORiBkZXRlY3RlZC4gTWlzc2luZyBCQU5EV0lEVEggYXR0cmlidXRlLicpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0cy5zZXR1cE1lZGlhUGxheWxpc3RzID0gc2V0dXBNZWRpYVBsYXlsaXN0cztcbnZhciByZXNvbHZlTWVkaWFHcm91cFVyaXMgPSBmdW5jdGlvbiByZXNvbHZlTWVkaWFHcm91cFVyaXMobWFzdGVyKSB7XG4gIFsnQVVESU8nLCAnU1VCVElUTEVTJ10uZm9yRWFjaChmdW5jdGlvbiAobWVkaWFUeXBlKSB7XG4gICAgZm9yICh2YXIgZ3JvdXBLZXkgaW4gbWFzdGVyLm1lZGlhR3JvdXBzW21lZGlhVHlwZV0pIHtcbiAgICAgIGZvciAodmFyIGxhYmVsS2V5IGluIG1hc3Rlci5tZWRpYUdyb3Vwc1ttZWRpYVR5cGVdW2dyb3VwS2V5XSkge1xuICAgICAgICB2YXIgbWVkaWFQcm9wZXJ0aWVzID0gbWFzdGVyLm1lZGlhR3JvdXBzW21lZGlhVHlwZV1bZ3JvdXBLZXldW2xhYmVsS2V5XTtcblxuICAgICAgICBpZiAobWVkaWFQcm9wZXJ0aWVzLnVyaSkge1xuICAgICAgICAgIG1lZGlhUHJvcGVydGllcy5yZXNvbHZlZFVyaSA9ICgwLCBfcmVzb2x2ZVVybDJbJ2RlZmF1bHQnXSkobWFzdGVyLnVyaSwgbWVkaWFQcm9wZXJ0aWVzLnVyaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuZXhwb3J0cy5yZXNvbHZlTWVkaWFHcm91cFVyaXMgPSByZXNvbHZlTWVkaWFHcm91cFVyaXM7XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHRpbWUgdG8gd2FpdCBiZWZvcmUgcmVmcmVzaGluZyBhIGxpdmUgcGxheWxpc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWVkaWFcbiAqICAgICAgICBUaGUgY3VycmVudCBtZWRpYVxuICogQHBhcmFtIHtCb29sZWFufSB1cGRhdGVcbiAqICAgICAgICBUcnVlIGlmIHRoZXJlIHdlcmUgYW55IHVwZGF0ZXMgZnJvbSB0aGUgbGFzdCByZWZyZXNoLCBmYWxzZSBvdGhlcndpc2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqICAgICAgICAgVGhlIHRpbWUgaW4gbXMgdG8gd2FpdCBiZWZvcmUgcmVmcmVzaGluZyB0aGUgbGl2ZSBwbGF5bGlzdFxuICovXG52YXIgcmVmcmVzaERlbGF5ID0gZnVuY3Rpb24gcmVmcmVzaERlbGF5KG1lZGlhLCB1cGRhdGUpIHtcbiAgdmFyIGxhc3RTZWdtZW50ID0gbWVkaWEuc2VnbWVudHNbbWVkaWEuc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gIHZhciBkZWxheSA9IHVuZGVmaW5lZDtcblxuICBpZiAodXBkYXRlICYmIGxhc3RTZWdtZW50ICYmIGxhc3RTZWdtZW50LmR1cmF0aW9uKSB7XG4gICAgZGVsYXkgPSBsYXN0U2VnbWVudC5kdXJhdGlvbiAqIDEwMDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgdGhlIHBsYXlsaXN0IGlzIHVuY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCByZWxvYWQgb3IgbGFzdCBzZWdtZW50IGR1cmF0aW9uXG4gICAgLy8gY2Fubm90IGJlIGRldGVybWluZWQsIHRyeSBhZ2FpbiBhZnRlciBoYWxmIHRoZSB0YXJnZXQgZHVyYXRpb25cbiAgICBkZWxheSA9IChtZWRpYS50YXJnZXREdXJhdGlvbiB8fCAxMCkgKiA1MDA7XG4gIH1cbiAgcmV0dXJuIGRlbGF5O1xufTtcblxuZXhwb3J0cy5yZWZyZXNoRGVsYXkgPSByZWZyZXNoRGVsYXk7XG4vKipcbiAqIExvYWQgYSBwbGF5bGlzdCBmcm9tIGEgcmVtb3RlIGxvY2F0aW9uXG4gKlxuICogQGNsYXNzIFBsYXlsaXN0TG9hZGVyXG4gKiBAZXh0ZW5kcyBTdHJlYW1cbiAqIEBwYXJhbSB7U3RyaW5nfSBzcmNVcmwgdGhlIHVybCB0byBzdGFydCB3aXRoXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhDcmVkZW50aWFscyB0aGUgd2l0aENyZWRlbnRpYWxzIHhociBvcHRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBQbGF5bGlzdExvYWRlciA9IChmdW5jdGlvbiAoX0V2ZW50VGFyZ2V0KSB7XG4gIF9pbmhlcml0cyhQbGF5bGlzdExvYWRlciwgX0V2ZW50VGFyZ2V0KTtcblxuICBmdW5jdGlvbiBQbGF5bGlzdExvYWRlcihzcmNVcmwsIGhscywgd2l0aENyZWRlbnRpYWxzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5bGlzdExvYWRlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihQbGF5bGlzdExvYWRlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5zcmNVcmwgPSBzcmNVcmw7XG4gICAgdGhpcy5obHNfID0gaGxzO1xuICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzO1xuXG4gICAgaWYgKCF0aGlzLnNyY1VybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIG5vbi1lbXB0eSBwbGF5bGlzdCBVUkwgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsaXplIHRoZSBsb2FkZXIgc3RhdGVcbiAgICB0aGlzLnN0YXRlID0gJ0hBVkVfTk9USElORyc7XG5cbiAgICAvLyBsaXZlIHBsYXlsaXN0IHN0YWxlbmVzcyB0aW1lb3V0XG4gICAgdGhpcy5vbignbWVkaWF1cGRhdGV0aW1lb3V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLnN0YXRlICE9PSAnSEFWRV9NRVRBREFUQScpIHtcbiAgICAgICAgLy8gb25seSByZWZyZXNoIHRoZSBtZWRpYSBwbGF5bGlzdCBpZiBubyBvdGhlciBhY3Rpdml0eSBpcyBnb2luZyBvblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnN0YXRlID0gJ0hBVkVfQ1VSUkVOVF9NRVRBREFUQSc7XG5cbiAgICAgIF90aGlzLnJlcXVlc3QgPSBfdGhpcy5obHNfLnhocih7XG4gICAgICAgIHVyaTogKDAsIF9yZXNvbHZlVXJsMlsnZGVmYXVsdCddKShfdGhpcy5tYXN0ZXIudXJpLCBfdGhpcy5tZWRpYSgpLnVyaSksXG4gICAgICAgIHdpdGhDcmVkZW50aWFsczogX3RoaXMud2l0aENyZWRlbnRpYWxzXG4gICAgICB9LCBmdW5jdGlvbiAoZXJyb3IsIHJlcSkge1xuICAgICAgICAvLyBkaXNwb3NlZFxuICAgICAgICBpZiAoIV90aGlzLnJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMucGxheWxpc3RSZXF1ZXN0RXJyb3IoX3RoaXMucmVxdWVzdCwgX3RoaXMubWVkaWEoKS51cmksICdIQVZFX01FVEFEQVRBJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5oYXZlTWV0YWRhdGEoX3RoaXMucmVxdWVzdCwgX3RoaXMubWVkaWEoKS51cmkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGxheWxpc3RMb2FkZXIsIFt7XG4gICAga2V5OiAncGxheWxpc3RSZXF1ZXN0RXJyb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5bGlzdFJlcXVlc3RFcnJvcih4aHIsIHVybCwgc3RhcnRpbmdTdGF0ZSkge1xuICAgICAgLy8gYW55IGluLWZsaWdodCByZXF1ZXN0IGlzIG5vdyBmaW5pc2hlZFxuICAgICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcblxuICAgICAgaWYgKHN0YXJ0aW5nU3RhdGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXJ0aW5nU3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXJyb3IgPSB7XG4gICAgICAgIHBsYXlsaXN0OiB0aGlzLm1hc3Rlci5wbGF5bGlzdHNbdXJsXSxcbiAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICBtZXNzYWdlOiAnSExTIHBsYXlsaXN0IHJlcXVlc3QgZXJyb3IgYXQgVVJMOiAnICsgdXJsLFxuICAgICAgICByZXNwb25zZVRleHQ6IHhoci5yZXNwb25zZVRleHQsXG4gICAgICAgIGNvZGU6IHhoci5zdGF0dXMgPj0gNTAwID8gNCA6IDJcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudHJpZ2dlcignZXJyb3InKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIHBsYXlsaXN0IGxvYWRlcidzIHN0YXRlIGluIHJlc3BvbnNlIHRvIGEgbmV3IG9yXG4gICAgLy8gdXBkYXRlZCBwbGF5bGlzdC5cbiAgfSwge1xuICAgIGtleTogJ2hhdmVNZXRhZGF0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhdmVNZXRhZGF0YSh4aHIsIHVybCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIGFueSBpbi1mbGlnaHQgcmVxdWVzdCBpcyBub3cgZmluaXNoZWRcbiAgICAgIHRoaXMucmVxdWVzdCA9IG51bGw7XG4gICAgICB0aGlzLnN0YXRlID0gJ0hBVkVfTUVUQURBVEEnO1xuXG4gICAgICB2YXIgcGFyc2VyID0gbmV3IF9tM3U4UGFyc2VyMlsnZGVmYXVsdCddLlBhcnNlcigpO1xuXG4gICAgICBwYXJzZXIucHVzaCh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIHBhcnNlci5lbmQoKTtcbiAgICAgIHBhcnNlci5tYW5pZmVzdC51cmkgPSB1cmw7XG4gICAgICAvLyBtM3U4LXBhcnNlciBkb2VzIG5vdCBhdHRhY2ggYW4gYXR0cmlidXRlcyBwcm9wZXJ0eSB0byBtZWRpYSBwbGF5bGlzdHMgc28gbWFrZVxuICAgICAgLy8gc3VyZSB0aGF0IHRoZSBwcm9wZXJ0eSBpcyBhdHRhY2hlZCB0byBhdm9pZCB1bmRlZmluZWQgcmVmZXJlbmNlIGVycm9yc1xuICAgICAgcGFyc2VyLm1hbmlmZXN0LmF0dHJpYnV0ZXMgPSBwYXJzZXIubWFuaWZlc3QuYXR0cmlidXRlcyB8fCB7fTtcblxuICAgICAgLy8gbWVyZ2UgdGhpcyBwbGF5bGlzdCBpbnRvIHRoZSBtYXN0ZXJcbiAgICAgIHZhciB1cGRhdGUgPSB1cGRhdGVNYXN0ZXIodGhpcy5tYXN0ZXIsIHBhcnNlci5tYW5pZmVzdCk7XG5cbiAgICAgIHRoaXMudGFyZ2V0RHVyYXRpb24gPSBwYXJzZXIubWFuaWZlc3QudGFyZ2V0RHVyYXRpb247XG5cbiAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5tYXN0ZXIgPSB1cGRhdGU7XG4gICAgICAgIHRoaXMubWVkaWFfID0gdGhpcy5tYXN0ZXIucGxheWxpc3RzW3BhcnNlci5tYW5pZmVzdC51cmldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdwbGF5bGlzdHVuY2hhbmdlZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyByZWZyZXNoIGxpdmUgcGxheWxpc3RzIGFmdGVyIGEgdGFyZ2V0IGR1cmF0aW9uIHBhc3Nlc1xuICAgICAgaWYgKCF0aGlzLm1lZGlhKCkuZW5kTGlzdCkge1xuICAgICAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLmNsZWFyVGltZW91dCh0aGlzLm1lZGlhVXBkYXRlVGltZW91dCk7XG4gICAgICAgIHRoaXMubWVkaWFVcGRhdGVUaW1lb3V0ID0gX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIudHJpZ2dlcignbWVkaWF1cGRhdGV0aW1lb3V0Jyk7XG4gICAgICAgIH0sIHJlZnJlc2hEZWxheSh0aGlzLm1lZGlhKCksICEhdXBkYXRlKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJpZ2dlcignbG9hZGVkcGxheWxpc3QnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBYm9ydCBhbnkgb3V0c3RhbmRpbmcgd29yayBhbmQgY2xlYW4gdXAuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdkaXNwb3NlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuc3RvcFJlcXVlc3QoKTtcbiAgICAgIF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uY2xlYXJUaW1lb3V0KHRoaXMubWVkaWFVcGRhdGVUaW1lb3V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdG9wUmVxdWVzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BSZXF1ZXN0KCkge1xuICAgICAgaWYgKHRoaXMucmVxdWVzdCkge1xuICAgICAgICB2YXIgb2xkUmVxdWVzdCA9IHRoaXMucmVxdWVzdDtcblxuICAgICAgICB0aGlzLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICBvbGRSZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIG9sZFJlcXVlc3QuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGNhbGxlZCB3aXRob3V0IGFueSBhcmd1bWVudHMsIHJldHVybnMgdGhlIGN1cnJlbnRseVxuICAgICAqIGFjdGl2ZSBtZWRpYSBwbGF5bGlzdC4gV2hlbiBjYWxsZWQgd2l0aCBhIHNpbmdsZSBhcmd1bWVudCxcbiAgICAgKiB0cmlnZ2VycyB0aGUgcGxheWxpc3QgbG9hZGVyIHRvIGFzeW5jaHJvbm91c2x5IHN3aXRjaCB0byB0aGVcbiAgICAgKiBzcGVjaWZpZWQgbWVkaWEgcGxheWxpc3QuIENhbGxpbmcgdGhpcyBtZXRob2Qgd2hpbGUgdGhlXG4gICAgICogbG9hZGVyIGlzIGluIHRoZSBIQVZFX05PVEhJTkcgY2F1c2VzIGFuIGVycm9yIHRvIGJlIGVtaXR0ZWRcbiAgICAgKiBidXQgb3RoZXJ3aXNlIGhhcyBubyBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IHBsYXlsaXN0IHRoZSBwYXJzZWQgbWVkaWEgcGxheWxpc3RcbiAgICAgKiBvYmplY3QgdG8gc3dpdGNoIHRvXG4gICAgICogQHJldHVybiB7UGxheWxpc3R9IHRoZSBjdXJyZW50IGxvYWRlZCBtZWRpYVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnbWVkaWEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZWRpYShwbGF5bGlzdCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIC8vIGdldHRlclxuICAgICAgaWYgKCFwbGF5bGlzdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYV87XG4gICAgICB9XG5cbiAgICAgIC8vIHNldHRlclxuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdIQVZFX05PVEhJTkcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3aXRjaCBtZWRpYSBwbGF5bGlzdCBmcm9tICcgKyB0aGlzLnN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0aW5nU3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgICAvLyBmaW5kIHRoZSBwbGF5bGlzdCBvYmplY3QgaWYgdGhlIHRhcmdldCBwbGF5bGlzdCBoYXMgYmVlblxuICAgICAgLy8gc3BlY2lmaWVkIGJ5IFVSSVxuICAgICAgaWYgKHR5cGVvZiBwbGF5bGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hc3Rlci5wbGF5bGlzdHNbcGxheWxpc3RdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHBsYXlsaXN0IFVSSTogJyArIHBsYXlsaXN0KTtcbiAgICAgICAgfVxuICAgICAgICBwbGF5bGlzdCA9IHRoaXMubWFzdGVyLnBsYXlsaXN0c1twbGF5bGlzdF07XG4gICAgICB9XG5cbiAgICAgIHZhciBtZWRpYUNoYW5nZSA9ICF0aGlzLm1lZGlhXyB8fCBwbGF5bGlzdC51cmkgIT09IHRoaXMubWVkaWFfLnVyaTtcblxuICAgICAgLy8gc3dpdGNoIHRvIGZ1bGx5IGxvYWRlZCBwbGF5bGlzdHMgaW1tZWRpYXRlbHlcbiAgICAgIGlmICh0aGlzLm1hc3Rlci5wbGF5bGlzdHNbcGxheWxpc3QudXJpXS5lbmRMaXN0KSB7XG4gICAgICAgIC8vIGFib3J0IG91dHN0YW5kaW5nIHBsYXlsaXN0IHJlcXVlc3RzXG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgICB0aGlzLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnSEFWRV9NRVRBREFUQSc7XG4gICAgICAgIHRoaXMubWVkaWFfID0gcGxheWxpc3Q7XG5cbiAgICAgICAgLy8gdHJpZ2dlciBtZWRpYSBjaGFuZ2UgaWYgdGhlIGFjdGl2ZSBtZWRpYSBoYXMgYmVlbiB1cGRhdGVkXG4gICAgICAgIGlmIChtZWRpYUNoYW5nZSkge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignbWVkaWFjaGFuZ2luZycpO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignbWVkaWFjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHN3aXRjaGluZyB0byB0aGUgYWN0aXZlIHBsYXlsaXN0IGlzIGEgbm8tb3BcbiAgICAgIGlmICghbWVkaWFDaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlID0gJ1NXSVRDSElOR19NRURJQSc7XG5cbiAgICAgIC8vIHRoZXJlIGlzIGFscmVhZHkgYW4gb3V0c3RhbmRpbmcgcGxheWxpc3QgcmVxdWVzdFxuICAgICAgaWYgKHRoaXMucmVxdWVzdCkge1xuICAgICAgICBpZiAoKDAsIF9yZXNvbHZlVXJsMlsnZGVmYXVsdCddKSh0aGlzLm1hc3Rlci51cmksIHBsYXlsaXN0LnVyaSkgPT09IHRoaXMucmVxdWVzdC51cmwpIHtcbiAgICAgICAgICAvLyByZXF1ZXN0aW5nIHRvIHN3aXRjaCB0byB0aGUgc2FtZSBwbGF5bGlzdCBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAgIC8vIGhhcyBubyBlZmZlY3QgYWZ0ZXIgdGhlIGZpcnN0XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gcmVxdWVzdCB0aGUgbmV3IHBsYXlsaXN0XG4gICAgICBpZiAodGhpcy5tZWRpYV8pIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdtZWRpYWNoYW5naW5nJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVxdWVzdCA9IHRoaXMuaGxzXy54aHIoe1xuICAgICAgICB1cmk6ICgwLCBfcmVzb2x2ZVVybDJbJ2RlZmF1bHQnXSkodGhpcy5tYXN0ZXIudXJpLCBwbGF5bGlzdC51cmkpLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHRoaXMud2l0aENyZWRlbnRpYWxzXG4gICAgICB9LCBmdW5jdGlvbiAoZXJyb3IsIHJlcSkge1xuICAgICAgICAvLyBkaXNwb3NlZFxuICAgICAgICBpZiAoIV90aGlzMy5yZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5wbGF5bGlzdFJlcXVlc3RFcnJvcihfdGhpczMucmVxdWVzdCwgcGxheWxpc3QudXJpLCBzdGFydGluZ1N0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMy5oYXZlTWV0YWRhdGEocmVxLCBwbGF5bGlzdC51cmkpO1xuXG4gICAgICAgIC8vIGZpcmUgbG9hZGVkbWV0YWRhdGEgdGhlIGZpcnN0IHRpbWUgYSBtZWRpYSBwbGF5bGlzdCBpcyBsb2FkZWRcbiAgICAgICAgaWYgKHN0YXJ0aW5nU3RhdGUgPT09ICdIQVZFX01BU1RFUicpIHtcbiAgICAgICAgICBfdGhpczMudHJpZ2dlcignbG9hZGVkbWV0YWRhdGEnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczMudHJpZ2dlcignbWVkaWFjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGF1c2UgbG9hZGluZyBvZiB0aGUgcGxheWxpc3RcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3BhdXNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICB0aGlzLnN0b3BSZXF1ZXN0KCk7XG4gICAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLmNsZWFyVGltZW91dCh0aGlzLm1lZGlhVXBkYXRlVGltZW91dCk7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0hBVkVfTk9USElORycpIHtcbiAgICAgICAgLy8gSWYgd2UgcGF1c2UgdGhlIGxvYWRlciBiZWZvcmUgYW55IGRhdGEgaGFzIGJlZW4gcmV0cmlldmVkLCBpdHMgYXMgaWYgd2UgbmV2ZXJcbiAgICAgICAgLy8gc3RhcnRlZCwgc28gcmVzZXQgdG8gYW4gdW5zdGFydGVkIHN0YXRlLlxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIE5lZWQgdG8gcmVzdG9yZSBzdGF0ZSBub3cgdGhhdCBubyBhY3Rpdml0eSBpcyBoYXBwZW5pbmdcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnU1dJVENISU5HX01FRElBJykge1xuICAgICAgICAvLyBpZiB0aGUgbG9hZGVyIHdhcyBpbiB0aGUgcHJvY2VzcyBvZiBzd2l0Y2hpbmcgbWVkaWEsIGl0IHNob3VsZCBlaXRoZXIgcmV0dXJuIHRvXG4gICAgICAgIC8vIEhBVkVfTUFTVEVSIG9yIEhBVkVfTUVUQURBVEEgZGVwZW5kaW5nIG9uIGlmIHRoZSBsb2FkZXIgaGFzIGxvYWRlZCBhIG1lZGlhXG4gICAgICAgIC8vIHBsYXlsaXN0IHlldC4gVGhpcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBleGlzdGVuY2Ugb2YgbG9hZGVyLm1lZGlhX1xuICAgICAgICBpZiAodGhpcy5tZWRpYV8pIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gJ0hBVkVfTUVUQURBVEEnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSAnSEFWRV9NQVNURVInO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdIQVZFX0NVUlJFTlRfTUVUQURBVEEnKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnSEFWRV9NRVRBREFUQSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc3RhcnQgbG9hZGluZyBvZiB0aGUgcGxheWxpc3RcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2xvYWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKGlzRmluYWxSZW5kaXRpb24pIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLmNsZWFyVGltZW91dCh0aGlzLm1lZGlhVXBkYXRlVGltZW91dCk7XG5cbiAgICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEoKTtcblxuICAgICAgaWYgKGlzRmluYWxSZW5kaXRpb24pIHtcbiAgICAgICAgdmFyIGRlbGF5ID0gbWVkaWEgPyBtZWRpYS50YXJnZXREdXJhdGlvbiAvIDIgKiAxMDAwIDogNSAqIDEwMDA7XG5cbiAgICAgICAgdGhpcy5tZWRpYVVwZGF0ZVRpbWVvdXQgPSBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczQubG9hZCgpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYSAmJiAhbWVkaWEuZW5kTGlzdCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ21lZGlhdXBkYXRldGltZW91dCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2FkZWRwbGF5bGlzdCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHN0YXJ0IGxvYWRpbmcgb2YgdGhlIHBsYXlsaXN0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzdGFydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIC8vIHJlcXVlc3QgdGhlIHNwZWNpZmllZCBVUkxcbiAgICAgIHRoaXMucmVxdWVzdCA9IHRoaXMuaGxzXy54aHIoe1xuICAgICAgICB1cmk6IHRoaXMuc3JjVXJsLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHRoaXMud2l0aENyZWRlbnRpYWxzXG4gICAgICB9LCBmdW5jdGlvbiAoZXJyb3IsIHJlcSkge1xuICAgICAgICAvLyBkaXNwb3NlZFxuICAgICAgICBpZiAoIV90aGlzNS5yZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGxvYWRlcidzIHJlcXVlc3QgcmVmZXJlbmNlXG4gICAgICAgIF90aGlzNS5yZXF1ZXN0ID0gbnVsbDtcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBfdGhpczUuZXJyb3IgPSB7XG4gICAgICAgICAgICBzdGF0dXM6IHJlcS5zdGF0dXMsXG4gICAgICAgICAgICBtZXNzYWdlOiAnSExTIHBsYXlsaXN0IHJlcXVlc3QgZXJyb3IgYXQgVVJMOiAnICsgX3RoaXM1LnNyY1VybCxcbiAgICAgICAgICAgIHJlc3BvbnNlVGV4dDogcmVxLnJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgIC8vIE1FRElBX0VSUl9ORVRXT1JLXG4gICAgICAgICAgICBjb2RlOiAyXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoX3RoaXM1LnN0YXRlID09PSAnSEFWRV9OT1RISU5HJykge1xuICAgICAgICAgICAgX3RoaXM1LnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF90aGlzNS50cmlnZ2VyKCdlcnJvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBfbTN1OFBhcnNlcjJbJ2RlZmF1bHQnXS5QYXJzZXIoKTtcblxuICAgICAgICBwYXJzZXIucHVzaChyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgcGFyc2VyLmVuZCgpO1xuXG4gICAgICAgIF90aGlzNS5zdGF0ZSA9ICdIQVZFX01BU1RFUic7XG5cbiAgICAgICAgcGFyc2VyLm1hbmlmZXN0LnVyaSA9IF90aGlzNS5zcmNVcmw7XG5cbiAgICAgICAgLy8gbG9hZGVkIGEgbWFzdGVyIHBsYXlsaXN0XG4gICAgICAgIGlmIChwYXJzZXIubWFuaWZlc3QucGxheWxpc3RzKSB7XG4gICAgICAgICAgX3RoaXM1Lm1hc3RlciA9IHBhcnNlci5tYW5pZmVzdDtcblxuICAgICAgICAgIHNldHVwTWVkaWFQbGF5bGlzdHMoX3RoaXM1Lm1hc3Rlcik7XG4gICAgICAgICAgcmVzb2x2ZU1lZGlhR3JvdXBVcmlzKF90aGlzNS5tYXN0ZXIpO1xuXG4gICAgICAgICAgX3RoaXM1LnRyaWdnZXIoJ2xvYWRlZHBsYXlsaXN0Jyk7XG4gICAgICAgICAgaWYgKCFfdGhpczUucmVxdWVzdCkge1xuICAgICAgICAgICAgLy8gbm8gbWVkaWEgcGxheWxpc3Qgd2FzIHNwZWNpZmljYWxseSBzZWxlY3RlZCBzbyBzdGFydFxuICAgICAgICAgICAgLy8gZnJvbSB0aGUgZmlyc3QgbGlzdGVkIG9uZVxuICAgICAgICAgICAgX3RoaXM1Lm1lZGlhKHBhcnNlci5tYW5pZmVzdC5wbGF5bGlzdHNbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsb2FkZWQgYSBtZWRpYSBwbGF5bGlzdFxuICAgICAgICAvLyBpbmZlciBhIG1hc3RlciBwbGF5bGlzdCBpZiBub25lIHdhcyBwcmV2aW91c2x5IHJlcXVlc3RlZFxuICAgICAgICBfdGhpczUubWFzdGVyID0ge1xuICAgICAgICAgIG1lZGlhR3JvdXBzOiB7XG4gICAgICAgICAgICAnQVVESU8nOiB7fSxcbiAgICAgICAgICAgICdWSURFTyc6IHt9LFxuICAgICAgICAgICAgJ0NMT1NFRC1DQVBUSU9OUyc6IHt9LFxuICAgICAgICAgICAgJ1NVQlRJVExFUyc6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cmk6IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10ubG9jYXRpb24uaHJlZixcbiAgICAgICAgICBwbGF5bGlzdHM6IFt7XG4gICAgICAgICAgICB1cmk6IF90aGlzNS5zcmNVcmxcbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgICBfdGhpczUubWFzdGVyLnBsYXlsaXN0c1tfdGhpczUuc3JjVXJsXSA9IF90aGlzNS5tYXN0ZXIucGxheWxpc3RzWzBdO1xuICAgICAgICBfdGhpczUubWFzdGVyLnBsYXlsaXN0c1swXS5yZXNvbHZlZFVyaSA9IF90aGlzNS5zcmNVcmw7XG4gICAgICAgIC8vIG0zdTgtcGFyc2VyIGRvZXMgbm90IGF0dGFjaCBhbiBhdHRyaWJ1dGVzIHByb3BlcnR5IHRvIG1lZGlhIHBsYXlsaXN0cyBzbyBtYWtlXG4gICAgICAgIC8vIHN1cmUgdGhhdCB0aGUgcHJvcGVydHkgaXMgYXR0YWNoZWQgdG8gYXZvaWQgdW5kZWZpbmVkIHJlZmVyZW5jZSBlcnJvcnNcbiAgICAgICAgX3RoaXM1Lm1hc3Rlci5wbGF5bGlzdHNbMF0uYXR0cmlidXRlcyA9IF90aGlzNS5tYXN0ZXIucGxheWxpc3RzWzBdLmF0dHJpYnV0ZXMgfHwge307XG4gICAgICAgIF90aGlzNS5oYXZlTWV0YWRhdGEocmVxLCBfdGhpczUuc3JjVXJsKTtcbiAgICAgICAgcmV0dXJuIF90aGlzNS50cmlnZ2VyKCdsb2FkZWRtZXRhZGF0YScpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBsYXlsaXN0TG9hZGVyO1xufSkoX3ZpZGVvSnMuRXZlbnRUYXJnZXQpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBQbGF5bGlzdExvYWRlcjtcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuL3Jlc29sdmUtdXJsXCI6MTUsXCJnbG9iYWwvd2luZG93XCI6MzIsXCJtM3U4LXBhcnNlclwiOjMzfV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbnZhciBfY29uZmlnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbmZpZyk7XG5cbnZhciBfcGxheWxpc3QgPSByZXF1aXJlKCcuL3BsYXlsaXN0Jyk7XG5cbnZhciBfcGxheWxpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxheWxpc3QpO1xuXG52YXIgX3V0aWxDb2RlY3NKcyA9IHJlcXVpcmUoJy4vdXRpbC9jb2RlY3MuanMnKTtcblxuLy8gVXRpbGl0aWVzXG5cbi8qKlxuICogUmV0dXJucyB0aGUgQ1NTIHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IG9uIGFuIGVsZW1lbnRcbiAqIHVzaW5nIGBnZXRDb21wdXRlZFN0eWxlYC4gRmlyZWZveCBoYXMgYSBsb25nLXN0YW5kaW5nIGlzc3VlIHdoZXJlXG4gKiBnZXRDb21wdXRlZFN0eWxlKCkgbWF5IHJldHVybiBudWxsIHdoZW4gcnVubmluZyBpbiBhbiBpZnJhbWUgd2l0aFxuICogYGRpc3BsYXk6IG5vbmVgLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0aGUgaHRtbGVsZW1lbnQgdG8gd29yayBvblxuICogQHBhcmFtIHtzdHJpbmd9IHRoZSBwcm9wcmV0eSB0byBnZXQgdGhlIHN0eWxlIGZvclxuICovXG52YXIgc2FmZUdldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbiBzYWZlR2V0Q29tcHV0ZWRTdHlsZShlbCwgcHJvcGVydHkpIHtcbiAgdmFyIHJlc3VsdCA9IHVuZGVmaW5lZDtcblxuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmVzdWx0ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBpZiAoIXJlc3VsdCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHRbcHJvcGVydHldO1xufTtcblxuLyoqXG4gKiBSZXN1YWJsZSBzdGFibGUgc29ydCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7UGxheWxpc3RzfSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydEZuIERpZmZlcmVudCBjb21wYXJhdG9yc1xuICogQGZ1bmN0aW9uIHN0YWJsZVNvcnRcbiAqL1xudmFyIHN0YWJsZVNvcnQgPSBmdW5jdGlvbiBzdGFibGVTb3J0KGFycmF5LCBzb3J0Rm4pIHtcbiAgdmFyIG5ld0FycmF5ID0gYXJyYXkuc2xpY2UoKTtcblxuICBhcnJheS5zb3J0KGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIHZhciBjbXAgPSBzb3J0Rm4obGVmdCwgcmlnaHQpO1xuXG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ld0FycmF5LmluZGV4T2YobGVmdCkgLSBuZXdBcnJheS5pbmRleE9mKHJpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNtcDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBzb3J0IHR3byBwbGF5bGlzdCBvYmplY3QgYnkgYmFuZHdpZHRoLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBsZWZ0IGEgbWVkaWEgcGxheWxpc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gcmlnaHQgYSBtZWRpYSBwbGF5bGlzdCBvYmplY3RcbiAqIEByZXR1cm4ge051bWJlcn0gR3JlYXRlciB0aGFuIHplcm8gaWYgdGhlIGJhbmR3aWR0aCBhdHRyaWJ1dGUgb2ZcbiAqIGxlZnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZSBvZiByaWdodC4gTGVzc1xuICogdGhhbiB6ZXJvIGlmIHRoZSBiYW5kd2lkdGggb2YgcmlnaHQgaXMgZ3JlYXRlciB0aGFuIGxlZnQgYW5kXG4gKiBleGFjdGx5IHplcm8gaWYgdGhlIHR3byBhcmUgZXF1YWwuXG4gKi9cbnZhciBjb21wYXJlUGxheWxpc3RCYW5kd2lkdGggPSBmdW5jdGlvbiBjb21wYXJlUGxheWxpc3RCYW5kd2lkdGgobGVmdCwgcmlnaHQpIHtcbiAgdmFyIGxlZnRCYW5kd2lkdGggPSB1bmRlZmluZWQ7XG4gIHZhciByaWdodEJhbmR3aWR0aCA9IHVuZGVmaW5lZDtcblxuICBpZiAobGVmdC5hdHRyaWJ1dGVzLkJBTkRXSURUSCkge1xuICAgIGxlZnRCYW5kd2lkdGggPSBsZWZ0LmF0dHJpYnV0ZXMuQkFORFdJRFRIO1xuICB9XG4gIGxlZnRCYW5kd2lkdGggPSBsZWZ0QmFuZHdpZHRoIHx8IHdpbmRvdy5OdW1iZXIuTUFYX1ZBTFVFO1xuICBpZiAocmlnaHQuYXR0cmlidXRlcy5CQU5EV0lEVEgpIHtcbiAgICByaWdodEJhbmR3aWR0aCA9IHJpZ2h0LmF0dHJpYnV0ZXMuQkFORFdJRFRIO1xuICB9XG4gIHJpZ2h0QmFuZHdpZHRoID0gcmlnaHRCYW5kd2lkdGggfHwgd2luZG93Lk51bWJlci5NQVhfVkFMVUU7XG5cbiAgcmV0dXJuIGxlZnRCYW5kd2lkdGggLSByaWdodEJhbmR3aWR0aDtcbn07XG5cbmV4cG9ydHMuY29tcGFyZVBsYXlsaXN0QmFuZHdpZHRoID0gY29tcGFyZVBsYXlsaXN0QmFuZHdpZHRoO1xuLyoqXG4gKiBBIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gc29ydCB0d28gcGxheWxpc3Qgb2JqZWN0IGJ5IHJlc29sdXRpb24gKHdpZHRoKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsZWZ0IGEgbWVkaWEgcGxheWxpc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gcmlnaHQgYSBtZWRpYSBwbGF5bGlzdCBvYmplY3RcbiAqIEByZXR1cm4ge051bWJlcn0gR3JlYXRlciB0aGFuIHplcm8gaWYgdGhlIHJlc29sdXRpb24ud2lkdGggYXR0cmlidXRlIG9mXG4gKiBsZWZ0IGlzIGdyZWF0ZXIgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGUgb2YgcmlnaHQuIExlc3NcbiAqIHRoYW4gemVybyBpZiB0aGUgcmVzb2x1dGlvbi53aWR0aCBvZiByaWdodCBpcyBncmVhdGVyIHRoYW4gbGVmdCBhbmRcbiAqIGV4YWN0bHkgemVybyBpZiB0aGUgdHdvIGFyZSBlcXVhbC5cbiAqL1xudmFyIGNvbXBhcmVQbGF5bGlzdFJlc29sdXRpb24gPSBmdW5jdGlvbiBjb21wYXJlUGxheWxpc3RSZXNvbHV0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gIHZhciBsZWZ0V2lkdGggPSB1bmRlZmluZWQ7XG4gIHZhciByaWdodFdpZHRoID0gdW5kZWZpbmVkO1xuXG4gIGlmIChsZWZ0LmF0dHJpYnV0ZXMuUkVTT0xVVElPTiAmJiBsZWZ0LmF0dHJpYnV0ZXMuUkVTT0xVVElPTi53aWR0aCkge1xuICAgIGxlZnRXaWR0aCA9IGxlZnQuYXR0cmlidXRlcy5SRVNPTFVUSU9OLndpZHRoO1xuICB9XG5cbiAgbGVmdFdpZHRoID0gbGVmdFdpZHRoIHx8IHdpbmRvdy5OdW1iZXIuTUFYX1ZBTFVFO1xuXG4gIGlmIChyaWdodC5hdHRyaWJ1dGVzLlJFU09MVVRJT04gJiYgcmlnaHQuYXR0cmlidXRlcy5SRVNPTFVUSU9OLndpZHRoKSB7XG4gICAgcmlnaHRXaWR0aCA9IHJpZ2h0LmF0dHJpYnV0ZXMuUkVTT0xVVElPTi53aWR0aDtcbiAgfVxuXG4gIHJpZ2h0V2lkdGggPSByaWdodFdpZHRoIHx8IHdpbmRvdy5OdW1iZXIuTUFYX1ZBTFVFO1xuXG4gIC8vIE5PVEUgLSBGYWxsYmFjayB0byBiYW5kd2lkdGggc29ydCBhcyBhcHByb3ByaWF0ZSBpbiBjYXNlcyB3aGVyZSBtdWx0aXBsZSByZW5kaXRpb25zXG4gIC8vIGhhdmUgdGhlIHNhbWUgbWVkaWEgZGltZW5zaW9ucy8gcmVzb2x1dGlvblxuICBpZiAobGVmdFdpZHRoID09PSByaWdodFdpZHRoICYmIGxlZnQuYXR0cmlidXRlcy5CQU5EV0lEVEggJiYgcmlnaHQuYXR0cmlidXRlcy5CQU5EV0lEVEgpIHtcbiAgICByZXR1cm4gbGVmdC5hdHRyaWJ1dGVzLkJBTkRXSURUSCAtIHJpZ2h0LmF0dHJpYnV0ZXMuQkFORFdJRFRIO1xuICB9XG4gIHJldHVybiBsZWZ0V2lkdGggLSByaWdodFdpZHRoO1xufTtcblxuZXhwb3J0cy5jb21wYXJlUGxheWxpc3RSZXNvbHV0aW9uID0gY29tcGFyZVBsYXlsaXN0UmVzb2x1dGlvbjtcbi8qKlxuICogQ2hvb3NlcyB0aGUgYXBwcm9wcmlhdGUgbWVkaWEgcGxheWxpc3QgYmFzZWQgb24gYmFuZHdpZHRoIGFuZCBwbGF5ZXIgc2l6ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXN0ZXJcbiAqICAgICAgICBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hc3RlciBtYW5pZmVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IHBsYXllckJhbmR3aWR0aFxuICogICAgICAgIEN1cnJlbnQgY2FsY3VsYXRlZCBiYW5kd2lkdGggb2YgdGhlIHBsYXllclxuICogQHBhcmFtIHtOdW1iZXJ9IHBsYXllcldpZHRoXG4gKiAgICAgICAgQ3VycmVudCB3aWR0aCBvZiB0aGUgcGxheWVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBwbGF5ZXJIZWlnaHRcbiAqICAgICAgICBDdXJyZW50IGhlaWdodCBvZiB0aGUgcGxheWVyIGVsZW1lbnRcbiAqIEByZXR1cm4ge1BsYXlsaXN0fSB0aGUgaGlnaGVzdCBiaXRyYXRlIHBsYXlsaXN0IGxlc3MgdGhhbiB0aGVcbiAqIGN1cnJlbnRseSBkZXRlY3RlZCBiYW5kd2lkdGgsIGFjY291bnRpbmcgZm9yIHNvbWUgYW1vdW50IG9mXG4gKiBiYW5kd2lkdGggdmFyaWFuY2VcbiAqL1xudmFyIHNpbXBsZVNlbGVjdG9yID0gZnVuY3Rpb24gc2ltcGxlU2VsZWN0b3IobWFzdGVyLCBwbGF5ZXJCYW5kd2lkdGgsIHBsYXllcldpZHRoLCBwbGF5ZXJIZWlnaHQpIHtcbiAgLy8gY29udmVydCB0aGUgcGxheWxpc3RzIHRvIGFuIGludGVybWVkaWFyeSByZXByZXNlbnRhdGlvbiB0byBtYWtlIGNvbXBhcmlzb25zIGVhc2llclxuICB2YXIgc29ydGVkUGxheWxpc3RSZXBzID0gbWFzdGVyLnBsYXlsaXN0cy5tYXAoZnVuY3Rpb24gKHBsYXlsaXN0KSB7XG4gICAgdmFyIHdpZHRoID0gdW5kZWZpbmVkO1xuICAgIHZhciBoZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGJhbmR3aWR0aCA9IHVuZGVmaW5lZDtcblxuICAgIHdpZHRoID0gcGxheWxpc3QuYXR0cmlidXRlcy5SRVNPTFVUSU9OICYmIHBsYXlsaXN0LmF0dHJpYnV0ZXMuUkVTT0xVVElPTi53aWR0aDtcbiAgICBoZWlnaHQgPSBwbGF5bGlzdC5hdHRyaWJ1dGVzLlJFU09MVVRJT04gJiYgcGxheWxpc3QuYXR0cmlidXRlcy5SRVNPTFVUSU9OLmhlaWdodDtcbiAgICBiYW5kd2lkdGggPSBwbGF5bGlzdC5hdHRyaWJ1dGVzLkJBTkRXSURUSDtcblxuICAgIGJhbmR3aWR0aCA9IGJhbmR3aWR0aCB8fCB3aW5kb3cuTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIHJldHVybiB7XG4gICAgICBiYW5kd2lkdGg6IGJhbmR3aWR0aCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgcGxheWxpc3Q6IHBsYXlsaXN0XG4gICAgfTtcbiAgfSk7XG5cbiAgc3RhYmxlU29ydChzb3J0ZWRQbGF5bGlzdFJlcHMsIGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0LmJhbmR3aWR0aCAtIHJpZ2h0LmJhbmR3aWR0aDtcbiAgfSk7XG5cbiAgLy8gZmlsdGVyIG91dCBhbnkgcGxheWxpc3RzIHRoYXQgaGF2ZSBiZWVuIGV4Y2x1ZGVkIGR1ZSB0b1xuICAvLyBpbmNvbXBhdGlibGUgY29uZmlndXJhdGlvbnNcbiAgc29ydGVkUGxheWxpc3RSZXBzID0gc29ydGVkUGxheWxpc3RSZXBzLmZpbHRlcihmdW5jdGlvbiAocmVwKSB7XG4gICAgcmV0dXJuICFfcGxheWxpc3QyWydkZWZhdWx0J10uaXNJbmNvbXBhdGlibGUocmVwLnBsYXlsaXN0KTtcbiAgfSk7XG5cbiAgLy8gZmlsdGVyIG91dCBhbnkgcGxheWxpc3RzIHRoYXQgaGF2ZSBiZWVuIGRpc2FibGVkIG1hbnVhbGx5IHRocm91Z2ggdGhlIHJlcHJlc2VudGF0aW9uc1xuICAvLyBhcGkgb3IgYmxhY2tsaXN0ZWQgdGVtcG9yYXJpbHkgZHVlIHRvIHBsYXliYWNrIGVycm9ycy5cbiAgdmFyIGVuYWJsZWRQbGF5bGlzdFJlcHMgPSBzb3J0ZWRQbGF5bGlzdFJlcHMuZmlsdGVyKGZ1bmN0aW9uIChyZXApIHtcbiAgICByZXR1cm4gX3BsYXlsaXN0MlsnZGVmYXVsdCddLmlzRW5hYmxlZChyZXAucGxheWxpc3QpO1xuICB9KTtcblxuICBpZiAoIWVuYWJsZWRQbGF5bGlzdFJlcHMubGVuZ3RoKSB7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIGVuYWJsZWQgcGxheWxpc3RzLCB0aGVuIHRoZXkgaGF2ZSBhbGwgYmVlbiBibGFja2xpc3RlZCBvciBkaXNhYmxlZFxuICAgIC8vIGJ5IHRoZSB1c2VyIHRocm91Z2ggdGhlIHJlcHJlc2VudGF0aW9ucyBhcGkuIEluIHRoaXMgY2FzZSwgaWdub3JlIGJsYWNrbGlzdGluZyBhbmRcbiAgICAvLyBmYWxsYmFjayB0byB3aGF0IHRoZSB1c2VyIHdhbnRzIGJ5IHVzaW5nIHBsYXlsaXN0cyB0aGUgdXNlciBoYXMgbm90IGRpc2FibGVkLlxuICAgIGVuYWJsZWRQbGF5bGlzdFJlcHMgPSBzb3J0ZWRQbGF5bGlzdFJlcHMuZmlsdGVyKGZ1bmN0aW9uIChyZXApIHtcbiAgICAgIHJldHVybiAhX3BsYXlsaXN0MlsnZGVmYXVsdCddLmlzRGlzYWJsZWQocmVwLnBsYXlsaXN0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGZpbHRlciBvdXQgYW55IHZhcmlhbnQgdGhhdCBoYXMgZ3JlYXRlciBlZmZlY3RpdmUgYml0cmF0ZVxuICAvLyB0aGFuIHRoZSBjdXJyZW50IGVzdGltYXRlZCBiYW5kd2lkdGhcbiAgdmFyIGJhbmR3aWR0aFBsYXlsaXN0UmVwcyA9IGVuYWJsZWRQbGF5bGlzdFJlcHMuZmlsdGVyKGZ1bmN0aW9uIChyZXApIHtcbiAgICByZXR1cm4gcmVwLmJhbmR3aWR0aCAqIF9jb25maWcyWydkZWZhdWx0J10uQkFORFdJRFRIX1ZBUklBTkNFIDwgcGxheWVyQmFuZHdpZHRoO1xuICB9KTtcblxuICB2YXIgaGlnaGVzdFJlbWFpbmluZ0JhbmR3aWR0aFJlcCA9IGJhbmR3aWR0aFBsYXlsaXN0UmVwc1tiYW5kd2lkdGhQbGF5bGlzdFJlcHMubGVuZ3RoIC0gMV07XG5cbiAgLy8gZ2V0IGFsbCBvZiB0aGUgcmVuZGl0aW9ucyB3aXRoIHRoZSBzYW1lIChoaWdoZXN0KSBiYW5kd2lkdGhcbiAgLy8gYW5kIHRoZW4gdGFraW5nIHRoZSB2ZXJ5IGZpcnN0IGVsZW1lbnRcbiAgdmFyIGJhbmR3aWR0aEJlc3RSZXAgPSBiYW5kd2lkdGhQbGF5bGlzdFJlcHMuZmlsdGVyKGZ1bmN0aW9uIChyZXApIHtcbiAgICByZXR1cm4gcmVwLmJhbmR3aWR0aCA9PT0gaGlnaGVzdFJlbWFpbmluZ0JhbmR3aWR0aFJlcC5iYW5kd2lkdGg7XG4gIH0pWzBdO1xuXG4gIC8vIGZpbHRlciBvdXQgcGxheWxpc3RzIHdpdGhvdXQgcmVzb2x1dGlvbiBpbmZvcm1hdGlvblxuICB2YXIgaGF2ZVJlc29sdXRpb24gPSBiYW5kd2lkdGhQbGF5bGlzdFJlcHMuZmlsdGVyKGZ1bmN0aW9uIChyZXApIHtcbiAgICByZXR1cm4gcmVwLndpZHRoICYmIHJlcC5oZWlnaHQ7XG4gIH0pO1xuXG4gIC8vIHNvcnQgdmFyaWFudHMgYnkgcmVzb2x1dGlvblxuICBzdGFibGVTb3J0KGhhdmVSZXNvbHV0aW9uLCBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdC53aWR0aCAtIHJpZ2h0LndpZHRoO1xuICB9KTtcblxuICAvLyBpZiB3ZSBoYXZlIHRoZSBleGFjdCByZXNvbHV0aW9uIGFzIHRoZSBwbGF5ZXIgdXNlIGl0XG4gIHZhciByZXNvbHV0aW9uQmVzdFJlcExpc3QgPSBoYXZlUmVzb2x1dGlvbi5maWx0ZXIoZnVuY3Rpb24gKHJlcCkge1xuICAgIHJldHVybiByZXAud2lkdGggPT09IHBsYXllcldpZHRoICYmIHJlcC5oZWlnaHQgPT09IHBsYXllckhlaWdodDtcbiAgfSk7XG5cbiAgaGlnaGVzdFJlbWFpbmluZ0JhbmR3aWR0aFJlcCA9IHJlc29sdXRpb25CZXN0UmVwTGlzdFtyZXNvbHV0aW9uQmVzdFJlcExpc3QubGVuZ3RoIC0gMV07XG4gIC8vIGVuc3VyZSB0aGF0IHdlIHBpY2sgdGhlIGhpZ2hlc3QgYmFuZHdpZHRoIHZhcmlhbnQgdGhhdCBoYXZlIGV4YWN0IHJlc29sdXRpb25cbiAgdmFyIHJlc29sdXRpb25CZXN0UmVwID0gcmVzb2x1dGlvbkJlc3RSZXBMaXN0LmZpbHRlcihmdW5jdGlvbiAocmVwKSB7XG4gICAgcmV0dXJuIHJlcC5iYW5kd2lkdGggPT09IGhpZ2hlc3RSZW1haW5pbmdCYW5kd2lkdGhSZXAuYmFuZHdpZHRoO1xuICB9KVswXTtcblxuICB2YXIgcmVzb2x1dGlvblBsdXNPbmVMaXN0ID0gdW5kZWZpbmVkO1xuICB2YXIgcmVzb2x1dGlvblBsdXNPbmVTbWFsbGVzdCA9IHVuZGVmaW5lZDtcbiAgdmFyIHJlc29sdXRpb25QbHVzT25lUmVwID0gdW5kZWZpbmVkO1xuXG4gIC8vIGZpbmQgdGhlIHNtYWxsZXN0IHZhcmlhbnQgdGhhdCBpcyBsYXJnZXIgdGhhbiB0aGUgcGxheWVyXG4gIC8vIGlmIHRoZXJlIGlzIG5vIG1hdGNoIG9mIGV4YWN0IHJlc29sdXRpb25cbiAgaWYgKCFyZXNvbHV0aW9uQmVzdFJlcCkge1xuICAgIHJlc29sdXRpb25QbHVzT25lTGlzdCA9IGhhdmVSZXNvbHV0aW9uLmZpbHRlcihmdW5jdGlvbiAocmVwKSB7XG4gICAgICByZXR1cm4gcmVwLndpZHRoID4gcGxheWVyV2lkdGggfHwgcmVwLmhlaWdodCA+IHBsYXllckhlaWdodDtcbiAgICB9KTtcblxuICAgIC8vIGZpbmQgYWxsIHRoZSB2YXJpYW50cyBoYXZlIHRoZSBzYW1lIHNtYWxsZXN0IHJlc29sdXRpb25cbiAgICByZXNvbHV0aW9uUGx1c09uZVNtYWxsZXN0ID0gcmVzb2x1dGlvblBsdXNPbmVMaXN0LmZpbHRlcihmdW5jdGlvbiAocmVwKSB7XG4gICAgICByZXR1cm4gcmVwLndpZHRoID09PSByZXNvbHV0aW9uUGx1c09uZUxpc3RbMF0ud2lkdGggJiYgcmVwLmhlaWdodCA9PT0gcmVzb2x1dGlvblBsdXNPbmVMaXN0WzBdLmhlaWdodDtcbiAgICB9KTtcblxuICAgIC8vIGVuc3VyZSB0aGF0IHdlIGFsc28gcGljayB0aGUgaGlnaGVzdCBiYW5kd2lkdGggdmFyaWFudCB0aGF0XG4gICAgLy8gaXMganVzdC1sYXJnZXItdGhhbiB0aGUgdmlkZW8gcGxheWVyXG4gICAgaGlnaGVzdFJlbWFpbmluZ0JhbmR3aWR0aFJlcCA9IHJlc29sdXRpb25QbHVzT25lU21hbGxlc3RbcmVzb2x1dGlvblBsdXNPbmVTbWFsbGVzdC5sZW5ndGggLSAxXTtcbiAgICByZXNvbHV0aW9uUGx1c09uZVJlcCA9IHJlc29sdXRpb25QbHVzT25lU21hbGxlc3QuZmlsdGVyKGZ1bmN0aW9uIChyZXApIHtcbiAgICAgIHJldHVybiByZXAuYmFuZHdpZHRoID09PSBoaWdoZXN0UmVtYWluaW5nQmFuZHdpZHRoUmVwLmJhbmR3aWR0aDtcbiAgICB9KVswXTtcbiAgfVxuXG4gIC8vIGZhbGxiYWNrIGNoYWluIG9mIHZhcmlhbnRzXG4gIHZhciBjaG9zZW5SZXAgPSByZXNvbHV0aW9uUGx1c09uZVJlcCB8fCByZXNvbHV0aW9uQmVzdFJlcCB8fCBiYW5kd2lkdGhCZXN0UmVwIHx8IGVuYWJsZWRQbGF5bGlzdFJlcHNbMF0gfHwgc29ydGVkUGxheWxpc3RSZXBzWzBdO1xuXG4gIHJldHVybiBjaG9zZW5SZXAgPyBjaG9zZW5SZXAucGxheWxpc3QgOiBudWxsO1xufTtcblxuZXhwb3J0cy5zaW1wbGVTZWxlY3RvciA9IHNpbXBsZVNlbGVjdG9yO1xuLy8gUGxheWxpc3QgU2VsZWN0b3JzXG5cbi8qKlxuICogQ2hvb3NlcyB0aGUgYXBwcm9wcmlhdGUgbWVkaWEgcGxheWxpc3QgYmFzZWQgb24gdGhlIG1vc3QgcmVjZW50XG4gKiBiYW5kd2lkdGggZXN0aW1hdGUgYW5kIHRoZSBwbGF5ZXIgc2l6ZS5cbiAqXG4gKiBFeHBlY3RzIHRvIGJlIGNhbGxlZCB3aXRoaW4gdGhlIGNvbnRleHQgb2YgYW4gaW5zdGFuY2Ugb2YgSGxzSGFuZGxlclxuICpcbiAqIEByZXR1cm4ge1BsYXlsaXN0fSB0aGUgaGlnaGVzdCBiaXRyYXRlIHBsYXlsaXN0IGxlc3MgdGhhbiB0aGVcbiAqIGN1cnJlbnRseSBkZXRlY3RlZCBiYW5kd2lkdGgsIGFjY291bnRpbmcgZm9yIHNvbWUgYW1vdW50IG9mXG4gKiBiYW5kd2lkdGggdmFyaWFuY2VcbiAqL1xudmFyIGxhc3RCYW5kd2lkdGhTZWxlY3RvciA9IGZ1bmN0aW9uIGxhc3RCYW5kd2lkdGhTZWxlY3RvcigpIHtcbiAgcmV0dXJuIHNpbXBsZVNlbGVjdG9yKHRoaXMucGxheWxpc3RzLm1hc3RlciwgdGhpcy5zeXN0ZW1CYW5kd2lkdGgsIHBhcnNlSW50KHNhZmVHZXRDb21wdXRlZFN0eWxlKHRoaXMudGVjaF8uZWwoKSwgJ3dpZHRoJyksIDEwKSwgcGFyc2VJbnQoc2FmZUdldENvbXB1dGVkU3R5bGUodGhpcy50ZWNoXy5lbCgpLCAnaGVpZ2h0JyksIDEwKSk7XG59O1xuXG5leHBvcnRzLmxhc3RCYW5kd2lkdGhTZWxlY3RvciA9IGxhc3RCYW5kd2lkdGhTZWxlY3Rvcjtcbi8qKlxuICogQ2hvb3NlcyB0aGUgYXBwcm9wcmlhdGUgbWVkaWEgcGxheWxpc3QgYmFzZWQgb24gYW5cbiAqIGV4cG9uZW50aWFsLXdlaWdodGVkIG1vdmluZyBhdmVyYWdlIG9mIHRoZSBiYW5kd2lkdGggYWZ0ZXJcbiAqIGZpbHRlcmluZyBmb3IgcGxheWVyIHNpemUuXG4gKlxuICogRXhwZWN0cyB0byBiZSBjYWxsZWQgd2l0aGluIHRoZSBjb250ZXh0IG9mIGFuIGluc3RhbmNlIG9mIEhsc0hhbmRsZXJcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVjYXkgLSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuIEhpZ2hlciB2YWx1ZXMgb2ZcbiAqIHRoaXMgcGFyYW1ldGVyIHdpbGwgY2F1c2UgcHJldmlvdXMgYmFuZHdpZHRoIGVzdGltYXRlcyB0byBsb3NlXG4gKiBzaWduaWZpY2FuY2UgbW9yZSBxdWlja2x5LlxuICogQHJldHVybiB7RnVuY3Rpb259IGEgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIGludm9rZWQgdG8gY3JlYXRlIGEgbmV3XG4gKiBwbGF5bGlzdCBzZWxlY3RvciBmdW5jdGlvbi5cbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW92aW5nX2F2ZXJhZ2UjRXhwb25lbnRpYWxfbW92aW5nX2F2ZXJhZ2VcbiAqL1xudmFyIG1vdmluZ0F2ZXJhZ2VCYW5kd2lkdGhTZWxlY3RvciA9IGZ1bmN0aW9uIG1vdmluZ0F2ZXJhZ2VCYW5kd2lkdGhTZWxlY3RvcihkZWNheSkge1xuICB2YXIgYXZlcmFnZSA9IC0xO1xuXG4gIGlmIChkZWNheSA8IDAgfHwgZGVjYXkgPiAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNb3ZpbmcgYXZlcmFnZSBiYW5kd2lkdGggZGVjYXkgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuJyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhdmVyYWdlIDwgMCkge1xuICAgICAgYXZlcmFnZSA9IHRoaXMuc3lzdGVtQmFuZHdpZHRoO1xuICAgIH1cblxuICAgIGF2ZXJhZ2UgPSBkZWNheSAqIHRoaXMuc3lzdGVtQmFuZHdpZHRoICsgKDEgLSBkZWNheSkgKiBhdmVyYWdlO1xuICAgIHJldHVybiBzaW1wbGVTZWxlY3Rvcih0aGlzLnBsYXlsaXN0cy5tYXN0ZXIsIGF2ZXJhZ2UsIHBhcnNlSW50KHNhZmVHZXRDb21wdXRlZFN0eWxlKHRoaXMudGVjaF8uZWwoKSwgJ3dpZHRoJyksIDEwKSwgcGFyc2VJbnQoc2FmZUdldENvbXB1dGVkU3R5bGUodGhpcy50ZWNoXy5lbCgpLCAnaGVpZ2h0JyksIDEwKSk7XG4gIH07XG59O1xuXG5leHBvcnRzLm1vdmluZ0F2ZXJhZ2VCYW5kd2lkdGhTZWxlY3RvciA9IG1vdmluZ0F2ZXJhZ2VCYW5kd2lkdGhTZWxlY3Rvcjtcbi8qKlxuICogQ2hvb3NlcyB0aGUgYXBwcm9wcmlhdGUgbWVkaWEgcGxheWxpc3QgYmFzZWQgb24gdGhlIHBvdGVudGlhbCB0byByZWJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xuICogICAgICAgIE9iamVjdCBvZiBpbmZvcm1hdGlvbiByZXF1aXJlZCB0byB1c2UgdGhpcyBzZWxlY3RvclxuICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLm1hc3RlclxuICogICAgICAgIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWFzdGVyIG1hbmlmZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gc2V0dGluZ3MuY3VycmVudFRpbWVcbiAqICAgICAgICBUaGUgY3VycmVudCB0aW1lIG9mIHRoZSBwbGF5ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzZXR0aW5ncy5iYW5kd2lkdGhcbiAqICAgICAgICBDdXJyZW50IG1lYXN1cmVkIGJhbmR3aWR0aFxuICogQHBhcmFtIHtOdW1iZXJ9IHNldHRpbmdzLmR1cmF0aW9uXG4gKiAgICAgICAgRHVyYXRpb24gb2YgdGhlIG1lZGlhXG4gKiBAcGFyYW0ge051bWJlcn0gc2V0dGluZ3Muc2VnbWVudER1cmF0aW9uXG4gKiAgICAgICAgU2VnbWVudCBkdXJhdGlvbiB0byBiZSB1c2VkIGluIHJvdW5kIHRyaXAgdGltZSBjYWxjdWxhdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBzZXR0aW5ncy50aW1lVW50aWxSZWJ1ZmZlclxuICogICAgICAgIFRpbWUgbGVmdCBpbiBzZWNvbmRzIHVudGlsIHRoZSBwbGF5ZXIgaGFzIHRvIHJlYnVmZmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc2V0dGluZ3MuY3VycmVudFRpbWVsaW5lXG4gKiAgICAgICAgVGhlIGN1cnJlbnQgdGltZWxpbmUgc2VnbWVudHMgYXJlIGJlaW5nIGxvYWRlZCBmcm9tXG4gKiBAcGFyYW0ge1N5bmNDb250cm9sbGVyfSBzZXR0aW5ncy5zeW5jQ29udHJvbGxlclxuICogICAgICAgIFN5bmNDb250cm9sbGVyIGZvciBkZXRlcm1pbmluZyBpZiB3ZSBoYXZlIGEgc3luYyBwb2ludCBmb3IgYSBnaXZlbiBwbGF5bGlzdFxuICogQHJldHVybiB7T2JqZWN0fG51bGx9XG4gKiAgICAgICAgIHtPYmplY3R9IHJldHVybi5wbGF5bGlzdFxuICogICAgICAgICBUaGUgaGlnaGVzdCBiYW5kd2lkdGggcGxheWxpc3Qgd2l0aCB0aGUgbGVhc3QgYW1vdW50IG9mIHJlYnVmZmVyaW5nXG4gKiAgICAgICAgIHtOdW1iZXJ9IHJldHVybi5yZWJ1ZmZlcmluZ0ltcGFjdFxuICogICAgICAgICBUaGUgYW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kcyBzd2l0Y2hpbmcgdG8gdGhpcyBwbGF5bGlzdCB3aWxsIHJlYnVmZmVyLiBBXG4gKiAgICAgICAgIG5lZ2F0aXZlIHZhbHVlIG1lYW5zIHRoYXQgc3dpdGNoaW5nIHdpbGwgY2F1c2UgemVybyByZWJ1ZmZlcmluZy5cbiAqL1xudmFyIG1pblJlYnVmZmVyTWF4QmFuZHdpZHRoU2VsZWN0b3IgPSBmdW5jdGlvbiBtaW5SZWJ1ZmZlck1heEJhbmR3aWR0aFNlbGVjdG9yKHNldHRpbmdzKSB7XG4gIHZhciBtYXN0ZXIgPSBzZXR0aW5ncy5tYXN0ZXI7XG4gIHZhciBjdXJyZW50VGltZSA9IHNldHRpbmdzLmN1cnJlbnRUaW1lO1xuICB2YXIgYmFuZHdpZHRoID0gc2V0dGluZ3MuYmFuZHdpZHRoO1xuICB2YXIgZHVyYXRpb24gPSBzZXR0aW5ncy5kdXJhdGlvbjtcbiAgdmFyIHNlZ21lbnREdXJhdGlvbiA9IHNldHRpbmdzLnNlZ21lbnREdXJhdGlvbjtcbiAgdmFyIHRpbWVVbnRpbFJlYnVmZmVyID0gc2V0dGluZ3MudGltZVVudGlsUmVidWZmZXI7XG4gIHZhciBjdXJyZW50VGltZWxpbmUgPSBzZXR0aW5ncy5jdXJyZW50VGltZWxpbmU7XG4gIHZhciBzeW5jQ29udHJvbGxlciA9IHNldHRpbmdzLnN5bmNDb250cm9sbGVyO1xuXG4gIC8vIGZpbHRlciBvdXQgYW55IHBsYXlsaXN0cyB0aGF0IGhhdmUgYmVlbiBleGNsdWRlZCBkdWUgdG9cbiAgLy8gaW5jb21wYXRpYmxlIGNvbmZpZ3VyYXRpb25zXG4gIHZhciBjb21wYXRpYmxlUGxheWxpc3RzID0gbWFzdGVyLnBsYXlsaXN0cy5maWx0ZXIoZnVuY3Rpb24gKHBsYXlsaXN0KSB7XG4gICAgcmV0dXJuICFfcGxheWxpc3QyWydkZWZhdWx0J10uaXNJbmNvbXBhdGlibGUocGxheWxpc3QpO1xuICB9KTtcblxuICAvLyBmaWx0ZXIgb3V0IGFueSBwbGF5bGlzdHMgdGhhdCBoYXZlIGJlZW4gZGlzYWJsZWQgbWFudWFsbHkgdGhyb3VnaCB0aGUgcmVwcmVzZW50YXRpb25zXG4gIC8vIGFwaSBvciBibGFja2xpc3RlZCB0ZW1wb3JhcmlseSBkdWUgdG8gcGxheWJhY2sgZXJyb3JzLlxuICB2YXIgZW5hYmxlZFBsYXlsaXN0cyA9IGNvbXBhdGlibGVQbGF5bGlzdHMuZmlsdGVyKF9wbGF5bGlzdDJbJ2RlZmF1bHQnXS5pc0VuYWJsZWQpO1xuXG4gIGlmICghZW5hYmxlZFBsYXlsaXN0cy5sZW5ndGgpIHtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gZW5hYmxlZCBwbGF5bGlzdHMsIHRoZW4gdGhleSBoYXZlIGFsbCBiZWVuIGJsYWNrbGlzdGVkIG9yIGRpc2FibGVkXG4gICAgLy8gYnkgdGhlIHVzZXIgdGhyb3VnaCB0aGUgcmVwcmVzZW50YXRpb25zIGFwaS4gSW4gdGhpcyBjYXNlLCBpZ25vcmUgYmxhY2tsaXN0aW5nIGFuZFxuICAgIC8vIGZhbGxiYWNrIHRvIHdoYXQgdGhlIHVzZXIgd2FudHMgYnkgdXNpbmcgcGxheWxpc3RzIHRoZSB1c2VyIGhhcyBub3QgZGlzYWJsZWQuXG4gICAgZW5hYmxlZFBsYXlsaXN0cyA9IGNvbXBhdGlibGVQbGF5bGlzdHMuZmlsdGVyKGZ1bmN0aW9uIChwbGF5bGlzdCkge1xuICAgICAgcmV0dXJuICFfcGxheWxpc3QyWydkZWZhdWx0J10uaXNEaXNhYmxlZChwbGF5bGlzdCk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgYmFuZHdpZHRoUGxheWxpc3RzID0gZW5hYmxlZFBsYXlsaXN0cy5maWx0ZXIoX3BsYXlsaXN0MlsnZGVmYXVsdCddLmhhc0F0dHJpYnV0ZS5iaW5kKG51bGwsICdCQU5EV0lEVEgnKSk7XG5cbiAgdmFyIHJlYnVmZmVyaW5nRXN0aW1hdGVzID0gYmFuZHdpZHRoUGxheWxpc3RzLm1hcChmdW5jdGlvbiAocGxheWxpc3QpIHtcbiAgICB2YXIgc3luY1BvaW50ID0gc3luY0NvbnRyb2xsZXIuZ2V0U3luY1BvaW50KHBsYXlsaXN0LCBkdXJhdGlvbiwgY3VycmVudFRpbWVsaW5lLCBjdXJyZW50VGltZSk7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gc3luYyBwb2ludCBmb3IgdGhpcyBwbGF5bGlzdCwgc3dpdGNoaW5nIHRvIGl0IHdpbGwgcmVxdWlyZSBhXG4gICAgLy8gc3luYyByZXF1ZXN0IGZpcnN0LiBUaGlzIHdpbGwgZG91YmxlIHRoZSByZXF1ZXN0IHRpbWVcbiAgICB2YXIgbnVtUmVxdWVzdHMgPSBzeW5jUG9pbnQgPyAxIDogMjtcbiAgICB2YXIgcmVxdWVzdFRpbWVFc3RpbWF0ZSA9IF9wbGF5bGlzdDJbJ2RlZmF1bHQnXS5lc3RpbWF0ZVNlZ21lbnRSZXF1ZXN0VGltZShzZWdtZW50RHVyYXRpb24sIGJhbmR3aWR0aCwgcGxheWxpc3QpO1xuICAgIHZhciByZWJ1ZmZlcmluZ0ltcGFjdCA9IHJlcXVlc3RUaW1lRXN0aW1hdGUgKiBudW1SZXF1ZXN0cyAtIHRpbWVVbnRpbFJlYnVmZmVyO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBsYXlsaXN0OiBwbGF5bGlzdCxcbiAgICAgIHJlYnVmZmVyaW5nSW1wYWN0OiByZWJ1ZmZlcmluZ0ltcGFjdFxuICAgIH07XG4gIH0pO1xuXG4gIHZhciBub1JlYnVmZmVyaW5nUGxheWxpc3RzID0gcmVidWZmZXJpbmdFc3RpbWF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChlc3RpbWF0ZSkge1xuICAgIHJldHVybiBlc3RpbWF0ZS5yZWJ1ZmZlcmluZ0ltcGFjdCA8PSAwO1xuICB9KTtcblxuICAvLyBTb3J0IGJ5IGJhbmR3aWR0aCBERVNDXG4gIHN0YWJsZVNvcnQobm9SZWJ1ZmZlcmluZ1BsYXlsaXN0cywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gY29tcGFyZVBsYXlsaXN0QmFuZHdpZHRoKGIucGxheWxpc3QsIGEucGxheWxpc3QpO1xuICB9KTtcblxuICBpZiAobm9SZWJ1ZmZlcmluZ1BsYXlsaXN0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbm9SZWJ1ZmZlcmluZ1BsYXlsaXN0c1swXTtcbiAgfVxuXG4gIHN0YWJsZVNvcnQocmVidWZmZXJpbmdFc3RpbWF0ZXMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEucmVidWZmZXJpbmdJbXBhY3QgLSBiLnJlYnVmZmVyaW5nSW1wYWN0O1xuICB9KTtcblxuICByZXR1cm4gcmVidWZmZXJpbmdFc3RpbWF0ZXNbMF0gfHwgbnVsbDtcbn07XG5cbmV4cG9ydHMubWluUmVidWZmZXJNYXhCYW5kd2lkdGhTZWxlY3RvciA9IG1pblJlYnVmZmVyTWF4QmFuZHdpZHRoU2VsZWN0b3I7XG4vKipcbiAqIENob29zZXMgdGhlIGFwcHJvcHJpYXRlIG1lZGlhIHBsYXlsaXN0LCB3aGljaCBpbiB0aGlzIGNhc2UgaXMgdGhlIGxvd2VzdCBiaXRyYXRlXG4gKiBvbmUgd2l0aCB2aWRlby4gIElmIG5vIHJlbmRpdGlvbnMgd2l0aCB2aWRlbyBleGlzdCwgcmV0dXJuIHRoZSBsb3dlc3QgYXVkaW8gcmVuZGl0aW9uLlxuICpcbiAqIEV4cGVjdHMgdG8gYmUgY2FsbGVkIHdpdGhpbiB0aGUgY29udGV4dCBvZiBhbiBpbnN0YW5jZSBvZiBIbHNIYW5kbGVyXG4gKlxuICogQHJldHVybiB7T2JqZWN0fG51bGx9XG4gKiAgICAgICAgIHtPYmplY3R9IHJldHVybi5wbGF5bGlzdFxuICogICAgICAgICBUaGUgbG93ZXN0IGJpdHJhdGUgcGxheWxpc3QgdGhhdCBjb250YWlucyBhIHZpZGVvIGNvZGVjLiAgSWYgbm8gc3VjaCByZW5kaXRpb25cbiAqICAgICAgICAgZXhpc3RzIHBpY2sgdGhlIGxvd2VzdCBhdWRpbyByZW5kaXRpb24uXG4gKi9cbnZhciBsb3dlc3RCaXRyYXRlQ29tcGF0aWJsZVZhcmlhbnRTZWxlY3RvciA9IGZ1bmN0aW9uIGxvd2VzdEJpdHJhdGVDb21wYXRpYmxlVmFyaWFudFNlbGVjdG9yKCkge1xuICAvLyBmaWx0ZXIgb3V0IGFueSBwbGF5bGlzdHMgdGhhdCBoYXZlIGJlZW4gZXhjbHVkZWQgZHVlIHRvXG4gIC8vIGluY29tcGF0aWJsZSBjb25maWd1cmF0aW9ucyBvciBwbGF5YmFjayBlcnJvcnNcbiAgdmFyIHBsYXlsaXN0cyA9IHRoaXMucGxheWxpc3RzLm1hc3Rlci5wbGF5bGlzdHMuZmlsdGVyKF9wbGF5bGlzdDJbJ2RlZmF1bHQnXS5pc0VuYWJsZWQpO1xuXG4gIC8vIFNvcnQgYXNjZW5kaW5nIGJ5IGJpdHJhdGVcbiAgc3RhYmxlU29ydChwbGF5bGlzdHMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVQbGF5bGlzdEJhbmR3aWR0aChhLCBiKTtcbiAgfSk7XG5cbiAgLy8gUGFyc2UgYW5kIGFzc3VtZSB0aGF0IHBsYXlsaXN0cyB3aXRoIG5vIHZpZGVvIGNvZGVjIGhhdmUgbm8gdmlkZW9cbiAgLy8gKHRoaXMgaXMgbm90IG5lY2Vzc2FyaWx5IHRydWUsIGFsdGhvdWdoIGl0IGlzIGdlbmVyYWxseSB0cnVlKS5cbiAgLy9cbiAgLy8gSWYgYW4gZW50aXJlIG1hbmlmZXN0IGhhcyBubyB2YWxpZCB2aWRlb3MgZXZlcnl0aGluZyB3aWxsIGdldCBmaWx0ZXJlZFxuICAvLyBvdXQuXG4gIHZhciBwbGF5bGlzdHNXaXRoVmlkZW8gPSBwbGF5bGlzdHMuZmlsdGVyKGZ1bmN0aW9uIChwbGF5bGlzdCkge1xuICAgIHJldHVybiAoMCwgX3V0aWxDb2RlY3NKcy5wYXJzZUNvZGVjcykocGxheWxpc3QuYXR0cmlidXRlcy5DT0RFQ1MpLnZpZGVvQ29kZWM7XG4gIH0pO1xuXG4gIHJldHVybiBwbGF5bGlzdHNXaXRoVmlkZW9bMF0gfHwgbnVsbDtcbn07XG5leHBvcnRzLmxvd2VzdEJpdHJhdGVDb21wYXRpYmxlVmFyaWFudFNlbGVjdG9yID0gbG93ZXN0Qml0cmF0ZUNvbXBhdGlibGVWYXJpYW50U2VsZWN0b3I7XG59LHtcIi4vY29uZmlnXCI6MyxcIi4vcGxheWxpc3RcIjoxMSxcIi4vdXRpbC9jb2RlY3MuanNcIjoxOX1dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogQGZpbGUgcGxheWxpc3QuanNcbiAqXG4gKiBQbGF5bGlzdCByZWxhdGVkIHV0aWxpdGllcy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3ZpZGVvSnMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sndmlkZW9qcyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndmlkZW9qcyddIDogbnVsbCk7XG5cbnZhciBfZ2xvYmFsV2luZG93ID0gcmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgX2dsb2JhbFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxXaW5kb3cpO1xuXG4vKipcbiAqIHdhbGsgYmFja3dhcmQgdW50aWwgd2UgZmluZCBhIGR1cmF0aW9uIHdlIGNhbiB1c2VcbiAqIG9yIHJldHVybiBhIGZhaWx1cmVcbiAqXG4gKiBAcGFyYW0ge1BsYXlsaXN0fSBwbGF5bGlzdCB0aGUgcGxheWxpc3QgdG8gd2FsayB0aHJvdWdoXG4gKiBAcGFyYW0ge051bWJlcn0gZW5kU2VxdWVuY2UgdGhlIG1lZGlhU2VxdWVuY2UgdG8gc3RvcCB3YWxraW5nIG9uXG4gKi9cblxudmFyIGJhY2t3YXJkRHVyYXRpb24gPSBmdW5jdGlvbiBiYWNrd2FyZER1cmF0aW9uKHBsYXlsaXN0LCBlbmRTZXF1ZW5jZSkge1xuICB2YXIgcmVzdWx0ID0gMDtcbiAgdmFyIGkgPSBlbmRTZXF1ZW5jZSAtIHBsYXlsaXN0Lm1lZGlhU2VxdWVuY2U7XG4gIC8vIGlmIGEgc3RhcnQgdGltZSBpcyBhdmFpbGFibGUgZm9yIHNlZ21lbnQgaW1tZWRpYXRlbHkgZm9sbG93aW5nXG4gIC8vIHRoZSBpbnRlcnZhbCwgdXNlIGl0XG4gIHZhciBzZWdtZW50ID0gcGxheWxpc3Quc2VnbWVudHNbaV07XG5cbiAgLy8gV2FsayBiYWNrd2FyZCB1bnRpbCB3ZSBmaW5kIHRoZSBsYXRlc3Qgc2VnbWVudCB3aXRoIHRpbWVsaW5lXG4gIC8vIGluZm9ybWF0aW9uIHRoYXQgaXMgZWFybGllciB0aGFuIGVuZFNlcXVlbmNlXG4gIGlmIChzZWdtZW50KSB7XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50LnN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHsgcmVzdWx0OiBzZWdtZW50LnN0YXJ0LCBwcmVjaXNlOiB0cnVlIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VnbWVudC5lbmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHNlZ21lbnQuZW5kIC0gc2VnbWVudC5kdXJhdGlvbixcbiAgICAgICAgcHJlY2lzZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGktLSkge1xuICAgIHNlZ21lbnQgPSBwbGF5bGlzdC5zZWdtZW50c1tpXTtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQuZW5kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHsgcmVzdWx0OiByZXN1bHQgKyBzZWdtZW50LmVuZCwgcHJlY2lzZTogdHJ1ZSB9O1xuICAgIH1cblxuICAgIHJlc3VsdCArPSBzZWdtZW50LmR1cmF0aW9uO1xuXG4gICAgaWYgKHR5cGVvZiBzZWdtZW50LnN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHsgcmVzdWx0OiByZXN1bHQgKyBzZWdtZW50LnN0YXJ0LCBwcmVjaXNlOiB0cnVlIH07XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHJlc3VsdDogcmVzdWx0LCBwcmVjaXNlOiBmYWxzZSB9O1xufTtcblxuLyoqXG4gKiB3YWxrIGZvcndhcmQgdW50aWwgd2UgZmluZCBhIGR1cmF0aW9uIHdlIGNhbiB1c2VcbiAqIG9yIHJldHVybiBhIGZhaWx1cmVcbiAqXG4gKiBAcGFyYW0ge1BsYXlsaXN0fSBwbGF5bGlzdCB0aGUgcGxheWxpc3QgdG8gd2FsayB0aHJvdWdoXG4gKiBAcGFyYW0ge051bWJlcn0gZW5kU2VxdWVuY2UgdGhlIG1lZGlhU2VxdWVuY2UgdG8gc3RvcCB3YWxraW5nIG9uXG4gKi9cbnZhciBmb3J3YXJkRHVyYXRpb24gPSBmdW5jdGlvbiBmb3J3YXJkRHVyYXRpb24ocGxheWxpc3QsIGVuZFNlcXVlbmNlKSB7XG4gIHZhciByZXN1bHQgPSAwO1xuICB2YXIgc2VnbWVudCA9IHVuZGVmaW5lZDtcbiAgdmFyIGkgPSBlbmRTZXF1ZW5jZSAtIHBsYXlsaXN0Lm1lZGlhU2VxdWVuY2U7XG4gIC8vIFdhbGsgZm9yd2FyZCB1bnRpbCB3ZSBmaW5kIHRoZSBlYXJsaWVzdCBzZWdtZW50IHdpdGggdGltZWxpbmVcbiAgLy8gaW5mb3JtYXRpb25cblxuICBmb3IgKDsgaSA8IHBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgc2VnbWVudCA9IHBsYXlsaXN0LnNlZ21lbnRzW2ldO1xuICAgIGlmICh0eXBlb2Ygc2VnbWVudC5zdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDogc2VnbWVudC5zdGFydCAtIHJlc3VsdCxcbiAgICAgICAgcHJlY2lzZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXN1bHQgKz0gc2VnbWVudC5kdXJhdGlvbjtcblxuICAgIGlmICh0eXBlb2Ygc2VnbWVudC5lbmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHQ6IHNlZ21lbnQuZW5kIC0gcmVzdWx0LFxuICAgICAgICBwcmVjaXNlOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvLyBpbmRpY2F0ZSB3ZSBkaWRuJ3QgZmluZCBhIHVzZWZ1bCBkdXJhdGlvbiBlc3RpbWF0ZVxuICByZXR1cm4geyByZXN1bHQ6IC0xLCBwcmVjaXNlOiBmYWxzZSB9O1xufTtcblxuLyoqXG4gICogQ2FsY3VsYXRlIHRoZSBtZWRpYSBkdXJhdGlvbiBmcm9tIHRoZSBzZWdtZW50cyBhc3NvY2lhdGVkIHdpdGggYVxuICAqIHBsYXlsaXN0LiBUaGUgZHVyYXRpb24gb2YgYSBzdWJpbnRlcnZhbCBvZiB0aGUgYXZhaWxhYmxlIHNlZ21lbnRzXG4gICogbWF5IGJlIGNhbGN1bGF0ZWQgYnkgc3BlY2lmeWluZyBhbiBlbmQgaW5kZXguXG4gICpcbiAgKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgYSBtZWRpYSBwbGF5bGlzdCBvYmplY3RcbiAgKiBAcGFyYW0ge051bWJlcj19IGVuZFNlcXVlbmNlIGFuIGV4Y2x1c2l2ZSB1cHBlciBib3VuZGFyeVxuICAqIGZvciB0aGUgcGxheWxpc3QuICBEZWZhdWx0cyB0byBwbGF5bGlzdCBsZW5ndGguXG4gICogQHBhcmFtIHtOdW1iZXJ9IGV4cGlyZWQgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzIGRyb3BwZWRcbiAgKiBvZmYgdGhlIGZyb250IG9mIHRoZSBwbGF5bGlzdCBpbiBhIGxpdmUgc2NlbmFyaW9cbiAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBkdXJhdGlvbiBiZXR3ZWVuIHRoZSBmaXJzdCBhdmFpbGFibGUgc2VnbWVudFxuICAqIGFuZCBlbmQgaW5kZXguXG4gICovXG52YXIgaW50ZXJ2YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIGludGVydmFsRHVyYXRpb24ocGxheWxpc3QsIGVuZFNlcXVlbmNlLCBleHBpcmVkKSB7XG4gIHZhciBiYWNrd2FyZCA9IHVuZGVmaW5lZDtcbiAgdmFyIGZvcndhcmQgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKHR5cGVvZiBlbmRTZXF1ZW5jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbmRTZXF1ZW5jZSA9IHBsYXlsaXN0Lm1lZGlhU2VxdWVuY2UgKyBwbGF5bGlzdC5zZWdtZW50cy5sZW5ndGg7XG4gIH1cblxuICBpZiAoZW5kU2VxdWVuY2UgPCBwbGF5bGlzdC5tZWRpYVNlcXVlbmNlKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBkbyBhIGJhY2t3YXJkIHdhbGsgdG8gZXN0aW1hdGUgdGhlIGR1cmF0aW9uXG4gIGJhY2t3YXJkID0gYmFja3dhcmREdXJhdGlvbihwbGF5bGlzdCwgZW5kU2VxdWVuY2UpO1xuICBpZiAoYmFja3dhcmQucHJlY2lzZSkge1xuICAgIC8vIGlmIHdlIHdlcmUgYWJsZSB0byBiYXNlIG91ciBkdXJhdGlvbiBlc3RpbWF0ZSBvbiB0aW1pbmdcbiAgICAvLyBpbmZvcm1hdGlvbiBwcm92aWRlZCBkaXJlY3RseSBmcm9tIHRoZSBNZWRpYSBTb3VyY2UsIHJldHVyblxuICAgIC8vIGl0XG4gICAgcmV0dXJuIGJhY2t3YXJkLnJlc3VsdDtcbiAgfVxuXG4gIC8vIHdhbGsgZm9yd2FyZCB0byBzZWUgaWYgYSBwcmVjaXNlIGR1cmF0aW9uIGVzdGltYXRlIGNhbiBiZSBtYWRlXG4gIC8vIHRoYXQgd2F5XG4gIGZvcndhcmQgPSBmb3J3YXJkRHVyYXRpb24ocGxheWxpc3QsIGVuZFNlcXVlbmNlKTtcbiAgaWYgKGZvcndhcmQucHJlY2lzZSkge1xuICAgIC8vIHdlIGZvdW5kIGEgc2VnbWVudCB0aGF0IGhhcyBiZWVuIGJ1ZmZlcmVkIGFuZCBzbyBpdCdzXG4gICAgLy8gcG9zaXRpb24gaXMga25vd24gcHJlY2lzZWx5XG4gICAgcmV0dXJuIGZvcndhcmQucmVzdWx0O1xuICB9XG5cbiAgLy8gcmV0dXJuIHRoZSBsZXNzLXByZWNpc2UsIHBsYXlsaXN0LWJhc2VkIGR1cmF0aW9uIGVzdGltYXRlXG4gIHJldHVybiBiYWNrd2FyZC5yZXN1bHQgKyBleHBpcmVkO1xufTtcblxuLyoqXG4gICogQ2FsY3VsYXRlcyB0aGUgZHVyYXRpb24gb2YgYSBwbGF5bGlzdC4gSWYgYSBzdGFydCBhbmQgZW5kIGluZGV4XG4gICogYXJlIHNwZWNpZmllZCwgdGhlIGR1cmF0aW9uIHdpbGwgYmUgZm9yIHRoZSBzdWJzZXQgb2YgdGhlIG1lZGlhXG4gICogdGltZWxpbmUgYmV0d2VlbiB0aG9zZSB0d28gaW5kaWNlcy4gVGhlIHRvdGFsIGR1cmF0aW9uIGZvciBsaXZlXG4gICogcGxheWxpc3RzIGlzIGFsd2F5cyBJbmZpbml0eS5cbiAgKlxuICAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5bGlzdCBhIG1lZGlhIHBsYXlsaXN0IG9iamVjdFxuICAqIEBwYXJhbSB7TnVtYmVyPX0gZW5kU2VxdWVuY2UgYW4gZXhjbHVzaXZlIHVwcGVyXG4gICogYm91bmRhcnkgZm9yIHRoZSBwbGF5bGlzdC4gRGVmYXVsdHMgdG8gdGhlIHBsYXlsaXN0IG1lZGlhXG4gICogc2VxdWVuY2UgbnVtYmVyIHBsdXMgaXRzIGxlbmd0aC5cbiAgKiBAcGFyYW0ge051bWJlcj19IGV4cGlyZWQgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzXG4gICogZHJvcHBlZCBvZmYgdGhlIGZyb250IG9mIHRoZSBwbGF5bGlzdCBpbiBhIGxpdmUgc2NlbmFyaW9cbiAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBkdXJhdGlvbiBiZXR3ZWVuIHRoZSBzdGFydCBpbmRleCBhbmQgZW5kXG4gICogaW5kZXguXG4gICovXG52YXIgZHVyYXRpb24gPSBmdW5jdGlvbiBkdXJhdGlvbihwbGF5bGlzdCwgZW5kU2VxdWVuY2UsIGV4cGlyZWQpIHtcbiAgaWYgKCFwbGF5bGlzdCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBpcmVkICE9PSAnbnVtYmVyJykge1xuICAgIGV4cGlyZWQgPSAwO1xuICB9XG5cbiAgLy8gaWYgYSBzbGljZSBvZiB0aGUgdG90YWwgZHVyYXRpb24gaXMgbm90IHJlcXVlc3RlZCwgdXNlXG4gIC8vIHBsYXlsaXN0LWxldmVsIGR1cmF0aW9uIGluZGljYXRvcnMgd2hlbiB0aGV5J3JlIHByZXNlbnRcbiAgaWYgKHR5cGVvZiBlbmRTZXF1ZW5jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBpZiBwcmVzZW50LCB1c2UgdGhlIGR1cmF0aW9uIHNwZWNpZmllZCBpbiB0aGUgcGxheWxpc3RcbiAgICBpZiAocGxheWxpc3QudG90YWxEdXJhdGlvbikge1xuICAgICAgcmV0dXJuIHBsYXlsaXN0LnRvdGFsRHVyYXRpb247XG4gICAgfVxuXG4gICAgLy8gZHVyYXRpb24gc2hvdWxkIGJlIEluZmluaXR5IGZvciBsaXZlIHBsYXlsaXN0c1xuICAgIGlmICghcGxheWxpc3QuZW5kTGlzdCkge1xuICAgICAgcmV0dXJuIF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uSW5maW5pdHk7XG4gICAgfVxuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBkdXJhdGlvbiBiYXNlZCBvbiB0aGUgc2VnbWVudCBkdXJhdGlvbnNcbiAgcmV0dXJuIGludGVydmFsRHVyYXRpb24ocGxheWxpc3QsIGVuZFNlcXVlbmNlLCBleHBpcmVkKTtcbn07XG5cbmV4cG9ydHMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbi8qKlxuICAqIENhbGN1bGF0ZSB0aGUgdGltZSBiZXR3ZWVuIHR3byBpbmRleGVzIGluIHRoZSBjdXJyZW50IHBsYXlsaXN0XG4gICogbmVpZ2h0IHRoZSBzdGFydC0gbm9yIHRoZSBlbmQtaW5kZXggbmVlZCB0byBiZSB3aXRoaW4gdGhlIGN1cnJlbnRcbiAgKiBwbGF5bGlzdCBpbiB3aGljaCBjYXNlLCB0aGUgdGFyZ2V0RHVyYXRpb24gb2YgdGhlIHBsYXlsaXN0IGlzIHVzZWRcbiAgKiB0byBhcHByb3hpbWF0ZSB0aGUgZHVyYXRpb25zIG9mIHRoZSBzZWdtZW50c1xuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IHBsYXlsaXN0IGEgbWVkaWEgcGxheWxpc3Qgb2JqZWN0XG4gICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0SW5kZXhcbiAgKiBAcGFyYW0ge051bWJlcn0gZW5kSW5kZXhcbiAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBiZXR3ZWVuIHN0YXJ0SW5kZXggYW5kIGVuZEluZGV4XG4gICovXG52YXIgc3VtRHVyYXRpb25zID0gZnVuY3Rpb24gc3VtRHVyYXRpb25zKHBsYXlsaXN0LCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICB2YXIgZHVyYXRpb25zID0gMDtcblxuICBpZiAoc3RhcnRJbmRleCA+IGVuZEluZGV4KSB7XG4gICAgdmFyIF9yZWYgPSBbZW5kSW5kZXgsIHN0YXJ0SW5kZXhdO1xuICAgIHN0YXJ0SW5kZXggPSBfcmVmWzBdO1xuICAgIGVuZEluZGV4ID0gX3JlZlsxXTtcbiAgfVxuXG4gIGlmIChzdGFydEluZGV4IDwgMCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgTWF0aC5taW4oMCwgZW5kSW5kZXgpOyBpKyspIHtcbiAgICAgIGR1cmF0aW9ucyArPSBwbGF5bGlzdC50YXJnZXREdXJhdGlvbjtcbiAgICB9XG4gICAgc3RhcnRJbmRleCA9IDA7XG4gIH1cblxuICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICBkdXJhdGlvbnMgKz0gcGxheWxpc3Quc2VnbWVudHNbaV0uZHVyYXRpb247XG4gIH1cblxuICByZXR1cm4gZHVyYXRpb25zO1xufTtcblxuZXhwb3J0cy5zdW1EdXJhdGlvbnMgPSBzdW1EdXJhdGlvbnM7XG4vKipcbiAqIERldGVybWluZXMgdGhlIG1lZGlhIGluZGV4IG9mIHRoZSBzZWdtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHNhZmUgZWRnZSBvZiB0aGUgbGl2ZVxuICogd2luZG93IHdoaWNoIGlzIHRoZSBkdXJhdGlvbiBvZiB0aGUgbGFzdCBzZWdtZW50IHBsdXMgMiB0YXJnZXQgZHVyYXRpb25zIGZyb20gdGhlIGVuZFxuICogb2YgdGhlIHBsYXlsaXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5bGlzdFxuICogICAgICAgIGEgbWVkaWEgcGxheWxpc3Qgb2JqZWN0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiAgICAgICAgIFRoZSBtZWRpYSBpbmRleCBvZiB0aGUgc2VnbWVudCBhdCB0aGUgc2FmZSBsaXZlIHBvaW50LiAwIGlmIHRoZXJlIGlzIG5vIFwic2FmZVwiXG4gKiAgICAgICAgIHBvaW50LlxuICogQGZ1bmN0aW9uIHNhZmVMaXZlSW5kZXhcbiAqL1xudmFyIHNhZmVMaXZlSW5kZXggPSBmdW5jdGlvbiBzYWZlTGl2ZUluZGV4KHBsYXlsaXN0KSB7XG4gIGlmICghcGxheWxpc3Quc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgaSA9IHBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aCAtIDE7XG4gIHZhciBkaXN0YW5jZUZyb21FbmQgPSBwbGF5bGlzdC5zZWdtZW50c1tpXS5kdXJhdGlvbiB8fCBwbGF5bGlzdC50YXJnZXREdXJhdGlvbjtcbiAgdmFyIHNhZmVEaXN0YW5jZSA9IGRpc3RhbmNlRnJvbUVuZCArIHBsYXlsaXN0LnRhcmdldER1cmF0aW9uICogMjtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgZGlzdGFuY2VGcm9tRW5kICs9IHBsYXlsaXN0LnNlZ21lbnRzW2ldLmR1cmF0aW9uO1xuXG4gICAgaWYgKGRpc3RhbmNlRnJvbUVuZCA+PSBzYWZlRGlzdGFuY2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heCgwLCBpKTtcbn07XG5cbmV4cG9ydHMuc2FmZUxpdmVJbmRleCA9IHNhZmVMaXZlSW5kZXg7XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHBsYXlsaXN0IGVuZCB0aW1lXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBsYXlsaXN0IGEgbWVkaWEgcGxheWxpc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge051bWJlcj19IGV4cGlyZWQgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzXG4gKiAgICAgICAgICAgICAgICAgIGRyb3BwZWQgb2ZmIHRoZSBmcm9udCBvZiB0aGUgcGxheWxpc3QgaW4gYSBsaXZlIHNjZW5hcmlvXG4gKiBAcGFyYW0ge0Jvb2xlYW58ZmFsc2V9IHVzZVNhZmVMaXZlRW5kIGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICBwbGF5bGlzdCBlbmQgY2FsY3VsYXRpb24gc2hvdWxkIGNvbnNpZGVyIHRoZSBzYWZlIGxpdmUgZW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICh0cnVuY2F0ZSB0aGUgcGxheWxpc3QgZW5kIGJ5IHRocmVlIHNlZ21lbnRzKS4gVGhpcyBpcyBub3JtYWxseVxuICogICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGZvciBjYWxjdWxhdGluZyB0aGUgZW5kIG9mIHRoZSBwbGF5bGlzdCdzIHNlZWthYmxlIHJhbmdlLlxuICogQHJldHVybnMge051bWJlcn0gdGhlIGVuZCB0aW1lIG9mIHBsYXlsaXN0XG4gKiBAZnVuY3Rpb24gcGxheWxpc3RFbmRcbiAqL1xudmFyIHBsYXlsaXN0RW5kID0gZnVuY3Rpb24gcGxheWxpc3RFbmQocGxheWxpc3QsIGV4cGlyZWQsIHVzZVNhZmVMaXZlRW5kKSB7XG4gIGlmICghcGxheWxpc3QgfHwgIXBsYXlsaXN0LnNlZ21lbnRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHBsYXlsaXN0LmVuZExpc3QpIHtcbiAgICByZXR1cm4gZHVyYXRpb24ocGxheWxpc3QpO1xuICB9XG5cbiAgaWYgKGV4cGlyZWQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGV4cGlyZWQgPSBleHBpcmVkIHx8IDA7XG5cbiAgdmFyIGVuZFNlcXVlbmNlID0gdXNlU2FmZUxpdmVFbmQgPyBzYWZlTGl2ZUluZGV4KHBsYXlsaXN0KSA6IHBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aDtcblxuICByZXR1cm4gaW50ZXJ2YWxEdXJhdGlvbihwbGF5bGlzdCwgcGxheWxpc3QubWVkaWFTZXF1ZW5jZSArIGVuZFNlcXVlbmNlLCBleHBpcmVkKTtcbn07XG5cbmV4cG9ydHMucGxheWxpc3RFbmQgPSBwbGF5bGlzdEVuZDtcbi8qKlxuICAqIENhbGN1bGF0ZXMgdGhlIGludGVydmFsIG9mIHRpbWUgdGhhdCBpcyBjdXJyZW50bHkgc2Vla2FibGUgaW4gYVxuICAqIHBsYXlsaXN0LiBUaGUgcmV0dXJuZWQgdGltZSByYW5nZXMgYXJlIHJlbGF0aXZlIHRvIHRoZSBlYXJsaWVzdFxuICAqIG1vbWVudCBpbiB0aGUgc3BlY2lmaWVkIHBsYXlsaXN0IHRoYXQgaXMgc3RpbGwgYXZhaWxhYmxlLiBBIGZ1bGxcbiAgKiBzZWVrYWJsZSBpbXBsZW1lbnRhdGlvbiBmb3IgbGl2ZSBzdHJlYW1zIHdvdWxkIG5lZWQgdG8gb2Zmc2V0XG4gICogdGhlc2UgdmFsdWVzIGJ5IHRoZSBkdXJhdGlvbiBvZiBjb250ZW50IHRoYXQgaGFzIGV4cGlyZWQgZnJvbSB0aGVcbiAgKiBzdHJlYW0uXG4gICpcbiAgKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgYSBtZWRpYSBwbGF5bGlzdCBvYmplY3RcbiAgKiBkcm9wcGVkIG9mZiB0aGUgZnJvbnQgb2YgdGhlIHBsYXlsaXN0IGluIGEgbGl2ZSBzY2VuYXJpb1xuICAqIEBwYXJhbSB7TnVtYmVyPX0gZXhwaXJlZCB0aGUgYW1vdW50IG9mIHRpbWUgdGhhdCBoYXNcbiAgKiBkcm9wcGVkIG9mZiB0aGUgZnJvbnQgb2YgdGhlIHBsYXlsaXN0IGluIGEgbGl2ZSBzY2VuYXJpb1xuICAqIEByZXR1cm4ge1RpbWVSYW5nZXN9IHRoZSBwZXJpb2RzIG9mIHRpbWUgdGhhdCBhcmUgdmFsaWQgdGFyZ2V0c1xuICAqIGZvciBzZWVraW5nXG4gICovXG52YXIgc2Vla2FibGUgPSBmdW5jdGlvbiBzZWVrYWJsZShwbGF5bGlzdCwgZXhwaXJlZCkge1xuICB2YXIgdXNlU2FmZUxpdmVFbmQgPSB0cnVlO1xuICB2YXIgc2Vla2FibGVTdGFydCA9IGV4cGlyZWQgfHwgMDtcbiAgdmFyIHNlZWthYmxlRW5kID0gcGxheWxpc3RFbmQocGxheWxpc3QsIGV4cGlyZWQsIHVzZVNhZmVMaXZlRW5kKTtcblxuICBpZiAoc2Vla2FibGVFbmQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gKDAsIF92aWRlb0pzLmNyZWF0ZVRpbWVSYW5nZSkoKTtcbiAgfVxuICByZXR1cm4gKDAsIF92aWRlb0pzLmNyZWF0ZVRpbWVSYW5nZSkoc2Vla2FibGVTdGFydCwgc2Vla2FibGVFbmQpO1xufTtcblxuZXhwb3J0cy5zZWVrYWJsZSA9IHNlZWthYmxlO1xudmFyIGlzV2hvbGVOdW1iZXIgPSBmdW5jdGlvbiBpc1dob2xlTnVtYmVyKG51bSkge1xuICByZXR1cm4gbnVtIC0gTWF0aC5mbG9vcihudW0pID09PSAwO1xufTtcblxudmFyIHJvdW5kU2lnbmlmaWNhbnREaWdpdCA9IGZ1bmN0aW9uIHJvdW5kU2lnbmlmaWNhbnREaWdpdChpbmNyZW1lbnQsIG51bSkge1xuICAvLyBJZiB3ZSBoYXZlIGEgd2hvbGUgbnVtYmVyLCBqdXN0IGFkZCAxIHRvIGl0XG4gIGlmIChpc1dob2xlTnVtYmVyKG51bSkpIHtcbiAgICByZXR1cm4gbnVtICsgaW5jcmVtZW50ICogMC4xO1xuICB9XG5cbiAgdmFyIG51bURlY2ltYWxEaWdpdHMgPSBudW0udG9TdHJpbmcoKS5zcGxpdCgnLicpWzFdLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8PSBudW1EZWNpbWFsRGlnaXRzOyBpKyspIHtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLnBvdygxMCwgaSk7XG4gICAgdmFyIHRlbXAgPSBudW0gKiBzY2FsZTtcblxuICAgIGlmIChpc1dob2xlTnVtYmVyKHRlbXApIHx8IGkgPT09IG51bURlY2ltYWxEaWdpdHMpIHtcbiAgICAgIHJldHVybiAodGVtcCArIGluY3JlbWVudCkgLyBzY2FsZTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjZWlsTGVhc3RTaWduaWZpY2FudERpZ2l0ID0gcm91bmRTaWduaWZpY2FudERpZ2l0LmJpbmQobnVsbCwgMSk7XG52YXIgZmxvb3JMZWFzdFNpZ25pZmljYW50RGlnaXQgPSByb3VuZFNpZ25pZmljYW50RGlnaXQuYmluZChudWxsLCAtMSk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBpbmRleCBhbmQgZXN0aW1hdGVkIHN0YXJ0aW5nIHRpbWUgb2YgdGhlIHNlZ21lbnQgdGhhdFxuICogY29udGFpbnMgYSBzcGVjaWZpZWQgcGxheWJhY2sgcG9zaXRpb24gaW4gYSBtZWRpYSBwbGF5bGlzdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgdGhlIG1lZGlhIHBsYXlsaXN0IHRvIHF1ZXJ5XG4gKiBAcGFyYW0ge051bWJlcn0gY3VycmVudFRpbWUgVGhlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBlYXJsaWVzdFxuICogcG9zc2libGUgcG9zaXRpb24gdG8gZGV0ZXJtaW5lIHRoZSBjb250YWluaW5nIHNlZ21lbnQgZm9yXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRJbmRleFxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0VGltZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgZ2V0TWVkaWFJbmZvRm9yVGltZSA9IGZ1bmN0aW9uIGdldE1lZGlhSW5mb0ZvclRpbWUocGxheWxpc3QsIGN1cnJlbnRUaW1lLCBzdGFydEluZGV4LCBzdGFydFRpbWUpIHtcbiAgdmFyIGkgPSB1bmRlZmluZWQ7XG4gIHZhciBzZWdtZW50ID0gdW5kZWZpbmVkO1xuICB2YXIgbnVtU2VnbWVudHMgPSBwbGF5bGlzdC5zZWdtZW50cy5sZW5ndGg7XG5cbiAgdmFyIHRpbWUgPSBjdXJyZW50VGltZSAtIHN0YXJ0VGltZTtcblxuICBpZiAodGltZSA8IDApIHtcbiAgICAvLyBXYWxrIGJhY2t3YXJkIGZyb20gc3RhcnRJbmRleCBpbiB0aGUgcGxheWxpc3QsIGFkZGluZyBkdXJhdGlvbnNcbiAgICAvLyB1bnRpbCB3ZSBmaW5kIGEgc2VnbWVudCB0aGF0IGNvbnRhaW5zIGB0aW1lYCBhbmQgcmV0dXJuIGl0XG4gICAgaWYgKHN0YXJ0SW5kZXggPiAwKSB7XG4gICAgICBmb3IgKGkgPSBzdGFydEluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgc2VnbWVudCA9IHBsYXlsaXN0LnNlZ21lbnRzW2ldO1xuICAgICAgICB0aW1lICs9IGZsb29yTGVhc3RTaWduaWZpY2FudERpZ2l0KHNlZ21lbnQuZHVyYXRpb24pO1xuICAgICAgICBpZiAodGltZSA+IDApIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVkaWFJbmRleDogaSxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lIC0gc3VtRHVyYXRpb25zKHBsYXlsaXN0LCBzdGFydEluZGV4LCBpKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZmluZCBhIGdvb2Qgc2VnbWVudCB3aXRoaW4gdGhlIHBsYXlsaXN0XG4gICAgLy8gc28gc2VsZWN0IHRoZSBmaXJzdCBzZWdtZW50XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lZGlhSW5kZXg6IDAsXG4gICAgICBzdGFydFRpbWU6IGN1cnJlbnRUaW1lXG4gICAgfTtcbiAgfVxuXG4gIC8vIFdoZW4gc3RhcnRJbmRleCBpcyBuZWdhdGl2ZSwgd2UgZmlyc3Qgd2FsayBmb3J3YXJkIHRvIGZpcnN0IHNlZ21lbnRcbiAgLy8gYWRkaW5nIHRhcmdldCBkdXJhdGlvbnMuIElmIHdlIFwicnVuIG91dCBvZiB0aW1lXCIgYmVmb3JlIGdldHRpbmcgdG9cbiAgLy8gdGhlIGZpcnN0IHNlZ21lbnQsIHJldHVybiB0aGUgZmlyc3Qgc2VnbWVudFxuICBpZiAoc3RhcnRJbmRleCA8IDApIHtcbiAgICBmb3IgKGkgPSBzdGFydEluZGV4OyBpIDwgMDsgaSsrKSB7XG4gICAgICB0aW1lIC09IHBsYXlsaXN0LnRhcmdldER1cmF0aW9uO1xuICAgICAgaWYgKHRpbWUgPCAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWVkaWFJbmRleDogMCxcbiAgICAgICAgICBzdGFydFRpbWU6IGN1cnJlbnRUaW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXJ0SW5kZXggPSAwO1xuICB9XG5cbiAgLy8gV2FsayBmb3J3YXJkIGZyb20gc3RhcnRJbmRleCBpbiB0aGUgcGxheWxpc3QsIHN1YnRyYWN0aW5nIGR1cmF0aW9uc1xuICAvLyB1bnRpbCB3ZSBmaW5kIGEgc2VnbWVudCB0aGF0IGNvbnRhaW5zIGB0aW1lYCBhbmQgcmV0dXJuIGl0XG4gIGZvciAoaSA9IHN0YXJ0SW5kZXg7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG4gICAgc2VnbWVudCA9IHBsYXlsaXN0LnNlZ21lbnRzW2ldO1xuICAgIHRpbWUgLT0gY2VpbExlYXN0U2lnbmlmaWNhbnREaWdpdChzZWdtZW50LmR1cmF0aW9uKTtcbiAgICBpZiAodGltZSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lZGlhSW5kZXg6IGksXG4gICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lICsgc3VtRHVyYXRpb25zKHBsYXlsaXN0LCBzdGFydEluZGV4LCBpKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBXZSBhcmUgb3V0IG9mIHBvc3NpYmxlIGNhbmRpZGF0ZXMgc28gbG9hZCB0aGUgbGFzdCBvbmUuLi5cbiAgcmV0dXJuIHtcbiAgICBtZWRpYUluZGV4OiBudW1TZWdtZW50cyAtIDEsXG4gICAgc3RhcnRUaW1lOiBjdXJyZW50VGltZVxuICB9O1xufTtcblxuZXhwb3J0cy5nZXRNZWRpYUluZm9Gb3JUaW1lID0gZ2V0TWVkaWFJbmZvRm9yVGltZTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgcGxheWxpc3QgaXMgYmxhY2tsaXN0ZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5bGlzdCB0aGUgbWVkaWEgcGxheWxpc3Qgb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZSBwbGF5bGlzdCBpcyBibGFja2xpc3RlZCBvciBub3RcbiAqIEBmdW5jdGlvbiBpc0JsYWNrbGlzdGVkXG4gKi9cbnZhciBpc0JsYWNrbGlzdGVkID0gZnVuY3Rpb24gaXNCbGFja2xpc3RlZChwbGF5bGlzdCkge1xuICByZXR1cm4gcGxheWxpc3QuZXhjbHVkZVVudGlsICYmIHBsYXlsaXN0LmV4Y2x1ZGVVbnRpbCA+IERhdGUubm93KCk7XG59O1xuXG5leHBvcnRzLmlzQmxhY2tsaXN0ZWQgPSBpc0JsYWNrbGlzdGVkO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBwbGF5bGlzdCBpcyBjb21wYXRpYmxlIHdpdGggY3VycmVudCBwbGF5YmFjayBjb25maWd1cmF0aW9uIG9yIGhhc1xuICogYmVlbiBibGFja2xpc3RlZCBwZXJtYW5lbnRseSBmb3IgYmVpbmcgaW5jb21wYXRpYmxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5bGlzdCB0aGUgbWVkaWEgcGxheWxpc3Qgb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZSBwbGF5bGlzdCBpcyBpbmNvbXBhdGlibGUgb3Igbm90XG4gKiBAZnVuY3Rpb24gaXNJbmNvbXBhdGlibGVcbiAqL1xudmFyIGlzSW5jb21wYXRpYmxlID0gZnVuY3Rpb24gaXNJbmNvbXBhdGlibGUocGxheWxpc3QpIHtcbiAgcmV0dXJuIHBsYXlsaXN0LmV4Y2x1ZGVVbnRpbCAmJiBwbGF5bGlzdC5leGNsdWRlVW50aWwgPT09IEluZmluaXR5O1xufTtcblxuZXhwb3J0cy5pc0luY29tcGF0aWJsZSA9IGlzSW5jb21wYXRpYmxlO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBwbGF5bGlzdCBpcyBlbmFibGVkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgdGhlIG1lZGlhIHBsYXlsaXN0IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGUgcGxheWxpc3QgaXMgZW5hYmxlZCBvciBub3RcbiAqIEBmdW5jdGlvbiBpc0VuYWJsZWRcbiAqL1xudmFyIGlzRW5hYmxlZCA9IGZ1bmN0aW9uIGlzRW5hYmxlZChwbGF5bGlzdCkge1xuICB2YXIgYmxhY2tsaXN0ZWQgPSBpc0JsYWNrbGlzdGVkKHBsYXlsaXN0KTtcblxuICByZXR1cm4gIXBsYXlsaXN0LmRpc2FibGVkICYmICFibGFja2xpc3RlZDtcbn07XG5cbmV4cG9ydHMuaXNFbmFibGVkID0gaXNFbmFibGVkO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBwbGF5bGlzdCBoYXMgYmVlbiBtYW51YWxseSBkaXNhYmxlZCB0aHJvdWdoIHRoZSByZXByZXNlbnRhdGlvbnMgYXBpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5bGlzdCB0aGUgbWVkaWEgcGxheWxpc3Qgb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZSBwbGF5bGlzdCBpcyBkaXNhYmxlZCBtYW51YWxseSBvciBub3RcbiAqIEBmdW5jdGlvbiBpc0Rpc2FibGVkXG4gKi9cbnZhciBpc0Rpc2FibGVkID0gZnVuY3Rpb24gaXNEaXNhYmxlZChwbGF5bGlzdCkge1xuICByZXR1cm4gcGxheWxpc3QuZGlzYWJsZWQ7XG59O1xuXG5leHBvcnRzLmlzRGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcGxheWxpc3QgaXMgYW4gQUVTIGVuY3J5cHRlZCBITFMgc3RyZWFtXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBpdCdzIGFuIEFFUyBlbmNyeXB0ZWQgSExTIHN0cmVhbVxuICovXG52YXIgaXNBZXMgPSBmdW5jdGlvbiBpc0FlcyhtZWRpYSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhLnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG1lZGlhLnNlZ21lbnRzW2ldLmtleSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydHMuaXNBZXMgPSBpc0Flcztcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHBsYXlsaXN0IGNvbnRhaW5zIGZNUDRcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBwbGF5bGlzdCBjb250YWlucyBmTVA0XG4gKi9cbnZhciBpc0ZtcDQgPSBmdW5jdGlvbiBpc0ZtcDQobWVkaWEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWRpYS5zZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtZWRpYS5zZWdtZW50c1tpXS5tYXApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnRzLmlzRm1wNCA9IGlzRm1wNDtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwbGF5bGlzdCBoYXMgYSB2YWx1ZSBmb3IgdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0clxuICogICAgICAgIEF0dHJpYnV0ZSB0byBjaGVjayBmb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5bGlzdFxuICogICAgICAgIFRoZSBtZWRpYSBwbGF5bGlzdCBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgdGhlIHBsYXlsaXN0IGNvbnRhaW5zIGEgdmFsdWUgZm9yIHRoZSBhdHRyaWJ1dGUgb3Igbm90XG4gKiBAZnVuY3Rpb24gaGFzQXR0cmlidXRlXG4gKi9cbnZhciBoYXNBdHRyaWJ1dGUgPSBmdW5jdGlvbiBoYXNBdHRyaWJ1dGUoYXR0ciwgcGxheWxpc3QpIHtcbiAgcmV0dXJuIHBsYXlsaXN0LmF0dHJpYnV0ZXMgJiYgcGxheWxpc3QuYXR0cmlidXRlc1thdHRyXTtcbn07XG5cbmV4cG9ydHMuaGFzQXR0cmlidXRlID0gaGFzQXR0cmlidXRlO1xuLyoqXG4gKiBFc3RpbWF0ZXMgdGhlIHRpbWUgcmVxdWlyZWQgdG8gY29tcGxldGUgYSBzZWdtZW50IGRvd25sb2FkIGZyb20gdGhlIHNwZWNpZmllZCBwbGF5bGlzdFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzZWdtZW50RHVyYXRpb25cbiAqICAgICAgICBEdXJhdGlvbiBvZiByZXF1ZXN0ZWQgc2VnbWVudFxuICogQHBhcmFtIHtOdW1iZXJ9IGJhbmR3aWR0aFxuICogICAgICAgIEN1cnJlbnQgbWVhc3VyZWQgYmFuZHdpZHRoIG9mIHRoZSBwbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5bGlzdFxuICogICAgICAgIFRoZSBtZWRpYSBwbGF5bGlzdCBvYmplY3RcbiAqIEBwYXJhbSB7TnVtYmVyPX0gYnl0ZXNSZWNlaXZlZFxuICogICAgICAgIE51bWJlciBvZiBieXRlcyBhbHJlYWR5IHJlY2VpdmVkIGZvciB0aGUgcmVxdWVzdC4gRGVmYXVsdHMgdG8gMFxuICogQHJldHVybiB7TnVtYmVyfE5hTn1cbiAqICAgICAgICAgVGhlIGVzdGltYXRlZCB0aW1lIHRvIHJlcXVlc3QgdGhlIHNlZ21lbnQuIE5hTiBpZiBiYW5kd2lkdGggaW5mb3JtYXRpb24gZm9yXG4gKiAgICAgICAgIHRoZSBnaXZlbiBwbGF5bGlzdCBpcyB1bmF2YWlsYWJsZVxuICogQGZ1bmN0aW9uIGVzdGltYXRlU2VnbWVudFJlcXVlc3RUaW1lXG4gKi9cbnZhciBlc3RpbWF0ZVNlZ21lbnRSZXF1ZXN0VGltZSA9IGZ1bmN0aW9uIGVzdGltYXRlU2VnbWVudFJlcXVlc3RUaW1lKHNlZ21lbnREdXJhdGlvbiwgYmFuZHdpZHRoLCBwbGF5bGlzdCkge1xuICB2YXIgYnl0ZXNSZWNlaXZlZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbM107XG5cbiAgaWYgKCFoYXNBdHRyaWJ1dGUoJ0JBTkRXSURUSCcsIHBsYXlsaXN0KSkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICB2YXIgc2l6ZSA9IHNlZ21lbnREdXJhdGlvbiAqIHBsYXlsaXN0LmF0dHJpYnV0ZXMuQkFORFdJRFRIO1xuXG4gIHJldHVybiAoc2l6ZSAtIGJ5dGVzUmVjZWl2ZWQgKiA4KSAvIGJhbmR3aWR0aDtcbn07XG5cbmV4cG9ydHMuZXN0aW1hdGVTZWdtZW50UmVxdWVzdFRpbWUgPSBlc3RpbWF0ZVNlZ21lbnRSZXF1ZXN0VGltZTtcbi8qXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcGxheWxpc3QgaXMgdGhlIGxvd2VzdCByZW5kaXRpb25cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9uIGxvd2VzdCByZW5kaXRpb25cbiAqL1xudmFyIGlzTG93ZXN0RW5hYmxlZFJlbmRpdGlvbiA9IGZ1bmN0aW9uIGlzTG93ZXN0RW5hYmxlZFJlbmRpdGlvbihtYXN0ZXIsIG1lZGlhKSB7XG4gIGlmIChtYXN0ZXIucGxheWxpc3RzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRCYW5kd2lkdGggPSBtZWRpYS5hdHRyaWJ1dGVzLkJBTkRXSURUSCB8fCBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gIHJldHVybiBtYXN0ZXIucGxheWxpc3RzLmZpbHRlcihmdW5jdGlvbiAocGxheWxpc3QpIHtcbiAgICBpZiAoIWlzRW5hYmxlZChwbGF5bGlzdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHBsYXlsaXN0LmF0dHJpYnV0ZXMuQkFORFdJRFRIIHx8IDApIDwgY3VycmVudEJhbmR3aWR0aDtcbiAgfSkubGVuZ3RoID09PSAwO1xufTtcblxuZXhwb3J0cy5pc0xvd2VzdEVuYWJsZWRSZW5kaXRpb24gPSBpc0xvd2VzdEVuYWJsZWRSZW5kaXRpb247XG4vLyBleHBvcnRzXG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgc2Vla2FibGU6IHNlZWthYmxlLFxuICBzYWZlTGl2ZUluZGV4OiBzYWZlTGl2ZUluZGV4LFxuICBnZXRNZWRpYUluZm9Gb3JUaW1lOiBnZXRNZWRpYUluZm9Gb3JUaW1lLFxuICBpc0VuYWJsZWQ6IGlzRW5hYmxlZCxcbiAgaXNEaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgaXNCbGFja2xpc3RlZDogaXNCbGFja2xpc3RlZCxcbiAgaXNJbmNvbXBhdGlibGU6IGlzSW5jb21wYXRpYmxlLFxuICBwbGF5bGlzdEVuZDogcGxheWxpc3RFbmQsXG4gIGlzQWVzOiBpc0FlcyxcbiAgaXNGbXA0OiBpc0ZtcDQsXG4gIGhhc0F0dHJpYnV0ZTogaGFzQXR0cmlidXRlLFxuICBlc3RpbWF0ZVNlZ21lbnRSZXF1ZXN0VGltZTogZXN0aW1hdGVTZWdtZW50UmVxdWVzdFRpbWUsXG4gIGlzTG93ZXN0RW5hYmxlZFJlbmRpdGlvbjogaXNMb3dlc3RFbmFibGVkUmVuZGl0aW9uXG59O1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcImdsb2JhbC93aW5kb3dcIjozMn1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogcmFuZ2VzXG4gKlxuICogVXRpbGl0aWVzIGZvciB3b3JraW5nIHdpdGggVGltZVJhbmdlcy5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbJ3JldHVybiddKSBfaVsncmV0dXJuJ10oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpOyB9IH07IH0pKCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF92aWRlb0pzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ3ZpZGVvanMnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ3ZpZGVvanMnXSA6IG51bGwpO1xuXG52YXIgX3ZpZGVvSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlkZW9Kcyk7XG5cbi8vIEZ1ZGdlIGZhY3RvciB0byBhY2NvdW50IGZvciBUaW1lUmFuZ2VzIHJvdW5kaW5nXG52YXIgVElNRV9GVURHRV9GQUNUT1IgPSAxIC8gMzA7XG4vLyBDb21wYXJpc29ucyBiZXR3ZWVuIHRpbWUgdmFsdWVzIHN1Y2ggYXMgY3VycmVudCB0aW1lIGFuZCB0aGUgZW5kIG9mIHRoZSBidWZmZXJlZCByYW5nZVxuLy8gY2FuIGJlIG1pc2xlYWRpbmcgYmVjYXVzZSBvZiBwcmVjaXNpb24gZGlmZmVyZW5jZXMgb3Igd2hlbiB0aGUgY3VycmVudCBtZWRpYSBoYXMgcG9vcmx5XG4vLyBhbGlnbmVkIGF1ZGlvIGFuZCB2aWRlbywgd2hpY2ggY2FuIGNhdXNlIHZhbHVlcyB0byBiZSBzbGlnaHRseSBvZmYgZnJvbSB3aGF0IHlvdSB3b3VsZFxuLy8gZXhwZWN0LiBUaGlzIHZhbHVlIGlzIHdoYXQgd2UgY29uc2lkZXIgdG8gYmUgc2FmZSB0byB1c2UgaW4gc3VjaCBjb21wYXJpc29ucyB0byBhY2NvdW50XG4vLyBmb3IgdGhlc2Ugc2NlbmFyaW9zLlxudmFyIFNBRkVfVElNRV9ERUxUQSA9IFRJTUVfRlVER0VfRkFDVE9SICogMztcblxuLyoqXG4gKiBDbGFtcHMgYSB2YWx1ZSB0byB3aXRoaW4gYSByYW5nZVxuICogQHBhcmFtIHtOdW1iZXJ9IG51bSAtIHRoZSB2YWx1ZSB0byBjbGFtcFxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IC0gdGhlIHN0YXJ0IG9mIHRoZSByYW5nZSB0byBjbGFtcCB3aXRoaW4sIGluY2x1c2l2ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZCAtIHRoZSBlbmQgb2YgdGhlIHJhbmdlIHRvIGNsYW1wIHdpdGhpbiwgaW5jbHVzaXZlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZhciBjbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKG51bSwgX3JlZikge1xuICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKTtcblxuICB2YXIgc3RhcnQgPSBfcmVmMlswXTtcbiAgdmFyIGVuZCA9IF9yZWYyWzFdO1xuXG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChzdGFydCwgbnVtKSwgZW5kKTtcbn07XG52YXIgZmlsdGVyUmFuZ2VzID0gZnVuY3Rpb24gZmlsdGVyUmFuZ2VzKHRpbWVSYW5nZXMsIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgaSA9IHVuZGVmaW5lZDtcblxuICBpZiAodGltZVJhbmdlcyAmJiB0aW1lUmFuZ2VzLmxlbmd0aCkge1xuICAgIC8vIFNlYXJjaCBmb3IgcmFuZ2VzIHRoYXQgbWF0Y2ggdGhlIHByZWRpY2F0ZVxuICAgIGZvciAoaSA9IDA7IGkgPCB0aW1lUmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocHJlZGljYXRlKHRpbWVSYW5nZXMuc3RhcnQoaSksIHRpbWVSYW5nZXMuZW5kKGkpKSkge1xuICAgICAgICByZXN1bHRzLnB1c2goW3RpbWVSYW5nZXMuc3RhcnQoaSksIHRpbWVSYW5nZXMuZW5kKGkpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF92aWRlb0pzMlsnZGVmYXVsdCddLmNyZWF0ZVRpbWVSYW5nZXMocmVzdWx0cyk7XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGZpbmQgdGhlIGJ1ZmZlcmVkIFRpbWVSYW5nZSB0aGF0IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWRcbiAqIHRpbWUuXG4gKiBAcGFyYW0ge1RpbWVSYW5nZXN9IGJ1ZmZlcmVkIC0gdGhlIFRpbWVSYW5nZXMgb2JqZWN0IHRvIHF1ZXJ5XG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSAgLSB0aGUgdGltZSB0byBmaWx0ZXIgb24uXG4gKiBAcmV0dXJucyB7VGltZVJhbmdlc30gYSBuZXcgVGltZVJhbmdlcyBvYmplY3RcbiAqL1xudmFyIGZpbmRSYW5nZSA9IGZ1bmN0aW9uIGZpbmRSYW5nZShidWZmZXJlZCwgdGltZSkge1xuICByZXR1cm4gZmlsdGVyUmFuZ2VzKGJ1ZmZlcmVkLCBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBzdGFydCAtIFRJTUVfRlVER0VfRkFDVE9SIDw9IHRpbWUgJiYgZW5kICsgVElNRV9GVURHRV9GQUNUT1IgPj0gdGltZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIFRpbWVSYW5nZXMgdGhhdCBiZWdpbiBsYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQgdGltZS5cbiAqIEBwYXJhbSB7VGltZVJhbmdlc30gdGltZVJhbmdlcyAtIHRoZSBUaW1lUmFuZ2VzIG9iamVjdCB0byBxdWVyeVxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgLSB0aGUgdGltZSB0byBmaWx0ZXIgb24uXG4gKiBAcmV0dXJucyB7VGltZVJhbmdlc30gYSBuZXcgVGltZVJhbmdlcyBvYmplY3QuXG4gKi9cbnZhciBmaW5kTmV4dFJhbmdlID0gZnVuY3Rpb24gZmluZE5leHRSYW5nZSh0aW1lUmFuZ2VzLCB0aW1lKSB7XG4gIHJldHVybiBmaWx0ZXJSYW5nZXModGltZVJhbmdlcywgZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgcmV0dXJuIHN0YXJ0IC0gVElNRV9GVURHRV9GQUNUT1IgPj0gdGltZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZ2FwcyB3aXRoaW4gYSBsaXN0IG9mIFRpbWVSYW5nZXNcbiAqIEBwYXJhbSB7VGltZVJhbmdlc30gYnVmZmVyZWQgLSB0aGUgVGltZVJhbmdlcyBvYmplY3RcbiAqIEByZXR1cm4ge1RpbWVSYW5nZXN9IGEgVGltZVJhbmdlcyBvYmplY3Qgb2YgZ2Fwc1xuICovXG52YXIgZmluZEdhcHMgPSBmdW5jdGlvbiBmaW5kR2FwcyhidWZmZXJlZCkge1xuICBpZiAoYnVmZmVyZWQubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBfdmlkZW9KczJbJ2RlZmF1bHQnXS5jcmVhdGVUaW1lUmFuZ2VzKCk7XG4gIH1cblxuICB2YXIgcmFuZ2VzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGFydCA9IGJ1ZmZlcmVkLmVuZChpIC0gMSk7XG4gICAgdmFyIGVuZCA9IGJ1ZmZlcmVkLnN0YXJ0KGkpO1xuXG4gICAgcmFuZ2VzLnB1c2goW3N0YXJ0LCBlbmRdKTtcbiAgfVxuXG4gIHJldHVybiBfdmlkZW9KczJbJ2RlZmF1bHQnXS5jcmVhdGVUaW1lUmFuZ2VzKHJhbmdlcyk7XG59O1xuXG4vKipcbiAqIFNlYXJjaCBmb3IgYSBsaWtlbHkgZW5kIHRpbWUgZm9yIHRoZSBzZWdtZW50IHRoYXQgd2FzIGp1c3QgYXBwZW5lZFxuICogYmFzZWQgb24gdGhlIHN0YXRlIG9mIHRoZSBgYnVmZmVyZWRgIHByb3BlcnR5IGJlZm9yZSBhbmQgYWZ0ZXIgdGhlXG4gKiBhcHBlbmQuIElmIHdlIGZpbiBvbmx5IG9uZSBzdWNoIHVuY29tbW9uIGVuZC1wb2ludCByZXR1cm4gaXQuXG4gKiBAcGFyYW0ge1RpbWVSYW5nZXN9IG9yaWdpbmFsIC0gdGhlIGJ1ZmZlcmVkIHRpbWUgcmFuZ2VzIGJlZm9yZSB0aGUgdXBkYXRlXG4gKiBAcGFyYW0ge1RpbWVSYW5nZXN9IHVwZGF0ZSAtIHRoZSBidWZmZXJlZCB0aW1lIHJhbmdlcyBhZnRlciB0aGUgdXBkYXRlXG4gKiBAcmV0dXJucyB7TnVtYmVyfG51bGx9IHRoZSBlbmQgdGltZSBhZGRlZCBiZXR3ZWVuIGBvcmlnaW5hbGAgYW5kIGB1cGRhdGVgLFxuICogb3IgbnVsbCBpZiBvbmUgY2Fubm90IGJlIHVuYW1iaWd1b3VzbHkgZGV0ZXJtaW5lZC5cbiAqL1xudmFyIGZpbmRTb2xlVW5jb21tb25UaW1lUmFuZ2VzRW5kID0gZnVuY3Rpb24gZmluZFNvbGVVbmNvbW1vblRpbWVSYW5nZXNFbmQob3JpZ2luYWwsIHVwZGF0ZSkge1xuICB2YXIgaSA9IHVuZGVmaW5lZDtcbiAgdmFyIHN0YXJ0ID0gdW5kZWZpbmVkO1xuICB2YXIgZW5kID0gdW5kZWZpbmVkO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBlZGdlcyA9IFtdO1xuXG4gIC8vIEluIG9yZGVyIHRvIHF1YWxpZnkgYXMgYSBwb3NzaWJsZSBjYW5kaWRhdGUsIHRoZSBlbmQgcG9pbnQgbXVzdDpcbiAgLy8gIDEpIE5vdCBoYXZlIGFscmVhZHkgZXhpc3RlZCBpbiB0aGUgYG9yaWdpbmFsYCByYW5nZXNcbiAgLy8gIDIpIE5vdCByZXN1bHQgZnJvbSB0aGUgc2hyaW5raW5nIG9mIGEgcmFuZ2UgdGhhdCBhbHJlYWR5IGV4aXN0ZWRcbiAgLy8gICAgIGluIHRoZSBgb3JpZ2luYWxgIHJhbmdlc1xuICAvLyAgMykgTm90IGJlIGNvbnRhaW5lZCBpbnNpZGUgb2YgYSByYW5nZSB0aGF0IGV4aXN0ZWQgaW4gYG9yaWdpbmFsYFxuICB2YXIgb3ZlcmxhcHNDdXJyZW50RW5kID0gZnVuY3Rpb24gb3ZlcmxhcHNDdXJyZW50RW5kKHNwYW4pIHtcbiAgICByZXR1cm4gc3BhblswXSA8PSBlbmQgJiYgc3BhblsxXSA+PSBlbmQ7XG4gIH07XG5cbiAgaWYgKG9yaWdpbmFsKSB7XG4gICAgLy8gU2F2ZSBhbGwgdGhlIGVkZ2VzIGluIHRoZSBgb3JpZ2luYWxgIFRpbWVSYW5nZXMgb2JqZWN0XG4gICAgZm9yIChpID0gMDsgaSA8IG9yaWdpbmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGFydCA9IG9yaWdpbmFsLnN0YXJ0KGkpO1xuICAgICAgZW5kID0gb3JpZ2luYWwuZW5kKGkpO1xuXG4gICAgICBlZGdlcy5wdXNoKFtzdGFydCwgZW5kXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHVwZGF0ZSkge1xuICAgIC8vIFNhdmUgYW55IGVuZC1wb2ludHMgaW4gYHVwZGF0ZWAgdGhhdCBhcmUgbm90IGluIHRoZSBgb3JpZ2luYWxgXG4gICAgLy8gVGltZVJhbmdlcyBvYmplY3RcbiAgICBmb3IgKGkgPSAwOyBpIDwgdXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGFydCA9IHVwZGF0ZS5zdGFydChpKTtcbiAgICAgIGVuZCA9IHVwZGF0ZS5lbmQoaSk7XG5cbiAgICAgIGlmIChlZGdlcy5zb21lKG92ZXJsYXBzQ3VycmVudEVuZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGF0IHRoaXMgcG9pbnQgaXQgbXVzdCBiZSBhIHVuaXF1ZSBub24tc2hyaW5raW5nIGVuZCBlZGdlXG4gICAgICByZXN1bHQucHVzaChlbmQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHdlIGVyciBvbiB0aGUgc2lkZSBvZiBjYXV0aW9uIGFuZCByZXR1cm4gbnVsbCBpZiBkaWRuJ3QgZmluZFxuICAvLyBleGFjdGx5ICpvbmUqIGRpZmZlcmluZyBlbmQgZWRnZSBpbiB0aGUgc2VhcmNoIGFib3ZlXG4gIGlmIChyZXN1bHQubGVuZ3RoICE9PSAxKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0WzBdO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gVGltZVJhbmdlc1xuICogQHBhcmFtIHtUaW1lUmFuZ2VzfSBidWZmZXJBXG4gKiBAcGFyYW0ge1RpbWVSYW5nZXN9IGJ1ZmZlckJcbiAqIEByZXR1cm5zIHtUaW1lUmFuZ2VzfSBUaGUgaW50ZXJlc2VjdGlvbiBvZiBgYnVmZmVyQWAgd2l0aCBgYnVmZmVyQmBcbiAqL1xudmFyIGJ1ZmZlckludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGJ1ZmZlckludGVyc2VjdGlvbihidWZmZXJBLCBidWZmZXJCKSB7XG4gIHZhciBzdGFydCA9IG51bGw7XG4gIHZhciBlbmQgPSBudWxsO1xuICB2YXIgYXJpdHkgPSAwO1xuICB2YXIgZXh0ZW50cyA9IFtdO1xuICB2YXIgcmFuZ2VzID0gW107XG5cbiAgaWYgKCFidWZmZXJBIHx8ICFidWZmZXJBLmxlbmd0aCB8fCAhYnVmZmVyQiB8fCAhYnVmZmVyQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gX3ZpZGVvSnMyWydkZWZhdWx0J10uY3JlYXRlVGltZVJhbmdlKCk7XG4gIH1cblxuICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgaGF2ZSBib3RoIGJ1ZmZlcnMgYW5kIGNyZWF0ZSBhblxuICAvLyBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3b1xuICB2YXIgY291bnQgPSBidWZmZXJBLmxlbmd0aDtcblxuICAvLyBBKSBHYXRoZXIgdXAgYWxsIHN0YXJ0IGFuZCBlbmQgdGltZXNcbiAgd2hpbGUgKGNvdW50LS0pIHtcbiAgICBleHRlbnRzLnB1c2goeyB0aW1lOiBidWZmZXJBLnN0YXJ0KGNvdW50KSwgdHlwZTogJ3N0YXJ0JyB9KTtcbiAgICBleHRlbnRzLnB1c2goeyB0aW1lOiBidWZmZXJBLmVuZChjb3VudCksIHR5cGU6ICdlbmQnIH0pO1xuICB9XG4gIGNvdW50ID0gYnVmZmVyQi5sZW5ndGg7XG4gIHdoaWxlIChjb3VudC0tKSB7XG4gICAgZXh0ZW50cy5wdXNoKHsgdGltZTogYnVmZmVyQi5zdGFydChjb3VudCksIHR5cGU6ICdzdGFydCcgfSk7XG4gICAgZXh0ZW50cy5wdXNoKHsgdGltZTogYnVmZmVyQi5lbmQoY291bnQpLCB0eXBlOiAnZW5kJyB9KTtcbiAgfVxuICAvLyBCKSBTb3J0IHRoZW0gYnkgdGltZVxuICBleHRlbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuICB9KTtcblxuICAvLyBDKSBHbyBhbG9uZyBvbmUgYnkgb25lIGluY3JlbWVudGluZyBhcml0eSBmb3Igc3RhcnQgYW5kIGRlY3JlbWVudGluZ1xuICAvLyAgICBhcml0eSBmb3IgZW5kc1xuICBmb3IgKGNvdW50ID0gMDsgY291bnQgPCBleHRlbnRzLmxlbmd0aDsgY291bnQrKykge1xuICAgIGlmIChleHRlbnRzW2NvdW50XS50eXBlID09PSAnc3RhcnQnKSB7XG4gICAgICBhcml0eSsrO1xuXG4gICAgICAvLyBEKSBJZiBhcml0eSBpcyBldmVyIGluY3JlbWVudGVkIHRvIDIgd2UgYXJlIGVudGVyaW5nIGFuXG4gICAgICAvLyAgICBvdmVybGFwcGluZyByYW5nZVxuICAgICAgaWYgKGFyaXR5ID09PSAyKSB7XG4gICAgICAgIHN0YXJ0ID0gZXh0ZW50c1tjb3VudF0udGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4dGVudHNbY291bnRdLnR5cGUgPT09ICdlbmQnKSB7XG4gICAgICBhcml0eS0tO1xuXG4gICAgICAvLyBFKSBJZiBhcml0eSBpcyBldmVyIGRlY3JlbWVudGVkIHRvIDEgd2UgbGVhdmluZyBhblxuICAgICAgLy8gICAgb3ZlcmxhcHBpbmcgcmFuZ2VcbiAgICAgIGlmIChhcml0eSA9PT0gMSkge1xuICAgICAgICBlbmQgPSBleHRlbnRzW2NvdW50XS50aW1lO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEYpIFJlY29yZCBvdmVybGFwcGluZyByYW5nZXNcbiAgICBpZiAoc3RhcnQgIT09IG51bGwgJiYgZW5kICE9PSBudWxsKSB7XG4gICAgICByYW5nZXMucHVzaChbc3RhcnQsIGVuZF0pO1xuICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgZW5kID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX3ZpZGVvSnMyWydkZWZhdWx0J10uY3JlYXRlVGltZVJhbmdlcyhyYW5nZXMpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwZXJjZW50YWdlIG9mIGBzZWdtZW50UmFuZ2VgIHRoYXQgb3ZlcmxhcHMgdGhlXG4gKiBgYnVmZmVyZWRgIHRpbWUgcmFuZ2VzLlxuICogQHBhcmFtIHtUaW1lUmFuZ2VzfSBzZWdtZW50UmFuZ2UgLSB0aGUgdGltZSByYW5nZSB0aGF0IHRoZSBzZWdtZW50XG4gKiBjb3ZlcnMgYWRqdXN0ZWQgYWNjb3JkaW5nIHRvIGN1cnJlbnRUaW1lXG4gKiBAcGFyYW0ge1RpbWVSYW5nZXN9IHJlZmVyZW5jZVJhbmdlIC0gdGhlIG9yaWdpbmFsIHRpbWUgcmFuZ2UgdGhhdCB0aGVcbiAqIHNlZ21lbnQgY292ZXJzXG4gKiBAcGFyYW0ge051bWJlcn0gY3VycmVudFRpbWUgLSB0aW1lIGluIHNlY29uZHMgd2hlcmUgdGhlIGN1cnJlbnQgcGxheWJhY2tcbiAqIGlzIGF0XG4gKiBAcGFyYW0ge1RpbWVSYW5nZXN9IGJ1ZmZlcmVkIC0gdGhlIGN1cnJlbnRseSBidWZmZXJlZCB0aW1lIHJhbmdlc1xuICogQHJldHVybnMge051bWJlcn0gcGVyY2VudCBvZiB0aGUgc2VnbWVudCBjdXJyZW50bHkgYnVmZmVyZWRcbiAqL1xudmFyIGNhbGN1bGF0ZUJ1ZmZlcmVkUGVyY2VudCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUJ1ZmZlcmVkUGVyY2VudChhZGp1c3RlZFJhbmdlLCByZWZlcmVuY2VSYW5nZSwgY3VycmVudFRpbWUsIGJ1ZmZlcmVkKSB7XG4gIHZhciByZWZlcmVuY2VEdXJhdGlvbiA9IHJlZmVyZW5jZVJhbmdlLmVuZCgwKSAtIHJlZmVyZW5jZVJhbmdlLnN0YXJ0KDApO1xuICB2YXIgYWRqdXN0ZWREdXJhdGlvbiA9IGFkanVzdGVkUmFuZ2UuZW5kKDApIC0gYWRqdXN0ZWRSYW5nZS5zdGFydCgwKTtcbiAgdmFyIGJ1ZmZlck1pc3NpbmdGcm9tQWRqdXN0ZWQgPSByZWZlcmVuY2VEdXJhdGlvbiAtIGFkanVzdGVkRHVyYXRpb247XG4gIHZhciBhZGp1c3RlZEludGVyc2VjdGlvbiA9IGJ1ZmZlckludGVyc2VjdGlvbihhZGp1c3RlZFJhbmdlLCBidWZmZXJlZCk7XG4gIHZhciByZWZlcmVuY2VJbnRlcnNlY3Rpb24gPSBidWZmZXJJbnRlcnNlY3Rpb24ocmVmZXJlbmNlUmFuZ2UsIGJ1ZmZlcmVkKTtcbiAgdmFyIGFkanVzdGVkT3ZlcmxhcCA9IDA7XG4gIHZhciByZWZlcmVuY2VPdmVybGFwID0gMDtcblxuICB2YXIgY291bnQgPSBhZGp1c3RlZEludGVyc2VjdGlvbi5sZW5ndGg7XG5cbiAgd2hpbGUgKGNvdW50LS0pIHtcbiAgICBhZGp1c3RlZE92ZXJsYXAgKz0gYWRqdXN0ZWRJbnRlcnNlY3Rpb24uZW5kKGNvdW50KSAtIGFkanVzdGVkSW50ZXJzZWN0aW9uLnN0YXJ0KGNvdW50KTtcblxuICAgIC8vIElmIHRoZSBjdXJyZW50IG92ZXJsYXAgc2VnbWVudCBzdGFydHMgYXQgY3VycmVudFRpbWUsIHRoZW4gaW5jcmVhc2UgdGhlXG4gICAgLy8gb3ZlcmxhcCBkdXJhdGlvbiBzbyB0aGF0IGl0IGFjdHVhbGx5IHN0YXJ0cyBhdCB0aGUgYmVnaW5uaW5nIG9mIHJlZmVyZW5jZVJhbmdlXG4gICAgLy8gYnkgaW5jbHVkaW5nIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHR3byBSYW5nZSdzIGR1cmF0aW9uc1xuICAgIC8vIFRoaXMgaXMgYSB3b3JrIGFyb3VuZCBmb3IgdGhlIHdheSBGbGFzaCBoYXMgbm8gYnVmZmVyIGJlZm9yZSBjdXJyZW50VGltZVxuICAgIGlmIChhZGp1c3RlZEludGVyc2VjdGlvbi5zdGFydChjb3VudCkgPT09IGN1cnJlbnRUaW1lKSB7XG4gICAgICBhZGp1c3RlZE92ZXJsYXAgKz0gYnVmZmVyTWlzc2luZ0Zyb21BZGp1c3RlZDtcbiAgICB9XG4gIH1cblxuICBjb3VudCA9IHJlZmVyZW5jZUludGVyc2VjdGlvbi5sZW5ndGg7XG5cbiAgd2hpbGUgKGNvdW50LS0pIHtcbiAgICByZWZlcmVuY2VPdmVybGFwICs9IHJlZmVyZW5jZUludGVyc2VjdGlvbi5lbmQoY291bnQpIC0gcmVmZXJlbmNlSW50ZXJzZWN0aW9uLnN0YXJ0KGNvdW50KTtcbiAgfVxuXG4gIC8vIFVzZSB3aGljaGV2ZXIgdmFsdWUgaXMgbGFyZ2VyIGZvciB0aGUgcGVyY2VudGFnZS1idWZmZXJlZCBzaW5jZSB0aGF0IHZhbHVlXG4gIC8vIGlzIGxpa2VseSBtb3JlIGFjY3VyYXRlIGJlY2F1c2UgdGhlIG9ubHkgd2F5XG4gIHJldHVybiBNYXRoLm1heChhZGp1c3RlZE92ZXJsYXAsIHJlZmVyZW5jZU92ZXJsYXApIC8gcmVmZXJlbmNlRHVyYXRpb24gKiAxMDA7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgYW1vdW50IG9mIGEgcmFuZ2Ugc3BlY2lmaWVkIGJ5IHRoZSBzdGFydE9mU2VnbWVudCBhbmQgc2VnbWVudER1cmF0aW9uXG4gKiBvdmVybGFwcyB0aGUgY3VycmVudCBidWZmZXJlZCBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydE9mU2VnbWVudCAtIHRoZSB0aW1lIHdoZXJlIHRoZSBzZWdtZW50IGJlZ2luc1xuICogQHBhcmFtIHtOdW1iZXJ9IHNlZ21lbnREdXJhdGlvbiAtIHRoZSBkdXJhdGlvbiBvZiB0aGUgc2VnbWVudCBpbiBzZWNvbmRzXG4gKiBAcGFyYW0ge051bWJlcn0gY3VycmVudFRpbWUgLSB0aW1lIGluIHNlY29uZHMgd2hlcmUgdGhlIGN1cnJlbnQgcGxheWJhY2tcbiAqIGlzIGF0XG4gKiBAcGFyYW0ge1RpbWVSYW5nZXN9IGJ1ZmZlcmVkIC0gdGhlIHN0YXRlIG9mIHRoZSBidWZmZXJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHBlcmNlbnRhZ2Ugb2YgdGhlIHNlZ21lbnQncyB0aW1lIHJhbmdlIHRoYXQgaXNcbiAqIGFscmVhZHkgaW4gYGJ1ZmZlcmVkYFxuICovXG52YXIgZ2V0U2VnbWVudEJ1ZmZlcmVkUGVyY2VudCA9IGZ1bmN0aW9uIGdldFNlZ21lbnRCdWZmZXJlZFBlcmNlbnQoc3RhcnRPZlNlZ21lbnQsIHNlZ21lbnREdXJhdGlvbiwgY3VycmVudFRpbWUsIGJ1ZmZlcmVkKSB7XG4gIHZhciBlbmRPZlNlZ21lbnQgPSBzdGFydE9mU2VnbWVudCArIHNlZ21lbnREdXJhdGlvbjtcblxuICAvLyBUaGUgZW50aXJlIHRpbWUgcmFuZ2Ugb2YgdGhlIHNlZ21lbnRcbiAgdmFyIG9yaWdpbmFsU2VnbWVudFJhbmdlID0gX3ZpZGVvSnMyWydkZWZhdWx0J10uY3JlYXRlVGltZVJhbmdlcyhbW3N0YXJ0T2ZTZWdtZW50LCBlbmRPZlNlZ21lbnRdXSk7XG5cbiAgLy8gVGhlIGFkanVzdGVkIHNlZ21lbnQgdGltZSByYW5nZSB0aGF0IGlzIHNldHVwIHN1Y2ggdGhhdCBpdCBzdGFydHNcbiAgLy8gbm8gZWFybGllciB0aGFuIGN1cnJlbnRUaW1lXG4gIC8vIEZsYXNoIGhhcyBubyBub3Rpb24gb2YgYSBiYWNrLWJ1ZmZlciBzbyBhZGp1c3RlZFNlZ21lbnRSYW5nZSBhZGp1c3RzXG4gIC8vIGZvciB0aGF0IGFuZCB0aGUgZnVuY3Rpb24gd2lsbCBzdGlsbCByZXR1cm4gMTAwJSBpZiBhIG9ubHkgaGFsZiBvZiBhXG4gIC8vIHNlZ21lbnQgaXMgYWN0dWFsbHkgaW4gdGhlIGJ1ZmZlciBhcyBsb25nIGFzIHRoZSBjdXJyZW50VGltZSBpcyBhbHNvXG4gIC8vIGhhbGYtd2F5IHRocm91Z2ggdGhlIHNlZ21lbnRcbiAgdmFyIGFkanVzdGVkU2VnbWVudFJhbmdlID0gX3ZpZGVvSnMyWydkZWZhdWx0J10uY3JlYXRlVGltZVJhbmdlcyhbW2NsYW1wKHN0YXJ0T2ZTZWdtZW50LCBbY3VycmVudFRpbWUsIGVuZE9mU2VnbWVudF0pLCBlbmRPZlNlZ21lbnRdXSk7XG5cbiAgLy8gVGhpcyBjb25kaXRpb24gaGFwcGVucyB3aGVuIHRoZSBjdXJyZW50VGltZSBpcyBiZXlvbmQgdGhlIHNlZ21lbnQnc1xuICAvLyBlbmQgdGltZVxuICBpZiAoYWRqdXN0ZWRTZWdtZW50UmFuZ2Uuc3RhcnQoMCkgPT09IGFkanVzdGVkU2VnbWVudFJhbmdlLmVuZCgwKSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHBlcmNlbnQgPSBjYWxjdWxhdGVCdWZmZXJlZFBlcmNlbnQoYWRqdXN0ZWRTZWdtZW50UmFuZ2UsIG9yaWdpbmFsU2VnbWVudFJhbmdlLCBjdXJyZW50VGltZSwgYnVmZmVyZWQpO1xuXG4gIC8vIElmIHRoZSBzZWdtZW50IGlzIHJlcG9ydGVkIGFzIGhhdmluZyBhIHplcm8gZHVyYXRpb24sIHJldHVybiAwJVxuICAvLyBzaW5jZSBpdCBpcyBsaWtlbHkgdGhhdCB3ZSB3aWxsIG5lZWQgdG8gZmV0Y2ggdGhlIHNlZ21lbnRcbiAgaWYgKGlzTmFOKHBlcmNlbnQpIHx8IHBlcmNlbnQgPT09IEluZmluaXR5IHx8IHBlcmNlbnQgPT09IC1JbmZpbml0eSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHBlcmNlbnQ7XG59O1xuXG4vKipcbiAqIEdldHMgYSBodW1hbiByZWFkYWJsZSBzdHJpbmcgZm9yIGEgVGltZVJhbmdlXG4gKlxuICogQHBhcmFtIHtUaW1lUmFuZ2V9IHJhbmdlXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhIGh1bWFuIHJlYWRhYmxlIHN0cmluZ1xuICovXG52YXIgcHJpbnRhYmxlUmFuZ2UgPSBmdW5jdGlvbiBwcmludGFibGVSYW5nZShyYW5nZSkge1xuICB2YXIgc3RyQXJyID0gW107XG5cbiAgaWYgKCFyYW5nZSB8fCAhcmFuZ2UubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5sZW5ndGg7IGkrKykge1xuICAgIHN0ckFyci5wdXNoKHJhbmdlLnN0YXJ0KGkpICsgJyA9PiAnICsgcmFuZ2UuZW5kKGkpKTtcbiAgfVxuXG4gIHJldHVybiBzdHJBcnIuam9pbignLCAnKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYW1vdW50IG9mIHRpbWUgbGVmdCBpbiBzZWNvbmRzIHVudGlsIHRoZSBwbGF5ZXIgaGl0cyB0aGUgZW5kIG9mIHRoZVxuICogYnVmZmVyIGFuZCBjYXVzZXMgYSByZWJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7VGltZVJhbmdlfSBidWZmZXJlZFxuICogICAgICAgIFRoZSBzdGF0ZSBvZiB0aGUgYnVmZmVyXG4gKiBAcGFyYW0ge051bW5iZXJ9IGN1cnJlbnRUaW1lXG4gKiAgICAgICAgVGhlIGN1cnJlbnQgdGltZSBvZiB0aGUgcGxheWVyXG4gKiBAcGFyYW0ge051bWJlcn0gcGxheWJhY2tSYXRlXG4gKiAgICAgICAgVGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZSBvZiB0aGUgcGxheWVyLiBEZWZhdWx0cyB0byAxLlxuICogQHJldHVybiB7TnVtYmVyfVxuICogICAgICAgICBUaW1lIHVudGlsIHRoZSBwbGF5ZXIgaGFzIHRvIHN0YXJ0IHJlYnVmZmVyaW5nIGluIHNlY29uZHMuXG4gKiBAZnVuY3Rpb24gdGltZVVudGlsUmVidWZmZXJcbiAqL1xudmFyIHRpbWVVbnRpbFJlYnVmZmVyID0gZnVuY3Rpb24gdGltZVVudGlsUmVidWZmZXIoYnVmZmVyZWQsIGN1cnJlbnRUaW1lKSB7XG4gIHZhciBwbGF5YmFja1JhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAxIDogYXJndW1lbnRzWzJdO1xuXG4gIHZhciBidWZmZXJlZEVuZCA9IGJ1ZmZlcmVkLmxlbmd0aCA/IGJ1ZmZlcmVkLmVuZChidWZmZXJlZC5sZW5ndGggLSAxKSA6IDA7XG5cbiAgcmV0dXJuIChidWZmZXJlZEVuZCAtIGN1cnJlbnRUaW1lKSAvIHBsYXliYWNrUmF0ZTtcbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgZmluZFJhbmdlOiBmaW5kUmFuZ2UsXG4gIGZpbmROZXh0UmFuZ2U6IGZpbmROZXh0UmFuZ2UsXG4gIGZpbmRHYXBzOiBmaW5kR2FwcyxcbiAgZmluZFNvbGVVbmNvbW1vblRpbWVSYW5nZXNFbmQ6IGZpbmRTb2xlVW5jb21tb25UaW1lUmFuZ2VzRW5kLFxuICBnZXRTZWdtZW50QnVmZmVyZWRQZXJjZW50OiBnZXRTZWdtZW50QnVmZmVyZWRQZXJjZW50LFxuICBUSU1FX0ZVREdFX0ZBQ1RPUjogVElNRV9GVURHRV9GQUNUT1IsXG4gIFNBRkVfVElNRV9ERUxUQTogU0FGRV9USU1FX0RFTFRBLFxuICBwcmludGFibGVSYW5nZTogcHJpbnRhYmxlUmFuZ2UsXG4gIHRpbWVVbnRpbFJlYnVmZmVyOiB0aW1lVW50aWxSZWJ1ZmZlclxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfdmlkZW9KcyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2aWRlb2pzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd2aWRlb2pzJ10gOiBudWxsKTtcblxudmFyIF92aWRlb0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvSnMpO1xuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGVycm9ySW50ZXJ2YWw6IDMwLFxuICBnZXRTb3VyY2U6IGZ1bmN0aW9uIGdldFNvdXJjZShuZXh0KSB7XG4gICAgdmFyIHRlY2ggPSB0aGlzLnRlY2goeyBJV2lsbE5vdFVzZVRoaXNJblBsdWdpbnM6IHRydWUgfSk7XG4gICAgdmFyIHNvdXJjZU9iaiA9IHRlY2guY3VycmVudFNvdXJjZV87XG5cbiAgICByZXR1cm4gbmV4dChzb3VyY2VPYmopO1xuICB9XG59O1xuXG4vKipcbiAqIE1haW4gZW50cnkgcG9pbnQgZm9yIHRoZSBwbHVnaW5cbiAqXG4gKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyIGEgcmVmZXJlbmNlIHRvIGEgdmlkZW9qcyBQbGF5ZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gYW4gb2JqZWN0IHdpdGggcGx1Z2luIG9wdGlvbnNcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBpbml0UGx1Z2luID0gZnVuY3Rpb24gaW5pdFBsdWdpbihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RDYWxsZWQgPSAwO1xuICB2YXIgc2Vla1RvID0gMDtcbiAgdmFyIGxvY2FsT3B0aW9ucyA9IF92aWRlb0pzMlsnZGVmYXVsdCddLm1lcmdlT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgcGxheWVyLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICBwbGF5ZXIudHJpZ2dlcih7IHR5cGU6ICd1c2FnZScsIG5hbWU6ICdobHMtZXJyb3ItcmVsb2FkLWluaXRpYWxpemVkJyB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFBsYXllciBtb2RpZmljYXRpb25zIHRvIHBlcmZvcm0gdGhhdCBtdXN0IHdhaXQgdW50aWwgYGxvYWRlZG1ldGFkYXRhYFxuICAgKiBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciBsb2FkZWRNZXRhZGF0YUhhbmRsZXIgPSBmdW5jdGlvbiBsb2FkZWRNZXRhZGF0YUhhbmRsZXIoKSB7XG4gICAgaWYgKHNlZWtUbykge1xuICAgICAgcGxheWVyLmN1cnJlbnRUaW1lKHNlZWtUbyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBvbiB0aGUgcGxheWVyIGVsZW1lbnQsIHBsYXksIGFuZCBzZWVrIGlmIG5lY2Vzc2FyeVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlT2JqIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBzb3VyY2UgdXJsIGFuZCBtaW1lLXR5cGUgdG8gcGxheVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIHNldFNvdXJjZSA9IGZ1bmN0aW9uIHNldFNvdXJjZShzb3VyY2VPYmopIHtcbiAgICBpZiAoc291cmNlT2JqID09PSBudWxsIHx8IHNvdXJjZU9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlZWtUbyA9IHBsYXllci5kdXJhdGlvbigpICE9PSBJbmZpbml0eSAmJiBwbGF5ZXIuY3VycmVudFRpbWUoKSB8fCAwO1xuXG4gICAgcGxheWVyLm9uZSgnbG9hZGVkbWV0YWRhdGEnLCBsb2FkZWRNZXRhZGF0YUhhbmRsZXIpO1xuXG4gICAgcGxheWVyLnNyYyhzb3VyY2VPYmopO1xuICAgIHBsYXllci50cmlnZ2VyKHsgdHlwZTogJ3VzYWdlJywgbmFtZTogJ2hscy1lcnJvci1yZWxvYWQnIH0pO1xuICAgIHBsYXllci5wbGF5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gZ2V0IGEgc291cmNlIGZyb20gZWl0aGVyIHRoZSBidWlsdC1pbiBnZXRTb3VyY2UgZnVuY3Rpb25cbiAgICogb3IgYSBjdXN0b20gZnVuY3Rpb24gcHJvdmlkZWQgdmlhIHRoZSBvcHRpb25zXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gZXJyb3JIYW5kbGVyKCkge1xuICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHJlbG9hZCB0aGUgc291cmNlIGlmIGEgc291cmNlLXJlbG9hZCBvY2N1cnJlZCBiZWZvcmVcbiAgICAvLyAnZXJyb3JJbnRlcnZhbCcgdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBzb3VyY2UtcmVsb2FkXG4gICAgaWYgKERhdGUubm93KCkgLSBsYXN0Q2FsbGVkIDwgbG9jYWxPcHRpb25zLmVycm9ySW50ZXJ2YWwgKiAxMDAwKSB7XG4gICAgICBwbGF5ZXIudHJpZ2dlcih7IHR5cGU6ICd1c2FnZScsIG5hbWU6ICdobHMtZXJyb3ItcmVsb2FkLWNhbmNlbGVkJyB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWxvY2FsT3B0aW9ucy5nZXRTb3VyY2UgfHwgdHlwZW9mIGxvY2FsT3B0aW9ucy5nZXRTb3VyY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIF92aWRlb0pzMlsnZGVmYXVsdCddLmxvZy5lcnJvcignRVJST1I6IHJlbG9hZFNvdXJjZU9uRXJyb3IgLSBUaGUgb3B0aW9uIGdldFNvdXJjZSBtdXN0IGJlIGEgZnVuY3Rpb24hJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3RDYWxsZWQgPSBEYXRlLm5vdygpO1xuXG4gICAgcmV0dXJuIGxvY2FsT3B0aW9ucy5nZXRTb3VyY2UuY2FsbChwbGF5ZXIsIHNldFNvdXJjZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVuYmluZCBhbnkgZXZlbnQgaGFuZGxlcnMgdGhhdCB3ZXJlIGJvdW5kIGJ5IHRoZSBwbHVnaW5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciBjbGVhbnVwRXZlbnRzID0gZnVuY3Rpb24gY2xlYW51cEV2ZW50cygpIHtcbiAgICBwbGF5ZXIub2ZmKCdsb2FkZWRtZXRhZGF0YScsIGxvYWRlZE1ldGFkYXRhSGFuZGxlcik7XG4gICAgcGxheWVyLm9mZignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuICAgIHBsYXllci5vZmYoJ2Rpc3Bvc2UnLCBjbGVhbnVwRXZlbnRzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYW51cCBiZWZvcmUgcmUtaW5pdGlhbGl6aW5nIHRoZSBwbHVnaW5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtuZXdPcHRpb25zXSBhbiBvYmplY3Qgd2l0aCBwbHVnaW4gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIHJlaW5pdFBsdWdpbiA9IGZ1bmN0aW9uIHJlaW5pdFBsdWdpbihuZXdPcHRpb25zKSB7XG4gICAgY2xlYW51cEV2ZW50cygpO1xuICAgIGluaXRQbHVnaW4ocGxheWVyLCBuZXdPcHRpb25zKTtcbiAgfTtcblxuICBwbGF5ZXIub24oJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcbiAgcGxheWVyLm9uKCdkaXNwb3NlJywgY2xlYW51cEV2ZW50cyk7XG5cbiAgLy8gT3ZlcndyaXRlIHRoZSBwbHVnaW4gZnVuY3Rpb24gc28gdGhhdCB3ZSBjYW4gY29ycmVjdGx5IGNsZWFudXAgYmVmb3JlXG4gIC8vIGluaXRpYWxpemluZyB0aGUgcGx1Z2luXG4gIHBsYXllci5yZWxvYWRTb3VyY2VPbkVycm9yID0gcmVpbml0UGx1Z2luO1xufTtcblxuLyoqXG4gKiBSZWxvYWQgdGhlIHNvdXJjZSB3aGVuIGFuIGVycm9yIGlzIGRldGVjdGVkIGFzIGxvbmcgYXMgdGhlcmVcbiAqIHdhc24ndCBhbiBlcnJvciBwcmV2aW91c2x5IHdpdGhpbiB0aGUgbGFzdCAzMCBzZWNvbmRzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBhbiBvYmplY3Qgd2l0aCBwbHVnaW4gb3B0aW9uc1xuICovXG52YXIgcmVsb2FkU291cmNlT25FcnJvciA9IGZ1bmN0aW9uIHJlbG9hZFNvdXJjZU9uRXJyb3Iob3B0aW9ucykge1xuICBpbml0UGx1Z2luKHRoaXMsIG9wdGlvbnMpO1xufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gcmVsb2FkU291cmNlT25FcnJvcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxudmFyIF9wbGF5bGlzdEpzID0gcmVxdWlyZSgnLi9wbGF5bGlzdC5qcycpO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjdHMgYXMgdGhlIEVuYWJsZS9kaXNhYmxlIHBsYXlsaXN0IGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7UGxheWxpc3RMb2FkZXJ9IGxvYWRlciAtIFRoZSBtYXN0ZXIgcGxheWxpc3QgbG9hZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxheWxpc3RVcmkgLSB1cmkgb2YgdGhlIHBsYXlsaXN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGFuZ2VQbGF5bGlzdEZuIC0gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgYVxuICogcGxheWxpc3QncyBlbmFibGVkLXN0YXRlIGhhcyBiZWVuIGNoYW5nZWQuIFdpbGwgTk9UIGJlIGNhbGxlZCBpZiBhXG4gKiBwbGF5bGlzdCdzIGVuYWJsZWQtc3RhdGUgaXMgdW5jaGFuZ2VkXG4gKiBAcGFyYW0ge0Jvb2xlYW49fSBlbmFibGUgLSBWYWx1ZSB0byBzZXQgdGhlIHBsYXlsaXN0IGVuYWJsZWQtc3RhdGUgdG9cbiAqIG9yIGlmIHVuZGVmaW5lZCByZXR1cm5zIHRoZSBjdXJyZW50IGVuYWJsZWQtc3RhdGUgZm9yIHRoZSBwbGF5bGlzdFxuICogQHJldHVybiB7RnVuY3Rpb259IEZ1bmN0aW9uIGZvciBzZXR0aW5nL2dldHRpbmcgZW5hYmxlZFxuICovXG52YXIgZW5hYmxlRnVuY3Rpb24gPSBmdW5jdGlvbiBlbmFibGVGdW5jdGlvbihsb2FkZXIsIHBsYXlsaXN0VXJpLCBjaGFuZ2VQbGF5bGlzdEZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZW5hYmxlKSB7XG4gICAgdmFyIHBsYXlsaXN0ID0gbG9hZGVyLm1hc3Rlci5wbGF5bGlzdHNbcGxheWxpc3RVcmldO1xuICAgIHZhciBpbmNvbXBhdGlibGUgPSAoMCwgX3BsYXlsaXN0SnMuaXNJbmNvbXBhdGlibGUpKHBsYXlsaXN0KTtcbiAgICB2YXIgY3VycmVudGx5RW5hYmxlZCA9ICgwLCBfcGxheWxpc3RKcy5pc0VuYWJsZWQpKHBsYXlsaXN0KTtcblxuICAgIGlmICh0eXBlb2YgZW5hYmxlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnRseUVuYWJsZWQ7XG4gICAgfVxuXG4gICAgaWYgKGVuYWJsZSkge1xuICAgICAgZGVsZXRlIHBsYXlsaXN0LmRpc2FibGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBwbGF5bGlzdC5kaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVuYWJsZSAhPT0gY3VycmVudGx5RW5hYmxlZCAmJiAhaW5jb21wYXRpYmxlKSB7XG4gICAgICAvLyBFbnN1cmUgdGhlIG91dHNpZGUgd29ybGQga25vd3MgYWJvdXQgb3VyIGNoYW5nZXNcbiAgICAgIGNoYW5nZVBsYXlsaXN0Rm4oKTtcbiAgICAgIGlmIChlbmFibGUpIHtcbiAgICAgICAgbG9hZGVyLnRyaWdnZXIoJ3JlbmRpdGlvbmVuYWJsZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRlci50cmlnZ2VyKCdyZW5kaXRpb25kaXNhYmxlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5hYmxlO1xuICB9O1xufTtcblxuLyoqXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2JqZWN0IGVuY2Fwc3VsYXRlcyB0aGUgcHVibGljbHkgdmlzaWJsZSBpbmZvcm1hdGlvblxuICogaW4gYSBtZWRpYSBwbGF5bGlzdCBhbG9uZyB3aXRoIGEgc2V0dGVyL2dldHRlci10eXBlIGZ1bmN0aW9uIChlbmFibGVkKVxuICogZm9yIGNoYW5naW5nIHRoZSBlbmFibGVkLXN0YXRlIG9mIGEgcGFydGljdWxhciBwbGF5bGlzdCBlbnRyeVxuICpcbiAqIEBjbGFzcyBSZXByZXNlbnRhdGlvblxuICovXG5cbnZhciBSZXByZXNlbnRhdGlvbiA9IGZ1bmN0aW9uIFJlcHJlc2VudGF0aW9uKGhsc0hhbmRsZXIsIHBsYXlsaXN0LCBpZCkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVwcmVzZW50YXRpb24pO1xuXG4gIC8vIEdldCBhIHJlZmVyZW5jZSB0byBhIGJvdW5kIHZlcnNpb24gb2YgZmFzdFF1YWxpdHlDaGFuZ2VfXG4gIHZhciBmYXN0Q2hhbmdlRnVuY3Rpb24gPSBobHNIYW5kbGVyLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8uZmFzdFF1YWxpdHlDaGFuZ2VfLmJpbmQoaGxzSGFuZGxlci5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfKTtcblxuICAvLyBzb21lIHBsYXlsaXN0IGF0dHJpYnV0ZXMgYXJlIG9wdGlvbmFsXG4gIGlmIChwbGF5bGlzdC5hdHRyaWJ1dGVzLlJFU09MVVRJT04pIHtcbiAgICB2YXIgcmVzb2x1dGlvbiA9IHBsYXlsaXN0LmF0dHJpYnV0ZXMuUkVTT0xVVElPTjtcblxuICAgIHRoaXMud2lkdGggPSByZXNvbHV0aW9uLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gIH1cblxuICB0aGlzLmJhbmR3aWR0aCA9IHBsYXlsaXN0LmF0dHJpYnV0ZXMuQkFORFdJRFRIO1xuXG4gIC8vIFRoZSBpZCBpcyBzaW1wbHkgdGhlIG9yZGluYWxpdHkgb2YgdGhlIG1lZGlhIHBsYXlsaXN0XG4gIC8vIHdpdGhpbiB0aGUgbWFzdGVyIHBsYXlsaXN0XG4gIHRoaXMuaWQgPSBpZDtcblxuICAvLyBQYXJ0aWFsbHktYXBwbHkgdGhlIGVuYWJsZUZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHBsYXlsaXN0LVxuICAvLyBzcGVjaWZpYyB2YXJpYW50XG4gIHRoaXMuZW5hYmxlZCA9IGVuYWJsZUZ1bmN0aW9uKGhsc0hhbmRsZXIucGxheWxpc3RzLCBwbGF5bGlzdC51cmksIGZhc3RDaGFuZ2VGdW5jdGlvbik7XG59XG5cbi8qKlxuICogQSBtaXhpbiBmdW5jdGlvbiB0aGF0IGFkZHMgdGhlIGByZXByZXNlbnRhdGlvbnNgIGFwaSB0byBhbiBpbnN0YW5jZVxuICogb2YgdGhlIEhsc0hhbmRsZXIgY2xhc3NcbiAqIEBwYXJhbSB7SGxzSGFuZGxlcn0gaGxzSGFuZGxlciAtIEFuIGluc3RhbmNlIG9mIEhsc0hhbmRsZXIgdG8gYWRkIHRoZVxuICogcmVwcmVzZW50YXRpb24gQVBJIGludG9cbiAqL1xuO1xuXG52YXIgcmVuZGl0aW9uU2VsZWN0aW9uTWl4aW4gPSBmdW5jdGlvbiByZW5kaXRpb25TZWxlY3Rpb25NaXhpbihobHNIYW5kbGVyKSB7XG4gIHZhciBwbGF5bGlzdHMgPSBobHNIYW5kbGVyLnBsYXlsaXN0cztcblxuICAvLyBBZGQgYSBzaW5nbGUgQVBJLXNwZWNpZmljIGZ1bmN0aW9uIHRvIHRoZSBIbHNIYW5kbGVyIGluc3RhbmNlXG4gIGhsc0hhbmRsZXIucmVwcmVzZW50YXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwbGF5bGlzdHMubWFzdGVyLnBsYXlsaXN0cy5maWx0ZXIoZnVuY3Rpb24gKG1lZGlhKSB7XG4gICAgICByZXR1cm4gISgwLCBfcGxheWxpc3RKcy5pc0luY29tcGF0aWJsZSkobWVkaWEpO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgcmV0dXJuIG5ldyBSZXByZXNlbnRhdGlvbihobHNIYW5kbGVyLCBlLCBlLnVyaSk7XG4gICAgfSk7XG4gIH07XG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSByZW5kaXRpb25TZWxlY3Rpb25NaXhpbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSx7XCIuL3BsYXlsaXN0LmpzXCI6MTF9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIHJlc29sdmUtdXJsLmpzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3VybFRvb2xraXQgPSByZXF1aXJlKCd1cmwtdG9vbGtpdCcpO1xuXG52YXIgX3VybFRvb2xraXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXJsVG9vbGtpdCk7XG5cbnZhciBfZ2xvYmFsV2luZG93ID0gcmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgX2dsb2JhbFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxXaW5kb3cpO1xuXG52YXIgcmVzb2x2ZVVybCA9IGZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgLy8gcmV0dXJuIGVhcmx5IGlmIHdlIGRvbid0IG5lZWQgdG8gcmVzb2x2ZVxuICBpZiAoL15bYS16XSs6L2kudGVzdChyZWxhdGl2ZVVSTCkpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVVUkw7XG4gIH1cblxuICAvLyBpZiB0aGUgYmFzZSBVUkwgaXMgcmVsYXRpdmUgdGhlbiBjb21iaW5lIHdpdGggdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgaWYgKCEvXFwvXFwvL2kudGVzdChiYXNlVVJMKSkge1xuICAgIGJhc2VVUkwgPSBfdXJsVG9vbGtpdDJbJ2RlZmF1bHQnXS5idWlsZEFic29sdXRlVVJMKF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10ubG9jYXRpb24uaHJlZiwgYmFzZVVSTCk7XG4gIH1cblxuICByZXR1cm4gX3VybFRvb2xraXQyWydkZWZhdWx0J10uYnVpbGRBYnNvbHV0ZVVSTChiYXNlVVJMLCByZWxhdGl2ZVVSTCk7XG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSByZXNvbHZlVXJsO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG59LHtcImdsb2JhbC93aW5kb3dcIjozMixcInVybC10b29sa2l0XCI6NjN9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIEBmaWxlIHNlZ21lbnQtbG9hZGVyLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94NCwgX3g1LCBfeDYpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3g0LCBwcm9wZXJ0eSA9IF94NSwgcmVjZWl2ZXIgPSBfeDY7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3g0ID0gcGFyZW50OyBfeDUgPSBwcm9wZXJ0eTsgX3g2ID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9wbGF5bGlzdCA9IHJlcXVpcmUoJy4vcGxheWxpc3QnKTtcblxudmFyIF9wbGF5bGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF5bGlzdCk7XG5cbnZhciBfdmlkZW9KcyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2aWRlb2pzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd2aWRlb2pzJ10gOiBudWxsKTtcblxudmFyIF92aWRlb0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvSnMpO1xuXG52YXIgX3NvdXJjZVVwZGF0ZXIgPSByZXF1aXJlKCcuL3NvdXJjZS11cGRhdGVyJyk7XG5cbnZhciBfc291cmNlVXBkYXRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zb3VyY2VVcGRhdGVyKTtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG52YXIgX2NvbmZpZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25maWcpO1xuXG52YXIgX2dsb2JhbFdpbmRvdyA9IHJlcXVpcmUoJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIF9nbG9iYWxXaW5kb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsV2luZG93KTtcblxudmFyIF92aWRlb2pzQ29udHJpYk1lZGlhU291cmNlc0VzNVJlbW92ZUN1ZXNGcm9tVHJhY2tKcyA9IHJlcXVpcmUoJ3ZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzL2VzNS9yZW1vdmUtY3Vlcy1mcm9tLXRyYWNrLmpzJyk7XG5cbnZhciBfdmlkZW9qc0NvbnRyaWJNZWRpYVNvdXJjZXNFczVSZW1vdmVDdWVzRnJvbVRyYWNrSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlkZW9qc0NvbnRyaWJNZWRpYVNvdXJjZXNFczVSZW1vdmVDdWVzRnJvbVRyYWNrSnMpO1xuXG52YXIgX2JpblV0aWxzID0gcmVxdWlyZSgnLi9iaW4tdXRpbHMnKTtcblxudmFyIF9tZWRpYVNlZ21lbnRSZXF1ZXN0ID0gcmVxdWlyZSgnLi9tZWRpYS1zZWdtZW50LXJlcXVlc3QnKTtcblxudmFyIF9yYW5nZXMgPSByZXF1aXJlKCcuL3JhbmdlcycpO1xuXG52YXIgX3BsYXlsaXN0U2VsZWN0b3JzID0gcmVxdWlyZSgnLi9wbGF5bGlzdC1zZWxlY3RvcnMnKTtcblxuLy8gaW4gbXNcbnZhciBDSEVDS19CVUZGRVJfREVMQVkgPSA1MDA7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB3ZSBzaG91bGQgY2FsbCBlbmRPZlN0cmVhbSBvbiB0aGUgbWVkaWEgc291cmNlIGJhc2VkXG4gKiBvbiB0aGUgc3RhdGUgb2YgdGhlIGJ1ZmZlciBvciBpZiBhcHBlbmVkIHNlZ21lbnQgd2FzIHRoZSBmaW5hbFxuICogc2VnbWVudCBpbiB0aGUgcGxheWxpc3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBsYXlsaXN0IGEgbWVkaWEgcGxheWxpc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gbWVkaWFTb3VyY2UgdGhlIE1lZGlhU291cmNlIG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXJ9IHNlZ21lbnRJbmRleCB0aGUgaW5kZXggb2Ygc2VnbWVudCB3ZSBsYXN0IGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZG8gd2UgbmVlZCB0byBjYWxsIGVuZE9mU3RyZWFtIG9uIHRoZSBNZWRpYVNvdXJjZVxuICovXG52YXIgZGV0ZWN0RW5kT2ZTdHJlYW0gPSBmdW5jdGlvbiBkZXRlY3RFbmRPZlN0cmVhbShwbGF5bGlzdCwgbWVkaWFTb3VyY2UsIHNlZ21lbnRJbmRleCkge1xuICBpZiAoIXBsYXlsaXN0IHx8ICFtZWRpYVNvdXJjZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBzZWdtZW50cyA9IHBsYXlsaXN0LnNlZ21lbnRzO1xuXG4gIC8vIGRldGVybWluZSBhIGZldyBib29sZWFuIHZhbHVlcyB0byBoZWxwIG1ha2UgdGhlIGJyYW5jaCBiZWxvdyBlYXNpZXJcbiAgLy8gdG8gcmVhZFxuICB2YXIgYXBwZW5kZWRMYXN0U2VnbWVudCA9IHNlZ21lbnRJbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoO1xuXG4gIC8vIGlmIHdlJ3ZlIGJ1ZmZlcmVkIHRvIHRoZSBlbmQgb2YgdGhlIHZpZGVvLCB3ZSBuZWVkIHRvIGNhbGwgZW5kT2ZTdHJlYW1cbiAgLy8gc28gdGhhdCBNZWRpYVNvdXJjZXMgY2FuIHRyaWdnZXIgdGhlIGBlbmRlZGAgZXZlbnQgd2hlbiBpdCBydW5zIG91dCBvZlxuICAvLyBidWZmZXJlZCBkYXRhIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgbWVcbiAgcmV0dXJuIHBsYXlsaXN0LmVuZExpc3QgJiYgbWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nICYmIGFwcGVuZGVkTGFzdFNlZ21lbnQ7XG59O1xuXG52YXIgZmluaXRlID0gZnVuY3Rpb24gZmluaXRlKG51bSkge1xuICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUobnVtKTtcbn07XG5cbnZhciBpbGxlZ2FsTWVkaWFTd2l0Y2ggPSBmdW5jdGlvbiBpbGxlZ2FsTWVkaWFTd2l0Y2gobG9hZGVyVHlwZSwgc3RhcnRpbmdNZWRpYSwgbmV3U2VnbWVudE1lZGlhKSB7XG4gIC8vIEFsdGhvdWdoIHRoZXNlIGNoZWNrcyBzaG91bGQgbW9zdCBsaWtlbHkgY292ZXIgbm9uICdtYWluJyB0eXBlcywgZm9yIG5vdyBpdCBuYXJyb3dzXG4gIC8vIHRoZSBzY29wZSBvZiBvdXIgY2hlY2tzLlxuICBpZiAobG9hZGVyVHlwZSAhPT0gJ21haW4nIHx8ICFzdGFydGluZ01lZGlhIHx8ICFuZXdTZWdtZW50TWVkaWEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghbmV3U2VnbWVudE1lZGlhLmNvbnRhaW5zQXVkaW8gJiYgIW5ld1NlZ21lbnRNZWRpYS5jb250YWluc1ZpZGVvKSB7XG4gICAgcmV0dXJuICdOZWl0aGVyIGF1ZGlvIG5vciB2aWRlbyBmb3VuZCBpbiBzZWdtZW50Lic7XG4gIH1cblxuICBpZiAoc3RhcnRpbmdNZWRpYS5jb250YWluc1ZpZGVvICYmICFuZXdTZWdtZW50TWVkaWEuY29udGFpbnNWaWRlbykge1xuICAgIHJldHVybiAnT25seSBhdWRpbyBmb3VuZCBpbiBzZWdtZW50IHdoZW4gd2UgZXhwZWN0ZWQgdmlkZW8uJyArICcgV2UgY2FuXFwndCBzd2l0Y2ggdG8gYXVkaW8gb25seSBmcm9tIGEgc3RyZWFtIHRoYXQgaGFkIHZpZGVvLicgKyAnIFRvIGdldCByaWQgb2YgdGhpcyBtZXNzYWdlLCBwbGVhc2UgYWRkIGNvZGVjIGluZm9ybWF0aW9uIHRvIHRoZSBtYW5pZmVzdC4nO1xuICB9XG5cbiAgaWYgKCFzdGFydGluZ01lZGlhLmNvbnRhaW5zVmlkZW8gJiYgbmV3U2VnbWVudE1lZGlhLmNvbnRhaW5zVmlkZW8pIHtcbiAgICByZXR1cm4gJ1ZpZGVvIGZvdW5kIGluIHNlZ21lbnQgd2hlbiB3ZSBleHBlY3RlZCBvbmx5IGF1ZGlvLicgKyAnIFdlIGNhblxcJ3Qgc3dpdGNoIHRvIGEgc3RyZWFtIHdpdGggdmlkZW8gZnJvbSBhbiBhdWRpbyBvbmx5IHN0cmVhbS4nICsgJyBUbyBnZXQgcmlkIG9mIHRoaXMgbWVzc2FnZSwgcGxlYXNlIGFkZCBjb2RlYyBpbmZvcm1hdGlvbiB0byB0aGUgbWFuaWZlc3QuJztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuZXhwb3J0cy5pbGxlZ2FsTWVkaWFTd2l0Y2ggPSBpbGxlZ2FsTWVkaWFTd2l0Y2g7XG4vKipcbiAqIENhbGN1bGF0ZXMgYSB0aW1lIHZhbHVlIHRoYXQgaXMgc2FmZSB0byByZW1vdmUgZnJvbSB0aGUgYmFjayBidWZmZXIgd2l0aG91dCBpbnRlcnVwdGluZ1xuICogcGxheWJhY2suXG4gKlxuICogQHBhcmFtIHtUaW1lUmFuZ2V9IHNlZWthYmxlXG4gKiAgICAgICAgVGhlIGN1cnJlbnQgc2Vla2FibGUgcmFuZ2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50VGltZVxuICogICAgICAgIFRoZSBjdXJyZW50IHRpbWUgb2YgdGhlIHBsYXllclxuICogQHBhcmFtIHtOdW1iZXJ9IHRhcmdldER1cmF0aW9uXG4gKiAgICAgICAgVGhlIHRhcmdldCBkdXJhdGlvbiBvZiB0aGUgY3VycmVudCBwbGF5bGlzdFxuICogQHJldHVybiB7TnVtYmVyfVxuICogICAgICAgICBUaW1lIHRoYXQgaXMgc2FmZSB0byByZW1vdmUgZnJvbSB0aGUgYmFjayBidWZmZXIgd2l0aG91dCBpbnRlcnVwdGluZyBwbGF5YmFja1xuICovXG52YXIgc2FmZUJhY2tCdWZmZXJUcmltVGltZSA9IGZ1bmN0aW9uIHNhZmVCYWNrQnVmZmVyVHJpbVRpbWUoc2Vla2FibGUsIGN1cnJlbnRUaW1lLCB0YXJnZXREdXJhdGlvbikge1xuICB2YXIgcmVtb3ZlVG9UaW1lID0gdW5kZWZpbmVkO1xuXG4gIGlmIChzZWVrYWJsZS5sZW5ndGggJiYgc2Vla2FibGUuc3RhcnQoMCkgPiAwICYmIHNlZWthYmxlLnN0YXJ0KDApIDwgY3VycmVudFRpbWUpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGEgc2Vla2FibGUgcmFuZ2UgdXNlIHRoYXQgYXMgdGhlIGxpbWl0IGZvciB3aGF0IGNhbiBiZSByZW1vdmVkIHNhZmVseVxuICAgIHJlbW92ZVRvVGltZSA9IHNlZWthYmxlLnN0YXJ0KDApO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aGVyd2lzZSByZW1vdmUgYW55dGhpbmcgb2xkZXIgdGhhbiAzMCBzZWNvbmRzIGJlZm9yZSB0aGUgY3VycmVudCBwbGF5IGhlYWRcbiAgICByZW1vdmVUb1RpbWUgPSBjdXJyZW50VGltZSAtIDMwO1xuICB9XG5cbiAgLy8gRG9uJ3QgYWxsb3cgcmVtb3ZpbmcgZnJvbSB0aGUgYnVmZmVyIHdpdGhpbiB0YXJnZXQgZHVyYXRpb24gb2YgY3VycmVudCB0aW1lXG4gIC8vIHRvIGF2b2lkIHRoZSBwb3NzaWJpbGl0eSBvZiByZW1vdmluZyB0aGUgR09QIGN1cnJlbnRseSBiZWluZyBwbGF5ZWQgd2hpY2ggY291bGRcbiAgLy8gY2F1c2UgcGxheWJhY2sgc3RhbGxzLlxuICByZXR1cm4gTWF0aC5taW4ocmVtb3ZlVG9UaW1lLCBjdXJyZW50VGltZSAtIHRhcmdldER1cmF0aW9uKTtcbn07XG5cbmV4cG9ydHMuc2FmZUJhY2tCdWZmZXJUcmltVGltZSA9IHNhZmVCYWNrQnVmZmVyVHJpbVRpbWU7XG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IG1hbmFnZXMgc2VnbWVudCBsb2FkaW5nIGFuZCBhcHBlbmRpbmcuXG4gKlxuICogQGNsYXNzIFNlZ21lbnRMb2FkZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHJlcXVpcmVkIGFuZCBvcHRpb25hbCBvcHRpb25zXG4gKiBAZXh0ZW5kcyB2aWRlb2pzLkV2ZW50VGFyZ2V0XG4gKi9cblxudmFyIFNlZ21lbnRMb2FkZXIgPSAoZnVuY3Rpb24gKF92aWRlb2pzJEV2ZW50VGFyZ2V0KSB7XG4gIF9pbmhlcml0cyhTZWdtZW50TG9hZGVyLCBfdmlkZW9qcyRFdmVudFRhcmdldCk7XG5cbiAgZnVuY3Rpb24gU2VnbWVudExvYWRlcihzZXR0aW5ncykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlZ21lbnRMb2FkZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2VnbWVudExvYWRlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIC8vIGNoZWNrIHByZS1jb25kaXRpb25zXG4gICAgaWYgKCFzZXR0aW5ncykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5pdGlhbGl6YXRpb24gc2V0dGluZ3MgYXJlIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuY3VycmVudFRpbWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vIGN1cnJlbnRUaW1lIGdldHRlciBzcGVjaWZpZWQnKTtcbiAgICB9XG4gICAgaWYgKCFzZXR0aW5ncy5tZWRpYVNvdXJjZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm8gTWVkaWFTb3VyY2Ugc3BlY2lmaWVkJyk7XG4gICAgfVxuICAgIC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG4gICAgdGhpcy5zdGF0ZSA9ICdJTklUJztcbiAgICB0aGlzLmJhbmR3aWR0aCA9IHNldHRpbmdzLmJhbmR3aWR0aDtcbiAgICB0aGlzLnRocm91Z2hwdXQgPSB7IHJhdGU6IDAsIGNvdW50OiAwIH07XG4gICAgdGhpcy5yb3VuZFRyaXAgPSBOYU47XG4gICAgdGhpcy5yZXNldFN0YXRzXygpO1xuICAgIHRoaXMubWVkaWFJbmRleCA9IG51bGw7XG5cbiAgICAvLyBwcml2YXRlIHNldHRpbmdzXG4gICAgdGhpcy5oYXNQbGF5ZWRfID0gc2V0dGluZ3MuaGFzUGxheWVkO1xuICAgIHRoaXMuY3VycmVudFRpbWVfID0gc2V0dGluZ3MuY3VycmVudFRpbWU7XG4gICAgdGhpcy5zZWVrYWJsZV8gPSBzZXR0aW5ncy5zZWVrYWJsZTtcbiAgICB0aGlzLnNlZWtpbmdfID0gc2V0dGluZ3Muc2Vla2luZztcbiAgICB0aGlzLmR1cmF0aW9uXyA9IHNldHRpbmdzLmR1cmF0aW9uO1xuICAgIHRoaXMubWVkaWFTb3VyY2VfID0gc2V0dGluZ3MubWVkaWFTb3VyY2U7XG4gICAgdGhpcy5obHNfID0gc2V0dGluZ3MuaGxzO1xuICAgIHRoaXMubG9hZGVyVHlwZV8gPSBzZXR0aW5ncy5sb2FkZXJUeXBlO1xuICAgIHRoaXMuc3RhcnRpbmdNZWRpYV8gPSB2b2lkIDA7XG4gICAgdGhpcy5zZWdtZW50TWV0YWRhdGFUcmFja18gPSBzZXR0aW5ncy5zZWdtZW50TWV0YWRhdGFUcmFjaztcbiAgICB0aGlzLmdvYWxCdWZmZXJMZW5ndGhfID0gc2V0dGluZ3MuZ29hbEJ1ZmZlckxlbmd0aDtcblxuICAgIC8vIHByaXZhdGUgaW5zdGFuY2UgdmFyaWFibGVzXG4gICAgdGhpcy5jaGVja0J1ZmZlclRpbWVvdXRfID0gbnVsbDtcbiAgICB0aGlzLmVycm9yXyA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJlbnRUaW1lbGluZV8gPSAtMTtcbiAgICB0aGlzLnBlbmRpbmdTZWdtZW50XyA9IG51bGw7XG4gICAgdGhpcy5taW1lVHlwZV8gPSBudWxsO1xuICAgIHRoaXMuc291cmNlVXBkYXRlcl8gPSBudWxsO1xuICAgIHRoaXMueGhyT3B0aW9uc18gPSBudWxsO1xuXG4gICAgLy8gRnJhZ21lbnRlZCBtcDQgcGxheWJhY2tcbiAgICB0aGlzLmFjdGl2ZUluaXRTZWdtZW50SWRfID0gbnVsbDtcbiAgICB0aGlzLmluaXRTZWdtZW50c18gPSB7fTtcblxuICAgIHRoaXMuZGVjcnlwdGVyXyA9IHNldHRpbmdzLmRlY3J5cHRlcjtcblxuICAgIC8vIE1hbmFnZXMgdGhlIHRyYWNraW5nIGFuZCBnZW5lcmF0aW9uIG9mIHN5bmMtcG9pbnRzLCBtYXBwaW5nc1xuICAgIC8vIGJldHdlZW4gYSB0aW1lIGluIHRoZSBkaXNwbGF5IHRpbWUgYW5kIGEgc2VnbWVudCBpbmRleCB3aXRoaW5cbiAgICAvLyBhIHBsYXlsaXN0XG4gICAgdGhpcy5zeW5jQ29udHJvbGxlcl8gPSBzZXR0aW5ncy5zeW5jQ29udHJvbGxlcjtcbiAgICB0aGlzLnN5bmNQb2ludF8gPSB7XG4gICAgICBzZWdtZW50SW5kZXg6IDAsXG4gICAgICB0aW1lOiAwXG4gICAgfTtcblxuICAgIHRoaXMuc3luY0NvbnRyb2xsZXJfLm9uKCdzeW5jaW5mb3VwZGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy50cmlnZ2VyKCdzeW5jaW5mb3VwZGF0ZScpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tZWRpYVNvdXJjZV8uYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5lbmRlZF8gPSBmYWxzZTtcbiAgICB9KTtcblxuICAgIC8vIC4uLmZvciBkZXRlcm1pbmluZyB0aGUgZmV0Y2ggbG9jYXRpb25cbiAgICB0aGlzLmZldGNoQXRCdWZmZXJfID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgdGhpcy5sb2dnZXJfID0gX3ZpZGVvSnMyWydkZWZhdWx0J10ubG9nLmJpbmQoX3ZpZGVvSnMyWydkZWZhdWx0J10sICdzZWdtZW50LWxvYWRlcicsIHRoaXMubG9hZGVyVHlwZV8sICctPicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiByZXNldCBhbGwgb2Ygb3VyIG1lZGlhIHN0YXRzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhTZWdtZW50TG9hZGVyLCBbe1xuICAgIGtleTogJ3Jlc2V0U3RhdHNfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRTdGF0c18oKSB7XG4gICAgICB0aGlzLm1lZGlhQnl0ZXNUcmFuc2ZlcnJlZCA9IDA7XG4gICAgICB0aGlzLm1lZGlhUmVxdWVzdHMgPSAwO1xuICAgICAgdGhpcy5tZWRpYVJlcXVlc3RzQWJvcnRlZCA9IDA7XG4gICAgICB0aGlzLm1lZGlhUmVxdWVzdHNUaW1lZG91dCA9IDA7XG4gICAgICB0aGlzLm1lZGlhUmVxdWVzdHNFcnJvcmVkID0gMDtcbiAgICAgIHRoaXMubWVkaWFUcmFuc2ZlckR1cmF0aW9uID0gMDtcbiAgICAgIHRoaXMubWVkaWFTZWNvbmRzTG9hZGVkID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkaXNwb3NlIG9mIHRoZSBTZWdtZW50TG9hZGVyIGFuZCByZXNldCB0byB0aGUgZGVmYXVsdCBzdGF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZGlzcG9zZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICB0aGlzLnN0YXRlID0gJ0RJU1BPU0VEJztcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIHRoaXMuYWJvcnRfKCk7XG4gICAgICBpZiAodGhpcy5zb3VyY2VVcGRhdGVyXykge1xuICAgICAgICB0aGlzLnNvdXJjZVVwZGF0ZXJfLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXRTdGF0c18oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhYm9ydCBhbnl0aGluZyB0aGF0IGlzIGN1cnJlbnRseSBkb2luZyBvbiB3aXRoIHRoZSBTZWdtZW50TG9hZGVyXG4gICAgICogYW5kIHJlc2V0IHRvIGEgZGVmYXVsdCBzdGF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnYWJvcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnV0FJVElORycpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1NlZ21lbnRfKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nU2VnbWVudF8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hYm9ydF8oKTtcblxuICAgICAgLy8gV2UgYWJvcnRlZCB0aGUgcmVxdWVzdHMgd2Ugd2VyZSB3YWl0aW5nIG9uLCBzbyByZXNldCB0aGUgbG9hZGVyJ3Mgc3RhdGUgdG8gUkVBRFlcbiAgICAgIC8vIHNpbmNlIHdlIGFyZSBubyBsb25nZXIgXCJ3YWl0aW5nXCIgb24gYW55IHJlcXVlc3RzLiBYSFIgY2FsbGJhY2sgaXMgbm90IGFsd2F5cyBydW5cbiAgICAgIC8vIHdoZW4gdGhlIHJlcXVlc3QgaXMgYWJvcnRlZC4gVGhpcyB3aWxsIHByZXZlbnQgdGhlIGxvYWRlciBmcm9tIGJlaW5nIHN0dWNrIGluIHRoZVxuICAgICAgLy8gV0FJVElORyBzdGF0ZSBpbmRlZmluaXRlbHkuXG4gICAgICB0aGlzLnN0YXRlID0gJ1JFQURZJztcblxuICAgICAgLy8gZG9uJ3Qgd2FpdCBmb3IgYnVmZmVyIGNoZWNrIHRpbWVvdXRzIHRvIGJlZ2luIGZldGNoaW5nIHRoZVxuICAgICAgLy8gbmV4dCBzZWdtZW50XG4gICAgICBpZiAoIXRoaXMucGF1c2VkKCkpIHtcbiAgICAgICAgdGhpcy5tb25pdG9yQnVmZmVyXygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFib3J0IGFsbCBwZW5kaW5nIHhociByZXF1ZXN0cyBhbmQgbnVsbCBhbnkgcGVuZGluZyBzZWdlbWVudHNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdhYm9ydF8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYm9ydF8oKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nU2VnbWVudF8pIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nU2VnbWVudF8uYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgfVxuXG4gICAgICAvLyBjbGVhciBvdXQgdGhlIHNlZ21lbnQgYmVpbmcgcHJvY2Vzc2VkXG4gICAgICB0aGlzLnBlbmRpbmdTZWdtZW50XyA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IGFuIGVycm9yIG9uIHRoZSBzZWdtZW50IGxvYWRlciBhbmQgbnVsbCBvdXQgYW55IHBlbmRpbmcgc2VnZW1lbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciB0aGUgZXJyb3IgdG8gc2V0IG9uIHRoZSBTZWdtZW50TG9hZGVyXG4gICAgICogQHJldHVybiB7RXJyb3J9IHRoZSBlcnJvciB0aGF0IHdhcyBzZXQgb3IgdGhhdCBpcyBjdXJyZW50bHkgc2V0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdlcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVycm9yKF9lcnJvcikge1xuICAgICAgaWYgKHR5cGVvZiBfZXJyb3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuZXJyb3JfID0gX2Vycm9yO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBlbmRpbmdTZWdtZW50XyA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5lcnJvcl87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5kT2ZTdHJlYW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRPZlN0cmVhbSgpIHtcbiAgICAgIHRoaXMuZW5kZWRfID0gdHJ1ZTtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIHRoaXMudHJpZ2dlcignZW5kZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2ggdGltZSByYW5nZXMgYXJlIGJ1ZmZlcmVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gICAgICogICAgICAgICBUaW1lUmFuZ2Ugb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2J1ZmZlcmVkXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1ZmZlcmVkXygpIHtcbiAgICAgIGlmICghdGhpcy5zb3VyY2VVcGRhdGVyXykge1xuICAgICAgICByZXR1cm4gX3ZpZGVvSnMyWydkZWZhdWx0J10uY3JlYXRlVGltZVJhbmdlcygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VVcGRhdGVyXy5idWZmZXJlZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYW5kIHNldHMgaW5pdCBzZWdtZW50IGZvciB0aGUgcHJvdmlkZWQgbWFwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwXG4gICAgICogICAgICAgIFRoZSBtYXAgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5pdCBzZWdtZW50IHRvIGdldCBvciBzZXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBzZXRcbiAgICAgKiAgICAgICAgSWYgdHJ1ZSwgdGhlIGluaXQgc2VnbWVudCBmb3IgdGhlIHByb3ZpZGVkIG1hcCBzaG91bGQgYmUgc2F2ZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICogICAgICAgICBtYXAgb2JqZWN0IGZvciBkZXNpcmVkIGluaXQgc2VnbWVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaW5pdFNlZ21lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0U2VnbWVudChtYXApIHtcbiAgICAgIHZhciBzZXQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZCA9ICgwLCBfYmluVXRpbHMuaW5pdFNlZ21lbnRJZCkobWFwKTtcbiAgICAgIHZhciBzdG9yZWRNYXAgPSB0aGlzLmluaXRTZWdtZW50c19baWRdO1xuXG4gICAgICBpZiAoc2V0ICYmICFzdG9yZWRNYXAgJiYgbWFwLmJ5dGVzKSB7XG4gICAgICAgIHRoaXMuaW5pdFNlZ21lbnRzX1tpZF0gPSBzdG9yZWRNYXAgPSB7XG4gICAgICAgICAgcmVzb2x2ZWRVcmk6IG1hcC5yZXNvbHZlZFVyaSxcbiAgICAgICAgICBieXRlcmFuZ2U6IG1hcC5ieXRlcmFuZ2UsXG4gICAgICAgICAgYnl0ZXM6IG1hcC5ieXRlc1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RvcmVkTWFwIHx8IG1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYWxsIGNvbmZpZ3VyYXRpb24gcmVxdWlyZWQgZm9yIGxvYWRpbmcgaXMgcHJlc2VudCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgYWxsIGNvbmZpZ3VyYXRpb24gaXMgcmVhZHkgZm9yIGxvYWRpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY291bGRCZWdpbkxvYWRpbmdfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY291bGRCZWdpbkxvYWRpbmdfKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGxheWxpc3RfICYmIChcbiAgICAgIC8vIHRoZSBzb3VyY2UgdXBkYXRlciBpcyBjcmVhdGVkIHdoZW4gaW5pdF8gaXMgY2FsbGVkLCBzbyBlaXRoZXIgaGF2aW5nIGFcbiAgICAgIC8vIHNvdXJjZSB1cGRhdGVyIG9yIGJlaW5nIGluIHRoZSBJTklUIHN0YXRlIHdpdGggYSBtaW1lVHlwZSBpcyBlbm91Z2hcbiAgICAgIC8vIHRvIHNheSB3ZSBoYXZlIGFsbCB0aGUgbmVlZGVkIGNvbmZpZ3VyYXRpb24gdG8gc3RhcnQgbG9hZGluZy5cbiAgICAgIHRoaXMuc291cmNlVXBkYXRlcl8gfHwgdGhpcy5taW1lVHlwZV8gJiYgdGhpcy5zdGF0ZSA9PT0gJ0lOSVQnKSAmJiAhdGhpcy5wYXVzZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBsb2FkIGEgcGxheWxpc3QgYW5kIHN0YXJ0IHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnbG9hZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICAvLyB1bi1wYXVzZVxuICAgICAgdGhpcy5tb25pdG9yQnVmZmVyXygpO1xuXG4gICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIGEgcGxheWxpc3QgeWV0LCBrZWVwIHdhaXRpbmcgZm9yIG9uZSB0byBiZVxuICAgICAgLy8gc3BlY2lmaWVkXG4gICAgICBpZiAoIXRoaXMucGxheWxpc3RfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdCBwbGFjZSBmb3IgdGhpc1xuICAgICAgdGhpcy5zeW5jQ29udHJvbGxlcl8uc2V0RGF0ZVRpbWVNYXBwaW5nKHRoaXMucGxheWxpc3RfKTtcblxuICAgICAgLy8gaWYgYWxsIHRoZSBjb25maWd1cmF0aW9uIGlzIHJlYWR5LCBpbml0aWFsaXplIGFuZCBiZWdpbiBsb2FkaW5nXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0lOSVQnICYmIHRoaXMuY291bGRCZWdpbkxvYWRpbmdfKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdF8oKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBwcm9jZXNzaW5nIGEgc2VnbWVudCBhbHJlYWR5LCBkb24ndFxuICAgICAgLy8ga2ljayBvZmYgYW4gYWRkaXRpb25hbCBzZWdtZW50IHJlcXVlc3RcbiAgICAgIGlmICghdGhpcy5jb3VsZEJlZ2luTG9hZGluZ18oKSB8fCB0aGlzLnN0YXRlICE9PSAnUkVBRFknICYmIHRoaXMuc3RhdGUgIT09ICdJTklUJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhdGUgPSAnUkVBRFknO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uY2UgYWxsIHRoZSBzdGFydGluZyBwYXJhbWV0ZXJzIGhhdmUgYmVlbiBzcGVjaWZpZWQsIGJlZ2luXG4gICAgICogb3BlcmF0aW9uLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBpbnZva2VkIGZyb20gdGhlIElOSVRcbiAgICAgKiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdpbml0XycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRfKCkge1xuICAgICAgdGhpcy5zdGF0ZSA9ICdSRUFEWSc7XG4gICAgICB0aGlzLnNvdXJjZVVwZGF0ZXJfID0gbmV3IF9zb3VyY2VVcGRhdGVyMlsnZGVmYXVsdCddKHRoaXMubWVkaWFTb3VyY2VfLCB0aGlzLm1pbWVUeXBlXyk7XG4gICAgICB0aGlzLnJlc2V0RXZlcnl0aGluZygpO1xuICAgICAgcmV0dXJuIHRoaXMubW9uaXRvckJ1ZmZlcl8oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgYSBwbGF5bGlzdCBvbiB0aGUgc2VnbWVudCBsb2FkZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGxheWxpc3RMb2FkZXJ9IG1lZGlhIHRoZSBwbGF5bGlzdCB0byBzZXQgb24gdGhlIHNlZ21lbnQgbG9hZGVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdwbGF5bGlzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXlsaXN0KG5ld1BsYXlsaXN0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgICBpZiAoIW5ld1BsYXlsaXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9sZFBsYXlsaXN0ID0gdGhpcy5wbGF5bGlzdF87XG4gICAgICB2YXIgc2VnbWVudEluZm8gPSB0aGlzLnBlbmRpbmdTZWdtZW50XztcblxuICAgICAgdGhpcy5wbGF5bGlzdF8gPSBuZXdQbGF5bGlzdDtcbiAgICAgIHRoaXMueGhyT3B0aW9uc18gPSBvcHRpb25zO1xuXG4gICAgICAvLyB3aGVuIHdlIGhhdmVuJ3Qgc3RhcnRlZCBwbGF5aW5nIHlldCwgdGhlIHN0YXJ0IG9mIGEgbGl2ZSBwbGF5bGlzdFxuICAgICAgLy8gaXMgYWx3YXlzIG91ciB6ZXJvLXRpbWUgc28gZm9yY2UgYSBzeW5jIHVwZGF0ZSBlYWNoIHRpbWUgdGhlIHBsYXlsaXN0XG4gICAgICAvLyBpcyByZWZyZXNoZWQgZnJvbSB0aGUgc2VydmVyXG4gICAgICBpZiAoIXRoaXMuaGFzUGxheWVkXygpKSB7XG4gICAgICAgIG5ld1BsYXlsaXN0LnN5bmNJbmZvID0ge1xuICAgICAgICAgIG1lZGlhU2VxdWVuY2U6IG5ld1BsYXlsaXN0Lm1lZGlhU2VxdWVuY2UsXG4gICAgICAgICAgdGltZTogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBpbiBWT0QsIHRoaXMgaXMgYWx3YXlzIGEgcmVuZGl0aW9uIHN3aXRjaCAob3Igd2UgdXBkYXRlZCBvdXIgc3luY0luZm8gYWJvdmUpXG4gICAgICAvLyBpbiBMSVZFLCB3ZSBhbHdheXMgd2FudCB0byB1cGRhdGUgd2l0aCBuZXcgcGxheWxpc3RzIChpbmNsdWRpbmcgcmVmcmVzaGVzKVxuICAgICAgdGhpcy50cmlnZ2VyKCdzeW5jaW5mb3VwZGF0ZScpO1xuXG4gICAgICAvLyBpZiB3ZSB3ZXJlIHVucGF1c2VkIGJ1dCB3YWl0aW5nIGZvciBhIHBsYXlsaXN0LCBzdGFydFxuICAgICAgLy8gYnVmZmVyaW5nIG5vd1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdJTklUJyAmJiB0aGlzLmNvdWxkQmVnaW5Mb2FkaW5nXygpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXRfKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghb2xkUGxheWxpc3QgfHwgb2xkUGxheWxpc3QudXJpICE9PSBuZXdQbGF5bGlzdC51cmkpIHtcbiAgICAgICAgaWYgKHRoaXMubWVkaWFJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHdlIG11c3QgXCJyZXN5bmNcIiB0aGUgc2VnbWVudCBsb2FkZXIgd2hlbiB3ZSBzd2l0Y2ggcmVuZGl0aW9ucyBhbmRcbiAgICAgICAgICAvLyB0aGUgc2VnbWVudCBsb2FkZXIgaXMgYWxyZWFkeSBzeW5jZWQgdG8gdGhlIHByZXZpb3VzIHJlbmRpdGlvblxuICAgICAgICAgIHRoaXMucmVzeW5jTG9hZGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgcmVzdCBvZiB0aGlzIGZ1bmN0aW9uIGRlcGVuZHMgb24gYG9sZFBsYXlsaXN0YCBiZWluZyBkZWZpbmVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgcmVsb2FkZWQgdGhlIHNhbWUgcGxheWxpc3Qgc28gd2UgYXJlIGluIGEgbGl2ZSBzY2VuYXJpb1xuICAgICAgLy8gYW5kIHdlIHdpbGwgbGlrZWx5IG5lZWQgdG8gYWRqdXN0IHRoZSBtZWRpYUluZGV4XG4gICAgICB2YXIgbWVkaWFTZXF1ZW5jZURpZmYgPSBuZXdQbGF5bGlzdC5tZWRpYVNlcXVlbmNlIC0gb2xkUGxheWxpc3QubWVkaWFTZXF1ZW5jZTtcblxuICAgICAgdGhpcy5sb2dnZXJfKCdtZWRpYVNlcXVlbmNlRGlmZicsIG1lZGlhU2VxdWVuY2VEaWZmKTtcblxuICAgICAgLy8gdXBkYXRlIHRoZSBtZWRpYUluZGV4IG9uIHRoZSBTZWdtZW50TG9hZGVyXG4gICAgICAvLyB0aGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHdlIGNhbiBhYm9ydCBhIHJlcXVlc3QgYW5kIHRoaXMgdmFsdWUgbXVzdCBiZVxuICAgICAgLy8gZXF1YWwgdG8gdGhlIGxhc3QgYXBwZW5kZWQgbWVkaWFJbmRleFxuICAgICAgaWYgKHRoaXMubWVkaWFJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLm1lZGlhSW5kZXggLT0gbWVkaWFTZXF1ZW5jZURpZmY7XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgbWVkaWFJbmRleCBvbiB0aGUgU2VnbWVudEluZm8gb2JqZWN0XG4gICAgICAvLyB0aGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHdlIHdpbGwgdXBkYXRlIHRoaXMubWVkaWFJbmRleCB3aXRoIHRoaXMgdmFsdWVcbiAgICAgIC8vIGluIGBoYW5kbGVVcGRhdGVFbmRfYCBhZnRlciB0aGUgc2VnbWVudCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgYXBwZW5kZWRcbiAgICAgIGlmIChzZWdtZW50SW5mbykge1xuICAgICAgICBzZWdtZW50SW5mby5tZWRpYUluZGV4IC09IG1lZGlhU2VxdWVuY2VEaWZmO1xuXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSByZWZlcmVuY2VkIHNlZ21lbnQgc28gdGhhdCB0aW1pbmcgaW5mb3JtYXRpb24gaXNcbiAgICAgICAgLy8gc2F2ZWQgZm9yIHRoZSBuZXcgcGxheWxpc3QncyBzZWdtZW50LCBob3dldmVyLCBpZiB0aGUgc2VnbWVudCBmZWxsIG9mZiB0aGVcbiAgICAgICAgLy8gcGxheWxpc3QsIHdlIGNhbiBsZWF2ZSB0aGUgb2xkIHJlZmVyZW5jZSBhbmQganVzdCBsb3NlIHRoZSB0aW1pbmcgaW5mb1xuICAgICAgICBpZiAoc2VnbWVudEluZm8ubWVkaWFJbmRleCA+PSAwKSB7XG4gICAgICAgICAgc2VnbWVudEluZm8uc2VnbWVudCA9IG5ld1BsYXlsaXN0LnNlZ21lbnRzW3NlZ21lbnRJbmZvLm1lZGlhSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3luY0NvbnRyb2xsZXJfLnNhdmVFeHBpcmVkU2VnbWVudEluZm8ob2xkUGxheWxpc3QsIG5ld1BsYXlsaXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50IHRoZSBsb2FkZXIgZnJvbSBmZXRjaGluZyBhZGRpdGlvbmFsIHNlZ21lbnRzLiBJZiB0aGVyZVxuICAgICAqIGlzIGEgc2VnbWVudCByZXF1ZXN0IG91dHN0YW5kaW5nLCBpdCB3aWxsIGZpbmlzaCBwcm9jZXNzaW5nXG4gICAgICogYmVmb3JlIHRoZSBsb2FkZXIgaGFsdHMuIEEgc2VnbWVudCBsb2FkZXIgY2FuIGJlIHVucGF1c2VkIGJ5XG4gICAgICogY2FsbGluZyBsb2FkKCkuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdwYXVzZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgaWYgKHRoaXMuY2hlY2tCdWZmZXJUaW1lb3V0Xykge1xuICAgICAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLmNsZWFyVGltZW91dCh0aGlzLmNoZWNrQnVmZmVyVGltZW91dF8pO1xuXG4gICAgICAgIHRoaXMuY2hlY2tCdWZmZXJUaW1lb3V0XyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBzZWdtZW50IGxvYWRlciBpcyBmZXRjaGluZyBhZGRpdGlvbmFsXG4gICAgICogc2VnbWVudHMgd2hlbiBnaXZlbiB0aGUgb3Bwb3J0dW5pdHkuIFRoaXMgcHJvcGVydHkgY2FuIGJlXG4gICAgICogbW9kaWZpZWQgdGhyb3VnaCBjYWxscyB0byBwYXVzZSgpIGFuZCBsb2FkKCkuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdwYXVzZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXVzZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGVja0J1ZmZlclRpbWVvdXRfID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZS9zZXQgdGhlIGZvbGxvd2luZyBtaW1ldHlwZSBvbiB0aGUgU291cmNlQnVmZmVyIHRocm91Z2ggYVxuICAgICAqIFNvdXJjZVVwZGF0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZSB0aGUgbWltZSB0eXBlIHN0cmluZyB0byB1c2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ21pbWVUeXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWltZVR5cGUoX21pbWVUeXBlKSB7XG4gICAgICBpZiAodGhpcy5taW1lVHlwZV8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1pbWVUeXBlXyA9IF9taW1lVHlwZTtcbiAgICAgIC8vIGlmIHdlIHdlcmUgdW5wYXVzZWQgYnV0IHdhaXRpbmcgZm9yIGEgc291cmNlVXBkYXRlciwgc3RhcnRcbiAgICAgIC8vIGJ1ZmZlcmluZyBub3dcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnSU5JVCcgJiYgdGhpcy5jb3VsZEJlZ2luTG9hZGluZ18oKSkge1xuICAgICAgICB0aGlzLmluaXRfKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFsbCB0aGUgYnVmZmVyZWQgZGF0YSBhbmQgcmVzZXQgdGhlIFNlZ21lbnRMb2FkZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0RXZlcnl0aGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0RXZlcnl0aGluZygpIHtcbiAgICAgIHRoaXMuZW5kZWRfID0gZmFsc2U7XG4gICAgICB0aGlzLnJlc2V0TG9hZGVyKCk7XG4gICAgICB0aGlzLnJlbW92ZSgwLCB0aGlzLmR1cmF0aW9uXygpKTtcbiAgICAgIHRoaXMudHJpZ2dlcigncmVzZXRldmVyeXRoaW5nJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yY2UgdGhlIFNlZ21lbnRMb2FkZXIgdG8gcmVzeW5jIGFuZCBzdGFydCBsb2FkaW5nIGFyb3VuZCB0aGUgY3VycmVudFRpbWUgaW5zdGVhZFxuICAgICAqIG9mIHN0YXJ0aW5nIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICAgICAqXG4gICAgICogVXNlZnVsIGZvciBmYXN0IHF1YWxpdHkgY2hhbmdlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVzZXRMb2FkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldExvYWRlcigpIHtcbiAgICAgIHRoaXMuZmV0Y2hBdEJ1ZmZlcl8gPSBmYWxzZTtcbiAgICAgIHRoaXMucmVzeW5jTG9hZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yY2UgdGhlIFNlZ21lbnRMb2FkZXIgdG8gcmVzdGFydCBzeW5jaHJvbml6YXRpb24gYW5kIG1ha2UgYSBjb25zZXJ2YXRpdmUgZ3Vlc3NcbiAgICAgKiBiZWZvcmUgcmV0dXJuaW5nIHRvIHRoZSBzaW1wbGUgd2Fsay1mb3J3YXJkIG1ldGhvZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVzeW5jTG9hZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzeW5jTG9hZGVyKCkge1xuICAgICAgdGhpcy5tZWRpYUluZGV4ID0gbnVsbDtcbiAgICAgIHRoaXMuc3luY1BvaW50XyA9IG51bGw7XG4gICAgICB0aGlzLmFib3J0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFueSBkYXRhIGluIHRoZSBzb3VyY2UgYnVmZmVyIGJldHdlZW4gc3RhcnQgYW5kIGVuZCB0aW1lc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCAtIHRoZSBzdGFydCB0aW1lIG9mIHRoZSByZWdpb24gdG8gcmVtb3ZlIGZyb20gdGhlIGJ1ZmZlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgLSB0aGUgZW5kIHRpbWUgb2YgdGhlIHJlZ2lvbiB0byByZW1vdmUgZnJvbSB0aGUgYnVmZmVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKHRoaXMuc291cmNlVXBkYXRlcl8pIHtcbiAgICAgICAgdGhpcy5zb3VyY2VVcGRhdGVyXy5yZW1vdmUoc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICAoMCwgX3ZpZGVvanNDb250cmliTWVkaWFTb3VyY2VzRXM1UmVtb3ZlQ3Vlc0Zyb21UcmFja0pzMlsnZGVmYXVsdCddKShzdGFydCwgZW5kLCB0aGlzLnNlZ21lbnRNZXRhZGF0YVRyYWNrXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogKHJlLSlzY2hlZHVsZSBtb25pdG9yQnVmZmVyVGlja18gdG8gcnVuIGFzIHNvb24gYXMgcG9zc2libGVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdtb25pdG9yQnVmZmVyXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vbml0b3JCdWZmZXJfKCkge1xuICAgICAgaWYgKHRoaXMuY2hlY2tCdWZmZXJUaW1lb3V0Xykge1xuICAgICAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLmNsZWFyVGltZW91dCh0aGlzLmNoZWNrQnVmZmVyVGltZW91dF8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoZWNrQnVmZmVyVGltZW91dF8gPSBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnNldFRpbWVvdXQodGhpcy5tb25pdG9yQnVmZmVyVGlja18uYmluZCh0aGlzKSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXMgbG9uZyBhcyB0aGUgU2VnbWVudExvYWRlciBpcyBpbiB0aGUgUkVBRFkgc3RhdGUsIHBlcmlvZGljYWxseVxuICAgICAqIGludm9rZSBmaWxsQnVmZmVyXygpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ21vbml0b3JCdWZmZXJUaWNrXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vbml0b3JCdWZmZXJUaWNrXygpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnUkVBRFknKSB7XG4gICAgICAgIHRoaXMuZmlsbEJ1ZmZlcl8oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2hlY2tCdWZmZXJUaW1lb3V0Xykge1xuICAgICAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLmNsZWFyVGltZW91dCh0aGlzLmNoZWNrQnVmZmVyVGltZW91dF8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoZWNrQnVmZmVyVGltZW91dF8gPSBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnNldFRpbWVvdXQodGhpcy5tb25pdG9yQnVmZmVyVGlja18uYmluZCh0aGlzKSwgQ0hFQ0tfQlVGRkVSX0RFTEFZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmaWxsIHRoZSBidWZmZXIgd2l0aCBzZWdlbWVudHMgdW5sZXNzIHRoZSBzb3VyY2VCdWZmZXJzIGFyZVxuICAgICAqIGN1cnJlbnRseSB1cGRhdGluZ1xuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBldmVyIGJlIGNhbGxlZCBieSBtb25pdG9yQnVmZmVyX1xuICAgICAqIGFuZCBuZXZlciBkaXJlY3RseVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2ZpbGxCdWZmZXJfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsbEJ1ZmZlcl8oKSB7XG4gICAgICBpZiAodGhpcy5zb3VyY2VVcGRhdGVyXy51cGRhdGluZygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnN5bmNQb2ludF8pIHtcbiAgICAgICAgdGhpcy5zeW5jUG9pbnRfID0gdGhpcy5zeW5jQ29udHJvbGxlcl8uZ2V0U3luY1BvaW50KHRoaXMucGxheWxpc3RfLCB0aGlzLmR1cmF0aW9uXygpLCB0aGlzLmN1cnJlbnRUaW1lbGluZV8sIHRoaXMuY3VycmVudFRpbWVfKCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZWUgaWYgd2UgbmVlZCB0byBiZWdpbiBsb2FkaW5nIGltbWVkaWF0ZWx5XG4gICAgICB2YXIgc2VnbWVudEluZm8gPSB0aGlzLmNoZWNrQnVmZmVyXyh0aGlzLmJ1ZmZlcmVkXygpLCB0aGlzLnBsYXlsaXN0XywgdGhpcy5tZWRpYUluZGV4LCB0aGlzLmhhc1BsYXllZF8oKSwgdGhpcy5jdXJyZW50VGltZV8oKSwgdGhpcy5zeW5jUG9pbnRfKTtcblxuICAgICAgaWYgKCFzZWdtZW50SW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0VuZE9mU3RyZWFtID0gZGV0ZWN0RW5kT2ZTdHJlYW0odGhpcy5wbGF5bGlzdF8sIHRoaXMubWVkaWFTb3VyY2VfLCBzZWdtZW50SW5mby5tZWRpYUluZGV4KTtcblxuICAgICAgaWYgKGlzRW5kT2ZTdHJlYW0pIHtcbiAgICAgICAgdGhpcy5lbmRPZlN0cmVhbSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWdtZW50SW5mby5tZWRpYUluZGV4ID09PSB0aGlzLnBsYXlsaXN0Xy5zZWdtZW50cy5sZW5ndGggLSAxICYmIHRoaXMubWVkaWFTb3VyY2VfLnJlYWR5U3RhdGUgPT09ICdlbmRlZCcgJiYgIXRoaXMuc2Vla2luZ18oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIHdpbGwgbmVlZCB0byBjaGFuZ2UgdGltZXN0YW1wT2Zmc2V0IG9mIHRoZSBzb3VyY2VCdWZmZXIgaWYgZWl0aGVyIG9mXG4gICAgICAvLyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4gICAgICAvLyAtIFRoZSBzZWdtZW50LnRpbWVsaW5lICE9PSB0aGlzLmN1cnJlbnRUaW1lbGluZVxuICAgICAgLy8gICAod2UgYXJlIGNyb3NzaW5nIGEgZGlzY29udGludWl0eSBzb21laG93KVxuICAgICAgLy8gLSBUaGUgXCJ0aW1lc3RhbXBPZmZzZXRcIiBmb3IgdGhlIHN0YXJ0IG9mIHRoaXMgc2VnbWVudCBpcyBsZXNzIHRoYW5cbiAgICAgIC8vICAgdGhlIGN1cnJlbnRseSBzZXQgdGltZXN0YW1wT2Zmc2V0XG4gICAgICBpZiAoc2VnbWVudEluZm8udGltZWxpbmUgIT09IHRoaXMuY3VycmVudFRpbWVsaW5lXyB8fCBzZWdtZW50SW5mby5zdGFydE9mU2VnbWVudCAhPT0gbnVsbCAmJiBzZWdtZW50SW5mby5zdGFydE9mU2VnbWVudCA8IHRoaXMuc291cmNlVXBkYXRlcl8udGltZXN0YW1wT2Zmc2V0KCkpIHtcbiAgICAgICAgdGhpcy5zeW5jQ29udHJvbGxlcl8ucmVzZXQoKTtcbiAgICAgICAgc2VnbWVudEluZm8udGltZXN0YW1wT2Zmc2V0ID0gc2VnbWVudEluZm8uc3RhcnRPZlNlZ21lbnQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9hZFNlZ21lbnRfKHNlZ21lbnRJbmZvKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoYXQgc2VnbWVudCByZXF1ZXN0IHNob3VsZCBiZSBtYWRlLCBnaXZlbiBjdXJyZW50IHBsYXliYWNrXG4gICAgICogc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RpbWVSYW5nZXN9IGJ1ZmZlcmVkIC0gdGhlIHN0YXRlIG9mIHRoZSBidWZmZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGxheWxpc3QgLSB0aGUgcGxheWxpc3Qgb2JqZWN0IHRvIGZldGNoIHNlZ21lbnRzIGZyb21cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWVkaWFJbmRleCAtIHRoZSBwcmV2aW91cyBtZWRpYUluZGV4IGZldGNoZWQgb3IgbnVsbFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaGFzUGxheWVkIC0gYSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB3ZSBoYXZlIHBsYXllZCBvciBub3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3VycmVudFRpbWUgLSB0aGUgcGxheWJhY2sgcG9zaXRpb24gaW4gc2Vjb25kc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzeW5jUG9pbnQgLSBhIHNlZ21lbnQgaW5mbyBvYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlXG4gICAgICogQHJldHVybnMge09iamVjdH0gYSBzZWdtZW50IHJlcXVlc3Qgb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBzZWdtZW50IHRvIGxvYWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2NoZWNrQnVmZmVyXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQnVmZmVyXyhidWZmZXJlZCwgcGxheWxpc3QsIG1lZGlhSW5kZXgsIGhhc1BsYXllZCwgY3VycmVudFRpbWUsIHN5bmNQb2ludCkge1xuICAgICAgdmFyIGxhc3RCdWZmZXJlZEVuZCA9IDA7XG4gICAgICB2YXIgc3RhcnRPZlNlZ21lbnQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChidWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgbGFzdEJ1ZmZlcmVkRW5kID0gYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkLmxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYnVmZmVyZWRUaW1lID0gTWF0aC5tYXgoMCwgbGFzdEJ1ZmZlcmVkRW5kIC0gY3VycmVudFRpbWUpO1xuXG4gICAgICBpZiAoIXBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlcmUgaXMgcGxlbnR5IG9mIGNvbnRlbnQgYnVmZmVyZWQsIGFuZCB0aGUgdmlkZW8gaGFzXG4gICAgICAvLyBiZWVuIHBsYXllZCBiZWZvcmUgcmVsYXggZm9yIGF3aGlsZVxuICAgICAgaWYgKGJ1ZmZlcmVkVGltZSA+PSB0aGlzLmdvYWxCdWZmZXJMZW5ndGhfKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSB2aWRlbyBoYXMgbm90IHlldCBwbGF5ZWQgb25jZSwgYW5kIHdlIGFscmVhZHkgaGF2ZVxuICAgICAgLy8gb25lIHNlZ21lbnQgZG93bmxvYWRlZCBkbyBub3RoaW5nXG4gICAgICBpZiAoIWhhc1BsYXllZCAmJiBidWZmZXJlZFRpbWUgPj0gMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2dnZXJfKCdjaGVja0J1ZmZlcl8nLCAnbWVkaWFJbmRleDonLCBtZWRpYUluZGV4LCAnaGFzUGxheWVkOicsIGhhc1BsYXllZCwgJ2N1cnJlbnRUaW1lOicsIGN1cnJlbnRUaW1lLCAnc3luY1BvaW50OicsIHN5bmNQb2ludCwgJ2ZldGNoQXRCdWZmZXI6JywgdGhpcy5mZXRjaEF0QnVmZmVyXywgJ2J1ZmZlcmVkVGltZTonLCBidWZmZXJlZFRpbWUpO1xuXG4gICAgICAvLyBXaGVuIHRoZSBzeW5jUG9pbnQgaXMgbnVsbCwgdGhlcmUgaXMgbm8gd2F5IG9mIGRldGVybWluaW5nIGEgZ29vZFxuICAgICAgLy8gY29uc2VydmF0aXZlIHNlZ21lbnQgaW5kZXggdG8gZmV0Y2ggZnJvbVxuICAgICAgLy8gVGhlIGJlc3QgdGhpbmcgdG8gZG8gaGVyZSBpcyB0byBnZXQgdGhlIGtpbmQgb2Ygc3luYy1wb2ludCBkYXRhIGJ5XG4gICAgICAvLyBtYWtpbmcgYSByZXF1ZXN0XG4gICAgICBpZiAoc3luY1BvaW50ID09PSBudWxsKSB7XG4gICAgICAgIG1lZGlhSW5kZXggPSB0aGlzLmdldFN5bmNTZWdtZW50Q2FuZGlkYXRlXyhwbGF5bGlzdCk7XG4gICAgICAgIHRoaXMubG9nZ2VyXygnZ2V0U3luYycsICdtZWRpYUluZGV4OicsIG1lZGlhSW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVNlZ21lbnRJbmZvXyhwbGF5bGlzdCwgbWVkaWFJbmRleCwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVuZGVyIG5vcm1hbCBwbGF5YmFjayBjb25kaXRpb25zIGZldGNoaW5nIGlzIGEgc2ltcGxlIHdhbGsgZm9yd2FyZFxuICAgICAgaWYgKG1lZGlhSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5sb2dnZXJfKCd3YWxrRm9yd2FyZCcsICdtZWRpYUluZGV4OicsIG1lZGlhSW5kZXggKyAxKTtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBwbGF5bGlzdC5zZWdtZW50c1ttZWRpYUluZGV4XTtcblxuICAgICAgICBpZiAoc2VnbWVudCAmJiBzZWdtZW50LmVuZCkge1xuICAgICAgICAgIHN0YXJ0T2ZTZWdtZW50ID0gc2VnbWVudC5lbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnRPZlNlZ21lbnQgPSBsYXN0QnVmZmVyZWRFbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVTZWdtZW50SW5mb18ocGxheWxpc3QsIG1lZGlhSW5kZXggKyAxLCBzdGFydE9mU2VnbWVudCwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGVyZSBpcyBhIHN5bmMtcG9pbnQgYnV0IHRoZSBsYWNrIG9mIGEgbWVkaWFJbmRleCBpbmRpY2F0ZXMgdGhhdFxuICAgICAgLy8gd2UgbmVlZCB0byBtYWtlIGEgZ29vZCBjb25zZXJ2YXRpdmUgZ3Vlc3MgYWJvdXQgd2hpY2ggc2VnbWVudCB0b1xuICAgICAgLy8gZmV0Y2hcbiAgICAgIGlmICh0aGlzLmZldGNoQXRCdWZmZXJfKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHNlZ21lbnQgY29udGFpbmluZyB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgICAgICAgdmFyIG1lZGlhU291cmNlSW5mbyA9IF9wbGF5bGlzdDJbJ2RlZmF1bHQnXS5nZXRNZWRpYUluZm9Gb3JUaW1lKHBsYXlsaXN0LCBsYXN0QnVmZmVyZWRFbmQsIHN5bmNQb2ludC5zZWdtZW50SW5kZXgsIHN5bmNQb2ludC50aW1lKTtcblxuICAgICAgICBtZWRpYUluZGV4ID0gbWVkaWFTb3VyY2VJbmZvLm1lZGlhSW5kZXg7XG4gICAgICAgIHN0YXJ0T2ZTZWdtZW50ID0gbWVkaWFTb3VyY2VJbmZvLnN0YXJ0VGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHNlZ21lbnQgY29udGFpbmluZyBjdXJyZW50VGltZVxuICAgICAgICB2YXIgbWVkaWFTb3VyY2VJbmZvID0gX3BsYXlsaXN0MlsnZGVmYXVsdCddLmdldE1lZGlhSW5mb0ZvclRpbWUocGxheWxpc3QsIGN1cnJlbnRUaW1lLCBzeW5jUG9pbnQuc2VnbWVudEluZGV4LCBzeW5jUG9pbnQudGltZSk7XG5cbiAgICAgICAgbWVkaWFJbmRleCA9IG1lZGlhU291cmNlSW5mby5tZWRpYUluZGV4O1xuICAgICAgICBzdGFydE9mU2VnbWVudCA9IG1lZGlhU291cmNlSW5mby5zdGFydFRpbWU7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZ2dlcl8oJ2dldE1lZGlhSW5kZXhGb3JUaW1lJywgJ21lZGlhSW5kZXg6JywgbWVkaWFJbmRleCwgJ3N0YXJ0T2ZTZWdtZW50OicsIHN0YXJ0T2ZTZWdtZW50KTtcblxuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVTZWdtZW50SW5mb18ocGxheWxpc3QsIG1lZGlhSW5kZXgsIHN0YXJ0T2ZTZWdtZW50LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlZ21lbnQgbG9hZGVyIGhhcyBubyByZWNvdXJzZSBleGNlcHQgdG8gZmV0Y2ggYSBzZWdtZW50IGluIHRoZVxuICAgICAqIGN1cnJlbnQgcGxheWxpc3QgYW5kIHVzZSB0aGUgaW50ZXJuYWwgdGltZXN0YW1wcyBpbiB0aGF0IHNlZ21lbnQgdG9cbiAgICAgKiBnZW5lcmF0ZSBhIHN5bmNQb2ludC4gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgZ29vZCBjYW5kaWRhdGUgaW5kZXhcbiAgICAgKiBmb3IgdGhhdCBwcm9jZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBsYXlsaXN0IC0gdGhlIHBsYXlsaXN0IG9iamVjdCB0byBsb29rIGZvciBhXG4gICAgICogQHJldHVybnMge051bWJlcn0gQW4gaW5kZXggb2YgYSBzZWdtZW50IGZyb20gdGhlIHBsYXlsaXN0IHRvIGxvYWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2dldFN5bmNTZWdtZW50Q2FuZGlkYXRlXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN5bmNTZWdtZW50Q2FuZGlkYXRlXyhwbGF5bGlzdCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRUaW1lbGluZV8gPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VnbWVudEluZGV4QXJyYXkgPSBwbGF5bGlzdC5zZWdtZW50cy5tYXAoZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0aW1lbGluZTogcy50aW1lbGluZSxcbiAgICAgICAgICBzZWdtZW50SW5kZXg6IGlcbiAgICAgICAgfTtcbiAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gcy50aW1lbGluZSA9PT0gX3RoaXMyLmN1cnJlbnRUaW1lbGluZV87XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNlZ21lbnRJbmRleEFycmF5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc2VnbWVudEluZGV4QXJyYXlbTWF0aC5taW4oc2VnbWVudEluZGV4QXJyYXkubGVuZ3RoIC0gMSwgMSldLnNlZ21lbnRJbmRleDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1hdGgubWF4KHBsYXlsaXN0LnNlZ21lbnRzLmxlbmd0aCAtIDEsIDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dlbmVyYXRlU2VnbWVudEluZm9fJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVTZWdtZW50SW5mb18ocGxheWxpc3QsIG1lZGlhSW5kZXgsIHN0YXJ0T2ZTZWdtZW50LCBpc1N5bmNSZXF1ZXN0KSB7XG4gICAgICBpZiAobWVkaWFJbmRleCA8IDAgfHwgbWVkaWFJbmRleCA+PSBwbGF5bGlzdC5zZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWdtZW50ID0gcGxheWxpc3Quc2VnbWVudHNbbWVkaWFJbmRleF07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3RJZDogJ3NlZ21lbnQtbG9hZGVyLScgKyBNYXRoLnJhbmRvbSgpLFxuICAgICAgICAvLyByZXNvbHZlIHRoZSBzZWdtZW50IFVSTCByZWxhdGl2ZSB0byB0aGUgcGxheWxpc3RcbiAgICAgICAgdXJpOiBzZWdtZW50LnJlc29sdmVkVXJpLFxuICAgICAgICAvLyB0aGUgc2VnbWVudCdzIG1lZGlhSW5kZXggYXQgdGhlIHRpbWUgaXQgd2FzIHJlcXVlc3RlZFxuICAgICAgICBtZWRpYUluZGV4OiBtZWRpYUluZGV4LFxuICAgICAgICAvLyB3aGV0aGVyIG9yIG5vdCB0byB1cGRhdGUgdGhlIFNlZ21lbnRMb2FkZXIncyBzdGF0ZSB3aXRoIHRoaXNcbiAgICAgICAgLy8gc2VnbWVudCdzIG1lZGlhSW5kZXhcbiAgICAgICAgaXNTeW5jUmVxdWVzdDogaXNTeW5jUmVxdWVzdCxcbiAgICAgICAgc3RhcnRPZlNlZ21lbnQ6IHN0YXJ0T2ZTZWdtZW50LFxuICAgICAgICAvLyB0aGUgc2VnbWVudCdzIHBsYXlsaXN0XG4gICAgICAgIHBsYXlsaXN0OiBwbGF5bGlzdCxcbiAgICAgICAgLy8gdW5lbmNyeXB0ZWQgYnl0ZXMgb2YgdGhlIHNlZ21lbnRcbiAgICAgICAgYnl0ZXM6IG51bGwsXG4gICAgICAgIC8vIHdoZW4gYSBrZXkgaXMgZGVmaW5lZCBmb3IgdGhpcyBzZWdtZW50LCB0aGUgZW5jcnlwdGVkIGJ5dGVzXG4gICAgICAgIGVuY3J5cHRlZEJ5dGVzOiBudWxsLFxuICAgICAgICAvLyBUaGUgdGFyZ2V0IHRpbWVzdGFtcE9mZnNldCBmb3IgdGhpcyBzZWdtZW50IHdoZW4gd2UgYXBwZW5kIGl0XG4gICAgICAgIC8vIHRvIHRoZSBzb3VyY2UgYnVmZmVyXG4gICAgICAgIHRpbWVzdGFtcE9mZnNldDogbnVsbCxcbiAgICAgICAgLy8gVGhlIHRpbWVsaW5lIHRoYXQgdGhlIHNlZ21lbnQgaXMgaW5cbiAgICAgICAgdGltZWxpbmU6IHNlZ21lbnQudGltZWxpbmUsXG4gICAgICAgIC8vIFRoZSBleHBlY3RlZCBkdXJhdGlvbiBvZiB0aGUgc2VnbWVudCBpbiBzZWNvbmRzXG4gICAgICAgIGR1cmF0aW9uOiBzZWdtZW50LmR1cmF0aW9uLFxuICAgICAgICAvLyByZXRhaW4gdGhlIHNlZ21lbnQgaW4gY2FzZSB0aGUgcGxheWxpc3QgdXBkYXRlcyB3aGlsZSBkb2luZyBhbiBhc3luYyBwcm9jZXNzXG4gICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgbmV0d29yayBoYXMgZW5vdWdoIGJhbmR3aWR0aCB0byBjb21wbGV0ZSB0aGUgY3VycmVudCBzZWdtZW50XG4gICAgICogcmVxdWVzdCBpbiBhIHRpbWVseSBtYW5uZXIuIElmIG5vdCwgdGhlIHJlcXVlc3Qgd2lsbCBiZSBhYm9ydGVkIGVhcmx5IGFuZCBiYW5kd2lkdGhcbiAgICAgKiB1cGRhdGVkIHRvIHRyaWdnZXIgYSBwbGF5bGlzdCBzd2l0Y2guXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdHNcbiAgICAgKiAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgc3RhdHMgYWJvdXQgdGhlIHJlcXVlc3QgdGltaW5nIGFuZCBzaXplXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmVxdWVzdCB3YXMgYWJvcnRlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2Fib3J0UmVxdWVzdEVhcmx5XycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0UmVxdWVzdEVhcmx5XyhzdGF0cykge1xuICAgICAgaWYgKHRoaXMuaGxzXy50ZWNoXy5wYXVzZWQoKSB8fFxuICAgICAgLy8gRG9uJ3QgYWJvcnQgaWYgdGhlIGN1cnJlbnQgcGxheWxpc3QgaXMgb24gdGhlIGxvd2VzdEVuYWJsZWRSZW5kaXRpb25cbiAgICAgIC8vIFRPRE86IFJlcGxhY2UgdXNpbmcgdGltZW91dCB3aXRoIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBwbGF5bGlzdCBpc1xuICAgICAgLy8gICAgICAgdGhlIGxvd2VzdEVuYWJsZWRSZW5kaXRpb24uXG4gICAgICAhdGhpcy54aHJPcHRpb25zXy50aW1lb3V0IHx8XG4gICAgICAvLyBEb24ndCBhYm9ydCBpZiB3ZSBoYXZlIG5vIGJhbmR3aWR0aCBpbmZvcm1hdGlvbiB0byBlc3RpbWF0ZSBzZWdtZW50IHNpemVzXG4gICAgICAhdGhpcy5wbGF5bGlzdF8uYXR0cmlidXRlcy5CQU5EV0lEVEgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBXYWl0IGF0IGxlYXN0IDEgc2Vjb25kIHNpbmNlIHRoZSBmaXJzdCBieXRlIG9mIGRhdGEgaGFzIGJlZW4gcmVjZWl2ZWQgYmVmb3JlXG4gICAgICAvLyB1c2luZyB0aGUgY2FsY3VsYXRlZCBiYW5kd2lkdGggZnJvbSB0aGUgcHJvZ3Jlc3MgZXZlbnQgdG8gYWxsb3cgdGhlIGJpdHJhdGVcbiAgICAgIC8vIHRvIHN0YWJpbGl6ZVxuICAgICAgaWYgKERhdGUubm93KCkgLSAoc3RhdHMuZmlyc3RCeXRlc1JlY2VpdmVkQXQgfHwgRGF0ZS5ub3coKSkgPCAxMDAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy5jdXJyZW50VGltZV8oKTtcbiAgICAgIHZhciBtZWFzdXJlZEJhbmR3aWR0aCA9IHN0YXRzLmJhbmR3aWR0aDtcbiAgICAgIHZhciBzZWdtZW50RHVyYXRpb24gPSB0aGlzLnBlbmRpbmdTZWdtZW50Xy5kdXJhdGlvbjtcblxuICAgICAgdmFyIHJlcXVlc3RUaW1lUmVtYWluaW5nID0gX3BsYXlsaXN0MlsnZGVmYXVsdCddLmVzdGltYXRlU2VnbWVudFJlcXVlc3RUaW1lKHNlZ21lbnREdXJhdGlvbiwgbWVhc3VyZWRCYW5kd2lkdGgsIHRoaXMucGxheWxpc3RfLCBzdGF0cy5ieXRlc1JlY2VpdmVkKTtcblxuICAgICAgLy8gU3VidHJhY3QgMSBmcm9tIHRoZSB0aW1lVW50aWxSZWJ1ZmZlciBzbyB3ZSBzdGlsbCBjb25zaWRlciBhbiBlYXJseSBhYm9ydFxuICAgICAgLy8gaWYgd2UgYXJlIG9ubHkgbGVmdCB3aXRoIGxlc3MgdGhhbiAxIHNlY29uZCB3aGVuIHRoZSByZXF1ZXN0IGNvbXBsZXRlcy5cbiAgICAgIC8vIEEgbmVnYXRpdmUgdGltZVVudGlsUmVidWZmZXJpbmcgaW5kaWNhdGVzIHdlIGFyZSBhbHJlYWR5IHJlYnVmZmVyaW5nXG4gICAgICB2YXIgdGltZVVudGlsUmVidWZmZXIgPSAoMCwgX3Jhbmdlcy50aW1lVW50aWxSZWJ1ZmZlcikodGhpcy5idWZmZXJlZF8oKSwgY3VycmVudFRpbWUsIHRoaXMuaGxzXy50ZWNoXy5wbGF5YmFja1JhdGUoKSkgLSAxO1xuXG4gICAgICAvLyBPbmx5IGNvbnNpZGVyIGFib3J0aW5nIGVhcmx5IGlmIHRoZSBlc3RpbWF0ZWQgdGltZSB0byBmaW5pc2ggdGhlIGRvd25sb2FkXG4gICAgICAvLyBpcyBsYXJnZXIgdGhhbiB0aGUgZXN0aW1hdGVkIHRpbWUgdW50aWwgdGhlIHBsYXllciBydW5zIG91dCBvZiBmb3J3YXJkIGJ1ZmZlclxuICAgICAgaWYgKHJlcXVlc3RUaW1lUmVtYWluaW5nIDw9IHRpbWVVbnRpbFJlYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN3aXRjaENhbmRpZGF0ZSA9ICgwLCBfcGxheWxpc3RTZWxlY3RvcnMubWluUmVidWZmZXJNYXhCYW5kd2lkdGhTZWxlY3Rvcikoe1xuICAgICAgICBtYXN0ZXI6IHRoaXMuaGxzXy5wbGF5bGlzdHMubWFzdGVyLFxuICAgICAgICBjdXJyZW50VGltZTogY3VycmVudFRpbWUsXG4gICAgICAgIGJhbmR3aWR0aDogbWVhc3VyZWRCYW5kd2lkdGgsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXygpLFxuICAgICAgICBzZWdtZW50RHVyYXRpb246IHNlZ21lbnREdXJhdGlvbixcbiAgICAgICAgdGltZVVudGlsUmVidWZmZXI6IHRpbWVVbnRpbFJlYnVmZmVyLFxuICAgICAgICBjdXJyZW50VGltZWxpbmU6IHRoaXMuY3VycmVudFRpbWVsaW5lXyxcbiAgICAgICAgc3luY0NvbnRyb2xsZXI6IHRoaXMuc3luY0NvbnRyb2xsZXJfXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFzd2l0Y2hDYW5kaWRhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVidWZmZXJpbmdJbXBhY3QgPSByZXF1ZXN0VGltZVJlbWFpbmluZyAtIHRpbWVVbnRpbFJlYnVmZmVyO1xuXG4gICAgICB2YXIgdGltZVNhdmVkQnlTd2l0Y2hpbmcgPSByZWJ1ZmZlcmluZ0ltcGFjdCAtIHN3aXRjaENhbmRpZGF0ZS5yZWJ1ZmZlcmluZ0ltcGFjdDtcblxuICAgICAgdmFyIG1pbmltdW1UaW1lU2F2aW5nID0gMC41O1xuXG4gICAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSByZWJ1ZmZlcmluZywgaW5jcmVhc2UgdGhlIGFtb3VudCBvZiB2YXJpYW5jZSB3ZSBhZGQgdG8gdGhlXG4gICAgICAvLyBwb3RlbnRpYWwgcm91bmQgdHJpcCB0aW1lIG9mIHRoZSBuZXcgcmVxdWVzdCBzbyB0aGF0IHdlIGFyZSBub3QgdG9vIGFnZ3Jlc3NpdmVcbiAgICAgIC8vIHdpdGggc3dpdGNoaW5nIHRvIGEgcGxheWxpc3QgdGhhdCBtaWdodCBzYXZlIHVzIGEgZnJhY3Rpb24gb2YgYSBzZWNvbmQuXG4gICAgICBpZiAodGltZVVudGlsUmVidWZmZXIgPD0gX3Jhbmdlcy5USU1FX0ZVREdFX0ZBQ1RPUikge1xuICAgICAgICBtaW5pbXVtVGltZVNhdmluZyA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3dpdGNoQ2FuZGlkYXRlLnBsYXlsaXN0IHx8IHN3aXRjaENhbmRpZGF0ZS5wbGF5bGlzdC51cmkgPT09IHRoaXMucGxheWxpc3RfLnVyaSB8fCB0aW1lU2F2ZWRCeVN3aXRjaGluZyA8IG1pbmltdW1UaW1lU2F2aW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHRoZSBiYW5kd2lkdGggdG8gdGhhdCBvZiB0aGUgZGVzaXJlZCBwbGF5bGlzdCBiZWluZyBzdXJlIHRvIHNjYWxlIGJ5XG4gICAgICAvLyBCQU5EV0lEVEhfVkFSSUFOQ0UgYW5kIGFkZCBvbmUgc28gdGhlIHBsYXlsaXN0IHNlbGVjdG9yIGRvZXMgbm90IGV4Y2x1ZGUgaXRcbiAgICAgIC8vIGRvbid0IHRyaWdnZXIgYSBiYW5kd2lkdGh1cGRhdGUgYXMgdGhlIGJhbmR3aWR0aCBpcyBhcnRpZmlhbFxuICAgICAgdGhpcy5iYW5kd2lkdGggPSBzd2l0Y2hDYW5kaWRhdGUucGxheWxpc3QuYXR0cmlidXRlcy5CQU5EV0lEVEggKiBfY29uZmlnMlsnZGVmYXVsdCddLkJBTkRXSURUSF9WQVJJQU5DRSArIDE7XG4gICAgICB0aGlzLmFib3J0KCk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2Vhcmx5YWJvcnQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFhIUiBgcHJvZ3Jlc3NgIGV2ZW50IGhhbmRsZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9XG4gICAgICogICAgICAgIFRoZSBYSFIgYHByb2dyZXNzYCBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzaW1wbGVTZWdtZW50XG4gICAgICogICAgICAgIEEgc2ltcGxpZmllZCBzZWdtZW50IG9iamVjdCBjb3B5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hhbmRsZVByb2dyZXNzXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzXyhldmVudCwgc2ltcGxlU2VnbWVudCkge1xuICAgICAgaWYgKCF0aGlzLnBlbmRpbmdTZWdtZW50XyB8fCBzaW1wbGVTZWdtZW50LnJlcXVlc3RJZCAhPT0gdGhpcy5wZW5kaW5nU2VnbWVudF8ucmVxdWVzdElkIHx8IHRoaXMuYWJvcnRSZXF1ZXN0RWFybHlfKHNpbXBsZVNlZ21lbnQuc3RhdHMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmlnZ2VyKCdwcm9ncmVzcycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGxvYWQgYSBzcGVjaWZpYyBzZWdtZW50IGZyb20gYSByZXF1ZXN0IGludG8gdGhlIGJ1ZmZlclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2xvYWRTZWdtZW50XycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRTZWdtZW50XyhzZWdtZW50SW5mbykge1xuICAgICAgdGhpcy5zdGF0ZSA9ICdXQUlUSU5HJztcbiAgICAgIHRoaXMucGVuZGluZ1NlZ21lbnRfID0gc2VnbWVudEluZm87XG4gICAgICB0aGlzLnRyaW1CYWNrQnVmZmVyXyhzZWdtZW50SW5mbyk7XG5cbiAgICAgIHNlZ21lbnRJbmZvLmFib3J0UmVxdWVzdHMgPSAoMCwgX21lZGlhU2VnbWVudFJlcXVlc3QubWVkaWFTZWdtZW50UmVxdWVzdCkodGhpcy5obHNfLnhociwgdGhpcy54aHJPcHRpb25zXywgdGhpcy5kZWNyeXB0ZXJfLCB0aGlzLmNyZWF0ZVNpbXBsaWZpZWRTZWdtZW50T2JqXyhzZWdtZW50SW5mbyksXG4gICAgICAvLyBwcm9ncmVzcyBjYWxsYmFja1xuICAgICAgdGhpcy5oYW5kbGVQcm9ncmVzc18uYmluZCh0aGlzKSwgdGhpcy5zZWdtZW50UmVxdWVzdEZpbmlzaGVkXy5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0cmltIHRoZSBiYWNrIGJ1ZmZlciBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG9vIG11Y2ggZGF0YVxuICAgICAqIGluIHRoZSBzb3VyY2UgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlZ21lbnRJbmZvIC0gdGhlIGN1cnJlbnQgc2VnbWVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAndHJpbUJhY2tCdWZmZXJfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJpbUJhY2tCdWZmZXJfKHNlZ21lbnRJbmZvKSB7XG4gICAgICB2YXIgcmVtb3ZlVG9UaW1lID0gc2FmZUJhY2tCdWZmZXJUcmltVGltZSh0aGlzLnNlZWthYmxlXygpLCB0aGlzLmN1cnJlbnRUaW1lXygpLCB0aGlzLnBsYXlsaXN0Xy50YXJnZXREdXJhdGlvbiB8fCAxMCk7XG5cbiAgICAgIC8vIENocm9tZSBoYXMgYSBoYXJkIGxpbWl0IG9mIDE1ME1CIG9mXG4gICAgICAvLyBidWZmZXIgYW5kIGEgdmVyeSBjb25zZXJ2YXRpdmUgXCJnYXJiYWdlIGNvbGxlY3RvclwiXG4gICAgICAvLyBXZSBtYW51YWxseSBjbGVhciBvdXQgdGhlIG9sZCBidWZmZXIgdG8gZW5zdXJlXG4gICAgICAvLyB3ZSBkb24ndCB0cmlnZ2VyIHRoZSBRdW90YUV4Y2VlZGVkIGVycm9yXG4gICAgICAvLyBvbiB0aGUgc291cmNlIGJ1ZmZlciBkdXJpbmcgc3Vic2VxdWVudCBhcHBlbmRzXG5cbiAgICAgIGlmIChyZW1vdmVUb1RpbWUgPiAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKDAsIHJlbW92ZVRvVGltZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlZCBhIHNpbXBsaWZpZWQgY29weSBvZiB0aGUgc2VnbWVudCBvYmplY3Qgd2l0aCBqdXN0IHRoZVxuICAgICAqIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byBwZXJmb3JtIHRoZSBYSFIgYW5kIGRlY3J5cHRpb25cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudEluZm8gLSB0aGUgY3VycmVudCBzZWdtZW50XG4gICAgICogQHJldHVybnMge09iamVjdH0gYSBzaW1wbGlmaWVkIHNlZ21lbnQgb2JqZWN0IGNvcHlcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZVNpbXBsaWZpZWRTZWdtZW50T2JqXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVNpbXBsaWZpZWRTZWdtZW50T2JqXyhzZWdtZW50SW5mbykge1xuICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50SW5mby5zZWdtZW50O1xuICAgICAgdmFyIHNpbXBsZVNlZ21lbnQgPSB7XG4gICAgICAgIHJlc29sdmVkVXJpOiBzZWdtZW50LnJlc29sdmVkVXJpLFxuICAgICAgICBieXRlcmFuZ2U6IHNlZ21lbnQuYnl0ZXJhbmdlLFxuICAgICAgICByZXF1ZXN0SWQ6IHNlZ21lbnRJbmZvLnJlcXVlc3RJZFxuICAgICAgfTtcblxuICAgICAgaWYgKHNlZ21lbnQua2V5KSB7XG4gICAgICAgIC8vIGlmIHRoZSBtZWRpYSBzZXF1ZW5jZSBpcyBncmVhdGVyIHRoYW4gMl4zMiwgdGhlIElWIHdpbGwgYmUgaW5jb3JyZWN0XG4gICAgICAgIC8vIGFzc3VtaW5nIDEwcyBzZWdtZW50cywgdGhhdCB3b3VsZCBiZSBhYm91dCAxMzAwIHllYXJzXG4gICAgICAgIHZhciBpdiA9IHNlZ21lbnQua2V5Lml2IHx8IG5ldyBVaW50MzJBcnJheShbMCwgMCwgMCwgc2VnbWVudEluZm8ubWVkaWFJbmRleCArIHNlZ21lbnRJbmZvLnBsYXlsaXN0Lm1lZGlhU2VxdWVuY2VdKTtcblxuICAgICAgICBzaW1wbGVTZWdtZW50LmtleSA9IHtcbiAgICAgICAgICByZXNvbHZlZFVyaTogc2VnbWVudC5rZXkucmVzb2x2ZWRVcmksXG4gICAgICAgICAgaXY6IGl2XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWdtZW50Lm1hcCkge1xuICAgICAgICBzaW1wbGVTZWdtZW50Lm1hcCA9IHRoaXMuaW5pdFNlZ21lbnQoc2VnbWVudC5tYXApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2ltcGxlU2VnbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGNhbGxiYWNrIGZyb20gdGhlIHNlZ21lbnRSZXF1ZXN0IGZ1bmN0aW9uIGFuZCBzZXQgdGhlXG4gICAgICogYXNzb2NpYXRlZCBTZWdtZW50TG9hZGVyIHN0YXRlIGFuZCBlcnJvcnMgaWYgbmVjZXNzYXJ5XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnc2VnbWVudFJlcXVlc3RGaW5pc2hlZF8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWdtZW50UmVxdWVzdEZpbmlzaGVkXyhlcnJvciwgc2ltcGxlU2VnbWVudCkge1xuICAgICAgLy8gZXZlcnkgcmVxdWVzdCBjb3VudHMgYXMgYSBtZWRpYSByZXF1ZXN0IGV2ZW4gaWYgaXQgaGFzIGJlZW4gYWJvcnRlZFxuICAgICAgLy8gb3IgY2FuY2VsZWQgZHVlIHRvIGEgdGltZW91dFxuICAgICAgdGhpcy5tZWRpYVJlcXVlc3RzICs9IDE7XG5cbiAgICAgIGlmIChzaW1wbGVTZWdtZW50LnN0YXRzKSB7XG4gICAgICAgIHRoaXMubWVkaWFCeXRlc1RyYW5zZmVycmVkICs9IHNpbXBsZVNlZ21lbnQuc3RhdHMuYnl0ZXNSZWNlaXZlZDtcbiAgICAgICAgdGhpcy5tZWRpYVRyYW5zZmVyRHVyYXRpb24gKz0gc2ltcGxlU2VnbWVudC5zdGF0cy5yb3VuZFRyaXBUaW1lO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcmVxdWVzdCB3YXMgYWJvcnRlZCBhbmQgdGhlIFNlZ21lbnRMb2FkZXIgaGFzIGFscmVhZHkgYmVlbiByZXNldFxuICAgICAgaWYgKCF0aGlzLnBlbmRpbmdTZWdtZW50Xykge1xuICAgICAgICB0aGlzLm1lZGlhUmVxdWVzdHNBYm9ydGVkICs9IDE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gdGhlIHJlcXVlc3Qgd2FzIGFib3J0ZWQgYW5kIHRoZSBTZWdtZW50TG9hZGVyIGhhcyBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgIC8vIGFub3RoZXIgcmVxdWVzdC4gdGhpcyBjYW4gaGFwcGVuIHdoZW4gdGhlIHRpbWVvdXQgZm9yIGFuIGFib3J0ZWRcbiAgICAgIC8vIHJlcXVlc3QgdHJpZ2dlcnMgZHVlIHRvIGEgbGltaXRhdGlvbiBpbiB0aGUgWEhSIGxpYnJhcnlcbiAgICAgIC8vIGRvIG5vdCBjb3VudCB0aGlzIGFzIGFueSBzb3J0IG9mIHJlcXVlc3Qgb3Igd2UgcmlzayBkb3VibGUtY291bnRpbmdcbiAgICAgIGlmIChzaW1wbGVTZWdtZW50LnJlcXVlc3RJZCAhPT0gdGhpcy5wZW5kaW5nU2VnbWVudF8ucmVxdWVzdElkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYW4gZXJyb3Igb2NjdXJyZWQgZnJvbSB0aGUgYWN0aXZlIHBlbmRpbmdTZWdtZW50XyBzbyByZXNldCBldmVyeXRoaW5nXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nU2VnbWVudF8gPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gJ1JFQURZJztcblxuICAgICAgICAvLyB0aGUgcmVxdWVzdHMgd2VyZSBhYm9ydGVkIGp1c3QgcmVjb3JkIHRoZSBhYm9ydGVkIHN0YXQgYW5kIGV4aXRcbiAgICAgICAgLy8gdGhpcyBpcyBub3QgYSB0cnVlIGVycm9yIGNvbmRpdGlvbiBhbmQgbm90aGluZyBjb3JyZWN0aXZlIG5lZWRzXG4gICAgICAgIC8vIHRvIGJlIGRvbmVcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IF9tZWRpYVNlZ21lbnRSZXF1ZXN0LlJFUVVFU1RfRVJST1JTLkFCT1JURUQpIHtcbiAgICAgICAgICB0aGlzLm1lZGlhUmVxdWVzdHNBYm9ydGVkICs9IDE7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuXG4gICAgICAgIC8vIHRoZSBlcnJvciBpcyByZWFsbHkganVzdCB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGUgcmVxdWVzdHMgdGltZWQtb3V0XG4gICAgICAgIC8vIHNldCB0aGUgYmFuZHdpZHRoIHRvIGEgdmVyeSBsb3cgdmFsdWUgYW5kIHRyaWdnZXIgYW4gQUJSIHN3aXRjaCB0b1xuICAgICAgICAvLyB0YWtlIGVtZXJnZW5jeSBhY3Rpb25cbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IF9tZWRpYVNlZ21lbnRSZXF1ZXN0LlJFUVVFU1RfRVJST1JTLlRJTUVPVVQpIHtcbiAgICAgICAgICB0aGlzLm1lZGlhUmVxdWVzdHNUaW1lZG91dCArPSAxO1xuICAgICAgICAgIHRoaXMuYmFuZHdpZHRoID0gMTtcbiAgICAgICAgICB0aGlzLnJvdW5kVHJpcCA9IE5hTjtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JhbmR3aWR0aHVwZGF0ZScpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGNvbnRyb2wtZmxvdyBoYXMgYXJyaXZlZCBoZXJlLCB0aGVuIHRoZSBlcnJvciBpcyByZWFsXG4gICAgICAgIC8vIGVtaXQgYW4gZXJyb3IgZXZlbnQgdG8gYmxhY2tsaXN0IHRoZSBjdXJyZW50IHBsYXlsaXN0XG4gICAgICAgIHRoaXMubWVkaWFSZXF1ZXN0c0Vycm9yZWQgKz0gMTtcbiAgICAgICAgdGhpcy5lcnJvcihlcnJvcik7XG4gICAgICAgIHRoaXMudHJpZ2dlcignZXJyb3InKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGUgcmVzcG9uc2Ugd2FzIGEgc3VjY2VzcyBzbyBzZXQgYW55IGJhbmR3aWR0aCBzdGF0cyB0aGUgcmVxdWVzdFxuICAgICAgLy8gZ2VuZXJhdGVkIGZvciBBQlIgcHVycG9zZXNcbiAgICAgIHRoaXMuYmFuZHdpZHRoID0gc2ltcGxlU2VnbWVudC5zdGF0cy5iYW5kd2lkdGg7XG4gICAgICB0aGlzLnJvdW5kVHJpcCA9IHNpbXBsZVNlZ21lbnQuc3RhdHMucm91bmRUcmlwVGltZTtcblxuICAgICAgLy8gaWYgdGhpcyByZXF1ZXN0IGluY2x1ZGVkIGFuIGluaXRpYWxpemF0aW9uIHNlZ21lbnQsIHNhdmUgdGhhdCBkYXRhXG4gICAgICAvLyB0byB0aGUgaW5pdFNlZ21lbnQgY2FjaGVcbiAgICAgIGlmIChzaW1wbGVTZWdtZW50Lm1hcCkge1xuICAgICAgICBzaW1wbGVTZWdtZW50Lm1hcCA9IHRoaXMuaW5pdFNlZ21lbnQoc2ltcGxlU2VnbWVudC5tYXAsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb2Nlc3NTZWdtZW50UmVzcG9uc2VfKHNpbXBsZVNlZ21lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmUgYW55IGltcG9ydGFudCBkYXRhIGZyb20gdGhlIHNpbXBsaWZpZWQgc2VnbWVudCBvYmplY3RcbiAgICAgKiBiYWNrIHRvIHRoZSByZWFsIHNlZ21lbnQgb2JqZWN0IGZvciBmdXR1cmUgcGhhc2VzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncHJvY2Vzc1NlZ21lbnRSZXNwb25zZV8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzU2VnbWVudFJlc3BvbnNlXyhzaW1wbGVTZWdtZW50KSB7XG4gICAgICB2YXIgc2VnbWVudEluZm8gPSB0aGlzLnBlbmRpbmdTZWdtZW50XztcblxuICAgICAgc2VnbWVudEluZm8uYnl0ZXMgPSBzaW1wbGVTZWdtZW50LmJ5dGVzO1xuICAgICAgaWYgKHNpbXBsZVNlZ21lbnQubWFwKSB7XG4gICAgICAgIHNlZ21lbnRJbmZvLnNlZ21lbnQubWFwLmJ5dGVzID0gc2ltcGxlU2VnbWVudC5tYXAuYnl0ZXM7XG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnRJbmZvLmVuZE9mQWxsUmVxdWVzdHMgPSBzaW1wbGVTZWdtZW50LmVuZE9mQWxsUmVxdWVzdHM7XG4gICAgICB0aGlzLmhhbmRsZVNlZ21lbnRfKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYXBwZW5kIGEgZGVjcnlwdGVkIHNlZ2VtZW50IHRvIHRoZSBTb3VyY2VCdWZmZXIgdGhyb3VnaCBhIFNvdXJjZVVwZGF0ZXJcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVTZWdtZW50XycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVNlZ21lbnRfKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5wZW5kaW5nU2VnbWVudF8pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdSRUFEWSc7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlZ21lbnRJbmZvID0gdGhpcy5wZW5kaW5nU2VnbWVudF87XG4gICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRJbmZvLnNlZ21lbnQ7XG4gICAgICB2YXIgdGltaW5nSW5mbyA9IHRoaXMuc3luY0NvbnRyb2xsZXJfLnByb2JlU2VnbWVudEluZm8oc2VnbWVudEluZm8pO1xuXG4gICAgICAvLyBXaGVuIHdlIGhhdmUgb3VyIGZpcnN0IHRpbWluZyBpbmZvLCBkZXRlcm1pbmUgd2hhdCBtZWRpYSB0eXBlcyB0aGlzIGxvYWRlciBpc1xuICAgICAgLy8gZGVhbGluZyB3aXRoLiBBbHRob3VnaCB3ZSdyZSBtYWludGFpbmluZyBleHRyYSBzdGF0ZSwgaXQgaGVscHMgdG8gcHJlc2VydmUgdGhlXG4gICAgICAvLyBzZXBhcmF0aW9uIG9mIHNlZ21lbnQgbG9hZGVyIGZyb20gdGhlIGFjdHVhbCBzb3VyY2UgYnVmZmVycy5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zdGFydGluZ01lZGlhXyA9PT0gJ3VuZGVmaW5lZCcgJiYgdGltaW5nSW5mbyAmJiAoXG4gICAgICAvLyBHdWFyZCBhZ2FpbnN0IGNhc2VzIHdoZXJlIHdlJ3JlIG5vdCBnZXR0aW5nIHRpbWluZyBpbmZvIGF0IGFsbCB1bnRpbCB3ZSBhcmVcbiAgICAgIC8vIGNlcnRhaW4gdGhhdCBhbGwgc3RyZWFtcyB3aWxsIHByb3ZpZGUgaXQuXG4gICAgICB0aW1pbmdJbmZvLmNvbnRhaW5zQXVkaW8gfHwgdGltaW5nSW5mby5jb250YWluc1ZpZGVvKSkge1xuICAgICAgICB0aGlzLnN0YXJ0aW5nTWVkaWFfID0ge1xuICAgICAgICAgIGNvbnRhaW5zQXVkaW86IHRpbWluZ0luZm8uY29udGFpbnNBdWRpbyxcbiAgICAgICAgICBjb250YWluc1ZpZGVvOiB0aW1pbmdJbmZvLmNvbnRhaW5zVmlkZW9cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlsbGVnYWxNZWRpYVN3aXRjaEVycm9yID0gaWxsZWdhbE1lZGlhU3dpdGNoKHRoaXMubG9hZGVyVHlwZV8sIHRoaXMuc3RhcnRpbmdNZWRpYV8sIHRpbWluZ0luZm8pO1xuXG4gICAgICBpZiAoaWxsZWdhbE1lZGlhU3dpdGNoRXJyb3IpIHtcbiAgICAgICAgdGhpcy5lcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogaWxsZWdhbE1lZGlhU3dpdGNoRXJyb3IsXG4gICAgICAgICAgYmxhY2tsaXN0RHVyYXRpb246IEluZmluaXR5XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlZ21lbnRJbmZvLmlzU3luY1JlcXVlc3QpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzeW5jaW5mb3VwZGF0ZScpO1xuICAgICAgICB0aGlzLnBlbmRpbmdTZWdtZW50XyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnUkVBRFknO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWdtZW50SW5mby50aW1lc3RhbXBPZmZzZXQgIT09IG51bGwgJiYgc2VnbWVudEluZm8udGltZXN0YW1wT2Zmc2V0ICE9PSB0aGlzLnNvdXJjZVVwZGF0ZXJfLnRpbWVzdGFtcE9mZnNldCgpKSB7XG4gICAgICAgIHRoaXMuc291cmNlVXBkYXRlcl8udGltZXN0YW1wT2Zmc2V0KHNlZ21lbnRJbmZvLnRpbWVzdGFtcE9mZnNldCk7XG4gICAgICAgIC8vIGZpcmVkIHdoZW4gYSB0aW1lc3RhbXAgb2Zmc2V0IGlzIHNldCBpbiBITFMgKGNhbiBhbHNvIGlkZW50aWZ5IGRpc2NvbnRpbnVpdGllcylcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd0aW1lc3RhbXBvZmZzZXQnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWVsaW5lTWFwcGluZyA9IHRoaXMuc3luY0NvbnRyb2xsZXJfLm1hcHBpbmdGb3JUaW1lbGluZShzZWdtZW50SW5mby50aW1lbGluZSk7XG5cbiAgICAgIGlmICh0aW1lbGluZU1hcHBpbmcgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKHtcbiAgICAgICAgICB0eXBlOiAnc2VnbWVudHRpbWVtYXBwaW5nJyxcbiAgICAgICAgICBtYXBwaW5nOiB0aW1lbGluZU1hcHBpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhdGUgPSAnQVBQRU5ESU5HJztcblxuICAgICAgLy8gaWYgdGhlIG1lZGlhIGluaXRpYWxpemF0aW9uIHNlZ21lbnQgaXMgY2hhbmdpbmcsIGFwcGVuZCBpdFxuICAgICAgLy8gYmVmb3JlIHRoZSBjb250ZW50IHNlZ21lbnRcbiAgICAgIGlmIChzZWdtZW50Lm1hcCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbml0SWQgPSAoMCwgX2JpblV0aWxzLmluaXRTZWdtZW50SWQpKHNlZ21lbnQubWFwKTtcblxuICAgICAgICAgIGlmICghX3RoaXMzLmFjdGl2ZUluaXRTZWdtZW50SWRfIHx8IF90aGlzMy5hY3RpdmVJbml0U2VnbWVudElkXyAhPT0gaW5pdElkKSB7XG4gICAgICAgICAgICB2YXIgaW5pdFNlZ21lbnQgPSBfdGhpczMuaW5pdFNlZ21lbnQoc2VnbWVudC5tYXApO1xuXG4gICAgICAgICAgICBfdGhpczMuc291cmNlVXBkYXRlcl8uYXBwZW5kQnVmZmVyKGluaXRTZWdtZW50LmJ5dGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5hY3RpdmVJbml0U2VnbWVudElkXyA9IGluaXRJZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgIH1cblxuICAgICAgc2VnbWVudEluZm8uYnl0ZUxlbmd0aCA9IHNlZ21lbnRJbmZvLmJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICBpZiAodHlwZW9mIHNlZ21lbnQuc3RhcnQgPT09ICdudW1iZXInICYmIHR5cGVvZiBzZWdtZW50LmVuZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5tZWRpYVNlY29uZHNMb2FkZWQgKz0gc2VnbWVudC5lbmQgLSBzZWdtZW50LnN0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tZWRpYVNlY29uZHNMb2FkZWQgKz0gc2VnbWVudC5kdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zb3VyY2VVcGRhdGVyXy5hcHBlbmRCdWZmZXIoc2VnbWVudEluZm8uYnl0ZXMsIHRoaXMuaGFuZGxlVXBkYXRlRW5kXy5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjYWxsYmFjayB0byBydW4gd2hlbiBhcHBlbmRCdWZmZXIgaXMgZmluaXNoZWQuIGRldGVjdHMgaWYgd2UgYXJlXG4gICAgICogaW4gYSBnb29kIHN0YXRlIHRvIGRvIHRoaW5ncyB3aXRoIHRoZSBkYXRhIHdlIGdvdCwgb3IgaWYgd2UgbmVlZFxuICAgICAqIHRvIHdhaXQgZm9yIG1vcmVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVVcGRhdGVFbmRfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVXBkYXRlRW5kXygpIHtcbiAgICAgIHRoaXMubG9nZ2VyXygnaGFuZGxlVXBkYXRlRW5kXycsICdzZWdtZW50SW5mbzonLCB0aGlzLnBlbmRpbmdTZWdtZW50Xyk7XG5cbiAgICAgIGlmICghdGhpcy5wZW5kaW5nU2VnbWVudF8pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdSRUFEWSc7XG4gICAgICAgIGlmICghdGhpcy5wYXVzZWQoKSkge1xuICAgICAgICAgIHRoaXMubW9uaXRvckJ1ZmZlcl8oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWdtZW50SW5mbyA9IHRoaXMucGVuZGluZ1NlZ21lbnRfO1xuICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50SW5mby5zZWdtZW50O1xuICAgICAgdmFyIGlzV2Fsa2luZ0ZvcndhcmQgPSB0aGlzLm1lZGlhSW5kZXggIT09IG51bGw7XG5cbiAgICAgIHRoaXMucGVuZGluZ1NlZ21lbnRfID0gbnVsbDtcbiAgICAgIHRoaXMucmVjb3JkVGhyb3VnaHB1dF8oc2VnbWVudEluZm8pO1xuICAgICAgdGhpcy5hZGRTZWdtZW50TWV0YWRhdGFDdWVfKHNlZ21lbnRJbmZvKTtcblxuICAgICAgdGhpcy5zdGF0ZSA9ICdSRUFEWSc7XG5cbiAgICAgIHRoaXMubWVkaWFJbmRleCA9IHNlZ21lbnRJbmZvLm1lZGlhSW5kZXg7XG4gICAgICB0aGlzLmZldGNoQXRCdWZmZXJfID0gdHJ1ZTtcbiAgICAgIHRoaXMuY3VycmVudFRpbWVsaW5lXyA9IHNlZ21lbnRJbmZvLnRpbWVsaW5lO1xuXG4gICAgICAvLyBXZSBtdXN0IHVwZGF0ZSB0aGUgc3luY2luZm8gdG8gcmVjYWxjdWxhdGUgdGhlIHNlZWthYmxlIHJhbmdlIGJlZm9yZVxuICAgICAgLy8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25hbCBvdGhlcndpc2UgaXQgbWF5IGNvbnNpZGVyIHRoaXMgYSBiYWQgXCJndWVzc1wiXG4gICAgICAvLyBhbmQgYXR0ZW1wdCB0byByZXN5bmMgd2hlbiB0aGUgcG9zdC11cGRhdGUgc2Vla2FibGUgd2luZG93IGFuZCBsaXZlXG4gICAgICAvLyBwb2ludCB3b3VsZCBtZWFuIHRoYXQgdGhpcyB3YXMgdGhlIHBlcmZlY3Qgc2VnbWVudCB0byBmZXRjaFxuICAgICAgdGhpcy50cmlnZ2VyKCdzeW5jaW5mb3VwZGF0ZScpO1xuXG4gICAgICAvLyBJZiB3ZSBwcmV2aW91c2x5IGFwcGVuZGVkIGEgc2VnbWVudCB0aGF0IGVuZHMgbW9yZSB0aGFuIDMgdGFyZ2V0RHVyYXRpb25zIGJlZm9yZVxuICAgICAgLy8gdGhlIGN1cnJlbnRUaW1lXyB0aGF0IG1lYW5zIHRoYXQgb3VyIGNvbnNlcnZhdGl2ZSBndWVzcyB3YXMgdG9vIGNvbnNlcnZhdGl2ZS5cbiAgICAgIC8vIEluIHRoYXQgY2FzZSwgcmVzZXQgdGhlIGxvYWRlciBzdGF0ZSBzbyB0aGF0IHdlIHRyeSB0byB1c2UgYW55IGluZm9ybWF0aW9uIGdhaW5lZFxuICAgICAgLy8gZnJvbSB0aGUgcHJldmlvdXMgcmVxdWVzdCB0byBjcmVhdGUgYSBuZXcsIG1vcmUgYWNjdXJhdGUsIHN5bmMtcG9pbnQuXG4gICAgICBpZiAoc2VnbWVudC5lbmQgJiYgdGhpcy5jdXJyZW50VGltZV8oKSAtIHNlZ21lbnQuZW5kID4gc2VnbWVudEluZm8ucGxheWxpc3QudGFyZ2V0RHVyYXRpb24gKiAzKSB7XG4gICAgICAgIHRoaXMucmVzZXRFdmVyeXRoaW5nKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgZG8gYSByZW5kaXRpb24gc3dpdGNoIHVubGVzcyB3ZSBoYXZlIGVub3VnaCB0aW1lIHRvIGdldCBhIHN5bmMgc2VnbWVudFxuICAgICAgLy8gYW5kIGNvbnNlcnZhdGl2ZWx5IGd1ZXNzXG4gICAgICBpZiAoaXNXYWxraW5nRm9yd2FyZCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2JhbmR3aWR0aHVwZGF0ZScpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyKCdwcm9ncmVzcycpO1xuXG4gICAgICAvLyBhbnkgdGltZSBhbiB1cGRhdGUgZmluaXNoZXMgYW5kIHRoZSBsYXN0IHNlZ21lbnQgaXMgaW4gdGhlXG4gICAgICAvLyBidWZmZXIsIGVuZCB0aGUgc3RyZWFtLiB0aGlzIGVuc3VyZXMgdGhlIFwiZW5kZWRcIiBldmVudCB3aWxsXG4gICAgICAvLyBmaXJlIGlmIHBsYXliYWNrIHJlYWNoZXMgdGhhdCBwb2ludC5cbiAgICAgIHZhciBpc0VuZE9mU3RyZWFtID0gZGV0ZWN0RW5kT2ZTdHJlYW0oc2VnbWVudEluZm8ucGxheWxpc3QsIHRoaXMubWVkaWFTb3VyY2VfLCBzZWdtZW50SW5mby5tZWRpYUluZGV4ICsgMSk7XG5cbiAgICAgIGlmIChpc0VuZE9mU3RyZWFtKSB7XG4gICAgICAgIHRoaXMuZW5kT2ZTdHJlYW0oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnBhdXNlZCgpKSB7XG4gICAgICAgIHRoaXMubW9uaXRvckJ1ZmZlcl8oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNvcmRzIHRoZSBjdXJyZW50IHRocm91Z2hwdXQgb2YgdGhlIGRlY3J5cHQsIHRyYW5zbXV4LCBhbmQgYXBwZW5kXG4gICAgICogcG9ydGlvbiBvZiB0aGUgc2VtZ21lbnQgcGlwZWxpbmUuIGB0aHJvdWdocHV0LnJhdGVgIGlzIGEgdGhlIGN1bXVsYXRpdmVcbiAgICAgKiBtb3ZpbmcgYXZlcmFnZSBvZiB0aGUgdGhyb3VnaHB1dC4gYHRocm91Z2hwdXQuY291bnRgIGlzIHRoZSBudW1iZXIgb2ZcbiAgICAgKiBkYXRhIHBvaW50cyBpbiB0aGUgYXZlcmFnZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlZ21lbnRJbmZvIHRoZSBvYmplY3QgcmV0dXJuZWQgYnkgbG9hZFNlZ21lbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3JlY29yZFRocm91Z2hwdXRfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb3JkVGhyb3VnaHB1dF8oc2VnbWVudEluZm8pIHtcbiAgICAgIHZhciByYXRlID0gdGhpcy50aHJvdWdocHV0LnJhdGU7XG4gICAgICAvLyBBZGQgb25lIHRvIHRoZSB0aW1lIHRvIGVuc3VyZSB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseSBhdHRlbXB0IHRvIGRpdmlkZVxuICAgICAgLy8gYnkgemVybyBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgdGhyb3VnaHB1dCBpcyByaWRpY3Vsb3VzbHkgaGlnaFxuICAgICAgdmFyIHNlZ21lbnRQcm9jZXNzaW5nVGltZSA9IERhdGUubm93KCkgLSBzZWdtZW50SW5mby5lbmRPZkFsbFJlcXVlc3RzICsgMTtcbiAgICAgIC8vIE11bHRpcGx5IGJ5IDgwMDAgdG8gY29udmVydCBmcm9tIGJ5dGVzL21pbGxpc2Vjb25kIHRvIGJpdHMvc2Vjb25kXG4gICAgICB2YXIgc2VnbWVudFByb2Nlc3NpbmdUaHJvdWdocHV0ID0gTWF0aC5mbG9vcihzZWdtZW50SW5mby5ieXRlTGVuZ3RoIC8gc2VnbWVudFByb2Nlc3NpbmdUaW1lICogOCAqIDEwMDApO1xuXG4gICAgICAvLyBUaGlzIGlzIGp1c3QgYSBjdW11bGF0aXZlIG1vdmluZyBhdmVyYWdlIGNhbGN1bGF0aW9uOlxuICAgICAgLy8gICBuZXdBdmcgPSBvbGRBdmcgKyAoc2FtcGxlIC0gb2xkQXZnKSAvIChzYW1wbGVDb3VudCArIDEpXG4gICAgICB0aGlzLnRocm91Z2hwdXQucmF0ZSArPSAoc2VnbWVudFByb2Nlc3NpbmdUaHJvdWdocHV0IC0gcmF0ZSkgLyArK3RoaXMudGhyb3VnaHB1dC5jb3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGRlYnVnZ2luZyBsb2dnZXIgbm9vcCB0aGF0IGlzIHNldCB0byBjb25zb2xlLmxvZyBvbmx5IGlmIGRlYnVnZ2luZ1xuICAgICAqIGlzIGVuYWJsZWQgZ2xvYmFsbHlcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdsb2dnZXJfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9nZ2VyXygpIHt9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY3VlIHRvIHRoZSBzZWdtZW50LW1ldGFkYXRhIHRyYWNrIHdpdGggc29tZSBtZXRhZGF0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGVcbiAgICAgKiBzZWdtZW50XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWdtZW50SW5mb1xuICAgICAqICAgICAgICB0aGUgb2JqZWN0IHJldHVybmVkIGJ5IGxvYWRTZWdtZW50XG4gICAgICogQG1ldGhvZCBhZGRTZWdtZW50TWV0YWRhdGFDdWVfXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRTZWdtZW50TWV0YWRhdGFDdWVfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU2VnbWVudE1ldGFkYXRhQ3VlXyhzZWdtZW50SW5mbykge1xuICAgICAgaWYgKCF0aGlzLnNlZ21lbnRNZXRhZGF0YVRyYWNrXykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudEluZm8uc2VnbWVudDtcbiAgICAgIHZhciBzdGFydCA9IHNlZ21lbnQuc3RhcnQ7XG4gICAgICB2YXIgZW5kID0gc2VnbWVudC5lbmQ7XG5cbiAgICAgIC8vIERvIG5vdCB0cnkgYWRkaW5nIHRoZSBjdWUgaWYgdGhlIHN0YXJ0IGFuZCBlbmQgdGltZXMgYXJlIGludmFsaWQuXG4gICAgICBpZiAoIWZpbml0ZShzdGFydCkgfHwgIWZpbml0ZShlbmQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgKDAsIF92aWRlb2pzQ29udHJpYk1lZGlhU291cmNlc0VzNVJlbW92ZUN1ZXNGcm9tVHJhY2tKczJbJ2RlZmF1bHQnXSkoc3RhcnQsIGVuZCwgdGhpcy5zZWdtZW50TWV0YWRhdGFUcmFja18pO1xuXG4gICAgICB2YXIgQ3VlID0gX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5XZWJLaXREYXRhQ3VlIHx8IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uVlRUQ3VlO1xuICAgICAgdmFyIHZhbHVlID0ge1xuICAgICAgICB1cmk6IHNlZ21lbnRJbmZvLnVyaSxcbiAgICAgICAgdGltZWxpbmU6IHNlZ21lbnRJbmZvLnRpbWVsaW5lLFxuICAgICAgICBwbGF5bGlzdDogc2VnbWVudEluZm8ucGxheWxpc3QudXJpLFxuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kXG4gICAgICB9O1xuICAgICAgdmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICB2YXIgY3VlID0gbmV3IEN1ZShzdGFydCwgZW5kLCBkYXRhKTtcblxuICAgICAgLy8gQXR0YWNoIHRoZSBtZXRhZGF0YSB0byB0aGUgdmFsdWUgcHJvcGVydHkgb2YgdGhlIGN1ZSB0byBrZWVwIGNvbnNpc3RlbmN5IGJldHdlZW5cbiAgICAgIC8vIHRoZSBkaWZmZXJlbmNlcyBvZiBXZWJLaXREYXRhQ3VlIGluIHNhZmFyaSBhbmQgVlRUQ3VlIGluIG90aGVyIGJyb3dzZXJzXG4gICAgICBjdWUudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgdGhpcy5zZWdtZW50TWV0YWRhdGFUcmFja18uYWRkQ3VlKGN1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNlZ21lbnRMb2FkZXI7XG59KShfdmlkZW9KczJbJ2RlZmF1bHQnXS5FdmVudFRhcmdldCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFNlZ21lbnRMb2FkZXI7XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi9iaW4tdXRpbHNcIjoyLFwiLi9jb25maWdcIjozLFwiLi9tZWRpYS1zZWdtZW50LXJlcXVlc3RcIjo3LFwiLi9wbGF5bGlzdFwiOjExLFwiLi9wbGF5bGlzdC1zZWxlY3RvcnNcIjoxMCxcIi4vcmFuZ2VzXCI6MTIsXCIuL3NvdXJjZS11cGRhdGVyXCI6MTcsXCJnbG9iYWwvd2luZG93XCI6MzIsXCJ2aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9lczUvcmVtb3ZlLWN1ZXMtZnJvbS10cmFjay5qc1wiOjcyfV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBAZmlsZSBzb3VyY2UtdXBkYXRlci5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgX3ZpZGVvSnMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sndmlkZW9qcyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndmlkZW9qcyddIDogbnVsbCk7XG5cbnZhciBfdmlkZW9KczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aWRlb0pzKTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbi8qKlxuICogQSBxdWV1ZSBvZiBjYWxsYmFja3MgdG8gYmUgc2VyaWFsaXplZCBhbmQgYXBwbGllZCB3aGVuIGFcbiAqIE1lZGlhU291cmNlIGFuZCBpdHMgYXNzb2NpYXRlZCBTb3VyY2VCdWZmZXJzIGFyZSBub3QgaW4gdGhlXG4gKiB1cGRhdGluZyBzdGF0ZS4gSXQgaXMgdXNlZCBieSB0aGUgc2VnbWVudCBsb2FkZXIgdG8gdXBkYXRlIHRoZVxuICogdW5kZXJseWluZyBTb3VyY2VCdWZmZXJzIHdoZW4gbmV3IGRhdGEgaXMgbG9hZGVkLCBmb3IgaW5zdGFuY2UuXG4gKlxuICogQGNsYXNzIFNvdXJjZVVwZGF0ZXJcbiAqIEBwYXJhbSB7TWVkaWFTb3VyY2V9IG1lZGlhU291cmNlIHRoZSBNZWRpYVNvdXJjZSB0byBjcmVhdGUgdGhlXG4gKiBTb3VyY2VCdWZmZXIgZnJvbVxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIHRoZSBkZXNpcmVkIE1JTUUgdHlwZSBvZiB0aGUgdW5kZXJseWluZ1xuICogU291cmNlQnVmZmVyXG4gKi9cblxudmFyIFNvdXJjZVVwZGF0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTb3VyY2VVcGRhdGVyKG1lZGlhU291cmNlLCBtaW1lVHlwZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU291cmNlVXBkYXRlcik7XG5cbiAgICB2YXIgY3JlYXRlU291cmNlQnVmZmVyID0gZnVuY3Rpb24gY3JlYXRlU291cmNlQnVmZmVyKCkge1xuICAgICAgX3RoaXMuc291cmNlQnVmZmVyXyA9IG1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcihtaW1lVHlwZSk7XG5cbiAgICAgIC8vIHJ1biBjb21wbGV0aW9uIGhhbmRsZXJzIGFuZCBwcm9jZXNzIGNhbGxiYWNrcyBhcyB1cGRhdGVlbmRcbiAgICAgIC8vIGV2ZW50cyBmaXJlXG4gICAgICBfdGhpcy5vblVwZGF0ZWVuZENhbGxiYWNrXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBlbmRpbmdDYWxsYmFjayA9IF90aGlzLnBlbmRpbmdDYWxsYmFja187XG5cbiAgICAgICAgX3RoaXMucGVuZGluZ0NhbGxiYWNrXyA9IG51bGw7XG5cbiAgICAgICAgaWYgKHBlbmRpbmdDYWxsYmFjaykge1xuICAgICAgICAgIHBlbmRpbmdDYWxsYmFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMucnVuQ2FsbGJhY2tfKCk7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5zb3VyY2VCdWZmZXJfLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZWVuZCcsIF90aGlzLm9uVXBkYXRlZW5kQ2FsbGJhY2tfKTtcblxuICAgICAgX3RoaXMucnVuQ2FsbGJhY2tfKCk7XG4gICAgfTtcblxuICAgIHRoaXMuY2FsbGJhY2tzXyA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0NhbGxiYWNrXyA9IG51bGw7XG4gICAgdGhpcy50aW1lc3RhbXBPZmZzZXRfID0gMDtcbiAgICB0aGlzLm1lZGlhU291cmNlID0gbWVkaWFTb3VyY2U7XG4gICAgdGhpcy5wcm9jZXNzZWRBcHBlbmRfID0gZmFsc2U7XG5cbiAgICBpZiAobWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIG1lZGlhU291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCBjcmVhdGVTb3VyY2VCdWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVTb3VyY2VCdWZmZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWJvcnRzIHRoZSBjdXJyZW50IHNlZ21lbnQgYW5kIHJlc2V0cyB0aGUgc2VnbWVudCBwYXJzZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGRvbmVcbiAgICogQHNlZSBodHRwOi8vdzNjLmdpdGh1Yi5pby9tZWRpYS1zb3VyY2UvI3dpZGwtU291cmNlQnVmZmVyLWFib3J0LXZvaWRcbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKFNvdXJjZVVwZGF0ZXIsIFt7XG4gICAga2V5OiAnYWJvcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYm9ydChkb25lKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkQXBwZW5kXykge1xuICAgICAgICB0aGlzLnF1ZXVlQ2FsbGJhY2tfKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuc291cmNlQnVmZmVyXy5hYm9ydCgpO1xuICAgICAgICB9LCBkb25lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBRdWV1ZSBhbiB1cGRhdGUgdG8gYXBwZW5kIGFuIEFycmF5QnVmZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnl0ZXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lIHRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gZG9uZVxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyN3aWRsLVNvdXJjZUJ1ZmZlci1hcHBlbmRCdWZmZXItdm9pZC1BcnJheUJ1ZmZlci1kYXRhXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdhcHBlbmRCdWZmZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRCdWZmZXIoYnl0ZXMsIGRvbmUpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLnByb2Nlc3NlZEFwcGVuZF8gPSB0cnVlO1xuICAgICAgdGhpcy5xdWV1ZUNhbGxiYWNrXyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5zb3VyY2VCdWZmZXJfLmFwcGVuZEJ1ZmZlcihieXRlcyk7XG4gICAgICB9LCBkb25lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hhdCBUaW1lUmFuZ2VzIGFyZSBidWZmZXJlZCBpbiB0aGUgbWFuYWdlZCBTb3VyY2VCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jd2lkbC1Tb3VyY2VCdWZmZXItYnVmZmVyZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2J1ZmZlcmVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVmZmVyZWQoKSB7XG4gICAgICBpZiAoIXRoaXMuc291cmNlQnVmZmVyXykge1xuICAgICAgICByZXR1cm4gX3ZpZGVvSnMyWydkZWZhdWx0J10uY3JlYXRlVGltZVJhbmdlcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlQnVmZmVyXy5idWZmZXJlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBRdWV1ZSBhbiB1cGRhdGUgdG8gcmVtb3ZlIGEgdGltZSByYW5nZSBmcm9tIHRoZSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgd2hlcmUgdG8gc3RhcnQgdGhlIHJlbW92YWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIHdoZXJlIHRvIGVuZCB0aGUgcmVtb3ZhbFxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyN3aWRsLVNvdXJjZUJ1ZmZlci1yZW1vdmUtdm9pZC1kb3VibGUtc3RhcnQtdW5yZXN0cmljdGVkLWRvdWJsZS1lbmRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkQXBwZW5kXykge1xuICAgICAgICB0aGlzLnF1ZXVlQ2FsbGJhY2tfKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczQuc291cmNlQnVmZmVyXy5yZW1vdmUoc3RhcnQsIGVuZCk7XG4gICAgICAgIH0sIG5vb3ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHVuZGVybHlpbmcgc291cmNlQnVmZmVyIGlzIHVwZGF0aW5nIG9yIG5vdFxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdGhlIHVwZGF0aW5nIHN0YXR1cyBvZiB0aGUgU291cmNlQnVmZmVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0aW5nKCkge1xuICAgICAgcmV0dXJuICF0aGlzLnNvdXJjZUJ1ZmZlcl8gfHwgdGhpcy5zb3VyY2VCdWZmZXJfLnVwZGF0aW5nIHx8IHRoaXMucGVuZGluZ0NhbGxiYWNrXztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQvZ2V0IHRoZSB0aW1lc3RhbXBvZmZzZXQgb24gdGhlIFNvdXJjZUJ1ZmZlclxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB0aGUgdGltZXN0YW1wIG9mZnNldFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAndGltZXN0YW1wT2Zmc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGltZXN0YW1wT2Zmc2V0KG9mZnNldCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnF1ZXVlQ2FsbGJhY2tfKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczUuc291cmNlQnVmZmVyXy50aW1lc3RhbXBPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcE9mZnNldF8gPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXBPZmZzZXRfO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFF1ZXVlIGEgY2FsbGJhY2sgdG8gcnVuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdxdWV1ZUNhbGxiYWNrXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHF1ZXVlQ2FsbGJhY2tfKGNhbGxiYWNrLCBkb25lKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrc18ucHVzaChbY2FsbGJhY2suYmluZCh0aGlzKSwgZG9uZV0pO1xuICAgICAgdGhpcy5ydW5DYWxsYmFja18oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW4gYSBxdWV1ZWQgY2FsbGJhY2tcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3J1bkNhbGxiYWNrXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bkNhbGxiYWNrXygpIHtcbiAgICAgIHZhciBjYWxsYmFja3MgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICghdGhpcy51cGRhdGluZygpICYmIHRoaXMuY2FsbGJhY2tzXy5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3NfLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0NhbGxiYWNrXyA9IGNhbGxiYWNrc1sxXTtcbiAgICAgICAgY2FsbGJhY2tzWzBdKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZGlzcG9zZSBvZiB0aGUgc291cmNlIHVwZGF0ZXIgYW5kIHRoZSB1bmRlcmx5aW5nIHNvdXJjZUJ1ZmZlclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZGlzcG9zZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlcl8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXBkYXRlZW5kJywgdGhpcy5vblVwZGF0ZWVuZENhbGxiYWNrXyk7XG4gICAgICBpZiAodGhpcy5zb3VyY2VCdWZmZXJfICYmIHRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgIHRoaXMuc291cmNlQnVmZmVyXy5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTb3VyY2VVcGRhdGVyO1xufSkoKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU291cmNlVXBkYXRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIEBmaWxlIHN5bmMtY29udHJvbGxlci5qc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94MiwgX3gzLCBfeDQpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gyLCBwcm9wZXJ0eSA9IF94MywgcmVjZWl2ZXIgPSBfeDQ7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3gyID0gcGFyZW50OyBfeDMgPSBwcm9wZXJ0eTsgX3g0ID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9tdXhKc0xpYk1wNFByb2JlID0gcmVxdWlyZSgnbXV4LmpzL2xpYi9tcDQvcHJvYmUnKTtcblxudmFyIF9tdXhKc0xpYk1wNFByb2JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX211eEpzTGliTXA0UHJvYmUpO1xuXG52YXIgX211eEpzTGliVG9vbHNUc0luc3BlY3RvckpzID0gcmVxdWlyZSgnbXV4LmpzL2xpYi90b29scy90cy1pbnNwZWN0b3IuanMnKTtcblxudmFyIF9wbGF5bGlzdCA9IHJlcXVpcmUoJy4vcGxheWxpc3QnKTtcblxudmFyIF92aWRlb0pzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ3ZpZGVvanMnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ3ZpZGVvanMnXSA6IG51bGwpO1xuXG52YXIgX3ZpZGVvSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlkZW9Kcyk7XG5cbnZhciBzeW5jUG9pbnRTdHJhdGVnaWVzID0gW1xuLy8gU3RhdGVneSBcIlZPRFwiOiBIYW5kbGUgdGhlIFZPRC1jYXNlIHdoZXJlIHRoZSBzeW5jLXBvaW50IGlzICphbHdheXMqXG4vLyAgICAgICAgICAgICAgICB0aGUgZXF1aXZhbGVuY2UgZGlzcGxheS10aW1lIDAgPT09IHNlZ21lbnQtaW5kZXggMFxue1xuICBuYW1lOiAnVk9EJyxcbiAgcnVuOiBmdW5jdGlvbiBydW4oc3luY0NvbnRyb2xsZXIsIHBsYXlsaXN0LCBkdXJhdGlvbiwgY3VycmVudFRpbWVsaW5lLCBjdXJyZW50VGltZSkge1xuICAgIGlmIChkdXJhdGlvbiAhPT0gSW5maW5pdHkpIHtcbiAgICAgIHZhciBzeW5jUG9pbnQgPSB7XG4gICAgICAgIHRpbWU6IDAsXG4gICAgICAgIHNlZ21lbnRJbmRleDogMFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHN5bmNQb2ludDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0sXG4vLyBTdGF0ZWd5IFwiUHJvZ3JhbURhdGVUaW1lXCI6IFdlIGhhdmUgYSBwcm9ncmFtLWRhdGUtdGltZSB0YWcgaW4gdGhpcyBwbGF5bGlzdFxue1xuICBuYW1lOiAnUHJvZ3JhbURhdGVUaW1lJyxcbiAgcnVuOiBmdW5jdGlvbiBydW4oc3luY0NvbnRyb2xsZXIsIHBsYXlsaXN0LCBkdXJhdGlvbiwgY3VycmVudFRpbWVsaW5lLCBjdXJyZW50VGltZSkge1xuICAgIGlmIChzeW5jQ29udHJvbGxlci5kYXRldGltZVRvRGlzcGxheVRpbWUgJiYgcGxheWxpc3QuZGF0ZVRpbWVPYmplY3QpIHtcbiAgICAgIHZhciBwbGF5bGlzdFRpbWUgPSBwbGF5bGlzdC5kYXRlVGltZU9iamVjdC5nZXRUaW1lKCkgLyAxMDAwO1xuICAgICAgdmFyIHBsYXlsaXN0U3RhcnQgPSBwbGF5bGlzdFRpbWUgKyBzeW5jQ29udHJvbGxlci5kYXRldGltZVRvRGlzcGxheVRpbWU7XG4gICAgICB2YXIgc3luY1BvaW50ID0ge1xuICAgICAgICB0aW1lOiBwbGF5bGlzdFN0YXJ0LFxuICAgICAgICBzZWdtZW50SW5kZXg6IDBcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBzeW5jUG9pbnQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59LFxuLy8gU3RhdGVneSBcIlNlZ21lbnRcIjogV2UgaGF2ZSBhIGtub3duIHRpbWUgbWFwcGluZyBmb3IgYSB0aW1lbGluZSBhbmQgYVxuLy8gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQgaW4gdGhlIGN1cnJlbnQgdGltZWxpbmUgd2l0aCB0aW1pbmcgZGF0YVxue1xuICBuYW1lOiAnU2VnbWVudCcsXG4gIHJ1bjogZnVuY3Rpb24gcnVuKHN5bmNDb250cm9sbGVyLCBwbGF5bGlzdCwgZHVyYXRpb24sIGN1cnJlbnRUaW1lbGluZSwgY3VycmVudFRpbWUpIHtcbiAgICB2YXIgc2VnbWVudHMgPSBwbGF5bGlzdC5zZWdtZW50cyB8fCBbXTtcbiAgICB2YXIgc3luY1BvaW50ID0gbnVsbDtcbiAgICB2YXIgbGFzdERpc3RhbmNlID0gbnVsbDtcblxuICAgIGN1cnJlbnRUaW1lID0gY3VycmVudFRpbWUgfHwgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cbiAgICAgIGlmIChzZWdtZW50LnRpbWVsaW5lID09PSBjdXJyZW50VGltZWxpbmUgJiYgdHlwZW9mIHNlZ21lbnQuc3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKGN1cnJlbnRUaW1lIC0gc2VnbWVudC5zdGFydCk7XG5cbiAgICAgICAgLy8gT25jZSB0aGUgZGlzdGFuY2UgYmVnaW5zIHRvIGluY3JlYXNlLCB3ZSBoYXZlIHBhc3NlZFxuICAgICAgICAvLyBjdXJyZW50VGltZSBhbmQgY2FuIHN0b3AgbG9va2luZyBmb3IgYmV0dGVyIGNhbmRpZGF0ZXNcbiAgICAgICAgaWYgKGxhc3REaXN0YW5jZSAhPT0gbnVsbCAmJiBsYXN0RGlzdGFuY2UgPCBkaXN0YW5jZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzeW5jUG9pbnQgfHwgbGFzdERpc3RhbmNlID09PSBudWxsIHx8IGxhc3REaXN0YW5jZSA+PSBkaXN0YW5jZSkge1xuICAgICAgICAgIGxhc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgIHN5bmNQb2ludCA9IHtcbiAgICAgICAgICAgIHRpbWU6IHNlZ21lbnQuc3RhcnQsXG4gICAgICAgICAgICBzZWdtZW50SW5kZXg6IGlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzeW5jUG9pbnQ7XG4gIH1cbn0sXG4vLyBTdGF0ZWd5IFwiRGlzY29udGludWl0eVwiOiBXZSBoYXZlIGEgZGlzY29udGludWl0eSB3aXRoIGEga25vd25cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LXRpbWVcbntcbiAgbmFtZTogJ0Rpc2NvbnRpbnVpdHknLFxuICBydW46IGZ1bmN0aW9uIHJ1bihzeW5jQ29udHJvbGxlciwgcGxheWxpc3QsIGR1cmF0aW9uLCBjdXJyZW50VGltZWxpbmUsIGN1cnJlbnRUaW1lKSB7XG4gICAgdmFyIHN5bmNQb2ludCA9IG51bGw7XG5cbiAgICBjdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lIHx8IDA7XG5cbiAgICBpZiAocGxheWxpc3QuZGlzY29udGludWl0eVN0YXJ0cyAmJiBwbGF5bGlzdC5kaXNjb250aW51aXR5U3RhcnRzLmxlbmd0aCkge1xuICAgICAgdmFyIGxhc3REaXN0YW5jZSA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxheWxpc3QuZGlzY29udGludWl0eVN0YXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VnbWVudEluZGV4ID0gcGxheWxpc3QuZGlzY29udGludWl0eVN0YXJ0c1tpXTtcbiAgICAgICAgdmFyIGRpc2NvbnRpbnVpdHkgPSBwbGF5bGlzdC5kaXNjb250aW51aXR5U2VxdWVuY2UgKyBpICsgMTtcbiAgICAgICAgdmFyIGRpc2NvbnRpbnVpdHlTeW5jID0gc3luY0NvbnRyb2xsZXIuZGlzY29udGludWl0aWVzW2Rpc2NvbnRpbnVpdHldO1xuXG4gICAgICAgIGlmIChkaXNjb250aW51aXR5U3luYykge1xuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKGN1cnJlbnRUaW1lIC0gZGlzY29udGludWl0eVN5bmMudGltZSk7XG5cbiAgICAgICAgICAvLyBPbmNlIHRoZSBkaXN0YW5jZSBiZWdpbnMgdG8gaW5jcmVhc2UsIHdlIGhhdmUgcGFzc2VkXG4gICAgICAgICAgLy8gY3VycmVudFRpbWUgYW5kIGNhbiBzdG9wIGxvb2tpbmcgZm9yIGJldHRlciBjYW5kaWRhdGVzXG4gICAgICAgICAgaWYgKGxhc3REaXN0YW5jZSAhPT0gbnVsbCAmJiBsYXN0RGlzdGFuY2UgPCBkaXN0YW5jZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFzeW5jUG9pbnQgfHwgbGFzdERpc3RhbmNlID09PSBudWxsIHx8IGxhc3REaXN0YW5jZSA+PSBkaXN0YW5jZSkge1xuICAgICAgICAgICAgbGFzdERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICBzeW5jUG9pbnQgPSB7XG4gICAgICAgICAgICAgIHRpbWU6IGRpc2NvbnRpbnVpdHlTeW5jLnRpbWUsXG4gICAgICAgICAgICAgIHNlZ21lbnRJbmRleDogc2VnbWVudEluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3luY1BvaW50O1xuICB9XG59LFxuLy8gU3RhdGVneSBcIlBsYXlsaXN0XCI6IFdlIGhhdmUgYSBwbGF5bGlzdCB3aXRoIGEga25vd24gbWFwcGluZyBvZlxuLy8gICAgICAgICAgICAgICAgICAgICBzZWdtZW50IGluZGV4IHRvIGRpc3BsYXkgdGltZVxue1xuICBuYW1lOiAnUGxheWxpc3QnLFxuICBydW46IGZ1bmN0aW9uIHJ1bihzeW5jQ29udHJvbGxlciwgcGxheWxpc3QsIGR1cmF0aW9uLCBjdXJyZW50VGltZWxpbmUsIGN1cnJlbnRUaW1lKSB7XG4gICAgaWYgKHBsYXlsaXN0LnN5bmNJbmZvKSB7XG4gICAgICB2YXIgc3luY1BvaW50ID0ge1xuICAgICAgICB0aW1lOiBwbGF5bGlzdC5zeW5jSW5mby50aW1lLFxuICAgICAgICBzZWdtZW50SW5kZXg6IHBsYXlsaXN0LnN5bmNJbmZvLm1lZGlhU2VxdWVuY2UgLSBwbGF5bGlzdC5tZWRpYVNlcXVlbmNlXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gc3luY1BvaW50O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufV07XG5cbmV4cG9ydHMuc3luY1BvaW50U3RyYXRlZ2llcyA9IHN5bmNQb2ludFN0cmF0ZWdpZXM7XG5cbnZhciBTeW5jQ29udHJvbGxlciA9IChmdW5jdGlvbiAoX3ZpZGVvanMkRXZlbnRUYXJnZXQpIHtcbiAgX2luaGVyaXRzKFN5bmNDb250cm9sbGVyLCBfdmlkZW9qcyRFdmVudFRhcmdldCk7XG5cbiAgZnVuY3Rpb24gU3luY0NvbnRyb2xsZXIoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTeW5jQ29udHJvbGxlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihTeW5jQ29udHJvbGxlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIC8vIFNlZ21lbnQgTG9hZGVyIHN0YXRlIHZhcmlhYmxlcy4uLlxuICAgIC8vIC4uLmZvciBzeW5jaGluZyBhY3Jvc3MgdmFyaWFudHNcbiAgICB0aGlzLmluc3BlY3RDYWNoZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvLyAuLi5mb3Igc3luY2hpbmcgYWNyb3NzIHZhcmlhbnRzXG4gICAgdGhpcy50aW1lbGluZXMgPSBbXTtcbiAgICB0aGlzLmRpc2NvbnRpbnVpdGllcyA9IFtdO1xuICAgIHRoaXMuZGF0ZXRpbWVUb0Rpc3BsYXlUaW1lID0gbnVsbDtcblxuICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICB0aGlzLmxvZ2dlcl8gPSBfdmlkZW9KczJbJ2RlZmF1bHQnXS5sb2cuYmluZChfdmlkZW9KczJbJ2RlZmF1bHQnXSwgJ3N5bmMtY29udHJvbGxlciAtPicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGEgc3luYy1wb2ludCBmb3IgdGhlIHBsYXlsaXN0IHNwZWNpZmllZFxuICAgKlxuICAgKiBBIHN5bmMtcG9pbnQgaXMgZGVmaW5lZCBhcyBhIGtub3duIG1hcHBpbmcgZnJvbSBkaXNwbGF5LXRpbWUgdG9cbiAgICogYSBzZWdtZW50LWluZGV4IGluIHRoZSBjdXJyZW50IHBsYXlsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXlsaXN0fSBwbGF5bGlzdFxuICAgKiAgICAgICAgVGhlIHBsYXlsaXN0IHRoYXQgbmVlZHMgYSBzeW5jLXBvaW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvblxuICAgKiAgICAgICAgRHVyYXRpb24gb2YgdGhlIE1lZGlhU291cmNlIChJbmZpbml0ZSBpZiBwbGF5aW5nIGEgbGl2ZSBzb3VyY2UpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50VGltZWxpbmVcbiAgICogICAgICAgIFRoZSBsYXN0IHRpbWVsaW5lIGZyb20gd2hpY2ggYSBzZWdtZW50IHdhcyBsb2FkZWRcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICogICAgICAgICAgQSBzeW5jLXBvaW50IG9iamVjdFxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoU3luY0NvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnZ2V0U3luY1BvaW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3luY1BvaW50KHBsYXlsaXN0LCBkdXJhdGlvbiwgY3VycmVudFRpbWVsaW5lLCBjdXJyZW50VGltZSkge1xuICAgICAgdmFyIHN5bmNQb2ludHMgPSB0aGlzLnJ1blN0cmF0ZWdpZXNfKHBsYXlsaXN0LCBkdXJhdGlvbiwgY3VycmVudFRpbWVsaW5lLCBjdXJyZW50VGltZSk7XG5cbiAgICAgIGlmICghc3luY1BvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gU2lnbmFsIHRoYXQgd2UgbmVlZCB0byBhdHRlbXB0IHRvIGdldCBhIHN5bmMtcG9pbnQgbWFudWFsbHlcbiAgICAgICAgLy8gYnkgZmV0Y2hpbmcgYSBzZWdtZW50IGluIHRoZSBwbGF5bGlzdCBhbmQgY29uc3RydWN0aW5nXG4gICAgICAgIC8vIGEgc3luYy1wb2ludCBmcm9tIHRoYXQgaW5mb3JtYXRpb25cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdyBmaW5kIHRoZSBzeW5jLXBvaW50IHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgY3VycmVudFRpbWUgYmVjYXVzZVxuICAgICAgLy8gdGhhdCBzaG91bGQgcmVzdWx0IGluIHRoZSBtb3N0IGFjY3VyYXRlIGd1ZXNzIGFib3V0IHdoaWNoIHNlZ21lbnRcbiAgICAgIC8vIHRvIGZldGNoXG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RTeW5jUG9pbnRfKHN5bmNQb2ludHMsIHsga2V5OiAndGltZScsIHZhbHVlOiBjdXJyZW50VGltZSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzIGV4cGlyZWQgb2ZmIHRoZSBwbGF5bGlzdCBkdXJpbmcgcGxheWJhY2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGxheWxpc3R9IHBsYXlsaXN0XG4gICAgICogICAgICAgIFBsYXlsaXN0IG9iamVjdCB0byBjYWxjdWxhdGUgZXhwaXJlZCBmcm9tXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uXG4gICAgICogICAgICAgIER1cmF0aW9uIG9mIHRoZSBNZWRpYVNvdXJjZSAoSW5maW5pdHkgaWYgcGxheWxpbmcgYSBsaXZlIHNvdXJjZSlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfG51bGx9XG4gICAgICogICAgICAgICAgVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzIGV4cGlyZWQgb2ZmIHRoZSBwbGF5bGlzdCBkdXJpbmcgcGxheWJhY2suIE51bGxcbiAgICAgKiAgICAgICAgICBpZiBubyBzeW5jLXBvaW50cyBmb3IgdGhlIHBsYXlsaXN0IGNhbiBiZSBmb3VuZC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2dldEV4cGlyZWRUaW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RXhwaXJlZFRpbWUocGxheWxpc3QsIGR1cmF0aW9uKSB7XG4gICAgICBpZiAoIXBsYXlsaXN0IHx8ICFwbGF5bGlzdC5zZWdtZW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHN5bmNQb2ludHMgPSB0aGlzLnJ1blN0cmF0ZWdpZXNfKHBsYXlsaXN0LCBkdXJhdGlvbiwgcGxheWxpc3QuZGlzY29udGludWl0eVNlcXVlbmNlLCAwKTtcblxuICAgICAgLy8gV2l0aG91dCBzeW5jLXBvaW50cywgdGhlcmUgaXMgbm90IGVub3VnaCBpbmZvcm1hdGlvbiB0byBkZXRlcm1pbmUgdGhlIGV4cGlyZWQgdGltZVxuICAgICAgaWYgKCFzeW5jUG9pbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHN5bmNQb2ludCA9IHRoaXMuc2VsZWN0U3luY1BvaW50XyhzeW5jUG9pbnRzLCB7XG4gICAgICAgIGtleTogJ3NlZ21lbnRJbmRleCcsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgdGhlIHN5bmMtcG9pbnQgaXMgYmV5b25kIHRoZSBzdGFydCBvZiB0aGUgcGxheWxpc3QsIHdlIHdhbnQgdG8gc3VidHJhY3QgdGhlXG4gICAgICAvLyBkdXJhdGlvbiBmcm9tIGluZGV4IDAgdG8gc3luY1BvaW50LnNlZ21lbnRJbmRleCBpbnN0ZWFkIG9mIGFkZGluZy5cbiAgICAgIGlmIChzeW5jUG9pbnQuc2VnbWVudEluZGV4ID4gMCkge1xuICAgICAgICBzeW5jUG9pbnQudGltZSAqPSAtMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1hdGguYWJzKHN5bmNQb2ludC50aW1lICsgKDAsIF9wbGF5bGlzdC5zdW1EdXJhdGlvbnMpKHBsYXlsaXN0LCBzeW5jUG9pbnQuc2VnbWVudEluZGV4LCAwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBlYWNoIHN5bmMtcG9pbnQgc3RyYXRlZ3kgYW5kIHJldHVybnMgYSBsaXN0IG9mIHN5bmMtcG9pbnRzIHJldHVybmVkIGJ5IHRoZVxuICAgICAqIHN0cmF0ZWdpZXNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQbGF5bGlzdH0gcGxheWxpc3RcbiAgICAgKiAgICAgICAgVGhlIHBsYXlsaXN0IHRoYXQgbmVlZHMgYSBzeW5jLXBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uXG4gICAgICogICAgICAgIER1cmF0aW9uIG9mIHRoZSBNZWRpYVNvdXJjZSAoSW5maW5pdHkgaWYgcGxheWluZyBhIGxpdmUgc291cmNlKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50VGltZWxpbmVcbiAgICAgKiAgICAgICAgVGhlIGxhc3QgdGltZWxpbmUgZnJvbSB3aGljaCBhIHNlZ21lbnQgd2FzIGxvYWRlZFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiAgICAgICAgICBBIGxpc3Qgb2Ygc3luYy1wb2ludCBvYmplY3RzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdydW5TdHJhdGVnaWVzXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1blN0cmF0ZWdpZXNfKHBsYXlsaXN0LCBkdXJhdGlvbiwgY3VycmVudFRpbWVsaW5lLCBjdXJyZW50VGltZSkge1xuICAgICAgdmFyIHN5bmNQb2ludHMgPSBbXTtcblxuICAgICAgLy8gVHJ5IHRvIGZpbmQgYSBzeW5jLXBvaW50IGluIGJ5IHV0aWxpemluZyB2YXJpb3VzIHN0cmF0ZWdpZXMuLi5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3luY1BvaW50U3RyYXRlZ2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3RyYXRlZ3kgPSBzeW5jUG9pbnRTdHJhdGVnaWVzW2ldO1xuICAgICAgICB2YXIgc3luY1BvaW50ID0gc3RyYXRlZ3kucnVuKHRoaXMsIHBsYXlsaXN0LCBkdXJhdGlvbiwgY3VycmVudFRpbWVsaW5lLCBjdXJyZW50VGltZSk7XG5cbiAgICAgICAgaWYgKHN5bmNQb2ludCkge1xuICAgICAgICAgIHN5bmNQb2ludC5zdHJhdGVneSA9IHN0cmF0ZWd5Lm5hbWU7XG4gICAgICAgICAgc3luY1BvaW50cy5wdXNoKHtcbiAgICAgICAgICAgIHN0cmF0ZWd5OiBzdHJhdGVneS5uYW1lLFxuICAgICAgICAgICAgc3luY1BvaW50OiBzeW5jUG9pbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmxvZ2dlcl8oJ3N5bmNQb2ludCBmb3VuZCB2aWEgPCcgKyBzdHJhdGVneS5uYW1lICsgJz46Jywgc3luY1BvaW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3luY1BvaW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBzeW5jLXBvaW50IG5lYXJlc3QgdGhlIHNwZWNpZmllZCB0YXJnZXRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3luY1BvaW50c1xuICAgICAqICAgICAgICBMaXN0IG9mIHN5bmMtcG9pbnRzIHRvIHNlbGVjdCBmcm9tXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqICAgICAgICBPYmplY3Qgc3BlY2lmeWluZyB0aGUgcHJvcGVydHkgYW5kIHZhbHVlIHdlIGFyZSB0YXJnZXRpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0LmtleVxuICAgICAqICAgICAgICBTcGVjaWZpZXMgdGhlIHByb3BlcnR5IHRvIHRhcmdldC4gTXVzdCBiZSBlaXRoZXIgJ3RpbWUnIG9yICdzZWdtZW50SW5kZXgnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRhcmdldC52YWx1ZVxuICAgICAqICAgICAgICBUaGUgdmFsdWUgdG8gdGFyZ2V0IGZvciB0aGUgc3BlY2lmaWVkIGtleS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqICAgICAgICAgIFRoZSBzeW5jLXBvaW50IG5lYXJlc3QgdGhlIHRhcmdldFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnc2VsZWN0U3luY1BvaW50XycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdFN5bmNQb2ludF8oc3luY1BvaW50cywgdGFyZ2V0KSB7XG4gICAgICB2YXIgYmVzdFN5bmNQb2ludCA9IHN5bmNQb2ludHNbMF0uc3luY1BvaW50O1xuICAgICAgdmFyIGJlc3REaXN0YW5jZSA9IE1hdGguYWJzKHN5bmNQb2ludHNbMF0uc3luY1BvaW50W3RhcmdldC5rZXldIC0gdGFyZ2V0LnZhbHVlKTtcbiAgICAgIHZhciBiZXN0U3RyYXRlZ3kgPSBzeW5jUG9pbnRzWzBdLnN0cmF0ZWd5O1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHN5bmNQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld0Rpc3RhbmNlID0gTWF0aC5hYnMoc3luY1BvaW50c1tpXS5zeW5jUG9pbnRbdGFyZ2V0LmtleV0gLSB0YXJnZXQudmFsdWUpO1xuXG4gICAgICAgIGlmIChuZXdEaXN0YW5jZSA8IGJlc3REaXN0YW5jZSkge1xuICAgICAgICAgIGJlc3REaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgIGJlc3RTeW5jUG9pbnQgPSBzeW5jUG9pbnRzW2ldLnN5bmNQb2ludDtcbiAgICAgICAgICBiZXN0U3RyYXRlZ3kgPSBzeW5jUG9pbnRzW2ldLnN0cmF0ZWd5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nZ2VyXygnc3luY1BvaW50IHdpdGggc3RyYXRlZ3kgPCcgKyBiZXN0U3RyYXRlZ3kgKyAnPiBjaG9zZW46ICcsIGJlc3RTeW5jUG9pbnQpO1xuICAgICAgcmV0dXJuIGJlc3RTeW5jUG9pbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2F2ZSBhbnkgbWV0YS1kYXRhIHByZXNlbnQgb24gdGhlIHNlZ21lbnRzIHdoZW4gc2VnbWVudHMgbGVhdmVcbiAgICAgKiB0aGUgbGl2ZSB3aW5kb3cgdG8gdGhlIHBsYXlsaXN0IHRvIGFsbG93IGZvciBzeW5jaHJvbml6YXRpb24gYXQgdGhlXG4gICAgICogcGxheWxpc3QgbGV2ZWwgbGF0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BsYXlsaXN0fSBvbGRQbGF5bGlzdCAtIFRoZSBwcmV2aW91cyBhY3RpdmUgcGxheWxpc3RcbiAgICAgKiBAcGFyYW0ge1BsYXlsaXN0fSBuZXdQbGF5bGlzdCAtIFRoZSB1cGRhdGVkIGFuZCBtb3N0IGN1cnJlbnQgcGxheWxpc3RcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NhdmVFeHBpcmVkU2VnbWVudEluZm8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlRXhwaXJlZFNlZ21lbnRJbmZvKG9sZFBsYXlsaXN0LCBuZXdQbGF5bGlzdCkge1xuICAgICAgdmFyIG1lZGlhU2VxdWVuY2VEaWZmID0gbmV3UGxheWxpc3QubWVkaWFTZXF1ZW5jZSAtIG9sZFBsYXlsaXN0Lm1lZGlhU2VxdWVuY2U7XG5cbiAgICAgIC8vIFdoZW4gYSBzZWdtZW50IGV4cGlyZXMgZnJvbSB0aGUgcGxheWxpc3QgYW5kIGl0IGhhcyBhIHN0YXJ0IHRpbWVcbiAgICAgIC8vIHNhdmUgdGhhdCBpbmZvcm1hdGlvbiBhcyBhIHBvc3NpYmxlIHN5bmMtcG9pbnQgcmVmZXJlbmNlIGluIGZ1dHVyZVxuICAgICAgZm9yICh2YXIgaSA9IG1lZGlhU2VxdWVuY2VEaWZmIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGxhc3RSZW1vdmVkU2VnbWVudCA9IG9sZFBsYXlsaXN0LnNlZ21lbnRzW2ldO1xuXG4gICAgICAgIGlmIChsYXN0UmVtb3ZlZFNlZ21lbnQgJiYgdHlwZW9mIGxhc3RSZW1vdmVkU2VnbWVudC5zdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBuZXdQbGF5bGlzdC5zeW5jSW5mbyA9IHtcbiAgICAgICAgICAgIG1lZGlhU2VxdWVuY2U6IG9sZFBsYXlsaXN0Lm1lZGlhU2VxdWVuY2UgKyBpLFxuICAgICAgICAgICAgdGltZTogbGFzdFJlbW92ZWRTZWdtZW50LnN0YXJ0XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmxvZ2dlcl8oJ3BsYXlsaXN0IHN5bmM6JywgbmV3UGxheWxpc3Quc3luY0luZm8pO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignc3luY2luZm91cGRhdGUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmUgdGhlIG1hcHBpbmcgZnJvbSBwbGF5bGlzdCdzIFByb2dyYW1EYXRlVGltZSB0byBkaXNwbGF5LiBUaGlzIHNob3VsZFxuICAgICAqIG9ubHkgZXZlciBoYXBwZW4gb25jZSBhdCB0aGUgc3RhcnQgb2YgcGxheWJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BsYXlsaXN0fSBwbGF5bGlzdCAtIFRoZSBjdXJyZW50bHkgYWN0aXZlIHBsYXlsaXN0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzZXREYXRlVGltZU1hcHBpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREYXRlVGltZU1hcHBpbmcocGxheWxpc3QpIHtcbiAgICAgIGlmICghdGhpcy5kYXRldGltZVRvRGlzcGxheVRpbWUgJiYgcGxheWxpc3QuZGF0ZVRpbWVPYmplY3QpIHtcbiAgICAgICAgdmFyIHBsYXlsaXN0VGltZXN0YW1wID0gcGxheWxpc3QuZGF0ZVRpbWVPYmplY3QuZ2V0VGltZSgpIC8gMTAwMDtcblxuICAgICAgICB0aGlzLmRhdGV0aW1lVG9EaXNwbGF5VGltZSA9IC1wbGF5bGlzdFRpbWVzdGFtcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgc3RhdGUgb2YgdGhlIGluc3BlY3Rpb24gY2FjaGUgd2hlbiB3ZSBkbyBhIHJlbmRpdGlvblxuICAgICAqIHN3aXRjaFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuaW5zcGVjdENhY2hlXyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9iZSBvciBpbnNwZWN0IGEgZm1wNCBvciBhbiBtcGVnMi10cyBzZWdtZW50IHRvIGRldGVybWluZSB0aGUgc3RhcnRcbiAgICAgKiBhbmQgZW5kIG9mIHRoZSBzZWdtZW50IGluIGl0J3MgaW50ZXJuYWwgXCJtZWRpYSB0aW1lXCIuIFVzZWQgdG8gZ2VuZXJhdGVcbiAgICAgKiBtYXBwaW5ncyBmcm9tIHRoYXQgaW50ZXJuYWwgXCJtZWRpYSB0aW1lXCIgdG8gdGhlIGRpc3BsYXkgdGltZSB0aGF0IGlzXG4gICAgICogc2hvd24gb24gdGhlIHBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2VnbWVudEluZm99IHNlZ21lbnRJbmZvIC0gVGhlIGN1cnJlbnQgYWN0aXZlIHJlcXVlc3QgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3Byb2JlU2VnbWVudEluZm8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9iZVNlZ21lbnRJbmZvKHNlZ21lbnRJbmZvKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRJbmZvLnNlZ21lbnQ7XG4gICAgICB2YXIgcGxheWxpc3QgPSBzZWdtZW50SW5mby5wbGF5bGlzdDtcbiAgICAgIHZhciB0aW1pbmdJbmZvID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoc2VnbWVudC5tYXApIHtcbiAgICAgICAgdGltaW5nSW5mbyA9IHRoaXMucHJvYmVNcDRTZWdtZW50XyhzZWdtZW50SW5mbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1pbmdJbmZvID0gdGhpcy5wcm9iZVRzU2VnbWVudF8oc2VnbWVudEluZm8pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGltaW5nSW5mbykge1xuICAgICAgICBpZiAodGhpcy5jYWxjdWxhdGVTZWdtZW50VGltZU1hcHBpbmdfKHNlZ21lbnRJbmZvLCB0aW1pbmdJbmZvKSkge1xuICAgICAgICAgIHRoaXMuc2F2ZURpc2NvbnRpbnVpdHlTeW5jSW5mb18oc2VnbWVudEluZm8pO1xuXG4gICAgICAgICAgLy8gSWYgdGhlIHBsYXlsaXN0IGRvZXMgbm90IGhhdmUgc3luYyBpbmZvcm1hdGlvbiB5ZXQsIHJlY29yZCB0aGF0IGluZm9ybWF0aW9uXG4gICAgICAgICAgLy8gbm93IHdpdGggc2VnbWVudCB0aW1pbmcgaW5mb3JtYXRpb25cbiAgICAgICAgICBpZiAoIXBsYXlsaXN0LnN5bmNJbmZvKSB7XG4gICAgICAgICAgICBwbGF5bGlzdC5zeW5jSW5mbyA9IHtcbiAgICAgICAgICAgICAgbWVkaWFTZXF1ZW5jZTogcGxheWxpc3QubWVkaWFTZXF1ZW5jZSArIHNlZ21lbnRJbmZvLm1lZGlhSW5kZXgsXG4gICAgICAgICAgICAgIHRpbWU6IHNlZ21lbnQuc3RhcnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aW1pbmdJbmZvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2JlIGFuIGZtcDQgb3IgYW4gbXBlZzItdHMgc2VnbWVudCB0byBkZXRlcm1pbmUgdGhlIHN0YXJ0IG9mIHRoZSBzZWdtZW50XG4gICAgICogaW4gaXQncyBpbnRlcm5hbCBcIm1lZGlhIHRpbWVcIi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTZWdtZW50SW5mb30gc2VnbWVudEluZm8gLSBUaGUgY3VycmVudCBhY3RpdmUgcmVxdWVzdCBpbmZvcm1hdGlvblxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHN0YXJ0IGFuZCBlbmQgdGltZSBvZiB0aGUgY3VycmVudCBzZWdtZW50IGluIFwibWVkaWEgdGltZVwiXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9iZU1wNFNlZ21lbnRfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvYmVNcDRTZWdtZW50XyhzZWdtZW50SW5mbykge1xuICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50SW5mby5zZWdtZW50O1xuICAgICAgdmFyIHRpbWVzY2FsZXMgPSBfbXV4SnNMaWJNcDRQcm9iZTJbJ2RlZmF1bHQnXS50aW1lc2NhbGUoc2VnbWVudC5tYXAuYnl0ZXMpO1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IF9tdXhKc0xpYk1wNFByb2JlMlsnZGVmYXVsdCddLnN0YXJ0VGltZSh0aW1lc2NhbGVzLCBzZWdtZW50SW5mby5ieXRlcyk7XG5cbiAgICAgIGlmIChzZWdtZW50SW5mby50aW1lc3RhbXBPZmZzZXQgIT09IG51bGwpIHtcbiAgICAgICAgc2VnbWVudEluZm8udGltZXN0YW1wT2Zmc2V0IC09IHN0YXJ0VGltZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0VGltZSxcbiAgICAgICAgZW5kOiBzdGFydFRpbWUgKyBzZWdtZW50LmR1cmF0aW9uXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2JlIGFuIG1wZWcyLXRzIHNlZ21lbnQgdG8gZGV0ZXJtaW5lIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSBzZWdtZW50XG4gICAgICogaW4gaXQncyBpbnRlcm5hbCBcIm1lZGlhIHRpbWVcIi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTZWdtZW50SW5mb30gc2VnbWVudEluZm8gLSBUaGUgY3VycmVudCBhY3RpdmUgcmVxdWVzdCBpbmZvcm1hdGlvblxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHN0YXJ0IGFuZCBlbmQgdGltZSBvZiB0aGUgY3VycmVudCBzZWdtZW50IGluIFwibWVkaWEgdGltZVwiXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9iZVRzU2VnbWVudF8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9iZVRzU2VnbWVudF8oc2VnbWVudEluZm8pIHtcbiAgICAgIHZhciB0aW1lSW5mbyA9ICgwLCBfbXV4SnNMaWJUb29sc1RzSW5zcGVjdG9ySnMuaW5zcGVjdCkoc2VnbWVudEluZm8uYnl0ZXMsIHRoaXMuaW5zcGVjdENhY2hlXyk7XG4gICAgICB2YXIgc2VnbWVudFN0YXJ0VGltZSA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBzZWdtZW50RW5kVGltZSA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKCF0aW1lSW5mbykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRpbWVJbmZvLnZpZGVvICYmIHRpbWVJbmZvLnZpZGVvLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLmluc3BlY3RDYWNoZV8gPSB0aW1lSW5mby52aWRlb1sxXS5kdHM7XG4gICAgICAgIHNlZ21lbnRTdGFydFRpbWUgPSB0aW1lSW5mby52aWRlb1swXS5kdHNUaW1lO1xuICAgICAgICBzZWdtZW50RW5kVGltZSA9IHRpbWVJbmZvLnZpZGVvWzFdLmR0c1RpbWU7XG4gICAgICB9IGVsc2UgaWYgKHRpbWVJbmZvLmF1ZGlvICYmIHRpbWVJbmZvLmF1ZGlvLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLmluc3BlY3RDYWNoZV8gPSB0aW1lSW5mby5hdWRpb1sxXS5kdHM7XG4gICAgICAgIHNlZ21lbnRTdGFydFRpbWUgPSB0aW1lSW5mby5hdWRpb1swXS5kdHNUaW1lO1xuICAgICAgICBzZWdtZW50RW5kVGltZSA9IHRpbWVJbmZvLmF1ZGlvWzFdLmR0c1RpbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzZWdtZW50U3RhcnRUaW1lLFxuICAgICAgICBlbmQ6IHNlZ21lbnRFbmRUaW1lLFxuICAgICAgICBjb250YWluc1ZpZGVvOiB0aW1lSW5mby52aWRlbyAmJiB0aW1lSW5mby52aWRlby5sZW5ndGggPT09IDIsXG4gICAgICAgIGNvbnRhaW5zQXVkaW86IHRpbWVJbmZvLmF1ZGlvICYmIHRpbWVJbmZvLmF1ZGlvLmxlbmd0aCA9PT0gMlxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0aW1lc3RhbXBPZmZzZXRGb3JUaW1lbGluZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWVzdGFtcE9mZnNldEZvclRpbWVsaW5lKHRpbWVsaW5lKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMudGltZWxpbmVzW3RpbWVsaW5lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aW1lbGluZXNbdGltZWxpbmVdLnRpbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWFwcGluZ0ZvclRpbWVsaW5lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwcGluZ0ZvclRpbWVsaW5lKHRpbWVsaW5lKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMudGltZWxpbmVzW3RpbWVsaW5lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aW1lbGluZXNbdGltZWxpbmVdLm1hcHBpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoZSBcIm1lZGlhIHRpbWVcIiBmb3IgYSBzZWdtZW50IHRvIGdlbmVyYXRlIGEgbWFwcGluZyB0byBcImRpc3BsYXkgdGltZVwiIGFuZFxuICAgICAqIHNhdmUgdGhhdCBkaXNwbGF5IHRpbWUgdG8gdGhlIHNlZ21lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U2VnbWVudEluZm99IHNlZ21lbnRJbmZvXG4gICAgICogICAgICAgIFRoZSBjdXJyZW50IGFjdGl2ZSByZXF1ZXN0IGluZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRpbWluZ0luZm9cbiAgICAgKiAgICAgICAgVGhlIHN0YXJ0IGFuZCBlbmQgdGltZSBvZiB0aGUgY3VycmVudCBzZWdtZW50IGluIFwibWVkaWEgdGltZVwiXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogICAgICAgICAgUmV0dXJucyBmYWxzZSBpZiBzZWdtZW50IHRpbWUgbWFwcGluZyBjb3VsZCBub3QgYmUgY2FsY3VsYXRlZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlU2VnbWVudFRpbWVNYXBwaW5nXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVNlZ21lbnRUaW1lTWFwcGluZ18oc2VnbWVudEluZm8sIHRpbWluZ0luZm8pIHtcbiAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudEluZm8uc2VnbWVudDtcbiAgICAgIHZhciBtYXBwaW5nT2JqID0gdGhpcy50aW1lbGluZXNbc2VnbWVudEluZm8udGltZWxpbmVdO1xuXG4gICAgICBpZiAoc2VnbWVudEluZm8udGltZXN0YW1wT2Zmc2V0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyXygndHNPOicsIHNlZ21lbnRJbmZvLnRpbWVzdGFtcE9mZnNldCk7XG5cbiAgICAgICAgbWFwcGluZ09iaiA9IHtcbiAgICAgICAgICB0aW1lOiBzZWdtZW50SW5mby5zdGFydE9mU2VnbWVudCxcbiAgICAgICAgICBtYXBwaW5nOiBzZWdtZW50SW5mby5zdGFydE9mU2VnbWVudCAtIHRpbWluZ0luZm8uc3RhcnRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50aW1lbGluZXNbc2VnbWVudEluZm8udGltZWxpbmVdID0gbWFwcGluZ09iajtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd0aW1lc3RhbXBvZmZzZXQnKTtcblxuICAgICAgICBzZWdtZW50LnN0YXJ0ID0gc2VnbWVudEluZm8uc3RhcnRPZlNlZ21lbnQ7XG4gICAgICAgIHNlZ21lbnQuZW5kID0gdGltaW5nSW5mby5lbmQgKyBtYXBwaW5nT2JqLm1hcHBpbmc7XG4gICAgICB9IGVsc2UgaWYgKG1hcHBpbmdPYmopIHtcbiAgICAgICAgc2VnbWVudC5zdGFydCA9IHRpbWluZ0luZm8uc3RhcnQgKyBtYXBwaW5nT2JqLm1hcHBpbmc7XG4gICAgICAgIHNlZ21lbnQuZW5kID0gdGltaW5nSW5mby5lbmQgKyBtYXBwaW5nT2JqLm1hcHBpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVhY2ggdGltZSB3ZSBoYXZlIGRpc2NvbnRpbnVpdHkgaW4gdGhlIHBsYXlsaXN0LCBhdHRlbXB0IHRvIGNhbGN1bGF0ZSB0aGUgbG9jYXRpb25cbiAgICAgKiBpbiBkaXNwbGF5IG9mIHRoZSBzdGFydCBvZiB0aGUgZGlzY29udGludWl0eSBhbmQgc2F2ZSB0aGF0LiBXZSBhbHNvIHNhdmUgYW4gYWNjdXJhY3lcbiAgICAgKiB2YWx1ZSBzbyB0aGF0IHdlIHNhdmUgdmFsdWVzIHdpdGggdGhlIG1vc3QgYWNjdXJhY3kgKGNsb3Nlc3QgdG8gMC4pXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U2VnbWVudEluZm99IHNlZ21lbnRJbmZvIC0gVGhlIGN1cnJlbnQgYWN0aXZlIHJlcXVlc3QgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NhdmVEaXNjb250aW51aXR5U3luY0luZm9fJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2F2ZURpc2NvbnRpbnVpdHlTeW5jSW5mb18oc2VnbWVudEluZm8pIHtcbiAgICAgIHZhciBwbGF5bGlzdCA9IHNlZ21lbnRJbmZvLnBsYXlsaXN0O1xuICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50SW5mby5zZWdtZW50O1xuXG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBzZWdtZW50IGlzIGEgZGlzY29udGludWl0eSB0aGVuIHdlIGtub3cgZXhhY3RseSB3aGVyZVxuICAgICAgLy8gdGhlIHN0YXJ0IG9mIHRoZSByYW5nZSBhbmQgaXQncyBhY2N1cmFjeSBpcyAwIChncmVhdGVyIGFjY3VyYWN5IHZhbHVlc1xuICAgICAgLy8gbWVhbiBtb3JlIGFwcHJveGltYXRpb24pXG4gICAgICBpZiAoc2VnbWVudC5kaXNjb250aW51aXR5KSB7XG4gICAgICAgIHRoaXMuZGlzY29udGludWl0aWVzW3NlZ21lbnQudGltZWxpbmVdID0ge1xuICAgICAgICAgIHRpbWU6IHNlZ21lbnQuc3RhcnQsXG4gICAgICAgICAgYWNjdXJhY3k6IDBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAocGxheWxpc3QuZGlzY29udGludWl0eVN0YXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gU2VhcmNoIGZvciBmdXR1cmUgZGlzY29udGludWl0aWVzIHRoYXQgd2UgY2FuIHByb3ZpZGUgYmV0dGVyIHRpbWluZ1xuICAgICAgICAvLyBpbmZvcm1hdGlvbiBmb3IgYW5kIHNhdmUgdGhhdCBpbmZvcm1hdGlvbiBmb3Igc3luYyBwdXJwb3Nlc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYXlsaXN0LmRpc2NvbnRpbnVpdHlTdGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc2VnbWVudEluZGV4ID0gcGxheWxpc3QuZGlzY29udGludWl0eVN0YXJ0c1tpXTtcbiAgICAgICAgICB2YXIgZGlzY29udGludWl0eSA9IHBsYXlsaXN0LmRpc2NvbnRpbnVpdHlTZXF1ZW5jZSArIGkgKyAxO1xuICAgICAgICAgIHZhciBtZWRpYUluZGV4RGlmZiA9IHNlZ21lbnRJbmRleCAtIHNlZ21lbnRJbmZvLm1lZGlhSW5kZXg7XG4gICAgICAgICAgdmFyIGFjY3VyYWN5ID0gTWF0aC5hYnMobWVkaWFJbmRleERpZmYpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmRpc2NvbnRpbnVpdGllc1tkaXNjb250aW51aXR5XSB8fCB0aGlzLmRpc2NvbnRpbnVpdGllc1tkaXNjb250aW51aXR5XS5hY2N1cmFjeSA+IGFjY3VyYWN5KSB7XG4gICAgICAgICAgICB2YXIgdGltZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgaWYgKG1lZGlhSW5kZXhEaWZmIDwgMCkge1xuICAgICAgICAgICAgICB0aW1lID0gc2VnbWVudC5zdGFydCAtICgwLCBfcGxheWxpc3Quc3VtRHVyYXRpb25zKShwbGF5bGlzdCwgc2VnbWVudEluZm8ubWVkaWFJbmRleCwgc2VnbWVudEluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRpbWUgPSBzZWdtZW50LmVuZCArICgwLCBfcGxheWxpc3Quc3VtRHVyYXRpb25zKShwbGF5bGlzdCwgc2VnbWVudEluZm8ubWVkaWFJbmRleCArIDEsIHNlZ21lbnRJbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlzY29udGludWl0aWVzW2Rpc2NvbnRpbnVpdHldID0ge1xuICAgICAgICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICAgICAgICBhY2N1cmFjeTogYWNjdXJhY3lcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBkZWJ1Z2dpbmcgbG9nZ2VyIG5vb3AgdGhhdCBpcyBzZXQgdG8gY29uc29sZS5sb2cgb25seSBpZiBkZWJ1Z2dpbmdcbiAgICAgKiBpcyBlbmFibGVkIGdsb2JhbGx5XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnbG9nZ2VyXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvZ2dlcl8oKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIFN5bmNDb250cm9sbGVyO1xufSkoX3ZpZGVvSnMyWydkZWZhdWx0J10uRXZlbnRUYXJnZXQpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTeW5jQ29udHJvbGxlcjtcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuL3BsYXlsaXN0XCI6MTEsXCJtdXguanMvbGliL21wNC9wcm9iZVwiOjU3LFwibXV4LmpzL2xpYi90b29scy90cy1pbnNwZWN0b3IuanNcIjo1OX1dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBAZmlsZSAtIGNvZGVjcy5qcyAtIEhhbmRsZXMgdGFza3MgcmVnYXJkaW5nIGNvZGVjIHN0cmluZ3Mgc3VjaCBhcyB0cmFuc2xhdGluZyB0aGVtIHRvXG4gKiBjb2RlYyBzdHJpbmdzLCBvciB0cmFuc2xhdGluZyBjb2RlYyBzdHJpbmdzIGludG8gb2JqZWN0cyB0aGF0IGNhbiBiZSBleGFtaW5lZC5cbiAqL1xuXG4vKipcbiAqIFBhcnNlcyBhIGNvZGVjIHN0cmluZyB0byByZXRyaWV2ZSB0aGUgbnVtYmVyIG9mIGNvZGVjcyBzcGVjaWZpZWQsXG4gKiB0aGUgdmlkZW8gY29kZWMgYW5kIG9iamVjdCB0eXBlIGluZGljYXRvciwgYW5kIHRoZSBhdWRpbyBwcm9maWxlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgcGFyc2VDb2RlY3MgPSBmdW5jdGlvbiBwYXJzZUNvZGVjcygpIHtcbiAgdmFyIGNvZGVjcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/ICcnIDogYXJndW1lbnRzWzBdO1xuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgY29kZWNDb3VudDogMFxuICB9O1xuICB2YXIgcGFyc2VkID0gdW5kZWZpbmVkO1xuXG4gIHJlc3VsdC5jb2RlY0NvdW50ID0gY29kZWNzLnNwbGl0KCcsJykubGVuZ3RoO1xuICByZXN1bHQuY29kZWNDb3VudCA9IHJlc3VsdC5jb2RlY0NvdW50IHx8IDI7XG5cbiAgLy8gcGFyc2UgdGhlIHZpZGVvIGNvZGVjXG4gIHBhcnNlZCA9IC8oXnxcXHN8LCkrKGF2YzEpKFteICxdKikvaS5leGVjKGNvZGVjcyk7XG4gIGlmIChwYXJzZWQpIHtcbiAgICByZXN1bHQudmlkZW9Db2RlYyA9IHBhcnNlZFsyXTtcbiAgICByZXN1bHQudmlkZW9PYmplY3RUeXBlSW5kaWNhdG9yID0gcGFyc2VkWzNdO1xuICB9XG5cbiAgLy8gcGFyc2UgdGhlIGxhc3QgZmllbGQgb2YgdGhlIGF1ZGlvIGNvZGVjXG4gIHJlc3VsdC5hdWRpb1Byb2ZpbGUgPSAvKF58XFxzfCwpK21wNGEuWzAtOUEtRmEtZl0rXFwuKFswLTlBLUZhLWZdKykvaS5leGVjKGNvZGVjcyk7XG4gIHJlc3VsdC5hdWRpb1Byb2ZpbGUgPSByZXN1bHQuYXVkaW9Qcm9maWxlICYmIHJlc3VsdC5hdWRpb1Byb2ZpbGVbMl07XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLnBhcnNlQ29kZWNzID0gcGFyc2VDb2RlY3M7XG59LHt9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIEBmaWxlIHZ0dC1zZWdtZW50LWxvYWRlci5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeDMsIF94NCwgX3g1KSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94MywgcHJvcGVydHkgPSBfeDQsIHJlY2VpdmVyID0gX3g1OyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94MyA9IHBhcmVudDsgX3g0ID0gcHJvcGVydHk7IF94NSA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfc2VnbWVudExvYWRlciA9IHJlcXVpcmUoJy4vc2VnbWVudC1sb2FkZXInKTtcblxudmFyIF9zZWdtZW50TG9hZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NlZ21lbnRMb2FkZXIpO1xuXG52YXIgX3ZpZGVvSnMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sndmlkZW9qcyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndmlkZW9qcyddIDogbnVsbCk7XG5cbnZhciBfdmlkZW9KczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aWRlb0pzKTtcblxudmFyIF9nbG9iYWxXaW5kb3cgPSByZXF1aXJlKCdnbG9iYWwvd2luZG93Jyk7XG5cbnZhciBfZ2xvYmFsV2luZG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbFdpbmRvdyk7XG5cbnZhciBfdmlkZW9qc0NvbnRyaWJNZWRpYVNvdXJjZXNFczVSZW1vdmVDdWVzRnJvbVRyYWNrSnMgPSByZXF1aXJlKCd2aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9lczUvcmVtb3ZlLWN1ZXMtZnJvbS10cmFjay5qcycpO1xuXG52YXIgX3ZpZGVvanNDb250cmliTWVkaWFTb3VyY2VzRXM1UmVtb3ZlQ3Vlc0Zyb21UcmFja0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvanNDb250cmliTWVkaWFTb3VyY2VzRXM1UmVtb3ZlQ3Vlc0Zyb21UcmFja0pzKTtcblxudmFyIF9iaW5VdGlscyA9IHJlcXVpcmUoJy4vYmluLXV0aWxzJyk7XG5cbnZhciBWVFRfTElORV9URVJNSU5BVE9SUyA9IG5ldyBVaW50OEFycmF5KCdcXG5cXG4nLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKGNoYXIpIHtcbiAgcmV0dXJuIGNoYXIuY2hhckNvZGVBdCgwKTtcbn0pKTtcblxudmFyIHVpbnRUb1N0cmluZyA9IGZ1bmN0aW9uIHVpbnRUb1N0cmluZyh1aW50QXJyYXkpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdWludEFycmF5KTtcbn07XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgbWFuYWdlcyBzZWdtZW50IGxvYWRpbmcgYW5kIGFwcGVuZGluZy5cbiAqXG4gKiBAY2xhc3MgVlRUU2VnbWVudExvYWRlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgcmVxdWlyZWQgYW5kIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEBleHRlbmRzIHZpZGVvanMuRXZlbnRUYXJnZXRcbiAqL1xuXG52YXIgVlRUU2VnbWVudExvYWRlciA9IChmdW5jdGlvbiAoX1NlZ21lbnRMb2FkZXIpIHtcbiAgX2luaGVyaXRzKFZUVFNlZ21lbnRMb2FkZXIsIF9TZWdtZW50TG9hZGVyKTtcblxuICBmdW5jdGlvbiBWVFRTZWdtZW50TG9hZGVyKHNldHRpbmdzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWVFRTZWdtZW50TG9hZGVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFZUVFNlZ21lbnRMb2FkZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzLCBzZXR0aW5ncywgb3B0aW9ucyk7XG5cbiAgICAvLyBTZWdtZW50TG9hZGVyIHJlcXVpcmVzIGEgTWVkaWFTb3VyY2UgYmUgc3BlY2lmaWVkIG9yIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3I7XG4gICAgLy8gaG93ZXZlciwgVlRUU2VnbWVudExvYWRlciBoYXMgbm8gbmVlZCBvZiBhIG1lZGlhIHNvdXJjZSwgc28gZGVsZXRlIHRoZSByZWZlcmVuY2VcbiAgICB0aGlzLm1lZGlhU291cmNlXyA9IG51bGw7XG5cbiAgICB0aGlzLnN1YnRpdGxlc1RyYWNrXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoaWNoIHRpbWUgcmFuZ2VzIGFyZSBidWZmZXJlZFxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gICAqICAgICAgICAgVGltZVJhbmdlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgYnVmZmVyZWQgcmFuZ2VzXG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhWVFRTZWdtZW50TG9hZGVyLCBbe1xuICAgIGtleTogJ2J1ZmZlcmVkXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1ZmZlcmVkXygpIHtcbiAgICAgIGlmICghdGhpcy5zdWJ0aXRsZXNUcmFja18gfHwgIXRoaXMuc3VidGl0bGVzVHJhY2tfLmN1ZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBfdmlkZW9KczJbJ2RlZmF1bHQnXS5jcmVhdGVUaW1lUmFuZ2VzKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdWVzID0gdGhpcy5zdWJ0aXRsZXNUcmFja18uY3VlcztcbiAgICAgIHZhciBzdGFydCA9IGN1ZXNbMF0uc3RhcnRUaW1lO1xuICAgICAgdmFyIGVuZCA9IGN1ZXNbY3Vlcy5sZW5ndGggLSAxXS5zdGFydFRpbWU7XG5cbiAgICAgIHJldHVybiBfdmlkZW9KczJbJ2RlZmF1bHQnXS5jcmVhdGVUaW1lUmFuZ2VzKFtbc3RhcnQsIGVuZF1dKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFuZCBzZXRzIGluaXQgc2VnbWVudCBmb3IgdGhlIHByb3ZpZGVkIG1hcFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICAgICAqICAgICAgICBUaGUgbWFwIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluaXQgc2VnbWVudCB0byBnZXQgb3Igc2V0XG4gICAgICogQHBhcmFtIHtCb29sZWFuPX0gc2V0XG4gICAgICogICAgICAgIElmIHRydWUsIHRoZSBpbml0IHNlZ21lbnQgZm9yIHRoZSBwcm92aWRlZCBtYXAgc2hvdWxkIGJlIHNhdmVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqICAgICAgICAgbWFwIG9iamVjdCBmb3IgZGVzaXJlZCBpbml0IHNlZ21lbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2luaXRTZWdtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFNlZ21lbnQobWFwKSB7XG4gICAgICB2YXIgc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgIGlmICghbWFwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWQgPSAoMCwgX2JpblV0aWxzLmluaXRTZWdtZW50SWQpKG1hcCk7XG4gICAgICB2YXIgc3RvcmVkTWFwID0gdGhpcy5pbml0U2VnbWVudHNfW2lkXTtcblxuICAgICAgaWYgKHNldCAmJiAhc3RvcmVkTWFwICYmIG1hcC5ieXRlcykge1xuICAgICAgICAvLyBhcHBlbmQgV2ViVlRUIGxpbmUgdGVybWluYXRvcnMgdG8gdGhlIG1lZGlhIGluaXRpYWxpemF0aW9uIHNlZ21lbnQgaWYgaXQgZXhpc3RzXG4gICAgICAgIC8vIHRvIGZvbGxvdyB0aGUgV2ViVlRUIHNwZWMgKGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJ2dHQvI2ZpbGUtc3RydWN0dXJlKSB0aGF0XG4gICAgICAgIC8vIHJlcXVpcmVzIHR3byBvciBtb3JlIFdlYlZUVCBsaW5lIHRlcm1pbmF0b3JzIGJldHdlZW4gdGhlIFdlYlZUVCBoZWFkZXIgYW5kIHRoZVxuICAgICAgICAvLyByZXN0IG9mIHRoZSBmaWxlXG4gICAgICAgIHZhciBjb21iaW5lZEJ5dGVMZW5ndGggPSBWVFRfTElORV9URVJNSU5BVE9SUy5ieXRlTGVuZ3RoICsgbWFwLmJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICAgIHZhciBjb21iaW5lZFNlZ21lbnQgPSBuZXcgVWludDhBcnJheShjb21iaW5lZEJ5dGVMZW5ndGgpO1xuXG4gICAgICAgIGNvbWJpbmVkU2VnbWVudC5zZXQobWFwLmJ5dGVzKTtcbiAgICAgICAgY29tYmluZWRTZWdtZW50LnNldChWVFRfTElORV9URVJNSU5BVE9SUywgbWFwLmJ5dGVzLmJ5dGVMZW5ndGgpO1xuXG4gICAgICAgIHRoaXMuaW5pdFNlZ21lbnRzX1tpZF0gPSBzdG9yZWRNYXAgPSB7XG4gICAgICAgICAgcmVzb2x2ZWRVcmk6IG1hcC5yZXNvbHZlZFVyaSxcbiAgICAgICAgICBieXRlcmFuZ2U6IG1hcC5ieXRlcmFuZ2UsXG4gICAgICAgICAgYnl0ZXM6IGNvbWJpbmVkU2VnbWVudFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RvcmVkTWFwIHx8IG1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYWxsIGNvbmZpZ3VyYXRpb24gcmVxdWlyZWQgZm9yIGxvYWRpbmcgaXMgcHJlc2VudCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgYWxsIGNvbmZpZ3VyYXRpb24gaXMgcmVhZHkgZm9yIGxvYWRpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY291bGRCZWdpbkxvYWRpbmdfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY291bGRCZWdpbkxvYWRpbmdfKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGxheWxpc3RfICYmIHRoaXMuc3VidGl0bGVzVHJhY2tfICYmICF0aGlzLnBhdXNlZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uY2UgYWxsIHRoZSBzdGFydGluZyBwYXJhbWV0ZXJzIGhhdmUgYmVlbiBzcGVjaWZpZWQsIGJlZ2luXG4gICAgICogb3BlcmF0aW9uLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBpbnZva2VkIGZyb20gdGhlIElOSVRcbiAgICAgKiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdpbml0XycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRfKCkge1xuICAgICAgdGhpcy5zdGF0ZSA9ICdSRUFEWSc7XG4gICAgICB0aGlzLnJlc2V0RXZlcnl0aGluZygpO1xuICAgICAgcmV0dXJuIHRoaXMubW9uaXRvckJ1ZmZlcl8oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBzdWJ0aXRsZSB0cmFjayBvbiB0aGUgc2VnbWVudCBsb2FkZXIgdG8gYWRkIHN1YnRpdGxlcyB0b1xuICAgICAqXG4gICAgICogQHBhcmFtIHtUZXh0VHJhY2s9fSB0cmFja1xuICAgICAqICAgICAgICBUaGUgdGV4dCB0cmFjayB0byBhZGQgbG9hZGVkIHN1YnRpdGxlcyB0b1xuICAgICAqIEByZXR1cm4ge1RleHRUcmFja31cbiAgICAgKiAgICAgICAgUmV0dXJucyB0aGUgc3VidGl0bGVzIHRyYWNrXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICd0cmFjaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYWNrKF90cmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBfdHJhY2sgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnRpdGxlc1RyYWNrXztcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdWJ0aXRsZXNUcmFja18gPSBfdHJhY2s7XG5cbiAgICAgIC8vIGlmIHdlIHdlcmUgdW5wYXVzZWQgYnV0IHdhaXRpbmcgZm9yIGEgc291cmNlVXBkYXRlciwgc3RhcnRcbiAgICAgIC8vIGJ1ZmZlcmluZyBub3dcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnSU5JVCcgJiYgdGhpcy5jb3VsZEJlZ2luTG9hZGluZ18oKSkge1xuICAgICAgICB0aGlzLmluaXRfKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnN1YnRpdGxlc1RyYWNrXztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW55IGRhdGEgaW4gdGhlIHNvdXJjZSBidWZmZXIgYmV0d2VlbiBzdGFydCBhbmQgZW5kIHRpbWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IC0gdGhlIHN0YXJ0IHRpbWUgb2YgdGhlIHJlZ2lvbiB0byByZW1vdmUgZnJvbSB0aGUgYnVmZmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCAtIHRoZSBlbmQgdGltZSBvZiB0aGUgcmVnaW9uIHRvIHJlbW92ZSBmcm9tIHRoZSBidWZmZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShzdGFydCwgZW5kKSB7XG4gICAgICAoMCwgX3ZpZGVvanNDb250cmliTWVkaWFTb3VyY2VzRXM1UmVtb3ZlQ3Vlc0Zyb21UcmFja0pzMlsnZGVmYXVsdCddKShzdGFydCwgZW5kLCB0aGlzLnN1YnRpdGxlc1RyYWNrXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmlsbCB0aGUgYnVmZmVyIHdpdGggc2VnZW1lbnRzIHVubGVzcyB0aGUgc291cmNlQnVmZmVycyBhcmVcbiAgICAgKiBjdXJyZW50bHkgdXBkYXRpbmdcbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgZXZlciBiZSBjYWxsZWQgYnkgbW9uaXRvckJ1ZmZlcl9cbiAgICAgKiBhbmQgbmV2ZXIgZGlyZWN0bHlcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdmaWxsQnVmZmVyXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbGxCdWZmZXJfKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLnN5bmNQb2ludF8pIHtcbiAgICAgICAgdGhpcy5zeW5jUG9pbnRfID0gdGhpcy5zeW5jQ29udHJvbGxlcl8uZ2V0U3luY1BvaW50KHRoaXMucGxheWxpc3RfLCB0aGlzLmR1cmF0aW9uXygpLCB0aGlzLmN1cnJlbnRUaW1lbGluZV8sIHRoaXMuY3VycmVudFRpbWVfKCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZWUgaWYgd2UgbmVlZCB0byBiZWdpbiBsb2FkaW5nIGltbWVkaWF0ZWx5XG4gICAgICB2YXIgc2VnbWVudEluZm8gPSB0aGlzLmNoZWNrQnVmZmVyXyh0aGlzLmJ1ZmZlcmVkXygpLCB0aGlzLnBsYXlsaXN0XywgdGhpcy5tZWRpYUluZGV4LCB0aGlzLmhhc1BsYXllZF8oKSwgdGhpcy5jdXJyZW50VGltZV8oKSwgdGhpcy5zeW5jUG9pbnRfKTtcblxuICAgICAgc2VnbWVudEluZm8gPSB0aGlzLnNraXBFbXB0eVNlZ21lbnRzXyhzZWdtZW50SW5mbyk7XG5cbiAgICAgIGlmICghc2VnbWVudEluZm8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zeW5jQ29udHJvbGxlcl8udGltZXN0YW1wT2Zmc2V0Rm9yVGltZWxpbmUoc2VnbWVudEluZm8udGltZWxpbmUpID09PSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgdGhlIHRpbWVzdGFtcCBvZmZzZXQgdGhhdCB3ZSBuZWVkIHRvIHN5bmMgc3VidGl0bGVzLlxuICAgICAgICAvLyBSZXJ1biBvbiBhIHRpbWVzdGFtcCBvZmZzZXQgb3IgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgICAgdmFyIGNoZWNrVGltZXN0YW1wT2Zmc2V0ID0gZnVuY3Rpb24gY2hlY2tUaW1lc3RhbXBPZmZzZXQoKSB7XG4gICAgICAgICAgX3RoaXMuc3RhdGUgPSAnUkVBRFknO1xuICAgICAgICAgIGlmICghX3RoaXMucGF1c2VkKCkpIHtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBwYXVzZWQsIHF1ZXVlIGEgYnVmZmVyIGNoZWNrIGFzIHNvb24gYXMgcG9zc2libGVcbiAgICAgICAgICAgIF90aGlzLm1vbml0b3JCdWZmZXJfKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc3luY0NvbnRyb2xsZXJfLm9uZSgndGltZXN0YW1wb2Zmc2V0JywgY2hlY2tUaW1lc3RhbXBPZmZzZXQpO1xuICAgICAgICB0aGlzLnN0YXRlID0gJ1dBSVRJTkdfT05fVElNRUxJTkUnO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9hZFNlZ21lbnRfKHNlZ21lbnRJbmZvKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyB0aGUgc2VnbWVudCBsb2FkZXIgZnJvbSByZXF1ZXN0aW5nIHNlZ21lbnRzIHdlIGtub3cgY29udGFpbiBubyBzdWJ0aXRsZXNcbiAgICAgKiBieSB3YWxraW5nIGZvcndhcmQgdW50aWwgd2UgZmluZCB0aGUgbmV4dCBzZWdtZW50IHRoYXQgd2UgZG9uJ3Qga25vdyB3aGV0aGVyIGl0IGlzXG4gICAgICogZW1wdHkgb3Igbm90LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlZ21lbnRJbmZvXG4gICAgICogICAgICAgIGEgc2VnbWVudCBpbmZvIG9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgY3VycmVudCBzZWdtZW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqICAgICAgICAgYSBzZWdtZW50IGluZm8gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBjdXJyZW50IHNlZ21lbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NraXBFbXB0eVNlZ21lbnRzXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNraXBFbXB0eVNlZ21lbnRzXyhzZWdtZW50SW5mbykge1xuICAgICAgd2hpbGUgKHNlZ21lbnRJbmZvICYmIHNlZ21lbnRJbmZvLnNlZ21lbnQuZW1wdHkpIHtcbiAgICAgICAgc2VnbWVudEluZm8gPSB0aGlzLmdlbmVyYXRlU2VnbWVudEluZm9fKHNlZ21lbnRJbmZvLnBsYXlsaXN0LCBzZWdtZW50SW5mby5tZWRpYUluZGV4ICsgMSwgc2VnbWVudEluZm8uc3RhcnRPZlNlZ21lbnQgKyBzZWdtZW50SW5mby5kdXJhdGlvbiwgc2VnbWVudEluZm8uaXNTeW5jUmVxdWVzdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VnbWVudEluZm87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYXBwZW5kIGEgZGVjcnlwdGVkIHNlZ2VtZW50IHRvIHRoZSBTb3VyY2VCdWZmZXIgdGhyb3VnaCBhIFNvdXJjZVVwZGF0ZXJcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVTZWdtZW50XycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVNlZ21lbnRfKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5wZW5kaW5nU2VnbWVudF8gfHwgIXRoaXMuc3VidGl0bGVzVHJhY2tfKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnUkVBRFknO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhdGUgPSAnQVBQRU5ESU5HJztcblxuICAgICAgdmFyIHNlZ21lbnRJbmZvID0gdGhpcy5wZW5kaW5nU2VnbWVudF87XG4gICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRJbmZvLnNlZ21lbnQ7XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHZ0dGpzIGhhcyBsb2FkZWQsIG90aGVyd2lzZSwgd2FpdCB0aWxsIGl0IGZpbmlzaGVkIGxvYWRpbmdcbiAgICAgIGlmICh0eXBlb2YgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5XZWJWVFQgIT09ICdmdW5jdGlvbicgJiYgdGhpcy5zdWJ0aXRsZXNUcmFja18gJiYgdGhpcy5zdWJ0aXRsZXNUcmFja18udGVjaF8pIHtcbiAgICAgICAgdmFyIF9yZXQgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgdmFyIGxvYWRIYW5kbGVyID0gZnVuY3Rpb24gbG9hZEhhbmRsZXIoKSB7XG4gICAgICAgICAgICBfdGhpczIuaGFuZGxlU2VnbWVudF8oKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RoaXMyLnN0YXRlID0gJ1dBSVRJTkdfT05fVlRUSlMnO1xuICAgICAgICAgIF90aGlzMi5zdWJ0aXRsZXNUcmFja18udGVjaF8ub25lKCd2dHRqc2xvYWRlZCcsIGxvYWRIYW5kbGVyKTtcbiAgICAgICAgICBfdGhpczIuc3VidGl0bGVzVHJhY2tfLnRlY2hfLm9uZSgndnR0anNlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5zdWJ0aXRsZXNUcmFja18udGVjaF8ub2ZmKCd2dHRqc2xvYWRlZCcsIGxvYWRIYW5kbGVyKTtcbiAgICAgICAgICAgIF90aGlzMi5lcnJvcih7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdFcnJvciBsb2FkaW5nIHZ0dC5qcydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMyLnN0YXRlID0gJ1JFQURZJztcbiAgICAgICAgICAgIF90aGlzMi5wYXVzZSgpO1xuICAgICAgICAgICAgX3RoaXMyLnRyaWdnZXIoJ2Vycm9yJyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdjogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICBpZiAodHlwZW9mIF9yZXQgPT09ICdvYmplY3QnKSByZXR1cm4gX3JldC52O1xuICAgICAgfVxuXG4gICAgICBzZWdtZW50LnJlcXVlc3RlZCA9IHRydWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMucGFyc2VWVFRDdWVzXyhzZWdtZW50SW5mbyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdSRUFEWSc7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignZXJyb3InKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVUaW1lTWFwcGluZ18oc2VnbWVudEluZm8sIHRoaXMuc3luY0NvbnRyb2xsZXJfLnRpbWVsaW5lc1tzZWdtZW50SW5mby50aW1lbGluZV0sIHRoaXMucGxheWxpc3RfKTtcblxuICAgICAgaWYgKHNlZ21lbnRJbmZvLmlzU3luY1JlcXVlc3QpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzeW5jaW5mb3VwZGF0ZScpO1xuICAgICAgICB0aGlzLnBlbmRpbmdTZWdtZW50XyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnUkVBRFknO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnRJbmZvLmJ5dGVMZW5ndGggPSBzZWdtZW50SW5mby5ieXRlcy5ieXRlTGVuZ3RoO1xuXG4gICAgICB0aGlzLm1lZGlhU2Vjb25kc0xvYWRlZCArPSBzZWdtZW50LmR1cmF0aW9uO1xuXG4gICAgICBpZiAoc2VnbWVudEluZm8uY3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFueSBvdmVybGFwcGluZyBjdWVzIHRvIHByZXZlbnQgZG91YmxpbmdcbiAgICAgICAgdGhpcy5yZW1vdmUoc2VnbWVudEluZm8uY3Vlc1swXS5lbmRUaW1lLCBzZWdtZW50SW5mby5jdWVzW3NlZ21lbnRJbmZvLmN1ZXMubGVuZ3RoIC0gMV0uZW5kVGltZSk7XG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnRJbmZvLmN1ZXMuZm9yRWFjaChmdW5jdGlvbiAoY3VlKSB7XG4gICAgICAgIF90aGlzMi5zdWJ0aXRsZXNUcmFja18uYWRkQ3VlKGN1ZSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5oYW5kbGVVcGRhdGVFbmRfKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyB0aGUgV2ViVlRUIHBhcnNlciB0byBwYXJzZSB0aGUgc2VnbWVudCByZXNwb25zZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlZ21lbnRJbmZvXG4gICAgICogICAgICAgIGEgc2VnbWVudCBpbmZvIG9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgY3VycmVudCBzZWdtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3BhcnNlVlRUQ3Vlc18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVZUVEN1ZXNfKHNlZ21lbnRJbmZvKSB7XG4gICAgICB2YXIgZGVjb2RlciA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBkZWNvZGVCeXRlc1RvU3RyaW5nID0gZmFsc2U7XG5cbiAgICAgIGlmICh0eXBlb2YgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5UZXh0RGVjb2RlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkZWNvZGVyID0gbmV3IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uVGV4dERlY29kZXIoJ3V0ZjgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlY29kZXIgPSBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLldlYlZUVC5TdHJpbmdEZWNvZGVyKCk7XG4gICAgICAgIGRlY29kZUJ5dGVzVG9TdHJpbmcgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyc2VyID0gbmV3IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uV2ViVlRULlBhcnNlcihfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLCBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnZ0dGpzLCBkZWNvZGVyKTtcblxuICAgICAgc2VnbWVudEluZm8uY3VlcyA9IFtdO1xuICAgICAgc2VnbWVudEluZm8udGltZXN0YW1wbWFwID0geyBNUEVHVFM6IDAsIExPQ0FMOiAwIH07XG5cbiAgICAgIHBhcnNlci5vbmN1ZSA9IHNlZ21lbnRJbmZvLmN1ZXMucHVzaC5iaW5kKHNlZ21lbnRJbmZvLmN1ZXMpO1xuICAgICAgcGFyc2VyLm9udGltZXN0YW1wbWFwID0gZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICByZXR1cm4gc2VnbWVudEluZm8udGltZXN0YW1wbWFwID0gbWFwO1xuICAgICAgfTtcbiAgICAgIHBhcnNlci5vbnBhcnNpbmdlcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBfdmlkZW9KczJbJ2RlZmF1bHQnXS5sb2cud2FybignRXJyb3IgZW5jb3VudGVyZWQgd2hlbiBwYXJzaW5nIGN1ZXM6ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChzZWdtZW50SW5mby5zZWdtZW50Lm1hcCkge1xuICAgICAgICB2YXIgbWFwRGF0YSA9IHNlZ21lbnRJbmZvLnNlZ21lbnQubWFwLmJ5dGVzO1xuXG4gICAgICAgIGlmIChkZWNvZGVCeXRlc1RvU3RyaW5nKSB7XG4gICAgICAgICAgbWFwRGF0YSA9IHVpbnRUb1N0cmluZyhtYXBEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlci5wYXJzZShtYXBEYXRhKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlZ21lbnREYXRhID0gc2VnbWVudEluZm8uYnl0ZXM7XG5cbiAgICAgIGlmIChkZWNvZGVCeXRlc1RvU3RyaW5nKSB7XG4gICAgICAgIHNlZ21lbnREYXRhID0gdWludFRvU3RyaW5nKHNlZ21lbnREYXRhKTtcbiAgICAgIH1cblxuICAgICAgcGFyc2VyLnBhcnNlKHNlZ21lbnREYXRhKTtcbiAgICAgIHBhcnNlci5mbHVzaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHN0YXJ0IGFuZCBlbmQgdGltZXMgb2YgYW55IGN1ZXMgcGFyc2VkIGJ5IHRoZSBXZWJWVFQgcGFyc2VyIHVzaW5nXG4gICAgICogdGhlIGluZm9ybWF0aW9uIHBhcnNlZCBmcm9tIHRoZSBYLVRJTUVTVEFNUC1NQVAgaGVhZGVyIGFuZCBhIFRTIHRvIG1lZGlhIHRpbWUgbWFwcGluZ1xuICAgICAqIGZyb20gdGhlIFN5bmNDb250cm9sbGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudEluZm9cbiAgICAgKiAgICAgICAgYSBzZWdtZW50IGluZm8gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBjdXJyZW50IHNlZ21lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwcGluZ09ialxuICAgICAqICAgICAgICBvYmplY3QgY29udGFpbmluZyBhIG1hcHBpbmcgZnJvbSBUUyB0byBtZWRpYSB0aW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBsYXlsaXN0XG4gICAgICogICAgICAgIHRoZSBwbGF5bGlzdCBvYmplY3QgY29udGFpbmluZyB0aGUgc2VnbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVUaW1lTWFwcGluZ18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVUaW1lTWFwcGluZ18oc2VnbWVudEluZm8sIG1hcHBpbmdPYmosIHBsYXlsaXN0KSB7XG4gICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRJbmZvLnNlZ21lbnQ7XG5cbiAgICAgIGlmICghbWFwcGluZ09iaikge1xuICAgICAgICAvLyBJZiB0aGUgc3luYyBjb250cm9sbGVyIGRvZXMgbm90IGhhdmUgYSBtYXBwaW5nIG9mIFRTIHRvIE1lZGlhIFRpbWUgZm9yIHRoZVxuICAgICAgICAvLyB0aW1lbGluZSwgdGhlbiB3ZSBkb24ndCBoYXZlIGVub3VnaCBpbmZvcm1hdGlvbiB0byB1cGRhdGUgdGhlIGN1ZVxuICAgICAgICAvLyBzdGFydC9lbmQgdGltZXNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlZ21lbnRJbmZvLmN1ZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBjdWVzLCB3ZSBhbHNvIGRvIG5vdCBoYXZlIGVub3VnaCBpbmZvcm1hdGlvbiB0byBmaWd1cmUgb3V0XG4gICAgICAgIC8vIHNlZ21lbnQgdGltaW5nLiBNYXJrIHRoYXQgdGhlIHNlZ21lbnQgY29udGFpbnMgbm8gY3VlcyBzbyB3ZSBkb24ndCByZS1yZXF1ZXN0XG4gICAgICAgIC8vIGFuIGVtcHR5IHNlZ21lbnQuXG4gICAgICAgIHNlZ21lbnQuZW1wdHkgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0aW1lc3RhbXBtYXAgPSBzZWdtZW50SW5mby50aW1lc3RhbXBtYXA7XG4gICAgICB2YXIgZGlmZiA9IHRpbWVzdGFtcG1hcC5NUEVHVFMgLyA5MDAwMCAtIHRpbWVzdGFtcG1hcC5MT0NBTCArIG1hcHBpbmdPYmoubWFwcGluZztcblxuICAgICAgc2VnbWVudEluZm8uY3Vlcy5mb3JFYWNoKGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgICAgLy8gRmlyc3QgY29udmVydCBjdWUgdGltZSB0byBUUyB0aW1lIHVzaW5nIHRoZSB0aW1lc3RhbXAtbWFwIHByb3ZpZGVkIHdpdGhpbiB0aGUgdnR0XG4gICAgICAgIGN1ZS5zdGFydFRpbWUgKz0gZGlmZjtcbiAgICAgICAgY3VlLmVuZFRpbWUgKz0gZGlmZjtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXBsYXlsaXN0LnN5bmNJbmZvKSB7XG4gICAgICAgIHZhciBmaXJzdFN0YXJ0ID0gc2VnbWVudEluZm8uY3Vlc1swXS5zdGFydFRpbWU7XG4gICAgICAgIHZhciBsYXN0U3RhcnQgPSBzZWdtZW50SW5mby5jdWVzW3NlZ21lbnRJbmZvLmN1ZXMubGVuZ3RoIC0gMV0uc3RhcnRUaW1lO1xuXG4gICAgICAgIHBsYXlsaXN0LnN5bmNJbmZvID0ge1xuICAgICAgICAgIG1lZGlhU2VxdWVuY2U6IHBsYXlsaXN0Lm1lZGlhU2VxdWVuY2UgKyBzZWdtZW50SW5mby5tZWRpYUluZGV4LFxuICAgICAgICAgIHRpbWU6IE1hdGgubWluKGZpcnN0U3RhcnQsIGxhc3RTdGFydCAtIHNlZ21lbnQuZHVyYXRpb24pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZUVFNlZ21lbnRMb2FkZXI7XG59KShfc2VnbWVudExvYWRlcjJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFZUVFNlZ21lbnRMb2FkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuL2Jpbi11dGlsc1wiOjIsXCIuL3NlZ21lbnQtbG9hZGVyXCI6MTYsXCJnbG9iYWwvd2luZG93XCI6MzIsXCJ2aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcy9lczUvcmVtb3ZlLWN1ZXMtZnJvbS10cmFjay5qc1wiOjcyfV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBAZmlsZSB4aHIuanNcbiAqL1xuXG4vKipcbiAqIEEgd3JhcHBlciBmb3IgdmlkZW9qcy54aHIgdGhhdCB0cmFja3MgYmFuZHdpZHRoLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgZm9yIHRoZSBYSFJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gZG9uZVxuICogQHJldHVybiB7UmVxdWVzdH0gdGhlIHhociByZXF1ZXN0IHRoYXQgaXMgZ29pbmcgdG8gYmUgbWFkZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfdmlkZW9KcyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2aWRlb2pzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd2aWRlb2pzJ10gOiBudWxsKTtcblxudmFyIF92aWRlb0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvSnMpO1xuXG52YXIgeGhyRmFjdG9yeSA9IGZ1bmN0aW9uIHhockZhY3RvcnkoKSB7XG4gIHZhciB4aHIgPSBmdW5jdGlvbiBYaHJGdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIC8vIEFkZCBhIGRlZmF1bHQgdGltZW91dCBmb3IgYWxsIGhscyByZXF1ZXN0c1xuICAgIG9wdGlvbnMgPSAoMCwgX3ZpZGVvSnMubWVyZ2VPcHRpb25zKSh7XG4gICAgICB0aW1lb3V0OiA0NWUzXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBBbGxvdyBhbiBvcHRpb25hbCB1c2VyLXNwZWNpZmllZCBmdW5jdGlvbiB0byBtb2RpZnkgdGhlIG9wdGlvblxuICAgIC8vIG9iamVjdCBiZWZvcmUgd2UgY29uc3RydWN0IHRoZSB4aHIgcmVxdWVzdFxuICAgIHZhciBiZWZvcmVSZXF1ZXN0ID0gWGhyRnVuY3Rpb24uYmVmb3JlUmVxdWVzdCB8fCBfdmlkZW9KczJbJ2RlZmF1bHQnXS5IbHMueGhyLmJlZm9yZVJlcXVlc3Q7XG5cbiAgICBpZiAoYmVmb3JlUmVxdWVzdCAmJiB0eXBlb2YgYmVmb3JlUmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIG5ld09wdGlvbnMgPSBiZWZvcmVSZXF1ZXN0KG9wdGlvbnMpO1xuXG4gICAgICBpZiAobmV3T3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9ICgwLCBfdmlkZW9Kcy54aHIpKG9wdGlvbnMsIGZ1bmN0aW9uIChlcnJvciwgcmVzcG9uc2UpIHtcbiAgICAgIHZhciByZXFSZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG5cbiAgICAgIGlmICghZXJyb3IgJiYgcmVxUmVzcG9uc2UpIHtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXF1ZXN0LnJvdW5kVHJpcFRpbWUgPSByZXF1ZXN0LnJlc3BvbnNlVGltZSAtIHJlcXVlc3QucmVxdWVzdFRpbWU7XG4gICAgICAgIHJlcXVlc3QuYnl0ZXNSZWNlaXZlZCA9IHJlcVJlc3BvbnNlLmJ5dGVMZW5ndGggfHwgcmVxUmVzcG9uc2UubGVuZ3RoO1xuICAgICAgICBpZiAoIXJlcXVlc3QuYmFuZHdpZHRoKSB7XG4gICAgICAgICAgcmVxdWVzdC5iYW5kd2lkdGggPSBNYXRoLmZsb29yKHJlcXVlc3QuYnl0ZXNSZWNlaXZlZCAvIHJlcXVlc3Qucm91bmRUcmlwVGltZSAqIDggKiAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB2aWRlb2pzLnhociBub3cgdXNlcyBhIHNwZWNpZmljIGNvZGUgb24gdGhlIGVycm9yXG4gICAgICAvLyBvYmplY3QgdG8gc2lnbmFsIHRoYXQgYSByZXF1ZXN0IGhhcyB0aW1lZCBvdXQgaW5zdGVhZFxuICAgICAgLy8gb2Ygc2V0dGluZyBhIGJvb2xlYW4gb24gdGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gJ0VUSU1FRE9VVCcpIHtcbiAgICAgICAgcmVxdWVzdC50aW1lZG91dCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHZpZGVvanMueGhyIG5vIGxvbmdlciBjb25zaWRlcnMgc3RhdHVzIGNvZGVzIG91dHNpZGUgb2YgMjAwIGFuZCAwXG4gICAgICAvLyAoZm9yIGZpbGUgdXJpcykgdG8gYmUgZXJyb3JzLCBidXQgdGhlIG9sZCBYSFIgZGlkLCBzbyBlbXVsYXRlIHRoYXRcbiAgICAgIC8vIGJlaGF2aW9yLiBTdGF0dXMgMjA2IG1heSBiZSB1c2VkIGluIHJlc3BvbnNlIHRvIGJ5dGVyYW5nZSByZXF1ZXN0cy5cbiAgICAgIGlmICghZXJyb3IgJiYgIXJlcXVlc3QuYWJvcnRlZCAmJiByZXNwb25zZS5zdGF0dXNDb2RlICE9PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gMjA2ICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDApIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ1hIUiBGYWlsZWQgd2l0aCBhIHJlc3BvbnNlIG9mOiAnICsgKHJlcXVlc3QgJiYgKHJlcVJlc3BvbnNlIHx8IHJlcXVlc3QucmVzcG9uc2VUZXh0KSkpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhlcnJvciwgcmVxdWVzdCk7XG4gICAgfSk7XG4gICAgdmFyIG9yaWdpbmFsQWJvcnQgPSByZXF1ZXN0LmFib3J0O1xuXG4gICAgcmVxdWVzdC5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlcXVlc3QuYWJvcnRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gb3JpZ2luYWxBYm9ydC5hcHBseShyZXF1ZXN0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgcmVxdWVzdC51cmkgPSBvcHRpb25zLnVyaTtcbiAgICByZXF1ZXN0LnJlcXVlc3RUaW1lID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfTtcblxuICByZXR1cm4geGhyO1xufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0geGhyRmFjdG9yeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIGFlcy5qc1xuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhbiBhZGFwdGF0aW9uIG9mIHRoZSBBRVMgZGVjcnlwdGlvbiBhbGdvcml0aG1cbiAqIGZyb20gdGhlIFN0YW5kZm9yZCBKYXZhc2NyaXB0IENyeXB0b2dyYXBoeSBMaWJyYXJ5LiBUaGF0IHdvcmsgaXNcbiAqIGNvdmVyZWQgYnkgdGhlIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIHBlcm1pc3Npb25zIG5vdGljZTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDEwIEVtaWx5IFN0YXJrLCBNaWtlIEhhbWJ1cmcsIERhbiBCb25laC5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQVVUSE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTIE9SXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICogRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUlxuICogQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRVxuICogT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTlxuICogSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogVGhlIHZpZXdzIGFuZCBjb25jbHVzaW9ucyBjb250YWluZWQgaW4gdGhlIHNvZnR3YXJlIGFuZCBkb2N1bWVudGF0aW9uXG4gKiBhcmUgdGhvc2Ugb2YgdGhlIGF1dGhvcnMgYW5kIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgcmVwcmVzZW50aW5nXG4gKiBvZmZpY2lhbCBwb2xpY2llcywgZWl0aGVyIGV4cHJlc3NlZCBvciBpbXBsaWVkLCBvZiB0aGUgYXV0aG9ycy5cbiAqL1xuXG4vKipcbiAqIEV4cGFuZCB0aGUgUy1ib3ggdGFibGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgcHJlY29tcHV0ZSA9IGZ1bmN0aW9uIHByZWNvbXB1dGUoKSB7XG4gIHZhciB0YWJsZXMgPSBbW1tdLCBbXSwgW10sIFtdLCBbXV0sIFtbXSwgW10sIFtdLCBbXSwgW11dXTtcbiAgdmFyIGVuY1RhYmxlID0gdGFibGVzWzBdO1xuICB2YXIgZGVjVGFibGUgPSB0YWJsZXNbMV07XG4gIHZhciBzYm94ID0gZW5jVGFibGVbNF07XG4gIHZhciBzYm94SW52ID0gZGVjVGFibGVbNF07XG4gIHZhciBpID0gdW5kZWZpbmVkO1xuICB2YXIgeCA9IHVuZGVmaW5lZDtcbiAgdmFyIHhJbnYgPSB1bmRlZmluZWQ7XG4gIHZhciBkID0gW107XG4gIHZhciB0aCA9IFtdO1xuICB2YXIgeDIgPSB1bmRlZmluZWQ7XG4gIHZhciB4NCA9IHVuZGVmaW5lZDtcbiAgdmFyIHg4ID0gdW5kZWZpbmVkO1xuICB2YXIgcyA9IHVuZGVmaW5lZDtcbiAgdmFyIHRFbmMgPSB1bmRlZmluZWQ7XG4gIHZhciB0RGVjID0gdW5kZWZpbmVkO1xuXG4gIC8vIENvbXB1dGUgZG91YmxlIGFuZCB0aGlyZCB0YWJsZXNcbiAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgdGhbKGRbaV0gPSBpIDw8IDEgXiAoaSA+PiA3KSAqIDI4MykgXiBpXSA9IGk7XG4gIH1cblxuICBmb3IgKHggPSB4SW52ID0gMDsgIXNib3hbeF07IHggXj0geDIgfHwgMSwgeEludiA9IHRoW3hJbnZdIHx8IDEpIHtcbiAgICAvLyBDb21wdXRlIHNib3hcbiAgICBzID0geEludiBeIHhJbnYgPDwgMSBeIHhJbnYgPDwgMiBeIHhJbnYgPDwgMyBeIHhJbnYgPDwgNDtcbiAgICBzID0gcyA+PiA4IF4gcyAmIDI1NSBeIDk5O1xuICAgIHNib3hbeF0gPSBzO1xuICAgIHNib3hJbnZbc10gPSB4O1xuXG4gICAgLy8gQ29tcHV0ZSBNaXhDb2x1bW5zXG4gICAgeDggPSBkW3g0ID0gZFt4MiA9IGRbeF1dXTtcbiAgICB0RGVjID0geDggKiAweDEwMTAxMDEgXiB4NCAqIDB4MTAwMDEgXiB4MiAqIDB4MTAxIF4geCAqIDB4MTAxMDEwMDtcbiAgICB0RW5jID0gZFtzXSAqIDB4MTAxIF4gcyAqIDB4MTAxMDEwMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIGVuY1RhYmxlW2ldW3hdID0gdEVuYyA9IHRFbmMgPDwgMjQgXiB0RW5jID4+PiA4O1xuICAgICAgZGVjVGFibGVbaV1bc10gPSB0RGVjID0gdERlYyA8PCAyNCBeIHREZWMgPj4+IDg7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcGFjdGlmeS4gQ29uc2lkZXJhYmxlIHNwZWVkdXAgb24gRmlyZWZveC5cbiAgZm9yIChpID0gMDsgaSA8IDU7IGkrKykge1xuICAgIGVuY1RhYmxlW2ldID0gZW5jVGFibGVbaV0uc2xpY2UoMCk7XG4gICAgZGVjVGFibGVbaV0gPSBkZWNUYWJsZVtpXS5zbGljZSgwKTtcbiAgfVxuICByZXR1cm4gdGFibGVzO1xufTtcbnZhciBhZXNUYWJsZXMgPSBudWxsO1xuXG4vKipcbiAqIFNjaGVkdWxlIG91dCBhbiBBRVMga2V5IGZvciBib3RoIGVuY3J5cHRpb24gYW5kIGRlY3J5cHRpb24uIFRoaXNcbiAqIGlzIGEgbG93LWxldmVsIGNsYXNzLiBVc2UgYSBjaXBoZXIgbW9kZSB0byBkbyBidWxrIGVuY3J5cHRpb24uXG4gKlxuICogQGNsYXNzIEFFU1xuICogQHBhcmFtIGtleSB7QXJyYXl9IFRoZSBrZXkgYXMgYW4gYXJyYXkgb2YgNCwgNiBvciA4IHdvcmRzLlxuICovXG5cbnZhciBBRVMgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBRVMoa2V5KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFFUyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXhwYW5kZWQgUy1ib3ggYW5kIGludmVyc2UgUy1ib3ggdGFibGVzLiBUaGVzZSB3aWxsIGJlIGNvbXB1dGVkXG4gICAgICogb24gdGhlIGNsaWVudCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gc2VuZCB0aGVtIGRvd24gdGhlIHdpcmUuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIHRhYmxlcywgX3RhYmxlc1swXSBpcyBmb3IgZW5jcnlwdGlvbiBhbmRcbiAgICAgKiBfdGFibGVzWzFdIGlzIGZvciBkZWNyeXB0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGZpcnN0IDQgc3ViLXRhYmxlcyBhcmUgdGhlIGV4cGFuZGVkIFMtYm94IHdpdGggTWl4Q29sdW1ucy4gVGhlXG4gICAgICogbGFzdCAoX3RhYmxlc1swMV1bNF0pIGlzIHRoZSBTLWJveCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIC8vIGlmIHdlIGhhdmUgeWV0IHRvIHByZWNvbXB1dGUgdGhlIFMtYm94IHRhYmxlc1xuICAgIC8vIGRvIHNvIG5vd1xuICAgIGlmICghYWVzVGFibGVzKSB7XG4gICAgICBhZXNUYWJsZXMgPSBwcmVjb21wdXRlKCk7XG4gICAgfVxuICAgIC8vIHRoZW4gbWFrZSBhIGNvcHkgb2YgdGhhdCBvYmplY3QgZm9yIHVzZVxuICAgIHRoaXMuX3RhYmxlcyA9IFtbYWVzVGFibGVzWzBdWzBdLnNsaWNlKCksIGFlc1RhYmxlc1swXVsxXS5zbGljZSgpLCBhZXNUYWJsZXNbMF1bMl0uc2xpY2UoKSwgYWVzVGFibGVzWzBdWzNdLnNsaWNlKCksIGFlc1RhYmxlc1swXVs0XS5zbGljZSgpXSwgW2Flc1RhYmxlc1sxXVswXS5zbGljZSgpLCBhZXNUYWJsZXNbMV1bMV0uc2xpY2UoKSwgYWVzVGFibGVzWzFdWzJdLnNsaWNlKCksIGFlc1RhYmxlc1sxXVszXS5zbGljZSgpLCBhZXNUYWJsZXNbMV1bNF0uc2xpY2UoKV1dO1xuICAgIHZhciBpID0gdW5kZWZpbmVkO1xuICAgIHZhciBqID0gdW5kZWZpbmVkO1xuICAgIHZhciB0bXAgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGVuY0tleSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgZGVjS2V5ID0gdW5kZWZpbmVkO1xuICAgIHZhciBzYm94ID0gdGhpcy5fdGFibGVzWzBdWzRdO1xuICAgIHZhciBkZWNUYWJsZSA9IHRoaXMuX3RhYmxlc1sxXTtcbiAgICB2YXIga2V5TGVuID0ga2V5Lmxlbmd0aDtcbiAgICB2YXIgcmNvbiA9IDE7XG5cbiAgICBpZiAoa2V5TGVuICE9PSA0ICYmIGtleUxlbiAhPT0gNiAmJiBrZXlMZW4gIT09IDgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZXMga2V5IHNpemUnKTtcbiAgICB9XG5cbiAgICBlbmNLZXkgPSBrZXkuc2xpY2UoMCk7XG4gICAgZGVjS2V5ID0gW107XG4gICAgdGhpcy5fa2V5ID0gW2VuY0tleSwgZGVjS2V5XTtcblxuICAgIC8vIHNjaGVkdWxlIGVuY3J5cHRpb24ga2V5c1xuICAgIGZvciAoaSA9IGtleUxlbjsgaSA8IDQgKiBrZXlMZW4gKyAyODsgaSsrKSB7XG4gICAgICB0bXAgPSBlbmNLZXlbaSAtIDFdO1xuXG4gICAgICAvLyBhcHBseSBzYm94XG4gICAgICBpZiAoaSAlIGtleUxlbiA9PT0gMCB8fCBrZXlMZW4gPT09IDggJiYgaSAlIGtleUxlbiA9PT0gNCkge1xuICAgICAgICB0bXAgPSBzYm94W3RtcCA+Pj4gMjRdIDw8IDI0IF4gc2JveFt0bXAgPj4gMTYgJiAyNTVdIDw8IDE2IF4gc2JveFt0bXAgPj4gOCAmIDI1NV0gPDwgOCBeIHNib3hbdG1wICYgMjU1XTtcblxuICAgICAgICAvLyBzaGlmdCByb3dzIGFuZCBhZGQgcmNvblxuICAgICAgICBpZiAoaSAlIGtleUxlbiA9PT0gMCkge1xuICAgICAgICAgIHRtcCA9IHRtcCA8PCA4IF4gdG1wID4+PiAyNCBeIHJjb24gPDwgMjQ7XG4gICAgICAgICAgcmNvbiA9IHJjb24gPDwgMSBeIChyY29uID4+IDcpICogMjgzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVuY0tleVtpXSA9IGVuY0tleVtpIC0ga2V5TGVuXSBeIHRtcDtcbiAgICB9XG5cbiAgICAvLyBzY2hlZHVsZSBkZWNyeXB0aW9uIGtleXNcbiAgICBmb3IgKGogPSAwOyBpOyBqKyssIGktLSkge1xuICAgICAgdG1wID0gZW5jS2V5W2ogJiAzID8gaSA6IGkgLSA0XTtcbiAgICAgIGlmIChpIDw9IDQgfHwgaiA8IDQpIHtcbiAgICAgICAgZGVjS2V5W2pdID0gdG1wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVjS2V5W2pdID0gZGVjVGFibGVbMF1bc2JveFt0bXAgPj4+IDI0XV0gXiBkZWNUYWJsZVsxXVtzYm94W3RtcCA+PiAxNiAmIDI1NV1dIF4gZGVjVGFibGVbMl1bc2JveFt0bXAgPj4gOCAmIDI1NV1dIF4gZGVjVGFibGVbM11bc2JveFt0bXAgJiAyNTVdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVjcnlwdCAxNiBieXRlcywgc3BlY2lmaWVkIGFzIGZvdXIgMzItYml0IHdvcmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5jcnlwdGVkMCB0aGUgZmlyc3Qgd29yZCB0byBkZWNyeXB0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmNyeXB0ZWQxIHRoZSBzZWNvbmQgd29yZCB0byBkZWNyeXB0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmNyeXB0ZWQyIHRoZSB0aGlyZCB3b3JkIHRvIGRlY3J5cHRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuY3J5cHRlZDMgdGhlIGZvdXJ0aCB3b3JkIHRvIGRlY3J5cHRcbiAgICogQHBhcmFtIHtJbnQzMkFycmF5fSBvdXQgdGhlIGFycmF5IHRvIHdyaXRlIHRoZSBkZWNyeXB0ZWQgd29yZHNcbiAgICogaW50b1xuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IHRoZSBvZmZzZXQgaW50byB0aGUgb3V0cHV0IGFycmF5IHRvIHN0YXJ0XG4gICAqIHdyaXRpbmcgcmVzdWx0c1xuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIHBsYWludGV4dC5cbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKEFFUywgW3tcbiAgICBrZXk6ICdkZWNyeXB0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjcnlwdChlbmNyeXB0ZWQwLCBlbmNyeXB0ZWQxLCBlbmNyeXB0ZWQyLCBlbmNyeXB0ZWQzLCBvdXQsIG9mZnNldCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMuX2tleVsxXTtcbiAgICAgIC8vIHN0YXRlIHZhcmlhYmxlcyBhLGIsYyxkIGFyZSBsb2FkZWQgd2l0aCBwcmUtd2hpdGVuZWQgZGF0YVxuICAgICAgdmFyIGEgPSBlbmNyeXB0ZWQwIF4ga2V5WzBdO1xuICAgICAgdmFyIGIgPSBlbmNyeXB0ZWQzIF4ga2V5WzFdO1xuICAgICAgdmFyIGMgPSBlbmNyeXB0ZWQyIF4ga2V5WzJdO1xuICAgICAgdmFyIGQgPSBlbmNyeXB0ZWQxIF4ga2V5WzNdO1xuICAgICAgdmFyIGEyID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGIyID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGMyID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBrZXkubGVuZ3RoID09PSAyID9cbiAgICAgIHZhciBuSW5uZXJSb3VuZHMgPSBrZXkubGVuZ3RoIC8gNCAtIDI7XG4gICAgICB2YXIgaSA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBrSW5kZXggPSA0O1xuICAgICAgdmFyIHRhYmxlID0gdGhpcy5fdGFibGVzWzFdO1xuXG4gICAgICAvLyBsb2FkIHVwIHRoZSB0YWJsZXNcbiAgICAgIHZhciB0YWJsZTAgPSB0YWJsZVswXTtcbiAgICAgIHZhciB0YWJsZTEgPSB0YWJsZVsxXTtcbiAgICAgIHZhciB0YWJsZTIgPSB0YWJsZVsyXTtcbiAgICAgIHZhciB0YWJsZTMgPSB0YWJsZVszXTtcbiAgICAgIHZhciBzYm94ID0gdGFibGVbNF07XG5cbiAgICAgIC8vIElubmVyIHJvdW5kcy4gQ3JpYmJlZCBmcm9tIE9wZW5TU0wuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbklubmVyUm91bmRzOyBpKyspIHtcbiAgICAgICAgYTIgPSB0YWJsZTBbYSA+Pj4gMjRdIF4gdGFibGUxW2IgPj4gMTYgJiAyNTVdIF4gdGFibGUyW2MgPj4gOCAmIDI1NV0gXiB0YWJsZTNbZCAmIDI1NV0gXiBrZXlba0luZGV4XTtcbiAgICAgICAgYjIgPSB0YWJsZTBbYiA+Pj4gMjRdIF4gdGFibGUxW2MgPj4gMTYgJiAyNTVdIF4gdGFibGUyW2QgPj4gOCAmIDI1NV0gXiB0YWJsZTNbYSAmIDI1NV0gXiBrZXlba0luZGV4ICsgMV07XG4gICAgICAgIGMyID0gdGFibGUwW2MgPj4+IDI0XSBeIHRhYmxlMVtkID4+IDE2ICYgMjU1XSBeIHRhYmxlMlthID4+IDggJiAyNTVdIF4gdGFibGUzW2IgJiAyNTVdIF4ga2V5W2tJbmRleCArIDJdO1xuICAgICAgICBkID0gdGFibGUwW2QgPj4+IDI0XSBeIHRhYmxlMVthID4+IDE2ICYgMjU1XSBeIHRhYmxlMltiID4+IDggJiAyNTVdIF4gdGFibGUzW2MgJiAyNTVdIF4ga2V5W2tJbmRleCArIDNdO1xuICAgICAgICBrSW5kZXggKz0gNDtcbiAgICAgICAgYSA9IGEyO2IgPSBiMjtjID0gYzI7XG4gICAgICB9XG5cbiAgICAgIC8vIExhc3Qgcm91bmQuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIG91dFsoMyAmIC1pKSArIG9mZnNldF0gPSBzYm94W2EgPj4+IDI0XSA8PCAyNCBeIHNib3hbYiA+PiAxNiAmIDI1NV0gPDwgMTYgXiBzYm94W2MgPj4gOCAmIDI1NV0gPDwgOCBeIHNib3hbZCAmIDI1NV0gXiBrZXlba0luZGV4KytdO1xuICAgICAgICBhMiA9IGE7YSA9IGI7YiA9IGM7YyA9IGQ7ZCA9IGEyO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBRVM7XG59KSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBBRVM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbn0se31dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgYXN5bmMtc3RyZWFtLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9zdHJlYW0gPSByZXF1aXJlKCcuL3N0cmVhbScpO1xuXG52YXIgX3N0cmVhbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHJlYW0pO1xuXG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgdGhlIFN0cmVhbSBjbGFzcyB0byB1c2Ugc2V0VGllbW91dFxuICogYW5kIHJ1biBzdHJlYW0gXCJqb2JzXCIgQXN5bmNocm9ub3VzbHlcbiAqXG4gKiBAY2xhc3MgQXN5bmNTdHJlYW1cbiAqIEBleHRlbmRzIFN0cmVhbVxuICovXG5cbnZhciBBc3luY1N0cmVhbSA9IChmdW5jdGlvbiAoX1N0cmVhbSkge1xuICBfaW5oZXJpdHMoQXN5bmNTdHJlYW0sIF9TdHJlYW0pO1xuXG4gIGZ1bmN0aW9uIEFzeW5jU3RyZWFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBc3luY1N0cmVhbSk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihBc3luY1N0cmVhbS5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMsIF9zdHJlYW0yWydkZWZhdWx0J10pO1xuICAgIHRoaXMuam9icyA9IFtdO1xuICAgIHRoaXMuZGVsYXkgPSAxO1xuICAgIHRoaXMudGltZW91dF8gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIHByb2Nlc3MgYW4gYXN5bmMgam9iXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhBc3luY1N0cmVhbSwgW3tcbiAgICBrZXk6ICdwcm9jZXNzSm9iXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NKb2JfKCkge1xuICAgICAgdGhpcy5qb2JzLnNoaWZ0KCkoKTtcbiAgICAgIGlmICh0aGlzLmpvYnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudGltZW91dF8gPSBzZXRUaW1lb3V0KHRoaXMucHJvY2Vzc0pvYl8uYmluZCh0aGlzKSwgdGhpcy5kZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRpbWVvdXRfID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwdXNoIGEgam9iIGludG8gdGhlIHN0cmVhbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gam9iIHRoZSBqb2IgdG8gcHVzaCBpbnRvIHRoZSBzdHJlYW1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3B1c2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKGpvYikge1xuICAgICAgdGhpcy5qb2JzLnB1c2goam9iKTtcbiAgICAgIGlmICghdGhpcy50aW1lb3V0Xykge1xuICAgICAgICB0aGlzLnRpbWVvdXRfID0gc2V0VGltZW91dCh0aGlzLnByb2Nlc3NKb2JfLmJpbmQodGhpcyksIHRoaXMuZGVsYXkpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBc3luY1N0cmVhbTtcbn0pKF9zdHJlYW0yWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBBc3luY1N0cmVhbTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSx7XCIuL3N0cmVhbVwiOjI2fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBkZWNyeXB0ZXIuanNcbiAqXG4gKiBBbiBhc3luY2hyb25vdXMgaW1wbGVtZW50YXRpb24gb2YgQUVTLTEyOCBDQkMgZGVjcnlwdGlvbiB3aXRoXG4gKiBQS0NTIzcgcGFkZGluZy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgX2FlcyA9IHJlcXVpcmUoJy4vYWVzJyk7XG5cbnZhciBfYWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Flcyk7XG5cbnZhciBfYXN5bmNTdHJlYW0gPSByZXF1aXJlKCcuL2FzeW5jLXN0cmVhbScpO1xuXG52YXIgX2FzeW5jU3RyZWFtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FzeW5jU3RyZWFtKTtcblxudmFyIF9wa2NzNyA9IHJlcXVpcmUoJ3BrY3M3Jyk7XG5cbi8qKlxuICogQ29udmVydCBuZXR3b3JrLW9yZGVyIChiaWctZW5kaWFuKSBieXRlcyBpbnRvIHRoZWlyIGxpdHRsZS1lbmRpYW5cbiAqIHJlcHJlc2VudGF0aW9uLlxuICovXG52YXIgbnRvaCA9IGZ1bmN0aW9uIG50b2god29yZCkge1xuICByZXR1cm4gd29yZCA8PCAyNCB8ICh3b3JkICYgMHhmZjAwKSA8PCA4IHwgKHdvcmQgJiAweGZmMDAwMCkgPj4gOCB8IHdvcmQgPj4+IDI0O1xufTtcblxuLyoqXG4gKiBEZWNyeXB0IGJ5dGVzIHVzaW5nIEFFUy0xMjggd2l0aCBDQkMgYW5kIFBLQ1MjNyBwYWRkaW5nLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZW5jcnlwdGVkIHRoZSBlbmNyeXB0ZWQgYnl0ZXNcbiAqIEBwYXJhbSB7VWludDMyQXJyYXl9IGtleSB0aGUgYnl0ZXMgb2YgdGhlIGRlY3J5cHRpb24ga2V5XG4gKiBAcGFyYW0ge1VpbnQzMkFycmF5fSBpbml0VmVjdG9yIHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgKElWKSB0b1xuICogdXNlIGZvciB0aGUgZmlyc3Qgcm91bmQgb2YgQ0JDLlxuICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIGRlY3J5cHRlZCBieXRlc1xuICpcbiAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BZHZhbmNlZF9FbmNyeXB0aW9uX1N0YW5kYXJkXG4gKiBAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmxvY2tfY2lwaGVyX21vZGVfb2Zfb3BlcmF0aW9uI0NpcGhlcl9CbG9ja19DaGFpbmluZ18uMjhDQkMuMjlcbiAqIEBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIzMTVcbiAqL1xudmFyIGRlY3J5cHQgPSBmdW5jdGlvbiBkZWNyeXB0KGVuY3J5cHRlZCwga2V5LCBpbml0VmVjdG9yKSB7XG4gIC8vIHdvcmQtbGV2ZWwgYWNjZXNzIHRvIHRoZSBlbmNyeXB0ZWQgYnl0ZXNcbiAgdmFyIGVuY3J5cHRlZDMyID0gbmV3IEludDMyQXJyYXkoZW5jcnlwdGVkLmJ1ZmZlciwgZW5jcnlwdGVkLmJ5dGVPZmZzZXQsIGVuY3J5cHRlZC5ieXRlTGVuZ3RoID4+IDIpO1xuXG4gIHZhciBkZWNpcGhlciA9IG5ldyBfYWVzMlsnZGVmYXVsdCddKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGtleSkpO1xuXG4gIC8vIGJ5dGUgYW5kIHdvcmQtbGV2ZWwgYWNjZXNzIGZvciB0aGUgZGVjcnlwdGVkIG91dHB1dFxuICB2YXIgZGVjcnlwdGVkID0gbmV3IFVpbnQ4QXJyYXkoZW5jcnlwdGVkLmJ5dGVMZW5ndGgpO1xuICB2YXIgZGVjcnlwdGVkMzIgPSBuZXcgSW50MzJBcnJheShkZWNyeXB0ZWQuYnVmZmVyKTtcblxuICAvLyB0ZW1wb3JhcnkgdmFyaWFibGVzIGZvciB3b3JraW5nIHdpdGggdGhlIElWLCBlbmNyeXB0ZWQsIGFuZFxuICAvLyBkZWNyeXB0ZWQgZGF0YVxuICB2YXIgaW5pdDAgPSB1bmRlZmluZWQ7XG4gIHZhciBpbml0MSA9IHVuZGVmaW5lZDtcbiAgdmFyIGluaXQyID0gdW5kZWZpbmVkO1xuICB2YXIgaW5pdDMgPSB1bmRlZmluZWQ7XG4gIHZhciBlbmNyeXB0ZWQwID0gdW5kZWZpbmVkO1xuICB2YXIgZW5jcnlwdGVkMSA9IHVuZGVmaW5lZDtcbiAgdmFyIGVuY3J5cHRlZDIgPSB1bmRlZmluZWQ7XG4gIHZhciBlbmNyeXB0ZWQzID0gdW5kZWZpbmVkO1xuXG4gIC8vIGl0ZXJhdGlvbiB2YXJpYWJsZVxuICB2YXIgd29yZEl4ID0gdW5kZWZpbmVkO1xuXG4gIC8vIHB1bGwgb3V0IHRoZSB3b3JkcyBvZiB0aGUgSVYgdG8gZW5zdXJlIHdlIGRvbid0IG1vZGlmeSB0aGVcbiAgLy8gcGFzc2VkLWluIHJlZmVyZW5jZSBhbmQgZWFzaWVyIGFjY2Vzc1xuICBpbml0MCA9IGluaXRWZWN0b3JbMF07XG4gIGluaXQxID0gaW5pdFZlY3RvclsxXTtcbiAgaW5pdDIgPSBpbml0VmVjdG9yWzJdO1xuICBpbml0MyA9IGluaXRWZWN0b3JbM107XG5cbiAgLy8gZGVjcnlwdCBmb3VyIHdvcmQgc2VxdWVuY2VzLCBhcHBseWluZyBjaXBoZXItYmxvY2sgY2hhaW5pbmcgKENCQylcbiAgLy8gdG8gZWFjaCBkZWNyeXB0ZWQgYmxvY2tcbiAgZm9yICh3b3JkSXggPSAwOyB3b3JkSXggPCBlbmNyeXB0ZWQzMi5sZW5ndGg7IHdvcmRJeCArPSA0KSB7XG4gICAgLy8gY29udmVydCBiaWctZW5kaWFuIChuZXR3b3JrIG9yZGVyKSB3b3JkcyBpbnRvIGxpdHRsZS1lbmRpYW5cbiAgICAvLyAoamF2YXNjcmlwdCBvcmRlcilcbiAgICBlbmNyeXB0ZWQwID0gbnRvaChlbmNyeXB0ZWQzMlt3b3JkSXhdKTtcbiAgICBlbmNyeXB0ZWQxID0gbnRvaChlbmNyeXB0ZWQzMlt3b3JkSXggKyAxXSk7XG4gICAgZW5jcnlwdGVkMiA9IG50b2goZW5jcnlwdGVkMzJbd29yZEl4ICsgMl0pO1xuICAgIGVuY3J5cHRlZDMgPSBudG9oKGVuY3J5cHRlZDMyW3dvcmRJeCArIDNdKTtcblxuICAgIC8vIGRlY3J5cHQgdGhlIGJsb2NrXG4gICAgZGVjaXBoZXIuZGVjcnlwdChlbmNyeXB0ZWQwLCBlbmNyeXB0ZWQxLCBlbmNyeXB0ZWQyLCBlbmNyeXB0ZWQzLCBkZWNyeXB0ZWQzMiwgd29yZEl4KTtcblxuICAgIC8vIFhPUiB3aXRoIHRoZSBJViwgYW5kIHJlc3RvcmUgbmV0d29yayBieXRlLW9yZGVyIHRvIG9idGFpbiB0aGVcbiAgICAvLyBwbGFpbnRleHRcbiAgICBkZWNyeXB0ZWQzMlt3b3JkSXhdID0gbnRvaChkZWNyeXB0ZWQzMlt3b3JkSXhdIF4gaW5pdDApO1xuICAgIGRlY3J5cHRlZDMyW3dvcmRJeCArIDFdID0gbnRvaChkZWNyeXB0ZWQzMlt3b3JkSXggKyAxXSBeIGluaXQxKTtcbiAgICBkZWNyeXB0ZWQzMlt3b3JkSXggKyAyXSA9IG50b2goZGVjcnlwdGVkMzJbd29yZEl4ICsgMl0gXiBpbml0Mik7XG4gICAgZGVjcnlwdGVkMzJbd29yZEl4ICsgM10gPSBudG9oKGRlY3J5cHRlZDMyW3dvcmRJeCArIDNdIF4gaW5pdDMpO1xuXG4gICAgLy8gc2V0dXAgdGhlIElWIGZvciB0aGUgbmV4dCByb3VuZFxuICAgIGluaXQwID0gZW5jcnlwdGVkMDtcbiAgICBpbml0MSA9IGVuY3J5cHRlZDE7XG4gICAgaW5pdDIgPSBlbmNyeXB0ZWQyO1xuICAgIGluaXQzID0gZW5jcnlwdGVkMztcbiAgfVxuXG4gIHJldHVybiBkZWNyeXB0ZWQ7XG59O1xuXG5leHBvcnRzLmRlY3J5cHQgPSBkZWNyeXB0O1xuLyoqXG4gKiBUaGUgYERlY3J5cHRlcmAgY2xhc3MgdGhhdCBtYW5hZ2VzIGRlY3J5cHRpb24gb2YgQUVTXG4gKiBkYXRhIHRocm91Z2ggYEFzeW5jU3RyZWFtYCBvYmplY3RzIGFuZCB0aGUgYGRlY3J5cHRgXG4gKiBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZW5jcnlwdGVkIHRoZSBlbmNyeXB0ZWQgYnl0ZXNcbiAqIEBwYXJhbSB7VWludDMyQXJyYXl9IGtleSB0aGUgYnl0ZXMgb2YgdGhlIGRlY3J5cHRpb24ga2V5XG4gKiBAcGFyYW0ge1VpbnQzMkFycmF5fSBpbml0VmVjdG9yIHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgKElWKSB0b1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZSB0aGUgZnVuY3Rpb24gdG8gcnVuIHdoZW4gZG9uZVxuICogQGNsYXNzIERlY3J5cHRlclxuICovXG5cbnZhciBEZWNyeXB0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEZWNyeXB0ZXIoZW5jcnlwdGVkLCBrZXksIGluaXRWZWN0b3IsIGRvbmUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVjcnlwdGVyKTtcblxuICAgIHZhciBzdGVwID0gRGVjcnlwdGVyLlNURVA7XG4gICAgdmFyIGVuY3J5cHRlZDMyID0gbmV3IEludDMyQXJyYXkoZW5jcnlwdGVkLmJ1ZmZlcik7XG4gICAgdmFyIGRlY3J5cHRlZCA9IG5ldyBVaW50OEFycmF5KGVuY3J5cHRlZC5ieXRlTGVuZ3RoKTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB0aGlzLmFzeW5jU3RyZWFtXyA9IG5ldyBfYXN5bmNTdHJlYW0yWydkZWZhdWx0J10oKTtcblxuICAgIC8vIHNwbGl0IHVwIHRoZSBlbmNyeXB0aW9uIGpvYiBhbmQgZG8gdGhlIGluZGl2aWR1YWwgY2h1bmtzIGFzeW5jaHJvbm91c2x5XG4gICAgdGhpcy5hc3luY1N0cmVhbV8ucHVzaCh0aGlzLmRlY3J5cHRDaHVua18oZW5jcnlwdGVkMzIuc3ViYXJyYXkoaSwgaSArIHN0ZXApLCBrZXksIGluaXRWZWN0b3IsIGRlY3J5cHRlZCkpO1xuICAgIGZvciAoaSA9IHN0ZXA7IGkgPCBlbmNyeXB0ZWQzMi5sZW5ndGg7IGkgKz0gc3RlcCkge1xuICAgICAgaW5pdFZlY3RvciA9IG5ldyBVaW50MzJBcnJheShbbnRvaChlbmNyeXB0ZWQzMltpIC0gNF0pLCBudG9oKGVuY3J5cHRlZDMyW2kgLSAzXSksIG50b2goZW5jcnlwdGVkMzJbaSAtIDJdKSwgbnRvaChlbmNyeXB0ZWQzMltpIC0gMV0pXSk7XG4gICAgICB0aGlzLmFzeW5jU3RyZWFtXy5wdXNoKHRoaXMuZGVjcnlwdENodW5rXyhlbmNyeXB0ZWQzMi5zdWJhcnJheShpLCBpICsgc3RlcCksIGtleSwgaW5pdFZlY3RvciwgZGVjcnlwdGVkKSk7XG4gICAgfVxuICAgIC8vIGludm9rZSB0aGUgZG9uZSgpIGNhbGxiYWNrIHdoZW4gZXZlcnl0aGluZyBpcyBmaW5pc2hlZFxuICAgIHRoaXMuYXN5bmNTdHJlYW1fLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgLy8gcmVtb3ZlIHBrY3MjNyBwYWRkaW5nIGZyb20gdGhlIGRlY3J5cHRlZCBieXRlc1xuICAgICAgZG9uZShudWxsLCAoMCwgX3BrY3M3LnVucGFkKShkZWNyeXB0ZWQpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBhIGdldHRlciBmb3Igc3RlcCB0aGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdG8gcHJvY2VzcyBhdCBvbmUgdGltZVxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSB2YWx1ZSBvZiBzdGVwIDMyMDAwXG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhEZWNyeXB0ZXIsIFt7XG4gICAga2V5OiAnZGVjcnlwdENodW5rXycsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyeXB0Q2h1bmtfKGVuY3J5cHRlZCwga2V5LCBpbml0VmVjdG9yLCBkZWNyeXB0ZWQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBieXRlcyA9IGRlY3J5cHQoZW5jcnlwdGVkLCBrZXksIGluaXRWZWN0b3IpO1xuXG4gICAgICAgIGRlY3J5cHRlZC5zZXQoYnl0ZXMsIGVuY3J5cHRlZC5ieXRlT2Zmc2V0KTtcbiAgICAgIH07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdTVEVQJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIC8vIDQgKiA4MDAwO1xuICAgICAgcmV0dXJuIDMyMDAwO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEZWNyeXB0ZXI7XG59KSgpO1xuXG5leHBvcnRzLkRlY3J5cHRlciA9IERlY3J5cHRlcjtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgRGVjcnlwdGVyOiBEZWNyeXB0ZXIsXG4gIGRlY3J5cHQ6IGRlY3J5cHRcbn07XG59LHtcIi4vYWVzXCI6MjIsXCIuL2FzeW5jLXN0cmVhbVwiOjIzLFwicGtjczdcIjoyOH1dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgaW5kZXguanNcbiAqXG4gKiBJbmRleCBtb2R1bGUgdG8gZWFzaWx5IGltcG9ydCB0aGUgcHJpbWFyeSBjb21wb25lbnRzIG9mIEFFUy0xMjhcbiAqIGRlY3J5cHRpb24uIExpa2UgdGhpczpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHtEZWNyeXB0ZXIsIGRlY3J5cHQsIEFzeW5jU3RyZWFtfSBmcm9tICdhZXMtZGVjcnlwdGVyJztcbiAqIGBgYFxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfZGVjcnlwdGVyID0gcmVxdWlyZSgnLi9kZWNyeXB0ZXInKTtcblxudmFyIF9hc3luY1N0cmVhbSA9IHJlcXVpcmUoJy4vYXN5bmMtc3RyZWFtJyk7XG5cbnZhciBfYXN5bmNTdHJlYW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXN5bmNTdHJlYW0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIGRlY3J5cHQ6IF9kZWNyeXB0ZXIuZGVjcnlwdCxcbiAgRGVjcnlwdGVyOiBfZGVjcnlwdGVyLkRlY3J5cHRlcixcbiAgQXN5bmNTdHJlYW06IF9hc3luY1N0cmVhbTJbJ2RlZmF1bHQnXVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSx7XCIuL2FzeW5jLXN0cmVhbVwiOjIzLFwiLi9kZWNyeXB0ZXJcIjoyNH1dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgc3RyZWFtLmpzXG4gKi9cbi8qKlxuICogQSBsaWdodHdlaWdodCByZWFkYWJsZSBzdHJlYW0gaW1wbGVtZW50aW9uIHRoYXQgaGFuZGxlcyBldmVudCBkaXNwYXRjaGluZy5cbiAqXG4gKiBAY2xhc3MgU3RyZWFtXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgU3RyZWFtID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RyZWFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJlYW0pO1xuXG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBzcGVjaWZpZWQgZXZlbnQgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIGV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgdGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBhbiBldmVudCBvZlxuICAgKiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzXG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhTdHJlYW0sIFt7XG4gICAga2V5OiAnb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbGlzdGVuZXIgZm9yIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyICBhIGZ1bmN0aW9uIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBmb3IgdGhpc1xuICAgICAqIHR5cGUgb2YgZXZlbnQgdGhyb3VnaCBgb25gXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gaWYgd2UgY291bGQgdHVybiBpdCBvZmYgb3Igbm90XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdvZmYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvZmYodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpbmRleCA9IHRoaXMubGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHJldHVybiBpbmRleCA+IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9uIHRoaXMgc3RyZWFtLiBBbnkgYWRkaXRpb25hbFxuICAgICAqIGFyZ3VtZW50cyB0byB0aGlzIGZ1bmN0aW9uIGFyZSBwYXNzZWQgYXMgcGFyYW1ldGVycyB0byBldmVudCBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgZXZlbnQgbmFtZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAndHJpZ2dlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyaWdnZXIodHlwZSkge1xuICAgICAgdmFyIGNhbGxiYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBpID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhcmdzID0gdW5kZWZpbmVkO1xuXG4gICAgICBjYWxsYmFja3MgPSB0aGlzLmxpc3RlbmVyc1t0eXBlXTtcbiAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFNsaWNpbmcgdGhlIGFyZ3VtZW50cyBvbiBldmVyeSBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kXG4gICAgICAvLyBjYW4gYWRkIGEgc2lnbmlmaWNhbnQgYW1vdW50IG9mIG92ZXJoZWFkLiBBdm9pZCB0aGVcbiAgICAgIC8vIGludGVybWVkaWF0ZSBvYmplY3QgY3JlYXRpb24gZm9yIHRoZSBjb21tb24gY2FzZSBvZiBhXG4gICAgICAvLyBzaW5nbGUgY2FsbGJhY2sgYXJndW1lbnRcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGxlbmd0aCA9IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBsZW5ndGggPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgc3RyZWFtIGFuZCBjbGVhbnMgdXAuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdkaXNwb3NlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yd2FyZHMgYWxsIGBkYXRhYCBldmVudHMgb24gdGhpcyBzdHJlYW0gdG8gdGhlIGRlc3RpbmF0aW9uIHN0cmVhbS4gVGhlXG4gICAgICogZGVzdGluYXRpb24gc3RyZWFtIHNob3VsZCBwcm92aWRlIGEgbWV0aG9kIGBwdXNoYCB0byByZWNlaXZlIHRoZSBkYXRhXG4gICAgICogZXZlbnRzIGFzIHRoZXkgYXJyaXZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJlYW19IGRlc3RpbmF0aW9uIHRoZSBzdHJlYW0gdGhhdCB3aWxsIHJlY2VpdmUgYWxsIGBkYXRhYCBldmVudHNcbiAgICAgKiBAc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fcmVhZGFibGVfcGlwZV9kZXN0aW5hdGlvbl9vcHRpb25zXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdwaXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGlwZShkZXN0aW5hdGlvbikge1xuICAgICAgdGhpcy5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uLnB1c2goZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RyZWFtO1xufSkoKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU3RyZWFtO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG59LHt9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogcGtjczcucGFkXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYnJpZ2h0Y292ZS9wa2NzN1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcmlnaHRjb3ZlXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgYXBhY2hlMiBsaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBBRERJTkc7XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBVaW50OEFycmF5IHRoYXQgaXMgcGFkZGVkIHdpdGggUEtDUyM3IHBhZGRpbmcuXG4gKiBAcGFyYW0gcGxhaW50ZXh0IHtVaW50OEFycmF5fSB0aGUgaW5wdXQgYnl0ZXMgYmVmb3JlIGVuY3J5cHRpb25cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHRoZSBwYWRkZWQgYnl0ZXNcbiAqIEBzZWUgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTY1MlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhZChwbGFpbnRleHQpIHtcbiAgdmFyIHBhZGRpbmcgPSBQQURESU5HWyhwbGFpbnRleHQuYnl0ZUxlbmd0aCAlIDE2KSB8fCAwXSxcbiAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHBsYWludGV4dC5ieXRlTGVuZ3RoICsgcGFkZGluZy5sZW5ndGgpO1xuICByZXN1bHQuc2V0KHBsYWludGV4dCk7XG4gIHJlc3VsdC5zZXQocGFkZGluZywgcGxhaW50ZXh0LmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gcHJlLWRlZmluZSB0aGUgcGFkZGluZyB2YWx1ZXNcblBBRERJTkcgPSBbXG4gIFsxNiwgMTYsIDE2LCAxNixcbiAgIDE2LCAxNiwgMTYsIDE2LFxuICAgMTYsIDE2LCAxNiwgMTYsXG4gICAxNiwgMTYsIDE2LCAxNl0sXG5cbiAgWzE1LCAxNSwgMTUsIDE1LFxuICAgMTUsIDE1LCAxNSwgMTUsXG4gICAxNSwgMTUsIDE1LCAxNSxcbiAgIDE1LCAxNSwgMTVdLFxuXG4gIFsxNCwgMTQsIDE0LCAxNCxcbiAgIDE0LCAxNCwgMTQsIDE0LFxuICAgMTQsIDE0LCAxNCwgMTQsXG4gICAxNCwgMTRdLFxuXG4gIFsxMywgMTMsIDEzLCAxMyxcbiAgIDEzLCAxMywgMTMsIDEzLFxuICAgMTMsIDEzLCAxMywgMTMsXG4gICAxM10sXG5cbiAgWzEyLCAxMiwgMTIsIDEyLFxuICAgMTIsIDEyLCAxMiwgMTIsXG4gICAxMiwgMTIsIDEyLCAxMl0sXG5cbiAgWzExLCAxMSwgMTEsIDExLFxuICAgMTEsIDExLCAxMSwgMTEsXG4gICAxMSwgMTEsIDExXSxcblxuICBbMTAsIDEwLCAxMCwgMTAsXG4gICAxMCwgMTAsIDEwLCAxMCxcbiAgIDEwLCAxMF0sXG5cbiAgWzksIDksIDksIDksXG4gICA5LCA5LCA5LCA5LFxuICAgOV0sXG5cbiAgWzgsIDgsIDgsIDgsXG4gICA4LCA4LCA4LCA4XSxcblxuICBbNywgNywgNywgNyxcbiAgIDcsIDcsIDddLFxuXG4gIFs2LCA2LCA2LCA2LFxuICAgNiwgNl0sXG5cbiAgWzUsIDUsIDUsIDUsXG4gICA1XSxcblxuICBbNCwgNCwgNCwgNF0sXG5cbiAgWzMsIDMsIDNdLFxuXG4gIFsyLCAyXSxcblxuICBbMV1cbl07XG5cbn0se31dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBwa2NzN1xuICogaHR0cHM6Ly9naXRodWIuY29tL2JyaWdodGNvdmUvcGtjczdcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQnJpZ2h0Y292ZVxuICogTGljZW5zZWQgdW5kZXIgdGhlIGFwYWNoZTIgbGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMucGFkID0gcmVxdWlyZSgnLi9wYWQuanMnKTtcbmV4cG9ydHMudW5wYWQgPSByZXF1aXJlKCcuL3VucGFkLmpzJyk7XG5cbn0se1wiLi9wYWQuanNcIjoyNyxcIi4vdW5wYWQuanNcIjoyOX1dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBwa2NzNy51bnBhZFxuICogaHR0cHM6Ly9naXRodWIuY29tL2JyaWdodGNvdmUvcGtjczdcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQnJpZ2h0Y292ZVxuICogTGljZW5zZWQgdW5kZXIgdGhlIGFwYWNoZTIgbGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3ViYXJyYXkgb2YgYSBVaW50OEFycmF5IHdpdGhvdXQgUEtDUyM3IHBhZGRpbmcuXG4gKiBAcGFyYW0gcGFkZGVkIHtVaW50OEFycmF5fSB1bmVuY3J5cHRlZCBieXRlcyB0aGF0IGhhdmUgYmVlbiBwYWRkZWRcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHRoZSB1bnBhZGRlZCBieXRlc1xuICogQHNlZSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1NjUyXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdW5wYWQocGFkZGVkKSB7XG4gIHJldHVybiBwYWRkZWQuc3ViYXJyYXkoMCwgcGFkZGVkLmJ5dGVMZW5ndGggLSBwYWRkZWRbcGFkZGVkLmJ5dGVMZW5ndGggLSAxXSk7XG59O1xuXG59LHt9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cbn0se31dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciB0b3BMZXZlbCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDpcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9XG52YXIgbWluRG9jID0gcmVxdWlyZSgnbWluLWRvY3VtZW50Jyk7XG5cbnZhciBkb2NjeTtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkb2NjeSA9IGRvY3VtZW50O1xufSBlbHNlIHtcbiAgICBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J107XG5cbiAgICBpZiAoIWRvY2N5KSB7XG4gICAgICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXSA9IG1pbkRvYztcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG9jY3k7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCJtaW4tZG9jdW1lbnRcIjozMH1dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciB3aW47XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgd2luID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgd2luID0ge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9saW5lU3RyZWFtID0gcmVxdWlyZSgnLi9saW5lLXN0cmVhbScpO1xuXG52YXIgX2xpbmVTdHJlYW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGluZVN0cmVhbSk7XG5cbnZhciBfcGFyc2VTdHJlYW0gPSByZXF1aXJlKCcuL3BhcnNlLXN0cmVhbScpO1xuXG52YXIgX3BhcnNlU3RyZWFtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcnNlU3RyZWFtKTtcblxudmFyIF9wYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xuXG52YXIgX3BhcnNlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJzZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBMaW5lU3RyZWFtOiBfbGluZVN0cmVhbTJbJ2RlZmF1bHQnXSxcbiAgUGFyc2VTdHJlYW06IF9wYXJzZVN0cmVhbTJbJ2RlZmF1bHQnXSxcbiAgUGFyc2VyOiBfcGFyc2VyMlsnZGVmYXVsdCddXG59OyAvKipcbiAgICAqIEBmaWxlIG0zdTgvaW5kZXguanNcbiAgICAqXG4gICAgKiBVdGlsaXRpZXMgZm9yIHBhcnNpbmcgTTNVOCBmaWxlcy4gSWYgdGhlIGVudGlyZSBtYW5pZmVzdCBpcyBhdmFpbGFibGUsXG4gICAgKiBgUGFyc2VyYCB3aWxsIGNyZWF0ZSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24gd2l0aCBlbm91Z2ggZGV0YWlsIGZvciBtYW5hZ2luZ1xuICAgICogcGxheWJhY2suIGBQYXJzZVN0cmVhbWAgYW5kIGBMaW5lU3RyZWFtYCBhcmUgbG93ZXItbGV2ZWwgcGFyc2luZyBwcmltaXRpdmVzXG4gICAgKiB0aGF0IGRvIG5vdCBhc3N1bWUgdGhlIGVudGlyZXR5IG9mIHRoZSBtYW5pZmVzdCBpcyByZWFkeSBhbmQgZXhwb3NlIGFcbiAgICAqIFJlYWRhYmxlU3RyZWFtLWxpa2UgaW50ZXJmYWNlLlxuICAgICovXG59LHtcIi4vbGluZS1zdHJlYW1cIjozNCxcIi4vcGFyc2Utc3RyZWFtXCI6MzUsXCIuL3BhcnNlclwiOjM2fV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3N0cmVhbSA9IHJlcXVpcmUoJy4vc3RyZWFtJyk7XG5cbnZhciBfc3RyZWFtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmVhbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmaWxlIG0zdTgvbGluZS1zdHJlYW0uanNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5cbi8qKlxuICogQSBzdHJlYW0gdGhhdCBidWZmZXJzIHN0cmluZyBpbnB1dCBhbmQgZ2VuZXJhdGVzIGEgYGRhdGFgIGV2ZW50IGZvciBlYWNoXG4gKiBsaW5lLlxuICpcbiAqIEBjbGFzcyBMaW5lU3RyZWFtXG4gKiBAZXh0ZW5kcyBTdHJlYW1cbiAqL1xudmFyIExpbmVTdHJlYW0gPSBmdW5jdGlvbiAoX1N0cmVhbSkge1xuICBfaW5oZXJpdHMoTGluZVN0cmVhbSwgX1N0cmVhbSk7XG5cbiAgZnVuY3Rpb24gTGluZVN0cmVhbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluZVN0cmVhbSk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTGluZVN0cmVhbS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExpbmVTdHJlYW0pKS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLmJ1ZmZlciA9ICcnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbmV3IGRhdGEgdG8gYmUgcGFyc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0aGUgdGV4dCB0byBwcm9jZXNzXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKExpbmVTdHJlYW0sIFt7XG4gICAga2V5OiAncHVzaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2goZGF0YSkge1xuICAgICAgdmFyIG5leHROZXdsaW5lID0gdm9pZCAwO1xuXG4gICAgICB0aGlzLmJ1ZmZlciArPSBkYXRhO1xuICAgICAgbmV4dE5ld2xpbmUgPSB0aGlzLmJ1ZmZlci5pbmRleE9mKCdcXG4nKTtcblxuICAgICAgZm9yICg7IG5leHROZXdsaW5lID4gLTE7IG5leHROZXdsaW5lID0gdGhpcy5idWZmZXIuaW5kZXhPZignXFxuJykpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgdGhpcy5idWZmZXIuc3Vic3RyaW5nKDAsIG5leHROZXdsaW5lKSk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKG5leHROZXdsaW5lICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpbmVTdHJlYW07XG59KF9zdHJlYW0yWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBMaW5lU3RyZWFtO1xufSx7XCIuL3N0cmVhbVwiOjM3fV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfc3RyZWFtID0gcmVxdWlyZSgnLi9zdHJlYW0nKTtcblxudmFyIF9zdHJlYW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyZWFtKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZpbGUgbTN1OC9wYXJzZS1zdHJlYW0uanNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG5cbi8qKlxuICogXCJmb3JnaXZpbmdcIiBhdHRyaWJ1dGUgbGlzdCBwc3VlZG8tZ3JhbW1hcjpcbiAqIGF0dHJpYnV0ZXMgLT4ga2V5dmFsdWUgKCcsJyBrZXl2YWx1ZSkqXG4gKiBrZXl2YWx1ZSAgIC0+IGtleSAnPScgdmFsdWVcbiAqIGtleSAgICAgICAgLT4gW149XSpcbiAqIHZhbHVlICAgICAgLT4gJ1wiJyBbXlwiXSogJ1wiJyB8IFteLF0qXG4gKi9cbnZhciBhdHRyaWJ1dGVTZXBhcmF0b3IgPSBmdW5jdGlvbiBhdHRyaWJ1dGVTZXBhcmF0b3IoKSB7XG4gIHZhciBrZXkgPSAnW149XSonO1xuICB2YXIgdmFsdWUgPSAnXCJbXlwiXSpcInxbXixdKic7XG4gIHZhciBrZXl2YWx1ZSA9ICcoPzonICsga2V5ICsgJyk9KD86JyArIHZhbHVlICsgJyknO1xuXG4gIHJldHVybiBuZXcgUmVnRXhwKCcoPzpefCwpKCcgKyBrZXl2YWx1ZSArICcpJyk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGF0dHJpYnV0ZXMgZnJvbSBhIGxpbmUgZ2l2ZW4gdGhlIHNlcGVyYXRvclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVzIHRoZSBhdHRpYnV0ZSBsaW5lIHRvIHBhcnNlXG4gKi9cbnZhciBwYXJzZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAvLyBzcGxpdCB0aGUgc3RyaW5nIHVzaW5nIGF0dHJpYnV0ZXMgYXMgdGhlIHNlcGFyYXRvclxuICB2YXIgYXR0cnMgPSBhdHRyaWJ1dGVzLnNwbGl0KGF0dHJpYnV0ZVNlcGFyYXRvcigpKTtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgaSA9IGF0dHJzLmxlbmd0aDtcbiAgdmFyIGF0dHIgPSB2b2lkIDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIC8vIGZpbHRlciBvdXQgdW5tYXRjaGVkIHBvcnRpb25zIG9mIHRoZSBzdHJpbmdcbiAgICBpZiAoYXR0cnNbaV0gPT09ICcnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBzcGxpdCB0aGUga2V5IGFuZCB2YWx1ZVxuICAgIGF0dHIgPSAvKFtePV0qKT0oLiopLy5leGVjKGF0dHJzW2ldKS5zbGljZSgxKTtcbiAgICAvLyB0cmltIHdoaXRlc3BhY2UgYW5kIHJlbW92ZSBvcHRpb25hbCBxdW90ZXMgYXJvdW5kIHRoZSB2YWx1ZVxuICAgIGF0dHJbMF0gPSBhdHRyWzBdLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgICBhdHRyWzFdID0gYXR0clsxXS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gICAgYXR0clsxXSA9IGF0dHJbMV0ucmVwbGFjZSgvXlsnXCJdKC4qKVsnXCJdJC9nLCAnJDEnKTtcbiAgICByZXN1bHRbYXR0clswXV0gPSBhdHRyWzFdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEEgbGluZS1sZXZlbCBNM1U4IHBhcnNlciBldmVudCBzdHJlYW0uIEl0IGV4cGVjdHMgdG8gcmVjZWl2ZSBpbnB1dCBvbmVcbiAqIGxpbmUgYXQgYSB0aW1lIGFuZCBwZXJmb3JtcyBhIGNvbnRleHQtZnJlZSBwYXJzZSBvZiBpdHMgY29udGVudHMuIEEgc3RyZWFtXG4gKiBpbnRlcnByZXRhdGlvbiBvZiBhIG1hbmlmZXN0IGNhbiBiZSB1c2VmdWwgaWYgdGhlIG1hbmlmZXN0IGlzIGV4cGVjdGVkIHRvXG4gKiBiZSB0b28gbGFyZ2UgdG8gZml0IGNvbWZvcnRhYmx5IGludG8gbWVtb3J5IG9yIHRoZSBlbnRpcmV0eSBvZiB0aGUgaW5wdXRcbiAqIGlzIG5vdCBpbW1lZGlhdGVseSBhdmFpbGFibGUuIE90aGVyd2lzZSwgaXQncyBwcm9iYWJseSBtdWNoIGVhc2llciB0byB3b3JrXG4gKiB3aXRoIGEgcmVndWxhciBgUGFyc2VyYCBvYmplY3QuXG4gKlxuICogUHJvZHVjZXMgYGRhdGFgIGV2ZW50cyB3aXRoIGFuIG9iamVjdCB0aGF0IGNhcHR1cmVzIHRoZSBwYXJzZXInc1xuICogaW50ZXJwcmV0YXRpb24gb2YgdGhlIGlucHV0LiBUaGF0IG9iamVjdCBoYXMgYSBwcm9wZXJ0eSBgdGFnYCB0aGF0IGlzIG9uZVxuICogb2YgYHVyaWAsIGBjb21tZW50YCwgb3IgYHRhZ2AuIFVSSXMgb25seSBoYXZlIGEgc2luZ2xlIGFkZGl0aW9uYWxcbiAqIHByb3BlcnR5LCBgbGluZWAsIHdoaWNoIGNhcHR1cmVzIHRoZSBlbnRpcmV0eSBvZiB0aGUgaW5wdXQgd2l0aG91dFxuICogaW50ZXJwcmV0YXRpb24uIENvbW1lbnRzIHNpbWlsYXJseSBoYXZlIGEgc2luZ2xlIGFkZGl0aW9uYWwgcHJvcGVydHlcbiAqIGB0ZXh0YCB3aGljaCBpcyB0aGUgaW5wdXQgd2l0aG91dCB0aGUgbGVhZGluZyBgI2AuXG4gKlxuICogVGFncyBhbHdheXMgaGF2ZSBhIHByb3BlcnR5IGB0YWdUeXBlYCB3aGljaCBpcyB0aGUgbG93ZXItY2FzZWQgdmVyc2lvbiBvZlxuICogdGhlIE0zVTggZGlyZWN0aXZlIHdpdGhvdXQgdGhlIGAjRVhUYCBvciBgI0VYVC1YLWAgcHJlZml4LiBGb3IgaW5zdGFuY2UsXG4gKiBgI0VYVC1YLU1FRElBLVNFUVVFTkNFYCBiZWNvbWVzIGBtZWRpYS1zZXF1ZW5jZWAgd2hlbiBwYXJzZWQuIFVucmVjb2duaXplZFxuICogdGFncyBhcmUgZ2l2ZW4gdGhlIHRhZyB0eXBlIGB1bmtub3duYCBhbmQgYSBzaW5nbGUgYWRkaXRpb25hbCBwcm9wZXJ0eVxuICogYGRhdGFgIHdpdGggdGhlIHJlbWFpbmRlciBvZiB0aGUgaW5wdXQuXG4gKlxuICogQGNsYXNzIFBhcnNlU3RyZWFtXG4gKiBAZXh0ZW5kcyBTdHJlYW1cbiAqL1xuXG52YXIgUGFyc2VTdHJlYW0gPSBmdW5jdGlvbiAoX1N0cmVhbSkge1xuICBfaW5oZXJpdHMoUGFyc2VTdHJlYW0sIF9TdHJlYW0pO1xuXG4gIGZ1bmN0aW9uIFBhcnNlU3RyZWFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXJzZVN0cmVhbSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFBhcnNlU3RyZWFtLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUGFyc2VTdHJlYW0pKS5jYWxsKHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gYWRkaXRpb25hbCBsaW5lIG9mIGlucHV0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZSBhIHNpbmdsZSBsaW5lIG9mIGFuIE0zVTggZmlsZSB0byBwYXJzZVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhQYXJzZVN0cmVhbSwgW3tcbiAgICBrZXk6ICdwdXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChsaW5lKSB7XG4gICAgICB2YXIgbWF0Y2ggPSB2b2lkIDA7XG4gICAgICB2YXIgZXZlbnQgPSB2b2lkIDA7XG5cbiAgICAgIC8vIHN0cmlwIHdoaXRlc3BhY2VcbiAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL15bXFx1MDAwMFxcc10rfFtcXHUwMDAwXFxzXSskL2csICcnKTtcbiAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBpZ25vcmUgZW1wdHkgbGluZXNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBVUklzXG4gICAgICBpZiAobGluZVswXSAhPT0gJyMnKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIHtcbiAgICAgICAgICB0eXBlOiAndXJpJyxcbiAgICAgICAgICB1cmk6IGxpbmVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ29tbWVudHNcbiAgICAgIGlmIChsaW5lLmluZGV4T2YoJyNFWFQnKSAhPT0gMCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB7XG4gICAgICAgICAgdHlwZTogJ2NvbW1lbnQnLFxuICAgICAgICAgIHRleHQ6IGxpbmUuc2xpY2UoMSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gc3RyaXAgb2ZmIGFueSBjYXJyaWFnZSByZXR1cm5zIGhlcmUgc28gdGhlIHJlZ2V4IG1hdGNoaW5nXG4gICAgICAvLyBkb2Vzbid0IGhhdmUgdG8gYWNjb3VudCBmb3IgdGhlbS5cbiAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoJ1xccicsICcnKTtcblxuICAgICAgLy8gVGFnc1xuICAgICAgbWF0Y2ggPSAvXiNFWFRNM1UvLmV4ZWMobGluZSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywge1xuICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgIHRhZ1R5cGU6ICdtM3UnXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXRjaCA9IC9eI0VYVElORjo/KFswLTlcXC5dKik/LD8oLiopPyQvLmV4ZWMobGluZSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ2luZidcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgZXZlbnQuZHVyYXRpb24gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgICBldmVudC50aXRsZSA9IG1hdGNoWzJdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWF0Y2ggPSAvXiNFWFQtWC1UQVJHRVREVVJBVElPTjo/KFswLTkuXSopPy8uZXhlYyhsaW5lKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAndGFyZ2V0ZHVyYXRpb24nXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgIGV2ZW50LmR1cmF0aW9uID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hdGNoID0gL14jWkVOLVRPVEFMLURVUkFUSU9OOj8oWzAtOS5dKik/Ly5leGVjKGxpbmUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgIHRhZ1R5cGU6ICd0b3RhbGR1cmF0aW9uJ1xuICAgICAgICB9O1xuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICBldmVudC5kdXJhdGlvbiA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXRjaCA9IC9eI0VYVC1YLVZFUlNJT046PyhbMC05Ll0qKT8vLmV4ZWMobGluZSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ3ZlcnNpb24nXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgIGV2ZW50LnZlcnNpb24gPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWF0Y2ggPSAvXiNFWFQtWC1NRURJQS1TRVFVRU5DRTo/KFxcLT9bMC05Ll0qKT8vLmV4ZWMobGluZSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ21lZGlhLXNlcXVlbmNlJ1xuICAgICAgICB9O1xuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICBldmVudC5udW1iZXIgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWF0Y2ggPSAvXiNFWFQtWC1ESVNDT05USU5VSVRZLVNFUVVFTkNFOj8oXFwtP1swLTkuXSopPy8uZXhlYyhsaW5lKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAnZGlzY29udGludWl0eS1zZXF1ZW5jZSdcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgZXZlbnQubnVtYmVyID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hdGNoID0gL14jRVhULVgtUExBWUxJU1QtVFlQRTo/KC4qKT8kLy5leGVjKGxpbmUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgIHRhZ1R5cGU6ICdwbGF5bGlzdC10eXBlJ1xuICAgICAgICB9O1xuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICBldmVudC5wbGF5bGlzdFR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hdGNoID0gL14jRVhULVgtQllURVJBTkdFOj8oWzAtOS5dKik/QD8oWzAtOS5dKik/Ly5leGVjKGxpbmUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgIHRhZ1R5cGU6ICdieXRlcmFuZ2UnXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgIGV2ZW50Lmxlbmd0aCA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgICAgZXZlbnQub2Zmc2V0ID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hdGNoID0gL14jRVhULVgtQUxMT1ctQ0FDSEU6PyhZRVN8Tk8pPy8uZXhlYyhsaW5lKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAnYWxsb3ctY2FjaGUnXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgIGV2ZW50LmFsbG93ZWQgPSAhL05PLy50ZXN0KG1hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hdGNoID0gL14jRVhULVgtTUFQOj8oLiopJC8uZXhlYyhsaW5lKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAnbWFwJ1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKG1hdGNoWzFdKTtcblxuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLlVSSSkge1xuICAgICAgICAgICAgZXZlbnQudXJpID0gYXR0cmlidXRlcy5VUkk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLkJZVEVSQU5HRSkge1xuICAgICAgICAgICAgdmFyIF9hdHRyaWJ1dGVzJEJZVEVSQU5HRSA9IGF0dHJpYnV0ZXMuQllURVJBTkdFLnNwbGl0KCdAJyksXG4gICAgICAgICAgICAgICAgX2F0dHJpYnV0ZXMkQllURVJBTkdFMiA9IF9zbGljZWRUb0FycmF5KF9hdHRyaWJ1dGVzJEJZVEVSQU5HRSwgMiksXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gX2F0dHJpYnV0ZXMkQllURVJBTkdFMlswXSxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBfYXR0cmlidXRlcyRCWVRFUkFOR0UyWzFdO1xuXG4gICAgICAgICAgICBldmVudC5ieXRlcmFuZ2UgPSB7fTtcbiAgICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgZXZlbnQuYnl0ZXJhbmdlLmxlbmd0aCA9IHBhcnNlSW50KGxlbmd0aCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgICAgICBldmVudC5ieXRlcmFuZ2Uub2Zmc2V0ID0gcGFyc2VJbnQob2Zmc2V0LCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXRjaCA9IC9eI0VYVC1YLVNUUkVBTS1JTkY6PyguKikkLy5leGVjKGxpbmUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgIHRhZ1R5cGU6ICdzdHJlYW0taW5mJ1xuICAgICAgICB9O1xuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKG1hdGNoWzFdKTtcblxuICAgICAgICAgIGlmIChldmVudC5hdHRyaWJ1dGVzLlJFU09MVVRJT04pIHtcbiAgICAgICAgICAgIHZhciBzcGxpdCA9IGV2ZW50LmF0dHJpYnV0ZXMuUkVTT0xVVElPTi5zcGxpdCgneCcpO1xuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSB7fTtcblxuICAgICAgICAgICAgaWYgKHNwbGl0WzBdKSB7XG4gICAgICAgICAgICAgIHJlc29sdXRpb24ud2lkdGggPSBwYXJzZUludChzcGxpdFswXSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNwbGl0WzFdKSB7XG4gICAgICAgICAgICAgIHJlc29sdXRpb24uaGVpZ2h0ID0gcGFyc2VJbnQoc3BsaXRbMV0sIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMuUkVTT0xVVElPTiA9IHJlc29sdXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldmVudC5hdHRyaWJ1dGVzLkJBTkRXSURUSCkge1xuICAgICAgICAgICAgZXZlbnQuYXR0cmlidXRlcy5CQU5EV0lEVEggPSBwYXJzZUludChldmVudC5hdHRyaWJ1dGVzLkJBTkRXSURUSCwgMTApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQuYXR0cmlidXRlc1snUFJPR1JBTS1JRCddKSB7XG4gICAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzWydQUk9HUkFNLUlEJ10gPSBwYXJzZUludChldmVudC5hdHRyaWJ1dGVzWydQUk9HUkFNLUlEJ10sIDEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXRjaCA9IC9eI0VYVC1YLU1FRElBOj8oLiopJC8uZXhlYyhsaW5lKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAnbWVkaWEnXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMgPSBwYXJzZUF0dHJpYnV0ZXMobWF0Y2hbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWF0Y2ggPSAvXiNFWFQtWC1FTkRMSVNULy5leGVjKGxpbmUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAnZW5kbGlzdCdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hdGNoID0gL14jRVhULVgtRElTQ09OVElOVUlUWS8uZXhlYyhsaW5lKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ2Rpc2NvbnRpbnVpdHknXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXRjaCA9IC9eI0VYVC1YLVBST0dSQU0tREFURS1USU1FOj8oLiopJC8uZXhlYyhsaW5lKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAncHJvZ3JhbS1kYXRlLXRpbWUnXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgIGV2ZW50LmRhdGVUaW1lU3RyaW5nID0gbWF0Y2hbMV07XG4gICAgICAgICAgZXZlbnQuZGF0ZVRpbWVPYmplY3QgPSBuZXcgRGF0ZShtYXRjaFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXRjaCA9IC9eI0VYVC1YLUtFWTo/KC4qKSQvLmV4ZWMobGluZSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ2tleSdcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgZXZlbnQuYXR0cmlidXRlcyA9IHBhcnNlQXR0cmlidXRlcyhtYXRjaFsxXSk7XG4gICAgICAgICAgLy8gcGFyc2UgdGhlIElWIHN0cmluZyBpbnRvIGEgVWludDMyQXJyYXlcbiAgICAgICAgICBpZiAoZXZlbnQuYXR0cmlidXRlcy5JVikge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmF0dHJpYnV0ZXMuSVYuc3Vic3RyaW5nKDAsIDIpLnRvTG93ZXJDYXNlKCkgPT09ICcweCcpIHtcbiAgICAgICAgICAgICAgZXZlbnQuYXR0cmlidXRlcy5JViA9IGV2ZW50LmF0dHJpYnV0ZXMuSVYuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzLklWID0gZXZlbnQuYXR0cmlidXRlcy5JVi5tYXRjaCgvLns4fS9nKTtcbiAgICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMuSVZbMF0gPSBwYXJzZUludChldmVudC5hdHRyaWJ1dGVzLklWWzBdLCAxNik7XG4gICAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzLklWWzFdID0gcGFyc2VJbnQoZXZlbnQuYXR0cmlidXRlcy5JVlsxXSwgMTYpO1xuICAgICAgICAgICAgZXZlbnQuYXR0cmlidXRlcy5JVlsyXSA9IHBhcnNlSW50KGV2ZW50LmF0dHJpYnV0ZXMuSVZbMl0sIDE2KTtcbiAgICAgICAgICAgIGV2ZW50LmF0dHJpYnV0ZXMuSVZbM10gPSBwYXJzZUludChldmVudC5hdHRyaWJ1dGVzLklWWzNdLCAxNik7XG4gICAgICAgICAgICBldmVudC5hdHRyaWJ1dGVzLklWID0gbmV3IFVpbnQzMkFycmF5KGV2ZW50LmF0dHJpYnV0ZXMuSVYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hdGNoID0gL14jRVhULVgtQ1VFLU9VVC1DT05UOj8oLiopPyQvLmV4ZWMobGluZSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgdHlwZTogJ3RhZycsXG4gICAgICAgICAgdGFnVHlwZTogJ2N1ZS1vdXQtY29udCdcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgZXZlbnQuZGF0YSA9IG1hdGNoWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV2ZW50LmRhdGEgPSAnJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1hdGNoID0gL14jRVhULVgtQ1VFLU9VVDo/KC4qKT8kLy5leGVjKGxpbmUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgIHRhZ1R5cGU6ICdjdWUtb3V0J1xuICAgICAgICB9O1xuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICBldmVudC5kYXRhID0gbWF0Y2hbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlbnQuZGF0YSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWF0Y2ggPSAvXiNFWFQtWC1DVUUtSU46PyguKik/JC8uZXhlYyhsaW5lKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICB0YWdUeXBlOiAnY3VlLWluJ1xuICAgICAgICB9O1xuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICBldmVudC5kYXRhID0gbWF0Y2hbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlbnQuZGF0YSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB1bmtub3duIHRhZyB0eXBlXG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB7XG4gICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICBkYXRhOiBsaW5lLnNsaWNlKDQpXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGFyc2VTdHJlYW07XG59KF9zdHJlYW0yWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBQYXJzZVN0cmVhbTtcbn0se1wiLi9zdHJlYW1cIjozN31dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9zdHJlYW0gPSByZXF1aXJlKCcuL3N0cmVhbScpO1xuXG52YXIgX3N0cmVhbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHJlYW0pO1xuXG52YXIgX2xpbmVTdHJlYW0gPSByZXF1aXJlKCcuL2xpbmUtc3RyZWFtJyk7XG5cbnZhciBfbGluZVN0cmVhbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saW5lU3RyZWFtKTtcblxudmFyIF9wYXJzZVN0cmVhbSA9IHJlcXVpcmUoJy4vcGFyc2Utc3RyZWFtJyk7XG5cbnZhciBfcGFyc2VTdHJlYW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyc2VTdHJlYW0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH0gLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZmlsZSBtM3U4L3BhcnNlci5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cblxuLyoqXG4gKiBBIHBhcnNlciBmb3IgTTNVOCBmaWxlcy4gVGhlIGN1cnJlbnQgaW50ZXJwcmV0YXRpb24gb2YgdGhlIGlucHV0IGlzXG4gKiBleHBvc2VkIGFzIGEgcHJvcGVydHkgYG1hbmlmZXN0YCBvbiBwYXJzZXIgb2JqZWN0cy4gSXQncyBqdXN0IHR3byBsaW5lcyB0b1xuICogY3JlYXRlIGFuZCBwYXJzZSBhIG1hbmlmZXN0IG9uY2UgeW91IGhhdmUgdGhlIGNvbnRlbnRzIGF2YWlsYWJsZSBhcyBhIHN0cmluZzpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHBhcnNlciA9IG5ldyBtM3U4LlBhcnNlcigpO1xuICogcGFyc2VyLnB1c2goeGhyLnJlc3BvbnNlVGV4dCk7XG4gKiBgYGBcbiAqXG4gKiBOZXcgaW5wdXQgY2FuIGxhdGVyIGJlIGFwcGxpZWQgdG8gdXBkYXRlIHRoZSBtYW5pZmVzdCBvYmplY3QgYnkgY2FsbGluZ1xuICogYHB1c2hgIGFnYWluLlxuICpcbiAqIFRoZSBwYXJzZXIgYXR0ZW1wdHMgdG8gY3JlYXRlIGEgdXNhYmxlIG1hbmlmZXN0IG9iamVjdCBldmVuIGlmIHRoZVxuICogdW5kZXJseWluZyBpbnB1dCBpcyBzb21ld2hhdCBub25zZW5zaWNhbC4gSXQgZW1pdHMgYGluZm9gIGFuZCBgd2FybmluZ2BcbiAqIGV2ZW50cyBkdXJpbmcgdGhlIHBhcnNlIGlmIGl0IGVuY291bnRlcnMgaW5wdXQgdGhhdCBzZWVtcyBpbnZhbGlkIG9yXG4gKiByZXF1aXJlcyBzb21lIHByb3BlcnR5IG9mIHRoZSBtYW5pZmVzdCBvYmplY3QgdG8gYmUgZGVmYXVsdGVkLlxuICpcbiAqIEBjbGFzcyBQYXJzZXJcbiAqIEBleHRlbmRzIFN0cmVhbVxuICovXG52YXIgUGFyc2VyID0gZnVuY3Rpb24gKF9TdHJlYW0pIHtcbiAgX2luaGVyaXRzKFBhcnNlciwgX1N0cmVhbSk7XG5cbiAgZnVuY3Rpb24gUGFyc2VyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXJzZXIpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFBhcnNlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBhcnNlcikpLmNhbGwodGhpcykpO1xuXG4gICAgX3RoaXMubGluZVN0cmVhbSA9IG5ldyBfbGluZVN0cmVhbTJbJ2RlZmF1bHQnXSgpO1xuICAgIF90aGlzLnBhcnNlU3RyZWFtID0gbmV3IF9wYXJzZVN0cmVhbTJbJ2RlZmF1bHQnXSgpO1xuICAgIF90aGlzLmxpbmVTdHJlYW0ucGlwZShfdGhpcy5wYXJzZVN0cmVhbSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC10aGlzICovXG4gICAgdmFyIHNlbGYgPSBfdGhpcztcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGNvbnNpc3RlbnQtdGhpcyAqL1xuICAgIHZhciB1cmlzID0gW107XG4gICAgdmFyIGN1cnJlbnRVcmkgPSB7fTtcbiAgICAvLyBpZiBzcGVjaWZpZWQsIHRoZSBhY3RpdmUgRVhULVgtTUFQIGRlZmluaXRpb25cbiAgICB2YXIgY3VycmVudE1hcCA9IHZvaWQgMDtcbiAgICAvLyBpZiBzcGVjaWZpZWQsIHRoZSBhY3RpdmUgZGVjcnlwdGlvbiBrZXlcbiAgICB2YXIgX2tleSA9IHZvaWQgMDtcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbiAgICB2YXIgZGVmYXVsdE1lZGlhR3JvdXBzID0ge1xuICAgICAgJ0FVRElPJzoge30sXG4gICAgICAnVklERU8nOiB7fSxcbiAgICAgICdDTE9TRUQtQ0FQVElPTlMnOiB7fSxcbiAgICAgICdTVUJUSVRMRVMnOiB7fVxuICAgIH07XG4gICAgLy8gZ3JvdXAgc2VnbWVudHMgaW50byBudW1iZXJlZCB0aW1lbGluZXMgZGVsaW5lYXRlZCBieSBkaXNjb250aW51aXRpZXNcbiAgICB2YXIgY3VycmVudFRpbWVsaW5lID0gMDtcblxuICAgIC8vIHRoZSBtYW5pZmVzdCBpcyBlbXB0eSB1bnRpbCB0aGUgcGFyc2Ugc3RyZWFtIGJlZ2lucyBkZWxpdmVyaW5nIGRhdGFcbiAgICBfdGhpcy5tYW5pZmVzdCA9IHtcbiAgICAgIGFsbG93Q2FjaGU6IHRydWUsXG4gICAgICBkaXNjb250aW51aXR5U3RhcnRzOiBbXSxcbiAgICAgIHNlZ21lbnRzOiBbXVxuICAgIH07XG5cbiAgICAvLyB1cGRhdGUgdGhlIG1hbmlmZXN0IHdpdGggdGhlIG0zdTggZW50cnkgZnJvbSB0aGUgcGFyc2Ugc3RyZWFtXG4gICAgX3RoaXMucGFyc2VTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIHZhciBtZWRpYUdyb3VwID0gdm9pZCAwO1xuICAgICAgdmFyIHJlbmRpdGlvbiA9IHZvaWQgMDtcblxuICAgICAgKHtcbiAgICAgICAgdGFnOiBmdW5jdGlvbiB0YWcoKSB7XG4gICAgICAgICAgLy8gc3dpdGNoIGJhc2VkIG9uIHRoZSB0YWcgdHlwZVxuICAgICAgICAgICgoe1xuICAgICAgICAgICAgJ2FsbG93LWNhY2hlJzogZnVuY3Rpb24gYWxsb3dDYWNoZSgpIHtcbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5hbGxvd0NhY2hlID0gZW50cnkuYWxsb3dlZDtcbiAgICAgICAgICAgICAgaWYgKCEoJ2FsbG93ZWQnIGluIGVudHJ5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignaW5mbycsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdkZWZhdWx0aW5nIGFsbG93Q2FjaGUgdG8gWUVTJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QuYWxsb3dDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBieXRlcmFuZ2U6IGZ1bmN0aW9uIGJ5dGVyYW5nZSgpIHtcbiAgICAgICAgICAgICAgdmFyIGJ5dGVyYW5nZSA9IHt9O1xuXG4gICAgICAgICAgICAgIGlmICgnbGVuZ3RoJyBpbiBlbnRyeSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRVcmkuYnl0ZXJhbmdlID0gYnl0ZXJhbmdlO1xuICAgICAgICAgICAgICAgIGJ5dGVyYW5nZS5sZW5ndGggPSBlbnRyeS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoISgnb2Zmc2V0JyBpbiBlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignaW5mbycsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2RlZmF1bHRpbmcgb2Zmc2V0IHRvIHplcm8nXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGVudHJ5Lm9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICgnb2Zmc2V0JyBpbiBlbnRyeSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRVcmkuYnl0ZXJhbmdlID0gYnl0ZXJhbmdlO1xuICAgICAgICAgICAgICAgIGJ5dGVyYW5nZS5vZmZzZXQgPSBlbnRyeS5vZmZzZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmRsaXN0OiBmdW5jdGlvbiBlbmRsaXN0KCkge1xuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LmVuZExpc3QgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluZjogZnVuY3Rpb24gaW5mKCkge1xuICAgICAgICAgICAgICBpZiAoISgnbWVkaWFTZXF1ZW5jZScgaW4gdGhpcy5tYW5pZmVzdCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0Lm1lZGlhU2VxdWVuY2UgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignaW5mbycsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdkZWZhdWx0aW5nIG1lZGlhIHNlcXVlbmNlIHRvIHplcm8nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCEoJ2Rpc2NvbnRpbnVpdHlTZXF1ZW5jZScgaW4gdGhpcy5tYW5pZmVzdCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LmRpc2NvbnRpbnVpdHlTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdpbmZvJywge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2RlZmF1bHRpbmcgZGlzY29udGludWl0eSBzZXF1ZW5jZSB0byB6ZXJvJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChlbnRyeS5kdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VXJpLmR1cmF0aW9uID0gZW50cnkuZHVyYXRpb247XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZW50cnkuZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VXJpLmR1cmF0aW9uID0gMC4wMTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2luZm8nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAndXBkYXRpbmcgemVybyBzZWdtZW50IGR1cmF0aW9uIHRvIGEgc21hbGwgdmFsdWUnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LnNlZ21lbnRzID0gdXJpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXk6IGZ1bmN0aW9uIGtleSgpIHtcbiAgICAgICAgICAgICAgaWYgKCFlbnRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd3YXJuJywge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2lnbm9yaW5nIGtleSBkZWNsYXJhdGlvbiB3aXRob3V0IGF0dHJpYnV0ZSBsaXN0J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBjbGVhciB0aGUgYWN0aXZlIGVuY3J5cHRpb24ga2V5XG4gICAgICAgICAgICAgIGlmIChlbnRyeS5hdHRyaWJ1dGVzLk1FVEhPRCA9PT0gJ05PTkUnKSB7XG4gICAgICAgICAgICAgICAgX2tleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZW50cnkuYXR0cmlidXRlcy5VUkkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3dhcm4nLCB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaWdub3Jpbmcga2V5IGRlY2xhcmF0aW9uIHdpdGhvdXQgVVJJJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWVudHJ5LmF0dHJpYnV0ZXMuTUVUSE9EKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd3YXJuJywge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2RlZmF1bHRpbmcga2V5IG1ldGhvZCB0byBBRVMtMTI4J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gc2V0dXAgYW4gZW5jcnlwdGlvbiBrZXkgZm9yIHVwY29taW5nIHNlZ21lbnRzXG4gICAgICAgICAgICAgIF9rZXkgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBlbnRyeS5hdHRyaWJ1dGVzLk1FVEhPRCB8fCAnQUVTLTEyOCcsXG4gICAgICAgICAgICAgICAgdXJpOiBlbnRyeS5hdHRyaWJ1dGVzLlVSSVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkuYXR0cmlidXRlcy5JViAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBfa2V5Lml2ID0gZW50cnkuYXR0cmlidXRlcy5JVjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtZWRpYS1zZXF1ZW5jZSc6IGZ1bmN0aW9uIG1lZGlhU2VxdWVuY2UoKSB7XG4gICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoZW50cnkubnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpZ25vcmluZyBpbnZhbGlkIG1lZGlhIHNlcXVlbmNlOiAnICsgZW50cnkubnVtYmVyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QubWVkaWFTZXF1ZW5jZSA9IGVudHJ5Lm51bWJlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGlzY29udGludWl0eS1zZXF1ZW5jZSc6IGZ1bmN0aW9uIGRpc2NvbnRpbnVpdHlTZXF1ZW5jZSgpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShlbnRyeS5udW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd3YXJuJywge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2lnbm9yaW5nIGludmFsaWQgZGlzY29udGludWl0eSBzZXF1ZW5jZTogJyArIGVudHJ5Lm51bWJlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LmRpc2NvbnRpbnVpdHlTZXF1ZW5jZSA9IGVudHJ5Lm51bWJlcjtcbiAgICAgICAgICAgICAgY3VycmVudFRpbWVsaW5lID0gZW50cnkubnVtYmVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdwbGF5bGlzdC10eXBlJzogZnVuY3Rpb24gcGxheWxpc3RUeXBlKCkge1xuICAgICAgICAgICAgICBpZiAoIS9WT0R8RVZFTlQvLnRlc3QoZW50cnkucGxheWxpc3RUeXBlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpZ25vcmluZyB1bmtub3duIHBsYXlsaXN0IHR5cGU6ICcgKyBlbnRyeS5wbGF5bGlzdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0LnBsYXlsaXN0VHlwZSA9IGVudHJ5LnBsYXlsaXN0VHlwZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXA6IGZ1bmN0aW9uIG1hcCgpIHtcbiAgICAgICAgICAgICAgY3VycmVudE1hcCA9IHt9O1xuICAgICAgICAgICAgICBpZiAoZW50cnkudXJpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hcC51cmkgPSBlbnRyeS51cmk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGVudHJ5LmJ5dGVyYW5nZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXAuYnl0ZXJhbmdlID0gZW50cnkuYnl0ZXJhbmdlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3N0cmVhbS1pbmYnOiBmdW5jdGlvbiBzdHJlYW1JbmYoKSB7XG4gICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QucGxheWxpc3RzID0gdXJpcztcbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5tZWRpYUdyb3VwcyA9IHRoaXMubWFuaWZlc3QubWVkaWFHcm91cHMgfHwgZGVmYXVsdE1lZGlhR3JvdXBzO1xuXG4gICAgICAgICAgICAgIGlmICghZW50cnkuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpZ25vcmluZyBlbXB0eSBzdHJlYW0taW5mIGF0dHJpYnV0ZXMnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFjdXJyZW50VXJpLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VXJpLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfZXh0ZW5kcyhjdXJyZW50VXJpLmF0dHJpYnV0ZXMsIGVudHJ5LmF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lZGlhOiBmdW5jdGlvbiBtZWRpYSgpIHtcbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5tZWRpYUdyb3VwcyA9IHRoaXMubWFuaWZlc3QubWVkaWFHcm91cHMgfHwgZGVmYXVsdE1lZGlhR3JvdXBzO1xuXG4gICAgICAgICAgICAgIGlmICghKGVudHJ5LmF0dHJpYnV0ZXMgJiYgZW50cnkuYXR0cmlidXRlcy5UWVBFICYmIGVudHJ5LmF0dHJpYnV0ZXNbJ0dST1VQLUlEJ10gJiYgZW50cnkuYXR0cmlidXRlcy5OQU1FKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpZ25vcmluZyBpbmNvbXBsZXRlIG9yIG1pc3NpbmcgbWVkaWEgZ3JvdXAnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gZmluZCB0aGUgbWVkaWEgZ3JvdXAsIGNyZWF0aW5nIGRlZmF1bHRzIGFzIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICB2YXIgbWVkaWFHcm91cFR5cGUgPSB0aGlzLm1hbmlmZXN0Lm1lZGlhR3JvdXBzW2VudHJ5LmF0dHJpYnV0ZXMuVFlQRV07XG5cbiAgICAgICAgICAgICAgbWVkaWFHcm91cFR5cGVbZW50cnkuYXR0cmlidXRlc1snR1JPVVAtSUQnXV0gPSBtZWRpYUdyb3VwVHlwZVtlbnRyeS5hdHRyaWJ1dGVzWydHUk9VUC1JRCddXSB8fCB7fTtcbiAgICAgICAgICAgICAgbWVkaWFHcm91cCA9IG1lZGlhR3JvdXBUeXBlW2VudHJ5LmF0dHJpYnV0ZXNbJ0dST1VQLUlEJ11dO1xuXG4gICAgICAgICAgICAgIC8vIGNvbGxlY3QgdGhlIHJlbmRpdGlvbiBtZXRhZGF0YVxuICAgICAgICAgICAgICByZW5kaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiAveWVzL2kudGVzdChlbnRyeS5hdHRyaWJ1dGVzLkRFRkFVTFQpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChyZW5kaXRpb25bJ2RlZmF1bHQnXSkge1xuICAgICAgICAgICAgICAgIHJlbmRpdGlvbi5hdXRvc2VsZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW5kaXRpb24uYXV0b3NlbGVjdCA9IC95ZXMvaS50ZXN0KGVudHJ5LmF0dHJpYnV0ZXMuQVVUT1NFTEVDVCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGVudHJ5LmF0dHJpYnV0ZXMuTEFOR1VBR0UpIHtcbiAgICAgICAgICAgICAgICByZW5kaXRpb24ubGFuZ3VhZ2UgPSBlbnRyeS5hdHRyaWJ1dGVzLkxBTkdVQUdFO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChlbnRyeS5hdHRyaWJ1dGVzLlVSSSkge1xuICAgICAgICAgICAgICAgIHJlbmRpdGlvbi51cmkgPSBlbnRyeS5hdHRyaWJ1dGVzLlVSSTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZW50cnkuYXR0cmlidXRlc1snSU5TVFJFQU0tSUQnXSkge1xuICAgICAgICAgICAgICAgIHJlbmRpdGlvbi5pbnN0cmVhbUlkID0gZW50cnkuYXR0cmlidXRlc1snSU5TVFJFQU0tSUQnXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZW50cnkuYXR0cmlidXRlcy5DSEFSQUNURVJJU1RJQ1MpIHtcbiAgICAgICAgICAgICAgICByZW5kaXRpb24uY2hhcmFjdGVyaXN0aWNzID0gZW50cnkuYXR0cmlidXRlcy5DSEFSQUNURVJJU1RJQ1M7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGVudHJ5LmF0dHJpYnV0ZXMuRk9SQ0VEKSB7XG4gICAgICAgICAgICAgICAgcmVuZGl0aW9uLmZvcmNlZCA9IC95ZXMvaS50ZXN0KGVudHJ5LmF0dHJpYnV0ZXMuRk9SQ0VEKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGluc2VydCB0aGUgbmV3IHJlbmRpdGlvblxuICAgICAgICAgICAgICBtZWRpYUdyb3VwW2VudHJ5LmF0dHJpYnV0ZXMuTkFNRV0gPSByZW5kaXRpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzY29udGludWl0eTogZnVuY3Rpb24gZGlzY29udGludWl0eSgpIHtcbiAgICAgICAgICAgICAgY3VycmVudFRpbWVsaW5lICs9IDE7XG4gICAgICAgICAgICAgIGN1cnJlbnRVcmkuZGlzY29udGludWl0eSA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QuZGlzY29udGludWl0eVN0YXJ0cy5wdXNoKHVyaXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncHJvZ3JhbS1kYXRlLXRpbWUnOiBmdW5jdGlvbiBwcm9ncmFtRGF0ZVRpbWUoKSB7XG4gICAgICAgICAgICAgIHRoaXMubWFuaWZlc3QuZGF0ZVRpbWVTdHJpbmcgPSBlbnRyeS5kYXRlVGltZVN0cmluZztcbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC5kYXRlVGltZU9iamVjdCA9IGVudHJ5LmRhdGVUaW1lT2JqZWN0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRhcmdldGR1cmF0aW9uOiBmdW5jdGlvbiB0YXJnZXRkdXJhdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShlbnRyeS5kdXJhdGlvbikgfHwgZW50cnkuZHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd3YXJuJywge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2lnbm9yaW5nIGludmFsaWQgdGFyZ2V0IGR1cmF0aW9uOiAnICsgZW50cnkuZHVyYXRpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC50YXJnZXREdXJhdGlvbiA9IGVudHJ5LmR1cmF0aW9uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvdGFsZHVyYXRpb246IGZ1bmN0aW9uIHRvdGFsZHVyYXRpb24oKSB7XG4gICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoZW50cnkuZHVyYXRpb24pIHx8IGVudHJ5LmR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpZ25vcmluZyBpbnZhbGlkIHRvdGFsIGR1cmF0aW9uOiAnICsgZW50cnkuZHVyYXRpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5tYW5pZmVzdC50b3RhbER1cmF0aW9uID0gZW50cnkuZHVyYXRpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2N1ZS1vdXQnOiBmdW5jdGlvbiBjdWVPdXQoKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRVcmkuY3VlT3V0ID0gZW50cnkuZGF0YTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnY3VlLW91dC1jb250JzogZnVuY3Rpb24gY3VlT3V0Q29udCgpIHtcbiAgICAgICAgICAgICAgY3VycmVudFVyaS5jdWVPdXRDb250ID0gZW50cnkuZGF0YTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnY3VlLWluJzogZnVuY3Rpb24gY3VlSW4oKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRVcmkuY3VlSW4gPSBlbnRyeS5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pW2VudHJ5LnRhZ1R5cGVdIHx8IG5vb3ApLmNhbGwoc2VsZik7XG4gICAgICAgIH0sXG4gICAgICAgIHVyaTogZnVuY3Rpb24gdXJpKCkge1xuICAgICAgICAgIGN1cnJlbnRVcmkudXJpID0gZW50cnkudXJpO1xuICAgICAgICAgIHVyaXMucHVzaChjdXJyZW50VXJpKTtcblxuICAgICAgICAgIC8vIGlmIG5vIGV4cGxpY2l0IGR1cmF0aW9uIHdhcyBkZWNsYXJlZCwgdXNlIHRoZSB0YXJnZXQgZHVyYXRpb25cbiAgICAgICAgICBpZiAodGhpcy5tYW5pZmVzdC50YXJnZXREdXJhdGlvbiAmJiAhKCdkdXJhdGlvbicgaW4gY3VycmVudFVyaSkpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybicsIHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ2RlZmF1bHRpbmcgc2VnbWVudCBkdXJhdGlvbiB0byB0aGUgdGFyZ2V0IGR1cmF0aW9uJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50VXJpLmR1cmF0aW9uID0gdGhpcy5tYW5pZmVzdC50YXJnZXREdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gYW5ub3RhdGUgd2l0aCBlbmNyeXB0aW9uIGluZm9ybWF0aW9uLCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICBpZiAoX2tleSkge1xuICAgICAgICAgICAgY3VycmVudFVyaS5rZXkgPSBfa2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50VXJpLnRpbWVsaW5lID0gY3VycmVudFRpbWVsaW5lO1xuICAgICAgICAgIC8vIGFubm90YXRlIHdpdGggaW5pdGlhbGl6YXRpb24gc2VnbWVudCBpbmZvcm1hdGlvbiwgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgaWYgKGN1cnJlbnRNYXApIHtcbiAgICAgICAgICAgIGN1cnJlbnRVcmkubWFwID0gY3VycmVudE1hcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBwcmVwYXJlIGZvciB0aGUgbmV4dCBVUklcbiAgICAgICAgICBjdXJyZW50VXJpID0ge307XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1lbnQ6IGZ1bmN0aW9uIGNvbW1lbnQoKSB7XG4gICAgICAgICAgLy8gY29tbWVudHMgYXJlIG5vdCBpbXBvcnRhbnQgZm9yIHBsYXliYWNrXG4gICAgICAgIH1cbiAgICAgIH0pW2VudHJ5LnR5cGVdLmNhbGwoc2VsZik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgdGhlIGlucHV0IHN0cmluZyBhbmQgdXBkYXRlIHRoZSBtYW5pZmVzdCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjaHVuayBhIHBvdGVudGlhbGx5IGluY29tcGxldGUgcG9ydGlvbiBvZiB0aGUgbWFuaWZlc3RcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoUGFyc2VyLCBbe1xuICAgIGtleTogJ3B1c2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKGNodW5rKSB7XG4gICAgICB0aGlzLmxpbmVTdHJlYW0ucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmx1c2ggYW55IHJlbWFpbmluZyBpbnB1dC4gVGhpcyBjYW4gYmUgaGFuZHkgaWYgdGhlIGxhc3QgbGluZSBvZiBhbiBNM1U4XG4gICAgICogbWFuaWZlc3QgZGlkIG5vdCBjb250YWluIGEgdHJhaWxpbmcgbmV3bGluZSBidXQgdGhlIGZpbGUgaGFzIGJlZW5cbiAgICAgKiBjb21wbGV0ZWx5IHJlY2VpdmVkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICAvLyBmbHVzaCBhbnkgYnVmZmVyZWQgaW5wdXRcbiAgICAgIHRoaXMubGluZVN0cmVhbS5wdXNoKCdcXG4nKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGFyc2VyO1xufShfc3RyZWFtMlsnZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUGFyc2VyO1xufSx7XCIuL2xpbmUtc3RyZWFtXCI6MzQsXCIuL3BhcnNlLXN0cmVhbVwiOjM1LFwiLi9zdHJlYW1cIjozN31dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBAZmlsZSBzdHJlYW0uanNcbiAqL1xuLyoqXG4gKiBBIGxpZ2h0d2VpZ2h0IHJlYWRhYmxlIHN0cmVhbSBpbXBsZW1lbnRpb24gdGhhdCBoYW5kbGVzIGV2ZW50IGRpc3BhdGNoaW5nLlxuICpcbiAqIEBjbGFzcyBTdHJlYW1cbiAqL1xudmFyIFN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RyZWFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJlYW0pO1xuXG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBzcGVjaWZpZWQgZXZlbnQgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIGV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgdGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBhbiBldmVudCBvZlxuICAgKiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFN0cmVhbSwgW3tcbiAgICBrZXk6ICdvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAoIXRoaXMubGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBsaXN0ZW5lciBmb3IgYSBzcGVjaWZpZWQgZXZlbnQgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgIGEgZnVuY3Rpb24gcHJldmlvdXNseSByZWdpc3RlcmVkIGZvciB0aGlzXG4gICAgICogdHlwZSBvZiBldmVudCB0aHJvdWdoIGBvbmBcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBpZiB3ZSBjb3VsZCB0dXJuIGl0IG9mZiBvciBub3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb2ZmJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAoIXRoaXMubGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5saXN0ZW5lcnNbdHlwZV0uaW5kZXhPZihsaXN0ZW5lcik7XG5cbiAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICByZXR1cm4gaW5kZXggPiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvbiB0aGlzIHN0cmVhbS4gQW55IGFkZGl0aW9uYWxcbiAgICAgKiBhcmd1bWVudHMgdG8gdGhpcyBmdW5jdGlvbiBhcmUgcGFzc2VkIGFzIHBhcmFtZXRlcnMgdG8gZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIGV2ZW50IG5hbWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndHJpZ2dlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyaWdnZXIodHlwZSkge1xuICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMubGlzdGVuZXJzW3R5cGVdO1xuICAgICAgdmFyIGkgPSB2b2lkIDA7XG4gICAgICB2YXIgbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgdmFyIGFyZ3MgPSB2b2lkIDA7XG5cbiAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFNsaWNpbmcgdGhlIGFyZ3VtZW50cyBvbiBldmVyeSBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kXG4gICAgICAvLyBjYW4gYWRkIGEgc2lnbmlmaWNhbnQgYW1vdW50IG9mIG92ZXJoZWFkLiBBdm9pZCB0aGVcbiAgICAgIC8vIGludGVybWVkaWF0ZSBvYmplY3QgY3JlYXRpb24gZm9yIHRoZSBjb21tb24gY2FzZSBvZiBhXG4gICAgICAvLyBzaW5nbGUgY2FsbGJhY2sgYXJndW1lbnRcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGxlbmd0aCA9IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBsZW5ndGggPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgc3RyZWFtIGFuZCBjbGVhbnMgdXAuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Rpc3Bvc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yd2FyZHMgYWxsIGBkYXRhYCBldmVudHMgb24gdGhpcyBzdHJlYW0gdG8gdGhlIGRlc3RpbmF0aW9uIHN0cmVhbS4gVGhlXG4gICAgICogZGVzdGluYXRpb24gc3RyZWFtIHNob3VsZCBwcm92aWRlIGEgbWV0aG9kIGBwdXNoYCB0byByZWNlaXZlIHRoZSBkYXRhXG4gICAgICogZXZlbnRzIGFzIHRoZXkgYXJyaXZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJlYW19IGRlc3RpbmF0aW9uIHRoZSBzdHJlYW0gdGhhdCB3aWxsIHJlY2VpdmUgYWxsIGBkYXRhYCBldmVudHNcbiAgICAgKiBAc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fcmVhZGFibGVfcGlwZV9kZXN0aW5hdGlvbl9vcHRpb25zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BpcGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaXBlKGRlc3RpbmF0aW9uKSB7XG4gICAgICB0aGlzLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgZGVzdGluYXRpb24ucHVzaChkYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdHJlYW07XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFN0cmVhbTtcbn0se31dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogbXV4LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IEJyaWdodGNvdmVcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogQSBzdHJlYW0tYmFzZWQgYWFjIHRvIG1wNCBjb252ZXJ0ZXIuIFRoaXMgdXRpbGl0eSBjYW4gYmUgdXNlZCB0b1xuICogZGVsaXZlciBtcDRzIHRvIGEgU291cmNlQnVmZmVyIG9uIHBsYXRmb3JtcyB0aGF0IHN1cHBvcnQgbmF0aXZlXG4gKiBNZWRpYSBTb3VyY2UgRXh0ZW5zaW9ucy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4uL3V0aWxzL3N0cmVhbS5qcycpO1xuXG4vLyBDb25zdGFudHNcbnZhciBBYWNTdHJlYW07XG5cbi8qKlxuICogU3BsaXRzIGFuIGluY29taW5nIHN0cmVhbSBvZiBiaW5hcnkgZGF0YSBpbnRvIEFEVFMgYW5kIElEMyBGcmFtZXMuXG4gKi9cblxuQWFjU3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gIHZhclxuICAgIGV2ZXJ5dGhpbmcgPSBuZXcgVWludDhBcnJheSgpLFxuICAgIHRpbWVTdGFtcCA9IDA7XG5cbiAgQWFjU3RyZWFtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy5zZXRUaW1lc3RhbXAgPSBmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgICB0aW1lU3RhbXAgPSB0aW1lc3RhbXA7XG4gIH07XG5cbiAgdGhpcy5wYXJzZUlkM1RhZ1NpemUgPSBmdW5jdGlvbihoZWFkZXIsIGJ5dGVJbmRleCkge1xuICAgIHZhclxuICAgICAgcmV0dXJuU2l6ZSA9IChoZWFkZXJbYnl0ZUluZGV4ICsgNl0gPDwgMjEpIHxcbiAgICAgICAgICAgICAgICAgICAoaGVhZGVyW2J5dGVJbmRleCArIDddIDw8IDE0KSB8XG4gICAgICAgICAgICAgICAgICAgKGhlYWRlcltieXRlSW5kZXggKyA4XSA8PCA3KSB8XG4gICAgICAgICAgICAgICAgICAgKGhlYWRlcltieXRlSW5kZXggKyA5XSksXG4gICAgICBmbGFncyA9IGhlYWRlcltieXRlSW5kZXggKyA1XSxcbiAgICAgIGZvb3RlclByZXNlbnQgPSAoZmxhZ3MgJiAxNikgPj4gNDtcblxuICAgIGlmIChmb290ZXJQcmVzZW50KSB7XG4gICAgICByZXR1cm4gcmV0dXJuU2l6ZSArIDIwO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuU2l6ZSArIDEwO1xuICB9O1xuXG4gIHRoaXMucGFyc2VBZHRzU2l6ZSA9IGZ1bmN0aW9uKGhlYWRlciwgYnl0ZUluZGV4KSB7XG4gICAgdmFyXG4gICAgICBsb3dUaHJlZSA9IChoZWFkZXJbYnl0ZUluZGV4ICsgNV0gJiAweEUwKSA+PiA1LFxuICAgICAgbWlkZGxlID0gaGVhZGVyW2J5dGVJbmRleCArIDRdIDw8IDMsXG4gICAgICBoaWdoVHdvID0gaGVhZGVyW2J5dGVJbmRleCArIDNdICYgMHgzIDw8IDExO1xuXG4gICAgcmV0dXJuIChoaWdoVHdvIHwgbWlkZGxlKSB8IGxvd1RocmVlO1xuICB9O1xuXG4gIHRoaXMucHVzaCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgdmFyXG4gICAgICBmcmFtZVNpemUgPSAwLFxuICAgICAgYnl0ZUluZGV4ID0gMCxcbiAgICAgIGJ5dGVzTGVmdCxcbiAgICAgIGNodW5rLFxuICAgICAgcGFja2V0LFxuICAgICAgdGVtcExlbmd0aDtcblxuICAgIC8vIElmIHRoZXJlIGFyZSBieXRlcyByZW1haW5pbmcgZnJvbSB0aGUgbGFzdCBzZWdtZW50LCBwcmVwZW5kIHRoZW0gdG8gdGhlXG4gICAgLy8gYnl0ZXMgdGhhdCB3ZXJlIHB1c2hlZCBpblxuICAgIGlmIChldmVyeXRoaW5nLmxlbmd0aCkge1xuICAgICAgdGVtcExlbmd0aCA9IGV2ZXJ5dGhpbmcubGVuZ3RoO1xuICAgICAgZXZlcnl0aGluZyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmJ5dGVMZW5ndGggKyB0ZW1wTGVuZ3RoKTtcbiAgICAgIGV2ZXJ5dGhpbmcuc2V0KGV2ZXJ5dGhpbmcuc3ViYXJyYXkoMCwgdGVtcExlbmd0aCkpO1xuICAgICAgZXZlcnl0aGluZy5zZXQoYnl0ZXMsIHRlbXBMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVyeXRoaW5nID0gYnl0ZXM7XG4gICAgfVxuXG4gICAgd2hpbGUgKGV2ZXJ5dGhpbmcubGVuZ3RoIC0gYnl0ZUluZGV4ID49IDMpIHtcbiAgICAgIGlmICgoZXZlcnl0aGluZ1tieXRlSW5kZXhdID09PSAnSScuY2hhckNvZGVBdCgwKSkgJiZcbiAgICAgICAgICAoZXZlcnl0aGluZ1tieXRlSW5kZXggKyAxXSA9PT0gJ0QnLmNoYXJDb2RlQXQoMCkpICYmXG4gICAgICAgICAgKGV2ZXJ5dGhpbmdbYnl0ZUluZGV4ICsgMl0gPT09ICczJy5jaGFyQ29kZUF0KDApKSkge1xuXG4gICAgICAgIC8vIEV4aXQgZWFybHkgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGVub3VnaCB0byBwYXJzZVxuICAgICAgICAvLyB0aGUgSUQzIHRhZyBoZWFkZXJcbiAgICAgICAgaWYgKGV2ZXJ5dGhpbmcubGVuZ3RoIC0gYnl0ZUluZGV4IDwgMTApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZyYW1lc2l6ZVxuICAgICAgICBmcmFtZVNpemUgPSB0aGlzLnBhcnNlSWQzVGFnU2l6ZShldmVyeXRoaW5nLCBieXRlSW5kZXgpO1xuXG4gICAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggaW4gdGhlIGJ1ZmZlclxuICAgICAgICAvLyB0byBlbWl0IGEgZnVsbCBwYWNrZXRcbiAgICAgICAgaWYgKGZyYW1lU2l6ZSA+IGV2ZXJ5dGhpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmsgPSB7XG4gICAgICAgICAgdHlwZTogJ3RpbWVkLW1ldGFkYXRhJyxcbiAgICAgICAgICBkYXRhOiBldmVyeXRoaW5nLnN1YmFycmF5KGJ5dGVJbmRleCwgYnl0ZUluZGV4ICsgZnJhbWVTaXplKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIGJ5dGVJbmRleCArPSBmcmFtZVNpemU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmICgoZXZlcnl0aGluZ1tieXRlSW5kZXhdICYgMHhmZiA9PT0gMHhmZikgJiZcbiAgICAgICAgICAgICAgICAgKChldmVyeXRoaW5nW2J5dGVJbmRleCArIDFdICYgMHhmMCkgPT09IDB4ZjApKSB7XG5cbiAgICAgICAgLy8gRXhpdCBlYXJseSBiZWNhdXNlIHdlIGRvbid0IGhhdmUgZW5vdWdoIHRvIHBhcnNlXG4gICAgICAgIC8vIHRoZSBBRFRTIGZyYW1lIGhlYWRlclxuICAgICAgICBpZiAoZXZlcnl0aGluZy5sZW5ndGggLSBieXRlSW5kZXggPCA3KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFtZVNpemUgPSB0aGlzLnBhcnNlQWR0c1NpemUoZXZlcnl0aGluZywgYnl0ZUluZGV4KTtcblxuICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGRvbid0IGhhdmUgZW5vdWdoIGluIHRoZSBidWZmZXJcbiAgICAgICAgLy8gdG8gZW1pdCBhIGZ1bGwgcGFja2V0XG4gICAgICAgIGlmIChmcmFtZVNpemUgPiBldmVyeXRoaW5nLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFja2V0ID0ge1xuICAgICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgICAgZGF0YTogZXZlcnl0aGluZy5zdWJhcnJheShieXRlSW5kZXgsIGJ5dGVJbmRleCArIGZyYW1lU2l6ZSksXG4gICAgICAgICAgcHRzOiB0aW1lU3RhbXAsXG4gICAgICAgICAgZHRzOiB0aW1lU3RhbXBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgcGFja2V0KTtcbiAgICAgICAgYnl0ZUluZGV4ICs9IGZyYW1lU2l6ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBieXRlSW5kZXgrKztcbiAgICB9XG4gICAgYnl0ZXNMZWZ0ID0gZXZlcnl0aGluZy5sZW5ndGggLSBieXRlSW5kZXg7XG5cbiAgICBpZiAoYnl0ZXNMZWZ0ID4gMCkge1xuICAgICAgZXZlcnl0aGluZyA9IGV2ZXJ5dGhpbmcuc3ViYXJyYXkoYnl0ZUluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlcnl0aGluZyA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgfVxuICB9O1xufTtcblxuQWFjU3RyZWFtLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBYWNTdHJlYW07XG5cbn0se1wiLi4vdXRpbHMvc3RyZWFtLmpzXCI6NjJ9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIG11eC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiBCcmlnaHRjb3ZlXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFV0aWxpdGllcyB0byBkZXRlY3QgYmFzaWMgcHJvcGVydGllcyBhbmQgbWV0YWRhdGEgYWJvdXQgQWFjIGRhdGEuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEFEVFNfU0FNUExJTkdfRlJFUVVFTkNJRVMgPSBbXG4gIDk2MDAwLFxuICA4ODIwMCxcbiAgNjQwMDAsXG4gIDQ4MDAwLFxuICA0NDEwMCxcbiAgMzIwMDAsXG4gIDI0MDAwLFxuICAyMjA1MCxcbiAgMTYwMDAsXG4gIDEyMDAwLFxuICAxMTAyNSxcbiAgODAwMCxcbiAgNzM1MFxuXTtcblxudmFyIHBhcnNlU3luY1NhZmVJbnRlZ2VyID0gZnVuY3Rpb24oZGF0YSkge1xuICByZXR1cm4gKGRhdGFbMF0gPDwgMjEpIHxcbiAgICAgICAgICAoZGF0YVsxXSA8PCAxNCkgfFxuICAgICAgICAgIChkYXRhWzJdIDw8IDcpIHxcbiAgICAgICAgICAoZGF0YVszXSk7XG59O1xuXG4vLyByZXR1cm4gYSBwZXJjZW50LWVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCBieXRlIHJhbmdlXG4vLyBAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGVyY2VudC1lbmNvZGluZ1xudmFyIHBlcmNlbnRFbmNvZGUgPSBmdW5jdGlvbihieXRlcywgc3RhcnQsIGVuZCkge1xuICB2YXIgaSwgcmVzdWx0ID0gJyc7XG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXN1bHQgKz0gJyUnICsgKCcwMCcgKyBieXRlc1tpXS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gcmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCBieXRlIHJhbmdlLFxuLy8gaW50ZXJwcmV0ZWQgYXMgSVNPLTg4NTktMS5cbnZhciBwYXJzZUlzbzg4NTkxID0gZnVuY3Rpb24oYnl0ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHVuZXNjYXBlKHBlcmNlbnRFbmNvZGUoYnl0ZXMsIHN0YXJ0LCBlbmQpKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG59O1xuXG52YXIgcGFyc2VJZDNUYWdTaXplID0gZnVuY3Rpb24oaGVhZGVyLCBieXRlSW5kZXgpIHtcbiAgdmFyXG4gICAgcmV0dXJuU2l6ZSA9IChoZWFkZXJbYnl0ZUluZGV4ICsgNl0gPDwgMjEpIHxcbiAgICAgICAgICAgICAgICAgKGhlYWRlcltieXRlSW5kZXggKyA3XSA8PCAxNCkgfFxuICAgICAgICAgICAgICAgICAoaGVhZGVyW2J5dGVJbmRleCArIDhdIDw8IDcpIHxcbiAgICAgICAgICAgICAgICAgKGhlYWRlcltieXRlSW5kZXggKyA5XSksXG4gICAgZmxhZ3MgPSBoZWFkZXJbYnl0ZUluZGV4ICsgNV0sXG4gICAgZm9vdGVyUHJlc2VudCA9IChmbGFncyAmIDE2KSA+PiA0O1xuXG4gIGlmIChmb290ZXJQcmVzZW50KSB7XG4gICAgcmV0dXJuIHJldHVyblNpemUgKyAyMDtcbiAgfVxuICByZXR1cm4gcmV0dXJuU2l6ZSArIDEwO1xufTtcblxudmFyIHBhcnNlQWR0c1NpemUgPSBmdW5jdGlvbihoZWFkZXIsIGJ5dGVJbmRleCkge1xuICB2YXJcbiAgICBsb3dUaHJlZSA9IChoZWFkZXJbYnl0ZUluZGV4ICsgNV0gJiAweEUwKSA+PiA1LFxuICAgIG1pZGRsZSA9IGhlYWRlcltieXRlSW5kZXggKyA0XSA8PCAzLFxuICAgIGhpZ2hUd28gPSBoZWFkZXJbYnl0ZUluZGV4ICsgM10gJiAweDMgPDwgMTE7XG5cbiAgcmV0dXJuIChoaWdoVHdvIHwgbWlkZGxlKSB8IGxvd1RocmVlO1xufTtcblxudmFyIHBhcnNlVHlwZSA9IGZ1bmN0aW9uKGhlYWRlciwgYnl0ZUluZGV4KSB7XG4gIGlmICgoaGVhZGVyW2J5dGVJbmRleF0gPT09ICdJJy5jaGFyQ29kZUF0KDApKSAmJlxuICAgICAgKGhlYWRlcltieXRlSW5kZXggKyAxXSA9PT0gJ0QnLmNoYXJDb2RlQXQoMCkpICYmXG4gICAgICAoaGVhZGVyW2J5dGVJbmRleCArIDJdID09PSAnMycuY2hhckNvZGVBdCgwKSkpIHtcbiAgICByZXR1cm4gJ3RpbWVkLW1ldGFkYXRhJztcbiAgfSBlbHNlIGlmICgoaGVhZGVyW2J5dGVJbmRleF0gJiAweGZmID09PSAweGZmKSAmJlxuICAgICAgICAgICAgICgoaGVhZGVyW2J5dGVJbmRleCArIDFdICYgMHhmMCkgPT09IDB4ZjApKSB7XG4gICAgcmV0dXJuICdhdWRpbyc7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgcGFyc2VTYW1wbGVSYXRlID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSArIDUgPCBwYWNrZXQubGVuZ3RoKSB7XG4gICAgaWYgKHBhY2tldFtpXSAhPT0gMHhGRiB8fCAocGFja2V0W2kgKyAxXSAmIDB4RjYpICE9PSAweEYwKSB7XG4gICAgICAvLyBJZiBhIHZhbGlkIGhlYWRlciB3YXMgbm90IGZvdW5kLCAganVtcCBvbmUgZm9yd2FyZCBhbmQgYXR0ZW1wdCB0b1xuICAgICAgLy8gZmluZCBhIHZhbGlkIEFEVFMgaGVhZGVyIHN0YXJ0aW5nIGF0IHRoZSBuZXh0IGJ5dGVcbiAgICAgIGkrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4gQURUU19TQU1QTElOR19GUkVRVUVOQ0lFU1socGFja2V0W2kgKyAyXSAmIDB4M2MpID4+PiAyXTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIHBhcnNlQWFjVGltZXN0YW1wID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBmcmFtZVN0YXJ0LCBmcmFtZVNpemUsIGZyYW1lLCBmcmFtZUhlYWRlcjtcblxuICAvLyBmaW5kIHRoZSBzdGFydCBvZiB0aGUgZmlyc3QgZnJhbWUgYW5kIHRoZSBlbmQgb2YgdGhlIHRhZ1xuICBmcmFtZVN0YXJ0ID0gMTA7XG4gIGlmIChwYWNrZXRbNV0gJiAweDQwKSB7XG4gICAgLy8gYWR2YW5jZSB0aGUgZnJhbWUgc3RhcnQgcGFzdCB0aGUgZXh0ZW5kZWQgaGVhZGVyXG4gICAgZnJhbWVTdGFydCArPSA0OyAvLyBoZWFkZXIgc2l6ZSBmaWVsZFxuICAgIGZyYW1lU3RhcnQgKz0gcGFyc2VTeW5jU2FmZUludGVnZXIocGFja2V0LnN1YmFycmF5KDEwLCAxNCkpO1xuICB9XG5cbiAgLy8gcGFyc2Ugb25lIG9yIG1vcmUgSUQzIGZyYW1lc1xuICAvLyBodHRwOi8vaWQzLm9yZy9pZDN2Mi4zLjAjSUQzdjJfZnJhbWVfb3ZlcnZpZXdcbiAgZG8ge1xuICAgIC8vIGRldGVybWluZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoaXMgZnJhbWVcbiAgICBmcmFtZVNpemUgPSBwYXJzZVN5bmNTYWZlSW50ZWdlcihwYWNrZXQuc3ViYXJyYXkoZnJhbWVTdGFydCArIDQsIGZyYW1lU3RhcnQgKyA4KSk7XG4gICAgaWYgKGZyYW1lU2l6ZSA8IDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmcmFtZUhlYWRlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFja2V0W2ZyYW1lU3RhcnRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRbZnJhbWVTdGFydCArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRbZnJhbWVTdGFydCArIDJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXRbZnJhbWVTdGFydCArIDNdKTtcblxuICAgIGlmIChmcmFtZUhlYWRlciA9PT0gJ1BSSVYnKSB7XG4gICAgICBmcmFtZSA9IHBhY2tldC5zdWJhcnJheShmcmFtZVN0YXJ0ICsgMTAsIGZyYW1lU3RhcnQgKyBmcmFtZVNpemUgKyAxMCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWUuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmcmFtZVtpXSA9PT0gMCkge1xuICAgICAgICAgIHZhciBvd25lciA9IHBhcnNlSXNvODg1OTEoZnJhbWUsIDAsIGkpO1xuICAgICAgICAgIGlmIChvd25lciA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJykge1xuICAgICAgICAgICAgdmFyIGQgPSBmcmFtZS5zdWJhcnJheShpICsgMSk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9ICgoZFszXSAmIDB4MDEpICA8PCAzMCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAoZFs0XSAgPDwgMjIpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgKGRbNV0gPDwgMTQpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgKGRbNl0gPDwgNikgfFxuICAgICAgICAgICAgICAgICAgICAgICAoZFs3XSA+Pj4gMik7XG4gICAgICAgICAgICBzaXplICo9IDQ7XG4gICAgICAgICAgICBzaXplICs9IGRbN10gJiAweDAzO1xuXG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmcmFtZVN0YXJ0ICs9IDEwOyAvLyBhZHZhbmNlIHBhc3QgdGhlIGZyYW1lIGhlYWRlclxuICAgIGZyYW1lU3RhcnQgKz0gZnJhbWVTaXplOyAvLyBhZHZhbmNlIHBhc3QgdGhlIGZyYW1lIGJvZHlcbiAgfSB3aGlsZSAoZnJhbWVTdGFydCA8IHBhY2tldC5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2VJZDNUYWdTaXplOiBwYXJzZUlkM1RhZ1NpemUsXG4gIHBhcnNlQWR0c1NpemU6IHBhcnNlQWR0c1NpemUsXG4gIHBhcnNlVHlwZTogcGFyc2VUeXBlLFxuICBwYXJzZVNhbXBsZVJhdGU6IHBhcnNlU2FtcGxlUmF0ZSxcbiAgcGFyc2VBYWNUaW1lc3RhbXA6IHBhcnNlQWFjVGltZXN0YW1wXG59O1xuXG59LHt9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuLi91dGlscy9zdHJlYW0uanMnKTtcblxudmFyIEFkdHNTdHJlYW07XG5cbnZhclxuICBBRFRTX1NBTVBMSU5HX0ZSRVFVRU5DSUVTID0gW1xuICAgIDk2MDAwLFxuICAgIDg4MjAwLFxuICAgIDY0MDAwLFxuICAgIDQ4MDAwLFxuICAgIDQ0MTAwLFxuICAgIDMyMDAwLFxuICAgIDI0MDAwLFxuICAgIDIyMDUwLFxuICAgIDE2MDAwLFxuICAgIDEyMDAwLFxuICAgIDExMDI1LFxuICAgIDgwMDAsXG4gICAgNzM1MFxuICBdO1xuXG4vKlxuICogQWNjZXB0cyBhIEVsZW1lbnRhcnlTdHJlYW0gYW5kIGVtaXRzIGRhdGEgZXZlbnRzIHdpdGggcGFyc2VkXG4gKiBBQUMgQXVkaW8gRnJhbWVzIG9mIHRoZSBpbmRpdmlkdWFsIHBhY2tldHMuIElucHV0IGF1ZGlvIGluIEFEVFNcbiAqIGZvcm1hdCBpcyB1bnBhY2tlZCBhbmQgcmUtZW1pdHRlZCBhcyBBQUMgZnJhbWVzLlxuICpcbiAqIEBzZWUgaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICogQHNlZSBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4Lz90aXRsZT1VbmRlcnN0YW5kaW5nX0FBQ1xuICovXG5BZHRzU3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidWZmZXI7XG5cbiAgQWR0c1N0cmVhbS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMucHVzaCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICAgIHZhclxuICAgICAgaSA9IDAsXG4gICAgICBmcmFtZU51bSA9IDAsXG4gICAgICBmcmFtZUxlbmd0aCxcbiAgICAgIHByb3RlY3Rpb25Ta2lwQnl0ZXMsXG4gICAgICBmcmFtZUVuZCxcbiAgICAgIG9sZEJ1ZmZlcixcbiAgICAgIHNhbXBsZUNvdW50LFxuICAgICAgYWR0c0ZyYW1lRHVyYXRpb247XG5cbiAgICBpZiAocGFja2V0LnR5cGUgIT09ICdhdWRpbycpIHtcbiAgICAgIC8vIGlnbm9yZSBub24tYXVkaW8gZGF0YVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByZXBlbmQgYW55IGRhdGEgaW4gdGhlIGJ1ZmZlciB0byB0aGUgaW5wdXQgZGF0YSBzbyB0aGF0IHdlIGNhbiBwYXJzZVxuICAgIC8vIGFhYyBmcmFtZXMgdGhlIGNyb3NzIGEgUEVTIHBhY2tldCBib3VuZGFyeVxuICAgIGlmIChidWZmZXIpIHtcbiAgICAgIG9sZEJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KG9sZEJ1ZmZlci5ieXRlTGVuZ3RoICsgcGFja2V0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICBidWZmZXIuc2V0KG9sZEJ1ZmZlcik7XG4gICAgICBidWZmZXIuc2V0KHBhY2tldC5kYXRhLCBvbGRCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlciA9IHBhY2tldC5kYXRhO1xuICAgIH1cblxuICAgIC8vIHVucGFjayBhbnkgQURUUyBmcmFtZXMgd2hpY2ggaGF2ZSBiZWVuIGZ1bGx5IHJlY2VpdmVkXG4gICAgLy8gZm9yIGRldGFpbHMgb24gdGhlIEFEVFMgaGVhZGVyLCBzZWUgaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICAgIHdoaWxlIChpICsgNSA8IGJ1ZmZlci5sZW5ndGgpIHtcblxuICAgICAgLy8gTG9vb2sgZm9yIHRoZSBzdGFydCBvZiBhbiBBRFRTIGhlYWRlci4uXG4gICAgICBpZiAoYnVmZmVyW2ldICE9PSAweEZGIHx8IChidWZmZXJbaSArIDFdICYgMHhGNikgIT09IDB4RjApIHtcbiAgICAgICAgLy8gSWYgYSB2YWxpZCBoZWFkZXIgd2FzIG5vdCBmb3VuZCwgIGp1bXAgb25lIGZvcndhcmQgYW5kIGF0dGVtcHQgdG9cbiAgICAgICAgLy8gZmluZCBhIHZhbGlkIEFEVFMgaGVhZGVyIHN0YXJ0aW5nIGF0IHRoZSBuZXh0IGJ5dGVcbiAgICAgICAgaSsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHByb3RlY3Rpb24gc2tpcCBiaXQgdGVsbHMgdXMgaWYgd2UgaGF2ZSAyIGJ5dGVzIG9mIENSQyBkYXRhIGF0IHRoZVxuICAgICAgLy8gZW5kIG9mIHRoZSBBRFRTIGhlYWRlclxuICAgICAgcHJvdGVjdGlvblNraXBCeXRlcyA9ICh+YnVmZmVyW2kgKyAxXSAmIDB4MDEpICogMjtcblxuICAgICAgLy8gRnJhbWUgbGVuZ3RoIGlzIGEgMTMgYml0IGludGVnZXIgc3RhcnRpbmcgMTYgYml0cyBmcm9tIHRoZVxuICAgICAgLy8gZW5kIG9mIHRoZSBzeW5jIHNlcXVlbmNlXG4gICAgICBmcmFtZUxlbmd0aCA9ICgoYnVmZmVyW2kgKyAzXSAmIDB4MDMpIDw8IDExKSB8XG4gICAgICAgIChidWZmZXJbaSArIDRdIDw8IDMpIHxcbiAgICAgICAgKChidWZmZXJbaSArIDVdICYgMHhlMCkgPj4gNSk7XG5cbiAgICAgIHNhbXBsZUNvdW50ID0gKChidWZmZXJbaSArIDZdICYgMHgwMykgKyAxKSAqIDEwMjQ7XG4gICAgICBhZHRzRnJhbWVEdXJhdGlvbiA9IChzYW1wbGVDb3VudCAqIDkwMDAwKSAvXG4gICAgICAgIEFEVFNfU0FNUExJTkdfRlJFUVVFTkNJRVNbKGJ1ZmZlcltpICsgMl0gJiAweDNjKSA+Pj4gMl07XG5cbiAgICAgIGZyYW1lRW5kID0gaSArIGZyYW1lTGVuZ3RoO1xuXG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBkYXRhIHRvIGFjdHVhbGx5IGZpbmlzaCB0aGlzIEFEVFMgZnJhbWUsIHJldHVyblxuICAgICAgLy8gYW5kIHdhaXQgZm9yIG1vcmUgZGF0YVxuICAgICAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoIDwgZnJhbWVFbmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIGRlbGl2ZXIgdGhlIGNvbXBsZXRlIEFBQyBmcmFtZVxuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywge1xuICAgICAgICBwdHM6IHBhY2tldC5wdHMgKyAoZnJhbWVOdW0gKiBhZHRzRnJhbWVEdXJhdGlvbiksXG4gICAgICAgIGR0czogcGFja2V0LmR0cyArIChmcmFtZU51bSAqIGFkdHNGcmFtZUR1cmF0aW9uKSxcbiAgICAgICAgc2FtcGxlQ291bnQ6IHNhbXBsZUNvdW50LFxuICAgICAgICBhdWRpb29iamVjdHR5cGU6ICgoYnVmZmVyW2kgKyAyXSA+Pj4gNikgJiAweDAzKSArIDEsXG4gICAgICAgIGNoYW5uZWxjb3VudDogKChidWZmZXJbaSArIDJdICYgMSkgPDwgMikgfFxuICAgICAgICAgICgoYnVmZmVyW2kgKyAzXSAmIDB4YzApID4+PiA2KSxcbiAgICAgICAgc2FtcGxlcmF0ZTogQURUU19TQU1QTElOR19GUkVRVUVOQ0lFU1soYnVmZmVyW2kgKyAyXSAmIDB4M2MpID4+PiAyXSxcbiAgICAgICAgc2FtcGxpbmdmcmVxdWVuY3lpbmRleDogKGJ1ZmZlcltpICsgMl0gJiAweDNjKSA+Pj4gMixcbiAgICAgICAgLy8gYXNzdW1lIElTTy9JRUMgMTQ0OTYtMTIgQXVkaW9TYW1wbGVFbnRyeSBkZWZhdWx0IG9mIDE2XG4gICAgICAgIHNhbXBsZXNpemU6IDE2LFxuICAgICAgICBkYXRhOiBidWZmZXIuc3ViYXJyYXkoaSArIDcgKyBwcm90ZWN0aW9uU2tpcEJ5dGVzLCBmcmFtZUVuZClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJZiB0aGUgYnVmZmVyIGlzIGVtcHR5LCBjbGVhciBpdCBhbmQgcmV0dXJuXG4gICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPT09IGZyYW1lRW5kKSB7XG4gICAgICAgIGJ1ZmZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmcmFtZU51bSsrO1xuXG4gICAgICAvLyBSZW1vdmUgdGhlIGZpbmlzaGVkIGZyYW1lIGZyb20gdGhlIGJ1ZmZlciBhbmQgc3RhcnQgdGhlIHByb2Nlc3MgYWdhaW5cbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheShmcmFtZUVuZCk7XG4gICAgfVxuICB9O1xuICB0aGlzLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdkb25lJyk7XG4gIH07XG59O1xuXG5BZHRzU3RyZWFtLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZHRzU3RyZWFtO1xuXG59LHtcIi4uL3V0aWxzL3N0cmVhbS5qc1wiOjYyfV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi4vdXRpbHMvc3RyZWFtLmpzJyk7XG52YXIgRXhwR29sb21iID0gcmVxdWlyZSgnLi4vdXRpbHMvZXhwLWdvbG9tYi5qcycpO1xuXG52YXIgSDI2NFN0cmVhbSwgTmFsQnl0ZVN0cmVhbTtcbnZhciBQUk9GSUxFU19XSVRIX09QVElPTkFMX1NQU19EQVRBO1xuXG4vKipcbiAqIEFjY2VwdHMgYSBOQUwgdW5pdCBieXRlIHN0cmVhbSBhbmQgdW5wYWNrcyB0aGUgZW1iZWRkZWQgTkFMIHVuaXRzLlxuICovXG5OYWxCeXRlU3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gIHZhclxuICAgIHN5bmNQb2ludCA9IDAsXG4gICAgaSxcbiAgICBidWZmZXI7XG4gIE5hbEJ5dGVTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnB1c2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHN3YXBCdWZmZXI7XG5cbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgYnVmZmVyID0gZGF0YS5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2FwQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ5dGVMZW5ndGggKyBkYXRhLmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICBzd2FwQnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgc3dhcEJ1ZmZlci5zZXQoZGF0YS5kYXRhLCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICBidWZmZXIgPSBzd2FwQnVmZmVyO1xuICAgIH1cblxuICAgIC8vIFJlYy4gSVRVLVQgSC4yNjQsIEFubmV4IEJcbiAgICAvLyBzY2FuIGZvciBOQUwgdW5pdCBib3VuZGFyaWVzXG5cbiAgICAvLyBhIG1hdGNoIGxvb2tzIGxpa2UgdGhpczpcbiAgICAvLyAwIDAgMSAuLiBOQUwgLi4gMCAwIDFcbiAgICAvLyBeIHN5bmMgcG9pbnQgICAgICAgIF4gaVxuICAgIC8vIG9yIHRoaXM6XG4gICAgLy8gMCAwIDEgLi4gTkFMIC4uIDAgMCAwXG4gICAgLy8gXiBzeW5jIHBvaW50ICAgICAgICBeIGlcblxuICAgIC8vIGFkdmFuY2UgdGhlIHN5bmMgcG9pbnQgdG8gYSBOQUwgc3RhcnQsIGlmIG5lY2Vzc2FyeVxuICAgIGZvciAoOyBzeW5jUG9pbnQgPCBidWZmZXIuYnl0ZUxlbmd0aCAtIDM7IHN5bmNQb2ludCsrKSB7XG4gICAgICBpZiAoYnVmZmVyW3N5bmNQb2ludCArIDJdID09PSAxKSB7XG4gICAgICAgIC8vIHRoZSBzeW5jIHBvaW50IGlzIHByb3Blcmx5IGFsaWduZWRcbiAgICAgICAgaSA9IHN5bmNQb2ludCArIDU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChpIDwgYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIC8vIGxvb2sgYXQgdGhlIGN1cnJlbnQgYnl0ZSB0byBkZXRlcm1pbmUgaWYgd2UndmUgaGl0IHRoZSBlbmQgb2ZcbiAgICAgIC8vIGEgTkFMIHVuaXQgYm91bmRhcnlcbiAgICAgIHN3aXRjaCAoYnVmZmVyW2ldKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIC8vIHNraXAgcGFzdCBub24tc3luYyBzZXF1ZW5jZXNcbiAgICAgICAgaWYgKGJ1ZmZlcltpIC0gMV0gIT09IDApIHtcbiAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyW2kgLSAyXSAhPT0gMCkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlbGl2ZXIgdGhlIE5BTCB1bml0IGlmIGl0IGlzbid0IGVtcHR5XG4gICAgICAgIGlmIChzeW5jUG9pbnQgKyAzICE9PSBpIC0gMikge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGJ1ZmZlci5zdWJhcnJheShzeW5jUG9pbnQgKyAzLCBpIC0gMikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZHJvcCB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfSB3aGlsZSAoYnVmZmVyW2ldICE9PSAxICYmIGkgPCBidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgc3luY1BvaW50ID0gaSAtIDI7XG4gICAgICAgIGkgKz0gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIC8vIHNraXAgcGFzdCBub24tc3luYyBzZXF1ZW5jZXNcbiAgICAgICAgaWYgKGJ1ZmZlcltpIC0gMV0gIT09IDAgfHxcbiAgICAgICAgICAgIGJ1ZmZlcltpIC0gMl0gIT09IDApIHtcbiAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZWxpdmVyIHRoZSBOQUwgdW5pdFxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBidWZmZXIuc3ViYXJyYXkoc3luY1BvaW50ICsgMywgaSAtIDIpKTtcbiAgICAgICAgc3luY1BvaW50ID0gaSAtIDI7XG4gICAgICAgIGkgKz0gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyB0aGUgY3VycmVudCBieXRlIGlzbid0IGEgb25lIG9yIHplcm8sIHNvIGl0IGNhbm5vdCBiZSBwYXJ0XG4gICAgICAgIC8vIG9mIGEgc3luYyBzZXF1ZW5jZVxuICAgICAgICBpICs9IDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBmaWx0ZXIgb3V0IHRoZSBOQUwgdW5pdHMgdGhhdCB3ZXJlIGRlbGl2ZXJlZFxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheShzeW5jUG9pbnQpO1xuICAgIGkgLT0gc3luY1BvaW50O1xuICAgIHN5bmNQb2ludCA9IDA7XG4gIH07XG5cbiAgdGhpcy5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGRlbGl2ZXIgdGhlIGxhc3QgYnVmZmVyZWQgTkFMIHVuaXRcbiAgICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5ieXRlTGVuZ3RoID4gMykge1xuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgYnVmZmVyLnN1YmFycmF5KHN5bmNQb2ludCArIDMpKTtcbiAgICB9XG4gICAgLy8gcmVzZXQgdGhlIHN0cmVhbSBzdGF0ZVxuICAgIGJ1ZmZlciA9IG51bGw7XG4gICAgc3luY1BvaW50ID0gMDtcbiAgICB0aGlzLnRyaWdnZXIoJ2RvbmUnKTtcbiAgfTtcbn07XG5OYWxCeXRlU3RyZWFtLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcblxuLy8gdmFsdWVzIG9mIHByb2ZpbGVfaWRjIHRoYXQgaW5kaWNhdGUgYWRkaXRpb25hbCBmaWVsZHMgYXJlIGluY2x1ZGVkIGluIHRoZSBTUFNcbi8vIHNlZSBSZWNvbW1lbmRhdGlvbiBJVFUtVCBILjI2NCAoNC8yMDEzKSxcbi8vIDcuMy4yLjEuMSBTZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGRhdGEgc3ludGF4XG5QUk9GSUxFU19XSVRIX09QVElPTkFMX1NQU19EQVRBID0ge1xuICAxMDA6IHRydWUsXG4gIDExMDogdHJ1ZSxcbiAgMTIyOiB0cnVlLFxuICAyNDQ6IHRydWUsXG4gIDQ0OiB0cnVlLFxuICA4MzogdHJ1ZSxcbiAgODY6IHRydWUsXG4gIDExODogdHJ1ZSxcbiAgMTI4OiB0cnVlLFxuICAxMzg6IHRydWUsXG4gIDEzOTogdHJ1ZSxcbiAgMTM0OiB0cnVlXG59O1xuXG4vKipcbiAqIEFjY2VwdHMgaW5wdXQgZnJvbSBhIEVsZW1lbnRhcnlTdHJlYW0gYW5kIHByb2R1Y2VzIEguMjY0IE5BTCB1bml0IGRhdGFcbiAqIGV2ZW50cy5cbiAqL1xuSDI2NFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICB2YXJcbiAgICBuYWxCeXRlU3RyZWFtID0gbmV3IE5hbEJ5dGVTdHJlYW0oKSxcbiAgICBzZWxmLFxuICAgIHRyYWNrSWQsXG4gICAgY3VycmVudFB0cyxcbiAgICBjdXJyZW50RHRzLFxuXG4gICAgZGlzY2FyZEVtdWxhdGlvblByZXZlbnRpb25CeXRlcyxcbiAgICByZWFkU2VxdWVuY2VQYXJhbWV0ZXJTZXQsXG4gICAgc2tpcFNjYWxpbmdMaXN0O1xuXG4gIEgyNjRTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcbiAgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gICAgaWYgKHBhY2tldC50eXBlICE9PSAndmlkZW8nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyYWNrSWQgPSBwYWNrZXQudHJhY2tJZDtcbiAgICBjdXJyZW50UHRzID0gcGFja2V0LnB0cztcbiAgICBjdXJyZW50RHRzID0gcGFja2V0LmR0cztcblxuICAgIG5hbEJ5dGVTdHJlYW0ucHVzaChwYWNrZXQpO1xuICB9O1xuXG4gIG5hbEJ5dGVTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyXG4gICAgICBldmVudCA9IHtcbiAgICAgICAgdHJhY2tJZDogdHJhY2tJZCxcbiAgICAgICAgcHRzOiBjdXJyZW50UHRzLFxuICAgICAgICBkdHM6IGN1cnJlbnREdHMsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH07XG5cbiAgICBzd2l0Y2ggKGRhdGFbMF0gJiAweDFmKSB7XG4gICAgY2FzZSAweDA1OlxuICAgICAgZXZlbnQubmFsVW5pdFR5cGUgPSAnc2xpY2VfbGF5ZXJfd2l0aG91dF9wYXJ0aXRpb25pbmdfcmJzcF9pZHInO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDA2OlxuICAgICAgZXZlbnQubmFsVW5pdFR5cGUgPSAnc2VpX3Jic3AnO1xuICAgICAgZXZlbnQuZXNjYXBlZFJCU1AgPSBkaXNjYXJkRW11bGF0aW9uUHJldmVudGlvbkJ5dGVzKGRhdGEuc3ViYXJyYXkoMSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDA3OlxuICAgICAgZXZlbnQubmFsVW5pdFR5cGUgPSAnc2VxX3BhcmFtZXRlcl9zZXRfcmJzcCc7XG4gICAgICBldmVudC5lc2NhcGVkUkJTUCA9IGRpc2NhcmRFbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXMoZGF0YS5zdWJhcnJheSgxKSk7XG4gICAgICBldmVudC5jb25maWcgPSByZWFkU2VxdWVuY2VQYXJhbWV0ZXJTZXQoZXZlbnQuZXNjYXBlZFJCU1ApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAweDA4OlxuICAgICAgZXZlbnQubmFsVW5pdFR5cGUgPSAncGljX3BhcmFtZXRlcl9zZXRfcmJzcCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDB4MDk6XG4gICAgICBldmVudC5uYWxVbml0VHlwZSA9ICdhY2Nlc3NfdW5pdF9kZWxpbWl0ZXJfcmJzcCc7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2VsZi50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICB9KTtcbiAgbmFsQnl0ZVN0cmVhbS5vbignZG9uZScsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYudHJpZ2dlcignZG9uZScpO1xuICB9KTtcblxuICB0aGlzLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgbmFsQnl0ZVN0cmVhbS5mbHVzaCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZHZhbmNlIHRoZSBFeHBHb2xvbWIgZGVjb2RlciBwYXN0IGEgc2NhbGluZyBsaXN0LiBUaGUgc2NhbGluZ1xuICAgKiBsaXN0IGlzIG9wdGlvbmFsbHkgdHJhbnNtaXR0ZWQgYXMgcGFydCBvZiBhIHNlcXVlbmNlIHBhcmFtZXRlclxuICAgKiBzZXQgYW5kIGlzIG5vdCByZWxldmFudCB0byB0cmFuc211eGluZy5cbiAgICogQHBhcmFtIGNvdW50IHtudW1iZXJ9IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHNjYWxpbmcgbGlzdFxuICAgKiBAcGFyYW0gZXhwR29sb21iRGVjb2RlciB7b2JqZWN0fSBhbiBFeHBHb2xvbWIgcG9pbnRlZCB0byB0aGVcbiAgICogc3RhcnQgb2YgYSBzY2FsaW5nIGxpc3RcbiAgICogQHNlZSBSZWNvbW1lbmRhdGlvbiBJVFUtVCBILjI2NCwgU2VjdGlvbiA3LjMuMi4xLjEuMVxuICAgKi9cbiAgc2tpcFNjYWxpbmdMaXN0ID0gZnVuY3Rpb24oY291bnQsIGV4cEdvbG9tYkRlY29kZXIpIHtcbiAgICB2YXJcbiAgICAgIGxhc3RTY2FsZSA9IDgsXG4gICAgICBuZXh0U2NhbGUgPSA4LFxuICAgICAgaixcbiAgICAgIGRlbHRhU2NhbGU7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgaWYgKG5leHRTY2FsZSAhPT0gMCkge1xuICAgICAgICBkZWx0YVNjYWxlID0gZXhwR29sb21iRGVjb2Rlci5yZWFkRXhwR29sb21iKCk7XG4gICAgICAgIG5leHRTY2FsZSA9IChsYXN0U2NhbGUgKyBkZWx0YVNjYWxlICsgMjU2KSAlIDI1NjtcbiAgICAgIH1cblxuICAgICAgbGFzdFNjYWxlID0gKG5leHRTY2FsZSA9PT0gMCkgPyBsYXN0U2NhbGUgOiBuZXh0U2NhbGU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFeHB1bmdlIGFueSBcIkVtdWxhdGlvbiBQcmV2ZW50aW9uXCIgYnl0ZXMgZnJvbSBhIFwiUmF3IEJ5dGVcbiAgICogU2VxdWVuY2UgUGF5bG9hZFwiXG4gICAqIEBwYXJhbSBkYXRhIHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgYSBSQlNQIGZyb20gYSBOQUxcbiAgICogdW5pdFxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSB0aGUgUkJTUCB3aXRob3V0IGFueSBFbXVsYXRpb25cbiAgICogUHJldmVudGlvbiBCeXRlc1xuICAgKi9cbiAgZGlzY2FyZEVtdWxhdGlvblByZXZlbnRpb25CeXRlcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXJcbiAgICAgIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCxcbiAgICAgIGVtdWxhdGlvblByZXZlbnRpb25CeXRlc1Bvc2l0aW9ucyA9IFtdLFxuICAgICAgaSA9IDEsXG4gICAgICBuZXdMZW5ndGgsIG5ld0RhdGE7XG5cbiAgICAvLyBGaW5kIGFsbCBgRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXNgXG4gICAgd2hpbGUgKGkgPCBsZW5ndGggLSAyKSB7XG4gICAgICBpZiAoZGF0YVtpXSA9PT0gMCAmJiBkYXRhW2kgKyAxXSA9PT0gMCAmJiBkYXRhW2kgKyAyXSA9PT0gMHgwMykge1xuICAgICAgICBlbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXNQb3NpdGlvbnMucHVzaChpICsgMik7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlcyB3ZXJlIGZvdW5kIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICAgIC8vIGFycmF5XG4gICAgaWYgKGVtdWxhdGlvblByZXZlbnRpb25CeXRlc1Bvc2l0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIG5ldyBhcnJheSB0byBob2xkIHRoZSBOQUwgdW5pdCBkYXRhXG4gICAgbmV3TGVuZ3RoID0gbGVuZ3RoIC0gZW11bGF0aW9uUHJldmVudGlvbkJ5dGVzUG9zaXRpb25zLmxlbmd0aDtcbiAgICBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcbiAgICB2YXIgc291cmNlSW5kZXggPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5ld0xlbmd0aDsgc291cmNlSW5kZXgrKywgaSsrKSB7XG4gICAgICBpZiAoc291cmNlSW5kZXggPT09IGVtdWxhdGlvblByZXZlbnRpb25CeXRlc1Bvc2l0aW9uc1swXSkge1xuICAgICAgICAvLyBTa2lwIHRoaXMgYnl0ZVxuICAgICAgICBzb3VyY2VJbmRleCsrO1xuICAgICAgICAvLyBSZW1vdmUgdGhpcyBwb3NpdGlvbiBpbmRleFxuICAgICAgICBlbXVsYXRpb25QcmV2ZW50aW9uQnl0ZXNQb3NpdGlvbnMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIG5ld0RhdGFbaV0gPSBkYXRhW3NvdXJjZUluZGV4XTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfTtcblxuICAvKipcbiAgICogUmVhZCBhIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgYW5kIHJldHVybiBzb21lIGludGVyZXN0aW5nIHZpZGVvXG4gICAqIHByb3BlcnRpZXMuIEEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBpcyB0aGUgSDI2NCBtZXRhZGF0YSB0aGF0XG4gICAqIGRlc2NyaWJlcyB0aGUgcHJvcGVydGllcyBvZiB1cGNvbWluZyB2aWRlbyBmcmFtZXMuXG4gICAqIEBwYXJhbSBkYXRhIHtVaW50OEFycmF5fSB0aGUgYnl0ZXMgb2YgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0XG4gICAqIEByZXR1cm4ge29iamVjdH0gYW4gb2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBwYXJzZWQgZnJvbSB0aGVcbiAgICogc2VxdWVuY2UgcGFyYW1ldGVyIHNldCwgaW5jbHVkaW5nIHRoZSBkaW1lbnNpb25zIG9mIHRoZVxuICAgKiBhc3NvY2lhdGVkIHZpZGVvIGZyYW1lcy5cbiAgICovXG4gIHJlYWRTZXF1ZW5jZVBhcmFtZXRlclNldCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXJcbiAgICAgIGZyYW1lQ3JvcExlZnRPZmZzZXQgPSAwLFxuICAgICAgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSAwLFxuICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gMCxcbiAgICAgIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IDAsXG4gICAgICBzYXJTY2FsZSA9IDEsXG4gICAgICBleHBHb2xvbWJEZWNvZGVyLCBwcm9maWxlSWRjLCBsZXZlbElkYywgcHJvZmlsZUNvbXBhdGliaWxpdHksXG4gICAgICBjaHJvbWFGb3JtYXRJZGMsIHBpY09yZGVyQ250VHlwZSxcbiAgICAgIG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZSwgcGljV2lkdGhJbk1ic01pbnVzMSxcbiAgICAgIHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEsXG4gICAgICBmcmFtZU1ic09ubHlGbGFnLFxuICAgICAgc2NhbGluZ0xpc3RDb3VudCxcbiAgICAgIHNhclJhdGlvLFxuICAgICAgYXNwZWN0UmF0aW9JZGMsXG4gICAgICBpO1xuXG4gICAgZXhwR29sb21iRGVjb2RlciA9IG5ldyBFeHBHb2xvbWIoZGF0YSk7XG4gICAgcHJvZmlsZUlkYyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkQnl0ZSgpOyAvLyBwcm9maWxlX2lkY1xuICAgIHByb2ZpbGVDb21wYXRpYmlsaXR5ID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRCeXRlKCk7IC8vIGNvbnN0cmFpbnRfc2V0WzAtNV1fZmxhZ1xuICAgIGxldmVsSWRjID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRCeXRlKCk7IC8vIGxldmVsX2lkYyB1KDgpXG4gICAgZXhwR29sb21iRGVjb2Rlci5za2lwVW5zaWduZWRFeHBHb2xvbWIoKTsgLy8gc2VxX3BhcmFtZXRlcl9zZXRfaWRcblxuICAgIC8vIHNvbWUgcHJvZmlsZXMgaGF2ZSBtb3JlIG9wdGlvbmFsIGRhdGEgd2UgZG9uJ3QgbmVlZFxuICAgIGlmIChQUk9GSUxFU19XSVRIX09QVElPTkFMX1NQU19EQVRBW3Byb2ZpbGVJZGNdKSB7XG4gICAgICBjaHJvbWFGb3JtYXRJZGMgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEV4cEdvbG9tYigpO1xuICAgICAgaWYgKGNocm9tYUZvcm1hdElkYyA9PT0gMykge1xuICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnNraXBCaXRzKDEpOyAvLyBzZXBhcmF0ZV9jb2xvdXJfcGxhbmVfZmxhZ1xuICAgICAgfVxuICAgICAgZXhwR29sb21iRGVjb2Rlci5za2lwVW5zaWduZWRFeHBHb2xvbWIoKTsgLy8gYml0X2RlcHRoX2x1bWFfbWludXM4XG4gICAgICBleHBHb2xvbWJEZWNvZGVyLnNraXBVbnNpZ25lZEV4cEdvbG9tYigpOyAvLyBiaXRfZGVwdGhfY2hyb21hX21pbnVzOFxuICAgICAgZXhwR29sb21iRGVjb2Rlci5za2lwQml0cygxKTsgLy8gcXBwcmltZV95X3plcm9fdHJhbnNmb3JtX2J5cGFzc19mbGFnXG4gICAgICBpZiAoZXhwR29sb21iRGVjb2Rlci5yZWFkQm9vbGVhbigpKSB7IC8vIHNlcV9zY2FsaW5nX21hdHJpeF9wcmVzZW50X2ZsYWdcbiAgICAgICAgc2NhbGluZ0xpc3RDb3VudCA9IChjaHJvbWFGb3JtYXRJZGMgIT09IDMpID8gOCA6IDEyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2NhbGluZ0xpc3RDb3VudDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGV4cEdvbG9tYkRlY29kZXIucmVhZEJvb2xlYW4oKSkgeyAvLyBzZXFfc2NhbGluZ19saXN0X3ByZXNlbnRfZmxhZ1sgaSBdXG4gICAgICAgICAgICBpZiAoaSA8IDYpIHtcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDE2LCBleHBHb2xvbWJEZWNvZGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCg2NCwgZXhwR29sb21iRGVjb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwR29sb21iRGVjb2Rlci5za2lwVW5zaWduZWRFeHBHb2xvbWIoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuICAgIHBpY09yZGVyQ250VHlwZSA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkRXhwR29sb21iKCk7XG5cbiAgICBpZiAocGljT3JkZXJDbnRUeXBlID09PSAwKSB7XG4gICAgICBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEV4cEdvbG9tYigpOyAvLyBsb2cyX21heF9waWNfb3JkZXJfY250X2xzYl9taW51czRcbiAgICB9IGVsc2UgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMSkge1xuICAgICAgZXhwR29sb21iRGVjb2Rlci5za2lwQml0cygxKTsgLy8gZGVsdGFfcGljX29yZGVyX2Fsd2F5c196ZXJvX2ZsYWdcbiAgICAgIGV4cEdvbG9tYkRlY29kZXIuc2tpcEV4cEdvbG9tYigpOyAvLyBvZmZzZXRfZm9yX25vbl9yZWZfcGljXG4gICAgICBleHBHb2xvbWJEZWNvZGVyLnNraXBFeHBHb2xvbWIoKTsgLy8gb2Zmc2V0X2Zvcl90b3BfdG9fYm90dG9tX2ZpZWxkXG4gICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEV4cEdvbG9tYigpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTsgaSsrKSB7XG4gICAgICAgIGV4cEdvbG9tYkRlY29kZXIuc2tpcEV4cEdvbG9tYigpOyAvLyBvZmZzZXRfZm9yX3JlZl9mcmFtZVsgaSBdXG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwR29sb21iRGVjb2Rlci5za2lwVW5zaWduZWRFeHBHb2xvbWIoKTsgLy8gbWF4X251bV9yZWZfZnJhbWVzXG4gICAgZXhwR29sb21iRGVjb2Rlci5za2lwQml0cygxKTsgLy8gZ2Fwc19pbl9mcmFtZV9udW1fdmFsdWVfYWxsb3dlZF9mbGFnXG5cbiAgICBwaWNXaWR0aEluTWJzTWludXMxID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRFeHBHb2xvbWIoKTtcbiAgICBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRFeHBHb2xvbWIoKTtcblxuICAgIGZyYW1lTWJzT25seUZsYWcgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRCaXRzKDEpO1xuICAgIGlmIChmcmFtZU1ic09ubHlGbGFnID09PSAwKSB7XG4gICAgICBleHBHb2xvbWJEZWNvZGVyLnNraXBCaXRzKDEpOyAvLyBtYl9hZGFwdGl2ZV9mcmFtZV9maWVsZF9mbGFnXG4gICAgfVxuXG4gICAgZXhwR29sb21iRGVjb2Rlci5za2lwQml0cygxKTsgLy8gZGlyZWN0Xzh4OF9pbmZlcmVuY2VfZmxhZ1xuICAgIGlmIChleHBHb2xvbWJEZWNvZGVyLnJlYWRCb29sZWFuKCkpIHsgLy8gZnJhbWVfY3JvcHBpbmdfZmxhZ1xuICAgICAgZnJhbWVDcm9wTGVmdE9mZnNldCA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkRXhwR29sb21iKCk7XG4gICAgICBmcmFtZUNyb3BSaWdodE9mZnNldCA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkRXhwR29sb21iKCk7XG4gICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEV4cEdvbG9tYigpO1xuICAgICAgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRFeHBHb2xvbWIoKTtcbiAgICB9XG4gICAgaWYgKGV4cEdvbG9tYkRlY29kZXIucmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICBpZiAoZXhwR29sb21iRGVjb2Rlci5yZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICBhc3BlY3RSYXRpb0lkYyA9IGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkQnl0ZSgpO1xuICAgICAgICBzd2l0Y2ggKGFzcGVjdFJhdGlvSWRjKSB7XG4gICAgICAgICAgY2FzZSAxOiBzYXJSYXRpbyA9IFsxLCAxXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiBzYXJSYXRpbyA9IFsxMiwgMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDM6IHNhclJhdGlvID0gWzEwLCAxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDogc2FyUmF0aW8gPSBbMTYsIDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OiBzYXJSYXRpbyA9IFs0MCwgMzNdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDY6IHNhclJhdGlvID0gWzI0LCAxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzogc2FyUmF0aW8gPSBbMjAsIDExXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSA4OiBzYXJSYXRpbyA9IFszMiwgMTFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDk6IHNhclJhdGlvID0gWzgwLCAzM107IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTA6IHNhclJhdGlvID0gWzE4LCAxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTE6IHNhclJhdGlvID0gWzE1LCAxMV07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTI6IHNhclJhdGlvID0gWzY0LCAzM107IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM6IHNhclJhdGlvID0gWzE2MCwgOTldOyBicmVhaztcbiAgICAgICAgICBjYXNlIDE0OiBzYXJSYXRpbyA9IFs0LCAzXTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNTogc2FyUmF0aW8gPSBbMywgMl07IGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTY6IHNhclJhdGlvID0gWzIsIDFdOyBicmVhaztcbiAgICAgICAgICBjYXNlIDI1NToge1xuICAgICAgICAgICAgc2FyUmF0aW8gPSBbZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRCeXRlKCkgPDwgOCB8XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBHb2xvbWJEZWNvZGVyLnJlYWRVbnNpZ25lZEJ5dGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cEdvbG9tYkRlY29kZXIucmVhZFVuc2lnbmVkQnl0ZSgpIDw8IDggfFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwR29sb21iRGVjb2Rlci5yZWFkVW5zaWduZWRCeXRlKCkgXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2FyUmF0aW8pIHtcbiAgICAgICAgICBzYXJTY2FsZSA9IHNhclJhdGlvWzBdIC8gc2FyUmF0aW9bMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2ZpbGVJZGM6IHByb2ZpbGVJZGMsXG4gICAgICBsZXZlbElkYzogbGV2ZWxJZGMsXG4gICAgICBwcm9maWxlQ29tcGF0aWJpbGl0eTogcHJvZmlsZUNvbXBhdGliaWxpdHksXG4gICAgICB3aWR0aDogTWF0aC5jZWlsKCgoKHBpY1dpZHRoSW5NYnNNaW51czEgKyAxKSAqIDE2KSAtIGZyYW1lQ3JvcExlZnRPZmZzZXQgKiAyIC0gZnJhbWVDcm9wUmlnaHRPZmZzZXQgKiAyKSAqIHNhclNjYWxlKSxcbiAgICAgIGhlaWdodDogKCgyIC0gZnJhbWVNYnNPbmx5RmxhZykgKiAocGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSArIDEpICogMTYpIC0gKGZyYW1lQ3JvcFRvcE9mZnNldCAqIDIpIC0gKGZyYW1lQ3JvcEJvdHRvbU9mZnNldCAqIDIpXG4gICAgfTtcbiAgfTtcblxufTtcbkgyNjRTdHJlYW0ucHJvdG90eXBlID0gbmV3IFN0cmVhbSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSDI2NFN0cmVhbTogSDI2NFN0cmVhbSxcbiAgTmFsQnl0ZVN0cmVhbTogTmFsQnl0ZVN0cmVhbVxufTtcblxufSx7XCIuLi91dGlscy9leHAtZ29sb21iLmpzXCI6NjEsXCIuLi91dGlscy9zdHJlYW0uanNcIjo2Mn1dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBoaWdoUHJlZml4ID0gWzMzLCAxNiwgNSwgMzIsIDE2NCwgMjddO1xudmFyIGxvd1ByZWZpeCA9IFszMywgNjUsIDEwOCwgODQsIDEsIDIsIDQsIDgsIDE2OCwgMiwgNCwgOCwgMTcsIDE5MSwgMjUyXTtcbnZhciB6ZXJvRmlsbCA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBhID0gW107XG4gIHdoaWxlIChjb3VudC0tKSB7XG4gICAgYS5wdXNoKDApO1xuICB9XG4gIHJldHVybiBhO1xufTtcblxudmFyIG1ha2VUYWJsZSA9IGZ1bmN0aW9uKG1ldGFUYWJsZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMobWV0YVRhYmxlKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICBvYmpba2V5XSA9IG5ldyBVaW50OEFycmF5KG1ldGFUYWJsZVtrZXldLnJlZHVjZShmdW5jdGlvbihhcnIsIHBhcnQpIHtcbiAgICAgIHJldHVybiBhcnIuY29uY2F0KHBhcnQpO1xuICAgIH0sIFtdKSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLy8gRnJhbWVzLW9mLXNpbGVuY2UgdG8gdXNlIGZvciBmaWxsaW5nIGluIG1pc3NpbmcgQUFDIGZyYW1lc1xudmFyIGNvbmVPZlNpbGVuY2UgPSB7XG4gIDk2MDAwOiBbaGlnaFByZWZpeCwgWzIyNywgNjRdLCB6ZXJvRmlsbCgxNTQpLCBbNTZdXSxcbiAgODgyMDA6IFtoaWdoUHJlZml4LCBbMjMxXSwgemVyb0ZpbGwoMTcwKSwgWzU2XV0sXG4gIDY0MDAwOiBbaGlnaFByZWZpeCwgWzI0OCwgMTkyXSwgemVyb0ZpbGwoMjQwKSwgWzU2XV0sXG4gIDQ4MDAwOiBbaGlnaFByZWZpeCwgWzI1NSwgMTkyXSwgemVyb0ZpbGwoMjY4KSwgWzU1LCAxNDgsIDEyOF0sIHplcm9GaWxsKDU0KSwgWzExMl1dLFxuICA0NDEwMDogW2hpZ2hQcmVmaXgsIFsyNTUsIDE5Ml0sIHplcm9GaWxsKDI2OCksIFs1NSwgMTYzLCAxMjhdLCB6ZXJvRmlsbCg4NCksIFsxMTJdXSxcbiAgMzIwMDA6IFtoaWdoUHJlZml4LCBbMjU1LCAxOTJdLCB6ZXJvRmlsbCgyNjgpLCBbNTUsIDIzNF0sIHplcm9GaWxsKDIyNiksIFsxMTJdXSxcbiAgMjQwMDA6IFtoaWdoUHJlZml4LCBbMjU1LCAxOTJdLCB6ZXJvRmlsbCgyNjgpLCBbNTUsIDI1NSwgMTI4XSwgemVyb0ZpbGwoMjY4KSwgWzExMSwgMTEyXSwgemVyb0ZpbGwoMTI2KSwgWzIyNF1dLFxuICAxNjAwMDogW2hpZ2hQcmVmaXgsIFsyNTUsIDE5Ml0sIHplcm9GaWxsKDI2OCksIFs1NSwgMjU1LCAxMjhdLCB6ZXJvRmlsbCgyNjgpLCBbMTExLCAyNTVdLCB6ZXJvRmlsbCgyNjkpLCBbMjIzLCAxMDhdLCB6ZXJvRmlsbCgxOTUpLCBbMSwgMTkyXV0sXG4gIDEyMDAwOiBbbG93UHJlZml4LCB6ZXJvRmlsbCgyNjgpLCBbMywgMTI3LCAyNDhdLCB6ZXJvRmlsbCgyNjgpLCBbNiwgMjU1LCAyNDBdLCB6ZXJvRmlsbCgyNjgpLCBbMTMsIDI1NSwgMjI0XSwgemVyb0ZpbGwoMjY4KSwgWzI3LCAyNTMsIDEyOF0sIHplcm9GaWxsKDI1OSksIFs1Nl1dLFxuICAxMTAyNTogW2xvd1ByZWZpeCwgemVyb0ZpbGwoMjY4KSwgWzMsIDEyNywgMjQ4XSwgemVyb0ZpbGwoMjY4KSwgWzYsIDI1NSwgMjQwXSwgemVyb0ZpbGwoMjY4KSwgWzEzLCAyNTUsIDIyNF0sIHplcm9GaWxsKDI2OCksIFsyNywgMjU1LCAxOTJdLCB6ZXJvRmlsbCgyNjgpLCBbNTUsIDE3NSwgMTI4XSwgemVyb0ZpbGwoMTA4KSwgWzExMl1dLFxuICA4MDAwOiBbbG93UHJlZml4LCB6ZXJvRmlsbCgyNjgpLCBbMywgMTIxLCAxNl0sIHplcm9GaWxsKDQ3KSwgWzddXVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtYWtlVGFibGUoY29uZU9mU2lsZW5jZSk7XG5cbn0se31dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4uL3V0aWxzL3N0cmVhbS5qcycpO1xuXG4vKipcbiAqIFRoZSBmaW5hbCBzdGFnZSBvZiB0aGUgdHJhbnNtdXhlciB0aGF0IGVtaXRzIHRoZSBmbHYgdGFnc1xuICogZm9yIGF1ZGlvLCB2aWRlbywgYW5kIG1ldGFkYXRhLiBBbHNvIHRyYW5sYXRlcyBpbiB0aW1lIGFuZFxuICogb3V0cHV0cyBjYXB0aW9uIGRhdGEgYW5kIGlkMyBjdWVzLlxuICovXG52YXIgQ29hbGVzY2VTdHJlYW0gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8vIE51bWJlciBvZiBUcmFja3MgcGVyIG91dHB1dCBzZWdtZW50XG4gIC8vIElmIGdyZWF0ZXIgdGhhbiAxLCB3ZSBjb21iaW5lIG11bHRpcGxlXG4gIC8vIHRyYWNrcyBpbnRvIGEgc2luZ2xlIHNlZ21lbnRcbiAgdGhpcy5udW1iZXJPZlRyYWNrcyA9IDA7XG4gIHRoaXMubWV0YWRhdGFTdHJlYW0gPSBvcHRpb25zLm1ldGFkYXRhU3RyZWFtO1xuXG4gIHRoaXMudmlkZW9UYWdzID0gW107XG4gIHRoaXMuYXVkaW9UYWdzID0gW107XG4gIHRoaXMudmlkZW9UcmFjayA9IG51bGw7XG4gIHRoaXMuYXVkaW9UcmFjayA9IG51bGw7XG4gIHRoaXMucGVuZGluZ0NhcHRpb25zID0gW107XG4gIHRoaXMucGVuZGluZ01ldGFkYXRhID0gW107XG4gIHRoaXMucGVuZGluZ1RyYWNrcyA9IDA7XG4gIHRoaXMucHJvY2Vzc2VkVHJhY2tzID0gMDtcblxuICBDb2FsZXNjZVN0cmVhbS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuXG4gIC8vIFRha2Ugb3V0cHV0IGZyb20gbXVsdGlwbGVcbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgLy8gYnVmZmVyIGluY29taW5nIGNhcHRpb25zIHVudGlsIHRoZSBhc3NvY2lhdGVkIHZpZGVvIHNlZ21lbnRcbiAgICAvLyBmaW5pc2hlc1xuICAgIGlmIChvdXRwdXQudGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ0NhcHRpb25zLnB1c2gob3V0cHV0KTtcbiAgICB9XG4gICAgLy8gYnVmZmVyIGluY29taW5nIGlkMyB0YWdzIHVudGlsIHRoZSBmaW5hbCBmbHVzaFxuICAgIGlmIChvdXRwdXQuZnJhbWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5wZW5kaW5nTWV0YWRhdGEucHVzaChvdXRwdXQpO1xuICAgIH1cblxuICAgIGlmIChvdXRwdXQudHJhY2sudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgdGhpcy52aWRlb1RyYWNrID0gb3V0cHV0LnRyYWNrO1xuICAgICAgdGhpcy52aWRlb1RhZ3MgPSBvdXRwdXQudGFncztcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcysrO1xuICAgIH1cbiAgICBpZiAob3V0cHV0LnRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIHRoaXMuYXVkaW9UcmFjayA9IG91dHB1dC50cmFjaztcbiAgICAgIHRoaXMuYXVkaW9UYWdzID0gb3V0cHV0LnRhZ3M7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja3MrKztcbiAgICB9XG4gIH07XG59O1xuXG5Db2FsZXNjZVN0cmVhbS5wcm90b3R5cGUgPSBuZXcgU3RyZWFtKCk7XG5Db2FsZXNjZVN0cmVhbS5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbihmbHVzaFNvdXJjZSkge1xuICB2YXJcbiAgICBpZDMsXG4gICAgY2FwdGlvbixcbiAgICBpLFxuICAgIHRpbWVsaW5lU3RhcnRQdHMsXG4gICAgZXZlbnQgPSB7XG4gICAgICB0YWdzOiB7fSxcbiAgICAgIGNhcHRpb25zOiBbXSxcbiAgICAgIGNhcHRpb25TdHJlYW1zOiB7fSxcbiAgICAgIG1ldGFkYXRhOiBbXVxuICAgIH07XG5cbiAgaWYgKHRoaXMucGVuZGluZ1RyYWNrcyA8IHRoaXMubnVtYmVyT2ZUcmFja3MpIHtcbiAgICBpZiAoZmx1c2hTb3VyY2UgIT09ICdWaWRlb1NlZ21lbnRTdHJlYW0nICYmXG4gICAgICAgIGZsdXNoU291cmNlICE9PSAnQXVkaW9TZWdtZW50U3RyZWFtJykge1xuICAgICAgLy8gUmV0dXJuIGJlY2F1c2Ugd2UgaGF2ZW4ndCByZWNlaXZlZCBhIGZsdXNoIGZyb20gYSBkYXRhLWdlbmVyYXRpbmdcbiAgICAgIC8vIHBvcnRpb24gb2YgdGhlIHNlZ21lbnQgKG1lYW5pbmcgdGhhdCB3ZSBoYXZlIG9ubHkgcmVjaWV2ZWQgbWV0YS1kYXRhXG4gICAgICAvLyBvciBjYXB0aW9ucy4pXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0aGlzLnBlbmRpbmdUcmFja3MgPT09IDApIHtcbiAgICAgIC8vIEluIHRoZSBjYXNlIHdoZXJlIHdlIHJlY2VpdmUgYSBmbHVzaCB3aXRob3V0IGFueSBkYXRhIGhhdmluZyBiZWVuXG4gICAgICAvLyByZWNlaXZlZCB3ZSBjb25zaWRlciBpdCBhbiBlbWl0dGVkIHRyYWNrIGZvciB0aGUgcHVycG9zZXMgb2YgY29hbGVzY2luZ1xuICAgICAgLy8gYGRvbmVgIGV2ZW50cy5cbiAgICAgIC8vIFdlIGRvIHRoaXMgZm9yIHRoZSBjYXNlIHdoZXJlIHRoZXJlIGlzIGFuIGF1ZGlvIGFuZCB2aWRlbyB0cmFjayBpbiB0aGVcbiAgICAgIC8vIHNlZ21lbnQgYnV0IG5vIGF1ZGlvIGRhdGEuIChzZWVuIGluIHNldmVyYWwgcGxheWxpc3RzIHdpdGggYWx0ZXJuYXRlXG4gICAgICAvLyBhdWRpbyB0cmFja3MgYW5kIG5vIGF1ZGlvIHByZXNlbnQgaW4gdGhlIG1haW4gVFMgc2VnbWVudHMuKVxuICAgICAgdGhpcy5wcm9jZXNzZWRUcmFja3MrKztcblxuICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkVHJhY2tzIDwgdGhpcy5udW1iZXJPZlRyYWNrcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5wcm9jZXNzZWRUcmFja3MgKz0gdGhpcy5wZW5kaW5nVHJhY2tzO1xuICB0aGlzLnBlbmRpbmdUcmFja3MgPSAwO1xuXG4gIGlmICh0aGlzLnByb2Nlc3NlZFRyYWNrcyA8IHRoaXMubnVtYmVyT2ZUcmFja3MpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy52aWRlb1RyYWNrKSB7XG4gICAgdGltZWxpbmVTdGFydFB0cyA9IHRoaXMudmlkZW9UcmFjay50aW1lbGluZVN0YXJ0SW5mby5wdHM7XG4gIH0gZWxzZSBpZiAodGhpcy5hdWRpb1RyYWNrKSB7XG4gICAgdGltZWxpbmVTdGFydFB0cyA9IHRoaXMuYXVkaW9UcmFjay50aW1lbGluZVN0YXJ0SW5mby5wdHM7XG4gIH1cblxuICBldmVudC50YWdzLnZpZGVvVGFncyA9IHRoaXMudmlkZW9UYWdzO1xuICBldmVudC50YWdzLmF1ZGlvVGFncyA9IHRoaXMuYXVkaW9UYWdzO1xuXG4gIC8vIFRyYW5zbGF0ZSBjYXB0aW9uIFBUUyB0aW1lcyBpbnRvIHNlY29uZCBvZmZzZXRzIGludG8gdGhlXG4gIC8vIHZpZGVvIHRpbWVsaW5lIGZvciB0aGUgc2VnbWVudCwgYW5kIGFkZCB0cmFjayBpbmZvXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdDYXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGNhcHRpb24gPSB0aGlzLnBlbmRpbmdDYXB0aW9uc1tpXTtcbiAgICBjYXB0aW9uLnN0YXJ0VGltZSA9IGNhcHRpb24uc3RhcnRQdHMgLSB0aW1lbGluZVN0YXJ0UHRzO1xuICAgIGNhcHRpb24uc3RhcnRUaW1lIC89IDkwZTM7XG4gICAgY2FwdGlvbi5lbmRUaW1lID0gY2FwdGlvbi5lbmRQdHMgLSB0aW1lbGluZVN0YXJ0UHRzO1xuICAgIGNhcHRpb24uZW5kVGltZSAvPSA5MGUzO1xuICAgIGV2ZW50LmNhcHRpb25TdHJlYW1zW2NhcHRpb24uc3RyZWFtXSA9IHRydWU7XG4gICAgZXZlbnQuY2FwdGlvbnMucHVzaChjYXB0aW9uKTtcbiAgfVxuXG4gIC8vIFRyYW5zbGF0ZSBJRDMgZnJhbWUgUFRTIHRpbWVzIGludG8gc2Vjb25kIG9mZnNldHMgaW50byB0aGVcbiAgLy8gdmlkZW8gdGltZWxpbmUgZm9yIHRoZSBzZWdtZW50XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdNZXRhZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGlkMyA9IHRoaXMucGVuZGluZ01ldGFkYXRhW2ldO1xuICAgIGlkMy5jdWVUaW1lID0gaWQzLnB0cyAtIHRpbWVsaW5lU3RhcnRQdHM7XG4gICAgaWQzLmN1ZVRpbWUgLz0gOTBlMztcbiAgICBldmVudC5tZXRhZGF0YS5wdXNoKGlkMyk7XG4gIH1cbiAgLy8gV2UgYWRkIHRoaXMgdG8gZXZlcnkgc2luZ2xlIGVtaXR0ZWQgc2VnbWVudCBldmVuIHRob3VnaCB3ZSBvbmx5IG5lZWRcbiAgLy8gaXQgZm9yIHRoZSBmaXJzdFxuICBldmVudC5tZXRhZGF0YS5kaXNwYXRjaFR5cGUgPSB0aGlzLm1ldGFkYXRhU3RyZWFtLmRpc3BhdGNoVHlwZTtcblxuICAvLyBSZXNldCBzdHJlYW0gc3RhdGVcbiAgdGhpcy52aWRlb1RyYWNrID0gbnVsbDtcbiAgdGhpcy5hdWRpb1RyYWNrID0gbnVsbDtcbiAgdGhpcy52aWRlb1RhZ3MgPSBbXTtcbiAgdGhpcy5hdWRpb1RhZ3MgPSBbXTtcbiAgdGhpcy5wZW5kaW5nQ2FwdGlvbnMubGVuZ3RoID0gMDtcbiAgdGhpcy5wZW5kaW5nTWV0YWRhdGEubGVuZ3RoID0gMDtcbiAgdGhpcy5wZW5kaW5nVHJhY2tzID0gMDtcbiAgdGhpcy5wcm9jZXNzZWRUcmFja3MgPSAwO1xuXG4gIC8vIEVtaXQgdGhlIGZpbmFsIHNlZ21lbnRcbiAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuXG4gIHRoaXMudHJpZ2dlcignZG9uZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2FsZXNjZVN0cmVhbTtcblxufSx7XCIuLi91dGlscy9zdHJlYW0uanNcIjo2Mn1dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEZsdlRhZyA9IHJlcXVpcmUoJy4vZmx2LXRhZy5qcycpO1xuXG4vLyBGb3IgaW5mb3JtYXRpb24gb24gdGhlIEZMViBmb3JtYXQsIHNlZVxuLy8gaHR0cDovL2Rvd25sb2FkLm1hY3JvbWVkaWEuY29tL2Y0di92aWRlb19maWxlX2Zvcm1hdF9zcGVjX3YxMF8xLnBkZi5cbi8vIFRlY2huaWNhbGx5LCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGhlYWRlciBhbmQgYSBtZXRhZGF0YSBGTFYgdGFnXG4vLyBpZiBkdXJhdGlvbiBpcyBncmVhdGVyIHRoYW4gemVyb1xuLy8gZHVyYXRpb24gaW4gc2Vjb25kc1xuLy8gQHJldHVybiB7b2JqZWN0fSB0aGUgYnl0ZXMgb2YgdGhlIEZMViBoZWFkZXIgYXMgYSBVaW50OEFycmF5XG52YXIgZ2V0Rmx2SGVhZGVyID0gZnVuY3Rpb24oZHVyYXRpb24sIGF1ZGlvLCB2aWRlbykgeyAvLyA6Qnl0ZUFycmF5IHtcbiAgdmFyXG4gICAgaGVhZEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMyArIDEgKyAxICsgNCksXG4gICAgaGVhZCA9IG5ldyBEYXRhVmlldyhoZWFkQnl0ZXMuYnVmZmVyKSxcbiAgICBtZXRhZGF0YSxcbiAgICByZXN1bHQsXG4gICAgbWV0YWRhdGFMZW5ndGg7XG5cbiAgLy8gZGVmYXVsdCBhcmd1bWVudHNcbiAgZHVyYXRpb24gPSBkdXJhdGlvbiB8fCAwO1xuICBhdWRpbyA9IGF1ZGlvID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXVkaW87XG4gIHZpZGVvID0gdmlkZW8gPT09IHVuZGVmaW5lZCA/IHRydWUgOiB2aWRlbztcblxuICAvLyBzaWduYXR1cmVcbiAgaGVhZC5zZXRVaW50OCgwLCAweDQ2KTsgLy8gJ0YnXG4gIGhlYWQuc2V0VWludDgoMSwgMHg0Yyk7IC8vICdMJ1xuICBoZWFkLnNldFVpbnQ4KDIsIDB4NTYpOyAvLyAnVidcblxuICAvLyB2ZXJzaW9uXG4gIGhlYWQuc2V0VWludDgoMywgMHgwMSk7XG5cbiAgLy8gZmxhZ3NcbiAgaGVhZC5zZXRVaW50OCg0LCAoYXVkaW8gPyAweDA0IDogMHgwMCkgfCAodmlkZW8gPyAweDAxIDogMHgwMCkpO1xuXG4gIC8vIGRhdGEgb2Zmc2V0LCBzaG91bGQgYmUgOSBmb3IgRkxWIHYxXG4gIGhlYWQuc2V0VWludDMyKDUsIGhlYWRCeXRlcy5ieXRlTGVuZ3RoKTtcblxuICAvLyBpbml0IHRoZSBmaXJzdCBGTFYgdGFnXG4gIGlmIChkdXJhdGlvbiA8PSAwKSB7XG4gICAgLy8gbm8gZHVyYXRpb24gYXZhaWxhYmxlIHNvIGp1c3Qgd3JpdGUgdGhlIGZpcnN0IGZpZWxkIG9mIHRoZSBmaXJzdFxuICAgIC8vIEZMViB0YWdcbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShoZWFkQnl0ZXMuYnl0ZUxlbmd0aCArIDQpO1xuICAgIHJlc3VsdC5zZXQoaGVhZEJ5dGVzKTtcbiAgICByZXN1bHQuc2V0KFswLCAwLCAwLCAwXSwgaGVhZEJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyB3cml0ZSBvdXQgdGhlIGR1cmF0aW9uIG1ldGFkYXRhIHRhZ1xuICBtZXRhZGF0YSA9IG5ldyBGbHZUYWcoRmx2VGFnLk1FVEFEQVRBX1RBRyk7XG4gIG1ldGFkYXRhLnB0cyA9IG1ldGFkYXRhLmR0cyA9IDA7XG4gIG1ldGFkYXRhLndyaXRlTWV0YURhdGFEb3VibGUoJ2R1cmF0aW9uJywgZHVyYXRpb24pO1xuICBtZXRhZGF0YUxlbmd0aCA9IG1ldGFkYXRhLmZpbmFsaXplKCkubGVuZ3RoO1xuICByZXN1bHQgPSBuZXcgVWludDhBcnJheShoZWFkQnl0ZXMuYnl0ZUxlbmd0aCArIG1ldGFkYXRhTGVuZ3RoKTtcbiAgcmVzdWx0LnNldChoZWFkQnl0ZXMpO1xuICByZXN1bHQuc2V0KGhlYWQuYnl0ZUxlbmd0aCwgbWV0YWRhdGFMZW5ndGgpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEZsdkhlYWRlcjtcblxufSx7XCIuL2Zsdi10YWcuanNcIjo0NX1dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSBieXRlcyBvZiBhbiBGTFYgdGFnIGFuZCBtZXRob2RzIGZvclxuICogcXVlcnlpbmcgYW5kIG1hbmlwdWxhdGluZyB0aGF0IGRhdGEuXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5tYWNyb21lZGlhLmNvbS9mNHYvdmlkZW9fZmlsZV9mb3JtYXRfc3BlY192MTBfMS5wZGZcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmx2VGFnO1xuXG4vLyAodHlwZTp1aW50LCBleHRyYURhdGE6Qm9vbGVhbiA9IGZhbHNlKSBleHRlbmRzIEJ5dGVBcnJheVxuRmx2VGFnID0gZnVuY3Rpb24odHlwZSwgZXh0cmFEYXRhKSB7XG4gIHZhclxuICAgIC8vIENvdW50ZXIgaWYgdGhpcyBpcyBhIG1ldGFkYXRhIHRhZywgbmFsIHN0YXJ0IG1hcmtlciBpZiB0aGlzIGlzIGEgdmlkZW9cbiAgICAvLyB0YWcuIHVudXNlZCBpZiB0aGlzIGlzIGFuIGF1ZGlvIHRhZ1xuICAgIGFkSG9jID0gMCwgLy8gOnVpbnRcblxuICAgIC8vIFRoZSBkZWZhdWx0IHNpemUgaXMgMTZrYiBidXQgdGhpcyBpcyBub3QgZW5vdWdoIHRvIGhvbGQgaWZyYW1lXG4gICAgLy8gZGF0YSBhbmQgdGhlIHJlc2l6aW5nIGFsZ29yaXRobSBjb3N0cyBhIGJpdCBzbyB3ZSBjcmVhdGUgYSBsYXJnZXJcbiAgICAvLyBzdGFydGluZyBidWZmZXIgZm9yIHZpZGVvIHRhZ3NcbiAgICBidWZmZXJTdGFydFNpemUgPSAxNjM4NCxcblxuICAgIC8vIGNoZWNrcyB3aGV0aGVyIHRoZSBGTFYgdGFnIGhhcyBlbm91Z2ggY2FwYWNpdHkgdG8gYWNjZXB0IHRoZSBwcm9wb3NlZFxuICAgIC8vIHdyaXRlIGFuZCByZS1hbGxvY2F0ZXMgdGhlIGludGVybmFsIGJ1ZmZlcnMgaWYgbmVjZXNzYXJ5XG4gICAgcHJlcGFyZVdyaXRlID0gZnVuY3Rpb24oZmx2LCBjb3VudCkge1xuICAgICAgdmFyXG4gICAgICAgIGJ5dGVzLFxuICAgICAgICBtaW5MZW5ndGggPSBmbHYucG9zaXRpb24gKyBjb3VudDtcbiAgICAgIGlmIChtaW5MZW5ndGggPCBmbHYuYnl0ZXMuYnl0ZUxlbmd0aCkge1xuICAgICAgICAvLyB0aGVyZSdzIGVub3VnaCBjYXBhY2l0eSBzbyBkbyBub3RoaW5nXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYWxsb2NhdGUgYSBuZXcgYnVmZmVyIGFuZCBjb3B5IG92ZXIgdGhlIGRhdGEgdGhhdCB3aWxsIG5vdCBiZSBtb2RpZmllZFxuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShtaW5MZW5ndGggKiAyKTtcbiAgICAgIGJ5dGVzLnNldChmbHYuYnl0ZXMuc3ViYXJyYXkoMCwgZmx2LnBvc2l0aW9uKSwgMCk7XG4gICAgICBmbHYuYnl0ZXMgPSBieXRlcztcbiAgICAgIGZsdi52aWV3ID0gbmV3IERhdGFWaWV3KGZsdi5ieXRlcy5idWZmZXIpO1xuICAgIH0sXG5cbiAgICAvLyBjb21tb25seSB1c2VkIG1ldGFkYXRhIHByb3BlcnRpZXNcbiAgICB3aWR0aEJ5dGVzID0gRmx2VGFnLndpZHRoQnl0ZXMgfHwgbmV3IFVpbnQ4QXJyYXkoJ3dpZHRoJy5sZW5ndGgpLFxuICAgIGhlaWdodEJ5dGVzID0gRmx2VGFnLmhlaWdodEJ5dGVzIHx8IG5ldyBVaW50OEFycmF5KCdoZWlnaHQnLmxlbmd0aCksXG4gICAgdmlkZW9jb2RlY2lkQnl0ZXMgPSBGbHZUYWcudmlkZW9jb2RlY2lkQnl0ZXMgfHwgbmV3IFVpbnQ4QXJyYXkoJ3ZpZGVvY29kZWNpZCcubGVuZ3RoKSxcbiAgICBpO1xuXG4gIGlmICghRmx2VGFnLndpZHRoQnl0ZXMpIHtcbiAgICAvLyBjYWxjdWxhdGluZyB0aGUgYnl0ZXMgb2YgY29tbW9uIG1ldGFkYXRhIG5hbWVzIGFoZWFkIG9mIHRpbWUgbWFrZXMgdGhlXG4gICAgLy8gY29ycmVzcG9uZGluZyB3cml0ZXMgZmFzdGVyIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0byBsb29wIG92ZXIgdGhlXG4gICAgLy8gY2hhcmFjdGVyc1xuICAgIC8vIHJlLXRlc3Qgd2l0aCB0ZXN0L3BlcmYuaHRtbCBpZiB5b3UncmUgcGxhbm5pbmcgb24gY2hhbmdpbmcgdGhpc1xuICAgIGZvciAoaSA9IDA7IGkgPCAnd2lkdGgnLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3aWR0aEJ5dGVzW2ldID0gJ3dpZHRoJy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgJ2hlaWdodCcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlaWdodEJ5dGVzW2ldID0gJ2hlaWdodCcuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8ICd2aWRlb2NvZGVjaWQnLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2aWRlb2NvZGVjaWRCeXRlc1tpXSA9ICd2aWRlb2NvZGVjaWQnLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuXG4gICAgRmx2VGFnLndpZHRoQnl0ZXMgPSB3aWR0aEJ5dGVzO1xuICAgIEZsdlRhZy5oZWlnaHRCeXRlcyA9IGhlaWdodEJ5dGVzO1xuICAgIEZsdlRhZy52aWRlb2NvZGVjaWRCeXRlcyA9IHZpZGVvY29kZWNpZEJ5dGVzO1xuICB9XG5cbiAgdGhpcy5rZXlGcmFtZSA9IGZhbHNlOyAvLyA6Qm9vbGVhblxuXG4gIHN3aXRjaCAodHlwZSkge1xuICBjYXNlIEZsdlRhZy5WSURFT19UQUc6XG4gICAgdGhpcy5sZW5ndGggPSAxNjtcbiAgICAvLyBTdGFydCB0aGUgYnVmZmVyIGF0IDI1NmtcbiAgICBidWZmZXJTdGFydFNpemUgKj0gNjtcbiAgICBicmVhaztcbiAgY2FzZSBGbHZUYWcuQVVESU9fVEFHOlxuICAgIHRoaXMubGVuZ3RoID0gMTM7XG4gICAgdGhpcy5rZXlGcmFtZSA9IHRydWU7XG4gICAgYnJlYWs7XG4gIGNhc2UgRmx2VGFnLk1FVEFEQVRBX1RBRzpcbiAgICB0aGlzLmxlbmd0aCA9IDI5O1xuICAgIHRoaXMua2V5RnJhbWUgPSB0cnVlO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBGTFYgdGFnIHR5cGUnKTtcbiAgfVxuXG4gIHRoaXMuYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXJTdGFydFNpemUpO1xuICB0aGlzLnZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5ieXRlcy5idWZmZXIpO1xuICB0aGlzLmJ5dGVzWzBdID0gdHlwZTtcbiAgdGhpcy5wb3NpdGlvbiA9IHRoaXMubGVuZ3RoO1xuICB0aGlzLmtleUZyYW1lID0gZXh0cmFEYXRhOyAvLyBEZWZhdWx0cyB0byBmYWxzZVxuXG4gIC8vIHByZXNlbnRhdGlvbiB0aW1lc3RhbXBcbiAgdGhpcy5wdHMgPSAwO1xuICAvLyBkZWNvZGVyIHRpbWVzdGFtcFxuICB0aGlzLmR0cyA9IDA7XG5cbiAgLy8gQnl0ZUFycmF5I3dyaXRlQnl0ZXMoYnl0ZXM6Qnl0ZUFycmF5LCBvZmZzZXQ6dWludCA9IDAsIGxlbmd0aDp1aW50ID0gMClcbiAgdGhpcy53cml0ZUJ5dGVzID0gZnVuY3Rpb24oYnl0ZXMsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgdmFyXG4gICAgICBzdGFydCA9IG9mZnNldCB8fCAwLFxuICAgICAgZW5kO1xuICAgIGxlbmd0aCA9IGxlbmd0aCB8fCBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIGVuZCA9IHN0YXJ0ICsgbGVuZ3RoO1xuXG4gICAgcHJlcGFyZVdyaXRlKHRoaXMsIGxlbmd0aCk7XG4gICAgdGhpcy5ieXRlcy5zZXQoYnl0ZXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksIHRoaXMucG9zaXRpb24pO1xuXG4gICAgdGhpcy5wb3NpdGlvbiArPSBsZW5ndGg7XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgdGhpcy5wb3NpdGlvbik7XG4gIH07XG5cbiAgLy8gQnl0ZUFycmF5I3dyaXRlQnl0ZSh2YWx1ZTppbnQpOnZvaWRcbiAgdGhpcy53cml0ZUJ5dGUgPSBmdW5jdGlvbihieXRlKSB7XG4gICAgcHJlcGFyZVdyaXRlKHRoaXMsIDEpO1xuICAgIHRoaXMuYnl0ZXNbdGhpcy5wb3NpdGlvbl0gPSBieXRlO1xuICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCB0aGlzLnBvc2l0aW9uKTtcbiAgfTtcblxuICAvLyBCeXRlQXJyYXkjd3JpdGVTaG9ydCh2YWx1ZTppbnQpOnZvaWRcbiAgdGhpcy53cml0ZVNob3J0ID0gZnVuY3Rpb24oc2hvcnQpIHtcbiAgICBwcmVwYXJlV3JpdGUodGhpcywgMik7XG4gICAgdGhpcy52aWV3LnNldFVpbnQxNih0aGlzLnBvc2l0aW9uLCBzaG9ydCk7XG4gICAgdGhpcy5wb3NpdGlvbiArPSAyO1xuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIHRoaXMucG9zaXRpb24pO1xuICB9O1xuXG4gIC8vIE5lZ2F0aXZlIGluZGV4IGludG8gYXJyYXlcbiAgLy8gKHBvczp1aW50KTppbnRcbiAgdGhpcy5uZWdJbmRleCA9IGZ1bmN0aW9uKHBvcykge1xuICAgIHJldHVybiB0aGlzLmJ5dGVzW3RoaXMubGVuZ3RoIC0gcG9zXTtcbiAgfTtcblxuICAvLyBUaGUgZnVuY3Rpb25zIGJlbG93IE9OTFkgd29yayB3aGVuIHRoaXNbMF0gPT0gVklERU9fVEFHLlxuICAvLyBXZSBhcmUgbm90IGdvaW5nIHRvIGNoZWNrIGZvciB0aGF0IGJlY2F1c2Ugd2UgZG9udCB3YW50IHRoZSBvdmVyaGVhZFxuICAvLyAobmFsOkJ5dGVBcnJheSA9IG51bGwpOmludFxuICB0aGlzLm5hbFVuaXRTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGFkSG9jID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sZW5ndGggLSAoYWRIb2MgKyA0KTtcbiAgfTtcblxuICB0aGlzLnN0YXJ0TmFsVW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHJlbWVtYmVyIHBvc2l0aW9uIGFuZCBhZGQgNCBieXRlc1xuICAgIGlmIChhZEhvYyA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGNyZWF0ZSBuZXcgTkFMIHdpaG91dCBjbG9zaW5nIHRoZSBvbGQgb25lJyk7XG4gICAgfVxuXG4gICAgLy8gcmVzZXJ2ZSA0IGJ5dGVzIGZvciBuYWwgdW5pdCBzaXplXG4gICAgYWRIb2MgPSB0aGlzLmxlbmd0aDtcbiAgICB0aGlzLmxlbmd0aCArPSA0O1xuICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLmxlbmd0aDtcbiAgfTtcblxuICAvLyAobmFsOkJ5dGVBcnJheSA9IG51bGwpOnZvaWRcbiAgdGhpcy5lbmROYWxVbml0ID0gZnVuY3Rpb24obmFsQ29udGFpbmVyKSB7XG4gICAgdmFyXG4gICAgICBuYWxTdGFydCwgLy8gOnVpbnRcbiAgICAgIG5hbExlbmd0aDsgLy8gOnVpbnRcblxuICAgIC8vIFJld2luZCB0byB0aGUgbWFya2VyIGFuZCB3cml0ZSB0aGUgc2l6ZVxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gYWRIb2MgKyA0KSB7XG4gICAgICAvLyB3ZSBzdGFydGVkIGEgbmFsIHVuaXQsIGJ1dCBkaWRudCB3cml0ZSBvbmUsIHNvIHJvbGwgYmFjayB0aGUgNCBieXRlIHNpemUgdmFsdWVcbiAgICAgIHRoaXMubGVuZ3RoIC09IDQ7XG4gICAgfSBlbHNlIGlmIChhZEhvYyA+IDApIHtcbiAgICAgIG5hbFN0YXJ0ID0gYWRIb2MgKyA0O1xuICAgICAgbmFsTGVuZ3RoID0gdGhpcy5sZW5ndGggLSBuYWxTdGFydDtcblxuICAgICAgdGhpcy5wb3NpdGlvbiA9IGFkSG9jO1xuICAgICAgdGhpcy52aWV3LnNldFVpbnQzMih0aGlzLnBvc2l0aW9uLCBuYWxMZW5ndGgpO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICBpZiAobmFsQ29udGFpbmVyKSB7XG4gICAgICAgIC8vIEFkZCB0aGUgdGFnIHRvIHRoZSBOQUwgdW5pdFxuICAgICAgICBuYWxDb250YWluZXIucHVzaCh0aGlzLmJ5dGVzLnN1YmFycmF5KG5hbFN0YXJ0LCBuYWxTdGFydCArIG5hbExlbmd0aCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFkSG9jID0gMDtcbiAgfTtcblxuICAvKipcbiAgICogV3JpdGUgb3V0IGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IHZhbHVlZCBtZXRhZGF0YSBwcm9wZXJ0eS4gVGhpcyBtZXRob2QgaXNcbiAgICogY2FsbGVkIGZyZXF1ZW50bHkgZHVyaW5nIGEgdHlwaWNhbCBwYXJzZSBhbmQgbmVlZHMgdG8gYmUgZmFzdC5cbiAgICovXG4gIC8vIChrZXk6U3RyaW5nLCB2YWw6TnVtYmVyKTp2b2lkXG4gIHRoaXMud3JpdGVNZXRhRGF0YURvdWJsZSA9IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgdmFyIGk7XG4gICAgcHJlcGFyZVdyaXRlKHRoaXMsIDIgKyBrZXkubGVuZ3RoICsgOSk7XG5cbiAgICAvLyB3cml0ZSBzaXplIG9mIHByb3BlcnR5IG5hbWVcbiAgICB0aGlzLnZpZXcuc2V0VWludDE2KHRoaXMucG9zaXRpb24sIGtleS5sZW5ndGgpO1xuICAgIHRoaXMucG9zaXRpb24gKz0gMjtcblxuICAgIC8vIHRoaXMgbmV4dCBwYXJ0IGxvb2tzIHRlcnJpYmxlIGJ1dCBpdCBpbXByb3ZlcyBwYXJzZXIgdGhyb3VnaHB1dCBieVxuICAgIC8vIDEwa0IvcyBpbiBteSB0ZXN0aW5nXG5cbiAgICAvLyB3cml0ZSBwcm9wZXJ0eSBuYW1lXG4gICAgaWYgKGtleSA9PT0gJ3dpZHRoJykge1xuICAgICAgdGhpcy5ieXRlcy5zZXQod2lkdGhCeXRlcywgdGhpcy5wb3NpdGlvbik7XG4gICAgICB0aGlzLnBvc2l0aW9uICs9IDU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdoZWlnaHQnKSB7XG4gICAgICB0aGlzLmJ5dGVzLnNldChoZWlnaHRCeXRlcywgdGhpcy5wb3NpdGlvbik7XG4gICAgICB0aGlzLnBvc2l0aW9uICs9IDY7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICd2aWRlb2NvZGVjaWQnKSB7XG4gICAgICB0aGlzLmJ5dGVzLnNldCh2aWRlb2NvZGVjaWRCeXRlcywgdGhpcy5wb3NpdGlvbik7XG4gICAgICB0aGlzLnBvc2l0aW9uICs9IDEyO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNbdGhpcy5wb3NpdGlvbl0gPSBrZXkuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNraXAgbnVsbCBieXRlXG4gICAgdGhpcy5wb3NpdGlvbisrO1xuXG4gICAgLy8gd3JpdGUgcHJvcGVydHkgdmFsdWVcbiAgICB0aGlzLnZpZXcuc2V0RmxvYXQ2NCh0aGlzLnBvc2l0aW9uLCB2YWwpO1xuICAgIHRoaXMucG9zaXRpb24gKz0gODtcblxuICAgIC8vIHVwZGF0ZSBmbHYgdGFnIGxlbmd0aFxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIHRoaXMucG9zaXRpb24pO1xuICAgICsrYWRIb2M7XG4gIH07XG5cbiAgLy8gKGtleTpTdHJpbmcsIHZhbDpCb29sZWFuKTp2b2lkXG4gIHRoaXMud3JpdGVNZXRhRGF0YUJvb2xlYW4gPSBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgIHZhciBpO1xuICAgIHByZXBhcmVXcml0ZSh0aGlzLCAyKTtcbiAgICB0aGlzLnZpZXcuc2V0VWludDE2KHRoaXMucG9zaXRpb24sIGtleS5sZW5ndGgpO1xuICAgIHRoaXMucG9zaXRpb24gKz0gMjtcbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBpZiBrZXkuY2hhckNvZGVBdChpKSA+PSAyNTUsIGhhbmRsZSBlcnJvclxuICAgICAgcHJlcGFyZVdyaXRlKHRoaXMsIDEpO1xuICAgICAgdGhpcy5ieXRlc1t0aGlzLnBvc2l0aW9uXSA9IGtleS5jaGFyQ29kZUF0KGkpO1xuICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgIH1cbiAgICBwcmVwYXJlV3JpdGUodGhpcywgMik7XG4gICAgdGhpcy52aWV3LnNldFVpbnQ4KHRoaXMucG9zaXRpb24sIDB4MDEpO1xuICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB0aGlzLnZpZXcuc2V0VWludDgodGhpcy5wb3NpdGlvbiwgdmFsID8gMHgwMSA6IDB4MDApO1xuICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCB0aGlzLnBvc2l0aW9uKTtcbiAgICArK2FkSG9jO1xuICB9O1xuXG4gIC8vICgpOkJ5dGVBcnJheVxuICB0aGlzLmZpbmFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyXG4gICAgICBkdHNEZWx0YSwgLy8gOmludFxuICAgICAgbGVuOyAvLyA6aW50XG5cbiAgICBzd2l0Y2ggKHRoaXMuYnl0ZXNbMF0pIHtcbiAgICAgIC8vIFZpZGVvIERhdGFcbiAgICBjYXNlIEZsdlRhZy5WSURFT19UQUc6XG4gICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IEFWQywgMSA9IGtleSBmcmFtZSAoZm9yIEFWQywgYSBzZWVrYWJsZVxuICAgICAgIC8vIGZyYW1lKSwgMiA9IGludGVyIGZyYW1lIChmb3IgQVZDLCBhIG5vbi1zZWVrYWJsZSBmcmFtZSlcbiAgICAgIHRoaXMuYnl0ZXNbMTFdID0gKCh0aGlzLmtleUZyYW1lIHx8IGV4dHJhRGF0YSkgPyAweDEwIDogMHgyMCkgfCAweDA3O1xuICAgICAgdGhpcy5ieXRlc1sxMl0gPSBleHRyYURhdGEgPyAgMHgwMCA6IDB4MDE7XG5cbiAgICAgIGR0c0RlbHRhID0gdGhpcy5wdHMgLSB0aGlzLmR0cztcbiAgICAgIHRoaXMuYnl0ZXNbMTNdID0gKGR0c0RlbHRhICYgMHgwMEZGMDAwMCkgPj4+IDE2O1xuICAgICAgdGhpcy5ieXRlc1sxNF0gPSAoZHRzRGVsdGEgJiAweDAwMDBGRjAwKSA+Pj4gIDg7XG4gICAgICB0aGlzLmJ5dGVzWzE1XSA9IChkdHNEZWx0YSAmIDB4MDAwMDAwRkYpID4+PiAgMDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBGbHZUYWcuQVVESU9fVEFHOlxuICAgICAgdGhpcy5ieXRlc1sxMV0gPSAweEFGOyAvLyA0NCBrSHosIDE2LWJpdCBzdGVyZW9cbiAgICAgIHRoaXMuYnl0ZXNbMTJdID0gZXh0cmFEYXRhID8gMHgwMCA6IDB4MDE7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRmx2VGFnLk1FVEFEQVRBX1RBRzpcbiAgICAgIHRoaXMucG9zaXRpb24gPSAxMTtcbiAgICAgIHRoaXMudmlldy5zZXRVaW50OCh0aGlzLnBvc2l0aW9uLCAweDAyKTsgLy8gU3RyaW5nIHR5cGVcbiAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICAgIHRoaXMudmlldy5zZXRVaW50MTYodGhpcy5wb3NpdGlvbiwgMHgwQSk7IC8vIDEwIEJ5dGVzXG4gICAgICB0aGlzLnBvc2l0aW9uICs9IDI7XG4gICAgICAvLyBzZXQgXCJvbk1ldGFEYXRhXCJcbiAgICAgIHRoaXMuYnl0ZXMuc2V0KFsweDZmLCAweDZlLCAweDRkLCAweDY1LFxuICAgICAgICAgICAgICAgICAgICAgIDB4NzQsIDB4NjEsIDB4NDQsIDB4NjEsXG4gICAgICAgICAgICAgICAgICAgICAgMHg3NCwgMHg2MV0sIHRoaXMucG9zaXRpb24pO1xuICAgICAgdGhpcy5wb3NpdGlvbiArPSAxMDtcbiAgICAgIHRoaXMuYnl0ZXNbdGhpcy5wb3NpdGlvbl0gPSAweDA4OyAvLyBBcnJheSB0eXBlXG4gICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgICB0aGlzLnZpZXcuc2V0VWludDMyKHRoaXMucG9zaXRpb24sIGFkSG9jKTtcbiAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLmxlbmd0aDtcbiAgICAgIHRoaXMuYnl0ZXMuc2V0KFswLCAwLCA5XSwgdGhpcy5wb3NpdGlvbik7XG4gICAgICB0aGlzLnBvc2l0aW9uICs9IDM7IC8vIEVuZCBEYXRhIFRhZ1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbGVuID0gdGhpcy5sZW5ndGggLSAxMTtcblxuICAgIC8vIHdyaXRlIHRoZSBEYXRhU2l6ZSBmaWVsZFxuICAgIHRoaXMuYnl0ZXNbIDFdID0gKGxlbiAmIDB4MDBGRjAwMDApID4+PiAxNjtcbiAgICB0aGlzLmJ5dGVzWyAyXSA9IChsZW4gJiAweDAwMDBGRjAwKSA+Pj4gIDg7XG4gICAgdGhpcy5ieXRlc1sgM10gPSAobGVuICYgMHgwMDAwMDBGRikgPj4+ICAwO1xuICAgIC8vIHdyaXRlIHRoZSBUaW1lc3RhbXBcbiAgICB0aGlzLmJ5dGVzWyA0XSA9ICh0aGlzLmR0cyAmIDB4MDBGRjAwMDApID4+PiAxNjtcbiAgICB0aGlzLmJ5dGVzWyA1XSA9ICh0aGlzLmR0cyAmIDB4MDAwMEZGMDApID4+PiAgODtcbiAgICB0aGlzLmJ5dGVzWyA2XSA9ICh0aGlzLmR0cyAmIDB4MDAwMDAwRkYpID4+PiAgMDtcbiAgICB0aGlzLmJ5dGVzWyA3XSA9ICh0aGlzLmR0cyAmIDB4RkYwMDAwMDApID4+PiAyNDtcbiAgICAvLyB3cml0ZSB0aGUgU3RyZWFtSURcbiAgICB0aGlzLmJ5dGVzWyA4XSA9IDA7XG4gICAgdGhpcy5ieXRlc1sgOV0gPSAwO1xuICAgIHRoaXMuYnl0ZXNbMTBdID0gMDtcblxuICAgIC8vIFNvbWV0aW1lcyB3ZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSB2aWV3IGFuZCBoYXZlIG9uZSBzbG90IHRvIHdyaXRlIGFcbiAgICAvLyB1aW50MzIsIHNvLCBwcmVwYXJlV3JpdGUgb2YgY291bnQgNCwgc2luY2UsIHZpZXcgaXMgdWludDhcbiAgICBwcmVwYXJlV3JpdGUodGhpcywgNCk7XG4gICAgdGhpcy52aWV3LnNldFVpbnQzMih0aGlzLmxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICAgIHRoaXMubGVuZ3RoICs9IDQ7XG4gICAgdGhpcy5wb3NpdGlvbiArPSA0O1xuXG4gICAgLy8gdHJpbSBkb3duIHRoZSBieXRlIGJ1ZmZlciB0byB3aGF0IGlzIGFjdHVhbGx5IGJlaW5nIHVzZWRcbiAgICB0aGlzLmJ5dGVzID0gdGhpcy5ieXRlcy5zdWJhcnJheSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgdGhpcy5mcmFtZVRpbWUgPSBGbHZUYWcuZnJhbWVUaW1lKHRoaXMuYnl0ZXMpO1xuICAgIC8vIGlmIGJ5dGVzLmJ5dGVsZW5ndGggaXNuJ3QgZXF1YWwgdG8gdGhpcy5sZW5ndGgsIGhhbmRsZSBlcnJvclxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufTtcblxuRmx2VGFnLkFVRElPX1RBRyA9IDB4MDg7IC8vID09IDgsIDp1aW50XG5GbHZUYWcuVklERU9fVEFHID0gMHgwOTsgLy8gPT0gOSwgOnVpbnRcbkZsdlRhZy5NRVRBREFUQV9UQUcgPSAweDEyOyAvLyA9PSAxOCwgOnVpbnRcblxuLy8gKHRhZzpCeXRlQXJyYXkpOkJvb2xlYW4ge1xuRmx2VGFnLmlzQXVkaW9GcmFtZSA9IGZ1bmN0aW9uKHRhZykge1xuICByZXR1cm4gRmx2VGFnLkFVRElPX1RBRyA9PT0gdGFnWzBdO1xufTtcblxuLy8gKHRhZzpCeXRlQXJyYXkpOkJvb2xlYW4ge1xuRmx2VGFnLmlzVmlkZW9GcmFtZSA9IGZ1bmN0aW9uKHRhZykge1xuICByZXR1cm4gRmx2VGFnLlZJREVPX1RBRyA9PT0gdGFnWzBdO1xufTtcblxuLy8gKHRhZzpCeXRlQXJyYXkpOkJvb2xlYW4ge1xuRmx2VGFnLmlzTWV0YURhdGEgPSBmdW5jdGlvbih0YWcpIHtcbiAgcmV0dXJuIEZsdlRhZy5NRVRBREFUQV9UQUcgPT09IHRhZ1swXTtcbn07XG5cbi8vICh0YWc6Qnl0ZUFycmF5KTpCb29sZWFuIHtcbkZsdlRhZy5pc0tleUZyYW1lID0gZnVuY3Rpb24odGFnKSB7XG4gIGlmIChGbHZUYWcuaXNWaWRlb0ZyYW1lKHRhZykpIHtcbiAgICByZXR1cm4gdGFnWzExXSA9PT0gMHgxNztcbiAgfVxuXG4gIGlmIChGbHZUYWcuaXNBdWRpb0ZyYW1lKHRhZykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChGbHZUYWcuaXNNZXRhRGF0YSh0YWcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyAodGFnOkJ5dGVBcnJheSk6dWludCB7XG5GbHZUYWcuZnJhbWVUaW1lID0gZnVuY3Rpb24odGFnKSB7XG4gIHZhciBwdHMgPSB0YWdbIDRdIDw8IDE2OyAvLyA6dWludFxuICBwdHMgfD0gdGFnWyA1XSA8PCAgODtcbiAgcHRzIHw9IHRhZ1sgNl0gPDwgIDA7XG4gIHB0cyB8PSB0YWdbIDddIDw8IDI0O1xuICByZXR1cm4gcHRzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGbHZUYWc7XG5cbn0se31dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0ge1xuICB0YWc6IHJlcXVpcmUoJy4vZmx2LXRhZycpLFxuICBUcmFuc211eGVyOiByZXF1aXJlKCcuL3RyYW5zbXV4ZXInKSxcbiAgZ2V0Rmx2SGVhZGVyOiByZXF1aXJlKCcuL2Zsdi1oZWFkZXInKVxufTtcblxufSx7XCIuL2Zsdi1oZWFkZXJcIjo0NCxcIi4vZmx2LXRhZ1wiOjQ1LFwiLi90cmFuc211eGVyXCI6NDh9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBUYWdMaXN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLmxpc3QgPSBbXTtcblxuICB0aGlzLnB1c2ggPSBmdW5jdGlvbih0YWcpIHtcbiAgICB0aGlzLmxpc3QucHVzaCh7XG4gICAgICBieXRlczogdGFnLmJ5dGVzLFxuICAgICAgZHRzOiB0YWcuZHRzLFxuICAgICAgcHRzOiB0YWcucHRzLFxuICAgICAga2V5RnJhbWU6IHRhZy5rZXlGcmFtZSxcbiAgICAgIG1ldGFEYXRhVGFnOiB0YWcubWV0YURhdGFUYWdcbiAgICB9KTtcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2xlbmd0aCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNlbGYubGlzdC5sZW5ndGg7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGFnTGlzdDtcblxufSx7fV0sNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi4vdXRpbHMvc3RyZWFtLmpzJyk7XG52YXIgRmx2VGFnID0gcmVxdWlyZSgnLi9mbHYtdGFnLmpzJyk7XG52YXIgbTJ0cyA9IHJlcXVpcmUoJy4uL20ydHMvbTJ0cy5qcycpO1xudmFyIEFkdHNTdHJlYW0gPSByZXF1aXJlKCcuLi9jb2RlY3MvYWR0cy5qcycpO1xudmFyIEgyNjRTdHJlYW0gPSByZXF1aXJlKCcuLi9jb2RlY3MvaDI2NCcpLkgyNjRTdHJlYW07XG52YXIgQ29hbGVzY2VTdHJlYW0gPSByZXF1aXJlKCcuL2NvYWxlc2NlLXN0cmVhbS5qcycpO1xudmFyIFRhZ0xpc3QgPSByZXF1aXJlKCcuL3RhZy1saXN0LmpzJyk7XG5cbnZhclxuICBUcmFuc211eGVyLFxuICBWaWRlb1NlZ21lbnRTdHJlYW0sXG4gIEF1ZGlvU2VnbWVudFN0cmVhbSxcbiAgY29sbGVjdFRpbWVsaW5lSW5mbyxcbiAgbWV0YURhdGFUYWcsXG4gIGV4dHJhRGF0YVRhZztcblxuLyoqXG4gKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgdHJhY2thIGFuZCB0aGVcbiAqIGR1cmF0aW9uIGZvciBlYWNoIGZyYW1lL3NhbXBsZSB3ZSBwcm9jZXNzIGluIG9yZGVyIHRvIGNhbGN1bGF0ZVxuICogdGhlIGJhc2VNZWRpYURlY29kZVRpbWVcbiAqL1xuY29sbGVjdFRpbWVsaW5lSW5mbyA9IGZ1bmN0aW9uKHRyYWNrLCBkYXRhKSB7XG4gIGlmICh0eXBlb2YgZGF0YS5wdHMgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHRyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLnB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0cmFjay50aW1lbGluZVN0YXJ0SW5mby5wdHMgPSBkYXRhLnB0cztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2sudGltZWxpbmVTdGFydEluZm8ucHRzID1cbiAgICAgICAgTWF0aC5taW4odHJhY2sudGltZWxpbmVTdGFydEluZm8ucHRzLCBkYXRhLnB0cyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBkYXRhLmR0cyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHJhY2sudGltZWxpbmVTdGFydEluZm8uZHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmR0cyA9IGRhdGEuZHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFjay50aW1lbGluZVN0YXJ0SW5mby5kdHMgPVxuICAgICAgICBNYXRoLm1pbih0cmFjay50aW1lbGluZVN0YXJ0SW5mby5kdHMsIGRhdGEuZHRzKTtcbiAgICB9XG4gIH1cbn07XG5cbm1ldGFEYXRhVGFnID0gZnVuY3Rpb24odHJhY2ssIHB0cykge1xuICB2YXJcbiAgICB0YWcgPSBuZXcgRmx2VGFnKEZsdlRhZy5NRVRBREFUQV9UQUcpOyAvLyA6Rmx2VGFnXG5cbiAgdGFnLmR0cyA9IHB0cztcbiAgdGFnLnB0cyA9IHB0cztcblxuICB0YWcud3JpdGVNZXRhRGF0YURvdWJsZSgndmlkZW9jb2RlY2lkJywgNyk7XG4gIHRhZy53cml0ZU1ldGFEYXRhRG91YmxlKCd3aWR0aCcsIHRyYWNrLndpZHRoKTtcbiAgdGFnLndyaXRlTWV0YURhdGFEb3VibGUoJ2hlaWdodCcsIHRyYWNrLmhlaWdodCk7XG5cbiAgcmV0dXJuIHRhZztcbn07XG5cbmV4dHJhRGF0YVRhZyA9IGZ1bmN0aW9uKHRyYWNrLCBwdHMpIHtcbiAgdmFyXG4gICAgaSxcbiAgICB0YWcgPSBuZXcgRmx2VGFnKEZsdlRhZy5WSURFT19UQUcsIHRydWUpO1xuXG4gIHRhZy5kdHMgPSBwdHM7XG4gIHRhZy5wdHMgPSBwdHM7XG5cbiAgdGFnLndyaXRlQnl0ZSgweDAxKTsvLyB2ZXJzaW9uXG4gIHRhZy53cml0ZUJ5dGUodHJhY2sucHJvZmlsZUlkYyk7Ly8gcHJvZmlsZVxuICB0YWcud3JpdGVCeXRlKHRyYWNrLnByb2ZpbGVDb21wYXRpYmlsaXR5KTsvLyBjb21wYXRpYmlsaXR5XG4gIHRhZy53cml0ZUJ5dGUodHJhY2subGV2ZWxJZGMpOy8vIGxldmVsXG4gIHRhZy53cml0ZUJ5dGUoMHhGQyB8IDB4MDMpOyAvLyByZXNlcnZlZCAoNiBiaXRzKSwgTlVMQSBsZW5ndGggc2l6ZSAtIDEgKDIgYml0cylcbiAgdGFnLndyaXRlQnl0ZSgweEUwIHwgMHgwMSk7IC8vIHJlc2VydmVkICgzIGJpdHMpLCBudW0gb2YgU1BTICg1IGJpdHMpXG4gIHRhZy53cml0ZVNob3J0KHRyYWNrLnNwc1swXS5sZW5ndGgpOyAvLyBkYXRhIG9mIFNQU1xuICB0YWcud3JpdGVCeXRlcyh0cmFjay5zcHNbMF0pOyAvLyBTUFNcblxuICB0YWcud3JpdGVCeXRlKHRyYWNrLnBwcy5sZW5ndGgpOyAvLyBudW0gb2YgUFBTICh3aWxsIHRoZXJlIGV2ZXIgYmUgbW9yZSB0aGF0IDEgUFBTPylcbiAgZm9yIChpID0gMDsgaSA8IHRyYWNrLnBwcy5sZW5ndGg7ICsraSkge1xuICAgIHRhZy53cml0ZVNob3J0KHRyYWNrLnBwc1tpXS5sZW5ndGgpOyAvLyAyIGJ5dGVzIGZvciBsZW5ndGggb2YgUFBTXG4gICAgdGFnLndyaXRlQnl0ZXModHJhY2sucHBzW2ldKTsgLy8gZGF0YSBvZiBQUFNcbiAgfVxuXG4gIHJldHVybiB0YWc7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBzaW5nbGUtdHJhY2ssIG1lZGlhIHNlZ21lbnQgZnJvbSBBQUMgZGF0YVxuICogZXZlbnRzLiBUaGUgb3V0cHV0IG9mIHRoaXMgc3RyZWFtIGNhbiBiZSBmZWQgdG8gZmxhc2guXG4gKi9cbkF1ZGlvU2VnbWVudFN0cmVhbSA9IGZ1bmN0aW9uKHRyYWNrKSB7XG4gIHZhclxuICAgIGFkdHNGcmFtZXMgPSBbXSxcbiAgICB2aWRlb0tleUZyYW1lcyA9IFtdLFxuICAgIG9sZEV4dHJhRGF0YTtcblxuICBBdWRpb1NlZ21lbnRTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnB1c2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgY29sbGVjdFRpbWVsaW5lSW5mbyh0cmFjaywgZGF0YSk7XG5cbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHRyYWNrLmF1ZGlvb2JqZWN0dHlwZSA9IGRhdGEuYXVkaW9vYmplY3R0eXBlO1xuICAgICAgdHJhY2suY2hhbm5lbGNvdW50ID0gZGF0YS5jaGFubmVsY291bnQ7XG4gICAgICB0cmFjay5zYW1wbGVyYXRlID0gZGF0YS5zYW1wbGVyYXRlO1xuICAgICAgdHJhY2suc2FtcGxpbmdmcmVxdWVuY3lpbmRleCA9IGRhdGEuc2FtcGxpbmdmcmVxdWVuY3lpbmRleDtcbiAgICAgIHRyYWNrLnNhbXBsZXNpemUgPSBkYXRhLnNhbXBsZXNpemU7XG4gICAgICB0cmFjay5leHRyYURhdGEgPSAodHJhY2suYXVkaW9vYmplY3R0eXBlIDw8IDExKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAodHJhY2suc2FtcGxpbmdmcmVxdWVuY3lpbmRleCA8PCA3KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAodHJhY2suY2hhbm5lbGNvdW50IDw8IDMpO1xuICAgIH1cblxuICAgIGRhdGEucHRzID0gTWF0aC5yb3VuZChkYXRhLnB0cyAvIDkwKTtcbiAgICBkYXRhLmR0cyA9IE1hdGgucm91bmQoZGF0YS5kdHMgLyA5MCk7XG5cbiAgICAvLyBidWZmZXIgYXVkaW8gZGF0YSB1bnRpbCBlbmQoKSBpcyBjYWxsZWRcbiAgICBhZHRzRnJhbWVzLnB1c2goZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXJyZW50RnJhbWUsIGFkdHNGcmFtZSwgbGFzdE1ldGFQdHMsIHRhZ3MgPSBuZXcgVGFnTGlzdCgpO1xuICAgIC8vIHJldHVybiBlYXJseSBpZiBubyBhdWRpbyBkYXRhIGhhcyBiZWVuIG9ic2VydmVkXG4gICAgaWYgKGFkdHNGcmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RvbmUnLCAnQXVkaW9TZWdtZW50U3RyZWFtJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGFzdE1ldGFQdHMgPSAtSW5maW5pdHk7XG5cbiAgICB3aGlsZSAoYWR0c0ZyYW1lcy5sZW5ndGgpIHtcbiAgICAgIGN1cnJlbnRGcmFtZSA9IGFkdHNGcmFtZXMuc2hpZnQoKTtcblxuICAgICAgLy8gd3JpdGUgb3V0IGEgbWV0YWRhdGEgZnJhbWUgYXQgZXZlcnkgdmlkZW8ga2V5IGZyYW1lXG4gICAgICBpZiAodmlkZW9LZXlGcmFtZXMubGVuZ3RoICYmIGN1cnJlbnRGcmFtZS5wdHMgPj0gdmlkZW9LZXlGcmFtZXNbMF0pIHtcbiAgICAgICAgbGFzdE1ldGFQdHMgPSB2aWRlb0tleUZyYW1lcy5zaGlmdCgpO1xuICAgICAgICB0aGlzLndyaXRlTWV0YURhdGFUYWdzKHRhZ3MsIGxhc3RNZXRhUHRzKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWxzbyB3cml0ZSBvdXQgbWV0YWRhdGEgdGFncyBldmVyeSAxIHNlY29uZCBzbyB0aGF0IHRoZSBkZWNvZGVyXG4gICAgICAvLyBpcyByZS1pbml0aWFsaXplZCBxdWlja2x5IGFmdGVyIHNlZWtpbmcgaW50byBhIGRpZmZlcmVudFxuICAgICAgLy8gYXVkaW8gY29uZmlndXJhdGlvbi5cbiAgICAgIGlmICh0cmFjay5leHRyYURhdGEgIT09IG9sZEV4dHJhRGF0YSB8fCBjdXJyZW50RnJhbWUucHRzIC0gbGFzdE1ldGFQdHMgPj0gMTAwMCkge1xuICAgICAgICB0aGlzLndyaXRlTWV0YURhdGFUYWdzKHRhZ3MsIGN1cnJlbnRGcmFtZS5wdHMpO1xuICAgICAgICBvbGRFeHRyYURhdGEgPSB0cmFjay5leHRyYURhdGE7XG4gICAgICAgIGxhc3RNZXRhUHRzID0gY3VycmVudEZyYW1lLnB0cztcbiAgICAgIH1cblxuICAgICAgYWR0c0ZyYW1lID0gbmV3IEZsdlRhZyhGbHZUYWcuQVVESU9fVEFHKTtcbiAgICAgIGFkdHNGcmFtZS5wdHMgPSBjdXJyZW50RnJhbWUucHRzO1xuICAgICAgYWR0c0ZyYW1lLmR0cyA9IGN1cnJlbnRGcmFtZS5kdHM7XG5cbiAgICAgIGFkdHNGcmFtZS53cml0ZUJ5dGVzKGN1cnJlbnRGcmFtZS5kYXRhKTtcblxuICAgICAgdGFncy5wdXNoKGFkdHNGcmFtZS5maW5hbGl6ZSgpKTtcbiAgICB9XG5cbiAgICB2aWRlb0tleUZyYW1lcy5sZW5ndGggPSAwO1xuICAgIG9sZEV4dHJhRGF0YSA9IG51bGw7XG4gICAgdGhpcy50cmlnZ2VyKCdkYXRhJywge3RyYWNrOiB0cmFjaywgdGFnczogdGFncy5saXN0fSk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2RvbmUnLCAnQXVkaW9TZWdtZW50U3RyZWFtJyk7XG4gIH07XG5cbiAgdGhpcy53cml0ZU1ldGFEYXRhVGFncyA9IGZ1bmN0aW9uKHRhZ3MsIHB0cykge1xuICAgIHZhciBhZHRzRnJhbWU7XG5cbiAgICBhZHRzRnJhbWUgPSBuZXcgRmx2VGFnKEZsdlRhZy5NRVRBREFUQV9UQUcpO1xuICAgIC8vIEZvciBhdWRpbywgRFRTIGlzIGFsd2F5cyB0aGUgc2FtZSBhcyBQVFMuIFdlIHdhbnQgdG8gc2V0IHRoZSBEVFNcbiAgICAvLyBob3dldmVyIHNvIHdlIGNhbiBjb21wYXJlIHdpdGggdmlkZW8gRFRTIHRvIGRldGVybWluZSBhcHByb3hpbWF0ZVxuICAgIC8vIHBhY2tldCBvcmRlclxuICAgIGFkdHNGcmFtZS5wdHMgPSBwdHM7XG4gICAgYWR0c0ZyYW1lLmR0cyA9IHB0cztcblxuICAgIC8vIEFBQyBpcyBhbHdheXMgMTBcbiAgICBhZHRzRnJhbWUud3JpdGVNZXRhRGF0YURvdWJsZSgnYXVkaW9jb2RlY2lkJywgMTApO1xuICAgIGFkdHNGcmFtZS53cml0ZU1ldGFEYXRhQm9vbGVhbignc3RlcmVvJywgdHJhY2suY2hhbm5lbGNvdW50ID09PSAyKTtcbiAgICBhZHRzRnJhbWUud3JpdGVNZXRhRGF0YURvdWJsZSgnYXVkaW9zYW1wbGVyYXRlJywgdHJhY2suc2FtcGxlcmF0ZSk7XG4gICAgLy8gSXMgQUFDIGFsd2F5cyAxNiBiaXQ/XG4gICAgYWR0c0ZyYW1lLndyaXRlTWV0YURhdGFEb3VibGUoJ2F1ZGlvc2FtcGxlc2l6ZScsIDE2KTtcblxuICAgIHRhZ3MucHVzaChhZHRzRnJhbWUuZmluYWxpemUoKSk7XG5cbiAgICBhZHRzRnJhbWUgPSBuZXcgRmx2VGFnKEZsdlRhZy5BVURJT19UQUcsIHRydWUpO1xuICAgIC8vIEZvciBhdWRpbywgRFRTIGlzIGFsd2F5cyB0aGUgc2FtZSBhcyBQVFMuIFdlIHdhbnQgdG8gc2V0IHRoZSBEVFNcbiAgICAvLyBob3dldmVyIHNvIHdlIGNhbiBjb21wYXJlIHdpdGggdmlkZW8gRFRTIHRvIGRldGVybWluZSBhcHByb3hpbWF0ZVxuICAgIC8vIHBhY2tldCBvcmRlclxuICAgIGFkdHNGcmFtZS5wdHMgPSBwdHM7XG4gICAgYWR0c0ZyYW1lLmR0cyA9IHB0cztcblxuICAgIGFkdHNGcmFtZS52aWV3LnNldFVpbnQxNihhZHRzRnJhbWUucG9zaXRpb24sIHRyYWNrLmV4dHJhRGF0YSk7XG4gICAgYWR0c0ZyYW1lLnBvc2l0aW9uICs9IDI7XG4gICAgYWR0c0ZyYW1lLmxlbmd0aCA9IE1hdGgubWF4KGFkdHNGcmFtZS5sZW5ndGgsIGFkdHNGcmFtZS5wb3NpdGlvbik7XG5cbiAgICB0YWdzLnB1c2goYWR0c0ZyYW1lLmZpbmFsaXplKCkpO1xuICB9O1xuXG4gIHRoaXMub25WaWRlb0tleUZyYW1lID0gZnVuY3Rpb24ocHRzKSB7XG4gICAgdmlkZW9LZXlGcmFtZXMucHVzaChwdHMpO1xuICB9O1xufTtcbkF1ZGlvU2VnbWVudFN0cmVhbS5wcm90b3R5cGUgPSBuZXcgU3RyZWFtKCk7XG5cbi8qKlxuICogU3RvcmUgRmx2VGFncyBmb3IgdGhlIGgyNjQgc3RyZWFtXG4gKiBAcGFyYW0gdHJhY2sge29iamVjdH0gdHJhY2sgbWV0YWRhdGEgY29uZmlndXJhdGlvblxuICovXG5WaWRlb1NlZ21lbnRTdHJlYW0gPSBmdW5jdGlvbih0cmFjaykge1xuICB2YXJcbiAgICBuYWxVbml0cyA9IFtdLFxuICAgIGNvbmZpZyxcbiAgICBoMjY0RnJhbWU7XG4gIFZpZGVvU2VnbWVudFN0cmVhbS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuZmluaXNoRnJhbWUgPSBmdW5jdGlvbih0YWdzLCBmcmFtZSkge1xuICAgIGlmICghZnJhbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYga2V5ZnJhbWUgYW5kIHRoZSBsZW5ndGggb2YgdGFncy5cbiAgICAvLyBUaGlzIG1ha2VzIHN1cmUgd2Ugd3JpdGUgbWV0YWRhdGEgb24gdGhlIGZpcnN0IGZyYW1lIG9mIGEgc2VnbWVudC5cbiAgICBpZiAoY29uZmlnICYmIHRyYWNrICYmIHRyYWNrLm5ld01ldGFkYXRhICYmXG4gICAgICAgIChmcmFtZS5rZXlGcmFtZSB8fCB0YWdzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgIC8vIFB1c2ggZXh0cmEgZGF0YSBvbiBldmVyeSBJRFIgZnJhbWUgaW4gY2FzZSB3ZSBkaWQgYSBzdHJlYW0gY2hhbmdlICsgc2Vla1xuICAgICAgdmFyIG1ldGFUYWcgPSBtZXRhRGF0YVRhZyhjb25maWcsIGZyYW1lLmR0cykuZmluYWxpemUoKTtcbiAgICAgIHZhciBleHRyYVRhZyA9IGV4dHJhRGF0YVRhZyh0cmFjaywgZnJhbWUuZHRzKS5maW5hbGl6ZSgpO1xuXG4gICAgICBtZXRhVGFnLm1ldGFEYXRhVGFnID0gZXh0cmFUYWcubWV0YURhdGFUYWcgPSB0cnVlO1xuXG4gICAgICB0YWdzLnB1c2gobWV0YVRhZyk7XG4gICAgICB0YWdzLnB1c2goZXh0cmFUYWcpO1xuICAgICAgdHJhY2submV3TWV0YWRhdGEgPSBmYWxzZTtcblxuICAgICAgdGhpcy50cmlnZ2VyKCdrZXlmcmFtZScsIGZyYW1lLmR0cyk7XG4gICAgfVxuXG4gICAgZnJhbWUuZW5kTmFsVW5pdCgpO1xuICAgIHRhZ3MucHVzaChmcmFtZS5maW5hbGl6ZSgpKTtcbiAgICBoMjY0RnJhbWUgPSBudWxsO1xuICB9O1xuXG4gIHRoaXMucHVzaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBjb2xsZWN0VGltZWxpbmVJbmZvKHRyYWNrLCBkYXRhKTtcblxuICAgIGRhdGEucHRzID0gTWF0aC5yb3VuZChkYXRhLnB0cyAvIDkwKTtcbiAgICBkYXRhLmR0cyA9IE1hdGgucm91bmQoZGF0YS5kdHMgLyA5MCk7XG5cbiAgICAvLyBidWZmZXIgdmlkZW8gdW50aWwgZmx1c2goKSBpcyBjYWxsZWRcbiAgICBuYWxVbml0cy5wdXNoKGRhdGEpO1xuICB9O1xuXG4gIHRoaXMuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXJcbiAgICAgIGN1cnJlbnROYWwsXG4gICAgICB0YWdzID0gbmV3IFRhZ0xpc3QoKTtcblxuICAgIC8vIFRocm93IGF3YXkgbmFsVW5pdHMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBieXRlIHN0cmVhbSB1bnRpbCB3ZSBmaW5kXG4gICAgLy8gdGhlIGZpcnN0IEFVRFxuICAgIHdoaWxlIChuYWxVbml0cy5sZW5ndGgpIHtcbiAgICAgIGlmIChuYWxVbml0c1swXS5uYWxVbml0VHlwZSA9PT0gJ2FjY2Vzc191bml0X2RlbGltaXRlcl9yYnNwJykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5hbFVuaXRzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIGVhcmx5IGlmIG5vIHZpZGVvIGRhdGEgaGFzIGJlZW4gb2JzZXJ2ZWRcbiAgICBpZiAobmFsVW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RvbmUnLCAnVmlkZW9TZWdtZW50U3RyZWFtJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKG5hbFVuaXRzLmxlbmd0aCkge1xuICAgICAgY3VycmVudE5hbCA9IG5hbFVuaXRzLnNoaWZ0KCk7XG5cbiAgICAgIC8vIHJlY29yZCB0aGUgdHJhY2sgY29uZmlnXG4gICAgICBpZiAoY3VycmVudE5hbC5uYWxVbml0VHlwZSA9PT0gJ3NlcV9wYXJhbWV0ZXJfc2V0X3Jic3AnKSB7XG4gICAgICAgIHRyYWNrLm5ld01ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnID0gY3VycmVudE5hbC5jb25maWc7XG4gICAgICAgIHRyYWNrLndpZHRoID0gY29uZmlnLndpZHRoO1xuICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICB0cmFjay5zcHMgPSBbY3VycmVudE5hbC5kYXRhXTtcbiAgICAgICAgdHJhY2sucHJvZmlsZUlkYyA9IGNvbmZpZy5wcm9maWxlSWRjO1xuICAgICAgICB0cmFjay5sZXZlbElkYyA9IGNvbmZpZy5sZXZlbElkYztcbiAgICAgICAgdHJhY2sucHJvZmlsZUNvbXBhdGliaWxpdHkgPSBjb25maWcucHJvZmlsZUNvbXBhdGliaWxpdHk7XG4gICAgICAgIGgyNjRGcmFtZS5lbmROYWxVbml0KCk7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnROYWwubmFsVW5pdFR5cGUgPT09ICdwaWNfcGFyYW1ldGVyX3NldF9yYnNwJykge1xuICAgICAgICB0cmFjay5uZXdNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIHRyYWNrLnBwcyA9IFtjdXJyZW50TmFsLmRhdGFdO1xuICAgICAgICBoMjY0RnJhbWUuZW5kTmFsVW5pdCgpO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50TmFsLm5hbFVuaXRUeXBlID09PSAnYWNjZXNzX3VuaXRfZGVsaW1pdGVyX3Jic3AnKSB7XG4gICAgICAgIGlmIChoMjY0RnJhbWUpIHtcbiAgICAgICAgICB0aGlzLmZpbmlzaEZyYW1lKHRhZ3MsIGgyNjRGcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaDI2NEZyYW1lID0gbmV3IEZsdlRhZyhGbHZUYWcuVklERU9fVEFHKTtcbiAgICAgICAgaDI2NEZyYW1lLnB0cyA9IGN1cnJlbnROYWwucHRzO1xuICAgICAgICBoMjY0RnJhbWUuZHRzID0gY3VycmVudE5hbC5kdHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY3VycmVudE5hbC5uYWxVbml0VHlwZSA9PT0gJ3NsaWNlX2xheWVyX3dpdGhvdXRfcGFydGl0aW9uaW5nX3Jic3BfaWRyJykge1xuICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHNhbXBsZSBpcyBhIGtleSBmcmFtZVxuICAgICAgICAgIGgyNjRGcmFtZS5rZXlGcmFtZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaDI2NEZyYW1lLmVuZE5hbFVuaXQoKTtcbiAgICAgIH1cbiAgICAgIGgyNjRGcmFtZS5zdGFydE5hbFVuaXQoKTtcbiAgICAgIGgyNjRGcmFtZS53cml0ZUJ5dGVzKGN1cnJlbnROYWwuZGF0YSk7XG4gICAgfVxuICAgIGlmIChoMjY0RnJhbWUpIHtcbiAgICAgIHRoaXMuZmluaXNoRnJhbWUodGFncywgaDI2NEZyYW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB7dHJhY2s6IHRyYWNrLCB0YWdzOiB0YWdzLmxpc3R9KTtcblxuICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIGZsdXNoIHByb2Nlc3Mgbm93XG4gICAgdGhpcy50cmlnZ2VyKCdkb25lJywgJ1ZpZGVvU2VnbWVudFN0cmVhbScpO1xuICB9O1xufTtcblxuVmlkZW9TZWdtZW50U3RyZWFtLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcblxuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBpbmNyZW1lbnRhbGx5IHRyYW5zbXV4ZXMgTVBFRzIgVHJhc3BvcnQgU3RyZWFtXG4gKiBjaHVua3MgaW50byBhbiBGTFYuXG4gKi9cblRyYW5zbXV4ZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhclxuICAgIHNlbGYgPSB0aGlzLFxuXG4gICAgcGFja2V0U3RyZWFtLCBwYXJzZVN0cmVhbSwgZWxlbWVudGFyeVN0cmVhbSxcbiAgICB2aWRlb1RpbWVzdGFtcFJvbGxvdmVyU3RyZWFtLCBhdWRpb1RpbWVzdGFtcFJvbGxvdmVyU3RyZWFtLFxuICAgIHRpbWVkTWV0YWRhdGFUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSxcbiAgICBhZHRzU3RyZWFtLCBoMjY0U3RyZWFtLFxuICAgIHZpZGVvU2VnbWVudFN0cmVhbSwgYXVkaW9TZWdtZW50U3RyZWFtLCBjYXB0aW9uU3RyZWFtLFxuICAgIGNvYWxlc2NlU3RyZWFtO1xuXG4gIFRyYW5zbXV4ZXIucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBleHBvc2UgdGhlIG1ldGFkYXRhIHN0cmVhbVxuICB0aGlzLm1ldGFkYXRhU3RyZWFtID0gbmV3IG0ydHMuTWV0YWRhdGFTdHJlYW0oKTtcblxuICBvcHRpb25zLm1ldGFkYXRhU3RyZWFtID0gdGhpcy5tZXRhZGF0YVN0cmVhbTtcblxuICAvLyBzZXQgdXAgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgcGFja2V0U3RyZWFtID0gbmV3IG0ydHMuVHJhbnNwb3J0UGFja2V0U3RyZWFtKCk7XG4gIHBhcnNlU3RyZWFtID0gbmV3IG0ydHMuVHJhbnNwb3J0UGFyc2VTdHJlYW0oKTtcbiAgZWxlbWVudGFyeVN0cmVhbSA9IG5ldyBtMnRzLkVsZW1lbnRhcnlTdHJlYW0oKTtcbiAgdmlkZW9UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSA9IG5ldyBtMnRzLlRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtKCd2aWRlbycpO1xuICBhdWRpb1RpbWVzdGFtcFJvbGxvdmVyU3RyZWFtID0gbmV3IG0ydHMuVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0oJ2F1ZGlvJyk7XG4gIHRpbWVkTWV0YWRhdGFUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSA9IG5ldyBtMnRzLlRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtKCd0aW1lZC1tZXRhZGF0YScpO1xuXG4gIGFkdHNTdHJlYW0gPSBuZXcgQWR0c1N0cmVhbSgpO1xuICBoMjY0U3RyZWFtID0gbmV3IEgyNjRTdHJlYW0oKTtcbiAgY29hbGVzY2VTdHJlYW0gPSBuZXcgQ29hbGVzY2VTdHJlYW0ob3B0aW9ucyk7XG5cbiAgLy8gZGlzYXNzZW1ibGUgTVBFRzItVFMgcGFja2V0cyBpbnRvIGVsZW1lbnRhcnkgc3RyZWFtc1xuICBwYWNrZXRTdHJlYW1cbiAgICAucGlwZShwYXJzZVN0cmVhbSlcbiAgICAucGlwZShlbGVtZW50YXJ5U3RyZWFtKTtcblxuICAvLyAhIVRISVMgT1JERVIgSVMgSU1QT1JUQU5UISFcbiAgLy8gZGVtdXggdGhlIHN0cmVhbXNcbiAgZWxlbWVudGFyeVN0cmVhbVxuICAgIC5waXBlKHZpZGVvVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0pXG4gICAgLnBpcGUoaDI2NFN0cmVhbSk7XG4gIGVsZW1lbnRhcnlTdHJlYW1cbiAgICAucGlwZShhdWRpb1RpbWVzdGFtcFJvbGxvdmVyU3RyZWFtKVxuICAgIC5waXBlKGFkdHNTdHJlYW0pO1xuXG4gIGVsZW1lbnRhcnlTdHJlYW1cbiAgICAucGlwZSh0aW1lZE1ldGFkYXRhVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0pXG4gICAgLnBpcGUodGhpcy5tZXRhZGF0YVN0cmVhbSlcbiAgICAucGlwZShjb2FsZXNjZVN0cmVhbSk7XG4gIC8vIGlmIENFQS03MDggcGFyc2luZyBpcyBhdmFpbGFibGUsIGhvb2sgdXAgYSBjYXB0aW9uIHN0cmVhbVxuICBjYXB0aW9uU3RyZWFtID0gbmV3IG0ydHMuQ2FwdGlvblN0cmVhbSgpO1xuICBoMjY0U3RyZWFtLnBpcGUoY2FwdGlvblN0cmVhbSlcbiAgICAucGlwZShjb2FsZXNjZVN0cmVhbSk7XG5cbiAgLy8gaG9vayB1cCB0aGUgc2VnbWVudCBzdHJlYW1zIG9uY2UgdHJhY2sgbWV0YWRhdGEgaXMgZGVsaXZlcmVkXG4gIGVsZW1lbnRhcnlTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGksIHZpZGVvVHJhY2ssIGF1ZGlvVHJhY2s7XG5cbiAgICBpZiAoZGF0YS50eXBlID09PSAnbWV0YWRhdGEnKSB7XG4gICAgICBpID0gZGF0YS50cmFja3MubGVuZ3RoO1xuXG4gICAgICAvLyBzY2FuIHRoZSB0cmFja3MgbGlzdGVkIGluIHRoZSBtZXRhZGF0YVxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoZGF0YS50cmFja3NbaV0udHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgIHZpZGVvVHJhY2sgPSBkYXRhLnRyYWNrc1tpXTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLnRyYWNrc1tpXS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgYXVkaW9UcmFjayA9IGRhdGEudHJhY2tzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGhvb2sgdXAgdGhlIHZpZGVvIHNlZ21lbnQgc3RyZWFtIHRvIHRoZSBmaXJzdCB0cmFjayB3aXRoIGgyNjQgZGF0YVxuICAgICAgaWYgKHZpZGVvVHJhY2sgJiYgIXZpZGVvU2VnbWVudFN0cmVhbSkge1xuICAgICAgICBjb2FsZXNjZVN0cmVhbS5udW1iZXJPZlRyYWNrcysrO1xuICAgICAgICB2aWRlb1NlZ21lbnRTdHJlYW0gPSBuZXcgVmlkZW9TZWdtZW50U3RyZWFtKHZpZGVvVHJhY2spO1xuXG4gICAgICAgIC8vIFNldCB1cCB0aGUgZmluYWwgcGFydCBvZiB0aGUgdmlkZW8gcGlwZWxpbmVcbiAgICAgICAgaDI2NFN0cmVhbVxuICAgICAgICAgIC5waXBlKHZpZGVvU2VnbWVudFN0cmVhbSlcbiAgICAgICAgICAucGlwZShjb2FsZXNjZVN0cmVhbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdWRpb1RyYWNrICYmICFhdWRpb1NlZ21lbnRTdHJlYW0pIHtcbiAgICAgICAgLy8gaG9vayB1cCB0aGUgYXVkaW8gc2VnbWVudCBzdHJlYW0gdG8gdGhlIGZpcnN0IHRyYWNrIHdpdGggYWFjIGRhdGFcbiAgICAgICAgY29hbGVzY2VTdHJlYW0ubnVtYmVyT2ZUcmFja3MrKztcbiAgICAgICAgYXVkaW9TZWdtZW50U3RyZWFtID0gbmV3IEF1ZGlvU2VnbWVudFN0cmVhbShhdWRpb1RyYWNrKTtcblxuICAgICAgICAvLyBTZXQgdXAgdGhlIGZpbmFsIHBhcnQgb2YgdGhlIGF1ZGlvIHBpcGVsaW5lXG4gICAgICAgIGFkdHNTdHJlYW1cbiAgICAgICAgICAucGlwZShhdWRpb1NlZ21lbnRTdHJlYW0pXG4gICAgICAgICAgLnBpcGUoY29hbGVzY2VTdHJlYW0pO1xuXG4gICAgICAgIGlmICh2aWRlb1NlZ21lbnRTdHJlYW0pIHtcbiAgICAgICAgICB2aWRlb1NlZ21lbnRTdHJlYW0ub24oJ2tleWZyYW1lJywgYXVkaW9TZWdtZW50U3RyZWFtLm9uVmlkZW9LZXlGcmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHBhY2tldFN0cmVhbS5wdXNoKGRhdGEpO1xuICB9O1xuXG4gIC8vIGZsdXNoIGFueSBidWZmZXJlZCBkYXRhXG4gIHRoaXMuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAvLyBTdGFydCBhdCB0aGUgdG9wIG9mIHRoZSBwaXBlbGluZSBhbmQgZmx1c2ggYWxsIHBlbmRpbmcgd29ya1xuICAgIHBhY2tldFN0cmVhbS5mbHVzaCgpO1xuICB9O1xuXG4gIC8vIENhcHRpb24gZGF0YSBoYXMgdG8gYmUgcmVzZXQgd2hlbiBzZWVraW5nIG91dHNpZGUgYnVmZmVyZWQgcmFuZ2VcbiAgdGhpcy5yZXNldENhcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgY2FwdGlvblN0cmVhbS5yZXNldCgpO1xuICB9O1xuXG4gIC8vIFJlLWVtaXQgYW55IGRhdGEgY29taW5nIGZyb20gdGhlIGNvYWxlc2NlIHN0cmVhbSB0byB0aGUgb3V0c2lkZSB3b3JsZFxuICBjb2FsZXNjZVN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgc2VsZi50cmlnZ2VyKCdkYXRhJywgZXZlbnQpO1xuICB9KTtcblxuICAvLyBMZXQgdGhlIGNvbnN1bWVyIGtub3cgd2UgaGF2ZSBmaW5pc2hlZCBmbHVzaGluZyB0aGUgZW50aXJlIHBpcGVsaW5lXG4gIGNvYWxlc2NlU3RyZWFtLm9uKCdkb25lJywgZnVuY3Rpb24oKSB7XG4gICAgc2VsZi50cmlnZ2VyKCdkb25lJyk7XG4gIH0pO1xufTtcblRyYW5zbXV4ZXIucHJvdG90eXBlID0gbmV3IFN0cmVhbSgpO1xuXG4vLyBmb3J3YXJkIGNvbXBhdGliaWxpdHlcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNtdXhlcjtcblxufSx7XCIuLi9jb2RlY3MvYWR0cy5qc1wiOjQwLFwiLi4vY29kZWNzL2gyNjRcIjo0MSxcIi4uL20ydHMvbTJ0cy5qc1wiOjUwLFwiLi4vdXRpbHMvc3RyZWFtLmpzXCI6NjIsXCIuL2NvYWxlc2NlLXN0cmVhbS5qc1wiOjQzLFwiLi9mbHYtdGFnLmpzXCI6NDUsXCIuL3RhZy1saXN0LmpzXCI6NDd9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIG11eC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBCcmlnaHRjb3ZlXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlYWRzIGluLWJhbmQgY2FwdGlvbiBpbmZvcm1hdGlvbiBmcm9tIGEgdmlkZW8gZWxlbWVudGFyeVxuICogc3RyZWFtLiBDYXB0aW9ucyBtdXN0IGZvbGxvdyB0aGUgQ0VBLTcwOCBzdGFuZGFyZCBmb3IgaW5qZWN0aW9uXG4gKiBpbnRvIGFuIE1QRUctMiB0cmFuc3BvcnQgc3RyZWFtcy5cbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ0VBLTcwOFxuICogQHNlZSBodHRwczovL3d3dy5ncG8uZ292L2Zkc3lzL3BrZy9DRlItMjAwNy10aXRsZTQ3LXZvbDEvcGRmL0NGUi0yMDA3LXRpdGxlNDctdm9sMS1zZWMxNS0xMTkucGRmXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGluayBUbyBUcmFuc3BvcnRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFN1cHBsZW1lbnRhbCBlbmhhbmNlbWVudCBpbmZvcm1hdGlvbiAoU0VJKSBOQUwgdW5pdHMgaGF2ZSBhXG4vLyBwYXlsb2FkIHR5cGUgZmllbGQgdG8gaW5kaWNhdGUgaG93IHRoZXkgYXJlIHRvIGJlXG4vLyBpbnRlcnByZXRlZC4gQ0VBUy03MDggY2FwdGlvbiBjb250ZW50IGlzIGFsd2F5cyB0cmFuc21pdHRlZCB3aXRoXG4vLyBwYXlsb2FkIHR5cGUgMHgwNC5cbnZhciBVU0VSX0RBVEFfUkVHSVNURVJFRF9JVFVfVF9UMzUgPSA0LFxuICAgIFJCU1BfVFJBSUxJTkdfQklUUyA9IDEyOCxcbiAgICBTdHJlYW0gPSByZXF1aXJlKCcuLi91dGlscy9zdHJlYW0nKTtcblxuLyoqXG4gICogUGFyc2UgYSBzdXBwbGVtZW50YWwgZW5oYW5jZW1lbnQgaW5mb3JtYXRpb24gKFNFSSkgTkFMIHVuaXQuXG4gICogU3RvcHMgcGFyc2luZyBvbmNlIGEgbWVzc2FnZSBvZiB0eXBlIElUVSBUIFQzNSBoYXMgYmVlbiBmb3VuZC5cbiAgKlxuICAqIEBwYXJhbSBieXRlcyB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIGEgU0VJIE5BTCB1bml0XG4gICogQHJldHVybiB7b2JqZWN0fSB0aGUgcGFyc2VkIFNFSSBwYXlsb2FkXG4gICogQHNlZSBSZWMuIElUVS1UIEguMjY0LCA3LjMuMi4zLjFcbiAgKi9cbnZhciBwYXJzZVNlaSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHZhclxuICAgIGkgPSAwLFxuICAgIHJlc3VsdCA9IHtcbiAgICAgIHBheWxvYWRUeXBlOiAtMSxcbiAgICAgIHBheWxvYWRTaXplOiAwXG4gICAgfSxcbiAgICBwYXlsb2FkVHlwZSA9IDAsXG4gICAgcGF5bG9hZFNpemUgPSAwO1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIHNlaV9yYnNwIHBhcnNpbmcgZWFjaCBlYWNoIGluZGl2aWR1YWwgc2VpX21lc3NhZ2VcbiAgd2hpbGUgKGkgPCBieXRlcy5ieXRlTGVuZ3RoKSB7XG4gICAgLy8gc3RvcCBvbmNlIHdlIGhhdmUgaGl0IHRoZSBlbmQgb2YgdGhlIHNlaV9yYnNwXG4gICAgaWYgKGJ5dGVzW2ldID09PSBSQlNQX1RSQUlMSU5HX0JJVFMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHBheWxvYWQgdHlwZVxuICAgIHdoaWxlIChieXRlc1tpXSA9PT0gMHhGRikge1xuICAgICAgcGF5bG9hZFR5cGUgKz0gMjU1O1xuICAgICAgaSsrO1xuICAgIH1cbiAgICBwYXlsb2FkVHlwZSArPSBieXRlc1tpKytdO1xuXG4gICAgLy8gUGFyc2UgcGF5bG9hZCBzaXplXG4gICAgd2hpbGUgKGJ5dGVzW2ldID09PSAweEZGKSB7XG4gICAgICBwYXlsb2FkU2l6ZSArPSAyNTU7XG4gICAgICBpKys7XG4gICAgfVxuICAgIHBheWxvYWRTaXplICs9IGJ5dGVzW2krK107XG5cbiAgICAvLyB0aGlzIHNlaV9tZXNzYWdlIGlzIGEgNjA4LzcwOCBjYXB0aW9uIHNvIHNhdmUgaXQgYW5kIGJyZWFrXG4gICAgLy8gdGhlcmUgY2FuIG9ubHkgZXZlciBiZSBvbmUgY2FwdGlvbiBtZXNzYWdlIGluIGEgZnJhbWUncyBzZWlcbiAgICBpZiAoIXJlc3VsdC5wYXlsb2FkICYmIHBheWxvYWRUeXBlID09PSBVU0VSX0RBVEFfUkVHSVNURVJFRF9JVFVfVF9UMzUpIHtcbiAgICAgIHJlc3VsdC5wYXlsb2FkVHlwZSA9IHBheWxvYWRUeXBlO1xuICAgICAgcmVzdWx0LnBheWxvYWRTaXplID0gcGF5bG9hZFNpemU7XG4gICAgICByZXN1bHQucGF5bG9hZCA9IGJ5dGVzLnN1YmFycmF5KGksIGkgKyBwYXlsb2FkU2l6ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBza2lwIHRoZSBwYXlsb2FkIGFuZCBwYXJzZSB0aGUgbmV4dCBtZXNzYWdlXG4gICAgaSArPSBwYXlsb2FkU2l6ZTtcbiAgICBwYXlsb2FkVHlwZSA9IDA7XG4gICAgcGF5bG9hZFNpemUgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIHNlZSBBTlNJL1NDVEUgMTI4LTEgKDIwMTMpLCBzZWN0aW9uIDguMVxudmFyIHBhcnNlVXNlckRhdGEgPSBmdW5jdGlvbihzZWkpIHtcbiAgLy8gaXR1X3RfdDM1X2NvbnRyeV9jb2RlIG11c3QgYmUgMTgxIChVbml0ZWQgU3RhdGVzKSBmb3JcbiAgLy8gY2FwdGlvbnNcbiAgaWYgKHNlaS5wYXlsb2FkWzBdICE9PSAxODEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGl0dV90X3QzNV9wcm92aWRlcl9jb2RlIHNob3VsZCBiZSA0OSAoQVRTQykgZm9yIGNhcHRpb25zXG4gIGlmICgoKHNlaS5wYXlsb2FkWzFdIDw8IDgpIHwgc2VpLnBheWxvYWRbMl0pICE9PSA0OSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gdGhlIHVzZXJfaWRlbnRpZmllciBzaG91bGQgYmUgXCJHQTk0XCIgdG8gaW5kaWNhdGUgQVRTQzEgZGF0YVxuICBpZiAoU3RyaW5nLmZyb21DaGFyQ29kZShzZWkucGF5bG9hZFszXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VpLnBheWxvYWRbNF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlaS5wYXlsb2FkWzVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzZWkucGF5bG9hZFs2XSkgIT09ICdHQTk0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gZmluYWxseSwgdXNlcl9kYXRhX3R5cGVfY29kZSBzaG91bGQgYmUgMHgwMyBmb3IgY2FwdGlvbiBkYXRhXG4gIGlmIChzZWkucGF5bG9hZFs3XSAhPT0gMHgwMykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gcmV0dXJuIHRoZSB1c2VyX2RhdGFfdHlwZV9zdHJ1Y3R1cmUgYW5kIHN0cmlwIHRoZSB0cmFpbGluZ1xuICAvLyBtYXJrZXIgYml0c1xuICByZXR1cm4gc2VpLnBheWxvYWQuc3ViYXJyYXkoOCwgc2VpLnBheWxvYWQubGVuZ3RoIC0gMSk7XG59O1xuXG4vLyBzZWUgQ0VBLTcwOC1ELCBzZWN0aW9uIDQuNFxudmFyIHBhcnNlQ2FwdGlvblBhY2tldHMgPSBmdW5jdGlvbihwdHMsIHVzZXJEYXRhKSB7XG4gIHZhciByZXN1bHRzID0gW10sIGksIGNvdW50LCBvZmZzZXQsIGRhdGE7XG5cbiAgLy8gaWYgdGhpcyBpcyBqdXN0IGZpbGxlciwgcmV0dXJuIGltbWVkaWF0ZWx5XG4gIGlmICghKHVzZXJEYXRhWzBdICYgMHg0MCkpIHtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8vIHBhcnNlIG91dCB0aGUgY2NfZGF0YV8xIGFuZCBjY19kYXRhXzIgZmllbGRzXG4gIGNvdW50ID0gdXNlckRhdGFbMF0gJiAweDFmO1xuICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIG9mZnNldCA9IGkgKiAzO1xuICAgIGRhdGEgPSB7XG4gICAgICB0eXBlOiB1c2VyRGF0YVtvZmZzZXQgKyAyXSAmIDB4MDMsXG4gICAgICBwdHM6IHB0c1xuICAgIH07XG5cbiAgICAvLyBjYXB0dXJlIGNjIGRhdGEgd2hlbiBjY192YWxpZCBpcyAxXG4gICAgaWYgKHVzZXJEYXRhW29mZnNldCArIDJdICYgMHgwNCkge1xuICAgICAgZGF0YS5jY0RhdGEgPSAodXNlckRhdGFbb2Zmc2V0ICsgM10gPDwgOCkgfCB1c2VyRGF0YVtvZmZzZXQgKyA0XTtcbiAgICAgIHJlc3VsdHMucHVzaChkYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG52YXIgQ2FwdGlvblN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuXG4gIENhcHRpb25TdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLmNhcHRpb25QYWNrZXRzXyA9IFtdO1xuXG4gIHRoaXMuY2NTdHJlYW1zXyA9IFtcbiAgICBuZXcgQ2VhNjA4U3RyZWFtKDAsIDApLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgbmV3IENlYTYwOFN0cmVhbSgwLCAxKSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuICAgIG5ldyBDZWE2MDhTdHJlYW0oMSwgMCksIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICBuZXcgQ2VhNjA4U3RyZWFtKDEsIDEpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgXTtcblxuICB0aGlzLnJlc2V0KCk7XG5cbiAgLy8gZm9yd2FyZCBkYXRhIGFuZCBkb25lIGV2ZW50cyBmcm9tIENDcyB0byB0aGlzIENhcHRpb25TdHJlYW1cbiAgdGhpcy5jY1N0cmVhbXNfLmZvckVhY2goZnVuY3Rpb24oY2MpIHtcbiAgICBjYy5vbignZGF0YScsIHRoaXMudHJpZ2dlci5iaW5kKHRoaXMsICdkYXRhJykpO1xuICAgIGNjLm9uKCdkb25lJywgdGhpcy50cmlnZ2VyLmJpbmQodGhpcywgJ2RvbmUnKSk7XG4gIH0sIHRoaXMpO1xuXG59O1xuXG5DYXB0aW9uU3RyZWFtLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcbkNhcHRpb25TdHJlYW0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihldmVudCkge1xuICB2YXIgc2VpLCB1c2VyRGF0YTtcblxuICAvLyBvbmx5IGV4YW1pbmUgU0VJIE5BTHNcbiAgaWYgKGV2ZW50Lm5hbFVuaXRUeXBlICE9PSAnc2VpX3Jic3AnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gcGFyc2UgdGhlIHNlaVxuICBzZWkgPSBwYXJzZVNlaShldmVudC5lc2NhcGVkUkJTUCk7XG5cbiAgLy8gaWdub3JlIGV2ZXJ5dGhpbmcgYnV0IHVzZXJfZGF0YV9yZWdpc3RlcmVkX2l0dV90X3QzNVxuICBpZiAoc2VpLnBheWxvYWRUeXBlICE9PSBVU0VSX0RBVEFfUkVHSVNURVJFRF9JVFVfVF9UMzUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBwYXJzZSBvdXQgdGhlIHVzZXIgZGF0YSBwYXlsb2FkXG4gIHVzZXJEYXRhID0gcGFyc2VVc2VyRGF0YShzZWkpO1xuXG4gIC8vIGlnbm9yZSB1bnJlY29nbml6ZWQgdXNlckRhdGFcbiAgaWYgKCF1c2VyRGF0YSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFNvbWV0aW1lcywgdGhlIHNhbWUgc2VnbWVudCAjIHdpbGwgYmUgZG93bmxvYWRlZCB0d2ljZS4gVG8gc3RvcCB0aGVcbiAgLy8gY2FwdGlvbiBkYXRhIGZyb20gYmVpbmcgcHJvY2Vzc2VkIHR3aWNlLCB3ZSB0cmFjayB0aGUgbGF0ZXN0IGR0cyB3ZSd2ZVxuICAvLyByZWNlaXZlZCBhbmQgaWdub3JlIGV2ZXJ5dGhpbmcgd2l0aCBhIGR0cyBiZWZvcmUgdGhhdC4gSG93ZXZlciwgc2luY2VcbiAgLy8gZGF0YSBmb3IgYSBzcGVjaWZpYyBkdHMgY2FuIGJlIHNwbGl0IGFjcm9zcyAyIHBhY2tldHMgb24gZWl0aGVyIHNpZGUgb2ZcbiAgLy8gYSBzZWdtZW50IGJvdW5kYXJ5LCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSAqZG9uJ3QqIGlnbm9yZSB0aGUgc2Vjb25kXG4gIC8vIGR0cyBwYWNrZXQgd2UgcmVjZWl2ZSB0aGF0IGhhcyBkdHMgPT09IHRoaXMubGF0ZXN0RHRzXy4gQW5kIHRodXMsIHRoZVxuICAvLyBpZ25vcmVOZXh0RXF1YWxEdHNfIGZsYWcgd2FzIGJvcm4uXG4gIGlmIChldmVudC5kdHMgPCB0aGlzLmxhdGVzdER0c18pIHtcbiAgICAvLyBXZSd2ZSBzdGFydGVkIGdldHRpbmcgb2xkZXIgZGF0YSwgc28gc2V0IHRoZSBmbGFnLlxuICAgIHRoaXMuaWdub3JlTmV4dEVxdWFsRHRzXyA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKChldmVudC5kdHMgPT09IHRoaXMubGF0ZXN0RHRzXykgJiYgKHRoaXMuaWdub3JlTmV4dEVxdWFsRHRzXykpIHtcbiAgICAvLyBXZSd2ZSByZWNlaXZlZCB0aGUgbGFzdCBkdXBsaWNhdGUgcGFja2V0LCB0aW1lIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYWdhaW5cbiAgICB0aGlzLmlnbm9yZU5leHRFcXVhbER0c18gPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBwYXJzZSBvdXQgQ0MgZGF0YSBwYWNrZXRzIGFuZCBzYXZlIHRoZW0gZm9yIGxhdGVyXG4gIHRoaXMuY2FwdGlvblBhY2tldHNfID0gdGhpcy5jYXB0aW9uUGFja2V0c18uY29uY2F0KHBhcnNlQ2FwdGlvblBhY2tldHMoZXZlbnQucHRzLCB1c2VyRGF0YSkpO1xuICB0aGlzLmxhdGVzdER0c18gPSBldmVudC5kdHM7XG59O1xuXG5DYXB0aW9uU3RyZWFtLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAvLyBtYWtlIHN1cmUgd2UgYWN0dWFsbHkgcGFyc2VkIGNhcHRpb25zIGJlZm9yZSBwcm9jZWVkaW5nXG4gIGlmICghdGhpcy5jYXB0aW9uUGFja2V0c18ubGVuZ3RoKSB7XG4gICAgdGhpcy5jY1N0cmVhbXNfLmZvckVhY2goZnVuY3Rpb24oY2MpIHtcbiAgICAgIGNjLmZsdXNoKCk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSW4gQ2hyb21lLCB0aGUgQXJyYXkjc29ydCBmdW5jdGlvbiBpcyBub3Qgc3RhYmxlIHNvIGFkZCBhXG4gIC8vIHByZXNvcnRJbmRleCB0aGF0IHdlIGNhbiB1c2UgdG8gZW5zdXJlIHdlIGdldCBhIHN0YWJsZS1zb3J0XG4gIHRoaXMuY2FwdGlvblBhY2tldHNfLmZvckVhY2goZnVuY3Rpb24oZWxlbSwgaWR4KSB7XG4gICAgZWxlbS5wcmVzb3J0SW5kZXggPSBpZHg7XG4gIH0pO1xuXG4gIC8vIHNvcnQgY2FwdGlvbiBieXRlLXBhaXJzIGJhc2VkIG9uIHRoZWlyIFBUUyB2YWx1ZXNcbiAgdGhpcy5jYXB0aW9uUGFja2V0c18uc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEucHRzID09PSBiLnB0cykge1xuICAgICAgcmV0dXJuIGEucHJlc29ydEluZGV4IC0gYi5wcmVzb3J0SW5kZXg7XG4gICAgfVxuICAgIHJldHVybiBhLnB0cyAtIGIucHRzO1xuICB9KTtcblxuICB0aGlzLmNhcHRpb25QYWNrZXRzXy5mb3JFYWNoKGZ1bmN0aW9uKHBhY2tldCkge1xuICAgIGlmIChwYWNrZXQudHlwZSA8IDIpIHtcbiAgICAgIC8vIERpc3BhdGNoIHBhY2tldCB0byB0aGUgcmlnaHQgQ2VhNjA4U3RyZWFtXG4gICAgICB0aGlzLmRpc3BhdGNoQ2VhNjA4UGFja2V0KHBhY2tldCk7XG4gICAgfVxuICAgIC8vIHRoaXMgaXMgd2hlcmUgYW4gJ2Vsc2UnIHdvdWxkIGdvIGZvciBhIGRpc3BhdGNoaW5nIHBhY2tldHNcbiAgICAvLyB0byBhIHRoZW9yZXRpY2FsIENlYTcwOFN0cmVhbSB0aGF0IGhhbmRsZXMgU0VSVklDRW4gZGF0YVxuICB9LCB0aGlzKTtcblxuICB0aGlzLmNhcHRpb25QYWNrZXRzXy5sZW5ndGggPSAwO1xuICB0aGlzLmNjU3RyZWFtc18uZm9yRWFjaChmdW5jdGlvbihjYykge1xuICAgIGNjLmZsdXNoKCk7XG4gIH0sIHRoaXMpO1xuICByZXR1cm47XG59O1xuXG5DYXB0aW9uU3RyZWFtLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxhdGVzdER0c18gPSBudWxsO1xuICB0aGlzLmlnbm9yZU5leHRFcXVhbER0c18gPSBmYWxzZTtcbiAgdGhpcy5hY3RpdmVDZWE2MDhDaGFubmVsXyA9IFtudWxsLCBudWxsXTtcbiAgdGhpcy5jY1N0cmVhbXNfLmZvckVhY2goZnVuY3Rpb24oY2NTdHJlYW0pIHtcbiAgICBjY1N0cmVhbS5yZXNldCgpO1xuICB9KTtcbn07XG5cbkNhcHRpb25TdHJlYW0ucHJvdG90eXBlLmRpc3BhdGNoQ2VhNjA4UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIC8vIE5PVEU6IHBhY2tldC50eXBlIGlzIHRoZSBDRUE2MDggZmllbGRcbiAgaWYgKHRoaXMuc2V0c0NoYW5uZWwxQWN0aXZlKHBhY2tldCkpIHtcbiAgICB0aGlzLmFjdGl2ZUNlYTYwOENoYW5uZWxfW3BhY2tldC50eXBlXSA9IDA7XG4gIH0gZWxzZSBpZiAodGhpcy5zZXRzQ2hhbm5lbDJBY3RpdmUocGFja2V0KSkge1xuICAgIHRoaXMuYWN0aXZlQ2VhNjA4Q2hhbm5lbF9bcGFja2V0LnR5cGVdID0gMTtcbiAgfVxuICBpZiAodGhpcy5hY3RpdmVDZWE2MDhDaGFubmVsX1twYWNrZXQudHlwZV0gPT09IG51bGwpIHtcbiAgICAvLyBJZiB3ZSBoYXZlbid0IHJlY2VpdmVkIGFueXRoaW5nIHRvIHNldCB0aGUgYWN0aXZlIGNoYW5uZWwsIGRpc2NhcmQgdGhlXG4gICAgLy8gZGF0YTsgd2UgZG9uJ3Qgd2FudCBqdW1ibGVkIGNhcHRpb25zXG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuY2NTdHJlYW1zX1socGFja2V0LnR5cGUgPDwgMSkgKyB0aGlzLmFjdGl2ZUNlYTYwOENoYW5uZWxfW3BhY2tldC50eXBlXV0ucHVzaChwYWNrZXQpO1xufTtcblxuQ2FwdGlvblN0cmVhbS5wcm90b3R5cGUuc2V0c0NoYW5uZWwxQWN0aXZlID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHJldHVybiAoKHBhY2tldC5jY0RhdGEgJiAweDc4MDApID09PSAweDEwMDApO1xufTtcbkNhcHRpb25TdHJlYW0ucHJvdG90eXBlLnNldHNDaGFubmVsMkFjdGl2ZSA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICByZXR1cm4gKChwYWNrZXQuY2NEYXRhICYgMHg3ODAwKSA9PT0gMHgxODAwKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNlc3Npb24gdG8gQXBwbGljYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIENIQVJBQ1RFUl9UUkFOU0xBVElPTiA9IHtcbiAgMHgyYTogMHhlMSwgICAgIC8vIMOhXG4gIDB4NWM6IDB4ZTksICAgICAvLyDDqVxuICAweDVlOiAweGVkLCAgICAgLy8gw61cbiAgMHg1ZjogMHhmMywgICAgIC8vIMOzXG4gIDB4NjA6IDB4ZmEsICAgICAvLyDDulxuICAweDdiOiAweGU3LCAgICAgLy8gw6dcbiAgMHg3YzogMHhmNywgICAgIC8vIMO3XG4gIDB4N2Q6IDB4ZDEsICAgICAvLyDDkVxuICAweDdlOiAweGYxLCAgICAgLy8gw7FcbiAgMHg3ZjogMHgyNTg4LCAgIC8vIOKWiFxuICAweDAxMzA6IDB4YWUsICAgLy8gwq5cbiAgMHgwMTMxOiAweGIwLCAgIC8vIMKwXG4gIDB4MDEzMjogMHhiZCwgICAvLyDCvVxuICAweDAxMzM6IDB4YmYsICAgLy8gwr9cbiAgMHgwMTM0OiAweDIxMjIsIC8vIOKEolxuICAweDAxMzU6IDB4YTIsICAgLy8gwqJcbiAgMHgwMTM2OiAweGEzLCAgIC8vIMKjXG4gIDB4MDEzNzogMHgyNjZhLCAvLyDimapcbiAgMHgwMTM4OiAweGUwLCAgIC8vIMOgXG4gIDB4MDEzOTogMHhhMCwgICAvL1xuICAweDAxM2E6IDB4ZTgsICAgLy8gw6hcbiAgMHgwMTNiOiAweGUyLCAgIC8vIMOiXG4gIDB4MDEzYzogMHhlYSwgICAvLyDDqlxuICAweDAxM2Q6IDB4ZWUsICAgLy8gw65cbiAgMHgwMTNlOiAweGY0LCAgIC8vIMO0XG4gIDB4MDEzZjogMHhmYiwgICAvLyDDu1xuICAweDAyMjA6IDB4YzEsICAgLy8gw4FcbiAgMHgwMjIxOiAweGM5LCAgIC8vIMOJXG4gIDB4MDIyMjogMHhkMywgICAvLyDDk1xuICAweDAyMjM6IDB4ZGEsICAgLy8gw5pcbiAgMHgwMjI0OiAweGRjLCAgIC8vIMOcXG4gIDB4MDIyNTogMHhmYywgICAvLyDDvFxuICAweDAyMjY6IDB4MjAxOCwgLy8g4oCYXG4gIDB4MDIyNzogMHhhMSwgICAvLyDCoVxuICAweDAyMjg6IDB4MmEsICAgLy8gKlxuICAweDAyMjk6IDB4MjcsICAgLy8gJ1xuICAweDAyMmE6IDB4MjAxNCwgLy8g4oCUXG4gIDB4MDIyYjogMHhhOSwgICAvLyDCqVxuICAweDAyMmM6IDB4MjEyMCwgLy8g4oSgXG4gIDB4MDIyZDogMHgyMDIyLCAvLyDigKJcbiAgMHgwMjJlOiAweDIwMWMsIC8vIOKAnFxuICAweDAyMmY6IDB4MjAxZCwgLy8g4oCdXG4gIDB4MDIzMDogMHhjMCwgICAvLyDDgFxuICAweDAyMzE6IDB4YzIsICAgLy8gw4JcbiAgMHgwMjMyOiAweGM3LCAgIC8vIMOHXG4gIDB4MDIzMzogMHhjOCwgICAvLyDDiFxuICAweDAyMzQ6IDB4Y2EsICAgLy8gw4pcbiAgMHgwMjM1OiAweGNiLCAgIC8vIMOLXG4gIDB4MDIzNjogMHhlYiwgICAvLyDDq1xuICAweDAyMzc6IDB4Y2UsICAgLy8gw45cbiAgMHgwMjM4OiAweGNmLCAgIC8vIMOPXG4gIDB4MDIzOTogMHhlZiwgICAvLyDDr1xuICAweDAyM2E6IDB4ZDQsICAgLy8gw5RcbiAgMHgwMjNiOiAweGQ5LCAgIC8vIMOZXG4gIDB4MDIzYzogMHhmOSwgICAvLyDDuVxuICAweDAyM2Q6IDB4ZGIsICAgLy8gw5tcbiAgMHgwMjNlOiAweGFiLCAgIC8vIMKrXG4gIDB4MDIzZjogMHhiYiwgICAvLyDCu1xuICAweDAzMjA6IDB4YzMsICAgLy8gw4NcbiAgMHgwMzIxOiAweGUzLCAgIC8vIMOjXG4gIDB4MDMyMjogMHhjZCwgICAvLyDDjVxuICAweDAzMjM6IDB4Y2MsICAgLy8gw4xcbiAgMHgwMzI0OiAweGVjLCAgIC8vIMOsXG4gIDB4MDMyNTogMHhkMiwgICAvLyDDklxuICAweDAzMjY6IDB4ZjIsICAgLy8gw7JcbiAgMHgwMzI3OiAweGQ1LCAgIC8vIMOVXG4gIDB4MDMyODogMHhmNSwgICAvLyDDtVxuICAweDAzMjk6IDB4N2IsICAgLy8ge1xuICAweDAzMmE6IDB4N2QsICAgLy8gfVxuICAweDAzMmI6IDB4NWMsICAgLy8gXFxcbiAgMHgwMzJjOiAweDVlLCAgIC8vIF5cbiAgMHgwMzJkOiAweDVmLCAgIC8vIF9cbiAgMHgwMzJlOiAweDdjLCAgIC8vIHxcbiAgMHgwMzJmOiAweDdlLCAgIC8vIH5cbiAgMHgwMzMwOiAweGM0LCAgIC8vIMOEXG4gIDB4MDMzMTogMHhlNCwgICAvLyDDpFxuICAweDAzMzI6IDB4ZDYsICAgLy8gw5ZcbiAgMHgwMzMzOiAweGY2LCAgIC8vIMO2XG4gIDB4MDMzNDogMHhkZiwgICAvLyDDn1xuICAweDAzMzU6IDB4YTUsICAgLy8gwqVcbiAgMHgwMzM2OiAweGE0LCAgIC8vIMKkXG4gIDB4MDMzNzogMHgyNTAyLCAvLyDilIJcbiAgMHgwMzM4OiAweGM1LCAgIC8vIMOFXG4gIDB4MDMzOTogMHhlNSwgICAvLyDDpVxuICAweDAzM2E6IDB4ZDgsICAgLy8gw5hcbiAgMHgwMzNiOiAweGY4LCAgIC8vIMO4XG4gIDB4MDMzYzogMHgyNTBjLCAvLyDilIxcbiAgMHgwMzNkOiAweDI1MTAsIC8vIOKUkFxuICAweDAzM2U6IDB4MjUxNCwgLy8g4pSUXG4gIDB4MDMzZjogMHgyNTE4ICAvLyDilJhcbn07XG5cbnZhciBnZXRDaGFyRnJvbUNvZGUgPSBmdW5jdGlvbihjb2RlKSB7XG4gIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvZGUgPSBDSEFSQUNURVJfVFJBTlNMQVRJT05bY29kZV0gfHwgY29kZTtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG59O1xuXG4vLyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgcm93IGluIGEgQ0VBLTYwOCBkaXNwbGF5IGJ1ZmZlclxudmFyIEJPVFRPTV9ST1cgPSAxNDtcblxuLy8gVGhpcyBhcnJheSBpcyB1c2VkIGZvciBtYXBwaW5nIFBBQ3MgLT4gcm93ICMsIHNpbmNlIHRoZXJlJ3Mgbm8gd2F5IG9mXG4vLyBnZXR0aW5nIGl0IHRocm91Z2ggYml0IGxvZ2ljLlxudmFyIFJPV1MgPSBbMHgxMTAwLCAweDExMjAsIDB4MTIwMCwgMHgxMjIwLCAweDE1MDAsIDB4MTUyMCwgMHgxNjAwLCAweDE2MjAsXG4gICAgICAgICAgICAweDE3MDAsIDB4MTcyMCwgMHgxMDAwLCAweDEzMDAsIDB4MTMyMCwgMHgxNDAwLCAweDE0MjBdO1xuXG4vLyBDRUEtNjA4IGNhcHRpb25zIGFyZSByZW5kZXJlZCBvbnRvIGEgMzR4MTUgbWF0cml4IG9mIGNoYXJhY3RlclxuLy8gY2VsbHMuIFRoZSBcImJvdHRvbVwiIHJvdyBpcyB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSBvdXRlciBhcnJheS5cbnZhciBjcmVhdGVEaXNwbGF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSBbXSwgaSA9IEJPVFRPTV9ST1cgKyAxO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgQ2VhNjA4U3RyZWFtID0gZnVuY3Rpb24oZmllbGQsIGRhdGFDaGFubmVsKSB7XG4gIENlYTYwOFN0cmVhbS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuZmllbGRfID0gZmllbGQgfHwgMDtcbiAgdGhpcy5kYXRhQ2hhbm5lbF8gPSBkYXRhQ2hhbm5lbCB8fCAwO1xuXG4gIHRoaXMubmFtZV8gPSAnQ0MnICsgKCgodGhpcy5maWVsZF8gPDwgMSkgfCB0aGlzLmRhdGFDaGFubmVsXykgKyAxKTtcblxuICB0aGlzLnNldENvbnN0YW50cygpO1xuICB0aGlzLnJlc2V0KCk7XG5cbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gICAgdmFyIGRhdGEsIHN3YXAsIGNoYXIwLCBjaGFyMSwgdGV4dDtcbiAgICAvLyByZW1vdmUgdGhlIHBhcml0eSBiaXRzXG4gICAgZGF0YSA9IHBhY2tldC5jY0RhdGEgJiAweDdmN2Y7XG5cbiAgICAvLyBpZ25vcmUgZHVwbGljYXRlIGNvbnRyb2wgY29kZXM7IHRoZSBzcGVjIGRlbWFuZHMgdGhleSdyZSBzZW50IHR3aWNlXG4gICAgaWYgKGRhdGEgPT09IHRoaXMubGFzdENvbnRyb2xDb2RlXykge1xuICAgICAgdGhpcy5sYXN0Q29udHJvbENvZGVfID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSBjb250cm9sIGNvZGVzXG4gICAgaWYgKChkYXRhICYgMHhmMDAwKSA9PT0gMHgxMDAwKSB7XG4gICAgICB0aGlzLmxhc3RDb250cm9sQ29kZV8gPSBkYXRhO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAhPT0gdGhpcy5QQURESU5HXykge1xuICAgICAgdGhpcy5sYXN0Q29udHJvbENvZGVfID0gbnVsbDtcbiAgICB9XG5cbiAgICBjaGFyMCA9IGRhdGEgPj4+IDg7XG4gICAgY2hhcjEgPSBkYXRhICYgMHhmZjtcblxuICAgIGlmIChkYXRhID09PSB0aGlzLlBBRERJTkdfKSB7XG4gICAgICByZXR1cm47XG5cbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IHRoaXMuUkVTVU1FX0NBUFRJT05fTE9BRElOR18pIHtcbiAgICAgIHRoaXMubW9kZV8gPSAncG9wT24nO1xuXG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB0aGlzLkVORF9PRl9DQVBUSU9OXykge1xuICAgICAgdGhpcy5jbGVhckZvcm1hdHRpbmcocGFja2V0LnB0cyk7XG4gICAgICAvLyBpZiBhIGNhcHRpb24gd2FzIGJlaW5nIGRpc3BsYXllZCwgaXQncyBnb25lIG5vd1xuICAgICAgdGhpcy5mbHVzaERpc3BsYXllZChwYWNrZXQucHRzKTtcblxuICAgICAgLy8gZmxpcCBtZW1vcnlcbiAgICAgIHN3YXAgPSB0aGlzLmRpc3BsYXllZF87XG4gICAgICB0aGlzLmRpc3BsYXllZF8gPSB0aGlzLm5vbkRpc3BsYXllZF87XG4gICAgICB0aGlzLm5vbkRpc3BsYXllZF8gPSBzd2FwO1xuXG4gICAgICAvLyBzdGFydCBtZWFzdXJpbmcgdGhlIHRpbWUgdG8gZGlzcGxheSB0aGUgY2FwdGlvblxuICAgICAgdGhpcy5zdGFydFB0c18gPSBwYWNrZXQucHRzO1xuXG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB0aGlzLlJPTExfVVBfMl9ST1dTXykge1xuICAgICAgdGhpcy50b3BSb3dfID0gQk9UVE9NX1JPVyAtIDE7XG4gICAgICB0aGlzLm1vZGVfID0gJ3JvbGxVcCc7XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB0aGlzLlJPTExfVVBfM19ST1dTXykge1xuICAgICAgdGhpcy50b3BSb3dfID0gQk9UVE9NX1JPVyAtIDI7XG4gICAgICB0aGlzLm1vZGVfID0gJ3JvbGxVcCc7XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB0aGlzLlJPTExfVVBfNF9ST1dTXykge1xuICAgICAgdGhpcy50b3BSb3dfID0gQk9UVE9NX1JPVyAtIDM7XG4gICAgICB0aGlzLm1vZGVfID0gJ3JvbGxVcCc7XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB0aGlzLkNBUlJJQUdFX1JFVFVSTl8pIHtcbiAgICAgIHRoaXMuY2xlYXJGb3JtYXR0aW5nKHBhY2tldC5wdHMpO1xuICAgICAgdGhpcy5mbHVzaERpc3BsYXllZChwYWNrZXQucHRzKTtcbiAgICAgIHRoaXMuc2hpZnRSb3dzVXBfKCk7XG4gICAgICB0aGlzLnN0YXJ0UHRzXyA9IHBhY2tldC5wdHM7XG5cbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IHRoaXMuQkFDS1NQQUNFXykge1xuICAgICAgaWYgKHRoaXMubW9kZV8gPT09ICdwb3BPbicpIHtcbiAgICAgICAgdGhpcy5ub25EaXNwbGF5ZWRfW0JPVFRPTV9ST1ddID0gdGhpcy5ub25EaXNwbGF5ZWRfW0JPVFRPTV9ST1ddLnNsaWNlKDAsIC0xKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkX1tCT1RUT01fUk9XXSA9IHRoaXMuZGlzcGxheWVkX1tCT1RUT01fUk9XXS5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB0aGlzLkVSQVNFX0RJU1BMQVlFRF9NRU1PUllfKSB7XG4gICAgICB0aGlzLmZsdXNoRGlzcGxheWVkKHBhY2tldC5wdHMpO1xuICAgICAgdGhpcy5kaXNwbGF5ZWRfID0gY3JlYXRlRGlzcGxheUJ1ZmZlcigpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdGhpcy5FUkFTRV9OT05fRElTUExBWUVEX01FTU9SWV8pIHtcbiAgICAgIHRoaXMubm9uRGlzcGxheWVkXyA9IGNyZWF0ZURpc3BsYXlCdWZmZXIoKTtcblxuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdGhpcy5SRVNVTUVfRElSRUNUX0NBUFRJT05JTkdfKSB7XG4gICAgICB0aGlzLm1vZGVfID0gJ3BhaW50T24nO1xuXG4gICAgLy8gQXBwZW5kIHNwZWNpYWwgY2hhcmFjdGVycyB0byBjYXB0aW9uIHRleHRcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTcGVjaWFsQ2hhcmFjdGVyKGNoYXIwLCBjaGFyMSkpIHtcbiAgICAgIC8vIEJpdG1hc2sgY2hhcjAgc28gdGhhdCB3ZSBjYW4gYXBwbHkgY2hhcmFjdGVyIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgLy8gcmVnYXJkbGVzcyBvZiBmaWVsZCBhbmQgZGF0YSBjaGFubmVsLlxuICAgICAgLy8gVGhlbiBieXRlLXNoaWZ0IHRvIHRoZSBsZWZ0IGFuZCBPUiB3aXRoIGNoYXIxIHNvIHdlIGNhbiBwYXNzIHRoZVxuICAgICAgLy8gZW50aXJlIGNoYXJhY3RlciBjb2RlIHRvIGBnZXRDaGFyRnJvbUNvZGVgLlxuICAgICAgY2hhcjAgPSAoY2hhcjAgJiAweDAzKSA8PCA4O1xuICAgICAgdGV4dCA9IGdldENoYXJGcm9tQ29kZShjaGFyMCB8IGNoYXIxKTtcbiAgICAgIHRoaXNbdGhpcy5tb2RlX10ocGFja2V0LnB0cywgdGV4dCk7XG4gICAgICB0aGlzLmNvbHVtbl8rKztcblxuICAgIC8vIEFwcGVuZCBleHRlbmRlZCBjaGFyYWN0ZXJzIHRvIGNhcHRpb24gdGV4dFxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0V4dENoYXJhY3RlcihjaGFyMCwgY2hhcjEpKSB7XG4gICAgICAvLyBFeHRlbmRlZCBjaGFyYWN0ZXJzIGFsd2F5cyBmb2xsb3cgdGhlaXIgXCJub24tZXh0ZW5kZWRcIiBlcXVpdmFsZW50cy5cbiAgICAgIC8vIElFIGlmIGEgXCLDqFwiIGlzIGRlc2lyZWQsIHlvdSdsbCBhbHdheXMgcmVjZWl2ZSBcImXDqFwiOyBub24tY29tcGxpYW50XG4gICAgICAvLyBkZWNvZGVycyBhcmUgc3VwcG9zZWQgdG8gZHJvcCB0aGUgXCLDqFwiLCB3aGlsZSBjb21wbGlhbnQgZGVjb2RlcnNcbiAgICAgIC8vIGJhY2tzcGFjZSB0aGUgXCJlXCIgYW5kIGluc2VydCBcIsOoXCIuXG5cbiAgICAgIC8vIERlbGV0ZSB0aGUgcHJldmlvdXMgY2hhcmFjdGVyXG4gICAgICBpZiAodGhpcy5tb2RlXyA9PT0gJ3BvcE9uJykge1xuICAgICAgICB0aGlzLm5vbkRpc3BsYXllZF9bdGhpcy5yb3dfXSA9IHRoaXMubm9uRGlzcGxheWVkX1t0aGlzLnJvd19dLnNsaWNlKDAsIC0xKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGxheWVkX1tCT1RUT01fUk9XXSA9IHRoaXMuZGlzcGxheWVkX1tCT1RUT01fUk9XXS5zbGljZSgwLCAtMSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJpdG1hc2sgY2hhcjAgc28gdGhhdCB3ZSBjYW4gYXBwbHkgY2hhcmFjdGVyIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgLy8gcmVnYXJkbGVzcyBvZiBmaWVsZCBhbmQgZGF0YSBjaGFubmVsLlxuICAgICAgLy8gVGhlbiBieXRlLXNoaWZ0IHRvIHRoZSBsZWZ0IGFuZCBPUiB3aXRoIGNoYXIxIHNvIHdlIGNhbiBwYXNzIHRoZVxuICAgICAgLy8gZW50aXJlIGNoYXJhY3RlciBjb2RlIHRvIGBnZXRDaGFyRnJvbUNvZGVgLlxuICAgICAgY2hhcjAgPSAoY2hhcjAgJiAweDAzKSA8PCA4O1xuICAgICAgdGV4dCA9IGdldENoYXJGcm9tQ29kZShjaGFyMCB8IGNoYXIxKTtcbiAgICAgIHRoaXNbdGhpcy5tb2RlX10ocGFja2V0LnB0cywgdGV4dCk7XG4gICAgICB0aGlzLmNvbHVtbl8rKztcblxuICAgIC8vIFByb2Nlc3MgbWlkLXJvdyBjb2Rlc1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc01pZFJvd0NvZGUoY2hhcjAsIGNoYXIxKSkge1xuICAgICAgLy8gQXR0cmlidXRlcyBhcmUgbm90IGFkZGl0aXZlLCBzbyBjbGVhciBhbGwgZm9ybWF0dGluZ1xuICAgICAgdGhpcy5jbGVhckZvcm1hdHRpbmcocGFja2V0LnB0cyk7XG5cbiAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgc3RhbmRhcmQsIG1pZC1yb3cgY29kZXNcbiAgICAgIC8vIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIHNwYWNlcywgc28gYWRkIG9uZSBub3dcbiAgICAgIHRoaXNbdGhpcy5tb2RlX10ocGFja2V0LnB0cywgJyAnKTtcbiAgICAgIHRoaXMuY29sdW1uXysrO1xuXG4gICAgICBpZiAoKGNoYXIxICYgMHhlKSA9PT0gMHhlKSB7XG4gICAgICAgIHRoaXMuYWRkRm9ybWF0dGluZyhwYWNrZXQucHRzLCBbJ2knXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoY2hhcjEgJiAweDEpID09PSAweDEpIHtcbiAgICAgICAgdGhpcy5hZGRGb3JtYXR0aW5nKHBhY2tldC5wdHMsIFsndSddKTtcbiAgICAgIH1cblxuICAgIC8vIERldGVjdCBvZmZzZXQgY29udHJvbCBjb2RlcyBhbmQgYWRqdXN0IGN1cnNvclxuICAgIH0gZWxzZSBpZiAodGhpcy5pc09mZnNldENvbnRyb2xDb2RlKGNoYXIwLCBjaGFyMSkpIHtcbiAgICAgIC8vIEN1cnNvciBwb3NpdGlvbiBpcyBzZXQgYnkgaW5kZW50IFBBQyAoc2VlIGJlbG93KSBpbiA0LWNvbHVtblxuICAgICAgLy8gaW5jcmVtZW50cywgd2l0aCBhbiBhZGRpdGlvbmFsIG9mZnNldCBjb2RlIG9mIDEtMyB0byByZWFjaCBhbnlcbiAgICAgIC8vIG9mIHRoZSAzMiBjb2x1bW5zIHNwZWNpZmllZCBieSBDRUEtNjA4LiBTbyBhbGwgd2UgbmVlZCB0byBkb1xuICAgICAgLy8gaGVyZSBpcyBpbmNyZW1lbnQgdGhlIGNvbHVtbiBjdXJzb3IgYnkgdGhlIGdpdmVuIG9mZnNldC5cbiAgICAgIHRoaXMuY29sdW1uXyArPSAoY2hhcjEgJiAweDAzKTtcblxuICAgIC8vIERldGVjdCBQQUNzIChQcmVhbWJsZSBBZGRyZXNzIENvZGVzKVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc1BBQyhjaGFyMCwgY2hhcjEpKSB7XG5cbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbG9naWMgZm9yIFBBQyAtPiByb3cgbWFwcGluZywgc28gd2UgaGF2ZSB0byBqdXN0XG4gICAgICAvLyBmaW5kIHRoZSByb3cgY29kZSBpbiBhbiBhcnJheSBhbmQgdXNlIGl0cyBpbmRleCA6KFxuICAgICAgdmFyIHJvdyA9IFJPV1MuaW5kZXhPZihkYXRhICYgMHgxZjIwKTtcblxuICAgICAgaWYgKHJvdyAhPT0gdGhpcy5yb3dfKSB7XG4gICAgICAgIC8vIGZvcm1hdHRpbmcgaXMgb25seSBwZXJzaXN0ZW50IGZvciBjdXJyZW50IHJvd1xuICAgICAgICB0aGlzLmNsZWFyRm9ybWF0dGluZyhwYWNrZXQucHRzKTtcbiAgICAgICAgdGhpcy5yb3dfID0gcm93O1xuICAgICAgfVxuICAgICAgLy8gQWxsIFBBQ3MgY2FuIGFwcGx5IHVuZGVybGluZSwgc28gZGV0ZWN0IGFuZCBhcHBseVxuICAgICAgLy8gKEFsbCBvZGQtbnVtYmVyZWQgc2Vjb25kIGJ5dGVzIHNldCB1bmRlcmxpbmUpXG4gICAgICBpZiAoKGNoYXIxICYgMHgxKSAmJiAodGhpcy5mb3JtYXR0aW5nXy5pbmRleE9mKCd1JykgPT09IC0xKSkge1xuICAgICAgICAgIHRoaXMuYWRkRm9ybWF0dGluZyhwYWNrZXQucHRzLCBbJ3UnXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoZGF0YSAmIDB4MTApID09PSAweDEwKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGdvdCBhbiBpbmRlbnQgbGV2ZWwgY29kZS4gRWFjaCBzdWNjZXNzaXZlIGV2ZW4gbnVtYmVyXG4gICAgICAgIC8vIGluY3JlbWVudHMgdGhlIGNvbHVtbiBjdXJzb3IgYnkgNCwgc28gd2UgY2FuIGdldCB0aGUgZGVzaXJlZFxuICAgICAgICAvLyBjb2x1bW4gcG9zaXRpb24gYnkgYml0LXNoaWZ0aW5nIHRvIHRoZSByaWdodCAodG8gZ2V0IG4vMilcbiAgICAgICAgLy8gYW5kIG11bHRpcGx5aW5nIGJ5IDQuXG4gICAgICAgIHRoaXMuY29sdW1uXyA9ICgoZGF0YSAmIDB4ZSkgPj4gMSkgKiA0O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0NvbG9yUEFDKGNoYXIxKSkge1xuICAgICAgICAvLyBpdCdzIGEgY29sb3IgY29kZSwgdGhvdWdoIHdlIG9ubHkgc3VwcG9ydCB3aGl0ZSwgd2hpY2hcbiAgICAgICAgLy8gY2FuIGJlIGVpdGhlciBub3JtYWwgb3IgaXRhbGljaXplZC4gd2hpdGUgaXRhbGljcyBjYW4gYmVcbiAgICAgICAgLy8gZWl0aGVyIDB4NGUgb3IgMHg2ZSBkZXBlbmRpbmcgb24gdGhlIHJvdywgc28gd2UganVzdFxuICAgICAgICAvLyBiaXR3aXNlLWFuZCB3aXRoIDB4ZSB0byBzZWUgaWYgaXRhbGljcyBzaG91bGQgYmUgdHVybmVkIG9uXG4gICAgICAgIGlmICgoY2hhcjEgJiAweGUpID09PSAweGUpIHtcbiAgICAgICAgICB0aGlzLmFkZEZvcm1hdHRpbmcocGFja2V0LnB0cywgWydpJ10pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAvLyBXZSBoYXZlIGEgbm9ybWFsIGNoYXJhY3RlciBpbiBjaGFyMCwgYW5kIHBvc3NpYmx5IG9uZSBpbiBjaGFyMVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc05vcm1hbENoYXIoY2hhcjApKSB7XG4gICAgICBpZiAoY2hhcjEgPT09IDB4MDApIHtcbiAgICAgICAgY2hhcjEgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGV4dCA9IGdldENoYXJGcm9tQ29kZShjaGFyMCk7XG4gICAgICB0ZXh0ICs9IGdldENoYXJGcm9tQ29kZShjaGFyMSk7XG4gICAgICB0aGlzW3RoaXMubW9kZV9dKHBhY2tldC5wdHMsIHRleHQpO1xuICAgICAgdGhpcy5jb2x1bW5fICs9IHRleHQubGVuZ3RoO1xuXG4gICAgfSAvLyBmaW5pc2ggZGF0YSBwcm9jZXNzaW5nXG5cbiAgfTtcbn07XG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlID0gbmV3IFN0cmVhbSgpO1xuLy8gVHJpZ2dlciBhIGN1ZSBwb2ludCB0aGF0IGNhcHR1cmVzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZVxuLy8gZGlzcGxheSBidWZmZXJcbkNlYTYwOFN0cmVhbS5wcm90b3R5cGUuZmx1c2hEaXNwbGF5ZWQgPSBmdW5jdGlvbihwdHMpIHtcbiAgdmFyIGNvbnRlbnQgPSB0aGlzLmRpc3BsYXllZF9cbiAgICAvLyByZW1vdmUgc3BhY2VzIGZyb20gdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHN0cmluZ1xuICAgIC5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICByZXR1cm4gcm93LnRyaW0oKTtcbiAgICB9KVxuICAgIC8vIGNvbWJpbmUgYWxsIHRleHQgcm93cyB0byBkaXNwbGF5IGluIG9uZSBjdWVcbiAgICAuam9pbignXFxuJylcbiAgICAvLyBhbmQgcmVtb3ZlIGJsYW5rIHJvd3MgZnJvbSB0aGUgc3RhcnQgYW5kIGVuZCwgYnV0IG5vdCB0aGUgbWlkZGxlXG4gICAgLnJlcGxhY2UoL15cXG4rfFxcbiskL2csICcnKTtcblxuICBpZiAoY29udGVudC5sZW5ndGgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB7XG4gICAgICBzdGFydFB0czogdGhpcy5zdGFydFB0c18sXG4gICAgICBlbmRQdHM6IHB0cyxcbiAgICAgIHRleHQ6IGNvbnRlbnQsXG4gICAgICBzdHJlYW06IHRoaXMubmFtZV9cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBaZXJvIG91dCB0aGUgZGF0YSwgdXNlZCBmb3Igc3RhcnR1cCBhbmQgb24gc2Vla1xuICovXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubW9kZV8gPSAncG9wT24nO1xuICAvLyBXaGVuIGluIHJvbGwtdXAgbW9kZSwgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHJvdyB0aGF0IHdpbGxcbiAgLy8gYWN0dWFsbHkgZGlzcGxheSBjYXB0aW9ucy4gSWYgYSBjYXB0aW9uIGlzIHNoaWZ0ZWQgdG8gYSByb3dcbiAgLy8gd2l0aCBhIGxvd2VyIGluZGV4IHRoYW4gdGhpcywgaXQgaXMgY2xlYXJlZCBmcm9tIHRoZSBkaXNwbGF5XG4gIC8vIGJ1ZmZlclxuICB0aGlzLnRvcFJvd18gPSAwO1xuICB0aGlzLnN0YXJ0UHRzXyA9IDA7XG4gIHRoaXMuZGlzcGxheWVkXyA9IGNyZWF0ZURpc3BsYXlCdWZmZXIoKTtcbiAgdGhpcy5ub25EaXNwbGF5ZWRfID0gY3JlYXRlRGlzcGxheUJ1ZmZlcigpO1xuICB0aGlzLmxhc3RDb250cm9sQ29kZV8gPSBudWxsO1xuXG4gIC8vIFRyYWNrIHJvdyBhbmQgY29sdW1uIGZvciBwcm9wZXIgbGluZS1icmVha2luZyBhbmQgc3BhY2luZ1xuICB0aGlzLmNvbHVtbl8gPSAwO1xuICB0aGlzLnJvd18gPSBCT1RUT01fUk9XO1xuXG4gIC8vIFRoaXMgdmFyaWFibGUgaG9sZHMgY3VycmVudGx5LWFwcGxpZWQgZm9ybWF0dGluZ1xuICB0aGlzLmZvcm1hdHRpbmdfID0gW107XG59O1xuXG4vKipcbiAqIFNldHMgdXAgY29udHJvbCBjb2RlIGFuZCByZWxhdGVkIGNvbnN0YW50cyBmb3IgdGhpcyBpbnN0YW5jZVxuICovXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLnNldENvbnN0YW50cyA9IGZ1bmN0aW9uKCkge1xuICAvLyBUaGUgZm9sbG93aW5nIGF0dHJpYnV0ZXMgaGF2ZSB0aGVzZSB1c2VzOlxuICAvLyBleHRfIDogICAgY2hhcjAgZm9yIG1pZC1yb3cgY29kZXMsIGFuZCB0aGUgYmFzZSBmb3IgZXh0ZW5kZWRcbiAgLy8gICAgICAgICAgIGNoYXJzIChleHRfKzAsIGV4dF8rMSwgYW5kIGV4dF8rMiBhcmUgY2hhcjBzIGZvclxuICAvLyAgICAgICAgICAgZXh0ZW5kZWQgY29kZXMpXG4gIC8vIGNvbnRyb2xfOiBjaGFyMCBmb3IgY29udHJvbCBjb2RlcywgZXhjZXB0IGJ5dGUtc2hpZnRlZCB0byB0aGVcbiAgLy8gICAgICAgICAgIGxlZnQgc28gdGhhdCB3ZSBjYW4gZG8gdGhpcy5jb250cm9sXyB8IENPTlRST0xfQ09ERVxuICAvLyBvZmZzZXRfOiAgY2hhcjAgZm9yIHRhYiBvZmZzZXQgY29kZXNcbiAgLy9cbiAgLy8gSXQncyBhbHNvIHdvcnRoIG5vdGluZyB0aGF0IGNvbnRyb2wgY29kZXMsIGFuZCBfb25seV8gY29udHJvbCBjb2RlcyxcbiAgLy8gZGlmZmVyIGJldHdlZW4gZmllbGQgMSBhbmQgZmllbGQyLiBGaWVsZCAyIGNvbnRyb2wgY29kZXMgYXJlIGFsd2F5c1xuICAvLyB0aGVpciBmaWVsZCAxIHZhbHVlIHBsdXMgMS4gVGhhdCdzIHdoeSB0aGVyZSdzIHRoZSBcInwgZmllbGRcIiBvbiB0aGVcbiAgLy8gY29udHJvbCB2YWx1ZS5cbiAgaWYgKHRoaXMuZGF0YUNoYW5uZWxfID09PSAwKSB7XG4gICAgdGhpcy5CQVNFXyAgICAgPSAweDEwO1xuICAgIHRoaXMuRVhUXyAgICAgID0gMHgxMTtcbiAgICB0aGlzLkNPTlRST0xfICA9ICgweDE0IHwgdGhpcy5maWVsZF8pIDw8IDg7XG4gICAgdGhpcy5PRkZTRVRfICAgPSAweDE3O1xuICB9IGVsc2UgaWYgKHRoaXMuZGF0YUNoYW5uZWxfID09PSAxKSB7XG4gICAgdGhpcy5CQVNFXyAgICAgPSAweDE4O1xuICAgIHRoaXMuRVhUXyAgICAgID0gMHgxOTtcbiAgICB0aGlzLkNPTlRST0xfICA9ICgweDFjIHwgdGhpcy5maWVsZF8pIDw8IDg7XG4gICAgdGhpcy5PRkZTRVRfICAgPSAweDFmO1xuICB9XG5cbiAgLy8gQ29uc3RhbnRzIGZvciB0aGUgTFNCeXRlIGNvbW1hbmQgY29kZXMgcmVjb2duaXplZCBieSBDZWE2MDhTdHJlYW0uIFRoaXNcbiAgLy8gbGlzdCBpcyBub3QgZXhoYXVzdGl2ZS4gRm9yIGEgbW9yZSBjb21wcmVoZW5zaXZlIGxpc3RpbmcgYW5kIHNlbWFudGljcyBzZWVcbiAgLy8gaHR0cDovL3d3dy5ncG8uZ292L2Zkc3lzL3BrZy9DRlItMjAxMC10aXRsZTQ3LXZvbDEvcGRmL0NGUi0yMDEwLXRpdGxlNDctdm9sMS1zZWMxNS0xMTkucGRmXG4gIC8vIFBhZGRpbmdcbiAgdGhpcy5QQURESU5HXyAgICAgICAgICAgICAgICAgICAgPSAweDAwMDA7XG4gIC8vIFBvcC1vbiBNb2RlXG4gIHRoaXMuUkVTVU1FX0NBUFRJT05fTE9BRElOR18gICAgID0gdGhpcy5DT05UUk9MXyB8IDB4MjA7XG4gIHRoaXMuRU5EX09GX0NBUFRJT05fICAgICAgICAgICAgID0gdGhpcy5DT05UUk9MXyB8IDB4MmY7XG4gIC8vIFJvbGwtdXAgTW9kZVxuICB0aGlzLlJPTExfVVBfMl9ST1dTXyAgICAgICAgICAgICA9IHRoaXMuQ09OVFJPTF8gfCAweDI1O1xuICB0aGlzLlJPTExfVVBfM19ST1dTXyAgICAgICAgICAgICA9IHRoaXMuQ09OVFJPTF8gfCAweDI2O1xuICB0aGlzLlJPTExfVVBfNF9ST1dTXyAgICAgICAgICAgICA9IHRoaXMuQ09OVFJPTF8gfCAweDI3O1xuICB0aGlzLkNBUlJJQUdFX1JFVFVSTl8gICAgICAgICAgICA9IHRoaXMuQ09OVFJPTF8gfCAweDJkO1xuICAvLyBwYWludC1vbiBtb2RlIChub3Qgc3VwcG9ydGVkKVxuICB0aGlzLlJFU1VNRV9ESVJFQ1RfQ0FQVElPTklOR18gICA9IHRoaXMuQ09OVFJPTF8gfCAweDI5O1xuICAvLyBFcmFzdXJlXG4gIHRoaXMuQkFDS1NQQUNFXyAgICAgICAgICAgICAgICAgID0gdGhpcy5DT05UUk9MXyB8IDB4MjE7XG4gIHRoaXMuRVJBU0VfRElTUExBWUVEX01FTU9SWV8gICAgID0gdGhpcy5DT05UUk9MXyB8IDB4MmM7XG4gIHRoaXMuRVJBU0VfTk9OX0RJU1BMQVlFRF9NRU1PUllfID0gdGhpcy5DT05UUk9MXyB8IDB4MmU7XG59O1xuXG4vKipcbiAqIERldGVjdHMgaWYgdGhlIDItYnl0ZSBwYWNrZXQgZGF0YSBpcyBhIHNwZWNpYWwgY2hhcmFjdGVyXG4gKlxuICogU3BlY2lhbCBjaGFyYWN0ZXJzIGhhdmUgYSBzZWNvbmQgYnl0ZSBpbiB0aGUgcmFuZ2UgMHgzMCB0byAweDNmLFxuICogd2l0aCB0aGUgZmlyc3QgYnl0ZSBiZWluZyAweDExIChmb3IgZGF0YSBjaGFubmVsIDEpIG9yIDB4MTkgKGZvclxuICogZGF0YSBjaGFubmVsIDIpLlxuICpcbiAqIEBwYXJhbSAge0ludGVnZXJ9IGNoYXIwIFRoZSBmaXJzdCBieXRlXG4gKiBAcGFyYW0gIHtJbnRlZ2VyfSBjaGFyMSBUaGUgc2Vjb25kIGJ5dGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgIFdoZXRoZXIgdGhlIDIgYnl0ZXMgYXJlIGFuIHNwZWNpYWwgY2hhcmFjdGVyXG4gKi9cbkNlYTYwOFN0cmVhbS5wcm90b3R5cGUuaXNTcGVjaWFsQ2hhcmFjdGVyID0gZnVuY3Rpb24oY2hhcjAsIGNoYXIxKSB7XG4gIHJldHVybiAoY2hhcjAgPT09IHRoaXMuRVhUXyAmJiBjaGFyMSA+PSAweDMwICYmIGNoYXIxIDw9IDB4M2YpO1xufTtcblxuLyoqXG4gKiBEZXRlY3RzIGlmIHRoZSAyLWJ5dGUgcGFja2V0IGRhdGEgaXMgYW4gZXh0ZW5kZWQgY2hhcmFjdGVyXG4gKlxuICogRXh0ZW5kZWQgY2hhcmFjdGVycyBoYXZlIGEgc2Vjb25kIGJ5dGUgaW4gdGhlIHJhbmdlIDB4MjAgdG8gMHgzZixcbiAqIHdpdGggdGhlIGZpcnN0IGJ5dGUgYmVpbmcgMHgxMiBvciAweDEzIChmb3IgZGF0YSBjaGFubmVsIDEpIG9yXG4gKiAweDFhIG9yIDB4MWIgKGZvciBkYXRhIGNoYW5uZWwgMikuXG4gKlxuICogQHBhcmFtICB7SW50ZWdlcn0gY2hhcjAgVGhlIGZpcnN0IGJ5dGVcbiAqIEBwYXJhbSAge0ludGVnZXJ9IGNoYXIxIFRoZSBzZWNvbmQgYnl0ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgV2hldGhlciB0aGUgMiBieXRlcyBhcmUgYW4gZXh0ZW5kZWQgY2hhcmFjdGVyXG4gKi9cbkNlYTYwOFN0cmVhbS5wcm90b3R5cGUuaXNFeHRDaGFyYWN0ZXIgPSBmdW5jdGlvbihjaGFyMCwgY2hhcjEpIHtcbiAgcmV0dXJuICgoY2hhcjAgPT09ICh0aGlzLkVYVF8gKyAxKSB8fCBjaGFyMCA9PT0gKHRoaXMuRVhUXyArIDIpKSAmJlxuICAgIChjaGFyMSA+PSAweDIwICYmIGNoYXIxIDw9IDB4M2YpKTtcbn07XG5cbi8qKlxuICogRGV0ZWN0cyBpZiB0aGUgMi1ieXRlIHBhY2tldCBpcyBhIG1pZC1yb3cgY29kZVxuICpcbiAqIE1pZC1yb3cgY29kZXMgaGF2ZSBhIHNlY29uZCBieXRlIGluIHRoZSByYW5nZSAweDIwIHRvIDB4MmYsIHdpdGhcbiAqIHRoZSBmaXJzdCBieXRlIGJlaW5nIDB4MTEgKGZvciBkYXRhIGNoYW5uZWwgMSkgb3IgMHgxOSAoZm9yIGRhdGFcbiAqIGNoYW5uZWwgMikuXG4gKlxuICogQHBhcmFtICB7SW50ZWdlcn0gY2hhcjAgVGhlIGZpcnN0IGJ5dGVcbiAqIEBwYXJhbSAge0ludGVnZXJ9IGNoYXIxIFRoZSBzZWNvbmQgYnl0ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgV2hldGhlciB0aGUgMiBieXRlcyBhcmUgYSBtaWQtcm93IGNvZGVcbiAqL1xuQ2VhNjA4U3RyZWFtLnByb3RvdHlwZS5pc01pZFJvd0NvZGUgPSBmdW5jdGlvbihjaGFyMCwgY2hhcjEpIHtcbiAgcmV0dXJuIChjaGFyMCA9PT0gdGhpcy5FWFRfICYmIChjaGFyMSA+PSAweDIwICYmIGNoYXIxIDw9IDB4MmYpKTtcbn07XG5cbi8qKlxuICogRGV0ZWN0cyBpZiB0aGUgMi1ieXRlIHBhY2tldCBpcyBhbiBvZmZzZXQgY29udHJvbCBjb2RlXG4gKlxuICogT2Zmc2V0IGNvbnRyb2wgY29kZXMgaGF2ZSBhIHNlY29uZCBieXRlIGluIHRoZSByYW5nZSAweDIxIHRvIDB4MjMsXG4gKiB3aXRoIHRoZSBmaXJzdCBieXRlIGJlaW5nIDB4MTcgKGZvciBkYXRhIGNoYW5uZWwgMSkgb3IgMHgxZiAoZm9yXG4gKiBkYXRhIGNoYW5uZWwgMikuXG4gKlxuICogQHBhcmFtICB7SW50ZWdlcn0gY2hhcjAgVGhlIGZpcnN0IGJ5dGVcbiAqIEBwYXJhbSAge0ludGVnZXJ9IGNoYXIxIFRoZSBzZWNvbmQgYnl0ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgV2hldGhlciB0aGUgMiBieXRlcyBhcmUgYW4gb2Zmc2V0IGNvbnRyb2wgY29kZVxuICovXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLmlzT2Zmc2V0Q29udHJvbENvZGUgPSBmdW5jdGlvbihjaGFyMCwgY2hhcjEpIHtcbiAgcmV0dXJuIChjaGFyMCA9PT0gdGhpcy5PRkZTRVRfICYmIChjaGFyMSA+PSAweDIxICYmIGNoYXIxIDw9IDB4MjMpKTtcbn07XG5cbi8qKlxuICogRGV0ZWN0cyBpZiB0aGUgMi1ieXRlIHBhY2tldCBpcyBhIFByZWFtYmxlIEFkZHJlc3MgQ29kZVxuICpcbiAqIFBBQ3MgaGF2ZSBhIGZpcnN0IGJ5dGUgaW4gdGhlIHJhbmdlIDB4MTAgdG8gMHgxNyAoZm9yIGRhdGEgY2hhbm5lbCAxKVxuICogb3IgMHgxOCB0byAweDFmIChmb3IgZGF0YSBjaGFubmVsIDIpLCB3aXRoIHRoZSBzZWNvbmQgYnl0ZSBpbiB0aGVcbiAqIHJhbmdlIDB4NDAgdG8gMHg3Zi5cbiAqXG4gKiBAcGFyYW0gIHtJbnRlZ2VyfSBjaGFyMCBUaGUgZmlyc3QgYnl0ZVxuICogQHBhcmFtICB7SW50ZWdlcn0gY2hhcjEgVGhlIHNlY29uZCBieXRlXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICBXaGV0aGVyIHRoZSAyIGJ5dGVzIGFyZSBhIFBBQ1xuICovXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLmlzUEFDID0gZnVuY3Rpb24oY2hhcjAsIGNoYXIxKSB7XG4gIHJldHVybiAoY2hhcjAgPj0gdGhpcy5CQVNFXyAmJiBjaGFyMCA8ICh0aGlzLkJBU0VfICsgOCkgJiZcbiAgICAoY2hhcjEgPj0gMHg0MCAmJiBjaGFyMSA8PSAweDdmKSk7XG59O1xuXG4vKipcbiAqIERldGVjdHMgaWYgYSBwYWNrZXQncyBzZWNvbmQgYnl0ZSBpcyBpbiB0aGUgcmFuZ2Ugb2YgYSBQQUMgY29sb3IgY29kZVxuICpcbiAqIFBBQyBjb2xvciBjb2RlcyBoYXZlIHRoZSBzZWNvbmQgYnl0ZSBiZSBpbiB0aGUgcmFuZ2UgMHg0MCB0byAweDRmLCBvclxuICogMHg2MCB0byAweDZmLlxuICpcbiAqIEBwYXJhbSAge0ludGVnZXJ9IGNoYXIxIFRoZSBzZWNvbmQgYnl0ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgV2hldGhlciB0aGUgYnl0ZSBpcyBhIGNvbG9yIFBBQ1xuICovXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLmlzQ29sb3JQQUMgPSBmdW5jdGlvbihjaGFyMSkge1xuICByZXR1cm4gKChjaGFyMSA+PSAweDQwICYmIGNoYXIxIDw9IDB4NGYpIHx8IChjaGFyMSA+PSAweDYwICYmIGNoYXIxIDw9IDB4N2YpKTtcbn07XG5cbi8qKlxuICogRGV0ZWN0cyBpZiBhIHNpbmdsZSBieXRlIGlzIGluIHRoZSByYW5nZSBvZiBhIG5vcm1hbCBjaGFyYWN0ZXJcbiAqXG4gKiBOb3JtYWwgdGV4dCBieXRlcyBhcmUgaW4gdGhlIHJhbmdlIDB4MjAgdG8gMHg3Zi5cbiAqXG4gKiBAcGFyYW0gIHtJbnRlZ2VyfSBjaGFyICBUaGUgYnl0ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgV2hldGhlciB0aGUgYnl0ZSBpcyBhIG5vcm1hbCBjaGFyYWN0ZXJcbiAqL1xuQ2VhNjA4U3RyZWFtLnByb3RvdHlwZS5pc05vcm1hbENoYXIgPSBmdW5jdGlvbihjaGFyKSB7XG4gIHJldHVybiAoY2hhciA+PSAweDIwICYmIGNoYXIgPD0gMHg3Zik7XG59O1xuXG4vLyBBZGRzIHRoZSBvcGVuaW5nIEhUTUwgdGFnIGZvciB0aGUgcGFzc2VkIGNoYXJhY3RlciB0byB0aGUgY2FwdGlvbiB0ZXh0LFxuLy8gYW5kIGtlZXBzIHRyYWNrIG9mIGl0IGZvciBsYXRlciBjbG9zaW5nXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLmFkZEZvcm1hdHRpbmcgPSBmdW5jdGlvbihwdHMsIGZvcm1hdCkge1xuICB0aGlzLmZvcm1hdHRpbmdfID0gdGhpcy5mb3JtYXR0aW5nXy5jb25jYXQoZm9ybWF0KTtcbiAgdmFyIHRleHQgPSBmb3JtYXQucmVkdWNlKGZ1bmN0aW9uKHRleHQsIGZvcm1hdCkge1xuICAgIHJldHVybiB0ZXh0ICsgJzwnICsgZm9ybWF0ICsgJz4nO1xuICB9LCAnJyk7XG4gIHRoaXNbdGhpcy5tb2RlX10ocHRzLCB0ZXh0KTtcbn07XG5cbi8vIEFkZHMgSFRNTCBjbG9zaW5nIHRhZ3MgZm9yIGN1cnJlbnQgZm9ybWF0dGluZyB0byBjYXB0aW9uIHRleHQgYW5kXG4vLyBjbGVhcnMgcmVtZW1iZXJlZCBmb3JtYXR0aW5nXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLmNsZWFyRm9ybWF0dGluZyA9IGZ1bmN0aW9uKHB0cykge1xuICBpZiAoIXRoaXMuZm9ybWF0dGluZ18ubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0ZXh0ID0gdGhpcy5mb3JtYXR0aW5nXy5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uKHRleHQsIGZvcm1hdCkge1xuICAgIHJldHVybiB0ZXh0ICsgJzwvJyArIGZvcm1hdCArICc+JztcbiAgfSwgJycpO1xuICB0aGlzLmZvcm1hdHRpbmdfID0gW107XG4gIHRoaXNbdGhpcy5tb2RlX10ocHRzLCB0ZXh0KTtcbn07XG5cbi8vIE1vZGUgSW1wbGVtZW50YXRpb25zXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLnBvcE9uID0gZnVuY3Rpb24ocHRzLCB0ZXh0KSB7XG4gIHZhciBiYXNlUm93ID0gdGhpcy5ub25EaXNwbGF5ZWRfW3RoaXMucm93X107XG5cbiAgLy8gYnVmZmVyIGNoYXJhY3RlcnNcbiAgYmFzZVJvdyArPSB0ZXh0O1xuICB0aGlzLm5vbkRpc3BsYXllZF9bdGhpcy5yb3dfXSA9IGJhc2VSb3c7XG59O1xuXG5DZWE2MDhTdHJlYW0ucHJvdG90eXBlLnJvbGxVcCA9IGZ1bmN0aW9uKHB0cywgdGV4dCkge1xuICB2YXIgYmFzZVJvdyA9IHRoaXMuZGlzcGxheWVkX1tCT1RUT01fUk9XXTtcblxuICBiYXNlUm93ICs9IHRleHQ7XG4gIHRoaXMuZGlzcGxheWVkX1tCT1RUT01fUk9XXSA9IGJhc2VSb3c7XG5cbn07XG5cbkNlYTYwOFN0cmVhbS5wcm90b3R5cGUuc2hpZnRSb3dzVXBfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpO1xuICAvLyBjbGVhciBvdXQgaW5hY3RpdmUgcm93c1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b3BSb3dfOyBpKyspIHtcbiAgICB0aGlzLmRpc3BsYXllZF9baV0gPSAnJztcbiAgfVxuICAvLyBzaGlmdCBkaXNwbGF5ZWQgcm93cyB1cFxuICBmb3IgKGkgPSB0aGlzLnRvcFJvd187IGkgPCBCT1RUT01fUk9XOyBpKyspIHtcbiAgICB0aGlzLmRpc3BsYXllZF9baV0gPSB0aGlzLmRpc3BsYXllZF9baSArIDFdO1xuICB9XG4gIC8vIGNsZWFyIG91dCB0aGUgYm90dG9tIHJvd1xuICB0aGlzLmRpc3BsYXllZF9bQk9UVE9NX1JPV10gPSAnJztcbn07XG5cbi8vIHBhaW50T24gbW9kZSBpcyBub3QgaW1wbGVtZW50ZWRcbkNlYTYwOFN0cmVhbS5wcm90b3R5cGUucGFpbnRPbiA9IGZ1bmN0aW9uKCkge307XG5cbi8vIGV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBDYXB0aW9uU3RyZWFtOiBDYXB0aW9uU3RyZWFtLFxuICBDZWE2MDhTdHJlYW06IENlYTYwOFN0cmVhbVxufTtcblxufSx7XCIuLi91dGlscy9zdHJlYW1cIjo2Mn1dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogbXV4LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEJyaWdodGNvdmVcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogQSBzdHJlYW0tYmFzZWQgbXAydCB0byBtcDQgY29udmVydGVyLiBUaGlzIHV0aWxpdHkgY2FuIGJlIHVzZWQgdG9cbiAqIGRlbGl2ZXIgbXA0cyB0byBhIFNvdXJjZUJ1ZmZlciBvbiBwbGF0Zm9ybXMgdGhhdCBzdXBwb3J0IG5hdGl2ZVxuICogTWVkaWEgU291cmNlIEV4dGVuc2lvbnMuXG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuLi91dGlscy9zdHJlYW0uanMnKSxcbiAgQ2FwdGlvblN0cmVhbSA9IHJlcXVpcmUoJy4vY2FwdGlvbi1zdHJlYW0nKSxcbiAgU3RyZWFtVHlwZXMgPSByZXF1aXJlKCcuL3N0cmVhbS10eXBlcycpLFxuICBUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSA9IHJlcXVpcmUoJy4vdGltZXN0YW1wLXJvbGxvdmVyLXN0cmVhbScpLlRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtO1xuXG52YXIgbTJ0c1N0cmVhbVR5cGVzID0gcmVxdWlyZSgnLi9zdHJlYW0tdHlwZXMuanMnKTtcblxuLy8gb2JqZWN0IHR5cGVzXG52YXIgVHJhbnNwb3J0UGFja2V0U3RyZWFtLCBUcmFuc3BvcnRQYXJzZVN0cmVhbSwgRWxlbWVudGFyeVN0cmVhbTtcblxuLy8gY29uc3RhbnRzXG52YXJcbiAgTVAyVF9QQUNLRVRfTEVOR1RIID0gMTg4LCAvLyBieXRlc1xuICBTWU5DX0JZVEUgPSAweDQ3O1xuXG4vKipcbiAqIFNwbGl0cyBhbiBpbmNvbWluZyBzdHJlYW0gb2YgYmluYXJ5IGRhdGEgaW50byBNUEVHLTIgVHJhbnNwb3J0XG4gKiBTdHJlYW0gcGFja2V0cy5cbiAqL1xuVHJhbnNwb3J0UGFja2V0U3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gIHZhclxuICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KE1QMlRfUEFDS0VUX0xFTkdUSCksXG4gICAgYnl0ZXNJbkJ1ZmZlciA9IDA7XG5cbiAgVHJhbnNwb3J0UGFja2V0U3RyZWFtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG5cbiAgIC8vIERlbGl2ZXIgbmV3IGJ5dGVzIHRvIHRoZSBzdHJlYW0uXG5cbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICB2YXJcbiAgICAgIHN0YXJ0SW5kZXggPSAwLFxuICAgICAgZW5kSW5kZXggPSBNUDJUX1BBQ0tFVF9MRU5HVEgsXG4gICAgICBldmVyeXRoaW5nO1xuXG4gICAgLy8gSWYgdGhlcmUgYXJlIGJ5dGVzIHJlbWFpbmluZyBmcm9tIHRoZSBsYXN0IHNlZ21lbnQsIHByZXBlbmQgdGhlbSB0byB0aGVcbiAgICAvLyBieXRlcyB0aGF0IHdlcmUgcHVzaGVkIGluXG4gICAgaWYgKGJ5dGVzSW5CdWZmZXIpIHtcbiAgICAgIGV2ZXJ5dGhpbmcgPSBuZXcgVWludDhBcnJheShieXRlcy5ieXRlTGVuZ3RoICsgYnl0ZXNJbkJ1ZmZlcik7XG4gICAgICBldmVyeXRoaW5nLnNldChidWZmZXIuc3ViYXJyYXkoMCwgYnl0ZXNJbkJ1ZmZlcikpO1xuICAgICAgZXZlcnl0aGluZy5zZXQoYnl0ZXMsIGJ5dGVzSW5CdWZmZXIpO1xuICAgICAgYnl0ZXNJbkJ1ZmZlciA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZXJ5dGhpbmcgPSBieXRlcztcbiAgICB9XG5cbiAgICAvLyBXaGlsZSB3ZSBoYXZlIGVub3VnaCBkYXRhIGZvciBhIHBhY2tldFxuICAgIHdoaWxlIChlbmRJbmRleCA8IGV2ZXJ5dGhpbmcuYnl0ZUxlbmd0aCkge1xuICAgICAgLy8gTG9vayBmb3IgYSBwYWlyIG9mIHN0YXJ0IGFuZCBlbmQgc3luYyBieXRlcyBpbiB0aGUgZGF0YS4uXG4gICAgICBpZiAoZXZlcnl0aGluZ1tzdGFydEluZGV4XSA9PT0gU1lOQ19CWVRFICYmIGV2ZXJ5dGhpbmdbZW5kSW5kZXhdID09PSBTWU5DX0JZVEUpIHtcbiAgICAgICAgLy8gV2UgZm91bmQgYSBwYWNrZXQgc28gZW1pdCBpdCBhbmQganVtcCBvbmUgd2hvbGUgcGFja2V0IGZvcndhcmQgaW5cbiAgICAgICAgLy8gdGhlIHN0cmVhbVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCBldmVyeXRoaW5nLnN1YmFycmF5KHN0YXJ0SW5kZXgsIGVuZEluZGV4KSk7XG4gICAgICAgIHN0YXJ0SW5kZXggKz0gTVAyVF9QQUNLRVRfTEVOR1RIO1xuICAgICAgICBlbmRJbmRleCArPSBNUDJUX1BBQ0tFVF9MRU5HVEg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHdlIGhhdmUgc29tZWhvdyBiZWNvbWUgZGUtc3luY2hyb25pemVkIGFuZCB3ZSBuZWVkIHRvIHN0ZXBcbiAgICAgIC8vIGZvcndhcmQgb25lIGJ5dGUgYXQgYSB0aW1lIHVudGlsIHdlIGZpbmQgYSBwYWlyIG9mIHN5bmMgYnl0ZXMgdGhhdCBkZW5vdGVcbiAgICAgIC8vIGEgcGFja2V0XG4gICAgICBzdGFydEluZGV4Kys7XG4gICAgICBlbmRJbmRleCsrO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIHdhcyBzb21lIGRhdGEgbGVmdCBvdmVyIGF0IHRoZSBlbmQgb2YgdGhlIHNlZ21lbnQgdGhhdCBjb3VsZG4ndFxuICAgIC8vIHBvc3NpYmx5IGJlIGEgd2hvbGUgcGFja2V0LCBrZWVwIGl0IGJlY2F1c2UgaXQgbWlnaHQgYmUgdGhlIHN0YXJ0IG9mIGEgcGFja2V0XG4gICAgLy8gdGhhdCBjb250aW51ZXMgaW4gdGhlIG5leHQgc2VnbWVudFxuICAgIGlmIChzdGFydEluZGV4IDwgZXZlcnl0aGluZy5ieXRlTGVuZ3RoKSB7XG4gICAgICBidWZmZXIuc2V0KGV2ZXJ5dGhpbmcuc3ViYXJyYXkoc3RhcnRJbmRleCksIDApO1xuICAgICAgYnl0ZXNJbkJ1ZmZlciA9IGV2ZXJ5dGhpbmcuYnl0ZUxlbmd0aCAtIHN0YXJ0SW5kZXg7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAvLyBJZiB0aGUgYnVmZmVyIGNvbnRhaW5zIGEgd2hvbGUgcGFja2V0IHdoZW4gd2UgYXJlIGJlaW5nIGZsdXNoZWQsIGVtaXQgaXRcbiAgICAvLyBhbmQgZW1wdHkgdGhlIGJ1ZmZlci4gT3RoZXJ3aXNlIGhvbGQgb250byB0aGUgZGF0YSBiZWNhdXNlIGl0IG1heSBiZVxuICAgIC8vIGltcG9ydGFudCBmb3IgZGVjb2RpbmcgdGhlIG5leHQgc2VnbWVudFxuICAgIGlmIChieXRlc0luQnVmZmVyID09PSBNUDJUX1BBQ0tFVF9MRU5HVEggJiYgYnVmZmVyWzBdID09PSBTWU5DX0JZVEUpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZGF0YScsIGJ1ZmZlcik7XG4gICAgICBieXRlc0luQnVmZmVyID0gMDtcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyKCdkb25lJyk7XG4gIH07XG59O1xuVHJhbnNwb3J0UGFja2V0U3RyZWFtLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcblxuLyoqXG4gKiBBY2NlcHRzIGFuIE1QMlQgVHJhbnNwb3J0UGFja2V0U3RyZWFtIGFuZCBlbWl0cyBkYXRhIGV2ZW50cyB3aXRoIHBhcnNlZFxuICogZm9ybXMgb2YgdGhlIGluZGl2aWR1YWwgdHJhbnNwb3J0IHN0cmVhbSBwYWNrZXRzLlxuICovXG5UcmFuc3BvcnRQYXJzZVN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyc2VQc2ksIHBhcnNlUGF0LCBwYXJzZVBtdCwgc2VsZjtcbiAgVHJhbnNwb3J0UGFyc2VTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcbiAgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5wYWNrZXRzV2FpdGluZ0ZvclBtdCA9IFtdO1xuICB0aGlzLnByb2dyYW1NYXBUYWJsZSA9IHVuZGVmaW5lZDtcblxuICBwYXJzZVBzaSA9IGZ1bmN0aW9uKHBheWxvYWQsIHBzaSkge1xuICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgLy8gUFNJIHBhY2tldHMgbWF5IGJlIHNwbGl0IGludG8gbXVsdGlwbGUgc2VjdGlvbnMgYW5kIHRob3NlXG4gICAgLy8gc2VjdGlvbnMgbWF5IGJlIHNwbGl0IGludG8gbXVsdGlwbGUgcGFja2V0cy4gSWYgYSBQU0lcbiAgICAvLyBzZWN0aW9uIHN0YXJ0cyBpbiB0aGlzIHBhY2tldCwgdGhlIHBheWxvYWRfdW5pdF9zdGFydF9pbmRpY2F0b3JcbiAgICAvLyB3aWxsIGJlIHRydWUgYW5kIHRoZSBmaXJzdCBieXRlIG9mIHRoZSBwYXlsb2FkIHdpbGwgaW5kaWNhdGVcbiAgICAvLyB0aGUgb2Zmc2V0IGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgIC8vIHNlY3Rpb24uXG4gICAgaWYgKHBzaS5wYXlsb2FkVW5pdFN0YXJ0SW5kaWNhdG9yKSB7XG4gICAgICBvZmZzZXQgKz0gcGF5bG9hZFtvZmZzZXRdICsgMTtcbiAgICB9XG5cbiAgICBpZiAocHNpLnR5cGUgPT09ICdwYXQnKSB7XG4gICAgICBwYXJzZVBhdChwYXlsb2FkLnN1YmFycmF5KG9mZnNldCksIHBzaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlUG10KHBheWxvYWQuc3ViYXJyYXkob2Zmc2V0KSwgcHNpKTtcbiAgICB9XG4gIH07XG5cbiAgcGFyc2VQYXQgPSBmdW5jdGlvbihwYXlsb2FkLCBwYXQpIHtcbiAgICBwYXQuc2VjdGlvbl9udW1iZXIgPSBwYXlsb2FkWzddOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgIHBhdC5sYXN0X3NlY3Rpb25fbnVtYmVyID0gcGF5bG9hZFs4XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcblxuICAgIC8vIHNraXAgdGhlIFBTSSBoZWFkZXIgYW5kIHBhcnNlIHRoZSBmaXJzdCBQTVQgZW50cnlcbiAgICBzZWxmLnBtdFBpZCA9IChwYXlsb2FkWzEwXSAmIDB4MUYpIDw8IDggfCBwYXlsb2FkWzExXTtcbiAgICBwYXQucG10UGlkID0gc2VsZi5wbXRQaWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIG91dCB0aGUgcmVsZXZhbnQgZmllbGRzIG9mIGEgUHJvZ3JhbSBNYXAgVGFibGUgKFBNVCkuXG4gICAqIEBwYXJhbSBwYXlsb2FkIHtVaW50OEFycmF5fSB0aGUgUE1ULXNwZWNpZmljIHBvcnRpb24gb2YgYW4gTVAyVFxuICAgKiBwYWNrZXQuIFRoZSBmaXJzdCBieXRlIGluIHRoaXMgYXJyYXkgc2hvdWxkIGJlIHRoZSB0YWJsZV9pZFxuICAgKiBmaWVsZC5cbiAgICogQHBhcmFtIHBtdCB7b2JqZWN0fSB0aGUgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGRlY29yYXRlZCB3aXRoXG4gICAqIGZpZWxkcyBwYXJzZWQgZnJvbSB0aGUgUE1ULlxuICAgKi9cbiAgcGFyc2VQbXQgPSBmdW5jdGlvbihwYXlsb2FkLCBwbXQpIHtcbiAgICB2YXIgc2VjdGlvbkxlbmd0aCwgdGFibGVFbmQsIHByb2dyYW1JbmZvTGVuZ3RoLCBvZmZzZXQ7XG5cbiAgICAvLyBQTVRzIGNhbiBiZSBzZW50IGFoZWFkIG9mIHRoZSB0aW1lIHdoZW4gdGhleSBzaG91bGQgYWN0dWFsbHlcbiAgICAvLyB0YWtlIGVmZmVjdC4gV2UgZG9uJ3QgYmVsaWV2ZSB0aGlzIHNob3VsZCBldmVyIGJlIHRoZSBjYXNlXG4gICAgLy8gZm9yIEhMUyBidXQgd2UnbGwgaWdub3JlIFwiZm9yd2FyZFwiIFBNVCBkZWNsYXJhdGlvbnMgaWYgd2Ugc2VlXG4gICAgLy8gdGhlbS4gRnV0dXJlIFBNVCBkZWNsYXJhdGlvbnMgaGF2ZSB0aGUgY3VycmVudF9uZXh0X2luZGljYXRvclxuICAgIC8vIHNldCB0byB6ZXJvLlxuICAgIGlmICghKHBheWxvYWRbNV0gJiAweDAxKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgcHJvZ3JhbSBtYXAgdGFibGVcbiAgICBzZWxmLnByb2dyYW1NYXBUYWJsZSA9IHtcbiAgICAgIHZpZGVvOiBudWxsLFxuICAgICAgYXVkaW86IG51bGwsXG4gICAgICAndGltZWQtbWV0YWRhdGEnOiB7fVxuICAgIH07XG5cbiAgICAvLyB0aGUgbWFwcGluZyB0YWJsZSBlbmRzIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc2VjdGlvblxuICAgIHNlY3Rpb25MZW5ndGggPSAocGF5bG9hZFsxXSAmIDB4MGYpIDw8IDggfCBwYXlsb2FkWzJdO1xuICAgIHRhYmxlRW5kID0gMyArIHNlY3Rpb25MZW5ndGggLSA0O1xuXG4gICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXJlIHRoZSB0YWJsZSBpcywgd2UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvd1xuICAgIC8vIGxvbmcgdGhlIHByb2dyYW0gaW5mbyBkZXNjcmlwdG9ycyBhcmVcbiAgICBwcm9ncmFtSW5mb0xlbmd0aCA9IChwYXlsb2FkWzEwXSAmIDB4MGYpIDw8IDggfCBwYXlsb2FkWzExXTtcblxuICAgIC8vIGFkdmFuY2UgdGhlIG9mZnNldCB0byB0aGUgZmlyc3QgZW50cnkgaW4gdGhlIG1hcHBpbmcgdGFibGVcbiAgICBvZmZzZXQgPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuICAgIHdoaWxlIChvZmZzZXQgPCB0YWJsZUVuZCkge1xuICAgICAgdmFyIHN0cmVhbVR5cGUgPSBwYXlsb2FkW29mZnNldF07XG4gICAgICB2YXIgcGlkID0gKHBheWxvYWRbb2Zmc2V0ICsgMV0gJiAweDFGKSA8PCA4IHwgcGF5bG9hZFtvZmZzZXQgKyAyXTtcblxuICAgICAgLy8gb25seSBtYXAgYSBzaW5nbGUgZWxlbWVudGFyeV9waWQgZm9yIGF1ZGlvIGFuZCB2aWRlbyBzdHJlYW0gdHlwZXNcbiAgICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIGRvbmUgZm9yIG1ldGFkYXRhIHRvbz8gZm9yIG5vdyBtYWludGFpbiBiZWhhdmlvciBvZlxuICAgICAgLy8gICAgICAgbXVsdGlwbGUgbWV0YWRhdGEgc3RyZWFtc1xuICAgICAgaWYgKHN0cmVhbVR5cGUgPT09IFN0cmVhbVR5cGVzLkgyNjRfU1RSRUFNX1RZUEUgJiZcbiAgICAgICAgICBzZWxmLnByb2dyYW1NYXBUYWJsZS52aWRlbyA9PT0gbnVsbCkge1xuICAgICAgICBzZWxmLnByb2dyYW1NYXBUYWJsZS52aWRlbyA9IHBpZDtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtVHlwZSA9PT0gU3RyZWFtVHlwZXMuQURUU19TVFJFQU1fVFlQRSAmJlxuICAgICAgICAgICAgICAgICBzZWxmLnByb2dyYW1NYXBUYWJsZS5hdWRpbyA9PT0gbnVsbCkge1xuICAgICAgICBzZWxmLnByb2dyYW1NYXBUYWJsZS5hdWRpbyA9IHBpZDtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtVHlwZSA9PT0gU3RyZWFtVHlwZXMuTUVUQURBVEFfU1RSRUFNX1RZUEUpIHtcbiAgICAgICAgLy8gbWFwIHBpZCB0byBzdHJlYW0gdHlwZSBmb3IgbWV0YWRhdGEgc3RyZWFtc1xuICAgICAgICBzZWxmLnByb2dyYW1NYXBUYWJsZVsndGltZWQtbWV0YWRhdGEnXVtwaWRdID0gc3RyZWFtVHlwZTtcbiAgICAgIH1cblxuICAgICAgLy8gbW92ZSB0byB0aGUgbmV4dCB0YWJsZSBlbnRyeVxuICAgICAgLy8gc2tpcCBwYXN0IHRoZSBlbGVtZW50YXJ5IHN0cmVhbSBkZXNjcmlwdG9ycywgaWYgcHJlc2VudFxuICAgICAgb2Zmc2V0ICs9ICgocGF5bG9hZFtvZmZzZXQgKyAzXSAmIDB4MEYpIDw8IDggfCBwYXlsb2FkW29mZnNldCArIDRdKSArIDU7XG4gICAgfVxuXG4gICAgLy8gcmVjb3JkIHRoZSBtYXAgb24gdGhlIHBhY2tldCBhcyB3ZWxsXG4gICAgcG10LnByb2dyYW1NYXBUYWJsZSA9IHNlbGYucHJvZ3JhbU1hcFRhYmxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWxpdmVyIGEgbmV3IE1QMlQgcGFja2V0IHRvIHRoZSBzdHJlYW0uXG4gICAqL1xuICB0aGlzLnB1c2ggPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgICB2YXJcbiAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgb2Zmc2V0ID0gNDtcblxuICAgIHJlc3VsdC5wYXlsb2FkVW5pdFN0YXJ0SW5kaWNhdG9yID0gISEocGFja2V0WzFdICYgMHg0MCk7XG5cbiAgICAvLyBwaWQgaXMgYSAxMy1iaXQgZmllbGQgc3RhcnRpbmcgYXQgdGhlIGxhc3QgYml0IG9mIHBhY2tldFsxXVxuICAgIHJlc3VsdC5waWQgPSBwYWNrZXRbMV0gJiAweDFmO1xuICAgIHJlc3VsdC5waWQgPDw9IDg7XG4gICAgcmVzdWx0LnBpZCB8PSBwYWNrZXRbMl07XG5cbiAgICAvLyBpZiBhbiBhZGFwdGlvbiBmaWVsZCBpcyBwcmVzZW50LCBpdHMgbGVuZ3RoIGlzIHNwZWNpZmllZCBieSB0aGVcbiAgICAvLyBmaWZ0aCBieXRlIG9mIHRoZSBUUyBwYWNrZXQgaGVhZGVyLiBUaGUgYWRhcHRhdGlvbiBmaWVsZCBpc1xuICAgIC8vIHVzZWQgdG8gYWRkIHN0dWZmaW5nIHRvIFBFUyBwYWNrZXRzIHRoYXQgZG9uJ3QgZmlsbCBhIGNvbXBsZXRlXG4gICAgLy8gVFMgcGFja2V0LCBhbmQgdG8gc3BlY2lmeSBzb21lIGZvcm1zIG9mIHRpbWluZyBhbmQgY29udHJvbCBkYXRhXG4gICAgLy8gdGhhdCB3ZSBkbyBub3QgY3VycmVudGx5IHVzZS5cbiAgICBpZiAoKChwYWNrZXRbM10gJiAweDMwKSA+Pj4gNCkgPiAweDAxKSB7XG4gICAgICBvZmZzZXQgKz0gcGFja2V0W29mZnNldF0gKyAxO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIHRoZSByZXN0IG9mIHRoZSBwYWNrZXQgYmFzZWQgb24gdGhlIHR5cGVcbiAgICBpZiAocmVzdWx0LnBpZCA9PT0gMCkge1xuICAgICAgcmVzdWx0LnR5cGUgPSAncGF0JztcbiAgICAgIHBhcnNlUHNpKHBhY2tldC5zdWJhcnJheShvZmZzZXQpLCByZXN1bHQpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgcmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5waWQgPT09IHRoaXMucG10UGlkKSB7XG4gICAgICByZXN1bHQudHlwZSA9ICdwbXQnO1xuICAgICAgcGFyc2VQc2kocGFja2V0LnN1YmFycmF5KG9mZnNldCksIHJlc3VsdCk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCByZXN1bHQpO1xuXG4gICAgICAvLyBpZiB0aGVyZSBhcmUgYW55IHBhY2tldHMgd2FpdGluZyBmb3IgYSBQTVQgdG8gYmUgZm91bmQsIHByb2Nlc3MgdGhlbSBub3dcbiAgICAgIHdoaWxlICh0aGlzLnBhY2tldHNXYWl0aW5nRm9yUG10Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NQZXNfLmFwcGx5KHRoaXMsIHRoaXMucGFja2V0c1dhaXRpbmdGb3JQbXQuc2hpZnQoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb2dyYW1NYXBUYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBXaGVuIHdlIGhhdmUgbm90IHNlZW4gYSBQTVQgeWV0LCBkZWZlciBmdXJ0aGVyIHByb2Nlc3Npbmcgb2ZcbiAgICAgIC8vIFBFUyBwYWNrZXRzIHVudGlsIG9uZSBoYXMgYmVlbiBwYXJzZWRcbiAgICAgIHRoaXMucGFja2V0c1dhaXRpbmdGb3JQbXQucHVzaChbcGFja2V0LCBvZmZzZXQsIHJlc3VsdF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb2Nlc3NQZXNfKHBhY2tldCwgb2Zmc2V0LCByZXN1bHQpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLnByb2Nlc3NQZXNfID0gZnVuY3Rpb24ocGFja2V0LCBvZmZzZXQsIHJlc3VsdCkge1xuICAgIC8vIHNldCB0aGUgYXBwcm9wcmlhdGUgc3RyZWFtIHR5cGVcbiAgICBpZiAocmVzdWx0LnBpZCA9PT0gdGhpcy5wcm9ncmFtTWFwVGFibGUudmlkZW8pIHtcbiAgICAgIHJlc3VsdC5zdHJlYW1UeXBlID0gU3RyZWFtVHlwZXMuSDI2NF9TVFJFQU1fVFlQRTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5waWQgPT09IHRoaXMucHJvZ3JhbU1hcFRhYmxlLmF1ZGlvKSB7XG4gICAgICByZXN1bHQuc3RyZWFtVHlwZSA9IFN0cmVhbVR5cGVzLkFEVFNfU1RSRUFNX1RZUEU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIG5vdCB2aWRlbyBvciBhdWRpbywgaXQgaXMgdGltZWQtbWV0YWRhdGEgb3IgdW5rbm93blxuICAgICAgLy8gaWYgdW5rbm93biwgc3RyZWFtVHlwZSB3aWxsIGJlIHVuZGVmaW5lZFxuICAgICAgcmVzdWx0LnN0cmVhbVR5cGUgPSB0aGlzLnByb2dyYW1NYXBUYWJsZVsndGltZWQtbWV0YWRhdGEnXVtyZXN1bHQucGlkXTtcbiAgICB9XG5cbiAgICByZXN1bHQudHlwZSA9ICdwZXMnO1xuICAgIHJlc3VsdC5kYXRhID0gcGFja2V0LnN1YmFycmF5KG9mZnNldCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCByZXN1bHQpO1xuICB9O1xuXG59O1xuVHJhbnNwb3J0UGFyc2VTdHJlYW0ucHJvdG90eXBlID0gbmV3IFN0cmVhbSgpO1xuVHJhbnNwb3J0UGFyc2VTdHJlYW0uU1RSRUFNX1RZUEVTICA9IHtcbiAgaDI2NDogMHgxYixcbiAgYWR0czogMHgwZlxufTtcblxuLyoqXG4gKiBSZWNvbnNpc3R1dGVzIHByb2dyYW0gZWxlbWVudGFyeSBzdHJlYW0gKFBFUykgcGFja2V0cyBmcm9tIHBhcnNlZFxuICogdHJhbnNwb3J0IHN0cmVhbSBwYWNrZXRzLiBUaGF0IGlzLCBpZiB5b3UgcGlwZSBhblxuICogbXAydC5UcmFuc3BvcnRQYXJzZVN0cmVhbSBpbnRvIGEgbXAydC5FbGVtZW50YXJ5U3RyZWFtLCB0aGUgb3V0cHV0XG4gKiBldmVudHMgd2lsbCBiZSBldmVudHMgd2hpY2ggY2FwdHVyZSB0aGUgYnl0ZXMgZm9yIGluZGl2aWR1YWwgUEVTXG4gKiBwYWNrZXRzIHBsdXMgcmVsZXZhbnQgbWV0YWRhdGEgdGhhdCBoYXMgYmVlbiBleHRyYWN0ZWQgZnJvbSB0aGVcbiAqIGNvbnRhaW5lci5cbiAqL1xuRWxlbWVudGFyeVN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICB2YXJcbiAgICBzZWxmID0gdGhpcyxcbiAgICAvLyBQRVMgcGFja2V0IGZyYWdtZW50c1xuICAgIHZpZGVvID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBzaXplOiAwXG4gICAgfSxcbiAgICBhdWRpbyA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgc2l6ZTogMFxuICAgIH0sXG4gICAgdGltZWRNZXRhZGF0YSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgc2l6ZTogMFxuICAgIH0sXG4gICAgcGFyc2VQZXMgPSBmdW5jdGlvbihwYXlsb2FkLCBwZXMpIHtcbiAgICAgIHZhciBwdHNEdHNGbGFncztcblxuICAgICAgLy8gZ2V0IHRoZSBwYWNrZXQgbGVuZ3RoLCB0aGlzIHdpbGwgYmUgMCBmb3IgdmlkZW9cbiAgICAgIHBlcy5wYWNrZXRMZW5ndGggPSA2ICsgKChwYXlsb2FkWzRdIDw8IDgpIHwgcGF5bG9hZFs1XSk7XG5cbiAgICAgIC8vIGZpbmQgb3V0IGlmIHRoaXMgcGFja2V0cyBzdGFydHMgYSBuZXcga2V5ZnJhbWVcbiAgICAgIHBlcy5kYXRhQWxpZ25tZW50SW5kaWNhdG9yID0gKHBheWxvYWRbNl0gJiAweDA0KSAhPT0gMDtcbiAgICAgIC8vIFBFUyBwYWNrZXRzIG1heSBiZSBhbm5vdGF0ZWQgd2l0aCBhIFBUUyB2YWx1ZSwgb3IgYSBQVFMgdmFsdWVcbiAgICAgIC8vIGFuZCBhIERUUyB2YWx1ZS4gRGV0ZXJtaW5lIHdoYXQgY29tYmluYXRpb24gb2YgdmFsdWVzIGlzXG4gICAgICAvLyBhdmFpbGFibGUgdG8gd29yayB3aXRoLlxuICAgICAgcHRzRHRzRmxhZ3MgPSBwYXlsb2FkWzddO1xuXG4gICAgICAvLyBQVFMgYW5kIERUUyBhcmUgbm9ybWFsbHkgc3RvcmVkIGFzIGEgMzMtYml0IG51bWJlci4gIEphdmFzY3JpcHRcbiAgICAgIC8vIHBlcmZvcm1zIGFsbCBiaXR3aXNlIG9wZXJhdGlvbnMgb24gMzItYml0IGludGVnZXJzIGJ1dCBqYXZhc2NyaXB0XG4gICAgICAvLyBzdXBwb3J0cyBhIG11Y2ggZ3JlYXRlciByYW5nZSAoNTItYml0cykgb2YgaW50ZWdlciB1c2luZyBzdGFuZGFyZFxuICAgICAgLy8gbWF0aGVtYXRpY2FsIG9wZXJhdGlvbnMuXG4gICAgICAvLyBXZSBjb25zdHJ1Y3QgYSAzMS1iaXQgdmFsdWUgdXNpbmcgYml0d2lzZSBvcGVyYXRvcnMgb3ZlciB0aGUgMzFcbiAgICAgIC8vIG1vc3Qgc2lnbmlmaWNhbnQgYml0cyBhbmQgdGhlbiBtdWx0aXBseSBieSA0IChlcXVhbCB0byBhIGxlZnQtc2hpZnRcbiAgICAgIC8vIG9mIDIpIGJlZm9yZSB3ZSBhZGQgdGhlIGZpbmFsIDIgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyBvZiB0aGVcbiAgICAgIC8vIHRpbWVzdGFtcCAoZXF1YWwgdG8gYW4gT1IuKVxuICAgICAgaWYgKHB0c0R0c0ZsYWdzICYgMHhDMCkge1xuICAgICAgICAvLyB0aGUgUFRTIGFuZCBEVFMgYXJlIG5vdCB3cml0dGVuIG91dCBkaXJlY3RseS4gRm9yIGluZm9ybWF0aW9uXG4gICAgICAgIC8vIG9uIGhvdyB0aGV5IGFyZSBlbmNvZGVkLCBzZWVcbiAgICAgICAgLy8gaHR0cDovL2R2ZC5zb3VyY2Vmb3JnZS5uZXQvZHZkaW5mby9wZXMtaGRyLmh0bWxcbiAgICAgICAgcGVzLnB0cyA9IChwYXlsb2FkWzldICYgMHgwRSkgPDwgMjcgfFxuICAgICAgICAgIChwYXlsb2FkWzEwXSAmIDB4RkYpIDw8IDIwIHxcbiAgICAgICAgICAocGF5bG9hZFsxMV0gJiAweEZFKSA8PCAxMiB8XG4gICAgICAgICAgKHBheWxvYWRbMTJdICYgMHhGRikgPDwgIDUgfFxuICAgICAgICAgIChwYXlsb2FkWzEzXSAmIDB4RkUpID4+PiAgMztcbiAgICAgICAgcGVzLnB0cyAqPSA0OyAvLyBMZWZ0IHNoaWZ0IGJ5IDJcbiAgICAgICAgcGVzLnB0cyArPSAocGF5bG9hZFsxM10gJiAweDA2KSA+Pj4gMTsgLy8gT1IgYnkgdGhlIHR3byBMU0JzXG4gICAgICAgIHBlcy5kdHMgPSBwZXMucHRzO1xuICAgICAgICBpZiAocHRzRHRzRmxhZ3MgJiAweDQwKSB7XG4gICAgICAgICAgcGVzLmR0cyA9IChwYXlsb2FkWzE0XSAmIDB4MEUpIDw8IDI3IHxcbiAgICAgICAgICAgIChwYXlsb2FkWzE1XSAmIDB4RkYpIDw8IDIwIHxcbiAgICAgICAgICAgIChwYXlsb2FkWzE2XSAmIDB4RkUpIDw8IDEyIHxcbiAgICAgICAgICAgIChwYXlsb2FkWzE3XSAmIDB4RkYpIDw8IDUgfFxuICAgICAgICAgICAgKHBheWxvYWRbMThdICYgMHhGRSkgPj4+IDM7XG4gICAgICAgICAgcGVzLmR0cyAqPSA0OyAvLyBMZWZ0IHNoaWZ0IGJ5IDJcbiAgICAgICAgICBwZXMuZHRzICs9IChwYXlsb2FkWzE4XSAmIDB4MDYpID4+PiAxOyAvLyBPUiBieSB0aGUgdHdvIExTQnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gdGhlIGRhdGEgc2VjdGlvbiBzdGFydHMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIFBFUyBoZWFkZXIuXG4gICAgICAvLyBwZXNfaGVhZGVyX2RhdGFfbGVuZ3RoIHNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIGhlYWRlciBieXRlc1xuICAgICAgLy8gdGhhdCBmb2xsb3cgdGhlIGxhc3QgYnl0ZSBvZiB0aGUgZmllbGQuXG4gICAgICBwZXMuZGF0YSA9IHBheWxvYWQuc3ViYXJyYXkoOSArIHBheWxvYWRbOF0pO1xuICAgIH0sXG4gICAgZmx1c2hTdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0sIHR5cGUsIGZvcmNlRmx1c2gpIHtcbiAgICAgIHZhclxuICAgICAgICBwYWNrZXREYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpLFxuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgIH0sXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICBwYWNrZXRGbHVzaGFibGUgPSBmYWxzZSxcbiAgICAgICAgZnJhZ21lbnQ7XG5cbiAgICAgIC8vIGRvIG5vdGhpbmcgaWYgdGhlcmUgaXMgbm90IGVub3VnaCBidWZmZXJlZCBkYXRhIGZvciBhIGNvbXBsZXRlXG4gICAgICAvLyBQRVMgaGVhZGVyXG4gICAgICBpZiAoIXN0cmVhbS5kYXRhLmxlbmd0aCB8fCBzdHJlYW0uc2l6ZSA8IDkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQudHJhY2tJZCA9IHN0cmVhbS5kYXRhWzBdLnBpZDtcblxuICAgICAgLy8gcmVhc3NlbWJsZSB0aGUgcGFja2V0XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyZWFtLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZnJhZ21lbnQgPSBzdHJlYW0uZGF0YVtpXTtcblxuICAgICAgICBwYWNrZXREYXRhLnNldChmcmFnbWVudC5kYXRhLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gZnJhZ21lbnQuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSBhc3NlbWJsZWQgcGFja2V0J3MgUEVTIGhlYWRlclxuICAgICAgcGFyc2VQZXMocGFja2V0RGF0YSwgZXZlbnQpO1xuXG4gICAgICAvLyBub24tdmlkZW8gUEVTIHBhY2tldHMgTVVTVCBoYXZlIGEgbm9uLXplcm8gUEVTX3BhY2tldF9sZW5ndGhcbiAgICAgIC8vIGNoZWNrIHRoYXQgdGhlcmUgaXMgZW5vdWdoIHN0cmVhbSBkYXRhIHRvIGZpbGwgdGhlIHBhY2tldFxuICAgICAgcGFja2V0Rmx1c2hhYmxlID0gdHlwZSA9PT0gJ3ZpZGVvJyB8fCBldmVudC5wYWNrZXRMZW5ndGggPD0gc3RyZWFtLnNpemU7XG5cbiAgICAgIC8vIGZsdXNoIHBlbmRpbmcgcGFja2V0cyBpZiB0aGUgY29uZGl0aW9ucyBhcmUgcmlnaHRcbiAgICAgIGlmIChmb3JjZUZsdXNoIHx8IHBhY2tldEZsdXNoYWJsZSkge1xuICAgICAgICBzdHJlYW0uc2l6ZSA9IDA7XG4gICAgICAgIHN0cmVhbS5kYXRhLmxlbmd0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgZW1pdCBwYWNrZXRzIHRoYXQgYXJlIGNvbXBsZXRlLiB0aGlzIGlzIHRvIGF2b2lkIGFzc2VtYmxpbmdcbiAgICAgIC8vIGluY29tcGxldGUgUEVTIHBhY2tldHMgZHVlIHRvIHBvb3Igc2VnbWVudGF0aW9uXG4gICAgICBpZiAocGFja2V0Rmx1c2hhYmxlKSB7XG4gICAgICAgIHNlbGYudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIEVsZW1lbnRhcnlTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnB1c2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgKHtcbiAgICAgIHBhdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gd2FpdCBmb3IgdGhlIFBNVCB0byBhcnJpdmUgYXMgd2VsbCBiZWZvcmUgd2VcbiAgICAgICAgLy8gaGF2ZSBhbnkgbWVhbmluZ2Z1bCBtZXRhZGF0YVxuICAgICAgfSxcbiAgICAgIHBlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdHJlYW0sIHN0cmVhbVR5cGU7XG5cbiAgICAgICAgc3dpdGNoIChkYXRhLnN0cmVhbVR5cGUpIHtcbiAgICAgICAgY2FzZSBTdHJlYW1UeXBlcy5IMjY0X1NUUkVBTV9UWVBFOlxuICAgICAgICBjYXNlIG0ydHNTdHJlYW1UeXBlcy5IMjY0X1NUUkVBTV9UWVBFOlxuICAgICAgICAgIHN0cmVhbSA9IHZpZGVvO1xuICAgICAgICAgIHN0cmVhbVR5cGUgPSAndmlkZW8nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN0cmVhbVR5cGVzLkFEVFNfU1RSRUFNX1RZUEU6XG4gICAgICAgICAgc3RyZWFtID0gYXVkaW87XG4gICAgICAgICAgc3RyZWFtVHlwZSA9ICdhdWRpbyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3RyZWFtVHlwZXMuTUVUQURBVEFfU1RSRUFNX1RZUEU6XG4gICAgICAgICAgc3RyZWFtID0gdGltZWRNZXRhZGF0YTtcbiAgICAgICAgICBzdHJlYW1UeXBlID0gJ3RpbWVkLW1ldGFkYXRhJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBpZ25vcmUgdW5rbm93biBzdHJlYW0gdHlwZXNcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhIG5ldyBwYWNrZXQgaXMgc3RhcnRpbmcsIHdlIGNhbiBmbHVzaCB0aGUgY29tcGxldGVkXG4gICAgICAgIC8vIHBhY2tldFxuICAgICAgICBpZiAoZGF0YS5wYXlsb2FkVW5pdFN0YXJ0SW5kaWNhdG9yKSB7XG4gICAgICAgICAgZmx1c2hTdHJlYW0oc3RyZWFtLCBzdHJlYW1UeXBlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJ1ZmZlciB0aGlzIGZyYWdtZW50IHVudGlsIHdlIGFyZSBzdXJlIHdlJ3ZlIHJlY2VpdmVkIHRoZVxuICAgICAgICAvLyBjb21wbGV0ZSBwYXlsb2FkXG4gICAgICAgIHN0cmVhbS5kYXRhLnB1c2goZGF0YSk7XG4gICAgICAgIHN0cmVhbS5zaXplICs9IGRhdGEuZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgfSxcbiAgICAgIHBtdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogJ21ldGFkYXRhJyxcbiAgICAgICAgICAgIHRyYWNrczogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb2dyYW1NYXBUYWJsZSA9IGRhdGEucHJvZ3JhbU1hcFRhYmxlO1xuXG4gICAgICAgIC8vIHRyYW5zbGF0ZSBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtcyB0byB0cmFja3NcbiAgICAgICAgaWYgKHByb2dyYW1NYXBUYWJsZS52aWRlbyAhPT0gbnVsbCkge1xuICAgICAgICAgIGV2ZW50LnRyYWNrcy5wdXNoKHtcbiAgICAgICAgICAgIHRpbWVsaW5lU3RhcnRJbmZvOiB7XG4gICAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWU6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogK3Byb2dyYW1NYXBUYWJsZS52aWRlbyxcbiAgICAgICAgICAgIGNvZGVjOiAnYXZjJyxcbiAgICAgICAgICAgIHR5cGU6ICd2aWRlbydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3JhbU1hcFRhYmxlLmF1ZGlvICE9PSBudWxsKSB7XG4gICAgICAgICAgZXZlbnQudHJhY2tzLnB1c2goe1xuICAgICAgICAgICAgdGltZWxpbmVTdGFydEluZm86IHtcbiAgICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkOiArcHJvZ3JhbU1hcFRhYmxlLmF1ZGlvLFxuICAgICAgICAgICAgY29kZWM6ICdhZHRzJyxcbiAgICAgICAgICAgIHR5cGU6ICdhdWRpbydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KVtkYXRhLnR5cGVdKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZsdXNoIGFueSByZW1haW5pbmcgaW5wdXQuIFZpZGVvIFBFUyBwYWNrZXRzIG1heSBiZSBvZiB2YXJpYWJsZVxuICAgKiBsZW5ndGguIE5vcm1hbGx5LCB0aGUgc3RhcnQgb2YgYSBuZXcgdmlkZW8gcGFja2V0IGNhbiB0cmlnZ2VyIHRoZVxuICAgKiBmaW5hbGl6YXRpb24gb2YgdGhlIHByZXZpb3VzIHBhY2tldC4gVGhhdCBpcyBub3QgcG9zc2libGUgaWYgbm9cbiAgICogbW9yZSB2aWRlbyBpcyBmb3J0aGNvbWluZywgaG93ZXZlci4gSW4gdGhhdCBjYXNlLCBzb21lIG90aGVyXG4gICAqIG1lY2hhbmlzbSAobGlrZSB0aGUgZW5kIG9mIHRoZSBmaWxlKSBoYXMgdG8gYmUgZW1wbG95ZWQuIFdoZW4gaXQgaXNcbiAgICogY2xlYXIgdGhhdCBubyBhZGRpdGlvbmFsIGRhdGEgaXMgZm9ydGhjb21pbmcsIGNhbGxpbmcgdGhpcyBtZXRob2RcbiAgICogd2lsbCBmbHVzaCB0aGUgYnVmZmVyZWQgcGFja2V0cy5cbiAgICovXG4gIHRoaXMuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAvLyAhIVRISVMgT1JERVIgSVMgSU1QT1JUQU5UISFcbiAgICAvLyB2aWRlbyBmaXJzdCB0aGVuIGF1ZGlvXG4gICAgZmx1c2hTdHJlYW0odmlkZW8sICd2aWRlbycpO1xuICAgIGZsdXNoU3RyZWFtKGF1ZGlvLCAnYXVkaW8nKTtcbiAgICBmbHVzaFN0cmVhbSh0aW1lZE1ldGFkYXRhLCAndGltZWQtbWV0YWRhdGEnKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2RvbmUnKTtcbiAgfTtcbn07XG5FbGVtZW50YXJ5U3RyZWFtLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcblxudmFyIG0ydHMgPSB7XG4gIFBBVF9QSUQ6IDB4MDAwMCxcbiAgTVAyVF9QQUNLRVRfTEVOR1RIOiBNUDJUX1BBQ0tFVF9MRU5HVEgsXG4gIFRyYW5zcG9ydFBhY2tldFN0cmVhbTogVHJhbnNwb3J0UGFja2V0U3RyZWFtLFxuICBUcmFuc3BvcnRQYXJzZVN0cmVhbTogVHJhbnNwb3J0UGFyc2VTdHJlYW0sXG4gIEVsZW1lbnRhcnlTdHJlYW06IEVsZW1lbnRhcnlTdHJlYW0sXG4gIFRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtOiBUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSxcbiAgQ2FwdGlvblN0cmVhbTogQ2FwdGlvblN0cmVhbS5DYXB0aW9uU3RyZWFtLFxuICBDZWE2MDhTdHJlYW06IENhcHRpb25TdHJlYW0uQ2VhNjA4U3RyZWFtLFxuICBNZXRhZGF0YVN0cmVhbTogcmVxdWlyZSgnLi9tZXRhZGF0YS1zdHJlYW0nKVxufTtcblxuZm9yICh2YXIgdHlwZSBpbiBTdHJlYW1UeXBlcykge1xuICBpZiAoU3RyZWFtVHlwZXMuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICBtMnRzW3R5cGVdID0gU3RyZWFtVHlwZXNbdHlwZV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtMnRzO1xuXG59LHtcIi4uL3V0aWxzL3N0cmVhbS5qc1wiOjYyLFwiLi9jYXB0aW9uLXN0cmVhbVwiOjQ5LFwiLi9tZXRhZGF0YS1zdHJlYW1cIjo1MSxcIi4vc3RyZWFtLXR5cGVzXCI6NTMsXCIuL3N0cmVhbS10eXBlcy5qc1wiOjUzLFwiLi90aW1lc3RhbXAtcm9sbG92ZXItc3RyZWFtXCI6NTR9XSw1MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEFjY2VwdHMgcHJvZ3JhbSBlbGVtZW50YXJ5IHN0cmVhbSAoUEVTKSBkYXRhIGV2ZW50cyBhbmQgcGFyc2VzIG91dFxuICogSUQzIG1ldGFkYXRhIGZyb20gdGhlbSwgaWYgcHJlc2VudC5cbiAqIEBzZWUgaHR0cDovL2lkMy5vcmcvaWQzdjIuMy4wXG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhclxuICBTdHJlYW0gPSByZXF1aXJlKCcuLi91dGlscy9zdHJlYW0nKSxcbiAgU3RyZWFtVHlwZXMgPSByZXF1aXJlKCcuL3N0cmVhbS10eXBlcycpLFxuICAvLyByZXR1cm4gYSBwZXJjZW50LWVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCBieXRlIHJhbmdlXG4gIC8vIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QZXJjZW50LWVuY29kaW5nXG4gIHBlcmNlbnRFbmNvZGUgPSBmdW5jdGlvbihieXRlcywgc3RhcnQsIGVuZCkge1xuICAgIHZhciBpLCByZXN1bHQgPSAnJztcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gJyUnICsgKCcwMCcgKyBieXRlc1tpXS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgLy8gcmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCBieXRlIHJhbmdlLFxuICAvLyBpbnRlcnByZXRlZCBhcyBVVGYtOC5cbiAgcGFyc2VVdGY4ID0gZnVuY3Rpb24oYnl0ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBlcmNlbnRFbmNvZGUoYnl0ZXMsIHN0YXJ0LCBlbmQpKTtcbiAgfSxcbiAgLy8gcmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCBieXRlIHJhbmdlLFxuICAvLyBpbnRlcnByZXRlZCBhcyBJU08tODg1OS0xLlxuICBwYXJzZUlzbzg4NTkxID0gZnVuY3Rpb24oYnl0ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gdW5lc2NhcGUocGVyY2VudEVuY29kZShieXRlcywgc3RhcnQsIGVuZCkpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgfSxcbiAgcGFyc2VTeW5jU2FmZUludGVnZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIChkYXRhWzBdIDw8IDIxKSB8XG4gICAgICAgICAgICAoZGF0YVsxXSA8PCAxNCkgfFxuICAgICAgICAgICAgKGRhdGFbMl0gPDwgNykgfFxuICAgICAgICAgICAgKGRhdGFbM10pO1xuICB9LFxuICB0YWdQYXJzZXJzID0ge1xuICAgIFRYWFg6IGZ1bmN0aW9uKHRhZykge1xuICAgICAgdmFyIGk7XG4gICAgICBpZiAodGFnLmRhdGFbMF0gIT09IDMpIHtcbiAgICAgICAgLy8gaWdub3JlIGZyYW1lcyB3aXRoIHVucmVjb2duaXplZCBjaGFyYWN0ZXIgZW5jb2RpbmdzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMTsgaSA8IHRhZy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0YWcuZGF0YVtpXSA9PT0gMCkge1xuICAgICAgICAgIC8vIHBhcnNlIHRoZSB0ZXh0IGZpZWxkc1xuICAgICAgICAgIHRhZy5kZXNjcmlwdGlvbiA9IHBhcnNlVXRmOCh0YWcuZGF0YSwgMSwgaSk7XG4gICAgICAgICAgLy8gZG8gbm90IGluY2x1ZGUgdGhlIG51bGwgdGVybWluYXRvciBpbiB0aGUgdGFnIHZhbHVlXG4gICAgICAgICAgdGFnLnZhbHVlID0gcGFyc2VVdGY4KHRhZy5kYXRhLCBpICsgMSwgdGFnLmRhdGEubGVuZ3RoKS5yZXBsYWNlKC9cXDAqJC8sICcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGFnLmRhdGEgPSB0YWcudmFsdWU7XG4gICAgfSxcbiAgICBXWFhYOiBmdW5jdGlvbih0YWcpIHtcbiAgICAgIHZhciBpO1xuICAgICAgaWYgKHRhZy5kYXRhWzBdICE9PSAzKSB7XG4gICAgICAgIC8vIGlnbm9yZSBmcmFtZXMgd2l0aCB1bnJlY29nbml6ZWQgY2hhcmFjdGVyIGVuY29kaW5nc1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPCB0YWcuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGFnLmRhdGFbaV0gPT09IDApIHtcbiAgICAgICAgICAvLyBwYXJzZSB0aGUgZGVzY3JpcHRpb24gYW5kIFVSTCBmaWVsZHNcbiAgICAgICAgICB0YWcuZGVzY3JpcHRpb24gPSBwYXJzZVV0ZjgodGFnLmRhdGEsIDEsIGkpO1xuICAgICAgICAgIHRhZy51cmwgPSBwYXJzZVV0ZjgodGFnLmRhdGEsIGkgKyAxLCB0YWcuZGF0YS5sZW5ndGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBQUklWOiBmdW5jdGlvbih0YWcpIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGFnLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRhZy5kYXRhW2ldID09PSAwKSB7XG4gICAgICAgICAgLy8gcGFyc2UgdGhlIGRlc2NyaXB0aW9uIGFuZCBVUkwgZmllbGRzXG4gICAgICAgICAgdGFnLm93bmVyID0gcGFyc2VJc284ODU5MSh0YWcuZGF0YSwgMCwgaSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRhZy5wcml2YXRlRGF0YSA9IHRhZy5kYXRhLnN1YmFycmF5KGkgKyAxKTtcbiAgICAgIHRhZy5kYXRhID0gdGFnLnByaXZhdGVEYXRhO1xuICAgIH1cbiAgfSxcbiAgTWV0YWRhdGFTdHJlYW07XG5cbk1ldGFkYXRhU3RyZWFtID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXJcbiAgICBzZXR0aW5ncyA9IHtcbiAgICAgIGRlYnVnOiAhIShvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpLFxuXG4gICAgICAvLyB0aGUgYnl0ZXMgb2YgdGhlIHByb2dyYW0tbGV2ZWwgZGVzY3JpcHRvciBmaWVsZCBpbiBNUDJUXG4gICAgICAvLyBzZWUgSVNPL0lFQyAxMzgxOC0xOjIwMTMgKEUpLCBzZWN0aW9uIDIuNiBcIlByb2dyYW0gYW5kXG4gICAgICAvLyBwcm9ncmFtIGVsZW1lbnQgZGVzY3JpcHRvcnNcIlxuICAgICAgZGVzY3JpcHRvcjogb3B0aW9ucyAmJiBvcHRpb25zLmRlc2NyaXB0b3JcbiAgICB9LFxuICAgIC8vIHRoZSB0b3RhbCBzaXplIGluIGJ5dGVzIG9mIHRoZSBJRDMgdGFnIGJlaW5nIHBhcnNlZFxuICAgIHRhZ1NpemUgPSAwLFxuICAgIC8vIHRhZyBkYXRhIHRoYXQgaXMgbm90IGNvbXBsZXRlIGVub3VnaCB0byBiZSBwYXJzZWRcbiAgICBidWZmZXIgPSBbXSxcbiAgICAvLyB0aGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyXG4gICAgYnVmZmVyU2l6ZSA9IDAsXG4gICAgaTtcblxuICBNZXRhZGF0YVN0cmVhbS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgdGV4dCB0cmFjayBpbi1iYW5kIG1ldGFkYXRhIHRyYWNrIGRpc3BhdGNoIHR5cGVcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3N0ZXBzLXRvLWV4cG9zZS1hLW1lZGlhLXJlc291cmNlLXNwZWNpZmljLXRleHQtdHJhY2tcbiAgdGhpcy5kaXNwYXRjaFR5cGUgPSBTdHJlYW1UeXBlcy5NRVRBREFUQV9TVFJFQU1fVFlQRS50b1N0cmluZygxNik7XG4gIGlmIChzZXR0aW5ncy5kZXNjcmlwdG9yKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHNldHRpbmdzLmRlc2NyaXB0b3IubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUeXBlICs9ICgnMDAnICsgc2V0dGluZ3MuZGVzY3JpcHRvcltpXS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnB1c2ggPSBmdW5jdGlvbihjaHVuaykge1xuICAgIHZhciB0YWcsIGZyYW1lU3RhcnQsIGZyYW1lU2l6ZSwgZnJhbWUsIGksIGZyYW1lSGVhZGVyO1xuICAgIGlmIChjaHVuay50eXBlICE9PSAndGltZWQtbWV0YWRhdGEnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgZGF0YV9hbGlnbm1lbnRfaW5kaWNhdG9yIGlzIHNldCBpbiB0aGUgUEVTIGhlYWRlcixcbiAgICAvLyB3ZSBtdXN0IGhhdmUgdGhlIHN0YXJ0IG9mIGEgbmV3IElEMyB0YWcuIEFzc3VtZSBhbnl0aGluZ1xuICAgIC8vIHJlbWFpbmluZyBpbiB0aGUgYnVmZmVyIHdhcyBtYWxmb3JtZWQgYW5kIHRocm93IGl0IG91dFxuICAgIGlmIChjaHVuay5kYXRhQWxpZ25tZW50SW5kaWNhdG9yKSB7XG4gICAgICBidWZmZXJTaXplID0gMDtcbiAgICAgIGJ1ZmZlci5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIC8vIGlnbm9yZSBldmVudHMgdGhhdCBkb24ndCBsb29rIGxpa2UgSUQzIGRhdGFcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAoY2h1bmsuZGF0YS5sZW5ndGggPCAxMCB8fFxuICAgICAgICAgIGNodW5rLmRhdGFbMF0gIT09ICdJJy5jaGFyQ29kZUF0KDApIHx8XG4gICAgICAgICAgY2h1bmsuZGF0YVsxXSAhPT0gJ0QnLmNoYXJDb2RlQXQoMCkgfHxcbiAgICAgICAgICBjaHVuay5kYXRhWzJdICE9PSAnMycuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIGlmIChzZXR0aW5ncy5kZWJ1Zykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmxvZygnU2tpcHBpbmcgdW5yZWNvZ25pemVkIG1ldGFkYXRhIHBhY2tldCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFkZCB0aGlzIGNodW5rIHRvIHRoZSBkYXRhIHdlJ3ZlIGNvbGxlY3RlZCBzbyBmYXJcblxuICAgIGJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICBidWZmZXJTaXplICs9IGNodW5rLmRhdGEuYnl0ZUxlbmd0aDtcblxuICAgIC8vIGdyYWIgdGhlIHNpemUgb2YgdGhlIGVudGlyZSBmcmFtZSBmcm9tIHRoZSBJRDMgaGVhZGVyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIHRoZSBmcmFtZSBzaXplIGlzIHRyYW5zbWl0dGVkIGFzIGEgMjgtYml0IGludGVnZXIgaW4gdGhlXG4gICAgICAvLyBsYXN0IGZvdXIgYnl0ZXMgb2YgdGhlIElEMyBoZWFkZXIuXG4gICAgICAvLyBUaGUgbW9zdCBzaWduaWZpY2FudCBiaXQgb2YgZWFjaCBieXRlIGlzIGRyb3BwZWQgYW5kIHRoZVxuICAgICAgLy8gcmVzdWx0cyBjb25jYXRlbmF0ZWQgdG8gcmVjb3ZlciB0aGUgYWN0dWFsIHZhbHVlLlxuICAgICAgdGFnU2l6ZSA9IHBhcnNlU3luY1NhZmVJbnRlZ2VyKGNodW5rLmRhdGEuc3ViYXJyYXkoNiwgMTApKTtcblxuICAgICAgLy8gSUQzIHJlcG9ydHMgdGhlIHRhZyBzaXplIGV4Y2x1ZGluZyB0aGUgaGVhZGVyIGJ1dCBpdCdzIG1vcmVcbiAgICAgIC8vIGNvbnZlbmllbnQgZm9yIG91ciBjb21wYXJpc29ucyB0byBpbmNsdWRlIGl0XG4gICAgICB0YWdTaXplICs9IDEwO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBlbnRpcmUgZnJhbWUgaGFzIG5vdCBhcnJpdmVkLCB3YWl0IGZvciBtb3JlIGRhdGFcbiAgICBpZiAoYnVmZmVyU2l6ZSA8IHRhZ1NpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjb2xsZWN0IHRoZSBlbnRpcmUgZnJhbWUgc28gaXQgY2FuIGJlIHBhcnNlZFxuICAgIHRhZyA9IHtcbiAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KHRhZ1NpemUpLFxuICAgICAgZnJhbWVzOiBbXSxcbiAgICAgIHB0czogYnVmZmVyWzBdLnB0cyxcbiAgICAgIGR0czogYnVmZmVyWzBdLmR0c1xuICAgIH07XG4gICAgZm9yIChpID0gMDsgaSA8IHRhZ1NpemU7KSB7XG4gICAgICB0YWcuZGF0YS5zZXQoYnVmZmVyWzBdLmRhdGEuc3ViYXJyYXkoMCwgdGFnU2l6ZSAtIGkpLCBpKTtcbiAgICAgIGkgKz0gYnVmZmVyWzBdLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIGJ1ZmZlclNpemUgLT0gYnVmZmVyWzBdLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIGJ1ZmZlci5zaGlmdCgpO1xuICAgIH1cblxuICAgIC8vIGZpbmQgdGhlIHN0YXJ0IG9mIHRoZSBmaXJzdCBmcmFtZSBhbmQgdGhlIGVuZCBvZiB0aGUgdGFnXG4gICAgZnJhbWVTdGFydCA9IDEwO1xuICAgIGlmICh0YWcuZGF0YVs1XSAmIDB4NDApIHtcbiAgICAgIC8vIGFkdmFuY2UgdGhlIGZyYW1lIHN0YXJ0IHBhc3QgdGhlIGV4dGVuZGVkIGhlYWRlclxuICAgICAgZnJhbWVTdGFydCArPSA0OyAvLyBoZWFkZXIgc2l6ZSBmaWVsZFxuICAgICAgZnJhbWVTdGFydCArPSBwYXJzZVN5bmNTYWZlSW50ZWdlcih0YWcuZGF0YS5zdWJhcnJheSgxMCwgMTQpKTtcblxuICAgICAgLy8gY2xpcCBhbnkgcGFkZGluZyBvZmYgdGhlIGVuZFxuICAgICAgdGFnU2l6ZSAtPSBwYXJzZVN5bmNTYWZlSW50ZWdlcih0YWcuZGF0YS5zdWJhcnJheSgxNiwgMjApKTtcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBvbmUgb3IgbW9yZSBJRDMgZnJhbWVzXG4gICAgLy8gaHR0cDovL2lkMy5vcmcvaWQzdjIuMy4wI0lEM3YyX2ZyYW1lX292ZXJ2aWV3XG4gICAgZG8ge1xuICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBmcmFtZVxuICAgICAgZnJhbWVTaXplID0gcGFyc2VTeW5jU2FmZUludGVnZXIodGFnLmRhdGEuc3ViYXJyYXkoZnJhbWVTdGFydCArIDQsIGZyYW1lU3RhcnQgKyA4KSk7XG4gICAgICBpZiAoZnJhbWVTaXplIDwgMSkge1xuICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKCdNYWxmb3JtZWQgSUQzIGZyYW1lIGVuY291bnRlcmVkLiBTa2lwcGluZyBtZXRhZGF0YSBwYXJzaW5nLicpO1xuICAgICAgfVxuICAgICAgZnJhbWVIZWFkZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRhZy5kYXRhW2ZyYW1lU3RhcnRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZy5kYXRhW2ZyYW1lU3RhcnQgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcuZGF0YVtmcmFtZVN0YXJ0ICsgMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnLmRhdGFbZnJhbWVTdGFydCArIDNdKTtcblxuXG4gICAgICBmcmFtZSA9IHtcbiAgICAgICAgaWQ6IGZyYW1lSGVhZGVyLFxuICAgICAgICBkYXRhOiB0YWcuZGF0YS5zdWJhcnJheShmcmFtZVN0YXJ0ICsgMTAsIGZyYW1lU3RhcnQgKyBmcmFtZVNpemUgKyAxMClcbiAgICAgIH07XG4gICAgICBmcmFtZS5rZXkgPSBmcmFtZS5pZDtcbiAgICAgIGlmICh0YWdQYXJzZXJzW2ZyYW1lLmlkXSkge1xuICAgICAgICB0YWdQYXJzZXJzW2ZyYW1lLmlkXShmcmFtZSk7XG5cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBzcGVjaWFsIFBSSVYgZnJhbWUgdXNlZCB0byBpbmRpY2F0ZSB0aGUgc3RhcnRcbiAgICAgICAgLy8gdGltZSBmb3IgcmF3IEFBQyBkYXRhXG4gICAgICAgIGlmIChmcmFtZS5vd25lciA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJykge1xuICAgICAgICAgIHZhclxuICAgICAgICAgICAgZCA9IGZyYW1lLmRhdGEsXG4gICAgICAgICAgICBzaXplID0gKChkWzNdICYgMHgwMSkgIDw8IDMwKSB8XG4gICAgICAgICAgICAgICAgICAgKGRbNF0gIDw8IDIyKSB8XG4gICAgICAgICAgICAgICAgICAgKGRbNV0gPDwgMTQpIHxcbiAgICAgICAgICAgICAgICAgICAoZFs2XSA8PCA2KSB8XG4gICAgICAgICAgICAgICAgICAgKGRbN10gPj4+IDIpO1xuXG4gICAgICAgICAgc2l6ZSAqPSA0O1xuICAgICAgICAgIHNpemUgKz0gZFs3XSAmIDB4MDM7XG4gICAgICAgICAgZnJhbWUudGltZVN0YW1wID0gc2l6ZTtcbiAgICAgICAgICAvLyBpbiByYXcgQUFDLCBhbGwgc3Vic2VxdWVudCBkYXRhIHdpbGwgYmUgdGltZXN0YW1wZWQgYmFzZWRcbiAgICAgICAgICAvLyBvbiB0aGUgdmFsdWUgb2YgdGhpcyBmcmFtZVxuICAgICAgICAgIC8vIHdlIGNvdWxkbid0IGhhdmUga25vd24gdGhlIGFwcHJvcHJpYXRlIHB0cyBhbmQgZHRzIGJlZm9yZVxuICAgICAgICAgIC8vIHBhcnNpbmcgdGhpcyBJRDMgdGFnIHNvIHNldCB0aG9zZSB2YWx1ZXMgbm93XG4gICAgICAgICAgaWYgKHRhZy5wdHMgPT09IHVuZGVmaW5lZCAmJiB0YWcuZHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRhZy5wdHMgPSBmcmFtZS50aW1lU3RhbXA7XG4gICAgICAgICAgICB0YWcuZHRzID0gZnJhbWUudGltZVN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RpbWVzdGFtcCcsIGZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGFnLmZyYW1lcy5wdXNoKGZyYW1lKTtcblxuICAgICAgZnJhbWVTdGFydCArPSAxMDsgLy8gYWR2YW5jZSBwYXN0IHRoZSBmcmFtZSBoZWFkZXJcbiAgICAgIGZyYW1lU3RhcnQgKz0gZnJhbWVTaXplOyAvLyBhZHZhbmNlIHBhc3QgdGhlIGZyYW1lIGJvZHlcbiAgICB9IHdoaWxlIChmcmFtZVN0YXJ0IDwgdGFnU2l6ZSk7XG4gICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgdGFnKTtcbiAgfTtcbn07XG5NZXRhZGF0YVN0cmVhbS5wcm90b3R5cGUgPSBuZXcgU3RyZWFtKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWV0YWRhdGFTdHJlYW07XG5cbn0se1wiLi4vdXRpbHMvc3RyZWFtXCI6NjIsXCIuL3N0cmVhbS10eXBlc1wiOjUzfV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBtdXguanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgQnJpZ2h0Y292ZVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBVdGlsaXRpZXMgdG8gZGV0ZWN0IGJhc2ljIHByb3BlcnRpZXMgYW5kIG1ldGFkYXRhIGFib3V0IFRTIFNlZ21lbnRzLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTdHJlYW1UeXBlcyA9IHJlcXVpcmUoJy4vc3RyZWFtLXR5cGVzLmpzJyk7XG5cbnZhciBwYXJzZVBpZCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB2YXIgcGlkID0gcGFja2V0WzFdICYgMHgxZjtcbiAgcGlkIDw8PSA4O1xuICBwaWQgfD0gcGFja2V0WzJdO1xuICByZXR1cm4gcGlkO1xufTtcblxudmFyIHBhcnNlUGF5bG9hZFVuaXRTdGFydEluZGljYXRvciA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICByZXR1cm4gISEocGFja2V0WzFdICYgMHg0MCk7XG59O1xuXG52YXIgcGFyc2VBZGFwdGlvbkZpZWxkID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBvZmZzZXQgPSAwO1xuICAvLyBpZiBhbiBhZGFwdGlvbiBmaWVsZCBpcyBwcmVzZW50LCBpdHMgbGVuZ3RoIGlzIHNwZWNpZmllZCBieSB0aGVcbiAgLy8gZmlmdGggYnl0ZSBvZiB0aGUgVFMgcGFja2V0IGhlYWRlci4gVGhlIGFkYXB0YXRpb24gZmllbGQgaXNcbiAgLy8gdXNlZCB0byBhZGQgc3R1ZmZpbmcgdG8gUEVTIHBhY2tldHMgdGhhdCBkb24ndCBmaWxsIGEgY29tcGxldGVcbiAgLy8gVFMgcGFja2V0LCBhbmQgdG8gc3BlY2lmeSBzb21lIGZvcm1zIG9mIHRpbWluZyBhbmQgY29udHJvbCBkYXRhXG4gIC8vIHRoYXQgd2UgZG8gbm90IGN1cnJlbnRseSB1c2UuXG4gIGlmICgoKHBhY2tldFszXSAmIDB4MzApID4+PiA0KSA+IDB4MDEpIHtcbiAgICBvZmZzZXQgKz0gcGFja2V0WzRdICsgMTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0O1xufTtcblxudmFyIHBhcnNlVHlwZSA9IGZ1bmN0aW9uKHBhY2tldCwgcG10UGlkKSB7XG4gIHZhciBwaWQgPSBwYXJzZVBpZChwYWNrZXQpO1xuICBpZiAocGlkID09PSAwKSB7XG4gICAgcmV0dXJuICdwYXQnO1xuICB9IGVsc2UgaWYgKHBpZCA9PT0gcG10UGlkKSB7XG4gICAgcmV0dXJuICdwbXQnO1xuICB9IGVsc2UgaWYgKHBtdFBpZCkge1xuICAgIHJldHVybiAncGVzJztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBwYXJzZVBhdCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB2YXIgcHVzaSA9IHBhcnNlUGF5bG9hZFVuaXRTdGFydEluZGljYXRvcihwYWNrZXQpO1xuICB2YXIgb2Zmc2V0ID0gNCArIHBhcnNlQWRhcHRpb25GaWVsZChwYWNrZXQpO1xuXG4gIGlmIChwdXNpKSB7XG4gICAgb2Zmc2V0ICs9IHBhY2tldFtvZmZzZXRdICsgMTtcbiAgfVxuXG4gIHJldHVybiAocGFja2V0W29mZnNldCArIDEwXSAmIDB4MWYpIDw8IDggfCBwYWNrZXRbb2Zmc2V0ICsgMTFdO1xufTtcblxudmFyIHBhcnNlUG10ID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBwcm9ncmFtTWFwVGFibGUgPSB7fTtcbiAgdmFyIHB1c2kgPSBwYXJzZVBheWxvYWRVbml0U3RhcnRJbmRpY2F0b3IocGFja2V0KTtcbiAgdmFyIHBheWxvYWRPZmZzZXQgPSA0ICsgcGFyc2VBZGFwdGlvbkZpZWxkKHBhY2tldCk7XG5cbiAgaWYgKHB1c2kpIHtcbiAgICBwYXlsb2FkT2Zmc2V0ICs9IHBhY2tldFtwYXlsb2FkT2Zmc2V0XSArIDE7XG4gIH1cblxuICAvLyBQTVRzIGNhbiBiZSBzZW50IGFoZWFkIG9mIHRoZSB0aW1lIHdoZW4gdGhleSBzaG91bGQgYWN0dWFsbHlcbiAgLy8gdGFrZSBlZmZlY3QuIFdlIGRvbid0IGJlbGlldmUgdGhpcyBzaG91bGQgZXZlciBiZSB0aGUgY2FzZVxuICAvLyBmb3IgSExTIGJ1dCB3ZSdsbCBpZ25vcmUgXCJmb3J3YXJkXCIgUE1UIGRlY2xhcmF0aW9ucyBpZiB3ZSBzZWVcbiAgLy8gdGhlbS4gRnV0dXJlIFBNVCBkZWNsYXJhdGlvbnMgaGF2ZSB0aGUgY3VycmVudF9uZXh0X2luZGljYXRvclxuICAvLyBzZXQgdG8gemVyby5cbiAgaWYgKCEocGFja2V0W3BheWxvYWRPZmZzZXQgKyA1XSAmIDB4MDEpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlY3Rpb25MZW5ndGgsIHRhYmxlRW5kLCBwcm9ncmFtSW5mb0xlbmd0aDtcbiAgLy8gdGhlIG1hcHBpbmcgdGFibGUgZW5kcyBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHNlY3Rpb25cbiAgc2VjdGlvbkxlbmd0aCA9IChwYWNrZXRbcGF5bG9hZE9mZnNldCArIDFdICYgMHgwZikgPDwgOCB8IHBhY2tldFtwYXlsb2FkT2Zmc2V0ICsgMl07XG4gIHRhYmxlRW5kID0gMyArIHNlY3Rpb25MZW5ndGggLSA0O1xuXG4gIC8vIHRvIGRldGVybWluZSB3aGVyZSB0aGUgdGFibGUgaXMsIHdlIGhhdmUgdG8gZmlndXJlIG91dCBob3dcbiAgLy8gbG9uZyB0aGUgcHJvZ3JhbSBpbmZvIGRlc2NyaXB0b3JzIGFyZVxuICBwcm9ncmFtSW5mb0xlbmd0aCA9IChwYWNrZXRbcGF5bG9hZE9mZnNldCArIDEwXSAmIDB4MGYpIDw8IDggfCBwYWNrZXRbcGF5bG9hZE9mZnNldCArIDExXTtcblxuICAvLyBhZHZhbmNlIHRoZSBvZmZzZXQgdG8gdGhlIGZpcnN0IGVudHJ5IGluIHRoZSBtYXBwaW5nIHRhYmxlXG4gIHZhciBvZmZzZXQgPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuICB3aGlsZSAob2Zmc2V0IDwgdGFibGVFbmQpIHtcbiAgICB2YXIgaSA9IHBheWxvYWRPZmZzZXQgKyBvZmZzZXQ7XG4gICAgLy8gYWRkIGFuIGVudHJ5IHRoYXQgbWFwcyB0aGUgZWxlbWVudGFyeV9waWQgdG8gdGhlIHN0cmVhbV90eXBlXG4gICAgcHJvZ3JhbU1hcFRhYmxlWyhwYWNrZXRbaSArIDFdICYgMHgxRikgPDwgOCB8IHBhY2tldFtpICsgMl1dID0gcGFja2V0W2ldO1xuXG4gICAgLy8gbW92ZSB0byB0aGUgbmV4dCB0YWJsZSBlbnRyeVxuICAgIC8vIHNraXAgcGFzdCB0aGUgZWxlbWVudGFyeSBzdHJlYW0gZGVzY3JpcHRvcnMsIGlmIHByZXNlbnRcbiAgICBvZmZzZXQgKz0gKChwYWNrZXRbaSArIDNdICYgMHgwRikgPDwgOCB8IHBhY2tldFtpICsgNF0pICsgNTtcbiAgfVxuICByZXR1cm4gcHJvZ3JhbU1hcFRhYmxlO1xufTtcblxudmFyIHBhcnNlUGVzVHlwZSA9IGZ1bmN0aW9uKHBhY2tldCwgcHJvZ3JhbU1hcFRhYmxlKSB7XG4gIHZhciBwaWQgPSBwYXJzZVBpZChwYWNrZXQpO1xuICB2YXIgdHlwZSA9IHByb2dyYW1NYXBUYWJsZVtwaWRdO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFN0cmVhbVR5cGVzLkgyNjRfU1RSRUFNX1RZUEU6XG4gICAgICByZXR1cm4gJ3ZpZGVvJztcbiAgICBjYXNlIFN0cmVhbVR5cGVzLkFEVFNfU1RSRUFNX1RZUEU6XG4gICAgICByZXR1cm4gJ2F1ZGlvJztcbiAgICBjYXNlIFN0cmVhbVR5cGVzLk1FVEFEQVRBX1NUUkVBTV9UWVBFOlxuICAgICAgcmV0dXJuICd0aW1lZC1tZXRhZGF0YSc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG52YXIgcGFyc2VQZXNUaW1lID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHZhciBwdXNpID0gcGFyc2VQYXlsb2FkVW5pdFN0YXJ0SW5kaWNhdG9yKHBhY2tldCk7XG4gIGlmICghcHVzaSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG9mZnNldCA9IDQgKyBwYXJzZUFkYXB0aW9uRmllbGQocGFja2V0KTtcblxuICBpZiAob2Zmc2V0ID49IHBhY2tldC5ieXRlTGVuZ3RoKSB7XG4gICAgLy8gRnJvbSB0aGUgSCAyMjIuMCBNUEVHLVRTIHNwZWNcbiAgICAvLyBcIkZvciB0cmFuc3BvcnQgc3RyZWFtIHBhY2tldHMgY2FycnlpbmcgUEVTIHBhY2tldHMsIHN0dWZmaW5nIGlzIG5lZWRlZCB3aGVuIHRoZXJlXG4gICAgLy8gIGlzIGluc3VmZmljaWVudCBQRVMgcGFja2V0IGRhdGEgdG8gY29tcGxldGVseSBmaWxsIHRoZSB0cmFuc3BvcnQgc3RyZWFtIHBhY2tldFxuICAgIC8vICBwYXlsb2FkIGJ5dGVzLiBTdHVmZmluZyBpcyBhY2NvbXBsaXNoZWQgYnkgZGVmaW5pbmcgYW4gYWRhcHRhdGlvbiBmaWVsZCBsb25nZXIgdGhhblxuICAgIC8vICB0aGUgc3VtIG9mIHRoZSBsZW5ndGhzIG9mIHRoZSBkYXRhIGVsZW1lbnRzIGluIGl0LCBzbyB0aGF0IHRoZSBwYXlsb2FkIGJ5dGVzXG4gICAgLy8gIHJlbWFpbmluZyBhZnRlciB0aGUgYWRhcHRhdGlvbiBmaWVsZCBleGFjdGx5IGFjY29tbW9kYXRlcyB0aGUgYXZhaWxhYmxlIFBFUyBwYWNrZXRcbiAgICAvLyAgZGF0YS5cIlxuICAgIC8vXG4gICAgLy8gSWYgdGhlIG9mZnNldCBpcyA+PSB0aGUgbGVuZ3RoIG9mIHRoZSBwYWNrZXQsIHRoZW4gdGhlIHBhY2tldCBjb250YWlucyBubyBkYXRhXG4gICAgLy8gYW5kIGluc3RlYWQgaXMganVzdCBhZGFwdGlvbiBmaWVsZCBzdHVmZmluZyBieXRlc1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHBlcyA9IG51bGw7XG4gIHZhciBwdHNEdHNGbGFncztcblxuICAvLyBQRVMgcGFja2V0cyBtYXkgYmUgYW5ub3RhdGVkIHdpdGggYSBQVFMgdmFsdWUsIG9yIGEgUFRTIHZhbHVlXG4gIC8vIGFuZCBhIERUUyB2YWx1ZS4gRGV0ZXJtaW5lIHdoYXQgY29tYmluYXRpb24gb2YgdmFsdWVzIGlzXG4gIC8vIGF2YWlsYWJsZSB0byB3b3JrIHdpdGguXG4gIHB0c0R0c0ZsYWdzID0gcGFja2V0W29mZnNldCArIDddO1xuXG4gIC8vIFBUUyBhbmQgRFRTIGFyZSBub3JtYWxseSBzdG9yZWQgYXMgYSAzMy1iaXQgbnVtYmVyLiAgSmF2YXNjcmlwdFxuICAvLyBwZXJmb3JtcyBhbGwgYml0d2lzZSBvcGVyYXRpb25zIG9uIDMyLWJpdCBpbnRlZ2VycyBidXQgamF2YXNjcmlwdFxuICAvLyBzdXBwb3J0cyBhIG11Y2ggZ3JlYXRlciByYW5nZSAoNTItYml0cykgb2YgaW50ZWdlciB1c2luZyBzdGFuZGFyZFxuICAvLyBtYXRoZW1hdGljYWwgb3BlcmF0aW9ucy5cbiAgLy8gV2UgY29uc3RydWN0IGEgMzEtYml0IHZhbHVlIHVzaW5nIGJpdHdpc2Ugb3BlcmF0b3JzIG92ZXIgdGhlIDMxXG4gIC8vIG1vc3Qgc2lnbmlmaWNhbnQgYml0cyBhbmQgdGhlbiBtdWx0aXBseSBieSA0IChlcXVhbCB0byBhIGxlZnQtc2hpZnRcbiAgLy8gb2YgMikgYmVmb3JlIHdlIGFkZCB0aGUgZmluYWwgMiBsZWFzdCBzaWduaWZpY2FudCBiaXRzIG9mIHRoZVxuICAvLyB0aW1lc3RhbXAgKGVxdWFsIHRvIGFuIE9SLilcbiAgaWYgKHB0c0R0c0ZsYWdzICYgMHhDMCkge1xuICAgIHBlcyA9IHt9O1xuICAgIC8vIHRoZSBQVFMgYW5kIERUUyBhcmUgbm90IHdyaXR0ZW4gb3V0IGRpcmVjdGx5LiBGb3IgaW5mb3JtYXRpb25cbiAgICAvLyBvbiBob3cgdGhleSBhcmUgZW5jb2RlZCwgc2VlXG4gICAgLy8gaHR0cDovL2R2ZC5zb3VyY2Vmb3JnZS5uZXQvZHZkaW5mby9wZXMtaGRyLmh0bWxcbiAgICBwZXMucHRzID0gKHBhY2tldFtvZmZzZXQgKyA5XSAmIDB4MEUpIDw8IDI3IHxcbiAgICAgIChwYWNrZXRbb2Zmc2V0ICsgMTBdICYgMHhGRikgPDwgMjAgfFxuICAgICAgKHBhY2tldFtvZmZzZXQgKyAxMV0gJiAweEZFKSA8PCAxMiB8XG4gICAgICAocGFja2V0W29mZnNldCArIDEyXSAmIDB4RkYpIDw8ICA1IHxcbiAgICAgIChwYWNrZXRbb2Zmc2V0ICsgMTNdICYgMHhGRSkgPj4+ICAzO1xuICAgIHBlcy5wdHMgKj0gNDsgLy8gTGVmdCBzaGlmdCBieSAyXG4gICAgcGVzLnB0cyArPSAocGFja2V0W29mZnNldCArIDEzXSAmIDB4MDYpID4+PiAxOyAvLyBPUiBieSB0aGUgdHdvIExTQnNcbiAgICBwZXMuZHRzID0gcGVzLnB0cztcbiAgICBpZiAocHRzRHRzRmxhZ3MgJiAweDQwKSB7XG4gICAgICBwZXMuZHRzID0gKHBhY2tldFtvZmZzZXQgKyAxNF0gJiAweDBFKSA8PCAyNyB8XG4gICAgICAgIChwYWNrZXRbb2Zmc2V0ICsgMTVdICYgMHhGRikgPDwgMjAgfFxuICAgICAgICAocGFja2V0W29mZnNldCArIDE2XSAmIDB4RkUpIDw8IDEyIHxcbiAgICAgICAgKHBhY2tldFtvZmZzZXQgKyAxN10gJiAweEZGKSA8PCA1IHxcbiAgICAgICAgKHBhY2tldFtvZmZzZXQgKyAxOF0gJiAweEZFKSA+Pj4gMztcbiAgICAgIHBlcy5kdHMgKj0gNDsgLy8gTGVmdCBzaGlmdCBieSAyXG4gICAgICBwZXMuZHRzICs9IChwYWNrZXRbb2Zmc2V0ICsgMThdICYgMHgwNikgPj4+IDE7IC8vIE9SIGJ5IHRoZSB0d28gTFNCc1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGVzO1xufTtcblxudmFyIHBhcnNlTmFsVW5pdFR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgMHgwNTpcbiAgICAgIHJldHVybiAnc2xpY2VfbGF5ZXJfd2l0aG91dF9wYXJ0aXRpb25pbmdfcmJzcF9pZHInO1xuICAgIGNhc2UgMHgwNjpcbiAgICAgIHJldHVybiAnc2VpX3Jic3AnO1xuICAgIGNhc2UgMHgwNzpcbiAgICAgIHJldHVybiAnc2VxX3BhcmFtZXRlcl9zZXRfcmJzcCc7XG4gICAgY2FzZSAweDA4OlxuICAgICAgcmV0dXJuICdwaWNfcGFyYW1ldGVyX3NldF9yYnNwJztcbiAgICBjYXNlIDB4MDk6XG4gICAgICByZXR1cm4gJ2FjY2Vzc191bml0X2RlbGltaXRlcl9yYnNwJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbnZhciB2aWRlb1BhY2tldENvbnRhaW5zS2V5RnJhbWUgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgdmFyIG9mZnNldCA9IDQgKyBwYXJzZUFkYXB0aW9uRmllbGQocGFja2V0KTtcbiAgdmFyIGZyYW1lQnVmZmVyID0gcGFja2V0LnN1YmFycmF5KG9mZnNldCk7XG4gIHZhciBmcmFtZUkgPSAwO1xuICB2YXIgZnJhbWVTeW5jUG9pbnQgPSAwO1xuICB2YXIgZm91bmRLZXlGcmFtZSA9IGZhbHNlO1xuICB2YXIgbmFsVHlwZTtcblxuICAvLyBhZHZhbmNlIHRoZSBzeW5jIHBvaW50IHRvIGEgTkFMIHN0YXJ0LCBpZiBuZWNlc3NhcnlcbiAgZm9yICg7IGZyYW1lU3luY1BvaW50IDwgZnJhbWVCdWZmZXIuYnl0ZUxlbmd0aCAtIDM7IGZyYW1lU3luY1BvaW50KyspIHtcbiAgICBpZiAoZnJhbWVCdWZmZXJbZnJhbWVTeW5jUG9pbnQgKyAyXSA9PT0gMSkge1xuICAgICAgLy8gdGhlIHN5bmMgcG9pbnQgaXMgcHJvcGVybHkgYWxpZ25lZFxuICAgICAgZnJhbWVJID0gZnJhbWVTeW5jUG9pbnQgKyA1O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKGZyYW1lSSA8IGZyYW1lQnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAvLyBsb29rIGF0IHRoZSBjdXJyZW50IGJ5dGUgdG8gZGV0ZXJtaW5lIGlmIHdlJ3ZlIGhpdCB0aGUgZW5kIG9mXG4gICAgLy8gYSBOQUwgdW5pdCBib3VuZGFyeVxuICAgIHN3aXRjaCAoZnJhbWVCdWZmZXJbZnJhbWVJXSkge1xuICAgIGNhc2UgMDpcbiAgICAgIC8vIHNraXAgcGFzdCBub24tc3luYyBzZXF1ZW5jZXNcbiAgICAgIGlmIChmcmFtZUJ1ZmZlcltmcmFtZUkgLSAxXSAhPT0gMCkge1xuICAgICAgICBmcmFtZUkgKz0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGZyYW1lQnVmZmVyW2ZyYW1lSSAtIDJdICE9PSAwKSB7XG4gICAgICAgIGZyYW1lSSsrO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGZyYW1lU3luY1BvaW50ICsgMyAhPT0gZnJhbWVJIC0gMikge1xuICAgICAgICBuYWxUeXBlID0gcGFyc2VOYWxVbml0VHlwZShmcmFtZUJ1ZmZlcltmcmFtZVN5bmNQb2ludCArIDNdICYgMHgxZik7XG4gICAgICAgIGlmIChuYWxUeXBlID09PSAnc2xpY2VfbGF5ZXJfd2l0aG91dF9wYXJ0aXRpb25pbmdfcmJzcF9pZHInKSB7XG4gICAgICAgICAgZm91bmRLZXlGcmFtZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZHJvcCB0cmFpbGluZyB6ZXJvZXNcbiAgICAgIGRvIHtcbiAgICAgICAgZnJhbWVJKys7XG4gICAgICB9IHdoaWxlIChmcmFtZUJ1ZmZlcltmcmFtZUldICE9PSAxICYmIGZyYW1lSSA8IGZyYW1lQnVmZmVyLmxlbmd0aCk7XG4gICAgICBmcmFtZVN5bmNQb2ludCA9IGZyYW1lSSAtIDI7XG4gICAgICBmcmFtZUkgKz0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIC8vIHNraXAgcGFzdCBub24tc3luYyBzZXF1ZW5jZXNcbiAgICAgIGlmIChmcmFtZUJ1ZmZlcltmcmFtZUkgLSAxXSAhPT0gMCB8fFxuICAgICAgICAgIGZyYW1lQnVmZmVyW2ZyYW1lSSAtIDJdICE9PSAwKSB7XG4gICAgICAgIGZyYW1lSSArPSAzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbmFsVHlwZSA9IHBhcnNlTmFsVW5pdFR5cGUoZnJhbWVCdWZmZXJbZnJhbWVTeW5jUG9pbnQgKyAzXSAmIDB4MWYpO1xuICAgICAgaWYgKG5hbFR5cGUgPT09ICdzbGljZV9sYXllcl93aXRob3V0X3BhcnRpdGlvbmluZ19yYnNwX2lkcicpIHtcbiAgICAgICAgZm91bmRLZXlGcmFtZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBmcmFtZVN5bmNQb2ludCA9IGZyYW1lSSAtIDI7XG4gICAgICBmcmFtZUkgKz0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyB0aGUgY3VycmVudCBieXRlIGlzbid0IGEgb25lIG9yIHplcm8sIHNvIGl0IGNhbm5vdCBiZSBwYXJ0XG4gICAgICAvLyBvZiBhIHN5bmMgc2VxdWVuY2VcbiAgICAgIGZyYW1lSSArPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGZyYW1lQnVmZmVyID0gZnJhbWVCdWZmZXIuc3ViYXJyYXkoZnJhbWVTeW5jUG9pbnQpO1xuICBmcmFtZUkgLT0gZnJhbWVTeW5jUG9pbnQ7XG4gIGZyYW1lU3luY1BvaW50ID0gMDtcbiAgLy8gcGFyc2UgdGhlIGZpbmFsIG5hbFxuICBpZiAoZnJhbWVCdWZmZXIgJiYgZnJhbWVCdWZmZXIuYnl0ZUxlbmd0aCA+IDMpIHtcbiAgICBuYWxUeXBlID0gcGFyc2VOYWxVbml0VHlwZShmcmFtZUJ1ZmZlcltmcmFtZVN5bmNQb2ludCArIDNdICYgMHgxZik7XG4gICAgaWYgKG5hbFR5cGUgPT09ICdzbGljZV9sYXllcl93aXRob3V0X3BhcnRpdGlvbmluZ19yYnNwX2lkcicpIHtcbiAgICAgIGZvdW5kS2V5RnJhbWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3VuZEtleUZyYW1lO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2VUeXBlOiBwYXJzZVR5cGUsXG4gIHBhcnNlUGF0OiBwYXJzZVBhdCxcbiAgcGFyc2VQbXQ6IHBhcnNlUG10LFxuICBwYXJzZVBheWxvYWRVbml0U3RhcnRJbmRpY2F0b3I6IHBhcnNlUGF5bG9hZFVuaXRTdGFydEluZGljYXRvcixcbiAgcGFyc2VQZXNUeXBlOiBwYXJzZVBlc1R5cGUsXG4gIHBhcnNlUGVzVGltZTogcGFyc2VQZXNUaW1lLFxuICB2aWRlb1BhY2tldENvbnRhaW5zS2V5RnJhbWU6IHZpZGVvUGFja2V0Q29udGFpbnNLZXlGcmFtZVxufTtcblxufSx7XCIuL3N0cmVhbS10eXBlcy5qc1wiOjUzfV0sNTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSDI2NF9TVFJFQU1fVFlQRTogMHgxQixcbiAgQURUU19TVFJFQU1fVFlQRTogMHgwRixcbiAgTUVUQURBVEFfU1RSRUFNX1RZUEU6IDB4MTVcbn07XG5cbn0se31dLDU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogbXV4LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IEJyaWdodGNvdmVcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogQWNjZXB0cyBwcm9ncmFtIGVsZW1lbnRhcnkgc3RyZWFtIChQRVMpIGRhdGEgZXZlbnRzIGFuZCBjb3JyZWN0c1xuICogZGVjb2RlIGFuZCBwcmVzZW50YXRpb24gdGltZSBzdGFtcHMgdG8gYWNjb3VudCBmb3IgYSByb2xsb3ZlclxuICogb2YgdGhlIDMzIGJpdCB2YWx1ZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuLi91dGlscy9zdHJlYW0nKTtcblxudmFyIE1BWF9UUyA9IDg1ODk5MzQ1OTI7XG5cbnZhciBST19USFJFU0ggPSA0Mjk0OTY3Mjk2O1xuXG52YXIgaGFuZGxlUm9sbG92ZXIgPSBmdW5jdGlvbih2YWx1ZSwgcmVmZXJlbmNlKSB7XG4gIHZhciBkaXJlY3Rpb24gPSAxO1xuXG4gIGlmICh2YWx1ZSA+IHJlZmVyZW5jZSkge1xuICAgIC8vIElmIHRoZSBjdXJyZW50IHRpbWVzdGFtcCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3VyIHJlZmVyZW5jZSB0aW1lc3RhbXAgYW5kIHdlIGRldGVjdCBhXG4gICAgLy8gdGltZXN0YW1wIHJvbGxvdmVyLCB0aGlzIG1lYW5zIHRoZSByb2xsIG92ZXIgaXMgaGFwcGVuaW5nIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uXG4gICAgLy8gRXhhbXBsZSBzY2VuYXJpbzogRW50ZXIgYSBsb25nIHN0cmVhbS92aWRlbyBqdXN0IGFmdGVyIGEgcm9sbG92ZXIgb2NjdXJyZWQuIFRoZSByZWZlcmVuY2VcbiAgICAvLyBwb2ludCB3aWxsIGJlIHNldCB0byBhIHNtYWxsIG51bWJlciwgZS5nLiAxLiBUaGUgdXNlciB0aGVuIHNlZWtzIGJhY2t3YXJkcyBvdmVyIHRoZVxuICAgIC8vIHJvbGxvdmVyIHBvaW50LiBJbiBsb2FkaW5nIHRoaXMgc2VnbWVudCwgdGhlIHRpbWVzdGFtcCB2YWx1ZXMgd2lsbCBiZSB2ZXJ5IGxhcmdlLFxuICAgIC8vIGUuZy4gMl4zMyAtIDEuIFNpbmNlIHRoaXMgY29tZXMgYmVmb3JlIHRoZSBkYXRhIHdlIGxvYWRlZCBwcmV2aW91c2x5LCB3ZSB3YW50IHRvIGFkanVzdFxuICAgIC8vIHRoZSB0aW1lIHN0YW1wIHRvIGJlIGB2YWx1ZSAtIDJeMzNgLlxuICAgIGRpcmVjdGlvbiA9IC0xO1xuICB9XG5cbiAgLy8gTm90ZTogQSBzZWVrIGZvcndhcmRzIG9yIGJhY2sgdGhhdCBpcyBncmVhdGVyIHRoYW4gdGhlIFJPX1RIUkVTSCAoMl4zMiwgfjEzIGhvdXJzKSB3aWxsXG4gIC8vIGNhdXNlIGFuIGluY29ycmVjdCBhZGp1c3RtZW50LlxuICB3aGlsZSAoTWF0aC5hYnMocmVmZXJlbmNlIC0gdmFsdWUpID4gUk9fVEhSRVNIKSB7XG4gICAgdmFsdWUgKz0gKGRpcmVjdGlvbiAqIE1BWF9UUyk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0gPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBsYXN0RFRTLCByZWZlcmVuY2VEVFM7XG5cbiAgVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnR5cGVfID0gdHlwZTtcblxuICB0aGlzLnB1c2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKGRhdGEudHlwZSAhPT0gdGhpcy50eXBlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyZWZlcmVuY2VEVFMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVmZXJlbmNlRFRTID0gZGF0YS5kdHM7XG4gICAgfVxuXG4gICAgZGF0YS5kdHMgPSBoYW5kbGVSb2xsb3ZlcihkYXRhLmR0cywgcmVmZXJlbmNlRFRTKTtcbiAgICBkYXRhLnB0cyA9IGhhbmRsZVJvbGxvdmVyKGRhdGEucHRzLCByZWZlcmVuY2VEVFMpO1xuXG4gICAgbGFzdERUUyA9IGRhdGEuZHRzO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHJlZmVyZW5jZURUUyA9IGxhc3REVFM7XG4gICAgdGhpcy50cmlnZ2VyKCdkb25lJyk7XG4gIH07XG5cbiAgdGhpcy5kaXNjb250aW51aXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmVmZXJlbmNlRFRTID0gdm9pZCAwO1xuICAgIGxhc3REVFMgPSB2b2lkIDA7XG4gIH07XG5cbn07XG5cblRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtOiBUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSxcbiAgaGFuZGxlUm9sbG92ZXI6IGhhbmRsZVJvbGxvdmVyXG59O1xuXG59LHtcIi4uL3V0aWxzL3N0cmVhbVwiOjYyfV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdlbmVyYXRvcjogcmVxdWlyZSgnLi9tcDQtZ2VuZXJhdG9yJyksXG4gIFRyYW5zbXV4ZXI6IHJlcXVpcmUoJy4vdHJhbnNtdXhlcicpLlRyYW5zbXV4ZXIsXG4gIEF1ZGlvU2VnbWVudFN0cmVhbTogcmVxdWlyZSgnLi90cmFuc211eGVyJykuQXVkaW9TZWdtZW50U3RyZWFtLFxuICBWaWRlb1NlZ21lbnRTdHJlYW06IHJlcXVpcmUoJy4vdHJhbnNtdXhlcicpLlZpZGVvU2VnbWVudFN0cmVhbVxufTtcblxufSx7XCIuL21wNC1nZW5lcmF0b3JcIjo1NixcIi4vdHJhbnNtdXhlclwiOjU4fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBtdXguanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQnJpZ2h0Y292ZVxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBGdW5jdGlvbnMgdGhhdCBnZW5lcmF0ZSBmcmFnbWVudGVkIE1QNHMgc3VpdGFibGUgZm9yIHVzZSB3aXRoIE1lZGlhXG4gKiBTb3VyY2UgRXh0ZW5zaW9ucy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVUlOVDMyX01BWCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5cbnZhciBib3gsIGRpbmYsIGVzZHMsIGZ0eXAsIG1kYXQsIG1maGQsIG1pbmYsIG1vb2YsIG1vb3YsIG12ZXgsIG12aGQsXG4gICAgdHJhaywgdGtoZCwgbWRpYSwgbWRoZCwgaGRsciwgc2R0cCwgc3RibCwgc3RzZCwgdHJhZiwgdHJleCxcbiAgICB0cnVuLCB0eXBlcywgTUFKT1JfQlJBTkQsIE1JTk9SX1ZFUlNJT04sIEFWQzFfQlJBTkQsIFZJREVPX0hETFIsXG4gICAgQVVESU9fSERMUiwgSERMUl9UWVBFUywgVk1IRCwgU01IRCwgRFJFRiwgU1RDTywgU1RTQywgU1RTWiwgU1RUUztcblxuLy8gcHJlLWNhbGN1bGF0ZSBjb25zdGFudHNcbihmdW5jdGlvbigpIHtcbiAgdmFyIGk7XG4gIHR5cGVzID0ge1xuICAgIGF2YzE6IFtdLCAvLyBjb2RpbmduYW1lXG4gICAgYXZjQzogW10sXG4gICAgYnRydDogW10sXG4gICAgZGluZjogW10sXG4gICAgZHJlZjogW10sXG4gICAgZXNkczogW10sXG4gICAgZnR5cDogW10sXG4gICAgaGRscjogW10sXG4gICAgbWRhdDogW10sXG4gICAgbWRoZDogW10sXG4gICAgbWRpYTogW10sXG4gICAgbWZoZDogW10sXG4gICAgbWluZjogW10sXG4gICAgbW9vZjogW10sXG4gICAgbW9vdjogW10sXG4gICAgbXA0YTogW10sIC8vIGNvZGluZ25hbWVcbiAgICBtdmV4OiBbXSxcbiAgICBtdmhkOiBbXSxcbiAgICBzZHRwOiBbXSxcbiAgICBzbWhkOiBbXSxcbiAgICBzdGJsOiBbXSxcbiAgICBzdGNvOiBbXSxcbiAgICBzdHNjOiBbXSxcbiAgICBzdHNkOiBbXSxcbiAgICBzdHN6OiBbXSxcbiAgICBzdHRzOiBbXSxcbiAgICBzdHlwOiBbXSxcbiAgICB0ZmR0OiBbXSxcbiAgICB0ZmhkOiBbXSxcbiAgICB0cmFmOiBbXSxcbiAgICB0cmFrOiBbXSxcbiAgICB0cnVuOiBbXSxcbiAgICB0cmV4OiBbXSxcbiAgICB0a2hkOiBbXSxcbiAgICB2bWhkOiBbXVxuICB9O1xuXG4gIC8vIEluIGVudmlyb25tZW50cyB3aGVyZSBVaW50OEFycmF5IGlzIHVuZGVmaW5lZCAoZS5nLiwgSUU4KSwgc2tpcCBzZXQgdXAgc28gdGhhdCB3ZVxuICAvLyBkb24ndCB0aHJvdyBhbiBlcnJvclxuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChpIGluIHR5cGVzKSB7XG4gICAgaWYgKHR5cGVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICB0eXBlc1tpXSA9IFtcbiAgICAgICAgaS5jaGFyQ29kZUF0KDApLFxuICAgICAgICBpLmNoYXJDb2RlQXQoMSksXG4gICAgICAgIGkuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgaS5jaGFyQ29kZUF0KDMpXG4gICAgICBdO1xuICAgIH1cbiAgfVxuXG4gIE1BSk9SX0JSQU5EID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICdpJy5jaGFyQ29kZUF0KDApLFxuICAgICdzJy5jaGFyQ29kZUF0KDApLFxuICAgICdvJy5jaGFyQ29kZUF0KDApLFxuICAgICdtJy5jaGFyQ29kZUF0KDApXG4gIF0pO1xuICBBVkMxX0JSQU5EID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICdhJy5jaGFyQ29kZUF0KDApLFxuICAgICd2Jy5jaGFyQ29kZUF0KDApLFxuICAgICdjJy5jaGFyQ29kZUF0KDApLFxuICAgICcxJy5jaGFyQ29kZUF0KDApXG4gIF0pO1xuICBNSU5PUl9WRVJTSU9OID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDFdKTtcbiAgVklERU9fSERMUiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgMHg3NiwgMHg2OSwgMHg2NCwgMHg2NSwgLy8gaGFuZGxlcl90eXBlOiAndmlkZSdcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDU2LCAweDY5LCAweDY0LCAweDY1LFxuICAgIDB4NmYsIDB4NDgsIDB4NjEsIDB4NmUsXG4gICAgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnVmlkZW9IYW5kbGVyJ1xuICBdKTtcbiAgQVVESU9fSERMUiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgMHg3MywgMHg2ZiwgMHg3NSwgMHg2ZSwgLy8gaGFuZGxlcl90eXBlOiAnc291bidcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDUzLCAweDZmLCAweDc1LCAweDZlLFxuICAgIDB4NjQsIDB4NDgsIDB4NjEsIDB4NmUsXG4gICAgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnU291bmRIYW5kbGVyJ1xuICBdKTtcbiAgSERMUl9UWVBFUyA9IHtcbiAgICB2aWRlbzogVklERU9fSERMUixcbiAgICBhdWRpbzogQVVESU9fSERMUlxuICB9O1xuICBEUkVGID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZW50cnlfY291bnRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDBjLCAvLyBlbnRyeV9zaXplXG4gICAgMHg3NSwgMHg3MiwgMHg2YywgMHgyMCwgLy8gJ3VybCcgdHlwZVxuICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDEgLy8gZW50cnlfZmxhZ3NcbiAgXSk7XG4gIFNNSEQgPSBuZXcgVWludDhBcnJheShbXG4gICAgMHgwMCwgICAgICAgICAgICAgLy8gdmVyc2lvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgICAgICAgLy8gYmFsYW5jZSwgMCBtZWFucyBjZW50ZXJlZFxuICAgIDB4MDAsIDB4MDAgICAgICAgIC8vIHJlc2VydmVkXG4gIF0pO1xuICBTVENPID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDB4MDAsIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gZW50cnlfY291bnRcbiAgXSk7XG4gIFNUU0MgPSBTVENPO1xuICBTVFNaID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDB4MDAsIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHNhbXBsZV9zaXplXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBzYW1wbGVfY291bnRcbiAgXSk7XG4gIFNUVFMgPSBTVENPO1xuICBWTUhEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDB4MDAsIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAxLCAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIC8vIGdyYXBoaWNzbW9kZVxuICAgIDB4MDAsIDB4MDAsXG4gICAgMHgwMCwgMHgwMCxcbiAgICAweDAwLCAweDAwIC8vIG9wY29sb3JcbiAgXSk7XG59KCkpO1xuXG5ib3ggPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhclxuICAgIHBheWxvYWQgPSBbXSxcbiAgICBzaXplID0gMCxcbiAgICBpLFxuICAgIHJlc3VsdCxcbiAgICB2aWV3O1xuXG4gIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBwYXlsb2FkLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgfVxuXG4gIGkgPSBwYXlsb2FkLmxlbmd0aDtcblxuICAvLyBjYWxjdWxhdGUgdGhlIHRvdGFsIHNpemUgd2UgbmVlZCB0byBhbGxvY2F0ZVxuICB3aGlsZSAoaS0tKSB7XG4gICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gIH1cbiAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSArIDgpO1xuICB2aWV3ID0gbmV3IERhdGFWaWV3KHJlc3VsdC5idWZmZXIsIHJlc3VsdC5ieXRlT2Zmc2V0LCByZXN1bHQuYnl0ZUxlbmd0aCk7XG4gIHZpZXcuc2V0VWludDMyKDAsIHJlc3VsdC5ieXRlTGVuZ3RoKTtcbiAgcmVzdWx0LnNldCh0eXBlLCA0KTtcblxuICAvLyBjb3B5IHRoZSBwYXlsb2FkIGludG8gdGhlIHJlc3VsdFxuICBmb3IgKGkgPSAwLCBzaXplID0gODsgaSA8IHBheWxvYWQubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHQuc2V0KHBheWxvYWRbaV0sIHNpemUpO1xuICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5kaW5mID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBib3godHlwZXMuZGluZiwgYm94KHR5cGVzLmRyZWYsIERSRUYpKTtcbn07XG5cbmVzZHMgPSBmdW5jdGlvbih0cmFjaykge1xuICByZXR1cm4gYm94KHR5cGVzLmVzZHMsIG5ldyBVaW50OEFycmF5KFtcbiAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcblxuICAgIC8vIEVTX0Rlc2NyaXB0b3JcbiAgICAweDAzLCAvLyB0YWcsIEVTX0Rlc2NyVGFnXG4gICAgMHgxOSwgLy8gbGVuZ3RoXG4gICAgMHgwMCwgMHgwMCwgLy8gRVNfSURcbiAgICAweDAwLCAvLyBzdHJlYW1EZXBlbmRlbmNlRmxhZywgVVJMX2ZsYWcsIHJlc2VydmVkLCBzdHJlYW1Qcmlvcml0eVxuXG4gICAgLy8gRGVjb2RlckNvbmZpZ0Rlc2NyaXB0b3JcbiAgICAweDA0LCAvLyB0YWcsIERlY29kZXJDb25maWdEZXNjclRhZ1xuICAgIDB4MTEsIC8vIGxlbmd0aFxuICAgIDB4NDAsIC8vIG9iamVjdCB0eXBlXG4gICAgMHgxNSwgIC8vIHN0cmVhbVR5cGVcbiAgICAweDAwLCAweDA2LCAweDAwLCAvLyBidWZmZXJTaXplREJcbiAgICAweDAwLCAweDAwLCAweGRhLCAweGMwLCAvLyBtYXhCaXRyYXRlXG4gICAgMHgwMCwgMHgwMCwgMHhkYSwgMHhjMCwgLy8gYXZnQml0cmF0ZVxuXG4gICAgLy8gRGVjb2RlclNwZWNpZmljSW5mb1xuICAgIDB4MDUsIC8vIHRhZywgRGVjb2RlclNwZWNpZmljSW5mb1RhZ1xuICAgIDB4MDIsIC8vIGxlbmd0aFxuICAgIC8vIElTTy9JRUMgMTQ0OTYtMywgQXVkaW9TcGVjaWZpY0NvbmZpZ1xuICAgIC8vIGZvciBzYW1wbGluZ0ZyZXF1ZW5jeUluZGV4IHNlZSBJU08vSUVDIDEzODE4LTc6MjAwNiwgOC4xLjMuMi4yLCBUYWJsZSAzNVxuICAgICh0cmFjay5hdWRpb29iamVjdHR5cGUgPDwgMykgfCAodHJhY2suc2FtcGxpbmdmcmVxdWVuY3lpbmRleCA+Pj4gMSksXG4gICAgKHRyYWNrLnNhbXBsaW5nZnJlcXVlbmN5aW5kZXggPDwgNykgfCAodHJhY2suY2hhbm5lbGNvdW50IDw8IDMpLFxuICAgIDB4MDYsIDB4MDEsIDB4MDIgLy8gR0FTcGVjaWZpY0NvbmZpZ1xuICBdKSk7XG59O1xuXG5mdHlwID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBib3godHlwZXMuZnR5cCwgTUFKT1JfQlJBTkQsIE1JTk9SX1ZFUlNJT04sIE1BSk9SX0JSQU5ELCBBVkMxX0JSQU5EKTtcbn07XG5cbmhkbHIgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHJldHVybiBib3godHlwZXMuaGRsciwgSERMUl9UWVBFU1t0eXBlXSk7XG59O1xubWRhdCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIGJveCh0eXBlcy5tZGF0LCBkYXRhKTtcbn07XG5tZGhkID0gZnVuY3Rpb24odHJhY2spIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAweDAwLCAgICAgICAgICAgICAgICAgICAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLCAgICAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAzLCAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgIDB4MDAsIDB4MDEsIDB4NWYsIDB4OTAsIC8vIHRpbWVzY2FsZSwgOTAsMDAwIFwidGlja3NcIiBwZXIgc2Vjb25kXG5cbiAgICAodHJhY2suZHVyYXRpb24gPj4+IDI0KSAmIDB4RkYsXG4gICAgKHRyYWNrLmR1cmF0aW9uID4+PiAxNikgJiAweEZGLFxuICAgICh0cmFjay5kdXJhdGlvbiA+Pj4gIDgpICYgMHhGRixcbiAgICB0cmFjay5kdXJhdGlvbiAmIDB4RkYsICAvLyBkdXJhdGlvblxuICAgIDB4NTUsIDB4YzQsICAgICAgICAgICAgIC8vICd1bmQnIGxhbmd1YWdlICh1bmRldGVybWluZWQpXG4gICAgMHgwMCwgMHgwMFxuICBdKTtcblxuICAvLyBVc2UgdGhlIHNhbXBsZSByYXRlIGZyb20gdGhlIHRyYWNrIG1ldGFkYXRhLCB3aGVuIGl0IGlzXG4gIC8vIGRlZmluZWQuIFRoZSBzYW1wbGUgcmF0ZSBjYW4gYmUgcGFyc2VkIG91dCBvZiBhbiBBRFRTIGhlYWRlciwgZm9yXG4gIC8vIGluc3RhbmNlLlxuICBpZiAodHJhY2suc2FtcGxlcmF0ZSkge1xuICAgIHJlc3VsdFsxMl0gPSAodHJhY2suc2FtcGxlcmF0ZSA+Pj4gMjQpICYgMHhGRjtcbiAgICByZXN1bHRbMTNdID0gKHRyYWNrLnNhbXBsZXJhdGUgPj4+IDE2KSAmIDB4RkY7XG4gICAgcmVzdWx0WzE0XSA9ICh0cmFjay5zYW1wbGVyYXRlID4+PiAgOCkgJiAweEZGO1xuICAgIHJlc3VsdFsxNV0gPSAodHJhY2suc2FtcGxlcmF0ZSkgICAgICAgICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBib3godHlwZXMubWRoZCwgcmVzdWx0KTtcbn07XG5tZGlhID0gZnVuY3Rpb24odHJhY2spIHtcbiAgcmV0dXJuIGJveCh0eXBlcy5tZGlhLCBtZGhkKHRyYWNrKSwgaGRscih0cmFjay50eXBlKSwgbWluZih0cmFjaykpO1xufTtcbm1maGQgPSBmdW5jdGlvbihzZXF1ZW5jZU51bWJlcikge1xuICByZXR1cm4gYm94KHR5cGVzLm1maGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAweDAwLFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGZsYWdzXG4gICAgKHNlcXVlbmNlTnVtYmVyICYgMHhGRjAwMDAwMCkgPj4gMjQsXG4gICAgKHNlcXVlbmNlTnVtYmVyICYgMHhGRjAwMDApID4+IDE2LFxuICAgIChzZXF1ZW5jZU51bWJlciAmIDB4RkYwMCkgPj4gOCxcbiAgICBzZXF1ZW5jZU51bWJlciAmIDB4RkYgLy8gc2VxdWVuY2VfbnVtYmVyXG4gIF0pKTtcbn07XG5taW5mID0gZnVuY3Rpb24odHJhY2spIHtcbiAgcmV0dXJuIGJveCh0eXBlcy5taW5mLFxuICAgICAgICAgICAgIHRyYWNrLnR5cGUgPT09ICd2aWRlbycgPyBib3godHlwZXMudm1oZCwgVk1IRCkgOiBib3godHlwZXMuc21oZCwgU01IRCksXG4gICAgICAgICAgICAgZGluZigpLFxuICAgICAgICAgICAgIHN0YmwodHJhY2spKTtcbn07XG5tb29mID0gZnVuY3Rpb24oc2VxdWVuY2VOdW1iZXIsIHRyYWNrcykge1xuICB2YXJcbiAgICB0cmFja0ZyYWdtZW50cyA9IFtdLFxuICAgIGkgPSB0cmFja3MubGVuZ3RoO1xuICAvLyBidWlsZCB0cmFmIGJveGVzIGZvciBlYWNoIHRyYWNrIGZyYWdtZW50XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0cmFja0ZyYWdtZW50c1tpXSA9IHRyYWYodHJhY2tzW2ldKTtcbiAgfVxuICByZXR1cm4gYm94LmFwcGx5KG51bGwsIFtcbiAgICB0eXBlcy5tb29mLFxuICAgIG1maGQoc2VxdWVuY2VOdW1iZXIpXG4gIF0uY29uY2F0KHRyYWNrRnJhZ21lbnRzKSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgbW92aWUgYm94LlxuICogQHBhcmFtIHRyYWNrcyB7YXJyYXl9IHRoZSB0cmFja3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbW92aWVcbiAqIEBzZWUgSVNPL0lFQyAxNDQ5Ni0xMjoyMDEyKEUpLCBzZWN0aW9uIDguMi4xXG4gKi9cbm1vb3YgPSBmdW5jdGlvbih0cmFja3MpIHtcbiAgdmFyXG4gICAgaSA9IHRyYWNrcy5sZW5ndGgsXG4gICAgYm94ZXMgPSBbXTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgYm94ZXNbaV0gPSB0cmFrKHRyYWNrc1tpXSk7XG4gIH1cblxuICByZXR1cm4gYm94LmFwcGx5KG51bGwsIFt0eXBlcy5tb292LCBtdmhkKDB4ZmZmZmZmZmYpXS5jb25jYXQoYm94ZXMpLmNvbmNhdChtdmV4KHRyYWNrcykpKTtcbn07XG5tdmV4ID0gZnVuY3Rpb24odHJhY2tzKSB7XG4gIHZhclxuICAgIGkgPSB0cmFja3MubGVuZ3RoLFxuICAgIGJveGVzID0gW107XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGJveGVzW2ldID0gdHJleCh0cmFja3NbaV0pO1xuICB9XG4gIHJldHVybiBib3guYXBwbHkobnVsbCwgW3R5cGVzLm12ZXhdLmNvbmNhdChib3hlcykpO1xufTtcbm12aGQgPSBmdW5jdGlvbihkdXJhdGlvbikge1xuICB2YXJcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAweDAwLCAweDAxLCAweDVmLCAweDkwLCAvLyB0aW1lc2NhbGUsIDkwLDAwMCBcInRpY2tzXCIgcGVyIHNlY29uZFxuICAgICAgKGR1cmF0aW9uICYgMHhGRjAwMDAwMCkgPj4gMjQsXG4gICAgICAoZHVyYXRpb24gJiAweEZGMDAwMCkgPj4gMTYsXG4gICAgICAoZHVyYXRpb24gJiAweEZGMDApID4+IDgsXG4gICAgICBkdXJhdGlvbiAmIDB4RkYsIC8vIGR1cmF0aW9uXG4gICAgICAweDAwLCAweDAxLCAweDAwLCAweDAwLCAvLyAxLjAgcmF0ZVxuICAgICAgMHgwMSwgMHgwMCwgLy8gMS4wIHZvbHVtZVxuICAgICAgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDQwLCAweDAwLCAweDAwLCAweDAwLCAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweGZmLCAweGZmLCAweGZmLCAweGZmIC8vIG5leHRfdHJhY2tfSURcbiAgICBdKTtcbiAgcmV0dXJuIGJveCh0eXBlcy5tdmhkLCBieXRlcyk7XG59O1xuXG5zZHRwID0gZnVuY3Rpb24odHJhY2spIHtcbiAgdmFyXG4gICAgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW10sXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheSg0ICsgc2FtcGxlcy5sZW5ndGgpLFxuICAgIGZsYWdzLFxuICAgIGk7XG5cbiAgLy8gbGVhdmUgdGhlIGZ1bGwgYm94IGhlYWRlciAoNCBieXRlcykgYWxsIHplcm9cblxuICAvLyB3cml0ZSB0aGUgc2FtcGxlIHRhYmxlXG4gIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgZmxhZ3MgPSBzYW1wbGVzW2ldLmZsYWdzO1xuXG4gICAgYnl0ZXNbaSArIDRdID0gKGZsYWdzLmRlcGVuZHNPbiA8PCA0KSB8XG4gICAgICAoZmxhZ3MuaXNEZXBlbmRlZE9uIDw8IDIpIHxcbiAgICAgIChmbGFncy5oYXNSZWR1bmRhbmN5KTtcbiAgfVxuXG4gIHJldHVybiBib3godHlwZXMuc2R0cCxcbiAgICAgICAgICAgICBieXRlcyk7XG59O1xuXG5zdGJsID0gZnVuY3Rpb24odHJhY2spIHtcbiAgcmV0dXJuIGJveCh0eXBlcy5zdGJsLFxuICAgICAgICAgICAgIHN0c2QodHJhY2spLFxuICAgICAgICAgICAgIGJveCh0eXBlcy5zdHRzLCBTVFRTKSxcbiAgICAgICAgICAgICBib3godHlwZXMuc3RzYywgU1RTQyksXG4gICAgICAgICAgICAgYm94KHR5cGVzLnN0c3osIFNUU1opLFxuICAgICAgICAgICAgIGJveCh0eXBlcy5zdGNvLCBTVENPKSk7XG59O1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciB2aWRlb1NhbXBsZSwgYXVkaW9TYW1wbGU7XG5cbiAgc3RzZCA9IGZ1bmN0aW9uKHRyYWNrKSB7XG5cbiAgICByZXR1cm4gYm94KHR5cGVzLnN0c2QsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDFcbiAgICBdKSwgdHJhY2sudHlwZSA9PT0gJ3ZpZGVvJyA/IHZpZGVvU2FtcGxlKHRyYWNrKSA6IGF1ZGlvU2FtcGxlKHRyYWNrKSk7XG4gIH07XG5cbiAgdmlkZW9TYW1wbGUgPSBmdW5jdGlvbih0cmFjaykge1xuICAgIHZhclxuICAgICAgc3BzID0gdHJhY2suc3BzIHx8IFtdLFxuICAgICAgcHBzID0gdHJhY2sucHBzIHx8IFtdLFxuICAgICAgc2VxdWVuY2VQYXJhbWV0ZXJTZXRzID0gW10sXG4gICAgICBwaWN0dXJlUGFyYW1ldGVyU2V0cyA9IFtdLFxuICAgICAgaTtcblxuICAgIC8vIGFzc2VtYmxlIHRoZSBTUFNzXG4gICAgZm9yIChpID0gMDsgaSA8IHNwcy5sZW5ndGg7IGkrKykge1xuICAgICAgc2VxdWVuY2VQYXJhbWV0ZXJTZXRzLnB1c2goKHNwc1tpXS5ieXRlTGVuZ3RoICYgMHhGRjAwKSA+Pj4gOCk7XG4gICAgICBzZXF1ZW5jZVBhcmFtZXRlclNldHMucHVzaCgoc3BzW2ldLmJ5dGVMZW5ndGggJiAweEZGKSk7IC8vIHNlcXVlbmNlUGFyYW1ldGVyU2V0TGVuZ3RoXG4gICAgICBzZXF1ZW5jZVBhcmFtZXRlclNldHMgPSBzZXF1ZW5jZVBhcmFtZXRlclNldHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNwc1tpXSkpOyAvLyBTUFNcbiAgICB9XG5cbiAgICAvLyBhc3NlbWJsZSB0aGUgUFBTc1xuICAgIGZvciAoaSA9IDA7IGkgPCBwcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBpY3R1cmVQYXJhbWV0ZXJTZXRzLnB1c2goKHBwc1tpXS5ieXRlTGVuZ3RoICYgMHhGRjAwKSA+Pj4gOCk7XG4gICAgICBwaWN0dXJlUGFyYW1ldGVyU2V0cy5wdXNoKChwcHNbaV0uYnl0ZUxlbmd0aCAmIDB4RkYpKTtcbiAgICAgIHBpY3R1cmVQYXJhbWV0ZXJTZXRzID0gcGljdHVyZVBhcmFtZXRlclNldHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHBwc1tpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBib3godHlwZXMuYXZjMSwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgICAgMHgwMCwgMHgwMCwgLy8gcHJlX2RlZmluZWRcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAodHJhY2sud2lkdGggJiAweGZmMDApID4+IDgsXG4gICAgICB0cmFjay53aWR0aCAmIDB4ZmYsIC8vIHdpZHRoXG4gICAgICAodHJhY2suaGVpZ2h0ICYgMHhmZjAwKSA+PiA4LFxuICAgICAgdHJhY2suaGVpZ2h0ICYgMHhmZiwgLy8gaGVpZ2h0XG4gICAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLCAvLyBob3JpenJlc29sdXRpb25cbiAgICAgIDB4MDAsIDB4NDgsIDB4MDAsIDB4MDAsIC8vIHZlcnRyZXNvbHV0aW9uXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMSwgLy8gZnJhbWVfY291bnRcbiAgICAgIDB4MTMsXG4gICAgICAweDc2LCAweDY5LCAweDY0LCAweDY1LFxuICAgICAgMHg2ZiwgMHg2YSwgMHg3MywgMHgyZCxcbiAgICAgIDB4NjMsIDB4NmYsIDB4NmUsIDB4NzQsXG4gICAgICAweDcyLCAweDY5LCAweDYyLCAweDJkLFxuICAgICAgMHg2OCwgMHg2YywgMHg3MywgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gY29tcHJlc3Nvcm5hbWVcbiAgICAgIDB4MDAsIDB4MTgsIC8vIGRlcHRoID0gMjRcbiAgICAgIDB4MTEsIDB4MTEgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgIF0pLCBib3godHlwZXMuYXZjQywgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMSwgLy8gY29uZmlndXJhdGlvblZlcnNpb25cbiAgICAgIHRyYWNrLnByb2ZpbGVJZGMsIC8vIEFWQ1Byb2ZpbGVJbmRpY2F0aW9uXG4gICAgICB0cmFjay5wcm9maWxlQ29tcGF0aWJpbGl0eSwgLy8gcHJvZmlsZV9jb21wYXRpYmlsaXR5XG4gICAgICB0cmFjay5sZXZlbElkYywgLy8gQVZDTGV2ZWxJbmRpY2F0aW9uXG4gICAgICAweGZmIC8vIGxlbmd0aFNpemVNaW51c09uZSwgaGFyZC1jb2RlZCB0byA0IGJ5dGVzXG4gICAgXS5jb25jYXQoW1xuICAgICAgc3BzLmxlbmd0aCAvLyBudW1PZlNlcXVlbmNlUGFyYW1ldGVyU2V0c1xuICAgIF0pLmNvbmNhdChzZXF1ZW5jZVBhcmFtZXRlclNldHMpLmNvbmNhdChbXG4gICAgICBwcHMubGVuZ3RoIC8vIG51bU9mUGljdHVyZVBhcmFtZXRlclNldHNcbiAgICBdKS5jb25jYXQocGljdHVyZVBhcmFtZXRlclNldHMpKSksIC8vIFwiUFBTXCJcbiAgICAgICAgICAgIGJveCh0eXBlcy5idHJ0LCBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAgIDB4MDAsIDB4MWMsIDB4OWMsIDB4ODAsIC8vIGJ1ZmZlclNpemVEQlxuICAgICAgICAgICAgICAweDAwLCAweDJkLCAweGM2LCAweGMwLCAvLyBtYXhCaXRyYXRlXG4gICAgICAgICAgICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzBcbiAgICAgICAgICAgIF0pKSAvLyBhdmdCaXRyYXRlXG4gICAgICAgICAgICAgICk7XG4gIH07XG5cbiAgYXVkaW9TYW1wbGUgPSBmdW5jdGlvbih0cmFjaykge1xuICAgIHJldHVybiBib3godHlwZXMubXA0YSwgbmV3IFVpbnQ4QXJyYXkoW1xuXG4gICAgICAvLyBTYW1wbGVFbnRyeSwgSVNPL0lFQyAxNDQ5Ni0xMlxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAgIDB4MDAsIDB4MDAsIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLCAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuXG4gICAgICAvLyBBdWRpb1NhbXBsZUVudHJ5LCBJU08vSUVDIDE0NDk2LTEyXG4gICAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgICh0cmFjay5jaGFubmVsY291bnQgJiAweGZmMDApID4+IDgsXG4gICAgICAodHJhY2suY2hhbm5lbGNvdW50ICYgMHhmZiksIC8vIGNoYW5uZWxjb3VudFxuXG4gICAgICAodHJhY2suc2FtcGxlc2l6ZSAmIDB4ZmYwMCkgPj4gOCxcbiAgICAgICh0cmFjay5zYW1wbGVzaXplICYgMHhmZiksIC8vIHNhbXBsZXNpemVcbiAgICAgIDB4MDAsIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuXG4gICAgICAodHJhY2suc2FtcGxlcmF0ZSAmIDB4ZmYwMCkgPj4gOCxcbiAgICAgICh0cmFjay5zYW1wbGVyYXRlICYgMHhmZiksXG4gICAgICAweDAwLCAweDAwIC8vIHNhbXBsZXJhdGUsIDE2LjE2XG5cbiAgICAgIC8vIE1QNEF1ZGlvU2FtcGxlRW50cnksIElTTy9JRUMgMTQ0OTYtMTRcbiAgICBdKSwgZXNkcyh0cmFjaykpO1xuICB9O1xufSgpKTtcblxudGtoZCA9IGZ1bmN0aW9uKHRyYWNrKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShbXG4gICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwNywgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAodHJhY2suaWQgJiAweEZGMDAwMDAwKSA+PiAyNCxcbiAgICAodHJhY2suaWQgJiAweEZGMDAwMCkgPj4gMTYsXG4gICAgKHRyYWNrLmlkICYgMHhGRjAwKSA+PiA4LFxuICAgIHRyYWNrLmlkICYgMHhGRiwgLy8gdHJhY2tfSURcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgICh0cmFjay5kdXJhdGlvbiAmIDB4RkYwMDAwMDApID4+IDI0LFxuICAgICh0cmFjay5kdXJhdGlvbiAmIDB4RkYwMDAwKSA+PiAxNixcbiAgICAodHJhY2suZHVyYXRpb24gJiAweEZGMDApID4+IDgsXG4gICAgdHJhY2suZHVyYXRpb24gJiAweEZGLCAvLyBkdXJhdGlvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAvLyBsYXllclxuICAgIDB4MDAsIDB4MDAsIC8vIGFsdGVybmF0ZV9ncm91cFxuICAgIDB4MDEsIDB4MDAsIC8vIG5vbi1hdWRpbyB0cmFjayB2b2x1bWVcbiAgICAweDAwLCAweDAwLCAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAweDQwLCAweDAwLCAweDAwLCAweDAwLCAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgKHRyYWNrLndpZHRoICYgMHhGRjAwKSA+PiA4LFxuICAgIHRyYWNrLndpZHRoICYgMHhGRixcbiAgICAweDAwLCAweDAwLCAvLyB3aWR0aFxuICAgICh0cmFjay5oZWlnaHQgJiAweEZGMDApID4+IDgsXG4gICAgdHJhY2suaGVpZ2h0ICYgMHhGRixcbiAgICAweDAwLCAweDAwIC8vIGhlaWdodFxuICBdKTtcblxuICByZXR1cm4gYm94KHR5cGVzLnRraGQsIHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgdHJhY2sgZnJhZ21lbnQgKHRyYWYpIGJveC4gQSB0cmFmIGJveCBjb2xsZWN0cyBtZXRhZGF0YVxuICogYWJvdXQgdHJhY2tzIGluIGEgbW92aWUgZnJhZ21lbnQgKG1vb2YpIGJveC5cbiAqL1xudHJhZiA9IGZ1bmN0aW9uKHRyYWNrKSB7XG4gIHZhciB0cmFja0ZyYWdtZW50SGVhZGVyLCB0cmFja0ZyYWdtZW50RGVjb2RlVGltZSwgdHJhY2tGcmFnbWVudFJ1bixcbiAgICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZSwgZGF0YU9mZnNldCxcbiAgICAgIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWU7XG5cbiAgdHJhY2tGcmFnbWVudEhlYWRlciA9IGJveCh0eXBlcy50ZmhkLCBuZXcgVWludDhBcnJheShbXG4gICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgzYSwgLy8gZmxhZ3NcbiAgICAodHJhY2suaWQgJiAweEZGMDAwMDAwKSA+PiAyNCxcbiAgICAodHJhY2suaWQgJiAweEZGMDAwMCkgPj4gMTYsXG4gICAgKHRyYWNrLmlkICYgMHhGRjAwKSA+PiA4LFxuICAgICh0cmFjay5pZCAmIDB4RkYpLCAvLyB0cmFja19JRFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIC8vIHNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgIC8vIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gIF0pKTtcblxuICB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcih0cmFjay5iYXNlTWVkaWFEZWNvZGVUaW1lIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKHRyYWNrLmJhc2VNZWRpYURlY29kZVRpbWUgJSAoVUlOVDMyX01BWCArIDEpKTtcblxuICB0cmFja0ZyYWdtZW50RGVjb2RlVGltZSA9IGJveCh0eXBlcy50ZmR0LCBuZXcgVWludDhBcnJheShbXG4gICAgMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgLy8gZmxhZ3NcbiAgICAvLyBiYXNlTWVkaWFEZWNvZGVUaW1lXG4gICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4+IDI0KSAmIDB4RkYsXG4gICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4+IDE2KSAmIDB4RkYsXG4gICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4+ICA4KSAmIDB4RkYsXG4gICAgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4RkYsXG4gICAgKGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4+IDI0KSAmIDB4RkYsXG4gICAgKGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4+IDE2KSAmIDB4RkYsXG4gICAgKGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4+ICA4KSAmIDB4RkYsXG4gICAgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4RkZcbiAgXSkpO1xuXG4gIC8vIHRoZSBkYXRhIG9mZnNldCBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiBieXRlcyBmcm9tIHRoZSBzdGFydCBvZlxuICAvLyB0aGUgY29udGFpbmluZyBtb29mIHRvIHRoZSBmaXJzdCBwYXlsb2FkIGJ5dGUgb2YgdGhlIGFzc29jaWF0ZWRcbiAgLy8gbWRhdFxuICBkYXRhT2Zmc2V0ID0gKDMyICsgLy8gdGZoZFxuICAgICAgICAgICAgICAgIDIwICsgLy8gdGZkdFxuICAgICAgICAgICAgICAgIDggKyAgLy8gdHJhZiBoZWFkZXJcbiAgICAgICAgICAgICAgICAxNiArIC8vIG1maGRcbiAgICAgICAgICAgICAgICA4ICsgIC8vIG1vb2YgaGVhZGVyXG4gICAgICAgICAgICAgICAgOCk7ICAvLyBtZGF0IGhlYWRlclxuXG4gIC8vIGF1ZGlvIHRyYWNrcyByZXF1aXJlIGxlc3MgbWV0YWRhdGFcbiAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICB0cmFja0ZyYWdtZW50UnVuID0gdHJ1bih0cmFjaywgZGF0YU9mZnNldCk7XG4gICAgcmV0dXJuIGJveCh0eXBlcy50cmFmLFxuICAgICAgICAgICAgICAgdHJhY2tGcmFnbWVudEhlYWRlcixcbiAgICAgICAgICAgICAgIHRyYWNrRnJhZ21lbnREZWNvZGVUaW1lLFxuICAgICAgICAgICAgICAgdHJhY2tGcmFnbWVudFJ1bik7XG4gIH1cblxuICAvLyB2aWRlbyB0cmFja3Mgc2hvdWxkIGNvbnRhaW4gYW4gaW5kZXBlbmRlbnQgYW5kIGRpc3Bvc2FibGUgc2FtcGxlc1xuICAvLyBib3ggKHNkdHApXG4gIC8vIGdlbmVyYXRlIG9uZSBhbmQgYWRqdXN0IG9mZnNldHMgdG8gbWF0Y2hcbiAgc2FtcGxlRGVwZW5kZW5jeVRhYmxlID0gc2R0cCh0cmFjayk7XG4gIHRyYWNrRnJhZ21lbnRSdW4gPSB0cnVuKHRyYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUubGVuZ3RoICsgZGF0YU9mZnNldCk7XG4gIHJldHVybiBib3godHlwZXMudHJhZixcbiAgICAgICAgICAgICB0cmFja0ZyYWdtZW50SGVhZGVyLFxuICAgICAgICAgICAgIHRyYWNrRnJhZ21lbnREZWNvZGVUaW1lLFxuICAgICAgICAgICAgIHRyYWNrRnJhZ21lbnRSdW4sXG4gICAgICAgICAgICAgc2FtcGxlRGVwZW5kZW5jeVRhYmxlKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSB0cmFjayBib3guXG4gKiBAcGFyYW0gdHJhY2sge29iamVjdH0gYSB0cmFjayBkZWZpbml0aW9uXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fSB0aGUgdHJhY2sgYm94XG4gKi9cbnRyYWsgPSBmdW5jdGlvbih0cmFjaykge1xuICB0cmFjay5kdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uIHx8IDB4ZmZmZmZmZmY7XG4gIHJldHVybiBib3godHlwZXMudHJhayxcbiAgICAgICAgICAgICB0a2hkKHRyYWNrKSxcbiAgICAgICAgICAgICBtZGlhKHRyYWNrKSk7XG59O1xuXG50cmV4ID0gZnVuY3Rpb24odHJhY2spIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAweDAwLCAweDAwLCAweDAwLCAvLyBmbGFnc1xuICAgICh0cmFjay5pZCAmIDB4RkYwMDAwMDApID4+IDI0LFxuICAgICh0cmFjay5pZCAmIDB4RkYwMDAwKSA+PiAxNixcbiAgICAodHJhY2suaWQgJiAweEZGMDApID4+IDgsXG4gICAgKHRyYWNrLmlkICYgMHhGRiksIC8vIHRyYWNrX0lEXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAvLyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC8vIGRlZmF1bHRfc2FtcGxlX3NpemVcbiAgICAweDAwLCAweDAxLCAweDAwLCAweDAxIC8vIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gIF0pO1xuICAvLyB0aGUgbGFzdCB0d28gYnl0ZXMgb2YgZGVmYXVsdF9zYW1wbGVfZmxhZ3MgaXMgdGhlIHNhbXBsZVxuICAvLyBkZWdyYWRhdGlvbiBwcmlvcml0eSwgYSBoaW50IGFib3V0IHRoZSBpbXBvcnRhbmNlIG9mIHRoaXMgc2FtcGxlXG4gIC8vIHJlbGF0aXZlIHRvIG90aGVycy4gTG93ZXIgdGhlIGRlZ3JhZGF0aW9uIHByaW9yaXR5IGZvciBhbGwgc2FtcGxlXG4gIC8vIHR5cGVzIG90aGVyIHRoYW4gdmlkZW8uXG4gIGlmICh0cmFjay50eXBlICE9PSAndmlkZW8nKSB7XG4gICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IDB4MDA7XG4gIH1cblxuICByZXR1cm4gYm94KHR5cGVzLnRyZXgsIHJlc3VsdCk7XG59O1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBhdWRpb1RydW4sIHZpZGVvVHJ1biwgdHJ1bkhlYWRlcjtcblxuICAvLyBUaGlzIG1ldGhvZCBhc3N1bWVzIGFsbCBzYW1wbGVzIGFyZSB1bmlmb3JtLiBUaGF0IGlzLCBpZiBhXG4gIC8vIGR1cmF0aW9uIGlzIHByZXNlbnQgZm9yIHRoZSBmaXJzdCBzYW1wbGUsIGl0IHdpbGwgYmUgcHJlc2VudCBmb3JcbiAgLy8gYWxsIHN1YnNlcXVlbnQgc2FtcGxlcy5cbiAgLy8gc2VlIElTTy9JRUMgMTQ0OTYtMTI6MjAxMiwgU2VjdGlvbiA4LjguOC4xXG4gIHRydW5IZWFkZXIgPSBmdW5jdGlvbihzYW1wbGVzLCBvZmZzZXQpIHtcbiAgICB2YXIgZHVyYXRpb25QcmVzZW50ID0gMCwgc2l6ZVByZXNlbnQgPSAwLFxuICAgICAgICBmbGFnc1ByZXNlbnQgPSAwLCBjb21wb3NpdGlvblRpbWVPZmZzZXQgPSAwO1xuXG4gICAgLy8gdHJ1biBmbGFnIGNvbnN0YW50c1xuICAgIGlmIChzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgaWYgKHNhbXBsZXNbMF0uZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkdXJhdGlvblByZXNlbnQgPSAweDE7XG4gICAgICB9XG4gICAgICBpZiAoc2FtcGxlc1swXS5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2l6ZVByZXNlbnQgPSAweDI7XG4gICAgICB9XG4gICAgICBpZiAoc2FtcGxlc1swXS5mbGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZsYWdzUHJlc2VudCA9IDB4NDtcbiAgICAgIH1cbiAgICAgIGlmIChzYW1wbGVzWzBdLmNvbXBvc2l0aW9uVGltZU9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXBvc2l0aW9uVGltZU9mZnNldCA9IDB4ODtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLFxuICAgICAgZHVyYXRpb25QcmVzZW50IHwgc2l6ZVByZXNlbnQgfCBmbGFnc1ByZXNlbnQgfCBjb21wb3NpdGlvblRpbWVPZmZzZXQsXG4gICAgICAweDAxLCAvLyBmbGFnc1xuICAgICAgKHNhbXBsZXMubGVuZ3RoICYgMHhGRjAwMDAwMCkgPj4+IDI0LFxuICAgICAgKHNhbXBsZXMubGVuZ3RoICYgMHhGRjAwMDApID4+PiAxNixcbiAgICAgIChzYW1wbGVzLmxlbmd0aCAmIDB4RkYwMCkgPj4+IDgsXG4gICAgICBzYW1wbGVzLmxlbmd0aCAmIDB4RkYsIC8vIHNhbXBsZV9jb3VudFxuICAgICAgKG9mZnNldCAmIDB4RkYwMDAwMDApID4+PiAyNCxcbiAgICAgIChvZmZzZXQgJiAweEZGMDAwMCkgPj4+IDE2LFxuICAgICAgKG9mZnNldCAmIDB4RkYwMCkgPj4+IDgsXG4gICAgICBvZmZzZXQgJiAweEZGIC8vIGRhdGFfb2Zmc2V0XG4gICAgXTtcbiAgfTtcblxuICB2aWRlb1RydW4gPSBmdW5jdGlvbih0cmFjaywgb2Zmc2V0KSB7XG4gICAgdmFyIGJ5dGVzLCBzYW1wbGVzLCBzYW1wbGUsIGk7XG5cbiAgICBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXTtcbiAgICBvZmZzZXQgKz0gOCArIDEyICsgKDE2ICogc2FtcGxlcy5sZW5ndGgpO1xuXG4gICAgYnl0ZXMgPSB0cnVuSGVhZGVyKHNhbXBsZXMsIG9mZnNldCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgc2FtcGxlID0gc2FtcGxlc1tpXTtcbiAgICAgIGJ5dGVzID0gYnl0ZXMuY29uY2F0KFtcbiAgICAgICAgKHNhbXBsZS5kdXJhdGlvbiAmIDB4RkYwMDAwMDApID4+PiAyNCxcbiAgICAgICAgKHNhbXBsZS5kdXJhdGlvbiAmIDB4RkYwMDAwKSA+Pj4gMTYsXG4gICAgICAgIChzYW1wbGUuZHVyYXRpb24gJiAweEZGMDApID4+PiA4LFxuICAgICAgICBzYW1wbGUuZHVyYXRpb24gJiAweEZGLCAvLyBzYW1wbGVfZHVyYXRpb25cbiAgICAgICAgKHNhbXBsZS5zaXplICYgMHhGRjAwMDAwMCkgPj4+IDI0LFxuICAgICAgICAoc2FtcGxlLnNpemUgJiAweEZGMDAwMCkgPj4+IDE2LFxuICAgICAgICAoc2FtcGxlLnNpemUgJiAweEZGMDApID4+PiA4LFxuICAgICAgICBzYW1wbGUuc2l6ZSAmIDB4RkYsIC8vIHNhbXBsZV9zaXplXG4gICAgICAgIChzYW1wbGUuZmxhZ3MuaXNMZWFkaW5nIDw8IDIpIHwgc2FtcGxlLmZsYWdzLmRlcGVuZHNPbixcbiAgICAgICAgKHNhbXBsZS5mbGFncy5pc0RlcGVuZGVkT24gPDwgNikgfFxuICAgICAgICAgIChzYW1wbGUuZmxhZ3MuaGFzUmVkdW5kYW5jeSA8PCA0KSB8XG4gICAgICAgICAgKHNhbXBsZS5mbGFncy5wYWRkaW5nVmFsdWUgPDwgMSkgfFxuICAgICAgICAgIHNhbXBsZS5mbGFncy5pc05vblN5bmNTYW1wbGUsXG4gICAgICAgIHNhbXBsZS5mbGFncy5kZWdyYWRhdGlvblByaW9yaXR5ICYgMHhGMCA8PCA4LFxuICAgICAgICBzYW1wbGUuZmxhZ3MuZGVncmFkYXRpb25Qcmlvcml0eSAmIDB4MEYsIC8vIHNhbXBsZV9mbGFnc1xuICAgICAgICAoc2FtcGxlLmNvbXBvc2l0aW9uVGltZU9mZnNldCAmIDB4RkYwMDAwMDApID4+PiAyNCxcbiAgICAgICAgKHNhbXBsZS5jb21wb3NpdGlvblRpbWVPZmZzZXQgJiAweEZGMDAwMCkgPj4+IDE2LFxuICAgICAgICAoc2FtcGxlLmNvbXBvc2l0aW9uVGltZU9mZnNldCAmIDB4RkYwMCkgPj4+IDgsXG4gICAgICAgIHNhbXBsZS5jb21wb3NpdGlvblRpbWVPZmZzZXQgJiAweEZGIC8vIHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiBib3godHlwZXMudHJ1biwgbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgfTtcblxuICBhdWRpb1RydW4gPSBmdW5jdGlvbih0cmFjaywgb2Zmc2V0KSB7XG4gICAgdmFyIGJ5dGVzLCBzYW1wbGVzLCBzYW1wbGUsIGk7XG5cbiAgICBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXTtcbiAgICBvZmZzZXQgKz0gOCArIDEyICsgKDggKiBzYW1wbGVzLmxlbmd0aCk7XG5cbiAgICBieXRlcyA9IHRydW5IZWFkZXIoc2FtcGxlcywgb2Zmc2V0KTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzYW1wbGUgPSBzYW1wbGVzW2ldO1xuICAgICAgYnl0ZXMgPSBieXRlcy5jb25jYXQoW1xuICAgICAgICAoc2FtcGxlLmR1cmF0aW9uICYgMHhGRjAwMDAwMCkgPj4+IDI0LFxuICAgICAgICAoc2FtcGxlLmR1cmF0aW9uICYgMHhGRjAwMDApID4+PiAxNixcbiAgICAgICAgKHNhbXBsZS5kdXJhdGlvbiAmIDB4RkYwMCkgPj4+IDgsXG4gICAgICAgIHNhbXBsZS5kdXJhdGlvbiAmIDB4RkYsIC8vIHNhbXBsZV9kdXJhdGlvblxuICAgICAgICAoc2FtcGxlLnNpemUgJiAweEZGMDAwMDAwKSA+Pj4gMjQsXG4gICAgICAgIChzYW1wbGUuc2l6ZSAmIDB4RkYwMDAwKSA+Pj4gMTYsXG4gICAgICAgIChzYW1wbGUuc2l6ZSAmIDB4RkYwMCkgPj4+IDgsXG4gICAgICAgIHNhbXBsZS5zaXplICYgMHhGRl0pOyAvLyBzYW1wbGVfc2l6ZVxuICAgIH1cblxuICAgIHJldHVybiBib3godHlwZXMudHJ1biwgbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgfTtcblxuICB0cnVuID0gZnVuY3Rpb24odHJhY2ssIG9mZnNldCkge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm4gYXVkaW9UcnVuKHRyYWNrLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiB2aWRlb1RydW4odHJhY2ssIG9mZnNldCk7XG4gIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZnR5cDogZnR5cCxcbiAgbWRhdDogbWRhdCxcbiAgbW9vZjogbW9vZixcbiAgbW9vdjogbW9vdixcbiAgaW5pdFNlZ21lbnQ6IGZ1bmN0aW9uKHRyYWNrcykge1xuICAgIHZhclxuICAgICAgZmlsZVR5cGUgPSBmdHlwKCksXG4gICAgICBtb3ZpZSA9IG1vb3YodHJhY2tzKSxcbiAgICAgIHJlc3VsdDtcblxuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGZpbGVUeXBlLmJ5dGVMZW5ndGggKyBtb3ZpZS5ieXRlTGVuZ3RoKTtcbiAgICByZXN1bHQuc2V0KGZpbGVUeXBlKTtcbiAgICByZXN1bHQuc2V0KG1vdmllLCBmaWxlVHlwZS5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG59LHt9XSw1NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIG11eC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBCcmlnaHRjb3ZlXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFV0aWxpdGllcyB0byBkZXRlY3QgYmFzaWMgcHJvcGVydGllcyBhbmQgbWV0YWRhdGEgYWJvdXQgTVA0cy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZmluZEJveCwgcGFyc2VUeXBlLCB0aW1lc2NhbGUsIHN0YXJ0VGltZTtcblxuLy8gRmluZCB0aGUgZGF0YSBmb3IgYSBib3ggc3BlY2lmaWVkIGJ5IGl0cyBwYXRoXG5maW5kQm94ID0gZnVuY3Rpb24oZGF0YSwgcGF0aCkge1xuICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgaSwgc2l6ZSwgdHlwZSwgZW5kLCBzdWJyZXN1bHRzO1xuXG4gIGlmICghcGF0aC5sZW5ndGgpIHtcbiAgICAvLyBzaG9ydC1jaXJjdWl0IHRoZSBzZWFyY2ggZm9yIGVtcHR5IHBhdGhzXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5ieXRlTGVuZ3RoOykge1xuICAgIHNpemUgID0gZGF0YVtpXSAgICAgPDwgMjQ7XG4gICAgc2l6ZSB8PSBkYXRhW2kgKyAxXSA8PCAxNjtcbiAgICBzaXplIHw9IGRhdGFbaSArIDJdIDw8IDg7XG4gICAgc2l6ZSB8PSBkYXRhW2kgKyAzXTtcblxuICAgIHR5cGUgPSBwYXJzZVR5cGUoZGF0YS5zdWJhcnJheShpICsgNCwgaSArIDgpKTtcblxuICAgIGVuZCA9IHNpemUgPiAxID8gaSArIHNpemUgOiBkYXRhLmJ5dGVMZW5ndGg7XG5cbiAgICBpZiAodHlwZSA9PT0gcGF0aFswXSkge1xuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgcGF0aCBhbmQgd2UndmUgZm91bmQgdGhlIGJveCB3ZSB3ZXJlXG4gICAgICAgIC8vIGxvb2tpbmcgZm9yXG4gICAgICAgIHJlc3VsdHMucHVzaChkYXRhLnN1YmFycmF5KGkgKyA4LCBlbmQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgdGhlIG5leHQgYm94IGFsb25nIHRoZSBwYXRoXG4gICAgICAgIHN1YnJlc3VsdHMgPSBmaW5kQm94KGRhdGEuc3ViYXJyYXkoaSArIDgsIGVuZCksIHBhdGguc2xpY2UoMSkpO1xuICAgICAgICBpZiAoc3VicmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQoc3VicmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaSA9IGVuZDtcbiAgfVxuXG4gIC8vIHdlJ3ZlIGZpbmlzaGVkIHNlYXJjaGluZyBhbGwgb2YgZGF0YVxuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFTQ0lJIGVuY29kZWQgZm91ciBieXRlIGJ1ZmZlci5cbiAqIEBwYXJhbSBidWZmZXIge1VpbnQ4QXJyYXl9IGEgZm91ci1ieXRlIGJ1ZmZlciB0byB0cmFuc2xhdGVcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGNvcnJlc3BvbmRpbmcgc3RyaW5nXG4gKi9cbnBhcnNlVHlwZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlclswXSk7XG4gIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlclsxXSk7XG4gIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlclsyXSk7XG4gIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlclszXSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhbiBNUDQgaW5pdGlhbGl6YXRpb24gc2VnbWVudCBhbmQgZXh0cmFjdHMgdGhlIHRpbWVzY2FsZVxuICogdmFsdWVzIGZvciBhbnkgZGVjbGFyZWQgdHJhY2tzLiBUaW1lc2NhbGUgdmFsdWVzIGluZGljYXRlIHRoZVxuICogbnVtYmVyIG9mIGNsb2NrIHRpY2tzIHBlciBzZWNvbmQgdG8gYXNzdW1lIGZvciB0aW1lLWJhc2VkIHZhbHVlc1xuICogZWxzZXdoZXJlIGluIHRoZSBNUDQuXG4gKlxuICogVG8gZGV0ZXJtaW5lIHRoZSBzdGFydCB0aW1lIG9mIGFuIE1QNCwgeW91IG5lZWQgdHdvIHBpZWNlcyBvZlxuICogaW5mb3JtYXRpb246IHRoZSB0aW1lc2NhbGUgdW5pdCBhbmQgdGhlIGVhcmxpZXN0IGJhc2UgbWVkaWEgZGVjb2RlXG4gKiB0aW1lLiBNdWx0aXBsZSB0aW1lc2NhbGVzIGNhbiBiZSBzcGVjaWZpZWQgd2l0aGluIGFuIE1QNCBidXQgdGhlXG4gKiBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGlzIGFsd2F5cyBleHByZXNzZWQgaW4gdGhlIHRpbWVzY2FsZSBmcm9tXG4gKiB0aGUgbWVkaWEgaGVhZGVyIGJveCBmb3IgdGhlIHRyYWNrOlxuICogYGBgXG4gKiBtb292ID4gdHJhayA+IG1kaWEgPiBtZGhkLnRpbWVzY2FsZVxuICogYGBgXG4gKiBAcGFyYW0gaW5pdCB7VWludDhBcnJheX0gdGhlIGJ5dGVzIG9mIHRoZSBpbml0IHNlZ21lbnRcbiAqIEByZXR1cm4ge29iamVjdH0gYSBoYXNoIG9mIHRyYWNrIGlkcyB0byB0aW1lc2NhbGUgdmFsdWVzIG9yIG51bGwgaWZcbiAqIHRoZSBpbml0IHNlZ21lbnQgaXMgbWFsZm9ybWVkLlxuICovXG50aW1lc2NhbGUgPSBmdW5jdGlvbihpbml0KSB7XG4gIHZhclxuICAgIHJlc3VsdCA9IHt9LFxuICAgIHRyYWtzID0gZmluZEJveChpbml0LCBbJ21vb3YnLCAndHJhayddKTtcblxuICAvLyBtZGhkIHRpbWVzY2FsZVxuICByZXR1cm4gdHJha3MucmVkdWNlKGZ1bmN0aW9uKHJlc3VsdCwgdHJhaykge1xuICAgIHZhciB0a2hkLCB2ZXJzaW9uLCBpbmRleCwgaWQsIG1kaGQ7XG5cbiAgICB0a2hkID0gZmluZEJveCh0cmFrLCBbJ3RraGQnXSlbMF07XG4gICAgaWYgKCF0a2hkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmVyc2lvbiA9IHRraGRbMF07XG4gICAgaW5kZXggPSB2ZXJzaW9uID09PSAwID8gMTIgOiAyMDtcbiAgICBpZCA9IHRraGRbaW5kZXhdICAgICA8PCAyNCB8XG4gICAgICAgICB0a2hkW2luZGV4ICsgMV0gPDwgMTYgfFxuICAgICAgICAgdGtoZFtpbmRleCArIDJdIDw8ICA4IHxcbiAgICAgICAgIHRraGRbaW5kZXggKyAzXTtcblxuICAgIG1kaGQgPSBmaW5kQm94KHRyYWssIFsnbWRpYScsICdtZGhkJ10pWzBdO1xuICAgIGlmICghbWRoZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZlcnNpb24gPSBtZGhkWzBdO1xuICAgIGluZGV4ID0gdmVyc2lvbiA9PT0gMCA/IDEyIDogMjA7XG4gICAgcmVzdWx0W2lkXSA9IG1kaGRbaW5kZXhdICAgICA8PCAyNCB8XG4gICAgICAgICAgICAgICAgIG1kaGRbaW5kZXggKyAxXSA8PCAxNiB8XG4gICAgICAgICAgICAgICAgIG1kaGRbaW5kZXggKyAyXSA8PCAgOCB8XG4gICAgICAgICAgICAgICAgIG1kaGRbaW5kZXggKyAzXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHN0YXJ0IHRpbWUsIGluIHNlY29uZHMsIGZvciBhbiBNUDRcbiAqIGZyYWdtZW50LiBJZiBtdWx0aXBsZSBmcmFnbWVudHMgYXJlIHNwZWNpZmllZCwgdGhlIGVhcmxpZXN0IHRpbWUgaXNcbiAqIHJldHVybmVkLlxuICpcbiAqIFRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGNhbiBiZSBwYXJzZWQgZnJvbSB0cmFjayBmcmFnbWVudFxuICogbWV0YWRhdGE6XG4gKiBgYGBcbiAqIG1vb2YgPiB0cmFmID4gdGZkdC5iYXNlTWVkaWFEZWNvZGVUaW1lXG4gKiBgYGBcbiAqIEl0IHJlcXVpcmVzIHRoZSB0aW1lc2NhbGUgdmFsdWUgZnJvbSB0aGUgbWRoZCB0byBpbnRlcnByZXQuXG4gKlxuICogQHBhcmFtIHRpbWVzY2FsZSB7b2JqZWN0fSBhIGhhc2ggb2YgdHJhY2sgaWRzIHRvIHRpbWVzY2FsZSB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lIGZvciB0aGVcbiAqIGZyYWdtZW50LCBpbiBzZWNvbmRzXG4gKi9cbnN0YXJ0VGltZSA9IGZ1bmN0aW9uKHRpbWVzY2FsZSwgZnJhZ21lbnQpIHtcbiAgdmFyIHRyYWZzLCBiYXNlVGltZXMsIHJlc3VsdDtcblxuICAvLyB3ZSBuZWVkIGluZm8gZnJvbSB0d28gY2hpbGRyZW5kIG9mIGVhY2ggdHJhY2sgZnJhZ21lbnQgYm94XG4gIHRyYWZzID0gZmluZEJveChmcmFnbWVudCwgWydtb29mJywgJ3RyYWYnXSk7XG5cbiAgLy8gZGV0ZXJtaW5lIHRoZSBzdGFydCB0aW1lcyBmb3IgZWFjaCB0cmFja1xuICBiYXNlVGltZXMgPSBbXS5jb25jYXQuYXBwbHkoW10sIHRyYWZzLm1hcChmdW5jdGlvbih0cmFmKSB7XG4gICAgcmV0dXJuIGZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLm1hcChmdW5jdGlvbih0ZmhkKSB7XG4gICAgICB2YXIgaWQsIHNjYWxlLCBiYXNlVGltZTtcblxuICAgICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgICBpZCA9IHRmaGRbNF0gPDwgMjQgfFxuICAgICAgICAgICB0ZmhkWzVdIDw8IDE2IHxcbiAgICAgICAgICAgdGZoZFs2XSA8PCA4IHxcbiAgICAgICAgICAgdGZoZFs3XTtcbiAgICAgIC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXG4gICAgICBzY2FsZSA9IHRpbWVzY2FsZVtpZF0gfHwgOTBlMztcblxuICAgICAgLy8gZ2V0IHRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGZyb20gdGhlIHRmZHRcbiAgICAgIGJhc2VUaW1lID0gZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkubWFwKGZ1bmN0aW9uKHRmZHQpIHtcbiAgICAgICAgdmFyIHZlcnNpb24sIHJlc3VsdDtcblxuICAgICAgICB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICAgICAgcmVzdWx0ID0gdGZkdFs0XSA8PCAyNCB8XG4gICAgICAgICAgICAgICAgIHRmZHRbNV0gPDwgMTYgfFxuICAgICAgICAgICAgICAgICB0ZmR0WzZdIDw8ICA4IHxcbiAgICAgICAgICAgICAgICAgdGZkdFs3XTtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09ICAxKSB7XG4gICAgICAgICAgcmVzdWx0ICo9IE1hdGgucG93KDIsIDMyKTtcbiAgICAgICAgICByZXN1bHQgKz0gdGZkdFs4XSAgPDwgMjQgfFxuICAgICAgICAgICAgICAgICAgICB0ZmR0WzldICA8PCAxNiB8XG4gICAgICAgICAgICAgICAgICAgIHRmZHRbMTBdIDw8ICA4IHxcbiAgICAgICAgICAgICAgICAgICAgdGZkdFsxMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pWzBdO1xuICAgICAgYmFzZVRpbWUgPSBiYXNlVGltZSB8fCBJbmZpbml0eTtcblxuICAgICAgLy8gY29udmVydCBiYXNlIHRpbWUgdG8gc2Vjb25kc1xuICAgICAgcmV0dXJuIGJhc2VUaW1lIC8gc2NhbGU7XG4gICAgfSk7XG4gIH0pKTtcblxuICAvLyByZXR1cm4gdGhlIG1pbmltdW1cbiAgcmVzdWx0ID0gTWF0aC5taW4uYXBwbHkobnVsbCwgYmFzZVRpbWVzKTtcbiAgcmV0dXJuIGlzRmluaXRlKHJlc3VsdCkgPyByZXN1bHQgOiAwO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlVHlwZTogcGFyc2VUeXBlLFxuICB0aW1lc2NhbGU6IHRpbWVzY2FsZSxcbiAgc3RhcnRUaW1lOiBzdGFydFRpbWVcbn07XG5cbn0se31dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogbXV4LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEJyaWdodGNvdmVcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogQSBzdHJlYW0tYmFzZWQgbXAydCB0byBtcDQgY29udmVydGVyLiBUaGlzIHV0aWxpdHkgY2FuIGJlIHVzZWQgdG9cbiAqIGRlbGl2ZXIgbXA0cyB0byBhIFNvdXJjZUJ1ZmZlciBvbiBwbGF0Zm9ybXMgdGhhdCBzdXBwb3J0IG5hdGl2ZVxuICogTWVkaWEgU291cmNlIEV4dGVuc2lvbnMuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4uL3V0aWxzL3N0cmVhbS5qcycpO1xudmFyIG1wNCA9IHJlcXVpcmUoJy4vbXA0LWdlbmVyYXRvci5qcycpO1xudmFyIG0ydHMgPSByZXF1aXJlKCcuLi9tMnRzL20ydHMuanMnKTtcbnZhciBBZHRzU3RyZWFtID0gcmVxdWlyZSgnLi4vY29kZWNzL2FkdHMuanMnKTtcbnZhciBIMjY0U3RyZWFtID0gcmVxdWlyZSgnLi4vY29kZWNzL2gyNjQnKS5IMjY0U3RyZWFtO1xudmFyIEFhY1N0cmVhbSA9IHJlcXVpcmUoJy4uL2FhYycpO1xudmFyIGNvbmVPZlNpbGVuY2UgPSByZXF1aXJlKCcuLi9kYXRhL3NpbGVuY2UnKTtcbnZhciBjbG9jayA9IHJlcXVpcmUoJy4uL3V0aWxzL2Nsb2NrJyk7XG5cbi8vIGNvbnN0YW50c1xudmFyIEFVRElPX1BST1BFUlRJRVMgPSBbXG4gICdhdWRpb29iamVjdHR5cGUnLFxuICAnY2hhbm5lbGNvdW50JyxcbiAgJ3NhbXBsZXJhdGUnLFxuICAnc2FtcGxpbmdmcmVxdWVuY3lpbmRleCcsXG4gICdzYW1wbGVzaXplJ1xuXTtcblxudmFyIFZJREVPX1BST1BFUlRJRVMgPSBbXG4gICd3aWR0aCcsXG4gICdoZWlnaHQnLFxuICAncHJvZmlsZUlkYycsXG4gICdsZXZlbElkYycsXG4gICdwcm9maWxlQ29tcGF0aWJpbGl0eSdcbl07XG5cbnZhciBPTkVfU0VDT05EX0lOX1RTID0gOTAwMDA7IC8vIDkwa0h6IGNsb2NrXG5cbi8vIG9iamVjdCB0eXBlc1xudmFyIFZpZGVvU2VnbWVudFN0cmVhbSwgQXVkaW9TZWdtZW50U3RyZWFtLCBUcmFuc211eGVyLCBDb2FsZXNjZVN0cmVhbTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uc1xudmFyXG4gIGNyZWF0ZURlZmF1bHRTYW1wbGUsXG4gIGlzTGlrZWx5QWFjRGF0YSxcbiAgY29sbGVjdER0c0luZm8sXG4gIGNsZWFyRHRzSW5mbyxcbiAgY2FsY3VsYXRlVHJhY2tCYXNlTWVkaWFEZWNvZGVUaW1lLFxuICBhcnJheUVxdWFscyxcbiAgc3VtRnJhbWVCeXRlTGVuZ3RocztcblxuLyoqXG4gKiBEZWZhdWx0IHNhbXBsZSBvYmplY3RcbiAqIHNlZSBJU08vSUVDIDE0NDk2LTEyOjIwMTIsIHNlY3Rpb24gOC42LjQuM1xuICovXG5jcmVhdGVEZWZhdWx0U2FtcGxlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgc2l6ZTogMCxcbiAgICBmbGFnczoge1xuICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgZGVwZW5kc09uOiAxLFxuICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgaGFzUmVkdW5kYW5jeTogMCxcbiAgICAgIGRlZ3JhZGF0aW9uUHJpb3JpdHk6IDBcbiAgICB9XG4gIH07XG59O1xuXG5pc0xpa2VseUFhY0RhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGlmICgoZGF0YVswXSA9PT0gJ0knLmNoYXJDb2RlQXQoMCkpICYmXG4gICAgICAoZGF0YVsxXSA9PT0gJ0QnLmNoYXJDb2RlQXQoMCkpICYmXG4gICAgICAoZGF0YVsyXSA9PT0gJzMnLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDb21wYXJlIHR3byBhcnJheXMgKGV2ZW4gdHlwZWQpIGZvciBzYW1lLW5lc3NcbiAqL1xuYXJyYXlFcXVhbHMgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhclxuICAgIGk7XG5cbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGNvbXBhcmUgdGhlIHZhbHVlIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXlcbiAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBTdW0gdGhlIGBieXRlTGVuZ3RoYCBwcm9wZXJ0aWVzIG9mIHRoZSBkYXRhIGluIGVhY2ggQUFDIGZyYW1lXG4gKi9cbnN1bUZyYW1lQnl0ZUxlbmd0aHMgPSBmdW5jdGlvbihhcnJheSkge1xuICB2YXJcbiAgICBpLFxuICAgIGN1cnJlbnRPYmosXG4gICAgc3VtID0gMDtcblxuICAvLyBzdW0gdGhlIGJ5dGVMZW5ndGgncyBhbGwgZWFjaCBuYWwgdW5pdCBpbiB0aGUgZnJhbWVcbiAgZm9yIChpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY3VycmVudE9iaiA9IGFycmF5W2ldO1xuICAgIHN1bSArPSBjdXJyZW50T2JqLmRhdGEuYnl0ZUxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBzdW07XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBzaW5nbGUtdHJhY2ssIElTTyBCTUZGIG1lZGlhIHNlZ21lbnQgZnJvbSBBQUMgZGF0YVxuICogZXZlbnRzLiBUaGUgb3V0cHV0IG9mIHRoaXMgc3RyZWFtIGNhbiBiZSBmZWQgdG8gYSBTb3VyY2VCdWZmZXJcbiAqIGNvbmZpZ3VyZWQgd2l0aCBhIHN1aXRhYmxlIGluaXRpYWxpemF0aW9uIHNlZ21lbnQuXG4gKi9cbkF1ZGlvU2VnbWVudFN0cmVhbSA9IGZ1bmN0aW9uKHRyYWNrKSB7XG4gIHZhclxuICAgIGFkdHNGcmFtZXMgPSBbXSxcbiAgICBzZXF1ZW5jZU51bWJlciA9IDAsXG4gICAgZWFybGllc3RBbGxvd2VkRHRzID0gMCxcbiAgICBhdWRpb0FwcGVuZFN0YXJ0VHMgPSAwLFxuICAgIHZpZGVvQmFzZU1lZGlhRGVjb2RlVGltZSA9IEluZmluaXR5O1xuXG4gIEF1ZGlvU2VnbWVudFN0cmVhbS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMucHVzaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBjb2xsZWN0RHRzSW5mbyh0cmFjaywgZGF0YSk7XG5cbiAgICBpZiAodHJhY2spIHtcbiAgICAgIEFVRElPX1BST1BFUlRJRVMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHRyYWNrW3Byb3BdID0gZGF0YVtwcm9wXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGJ1ZmZlciBhdWRpbyBkYXRhIHVudGlsIGVuZCgpIGlzIGNhbGxlZFxuICAgIGFkdHNGcmFtZXMucHVzaChkYXRhKTtcbiAgfTtcblxuICB0aGlzLnNldEVhcmxpZXN0RHRzID0gZnVuY3Rpb24oZWFybGllc3REdHMpIHtcbiAgICBlYXJsaWVzdEFsbG93ZWREdHMgPSBlYXJsaWVzdER0cyAtIHRyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmJhc2VNZWRpYURlY29kZVRpbWU7XG4gIH07XG5cbiAgdGhpcy5zZXRWaWRlb0Jhc2VNZWRpYURlY29kZVRpbWUgPSBmdW5jdGlvbihiYXNlTWVkaWFEZWNvZGVUaW1lKSB7XG4gICAgdmlkZW9CYXNlTWVkaWFEZWNvZGVUaW1lID0gYmFzZU1lZGlhRGVjb2RlVGltZTtcbiAgfTtcblxuICB0aGlzLnNldEF1ZGlvQXBwZW5kU3RhcnQgPSBmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgICBhdWRpb0FwcGVuZFN0YXJ0VHMgPSB0aW1lc3RhbXA7XG4gIH07XG5cbiAgdGhpcy5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhclxuICAgICAgZnJhbWVzLFxuICAgICAgbW9vZixcbiAgICAgIG1kYXQsXG4gICAgICBib3hlcztcblxuICAgIC8vIHJldHVybiBlYXJseSBpZiBubyBhdWRpbyBkYXRhIGhhcyBiZWVuIG9ic2VydmVkXG4gICAgaWYgKGFkdHNGcmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RvbmUnLCAnQXVkaW9TZWdtZW50U3RyZWFtJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnJhbWVzID0gdGhpcy50cmltQWR0c0ZyYW1lc0J5RWFybGllc3REdHNfKGFkdHNGcmFtZXMpO1xuICAgIHRyYWNrLmJhc2VNZWRpYURlY29kZVRpbWUgPSBjYWxjdWxhdGVUcmFja0Jhc2VNZWRpYURlY29kZVRpbWUodHJhY2spO1xuXG4gICAgdGhpcy5wcmVmaXhXaXRoU2lsZW5jZV8odHJhY2ssIGZyYW1lcyk7XG5cbiAgICAvLyB3ZSBoYXZlIHRvIGJ1aWxkIHRoZSBpbmRleCBmcm9tIGJ5dGUgbG9jYXRpb25zIHRvXG4gICAgLy8gc2FtcGxlcyAodGhhdCBpcywgYWR0cyBmcmFtZXMpIGluIHRoZSBhdWRpbyBkYXRhXG4gICAgdHJhY2suc2FtcGxlcyA9IHRoaXMuZ2VuZXJhdGVTYW1wbGVUYWJsZV8oZnJhbWVzKTtcblxuICAgIC8vIGNvbmNhdGVuYXRlIHRoZSBhdWRpbyBkYXRhIHRvIGNvbnN0dWN0IHRoZSBtZGF0XG4gICAgbWRhdCA9IG1wNC5tZGF0KHRoaXMuY29uY2F0ZW5hdGVGcmFtZURhdGFfKGZyYW1lcykpO1xuXG4gICAgYWR0c0ZyYW1lcyA9IFtdO1xuXG4gICAgbW9vZiA9IG1wNC5tb29mKHNlcXVlbmNlTnVtYmVyLCBbdHJhY2tdKTtcbiAgICBib3hlcyA9IG5ldyBVaW50OEFycmF5KG1vb2YuYnl0ZUxlbmd0aCArIG1kYXQuYnl0ZUxlbmd0aCk7XG5cbiAgICAvLyBidW1wIHRoZSBzZXF1ZW5jZSBudW1iZXIgZm9yIG5leHQgdGltZVxuICAgIHNlcXVlbmNlTnVtYmVyKys7XG5cbiAgICBib3hlcy5zZXQobW9vZik7XG4gICAgYm94ZXMuc2V0KG1kYXQsIG1vb2YuYnl0ZUxlbmd0aCk7XG5cbiAgICBjbGVhckR0c0luZm8odHJhY2spO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdkYXRhJywge3RyYWNrOiB0cmFjaywgYm94ZXM6IGJveGVzfSk7XG4gICAgdGhpcy50cmlnZ2VyKCdkb25lJywgJ0F1ZGlvU2VnbWVudFN0cmVhbScpO1xuICB9O1xuXG4gIC8vIFBvc3NpYmx5IHBhZCAocHJlZml4KSB0aGUgYXVkaW8gdHJhY2sgd2l0aCBzaWxlbmNlIGlmIGFwcGVuZGluZyB0aGlzIHRyYWNrXG4gIC8vIHdvdWxkIGxlYWQgdG8gdGhlIGludHJvZHVjdGlvbiBvZiBhIGdhcCBpbiB0aGUgYXVkaW8gYnVmZmVyXG4gIHRoaXMucHJlZml4V2l0aFNpbGVuY2VfID0gZnVuY3Rpb24odHJhY2ssIGZyYW1lcykge1xuICAgIHZhclxuICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZVRzLFxuICAgICAgZnJhbWVEdXJhdGlvbiA9IDAsXG4gICAgICBhdWRpb0dhcER1cmF0aW9uID0gMCxcbiAgICAgIGF1ZGlvRmlsbEZyYW1lQ291bnQgPSAwLFxuICAgICAgYXVkaW9GaWxsRHVyYXRpb24gPSAwLFxuICAgICAgc2lsZW50RnJhbWUsXG4gICAgICBpO1xuXG4gICAgaWYgKCFmcmFtZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYmFzZU1lZGlhRGVjb2RlVGltZVRzID0gY2xvY2suYXVkaW9Uc1RvVmlkZW9Ucyh0cmFjay5iYXNlTWVkaWFEZWNvZGVUaW1lLCB0cmFjay5zYW1wbGVyYXRlKTtcbiAgICAvLyBkZXRlcm1pbmUgZnJhbWUgY2xvY2sgZHVyYXRpb24gYmFzZWQgb24gc2FtcGxlIHJhdGUsIHJvdW5kIHVwIHRvIGF2b2lkIG92ZXJmaWxsc1xuICAgIGZyYW1lRHVyYXRpb24gPSBNYXRoLmNlaWwoT05FX1NFQ09ORF9JTl9UUyAvICh0cmFjay5zYW1wbGVyYXRlIC8gMTAyNCkpO1xuXG4gICAgaWYgKGF1ZGlvQXBwZW5kU3RhcnRUcyAmJiB2aWRlb0Jhc2VNZWRpYURlY29kZVRpbWUpIHtcbiAgICAgIC8vIGluc2VydCB0aGUgc2hvcnRlc3QgcG9zc2libGUgYW1vdW50IChhdWRpbyBnYXAgb3IgYXVkaW8gdG8gdmlkZW8gZ2FwKVxuICAgICAgYXVkaW9HYXBEdXJhdGlvbiA9XG4gICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWVUcyAtIE1hdGgubWF4KGF1ZGlvQXBwZW5kU3RhcnRUcywgdmlkZW9CYXNlTWVkaWFEZWNvZGVUaW1lKTtcbiAgICAgIC8vIG51bWJlciBvZiBmdWxsIGZyYW1lcyBpbiB0aGUgYXVkaW8gZ2FwXG4gICAgICBhdWRpb0ZpbGxGcmFtZUNvdW50ID0gTWF0aC5mbG9vcihhdWRpb0dhcER1cmF0aW9uIC8gZnJhbWVEdXJhdGlvbik7XG4gICAgICBhdWRpb0ZpbGxEdXJhdGlvbiA9IGF1ZGlvRmlsbEZyYW1lQ291bnQgKiBmcmFtZUR1cmF0aW9uO1xuICAgIH1cblxuICAgIC8vIGRvbid0IGF0dGVtcHQgdG8gZmlsbCBnYXBzIHNtYWxsZXIgdGhhbiBhIHNpbmdsZSBmcmFtZSBvciBsYXJnZXJcbiAgICAvLyB0aGFuIGEgaGFsZiBzZWNvbmRcbiAgICBpZiAoYXVkaW9GaWxsRnJhbWVDb3VudCA8IDEgfHwgYXVkaW9GaWxsRHVyYXRpb24gPiBPTkVfU0VDT05EX0lOX1RTIC8gMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNpbGVudEZyYW1lID0gY29uZU9mU2lsZW5jZVt0cmFjay5zYW1wbGVyYXRlXTtcblxuICAgIGlmICghc2lsZW50RnJhbWUpIHtcbiAgICAgIC8vIHdlIGRvbid0IGhhdmUgYSBzaWxlbnQgZnJhbWUgcHJlZ2VuZXJhdGVkIGZvciB0aGUgc2FtcGxlIHJhdGUsIHNvIHVzZSBhIGZyYW1lXG4gICAgICAvLyBmcm9tIHRoZSBjb250ZW50IGluc3RlYWRcbiAgICAgIHNpbGVudEZyYW1lID0gZnJhbWVzWzBdLmRhdGE7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGF1ZGlvRmlsbEZyYW1lQ291bnQ7IGkrKykge1xuICAgICAgZnJhbWVzLnNwbGljZShpLCAwLCB7XG4gICAgICAgIGRhdGE6IHNpbGVudEZyYW1lXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0cmFjay5iYXNlTWVkaWFEZWNvZGVUaW1lIC09XG4gICAgICBNYXRoLmZsb29yKGNsb2NrLnZpZGVvVHNUb0F1ZGlvVHMoYXVkaW9GaWxsRHVyYXRpb24sIHRyYWNrLnNhbXBsZXJhdGUpKTtcbiAgfTtcblxuICAvLyBJZiB0aGUgYXVkaW8gc2VnbWVudCBleHRlbmRzIGJlZm9yZSB0aGUgZWFybGllc3QgYWxsb3dlZCBkdHNcbiAgLy8gdmFsdWUsIHJlbW92ZSBBQUMgZnJhbWVzIHVudGlsIHN0YXJ0cyBhdCBvciBhZnRlciB0aGUgZWFybGllc3RcbiAgLy8gYWxsb3dlZCBEVFMgc28gdGhhdCB3ZSBkb24ndCBlbmQgdXAgd2l0aCBhIG5lZ2F0aXZlIGJhc2VNZWRpYS1cbiAgLy8gRGVjb2RlVGltZSBmb3IgdGhlIGF1ZGlvIHRyYWNrXG4gIHRoaXMudHJpbUFkdHNGcmFtZXNCeUVhcmxpZXN0RHRzXyA9IGZ1bmN0aW9uKGFkdHNGcmFtZXMpIHtcbiAgICBpZiAodHJhY2subWluU2VnbWVudER0cyA+PSBlYXJsaWVzdEFsbG93ZWREdHMpIHtcbiAgICAgIHJldHVybiBhZHRzRnJhbWVzO1xuICAgIH1cblxuICAgIC8vIFdlIHdpbGwgbmVlZCB0byByZWNhbGN1bGF0ZSB0aGUgZWFybGllc3Qgc2VnbWVudCBEdHNcbiAgICB0cmFjay5taW5TZWdtZW50RHRzID0gSW5maW5pdHk7XG5cbiAgICByZXR1cm4gYWR0c0ZyYW1lcy5maWx0ZXIoZnVuY3Rpb24oY3VycmVudEZyYW1lKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGFuIGFsbG93ZWQgZnJhbWUsIGtlZXAgaXQgYW5kIHJlY29yZCBpdCdzIER0c1xuICAgICAgaWYgKGN1cnJlbnRGcmFtZS5kdHMgPj0gZWFybGllc3RBbGxvd2VkRHRzKSB7XG4gICAgICAgIHRyYWNrLm1pblNlZ21lbnREdHMgPSBNYXRoLm1pbih0cmFjay5taW5TZWdtZW50RHRzLCBjdXJyZW50RnJhbWUuZHRzKTtcbiAgICAgICAgdHJhY2subWluU2VnbWVudFB0cyA9IHRyYWNrLm1pblNlZ21lbnREdHM7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlLCBkaXNjYXJkIGl0XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gZ2VuZXJhdGUgdGhlIHRyYWNrJ3MgcmF3IG1kYXQgZGF0YSBmcm9tIGFuIGFycmF5IG9mIGZyYW1lc1xuICB0aGlzLmdlbmVyYXRlU2FtcGxlVGFibGVfID0gZnVuY3Rpb24oZnJhbWVzKSB7XG4gICAgdmFyXG4gICAgICBpLFxuICAgICAgY3VycmVudEZyYW1lLFxuICAgICAgc2FtcGxlcyA9IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudEZyYW1lID0gZnJhbWVzW2ldO1xuICAgICAgc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgc2l6ZTogY3VycmVudEZyYW1lLmRhdGEuYnl0ZUxlbmd0aCxcbiAgICAgICAgZHVyYXRpb246IDEwMjQgLy8gRm9yIEFBQyBhdWRpbywgYWxsIHNhbXBsZXMgY29udGFpbiAxMDI0IHNhbXBsZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2FtcGxlcztcbiAgfTtcblxuICAvLyBnZW5lcmF0ZSB0aGUgdHJhY2sncyBzYW1wbGUgdGFibGUgZnJvbSBhbiBhcnJheSBvZiBmcmFtZXNcbiAgdGhpcy5jb25jYXRlbmF0ZUZyYW1lRGF0YV8gPSBmdW5jdGlvbihmcmFtZXMpIHtcbiAgICB2YXJcbiAgICAgIGksXG4gICAgICBjdXJyZW50RnJhbWUsXG4gICAgICBkYXRhT2Zmc2V0ID0gMCxcbiAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShzdW1GcmFtZUJ5dGVMZW5ndGhzKGZyYW1lcykpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudEZyYW1lID0gZnJhbWVzW2ldO1xuXG4gICAgICBkYXRhLnNldChjdXJyZW50RnJhbWUuZGF0YSwgZGF0YU9mZnNldCk7XG4gICAgICBkYXRhT2Zmc2V0ICs9IGN1cnJlbnRGcmFtZS5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9O1xufTtcblxuQXVkaW9TZWdtZW50U3RyZWFtLnByb3RvdHlwZSA9IG5ldyBTdHJlYW0oKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgc2luZ2xlLXRyYWNrLCBJU08gQk1GRiBtZWRpYSBzZWdtZW50IGZyb20gSDI2NCBkYXRhXG4gKiBldmVudHMuIFRoZSBvdXRwdXQgb2YgdGhpcyBzdHJlYW0gY2FuIGJlIGZlZCB0byBhIFNvdXJjZUJ1ZmZlclxuICogY29uZmlndXJlZCB3aXRoIGEgc3VpdGFibGUgaW5pdGlhbGl6YXRpb24gc2VnbWVudC5cbiAqIEBwYXJhbSB0cmFjayB7b2JqZWN0fSB0cmFjayBtZXRhZGF0YSBjb25maWd1cmF0aW9uXG4gKiBAcGFyYW0gb3B0aW9ucyB7b2JqZWN0fSB0cmFuc211eGVyIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0gb3B0aW9ucy5hbGlnbkdvcHNBdEVuZCB7Ym9vbGVhbn0gSWYgdHJ1ZSwgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZVxuICogICAgICAgIGdvcHNUb0FsaWduV2l0aCBsaXN0IHdoZW4gYXR0ZW1wdGluZyB0byBhbGlnbiBnb3AgcHRzXG4gKi9cblZpZGVvU2VnbWVudFN0cmVhbSA9IGZ1bmN0aW9uKHRyYWNrLCBvcHRpb25zKSB7XG4gIHZhclxuICAgIHNlcXVlbmNlTnVtYmVyID0gMCxcbiAgICBuYWxVbml0cyA9IFtdLFxuICAgIGdvcHNUb0FsaWduV2l0aCA9IFtdLFxuICAgIGNvbmZpZyxcbiAgICBwcHM7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgVmlkZW9TZWdtZW50U3RyZWFtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG5cbiAgZGVsZXRlIHRyYWNrLm1pblBUUztcblxuICB0aGlzLmdvcENhY2hlXyA9IFtdO1xuXG4gIHRoaXMucHVzaCA9IGZ1bmN0aW9uKG5hbFVuaXQpIHtcbiAgICBjb2xsZWN0RHRzSW5mbyh0cmFjaywgbmFsVW5pdCk7XG5cbiAgICAvLyByZWNvcmQgdGhlIHRyYWNrIGNvbmZpZ1xuICAgIGlmIChuYWxVbml0Lm5hbFVuaXRUeXBlID09PSAnc2VxX3BhcmFtZXRlcl9zZXRfcmJzcCcgJiYgIWNvbmZpZykge1xuICAgICAgY29uZmlnID0gbmFsVW5pdC5jb25maWc7XG4gICAgICB0cmFjay5zcHMgPSBbbmFsVW5pdC5kYXRhXTtcblxuICAgICAgVklERU9fUFJPUEVSVElFUy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgdHJhY2tbcHJvcF0gPSBjb25maWdbcHJvcF07XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAobmFsVW5pdC5uYWxVbml0VHlwZSA9PT0gJ3BpY19wYXJhbWV0ZXJfc2V0X3Jic3AnICYmXG4gICAgICAgICFwcHMpIHtcbiAgICAgIHBwcyA9IG5hbFVuaXQuZGF0YTtcbiAgICAgIHRyYWNrLnBwcyA9IFtuYWxVbml0LmRhdGFdO1xuICAgIH1cblxuICAgIC8vIGJ1ZmZlciB2aWRlbyB1bnRpbCBmbHVzaCgpIGlzIGNhbGxlZFxuICAgIG5hbFVuaXRzLnB1c2gobmFsVW5pdCk7XG4gIH07XG5cbiAgdGhpcy5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhclxuICAgICAgZnJhbWVzLFxuICAgICAgZ29wRm9yRnVzaW9uLFxuICAgICAgZ29wcyxcbiAgICAgIG1vb2YsXG4gICAgICBtZGF0LFxuICAgICAgYm94ZXM7XG5cbiAgICAvLyBUaHJvdyBhd2F5IG5hbFVuaXRzIGF0IHRoZSBzdGFydCBvZiB0aGUgYnl0ZSBzdHJlYW0gdW50aWxcbiAgICAvLyB3ZSBmaW5kIHRoZSBmaXJzdCBBVURcbiAgICB3aGlsZSAobmFsVW5pdHMubGVuZ3RoKSB7XG4gICAgICBpZiAobmFsVW5pdHNbMF0ubmFsVW5pdFR5cGUgPT09ICdhY2Nlc3NfdW5pdF9kZWxpbWl0ZXJfcmJzcCcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBuYWxVbml0cy5zaGlmdCgpO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBlYXJseSBpZiBubyB2aWRlbyBkYXRhIGhhcyBiZWVuIG9ic2VydmVkXG4gICAgaWYgKG5hbFVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5yZXNldFN0cmVhbV8oKTtcbiAgICAgIHRoaXMudHJpZ2dlcignZG9uZScsICdWaWRlb1NlZ21lbnRTdHJlYW0nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPcmdhbml6ZSB0aGUgcmF3IG5hbC11bml0cyBpbnRvIGFycmF5cyB0aGF0IHJlcHJlc2VudFxuICAgIC8vIGhpZ2hlci1sZXZlbCBjb25zdHJ1Y3RzIHN1Y2ggYXMgZnJhbWVzIGFuZCBnb3BzXG4gICAgLy8gKGdyb3VwLW9mLXBpY3R1cmVzKVxuICAgIGZyYW1lcyA9IHRoaXMuZ3JvdXBOYWxzSW50b0ZyYW1lc18obmFsVW5pdHMpO1xuICAgIGdvcHMgPSB0aGlzLmdyb3VwRnJhbWVzSW50b0dvcHNfKGZyYW1lcyk7XG5cbiAgICAvLyBJZiB0aGUgZmlyc3QgZnJhbWUgb2YgdGhpcyBmcmFnbWVudCBpcyBub3QgYSBrZXlmcmFtZSB3ZSBoYXZlXG4gICAgLy8gYSBwcm9ibGVtIHNpbmNlIE1TRSAob24gQ2hyb21lKSByZXF1aXJlcyBhIGxlYWRpbmcga2V5ZnJhbWUuXG4gICAgLy9cbiAgICAvLyBXZSBoYXZlIHR3byBhcHByb2FjaGVzIHRvIHJlcGFpcmluZyB0aGlzIHNpdHVhdGlvbjpcbiAgICAvLyAxKSBHT1AtRlVTSU9OOlxuICAgIC8vICAgIFRoaXMgaXMgd2hlcmUgd2Uga2VlcCB0cmFjayBvZiB0aGUgR09QUyAoZ3JvdXAtb2YtcGljdHVyZXMpXG4gICAgLy8gICAgZnJvbSBwcmV2aW91cyBmcmFnbWVudHMgYW5kIGF0dGVtcHQgdG8gZmluZCBvbmUgdGhhdCB3ZSBjYW5cbiAgICAvLyAgICBwcmVwZW5kIHRvIHRoZSBjdXJyZW50IGZyYWdtZW50IGluIG9yZGVyIHRvIGNyZWF0ZSBhIHZhbGlkXG4gICAgLy8gICAgZnJhZ21lbnQuXG4gICAgLy8gMikgS0VZRlJBTUUtUFVMTElORzpcbiAgICAvLyAgICBIZXJlIHdlIHNlYXJjaCBmb3IgdGhlIGZpcnN0IGtleWZyYW1lIGluIHRoZSBmcmFnbWVudCBhbmRcbiAgICAvLyAgICB0aHJvdyBhd2F5IGFsbCB0aGUgZnJhbWVzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudFxuICAgIC8vICAgIGFuZCB0aGF0IGtleWZyYW1lLiBXZSB0aGVuIGV4dGVuZCB0aGUgZHVyYXRpb24gYW5kIHB1bGwgdGhlXG4gICAgLy8gICAgUFRTIG9mIHRoZSBrZXlmcmFtZSBmb3J3YXJkIHNvIHRoYXQgaXQgY292ZXJzIHRoZSB0aW1lIHJhbmdlXG4gICAgLy8gICAgb2YgdGhlIGZyYW1lcyB0aGF0IHdlcmUgZGlzcG9zZWQgb2YuXG4gICAgLy9cbiAgICAvLyAjMSBpcyBmYXIgcHJlZmVyZWFibGUgb3ZlciAjMiB3aGljaCBjYW4gY2F1c2UgXCJzdHV0dGVyaW5nXCIgYnV0XG4gICAgLy8gcmVxdWlyZXMgbW9yZSB0aGluZ3MgdG8gYmUganVzdCByaWdodC5cbiAgICBpZiAoIWdvcHNbMF1bMF0ua2V5RnJhbWUpIHtcbiAgICAgIC8vIFNlYXJjaCBmb3IgYSBnb3AgZm9yIGZ1c2lvbiBmcm9tIG91ciBnb3BDYWNoZVxuICAgICAgZ29wRm9yRnVzaW9uID0gdGhpcy5nZXRHb3BGb3JGdXNpb25fKG5hbFVuaXRzWzBdLCB0cmFjayk7XG5cbiAgICAgIGlmIChnb3BGb3JGdXNpb24pIHtcbiAgICAgICAgZ29wcy51bnNoaWZ0KGdvcEZvckZ1c2lvbik7XG4gICAgICAgIC8vIEFkanVzdCBHb3BzJyBtZXRhZGF0YSB0byBhY2NvdW50IGZvciB0aGUgaW5jbHVzaW9uIG9mIHRoZVxuICAgICAgICAvLyBuZXcgZ29wIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgZ29wcy5ieXRlTGVuZ3RoICs9IGdvcEZvckZ1c2lvbi5ieXRlTGVuZ3RoO1xuICAgICAgICBnb3BzLm5hbENvdW50ICs9IGdvcEZvckZ1c2lvbi5uYWxDb3VudDtcbiAgICAgICAgZ29wcy5wdHMgPSBnb3BGb3JGdXNpb24ucHRzO1xuICAgICAgICBnb3BzLmR0cyA9IGdvcEZvckZ1c2lvbi5kdHM7XG4gICAgICAgIGdvcHMuZHVyYXRpb24gKz0gZ29wRm9yRnVzaW9uLmR1cmF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYSBjYW5kaWRhdGUgZ29wIGZhbGwgYmFjayB0byBrZXlyYW1lLXB1bGxpbmdcbiAgICAgICAgZ29wcyA9IHRoaXMuZXh0ZW5kRmlyc3RLZXlGcmFtZV8oZ29wcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJpbSBnb3BzIHRvIGFsaWduIHdpdGggZ29wc1RvQWxpZ25XaXRoXG4gICAgaWYgKGdvcHNUb0FsaWduV2l0aC5sZW5ndGgpIHtcbiAgICAgIHZhciBhbGlnbmVkR29wcztcblxuICAgICAgaWYgKG9wdGlvbnMuYWxpZ25Hb3BzQXRFbmQpIHtcbiAgICAgICAgYWxpZ25lZEdvcHMgPSB0aGlzLmFsaWduR29wc0F0RW5kXyhnb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsaWduZWRHb3BzID0gdGhpcy5hbGlnbkdvcHNBdFN0YXJ0Xyhnb3BzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhbGlnbmVkR29wcykge1xuICAgICAgICAvLyBzYXZlIGFsbCB0aGUgbmFscyBpbiB0aGUgbGFzdCBHT1AgaW50byB0aGUgZ29wIGNhY2hlXG4gICAgICAgIHRoaXMuZ29wQ2FjaGVfLnVuc2hpZnQoe1xuICAgICAgICAgIGdvcDogZ29wcy5wb3AoKSxcbiAgICAgICAgICBwcHM6IHRyYWNrLnBwcyxcbiAgICAgICAgICBzcHM6IHRyYWNrLnNwc1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBLZWVwIGEgbWF4aW11bSBvZiA2IEdPUHMgaW4gdGhlIGNhY2hlXG4gICAgICAgIHRoaXMuZ29wQ2FjaGVfLmxlbmd0aCA9IE1hdGgubWluKDYsIHRoaXMuZ29wQ2FjaGVfLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gQ2xlYXIgbmFsVW5pdHNcbiAgICAgICAgbmFsVW5pdHMgPSBbXTtcblxuICAgICAgICAvLyByZXR1cm4gZWFybHkgbm8gZ29wcyBjYW4gYmUgYWxpZ25lZCB3aXRoIGRlc2lyZWQgZ29wc1RvQWxpZ25XaXRoXG4gICAgICAgIHRoaXMucmVzZXRTdHJlYW1fKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignZG9uZScsICdWaWRlb1NlZ21lbnRTdHJlYW0nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTb21lIGdvcHMgd2VyZSB0cmltbWVkLiBjbGVhciBkdHMgaW5mbyBzbyBtaW5TZWdtZW50RHRzIGFuZCBwdHMgYXJlIGNvcnJlY3RcbiAgICAgIC8vIHdoZW4gcmVjYWxjdWxhdGVkIGJlZm9yZSBzZW5kaW5nIG9mZiB0byBDb2FsZXNjZVN0cmVhbVxuICAgICAgY2xlYXJEdHNJbmZvKHRyYWNrKTtcblxuICAgICAgZ29wcyA9IGFsaWduZWRHb3BzO1xuICAgIH1cblxuICAgIGNvbGxlY3REdHNJbmZvKHRyYWNrLCBnb3BzKTtcblxuICAgIC8vIEZpcnN0LCB3ZSBoYXZlIHRvIGJ1aWxkIHRoZSBpbmRleCBmcm9tIGJ5dGUgbG9jYXRpb25zIHRvXG4gICAgLy8gc2FtcGxlcyAodGhhdCBpcywgZnJhbWVzKSBpbiB0aGUgdmlkZW8gZGF0YVxuICAgIHRyYWNrLnNhbXBsZXMgPSB0aGlzLmdlbmVyYXRlU2FtcGxlVGFibGVfKGdvcHMpO1xuXG4gICAgLy8gQ29uY2F0ZW5hdGUgdGhlIHZpZGVvIGRhdGEgYW5kIGNvbnN0cnVjdCB0aGUgbWRhdFxuICAgIG1kYXQgPSBtcDQubWRhdCh0aGlzLmNvbmNhdGVuYXRlTmFsRGF0YV8oZ29wcykpO1xuXG4gICAgdHJhY2suYmFzZU1lZGlhRGVjb2RlVGltZSA9IGNhbGN1bGF0ZVRyYWNrQmFzZU1lZGlhRGVjb2RlVGltZSh0cmFjayk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3Byb2Nlc3NlZEdvcHNJbmZvJywgZ29wcy5tYXAoZnVuY3Rpb24oZ29wKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwdHM6IGdvcC5wdHMsXG4gICAgICAgIGR0czogZ29wLmR0cyxcbiAgICAgICAgYnl0ZUxlbmd0aDogZ29wLmJ5dGVMZW5ndGhcbiAgICAgIH07XG4gICAgfSkpO1xuXG4gICAgLy8gc2F2ZSBhbGwgdGhlIG5hbHMgaW4gdGhlIGxhc3QgR09QIGludG8gdGhlIGdvcCBjYWNoZVxuICAgIHRoaXMuZ29wQ2FjaGVfLnVuc2hpZnQoe1xuICAgICAgZ29wOiBnb3BzLnBvcCgpLFxuICAgICAgcHBzOiB0cmFjay5wcHMsXG4gICAgICBzcHM6IHRyYWNrLnNwc1xuICAgIH0pO1xuXG4gICAgLy8gS2VlcCBhIG1heGltdW0gb2YgNiBHT1BzIGluIHRoZSBjYWNoZVxuICAgIHRoaXMuZ29wQ2FjaGVfLmxlbmd0aCA9IE1hdGgubWluKDYsIHRoaXMuZ29wQ2FjaGVfLmxlbmd0aCk7XG5cbiAgICAvLyBDbGVhciBuYWxVbml0c1xuICAgIG5hbFVuaXRzID0gW107XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2Jhc2VNZWRpYURlY29kZVRpbWUnLCB0cmFjay5iYXNlTWVkaWFEZWNvZGVUaW1lKTtcbiAgICB0aGlzLnRyaWdnZXIoJ3RpbWVsaW5lU3RhcnRJbmZvJywgdHJhY2sudGltZWxpbmVTdGFydEluZm8pO1xuXG4gICAgbW9vZiA9IG1wNC5tb29mKHNlcXVlbmNlTnVtYmVyLCBbdHJhY2tdKTtcblxuICAgIC8vIGl0IHdvdWxkIGJlIGdyZWF0IHRvIGFsbG9jYXRlIHRoaXMgYXJyYXkgdXAgZnJvbnQgaW5zdGVhZCBvZlxuICAgIC8vIHRocm93aW5nIGF3YXkgaHVuZHJlZHMgb2YgbWVkaWEgc2VnbWVudCBmcmFnbWVudHNcbiAgICBib3hlcyA9IG5ldyBVaW50OEFycmF5KG1vb2YuYnl0ZUxlbmd0aCArIG1kYXQuYnl0ZUxlbmd0aCk7XG5cbiAgICAvLyBCdW1wIHRoZSBzZXF1ZW5jZSBudW1iZXIgZm9yIG5leHQgdGltZVxuICAgIHNlcXVlbmNlTnVtYmVyKys7XG5cbiAgICBib3hlcy5zZXQobW9vZik7XG4gICAgYm94ZXMuc2V0KG1kYXQsIG1vb2YuYnl0ZUxlbmd0aCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2RhdGEnLCB7dHJhY2s6IHRyYWNrLCBib3hlczogYm94ZXN9KTtcblxuICAgIHRoaXMucmVzZXRTdHJlYW1fKCk7XG5cbiAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBmbHVzaCBwcm9jZXNzIG5vd1xuICAgIHRoaXMudHJpZ2dlcignZG9uZScsICdWaWRlb1NlZ21lbnRTdHJlYW0nKTtcbiAgfTtcblxuICB0aGlzLnJlc2V0U3RyZWFtXyA9IGZ1bmN0aW9uKCkge1xuICAgIGNsZWFyRHRzSW5mbyh0cmFjayk7XG5cbiAgICAvLyByZXNldCBjb25maWcgYW5kIHBwcyBiZWNhdXNlIHRoZXkgbWF5IGRpZmZlciBhY3Jvc3Mgc2VnbWVudHNcbiAgICAvLyBmb3IgaW5zdGFuY2UsIHdoZW4gd2UgYXJlIHJlbmRpdGlvbiBzd2l0Y2hpbmdcbiAgICBjb25maWcgPSB1bmRlZmluZWQ7XG4gICAgcHBzID0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8vIFNlYXJjaCBmb3IgYSBjYW5kaWRhdGUgR29wIGZvciBnb3AtZnVzaW9uIGZyb20gdGhlIGdvcCBjYWNoZSBhbmRcbiAgLy8gcmV0dXJuIGl0IG9yIHJldHVybiBudWxsIGlmIG5vIGdvb2QgY2FuZGlkYXRlIHdhcyBmb3VuZFxuICB0aGlzLmdldEdvcEZvckZ1c2lvbl8gPSBmdW5jdGlvbihuYWxVbml0KSB7XG4gICAgdmFyXG4gICAgICBoYWxmU2Vjb25kID0gNDUwMDAsIC8vIEhhbGYtYS1zZWNvbmQgaW4gYSA5MGtoeiBjbG9ja1xuICAgICAgYWxsb3dhYmxlT3ZlcmxhcCA9IDEwMDAwLCAvLyBBYm91dCAzIGZyYW1lcyBAIDMwZnBzXG4gICAgICBuZWFyZXN0RGlzdGFuY2UgPSBJbmZpbml0eSxcbiAgICAgIGR0c0Rpc3RhbmNlLFxuICAgICAgbmVhcmVzdEdvcE9iaixcbiAgICAgIGN1cnJlbnRHb3AsXG4gICAgICBjdXJyZW50R29wT2JqLFxuICAgICAgaTtcblxuICAgIC8vIFNlYXJjaCBmb3IgdGhlIEdPUCBuZWFyZXN0IHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBuYWwgdW5pdFxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmdvcENhY2hlXy5sZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudEdvcE9iaiA9IHRoaXMuZ29wQ2FjaGVfW2ldO1xuICAgICAgY3VycmVudEdvcCA9IGN1cnJlbnRHb3BPYmouZ29wO1xuXG4gICAgICAvLyBSZWplY3QgR29wcyB3aXRoIGRpZmZlcmVudCBTUFMgb3IgUFBTXG4gICAgICBpZiAoISh0cmFjay5wcHMgJiYgYXJyYXlFcXVhbHModHJhY2sucHBzWzBdLCBjdXJyZW50R29wT2JqLnBwc1swXSkpIHx8XG4gICAgICAgICAgISh0cmFjay5zcHMgJiYgYXJyYXlFcXVhbHModHJhY2suc3BzWzBdLCBjdXJyZW50R29wT2JqLnNwc1swXSkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBSZWplY3QgR29wcyB0aGF0IHdvdWxkIHJlcXVpcmUgYSBuZWdhdGl2ZSBiYXNlTWVkaWFEZWNvZGVUaW1lXG4gICAgICBpZiAoY3VycmVudEdvcC5kdHMgPCB0cmFjay50aW1lbGluZVN0YXJ0SW5mby5kdHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBlbmQgb2YgdGhlIGdvcCBhbmQgdGhlIHN0YXJ0IG9mIHRoZSBuYWxVbml0XG4gICAgICBkdHNEaXN0YW5jZSA9IChuYWxVbml0LmR0cyAtIGN1cnJlbnRHb3AuZHRzKSAtIGN1cnJlbnRHb3AuZHVyYXRpb247XG5cbiAgICAgIC8vIE9ubHkgY29uc2lkZXIgR09QUyB0aGF0IHN0YXJ0IGJlZm9yZSB0aGUgbmFsIHVuaXQgYW5kIGVuZCB3aXRoaW5cbiAgICAgIC8vIGEgaGFsZi1zZWNvbmQgb2YgdGhlIG5hbCB1bml0XG4gICAgICBpZiAoZHRzRGlzdGFuY2UgPj0gLWFsbG93YWJsZU92ZXJsYXAgJiZcbiAgICAgICAgICBkdHNEaXN0YW5jZSA8PSBoYWxmU2Vjb25kKSB7XG5cbiAgICAgICAgLy8gQWx3YXlzIHVzZSB0aGUgY2xvc2VzdCBHT1Agd2UgZm91bmQgaWYgdGhlcmUgaXMgbW9yZSB0aGFuXG4gICAgICAgIC8vIG9uZSBjYW5kaWRhdGVcbiAgICAgICAgaWYgKCFuZWFyZXN0R29wT2JqIHx8XG4gICAgICAgICAgICBuZWFyZXN0RGlzdGFuY2UgPiBkdHNEaXN0YW5jZSkge1xuICAgICAgICAgIG5lYXJlc3RHb3BPYmogPSBjdXJyZW50R29wT2JqO1xuICAgICAgICAgIG5lYXJlc3REaXN0YW5jZSA9IGR0c0Rpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lYXJlc3RHb3BPYmopIHtcbiAgICAgIHJldHVybiBuZWFyZXN0R29wT2JqLmdvcDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdGhpcy5leHRlbmRGaXJzdEtleUZyYW1lXyA9IGZ1bmN0aW9uKGdvcHMpIHtcbiAgICB2YXIgY3VycmVudEdvcDtcblxuICAgIGlmICghZ29wc1swXVswXS5rZXlGcmFtZSAmJiBnb3BzLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgZmlyc3QgR09QXG4gICAgICBjdXJyZW50R29wID0gZ29wcy5zaGlmdCgpO1xuXG4gICAgICBnb3BzLmJ5dGVMZW5ndGggLT0gIGN1cnJlbnRHb3AuYnl0ZUxlbmd0aDtcbiAgICAgIGdvcHMubmFsQ291bnQgLT0gY3VycmVudEdvcC5uYWxDb3VudDtcblxuICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCBmcmFtZSBvZiB3aGF0IGlzIG5vdyB0aGVcbiAgICAgIC8vIGZpcnN0IGdvcCB0byBjb3ZlciB0aGUgdGltZSBwZXJpb2Qgb2YgdGhlXG4gICAgICAvLyBmcmFtZXMgd2UganVzdCByZW1vdmVkXG4gICAgICBnb3BzWzBdWzBdLmR0cyA9IGN1cnJlbnRHb3AuZHRzO1xuICAgICAgZ29wc1swXVswXS5wdHMgPSBjdXJyZW50R29wLnB0cztcbiAgICAgIGdvcHNbMF1bMF0uZHVyYXRpb24gKz0gY3VycmVudEdvcC5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZ29wcztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIGFycmF5IG9mIG5hbCB1bml0cyBpbnRvIGFuIGFycmF5IG9mIGZyYW1lcyB3aXRoIGVhY2ggZnJhbWUgYmVpbmdcbiAgLy8gY29tcG9zZWQgb2YgdGhlIG5hbCB1bml0cyB0aGF0IG1ha2UgdXAgdGhhdCBmcmFtZVxuICAvLyBBbHNvIGtlZXAgdHJhY2sgb2YgY3VtbXVsYXRpdmUgZGF0YSBhYm91dCB0aGUgZnJhbWUgZnJvbSB0aGUgbmFsIHVuaXRzIHN1Y2hcbiAgLy8gYXMgdGhlIGZyYW1lIGR1cmF0aW9uLCBzdGFydGluZyBwdHMsIGV0Yy5cbiAgdGhpcy5ncm91cE5hbHNJbnRvRnJhbWVzXyA9IGZ1bmN0aW9uKG5hbFVuaXRzKSB7XG4gICAgdmFyXG4gICAgICBpLFxuICAgICAgY3VycmVudE5hbCxcbiAgICAgIGN1cnJlbnRGcmFtZSA9IFtdLFxuICAgICAgZnJhbWVzID0gW107XG5cbiAgICBjdXJyZW50RnJhbWUuYnl0ZUxlbmd0aCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbmFsVW5pdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1cnJlbnROYWwgPSBuYWxVbml0c1tpXTtcblxuICAgICAgLy8gU3BsaXQgb24gJ2F1ZCctdHlwZSBuYWwgdW5pdHNcbiAgICAgIGlmIChjdXJyZW50TmFsLm5hbFVuaXRUeXBlID09PSAnYWNjZXNzX3VuaXRfZGVsaW1pdGVyX3Jic3AnKSB7XG4gICAgICAgIC8vIFNpbmNlIHRoZSB2ZXJ5IGZpcnN0IG5hbCB1bml0IGlzIGV4cGVjdGVkIHRvIGJlIGFuIEFVRFxuICAgICAgICAvLyBvbmx5IHB1c2ggdG8gdGhlIGZyYW1lcyBhcnJheSB3aGVuIGN1cnJlbnRGcmFtZSBpcyBub3QgZW1wdHlcbiAgICAgICAgaWYgKGN1cnJlbnRGcmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICBjdXJyZW50RnJhbWUuZHVyYXRpb24gPSBjdXJyZW50TmFsLmR0cyAtIGN1cnJlbnRGcmFtZS5kdHM7XG4gICAgICAgICAgZnJhbWVzLnB1c2goY3VycmVudEZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50RnJhbWUgPSBbY3VycmVudE5hbF07XG4gICAgICAgIGN1cnJlbnRGcmFtZS5ieXRlTGVuZ3RoID0gY3VycmVudE5hbC5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIGN1cnJlbnRGcmFtZS5wdHMgPSBjdXJyZW50TmFsLnB0cztcbiAgICAgICAgY3VycmVudEZyYW1lLmR0cyA9IGN1cnJlbnROYWwuZHRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3BlY2lmaWNhbGx5IGZsYWcga2V5IGZyYW1lcyBmb3IgZWFzZSBvZiB1c2UgbGF0ZXJcbiAgICAgICAgaWYgKGN1cnJlbnROYWwubmFsVW5pdFR5cGUgPT09ICdzbGljZV9sYXllcl93aXRob3V0X3BhcnRpdGlvbmluZ19yYnNwX2lkcicpIHtcbiAgICAgICAgICBjdXJyZW50RnJhbWUua2V5RnJhbWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRGcmFtZS5kdXJhdGlvbiA9IGN1cnJlbnROYWwuZHRzIC0gY3VycmVudEZyYW1lLmR0cztcbiAgICAgICAgY3VycmVudEZyYW1lLmJ5dGVMZW5ndGggKz0gY3VycmVudE5hbC5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIGN1cnJlbnRGcmFtZS5wdXNoKGN1cnJlbnROYWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciB0aGUgbGFzdCBmcmFtZSwgdXNlIHRoZSBkdXJhdGlvbiBvZiB0aGUgcHJldmlvdXMgZnJhbWUgaWYgd2VcbiAgICAvLyBoYXZlIG5vdGhpbmcgYmV0dGVyIHRvIGdvIG9uXG4gICAgaWYgKGZyYW1lcy5sZW5ndGggJiZcbiAgICAgICAgKCFjdXJyZW50RnJhbWUuZHVyYXRpb24gfHxcbiAgICAgICAgIGN1cnJlbnRGcmFtZS5kdXJhdGlvbiA8PSAwKSkge1xuICAgICAgY3VycmVudEZyYW1lLmR1cmF0aW9uID0gZnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAxXS5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICAvLyBQdXNoIHRoZSBmaW5hbCBmcmFtZVxuICAgIGZyYW1lcy5wdXNoKGN1cnJlbnRGcmFtZSk7XG4gICAgcmV0dXJuIGZyYW1lcztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIGFycmF5IG9mIGZyYW1lcyBpbnRvIGFuIGFycmF5IG9mIEdvcCB3aXRoIGVhY2ggR29wIGJlaW5nIGNvbXBvc2VkXG4gIC8vIG9mIHRoZSBmcmFtZXMgdGhhdCBtYWtlIHVwIHRoYXQgR29wXG4gIC8vIEFsc28ga2VlcCB0cmFjayBvZiBjdW1tdWxhdGl2ZSBkYXRhIGFib3V0IHRoZSBHb3AgZnJvbSB0aGUgZnJhbWVzIHN1Y2ggYXMgdGhlXG4gIC8vIEdvcCBkdXJhdGlvbiwgc3RhcnRpbmcgcHRzLCBldGMuXG4gIHRoaXMuZ3JvdXBGcmFtZXNJbnRvR29wc18gPSBmdW5jdGlvbihmcmFtZXMpIHtcbiAgICB2YXJcbiAgICAgIGksXG4gICAgICBjdXJyZW50RnJhbWUsXG4gICAgICBjdXJyZW50R29wID0gW10sXG4gICAgICBnb3BzID0gW107XG5cbiAgICAvLyBXZSBtdXN0IHByZS1zZXQgc29tZSBvZiB0aGUgdmFsdWVzIG9uIHRoZSBHb3Agc2luY2Ugd2VcbiAgICAvLyBrZWVwIHJ1bm5pbmcgdG90YWxzIG9mIHRoZXNlIHZhbHVlc1xuICAgIGN1cnJlbnRHb3AuYnl0ZUxlbmd0aCA9IDA7XG4gICAgY3VycmVudEdvcC5uYWxDb3VudCA9IDA7XG4gICAgY3VycmVudEdvcC5kdXJhdGlvbiA9IDA7XG4gICAgY3VycmVudEdvcC5wdHMgPSBmcmFtZXNbMF0ucHRzO1xuICAgIGN1cnJlbnRHb3AuZHRzID0gZnJhbWVzWzBdLmR0cztcblxuICAgIC8vIHN0b3JlIHNvbWUgbWV0YWRhdGEgYWJvdXQgYWxsIHRoZSBHb3BzXG4gICAgZ29wcy5ieXRlTGVuZ3RoID0gMDtcbiAgICBnb3BzLm5hbENvdW50ID0gMDtcbiAgICBnb3BzLmR1cmF0aW9uID0gMDtcbiAgICBnb3BzLnB0cyA9IGZyYW1lc1swXS5wdHM7XG4gICAgZ29wcy5kdHMgPSBmcmFtZXNbMF0uZHRzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudEZyYW1lID0gZnJhbWVzW2ldO1xuXG4gICAgICBpZiAoY3VycmVudEZyYW1lLmtleUZyYW1lKSB7XG4gICAgICAgIC8vIFNpbmNlIHRoZSB2ZXJ5IGZpcnN0IGZyYW1lIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGtleWZyYW1lXG4gICAgICAgIC8vIG9ubHkgcHVzaCB0byB0aGUgZ29wcyBhcnJheSB3aGVuIGN1cnJlbnRHb3AgaXMgbm90IGVtcHR5XG4gICAgICAgIGlmIChjdXJyZW50R29wLmxlbmd0aCkge1xuICAgICAgICAgIGdvcHMucHVzaChjdXJyZW50R29wKTtcbiAgICAgICAgICBnb3BzLmJ5dGVMZW5ndGggKz0gY3VycmVudEdvcC5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGdvcHMubmFsQ291bnQgKz0gY3VycmVudEdvcC5uYWxDb3VudDtcbiAgICAgICAgICBnb3BzLmR1cmF0aW9uICs9IGN1cnJlbnRHb3AuZHVyYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50R29wID0gW2N1cnJlbnRGcmFtZV07XG4gICAgICAgIGN1cnJlbnRHb3AubmFsQ291bnQgPSBjdXJyZW50RnJhbWUubGVuZ3RoO1xuICAgICAgICBjdXJyZW50R29wLmJ5dGVMZW5ndGggPSBjdXJyZW50RnJhbWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgY3VycmVudEdvcC5wdHMgPSBjdXJyZW50RnJhbWUucHRzO1xuICAgICAgICBjdXJyZW50R29wLmR0cyA9IGN1cnJlbnRGcmFtZS5kdHM7XG4gICAgICAgIGN1cnJlbnRHb3AuZHVyYXRpb24gPSBjdXJyZW50RnJhbWUuZHVyYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50R29wLmR1cmF0aW9uICs9IGN1cnJlbnRGcmFtZS5kdXJhdGlvbjtcbiAgICAgICAgY3VycmVudEdvcC5uYWxDb3VudCArPSBjdXJyZW50RnJhbWUubGVuZ3RoO1xuICAgICAgICBjdXJyZW50R29wLmJ5dGVMZW5ndGggKz0gY3VycmVudEZyYW1lLmJ5dGVMZW5ndGg7XG4gICAgICAgIGN1cnJlbnRHb3AucHVzaChjdXJyZW50RnJhbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChnb3BzLmxlbmd0aCAmJiBjdXJyZW50R29wLmR1cmF0aW9uIDw9IDApIHtcbiAgICAgIGN1cnJlbnRHb3AuZHVyYXRpb24gPSBnb3BzW2dvcHMubGVuZ3RoIC0gMV0uZHVyYXRpb247XG4gICAgfVxuICAgIGdvcHMuYnl0ZUxlbmd0aCArPSBjdXJyZW50R29wLmJ5dGVMZW5ndGg7XG4gICAgZ29wcy5uYWxDb3VudCArPSBjdXJyZW50R29wLm5hbENvdW50O1xuICAgIGdvcHMuZHVyYXRpb24gKz0gY3VycmVudEdvcC5kdXJhdGlvbjtcblxuICAgIC8vIHB1c2ggdGhlIGZpbmFsIEdvcFxuICAgIGdvcHMucHVzaChjdXJyZW50R29wKTtcbiAgICByZXR1cm4gZ29wcztcbiAgfTtcblxuICAvLyBnZW5lcmF0ZSB0aGUgdHJhY2sncyBzYW1wbGUgdGFibGUgZnJvbSBhbiBhcnJheSBvZiBnb3BzXG4gIHRoaXMuZ2VuZXJhdGVTYW1wbGVUYWJsZV8gPSBmdW5jdGlvbihnb3BzLCBiYXNlRGF0YU9mZnNldCkge1xuICAgIHZhclxuICAgICAgaCwgaSxcbiAgICAgIHNhbXBsZSxcbiAgICAgIGN1cnJlbnRHb3AsXG4gICAgICBjdXJyZW50RnJhbWUsXG4gICAgICBkYXRhT2Zmc2V0ID0gYmFzZURhdGFPZmZzZXQgfHwgMCxcbiAgICAgIHNhbXBsZXMgPSBbXTtcblxuICAgIGZvciAoaCA9IDA7IGggPCBnb3BzLmxlbmd0aDsgaCsrKSB7XG4gICAgICBjdXJyZW50R29wID0gZ29wc1toXTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGN1cnJlbnRHb3AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudEZyYW1lID0gY3VycmVudEdvcFtpXTtcblxuICAgICAgICBzYW1wbGUgPSBjcmVhdGVEZWZhdWx0U2FtcGxlKCk7XG5cbiAgICAgICAgc2FtcGxlLmRhdGFPZmZzZXQgPSBkYXRhT2Zmc2V0O1xuICAgICAgICBzYW1wbGUuY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gY3VycmVudEZyYW1lLnB0cyAtIGN1cnJlbnRGcmFtZS5kdHM7XG4gICAgICAgIHNhbXBsZS5kdXJhdGlvbiA9IGN1cnJlbnRGcmFtZS5kdXJhdGlvbjtcbiAgICAgICAgc2FtcGxlLnNpemUgPSA0ICogY3VycmVudEZyYW1lLmxlbmd0aDsgLy8gU3BhY2UgZm9yIG5hbCB1bml0IHNpemVcbiAgICAgICAgc2FtcGxlLnNpemUgKz0gY3VycmVudEZyYW1lLmJ5dGVMZW5ndGg7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRGcmFtZS5rZXlGcmFtZSkge1xuICAgICAgICAgIHNhbXBsZS5mbGFncy5kZXBlbmRzT24gPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YU9mZnNldCArPSBzYW1wbGUuc2l6ZTtcblxuICAgICAgICBzYW1wbGVzLnB1c2goc2FtcGxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNhbXBsZXM7XG4gIH07XG5cbiAgLy8gZ2VuZXJhdGUgdGhlIHRyYWNrJ3MgcmF3IG1kYXQgZGF0YSBmcm9tIGFuIGFycmF5IG9mIGdvcHNcbiAgdGhpcy5jb25jYXRlbmF0ZU5hbERhdGFfID0gZnVuY3Rpb24oZ29wcykge1xuICAgIHZhclxuICAgICAgaCwgaSwgaixcbiAgICAgIGN1cnJlbnRHb3AsXG4gICAgICBjdXJyZW50RnJhbWUsXG4gICAgICBjdXJyZW50TmFsLFxuICAgICAgZGF0YU9mZnNldCA9IDAsXG4gICAgICBuYWxzQnl0ZUxlbmd0aCA9IGdvcHMuYnl0ZUxlbmd0aCxcbiAgICAgIG51bWJlck9mTmFscyA9IGdvcHMubmFsQ291bnQsXG4gICAgICB0b3RhbEJ5dGVMZW5ndGggPSBuYWxzQnl0ZUxlbmd0aCArIDQgKiBudW1iZXJPZk5hbHMsXG4gICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodG90YWxCeXRlTGVuZ3RoKSxcbiAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoZGF0YS5idWZmZXIpO1xuXG4gICAgLy8gRm9yIGVhY2ggR29wLi5cbiAgICBmb3IgKGggPSAwOyBoIDwgZ29wcy5sZW5ndGg7IGgrKykge1xuICAgICAgY3VycmVudEdvcCA9IGdvcHNbaF07XG5cbiAgICAgIC8vIEZvciBlYWNoIEZyYW1lLi5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjdXJyZW50R29wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnRGcmFtZSA9IGN1cnJlbnRHb3BbaV07XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggTkFMLi5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1cnJlbnRGcmFtZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGN1cnJlbnROYWwgPSBjdXJyZW50RnJhbWVbal07XG5cbiAgICAgICAgICB2aWV3LnNldFVpbnQzMihkYXRhT2Zmc2V0LCBjdXJyZW50TmFsLmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgZGF0YU9mZnNldCArPSA0O1xuICAgICAgICAgIGRhdGEuc2V0KGN1cnJlbnROYWwuZGF0YSwgZGF0YU9mZnNldCk7XG4gICAgICAgICAgZGF0YU9mZnNldCArPSBjdXJyZW50TmFsLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICAvLyB0cmltIGdvcCBsaXN0IHRvIHRoZSBmaXJzdCBnb3AgZm91bmQgdGhhdCBoYXMgYSBtYXRjaGluZyBwdHMgd2l0aCBhIGdvcCBpbiB0aGUgbGlzdFxuICAvLyBvZiBnb3BzVG9BbGlnbldpdGggc3RhcnRpbmcgZnJvbSB0aGUgU1RBUlQgb2YgdGhlIGxpc3RcbiAgdGhpcy5hbGlnbkdvcHNBdFN0YXJ0XyA9IGZ1bmN0aW9uKGdvcHMpIHtcbiAgICB2YXIgYWxpZ25JbmRleCwgZ29wSW5kZXgsIGFsaWduLCBnb3AsIGJ5dGVMZW5ndGgsIG5hbENvdW50LCBkdXJhdGlvbiwgYWxpZ25lZEdvcHM7XG5cbiAgICBieXRlTGVuZ3RoID0gZ29wcy5ieXRlTGVuZ3RoO1xuICAgIG5hbENvdW50ID0gZ29wcy5uYWxDb3VudDtcbiAgICBkdXJhdGlvbiA9IGdvcHMuZHVyYXRpb247XG4gICAgYWxpZ25JbmRleCA9IGdvcEluZGV4ID0gMDtcblxuICAgIHdoaWxlIChhbGlnbkluZGV4IDwgZ29wc1RvQWxpZ25XaXRoLmxlbmd0aCAmJiBnb3BJbmRleCA8IGdvcHMubGVuZ3RoKSB7XG4gICAgICBhbGlnbiA9IGdvcHNUb0FsaWduV2l0aFthbGlnbkluZGV4XTtcbiAgICAgIGdvcCA9IGdvcHNbZ29wSW5kZXhdO1xuXG4gICAgICBpZiAoYWxpZ24ucHRzID09PSBnb3AucHRzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ29wLnB0cyA+IGFsaWduLnB0cykge1xuICAgICAgICAvLyB0aGlzIGN1cnJlbnQgZ29wIHN0YXJ0cyBhZnRlciB0aGUgY3VycmVudCBnb3Agd2Ugd2FudCB0byBhbGlnbiBvbiwgc28gaW5jcmVtZW50XG4gICAgICAgIC8vIGFsaWduIGluZGV4XG4gICAgICAgIGFsaWduSW5kZXgrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGN1cnJlbnQgZ29wIHN0YXJ0cyBiZWZvcmUgdGhlIGN1cnJlbnQgZ29wIHdlIHdhbnQgdG8gYWxpZ24gb24uIHNvIGluY3JlbWVudCBnb3BcbiAgICAgIC8vIGluZGV4XG4gICAgICBnb3BJbmRleCsrO1xuICAgICAgYnl0ZUxlbmd0aCAtPSBnb3AuYnl0ZUxlbmd0aDtcbiAgICAgIG5hbENvdW50IC09IGdvcC5uYWxDb3VudDtcbiAgICAgIGR1cmF0aW9uIC09IGdvcC5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoZ29wSW5kZXggPT09IDApIHtcbiAgICAgIC8vIG5vIGdvcHMgdG8gdHJpbVxuICAgICAgcmV0dXJuIGdvcHM7XG4gICAgfVxuXG4gICAgaWYgKGdvcEluZGV4ID09PSBnb3BzLmxlbmd0aCkge1xuICAgICAgLy8gYWxsIGdvcHMgdHJpbW1lZCwgc2tpcCBhcHBlbmRpbmcgYWxsIGdvcHNcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGFsaWduZWRHb3BzID0gZ29wcy5zbGljZShnb3BJbmRleCk7XG4gICAgYWxpZ25lZEdvcHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG4gICAgYWxpZ25lZEdvcHMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICBhbGlnbmVkR29wcy5uYWxDb3VudCA9IG5hbENvdW50O1xuICAgIGFsaWduZWRHb3BzLnB0cyA9IGFsaWduZWRHb3BzWzBdLnB0cztcbiAgICBhbGlnbmVkR29wcy5kdHMgPSBhbGlnbmVkR29wc1swXS5kdHM7XG5cbiAgICByZXR1cm4gYWxpZ25lZEdvcHM7XG4gIH07XG5cbiAgLy8gdHJpbSBnb3AgbGlzdCB0byB0aGUgZmlyc3QgZ29wIGZvdW5kIHRoYXQgaGFzIGEgbWF0Y2hpbmcgcHRzIHdpdGggYSBnb3AgaW4gdGhlIGxpc3RcbiAgLy8gb2YgZ29wc1RvQWxpZ25XaXRoIHN0YXJ0aW5nIGZyb20gdGhlIEVORCBvZiB0aGUgbGlzdFxuICB0aGlzLmFsaWduR29wc0F0RW5kXyA9IGZ1bmN0aW9uKGdvcHMpIHtcbiAgICB2YXIgYWxpZ25JbmRleCwgZ29wSW5kZXgsIGFsaWduLCBnb3AsIGFsaWduRW5kSW5kZXgsIG1hdGNoRm91bmQ7XG5cbiAgICBhbGlnbkluZGV4ID0gZ29wc1RvQWxpZ25XaXRoLmxlbmd0aCAtIDE7XG4gICAgZ29wSW5kZXggPSBnb3BzLmxlbmd0aCAtIDE7XG4gICAgYWxpZ25FbmRJbmRleCA9IG51bGw7XG4gICAgbWF0Y2hGb3VuZCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKGFsaWduSW5kZXggPj0gMCAmJiBnb3BJbmRleCA+PSAwKSB7XG4gICAgICBhbGlnbiA9IGdvcHNUb0FsaWduV2l0aFthbGlnbkluZGV4XTtcbiAgICAgIGdvcCA9IGdvcHNbZ29wSW5kZXhdO1xuXG4gICAgICBpZiAoYWxpZ24ucHRzID09PSBnb3AucHRzKSB7XG4gICAgICAgIG1hdGNoRm91bmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGFsaWduLnB0cyA+IGdvcC5wdHMpIHtcbiAgICAgICAgYWxpZ25JbmRleC0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsaWduSW5kZXggPT09IGdvcHNUb0FsaWduV2l0aC5sZW5ndGggLSAxKSB7XG4gICAgICAgIC8vIGdvcC5wdHMgaXMgZ3JlYXRlciB0aGFuIHRoZSBsYXN0IGFsaWdubWVudCBjYW5kaWRhdGUuIElmIG5vIG1hdGNoIGlzIGZvdW5kXG4gICAgICAgIC8vIGJ5IHRoZSBlbmQgb2YgdGhpcyBsb29wLCB3ZSBzdGlsbCB3YW50IHRvIGFwcGVuZCBnb3BzIHRoYXQgY29tZSBhZnRlciB0aGlzXG4gICAgICAgIC8vIHBvaW50XG4gICAgICAgIGFsaWduRW5kSW5kZXggPSBnb3BJbmRleDtcbiAgICAgIH1cblxuICAgICAgZ29wSW5kZXgtLTtcbiAgICB9XG5cbiAgICBpZiAoIW1hdGNoRm91bmQgJiYgYWxpZ25FbmRJbmRleCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHRyaW1JbmRleDtcblxuICAgIGlmIChtYXRjaEZvdW5kKSB7XG4gICAgICB0cmltSW5kZXggPSBnb3BJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpbUluZGV4ID0gYWxpZ25FbmRJbmRleDtcbiAgICB9XG5cbiAgICBpZiAodHJpbUluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gZ29wcztcbiAgICB9XG5cbiAgICB2YXIgYWxpZ25lZEdvcHMgPSBnb3BzLnNsaWNlKHRyaW1JbmRleCk7XG4gICAgdmFyIG1ldGFkYXRhID0gYWxpZ25lZEdvcHMucmVkdWNlKGZ1bmN0aW9uKHRvdGFsLCBnb3ApIHtcbiAgICAgIHRvdGFsLmJ5dGVMZW5ndGggKz0gZ29wLmJ5dGVMZW5ndGg7XG4gICAgICB0b3RhbC5kdXJhdGlvbiArPSBnb3AuZHVyYXRpb247XG4gICAgICB0b3RhbC5uYWxDb3VudCArPSBnb3AubmFsQ291bnQ7XG4gICAgICByZXR1cm4gdG90YWw7XG4gICAgfSwgeyBieXRlTGVuZ3RoOiAwLCBkdXJhdGlvbjogMCwgbmFsQ291bnQ6IDAgfSk7XG5cbiAgICBhbGlnbmVkR29wcy5ieXRlTGVuZ3RoID0gbWV0YWRhdGEuYnl0ZUxlbmd0aDtcbiAgICBhbGlnbmVkR29wcy5kdXJhdGlvbiA9IG1ldGFkYXRhLmR1cmF0aW9uO1xuICAgIGFsaWduZWRHb3BzLm5hbENvdW50ID0gbWV0YWRhdGEubmFsQ291bnQ7XG4gICAgYWxpZ25lZEdvcHMucHRzID0gYWxpZ25lZEdvcHNbMF0ucHRzO1xuICAgIGFsaWduZWRHb3BzLmR0cyA9IGFsaWduZWRHb3BzWzBdLmR0cztcblxuICAgIHJldHVybiBhbGlnbmVkR29wcztcbiAgfTtcblxuICB0aGlzLmFsaWduR29wc1dpdGggPSBmdW5jdGlvbihuZXdHb3BzVG9BbGlnbldpdGgpIHtcbiAgICBnb3BzVG9BbGlnbldpdGggPSBuZXdHb3BzVG9BbGlnbldpdGg7XG4gIH07XG59O1xuXG5WaWRlb1NlZ21lbnRTdHJlYW0ucHJvdG90eXBlID0gbmV3IFN0cmVhbSgpO1xuXG4vKipcbiAqIFN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSB0cmFjayBhbmQgdGhlXG4gKiBkdXJhdGlvbiBmb3IgZWFjaCBmcmFtZS9zYW1wbGUgd2UgcHJvY2VzcyBpbiBvcmRlciB0byBjYWxjdWxhdGVcbiAqIHRoZSBiYXNlTWVkaWFEZWNvZGVUaW1lXG4gKi9cbmNvbGxlY3REdHNJbmZvID0gZnVuY3Rpb24odHJhY2ssIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBkYXRhLnB0cyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHJhY2sudGltZWxpbmVTdGFydEluZm8ucHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLnB0cyA9IGRhdGEucHRzO1xuICAgIH1cblxuICAgIGlmICh0cmFjay5taW5TZWdtZW50UHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyYWNrLm1pblNlZ21lbnRQdHMgPSBkYXRhLnB0cztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2subWluU2VnbWVudFB0cyA9IE1hdGgubWluKHRyYWNrLm1pblNlZ21lbnRQdHMsIGRhdGEucHRzKTtcbiAgICB9XG5cbiAgICBpZiAodHJhY2subWF4U2VnbWVudFB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0cmFjay5tYXhTZWdtZW50UHRzID0gZGF0YS5wdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYWNrLm1heFNlZ21lbnRQdHMgPSBNYXRoLm1heCh0cmFjay5tYXhTZWdtZW50UHRzLCBkYXRhLnB0cyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBkYXRhLmR0cyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHJhY2sudGltZWxpbmVTdGFydEluZm8uZHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmR0cyA9IGRhdGEuZHRzO1xuICAgIH1cblxuICAgIGlmICh0cmFjay5taW5TZWdtZW50RHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyYWNrLm1pblNlZ21lbnREdHMgPSBkYXRhLmR0cztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhY2subWluU2VnbWVudER0cyA9IE1hdGgubWluKHRyYWNrLm1pblNlZ21lbnREdHMsIGRhdGEuZHRzKTtcbiAgICB9XG5cbiAgICBpZiAodHJhY2subWF4U2VnbWVudER0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0cmFjay5tYXhTZWdtZW50RHRzID0gZGF0YS5kdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYWNrLm1heFNlZ21lbnREdHMgPSBNYXRoLm1heCh0cmFjay5tYXhTZWdtZW50RHRzLCBkYXRhLmR0cyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFyIHZhbHVlcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgYmFzZU1lZGlhRGVjb2RlVGltZSBiZXR3ZWVuXG4gKiB0cmFja3NcbiAqL1xuY2xlYXJEdHNJbmZvID0gZnVuY3Rpb24odHJhY2spIHtcbiAgZGVsZXRlIHRyYWNrLm1pblNlZ21lbnREdHM7XG4gIGRlbGV0ZSB0cmFjay5tYXhTZWdtZW50RHRzO1xuICBkZWxldGUgdHJhY2subWluU2VnbWVudFB0cztcbiAgZGVsZXRlIHRyYWNrLm1heFNlZ21lbnRQdHM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgdHJhY2sncyBiYXNlTWVkaWFEZWNvZGVUaW1lIGJhc2VkIG9uIHRoZSBlYXJsaWVzdFxuICogRFRTIHRoZSB0cmFuc211eGVyIGhhcyBldmVyIHNlZW4gYW5kIHRoZSBtaW5pbXVtIERUUyBmb3IgdGhlXG4gKiBjdXJyZW50IHRyYWNrXG4gKi9cbmNhbGN1bGF0ZVRyYWNrQmFzZU1lZGlhRGVjb2RlVGltZSA9IGZ1bmN0aW9uKHRyYWNrKSB7XG4gIHZhclxuICAgIGJhc2VNZWRpYURlY29kZVRpbWUsXG4gICAgc2NhbGUsXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSwgaW4gdGltZSwgdGhhdCB0aGlzIHNlZ21lbnQgc3RhcnRzIGZyb20gdGhlIHN0YXJ0XG4gICAgLy8gb2YgdGhlIHRpbWVsaW5lIChlYXJsaWVzdCB0aW1lIHNlZW4gc2luY2UgdGhlIHRyYW5zbXV4ZXIgaW5pdGlhbGl6ZWQpXG4gICAgdGltZVNpbmNlU3RhcnRPZlRpbWVsaW5lID0gdHJhY2subWluU2VnbWVudER0cyAtIHRyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmR0cztcblxuICAvLyB0cmFjay50aW1lbGluZVN0YXJ0SW5mby5iYXNlTWVkaWFEZWNvZGVUaW1lIGlzIHRoZSBsb2NhdGlvbiwgaW4gdGltZSwgd2hlcmVcbiAgLy8gd2Ugd2FudCB0aGUgc3RhcnQgb2YgdGhlIGZpcnN0IHNlZ21lbnQgdG8gYmUgcGxhY2VkXG4gIGJhc2VNZWRpYURlY29kZVRpbWUgPSB0cmFjay50aW1lbGluZVN0YXJ0SW5mby5iYXNlTWVkaWFEZWNvZGVUaW1lO1xuXG4gIC8vIEFkZCB0byB0aGF0IHRoZSBkaXN0YW5jZSB0aGlzIHNlZ21lbnQgaXMgZnJvbSB0aGUgdmVyeSBmaXJzdFxuICBiYXNlTWVkaWFEZWNvZGVUaW1lICs9IHRpbWVTaW5jZVN0YXJ0T2ZUaW1lbGluZTtcblxuICAvLyBiYXNlTWVkaWFEZWNvZGVUaW1lIG11c3Qgbm90IGJlY29tZSBuZWdhdGl2ZVxuICBiYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5tYXgoMCwgYmFzZU1lZGlhRGVjb2RlVGltZSk7XG5cbiAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAvLyBBdWRpbyBoYXMgYSBkaWZmZXJlbnQgY2xvY2sgZXF1YWwgdG8gdGhlIHNhbXBsaW5nX3JhdGUgc28gd2UgbmVlZCB0b1xuICAgIC8vIHNjYWxlIHRoZSBQVFMgdmFsdWVzIGludG8gdGhlIGNsb2NrIHJhdGUgb2YgdGhlIHRyYWNrXG4gICAgc2NhbGUgPSB0cmFjay5zYW1wbGVyYXRlIC8gT05FX1NFQ09ORF9JTl9UUztcbiAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICo9IHNjYWxlO1xuICAgIGJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUpO1xuICB9XG5cbiAgcmV0dXJuIGJhc2VNZWRpYURlY29kZVRpbWU7XG59O1xuXG4vKipcbiAqIEEgU3RyZWFtIHRoYXQgY2FuIGNvbWJpbmUgbXVsdGlwbGUgc3RyZWFtcyAoaWUuIGF1ZGlvICYgdmlkZW8pXG4gKiBpbnRvIGEgc2luZ2xlIG91dHB1dCBzZWdtZW50IGZvciBNU0UuIEFsc28gc3VwcG9ydHMgYXVkaW8tb25seVxuICogYW5kIHZpZGVvLW9ubHkgc3RyZWFtcy5cbiAqL1xuQ29hbGVzY2VTdHJlYW0gPSBmdW5jdGlvbihvcHRpb25zLCBtZXRhZGF0YVN0cmVhbSkge1xuICAvLyBOdW1iZXIgb2YgVHJhY2tzIHBlciBvdXRwdXQgc2VnbWVudFxuICAvLyBJZiBncmVhdGVyIHRoYW4gMSwgd2UgY29tYmluZSBtdWx0aXBsZVxuICAvLyB0cmFja3MgaW50byBhIHNpbmdsZSBzZWdtZW50XG4gIHRoaXMubnVtYmVyT2ZUcmFja3MgPSAwO1xuICB0aGlzLm1ldGFkYXRhU3RyZWFtID0gbWV0YWRhdGFTdHJlYW07XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLnJlbXV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMucmVtdXhUcmFja3MgPSAhIW9wdGlvbnMucmVtdXg7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZW11eFRyYWNrcyA9IHRydWU7XG4gIH1cblxuICB0aGlzLnBlbmRpbmdUcmFja3MgPSBbXTtcbiAgdGhpcy52aWRlb1RyYWNrID0gbnVsbDtcbiAgdGhpcy5wZW5kaW5nQm94ZXMgPSBbXTtcbiAgdGhpcy5wZW5kaW5nQ2FwdGlvbnMgPSBbXTtcbiAgdGhpcy5wZW5kaW5nTWV0YWRhdGEgPSBbXTtcbiAgdGhpcy5wZW5kaW5nQnl0ZXMgPSAwO1xuICB0aGlzLmVtaXR0ZWRUcmFja3MgPSAwO1xuXG4gIENvYWxlc2NlU3RyZWFtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG5cbiAgLy8gVGFrZSBvdXRwdXQgZnJvbSBtdWx0aXBsZVxuICB0aGlzLnB1c2ggPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAvLyBidWZmZXIgaW5jb21pbmcgY2FwdGlvbnMgdW50aWwgdGhlIGFzc29jaWF0ZWQgdmlkZW8gc2VnbWVudFxuICAgIC8vIGZpbmlzaGVzXG4gICAgaWYgKG91dHB1dC50ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5wZW5kaW5nQ2FwdGlvbnMucHVzaChvdXRwdXQpO1xuICAgIH1cbiAgICAvLyBidWZmZXIgaW5jb21pbmcgaWQzIHRhZ3MgdW50aWwgdGhlIGZpbmFsIGZsdXNoXG4gICAgaWYgKG91dHB1dC5mcmFtZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdNZXRhZGF0YS5wdXNoKG91dHB1dCk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoaXMgdHJhY2sgdG8gdGhlIGxpc3Qgb2YgcGVuZGluZyB0cmFja3MgYW5kIHN0b3JlXG4gICAgLy8gaW1wb3J0YW50IGluZm9ybWF0aW9uIHJlcXVpcmVkIGZvciB0aGUgY29uc3RydWN0aW9uIG9mXG4gICAgLy8gdGhlIGZpbmFsIHNlZ21lbnRcbiAgICB0aGlzLnBlbmRpbmdUcmFja3MucHVzaChvdXRwdXQudHJhY2spO1xuICAgIHRoaXMucGVuZGluZ0JveGVzLnB1c2gob3V0cHV0LmJveGVzKTtcbiAgICB0aGlzLnBlbmRpbmdCeXRlcyArPSBvdXRwdXQuYm94ZXMuYnl0ZUxlbmd0aDtcblxuICAgIGlmIChvdXRwdXQudHJhY2sudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgdGhpcy52aWRlb1RyYWNrID0gb3V0cHV0LnRyYWNrO1xuICAgIH1cbiAgICBpZiAob3V0cHV0LnRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIHRoaXMuYXVkaW9UcmFjayA9IG91dHB1dC50cmFjaztcbiAgICB9XG4gIH07XG59O1xuXG5Db2FsZXNjZVN0cmVhbS5wcm90b3R5cGUgPSBuZXcgU3RyZWFtKCk7XG5Db2FsZXNjZVN0cmVhbS5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbihmbHVzaFNvdXJjZSkge1xuICB2YXJcbiAgICBvZmZzZXQgPSAwLFxuICAgIGV2ZW50ID0ge1xuICAgICAgY2FwdGlvbnM6IFtdLFxuICAgICAgY2FwdGlvblN0cmVhbXM6IHt9LFxuICAgICAgbWV0YWRhdGE6IFtdLFxuICAgICAgaW5mbzoge31cbiAgICB9LFxuICAgIGNhcHRpb24sXG4gICAgaWQzLFxuICAgIGluaXRTZWdtZW50LFxuICAgIHRpbWVsaW5lU3RhcnRQdHMgPSAwLFxuICAgIGk7XG5cbiAgaWYgKHRoaXMucGVuZGluZ1RyYWNrcy5sZW5ndGggPCB0aGlzLm51bWJlck9mVHJhY2tzKSB7XG4gICAgaWYgKGZsdXNoU291cmNlICE9PSAnVmlkZW9TZWdtZW50U3RyZWFtJyAmJlxuICAgICAgICBmbHVzaFNvdXJjZSAhPT0gJ0F1ZGlvU2VnbWVudFN0cmVhbScpIHtcbiAgICAgIC8vIFJldHVybiBiZWNhdXNlIHdlIGhhdmVuJ3QgcmVjZWl2ZWQgYSBmbHVzaCBmcm9tIGEgZGF0YS1nZW5lcmF0aW5nXG4gICAgICAvLyBwb3J0aW9uIG9mIHRoZSBzZWdtZW50IChtZWFuaW5nIHRoYXQgd2UgaGF2ZSBvbmx5IHJlY2lldmVkIG1ldGEtZGF0YVxuICAgICAgLy8gb3IgY2FwdGlvbnMuKVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZW11eFRyYWNrcykge1xuICAgICAgLy8gUmV0dXJuIHVudGlsIHdlIGhhdmUgZW5vdWdoIHRyYWNrcyBmcm9tIHRoZSBwaXBlbGluZSB0byByZW11eCAoaWYgd2VcbiAgICAgIC8vIGFyZSByZW11eGluZyBhdWRpbyBhbmQgdmlkZW8gaW50byBhIHNpbmdsZSBNUDQpXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0aGlzLnBlbmRpbmdUcmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBJbiB0aGUgY2FzZSB3aGVyZSB3ZSByZWNlaXZlIGEgZmx1c2ggd2l0aG91dCBhbnkgZGF0YSBoYXZpbmcgYmVlblxuICAgICAgLy8gcmVjZWl2ZWQgd2UgY29uc2lkZXIgaXQgYW4gZW1pdHRlZCB0cmFjayBmb3IgdGhlIHB1cnBvc2VzIG9mIGNvYWxlc2NpbmdcbiAgICAgIC8vIGBkb25lYCBldmVudHMuXG4gICAgICAvLyBXZSBkbyB0aGlzIGZvciB0aGUgY2FzZSB3aGVyZSB0aGVyZSBpcyBhbiBhdWRpbyBhbmQgdmlkZW8gdHJhY2sgaW4gdGhlXG4gICAgICAvLyBzZWdtZW50IGJ1dCBubyBhdWRpbyBkYXRhLiAoc2VlbiBpbiBzZXZlcmFsIHBsYXlsaXN0cyB3aXRoIGFsdGVybmF0ZVxuICAgICAgLy8gYXVkaW8gdHJhY2tzIGFuZCBubyBhdWRpbyBwcmVzZW50IGluIHRoZSBtYWluIFRTIHNlZ21lbnRzLilcbiAgICAgIHRoaXMuZW1pdHRlZFRyYWNrcysrO1xuXG4gICAgICBpZiAodGhpcy5lbWl0dGVkVHJhY2tzID49IHRoaXMubnVtYmVyT2ZUcmFja3MpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkb25lJyk7XG4gICAgICAgIHRoaXMuZW1pdHRlZFRyYWNrcyA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMudmlkZW9UcmFjaykge1xuICAgIHRpbWVsaW5lU3RhcnRQdHMgPSB0aGlzLnZpZGVvVHJhY2sudGltZWxpbmVTdGFydEluZm8ucHRzO1xuICAgIFZJREVPX1BST1BFUlRJRVMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICBldmVudC5pbmZvW3Byb3BdID0gdGhpcy52aWRlb1RyYWNrW3Byb3BdO1xuICAgIH0sIHRoaXMpO1xuICB9IGVsc2UgaWYgKHRoaXMuYXVkaW9UcmFjaykge1xuICAgIHRpbWVsaW5lU3RhcnRQdHMgPSB0aGlzLmF1ZGlvVHJhY2sudGltZWxpbmVTdGFydEluZm8ucHRzO1xuICAgIEFVRElPX1BST1BFUlRJRVMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICBldmVudC5pbmZvW3Byb3BdID0gdGhpcy5hdWRpb1RyYWNrW3Byb3BdO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgaWYgKHRoaXMucGVuZGluZ1RyYWNrcy5sZW5ndGggPT09IDEpIHtcbiAgICBldmVudC50eXBlID0gdGhpcy5wZW5kaW5nVHJhY2tzWzBdLnR5cGU7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnQudHlwZSA9ICdjb21iaW5lZCc7XG4gIH1cblxuICB0aGlzLmVtaXR0ZWRUcmFja3MgKz0gdGhpcy5wZW5kaW5nVHJhY2tzLmxlbmd0aDtcblxuICBpbml0U2VnbWVudCA9IG1wNC5pbml0U2VnbWVudCh0aGlzLnBlbmRpbmdUcmFja3MpO1xuXG4gIC8vIENyZWF0ZSBhIG5ldyB0eXBlZCBhcnJheSB0byBob2xkIHRoZSBpbml0IHNlZ21lbnRcbiAgZXZlbnQuaW5pdFNlZ21lbnQgPSBuZXcgVWludDhBcnJheShpbml0U2VnbWVudC5ieXRlTGVuZ3RoKTtcblxuICAvLyBDcmVhdGUgYW4gaW5pdCBzZWdtZW50IGNvbnRhaW5pbmcgYSBtb292XG4gIC8vIGFuZCB0cmFjayBkZWZpbml0aW9uc1xuICBldmVudC5pbml0U2VnbWVudC5zZXQoaW5pdFNlZ21lbnQpO1xuXG4gIC8vIENyZWF0ZSBhIG5ldyB0eXBlZCBhcnJheSB0byBob2xkIHRoZSBtb29mK21kYXRzXG4gIGV2ZW50LmRhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLnBlbmRpbmdCeXRlcyk7XG5cbiAgLy8gQXBwZW5kIGVhY2ggbW9vZittZGF0IChvbmUgcGVyIHRyYWNrKSB0b2dldGhlclxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nQm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBldmVudC5kYXRhLnNldCh0aGlzLnBlbmRpbmdCb3hlc1tpXSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gdGhpcy5wZW5kaW5nQm94ZXNbaV0uYnl0ZUxlbmd0aDtcbiAgfVxuXG4gIC8vIFRyYW5zbGF0ZSBjYXB0aW9uIFBUUyB0aW1lcyBpbnRvIHNlY29uZCBvZmZzZXRzIGludG8gdGhlXG4gIC8vIHZpZGVvIHRpbWVsaW5lIGZvciB0aGUgc2VnbWVudCwgYW5kIGFkZCB0cmFjayBpbmZvXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdDYXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGNhcHRpb24gPSB0aGlzLnBlbmRpbmdDYXB0aW9uc1tpXTtcbiAgICBjYXB0aW9uLnN0YXJ0VGltZSA9IChjYXB0aW9uLnN0YXJ0UHRzIC0gdGltZWxpbmVTdGFydFB0cyk7XG4gICAgY2FwdGlvbi5zdGFydFRpbWUgLz0gOTBlMztcbiAgICBjYXB0aW9uLmVuZFRpbWUgPSAoY2FwdGlvbi5lbmRQdHMgLSB0aW1lbGluZVN0YXJ0UHRzKTtcbiAgICBjYXB0aW9uLmVuZFRpbWUgLz0gOTBlMztcbiAgICBldmVudC5jYXB0aW9uU3RyZWFtc1tjYXB0aW9uLnN0cmVhbV0gPSB0cnVlO1xuICAgIGV2ZW50LmNhcHRpb25zLnB1c2goY2FwdGlvbik7XG4gIH1cblxuICAvLyBUcmFuc2xhdGUgSUQzIGZyYW1lIFBUUyB0aW1lcyBpbnRvIHNlY29uZCBvZmZzZXRzIGludG8gdGhlXG4gIC8vIHZpZGVvIHRpbWVsaW5lIGZvciB0aGUgc2VnbWVudFxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nTWV0YWRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZDMgPSB0aGlzLnBlbmRpbmdNZXRhZGF0YVtpXTtcbiAgICBpZDMuY3VlVGltZSA9IChpZDMucHRzIC0gdGltZWxpbmVTdGFydFB0cyk7XG4gICAgaWQzLmN1ZVRpbWUgLz0gOTBlMztcbiAgICBldmVudC5tZXRhZGF0YS5wdXNoKGlkMyk7XG4gIH1cbiAgLy8gV2UgYWRkIHRoaXMgdG8gZXZlcnkgc2luZ2xlIGVtaXR0ZWQgc2VnbWVudCBldmVuIHRob3VnaCB3ZSBvbmx5IG5lZWRcbiAgLy8gaXQgZm9yIHRoZSBmaXJzdFxuICBldmVudC5tZXRhZGF0YS5kaXNwYXRjaFR5cGUgPSB0aGlzLm1ldGFkYXRhU3RyZWFtLmRpc3BhdGNoVHlwZTtcblxuICAvLyBSZXNldCBzdHJlYW0gc3RhdGVcbiAgdGhpcy5wZW5kaW5nVHJhY2tzLmxlbmd0aCA9IDA7XG4gIHRoaXMudmlkZW9UcmFjayA9IG51bGw7XG4gIHRoaXMucGVuZGluZ0JveGVzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGVuZGluZ0NhcHRpb25zLmxlbmd0aCA9IDA7XG4gIHRoaXMucGVuZGluZ0J5dGVzID0gMDtcbiAgdGhpcy5wZW5kaW5nTWV0YWRhdGEubGVuZ3RoID0gMDtcblxuICAvLyBFbWl0IHRoZSBidWlsdCBzZWdtZW50XG4gIHRoaXMudHJpZ2dlcignZGF0YScsIGV2ZW50KTtcblxuICAvLyBPbmx5IGVtaXQgYGRvbmVgIGlmIGFsbCB0cmFja3MgaGF2ZSBiZWVuIGZsdXNoZWQgYW5kIGVtaXR0ZWRcbiAgaWYgKHRoaXMuZW1pdHRlZFRyYWNrcyA+PSB0aGlzLm51bWJlck9mVHJhY2tzKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdkb25lJyk7XG4gICAgdGhpcy5lbWl0dGVkVHJhY2tzID0gMDtcbiAgfVxufTtcbi8qKlxuICogQSBTdHJlYW0gdGhhdCBleHBlY3RzIE1QMlQgYmluYXJ5IGRhdGEgYXMgaW5wdXQgYW5kIHByb2R1Y2VzXG4gKiBjb3JyZXNwb25kaW5nIG1lZGlhIHNlZ21lbnRzLCBzdWl0YWJsZSBmb3IgdXNlIHdpdGggTWVkaWEgU291cmNlXG4gKiBFeHRlbnNpb24gKE1TRSkgaW1wbGVtZW50YXRpb25zIHRoYXQgc3VwcG9ydCB0aGUgSVNPIEJNRkYgYnl0ZVxuICogc3RyZWFtIGZvcm1hdCwgbGlrZSBDaHJvbWUuXG4gKi9cblRyYW5zbXV4ZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhclxuICAgIHNlbGYgPSB0aGlzLFxuICAgIGhhc0ZsdXNoZWQgPSB0cnVlLFxuICAgIHZpZGVvVHJhY2ssXG4gICAgYXVkaW9UcmFjaztcblxuICBUcmFuc211eGVyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuYmFzZU1lZGlhRGVjb2RlVGltZSA9IG9wdGlvbnMuYmFzZU1lZGlhRGVjb2RlVGltZSB8fCAwO1xuICB0aGlzLnRyYW5zbXV4UGlwZWxpbmVfID0ge307XG5cbiAgdGhpcy5zZXR1cEFhY1BpcGVsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBpcGVsaW5lID0ge307XG4gICAgdGhpcy50cmFuc211eFBpcGVsaW5lXyA9IHBpcGVsaW5lO1xuXG4gICAgcGlwZWxpbmUudHlwZSA9ICdhYWMnO1xuICAgIHBpcGVsaW5lLm1ldGFkYXRhU3RyZWFtID0gbmV3IG0ydHMuTWV0YWRhdGFTdHJlYW0oKTtcblxuICAgIC8vIHNldCB1cCB0aGUgcGFyc2luZyBwaXBlbGluZVxuICAgIHBpcGVsaW5lLmFhY1N0cmVhbSA9IG5ldyBBYWNTdHJlYW0oKTtcbiAgICBwaXBlbGluZS5hdWRpb1RpbWVzdGFtcFJvbGxvdmVyU3RyZWFtID0gbmV3IG0ydHMuVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0oJ2F1ZGlvJyk7XG4gICAgcGlwZWxpbmUudGltZWRNZXRhZGF0YVRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtID0gbmV3IG0ydHMuVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0oJ3RpbWVkLW1ldGFkYXRhJyk7XG4gICAgcGlwZWxpbmUuYWR0c1N0cmVhbSA9IG5ldyBBZHRzU3RyZWFtKCk7XG4gICAgcGlwZWxpbmUuY29hbGVzY2VTdHJlYW0gPSBuZXcgQ29hbGVzY2VTdHJlYW0ob3B0aW9ucywgcGlwZWxpbmUubWV0YWRhdGFTdHJlYW0pO1xuICAgIHBpcGVsaW5lLmhlYWRPZlBpcGVsaW5lID0gcGlwZWxpbmUuYWFjU3RyZWFtO1xuXG4gICAgcGlwZWxpbmUuYWFjU3RyZWFtXG4gICAgICAucGlwZShwaXBlbGluZS5hdWRpb1RpbWVzdGFtcFJvbGxvdmVyU3RyZWFtKVxuICAgICAgLnBpcGUocGlwZWxpbmUuYWR0c1N0cmVhbSk7XG4gICAgcGlwZWxpbmUuYWFjU3RyZWFtXG4gICAgICAucGlwZShwaXBlbGluZS50aW1lZE1ldGFkYXRhVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0pXG4gICAgICAucGlwZShwaXBlbGluZS5tZXRhZGF0YVN0cmVhbSlcbiAgICAgIC5waXBlKHBpcGVsaW5lLmNvYWxlc2NlU3RyZWFtKTtcblxuICAgIHBpcGVsaW5lLm1ldGFkYXRhU3RyZWFtLm9uKCd0aW1lc3RhbXAnLCBmdW5jdGlvbihmcmFtZSkge1xuICAgICAgcGlwZWxpbmUuYWFjU3RyZWFtLnNldFRpbWVzdGFtcChmcmFtZS50aW1lU3RhbXApO1xuICAgIH0pO1xuXG4gICAgcGlwZWxpbmUuYWFjU3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ3RpbWVkLW1ldGFkYXRhJyAmJiAhcGlwZWxpbmUuYXVkaW9TZWdtZW50U3RyZWFtKSB7XG4gICAgICAgIGF1ZGlvVHJhY2sgPSBhdWRpb1RyYWNrIHx8IHtcbiAgICAgICAgICB0aW1lbGluZVN0YXJ0SW5mbzoge1xuICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZTogc2VsZi5iYXNlTWVkaWFEZWNvZGVUaW1lXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb2RlYzogJ2FkdHMnLFxuICAgICAgICAgIHR5cGU6ICdhdWRpbydcbiAgICAgICAgfTtcbiAgICAgICAgLy8gaG9vayB1cCB0aGUgYXVkaW8gc2VnbWVudCBzdHJlYW0gdG8gdGhlIGZpcnN0IHRyYWNrIHdpdGggYWFjIGRhdGFcbiAgICAgICAgcGlwZWxpbmUuY29hbGVzY2VTdHJlYW0ubnVtYmVyT2ZUcmFja3MrKztcbiAgICAgICAgcGlwZWxpbmUuYXVkaW9TZWdtZW50U3RyZWFtID0gbmV3IEF1ZGlvU2VnbWVudFN0cmVhbShhdWRpb1RyYWNrKTtcbiAgICAgICAgLy8gU2V0IHVwIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSBhdWRpbyBwaXBlbGluZVxuICAgICAgICBwaXBlbGluZS5hZHRzU3RyZWFtXG4gICAgICAgICAgLnBpcGUocGlwZWxpbmUuYXVkaW9TZWdtZW50U3RyZWFtKVxuICAgICAgICAgIC5waXBlKHBpcGVsaW5lLmNvYWxlc2NlU3RyZWFtKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlLWVtaXQgYW55IGRhdGEgY29taW5nIGZyb20gdGhlIGNvYWxlc2NlIHN0cmVhbSB0byB0aGUgb3V0c2lkZSB3b3JsZFxuICAgIHBpcGVsaW5lLmNvYWxlc2NlU3RyZWFtLm9uKCdkYXRhJywgdGhpcy50cmlnZ2VyLmJpbmQodGhpcywgJ2RhdGEnKSk7XG4gICAgLy8gTGV0IHRoZSBjb25zdW1lciBrbm93IHdlIGhhdmUgZmluaXNoZWQgZmx1c2hpbmcgdGhlIGVudGlyZSBwaXBlbGluZVxuICAgIHBpcGVsaW5lLmNvYWxlc2NlU3RyZWFtLm9uKCdkb25lJywgdGhpcy50cmlnZ2VyLmJpbmQodGhpcywgJ2RvbmUnKSk7XG4gIH07XG5cbiAgdGhpcy5zZXR1cFRzUGlwZWxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGlwZWxpbmUgPSB7fTtcbiAgICB0aGlzLnRyYW5zbXV4UGlwZWxpbmVfID0gcGlwZWxpbmU7XG5cbiAgICBwaXBlbGluZS50eXBlID0gJ3RzJztcbiAgICBwaXBlbGluZS5tZXRhZGF0YVN0cmVhbSA9IG5ldyBtMnRzLk1ldGFkYXRhU3RyZWFtKCk7XG5cbiAgICAvLyBzZXQgdXAgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgICBwaXBlbGluZS5wYWNrZXRTdHJlYW0gPSBuZXcgbTJ0cy5UcmFuc3BvcnRQYWNrZXRTdHJlYW0oKTtcbiAgICBwaXBlbGluZS5wYXJzZVN0cmVhbSA9IG5ldyBtMnRzLlRyYW5zcG9ydFBhcnNlU3RyZWFtKCk7XG4gICAgcGlwZWxpbmUuZWxlbWVudGFyeVN0cmVhbSA9IG5ldyBtMnRzLkVsZW1lbnRhcnlTdHJlYW0oKTtcbiAgICBwaXBlbGluZS52aWRlb1RpbWVzdGFtcFJvbGxvdmVyU3RyZWFtID0gbmV3IG0ydHMuVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0oJ3ZpZGVvJyk7XG4gICAgcGlwZWxpbmUuYXVkaW9UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSA9IG5ldyBtMnRzLlRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtKCdhdWRpbycpO1xuICAgIHBpcGVsaW5lLnRpbWVkTWV0YWRhdGFUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSA9IG5ldyBtMnRzLlRpbWVzdGFtcFJvbGxvdmVyU3RyZWFtKCd0aW1lZC1tZXRhZGF0YScpO1xuICAgIHBpcGVsaW5lLmFkdHNTdHJlYW0gPSBuZXcgQWR0c1N0cmVhbSgpO1xuICAgIHBpcGVsaW5lLmgyNjRTdHJlYW0gPSBuZXcgSDI2NFN0cmVhbSgpO1xuICAgIHBpcGVsaW5lLmNhcHRpb25TdHJlYW0gPSBuZXcgbTJ0cy5DYXB0aW9uU3RyZWFtKCk7XG4gICAgcGlwZWxpbmUuY29hbGVzY2VTdHJlYW0gPSBuZXcgQ29hbGVzY2VTdHJlYW0ob3B0aW9ucywgcGlwZWxpbmUubWV0YWRhdGFTdHJlYW0pO1xuICAgIHBpcGVsaW5lLmhlYWRPZlBpcGVsaW5lID0gcGlwZWxpbmUucGFja2V0U3RyZWFtO1xuXG4gICAgLy8gZGlzYXNzZW1ibGUgTVBFRzItVFMgcGFja2V0cyBpbnRvIGVsZW1lbnRhcnkgc3RyZWFtc1xuICAgIHBpcGVsaW5lLnBhY2tldFN0cmVhbVxuICAgICAgLnBpcGUocGlwZWxpbmUucGFyc2VTdHJlYW0pXG4gICAgICAucGlwZShwaXBlbGluZS5lbGVtZW50YXJ5U3RyZWFtKTtcblxuICAgIC8vICEhVEhJUyBPUkRFUiBJUyBJTVBPUlRBTlQhIVxuICAgIC8vIGRlbXV4IHRoZSBzdHJlYW1zXG4gICAgcGlwZWxpbmUuZWxlbWVudGFyeVN0cmVhbVxuICAgICAgLnBpcGUocGlwZWxpbmUudmlkZW9UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSlcbiAgICAgIC5waXBlKHBpcGVsaW5lLmgyNjRTdHJlYW0pO1xuICAgIHBpcGVsaW5lLmVsZW1lbnRhcnlTdHJlYW1cbiAgICAgIC5waXBlKHBpcGVsaW5lLmF1ZGlvVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0pXG4gICAgICAucGlwZShwaXBlbGluZS5hZHRzU3RyZWFtKTtcblxuICAgIHBpcGVsaW5lLmVsZW1lbnRhcnlTdHJlYW1cbiAgICAgIC5waXBlKHBpcGVsaW5lLnRpbWVkTWV0YWRhdGFUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSlcbiAgICAgIC5waXBlKHBpcGVsaW5lLm1ldGFkYXRhU3RyZWFtKVxuICAgICAgLnBpcGUocGlwZWxpbmUuY29hbGVzY2VTdHJlYW0pO1xuXG4gICAgLy8gSG9vayB1cCBDRUEtNjA4LzcwOCBjYXB0aW9uIHN0cmVhbVxuICAgIHBpcGVsaW5lLmgyNjRTdHJlYW0ucGlwZShwaXBlbGluZS5jYXB0aW9uU3RyZWFtKVxuICAgICAgLnBpcGUocGlwZWxpbmUuY29hbGVzY2VTdHJlYW0pO1xuXG4gICAgcGlwZWxpbmUuZWxlbWVudGFyeVN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnbWV0YWRhdGEnKSB7XG4gICAgICAgIGkgPSBkYXRhLnRyYWNrcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gc2NhbiB0aGUgdHJhY2tzIGxpc3RlZCBpbiB0aGUgbWV0YWRhdGFcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIGlmICghdmlkZW9UcmFjayAmJiBkYXRhLnRyYWNrc1tpXS50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICB2aWRlb1RyYWNrID0gZGF0YS50cmFja3NbaV07XG4gICAgICAgICAgICB2aWRlb1RyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmJhc2VNZWRpYURlY29kZVRpbWUgPSBzZWxmLmJhc2VNZWRpYURlY29kZVRpbWU7XG4gICAgICAgICAgfSBlbHNlIGlmICghYXVkaW9UcmFjayAmJiBkYXRhLnRyYWNrc1tpXS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICBhdWRpb1RyYWNrID0gZGF0YS50cmFja3NbaV07XG4gICAgICAgICAgICBhdWRpb1RyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmJhc2VNZWRpYURlY29kZVRpbWUgPSBzZWxmLmJhc2VNZWRpYURlY29kZVRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaG9vayB1cCB0aGUgdmlkZW8gc2VnbWVudCBzdHJlYW0gdG8gdGhlIGZpcnN0IHRyYWNrIHdpdGggaDI2NCBkYXRhXG4gICAgICAgIGlmICh2aWRlb1RyYWNrICYmICFwaXBlbGluZS52aWRlb1NlZ21lbnRTdHJlYW0pIHtcbiAgICAgICAgICBwaXBlbGluZS5jb2FsZXNjZVN0cmVhbS5udW1iZXJPZlRyYWNrcysrO1xuICAgICAgICAgIHBpcGVsaW5lLnZpZGVvU2VnbWVudFN0cmVhbSA9IG5ldyBWaWRlb1NlZ21lbnRTdHJlYW0odmlkZW9UcmFjaywgb3B0aW9ucyk7XG5cbiAgICAgICAgICBwaXBlbGluZS52aWRlb1NlZ21lbnRTdHJlYW0ub24oJ3RpbWVsaW5lU3RhcnRJbmZvJywgZnVuY3Rpb24odGltZWxpbmVTdGFydEluZm8pIHtcbiAgICAgICAgICAvLyBXaGVuIHZpZGVvIGVtaXRzIHRpbWVsaW5lU3RhcnRJbmZvIGRhdGEgYWZ0ZXIgYSBmbHVzaCwgd2UgZm9yd2FyZCB0aGF0XG4gICAgICAgICAgLy8gaW5mbyB0byB0aGUgQXVkaW9TZWdtZW50U3RyZWFtLCBpZiBpdCBleGlzdHMsIGJlY2F1c2UgdmlkZW8gdGltZWxpbmVcbiAgICAgICAgICAvLyBkYXRhIHRha2VzIHByZWNlZGVuY2UuXG4gICAgICAgICAgICBpZiAoYXVkaW9UcmFjaykge1xuICAgICAgICAgICAgICBhdWRpb1RyYWNrLnRpbWVsaW5lU3RhcnRJbmZvID0gdGltZWxpbmVTdGFydEluZm87XG4gICAgICAgICAgICAgIC8vIE9uIHRoZSBmaXJzdCBzZWdtZW50IHdlIHRyaW0gQUFDIGZyYW1lcyB0aGF0IGV4aXN0IGJlZm9yZSB0aGVcbiAgICAgICAgICAgICAgLy8gdmVyeSBlYXJsaWVzdCBEVFMgd2UgaGF2ZSBzZWVuIGluIHZpZGVvIGJlY2F1c2UgQ2hyb21lIHdpbGxcbiAgICAgICAgICAgICAgLy8gaW50ZXJwcmV0IGFueSB2aWRlbyB0cmFjayB3aXRoIGEgYmFzZU1lZGlhRGVjb2RlVGltZSB0aGF0IGlzXG4gICAgICAgICAgICAgIC8vIG5vbi16ZXJvIGFzIGEgZ2FwLlxuICAgICAgICAgICAgICBwaXBlbGluZS5hdWRpb1NlZ21lbnRTdHJlYW0uc2V0RWFybGllc3REdHModGltZWxpbmVTdGFydEluZm8uZHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHBpcGVsaW5lLnZpZGVvU2VnbWVudFN0cmVhbS5vbigncHJvY2Vzc2VkR29wc0luZm8nLFxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyLmJpbmQoc2VsZiwgJ2dvcEluZm8nKSk7XG5cbiAgICAgICAgICBwaXBlbGluZS52aWRlb1NlZ21lbnRTdHJlYW0ub24oJ2Jhc2VNZWRpYURlY29kZVRpbWUnLCBmdW5jdGlvbihiYXNlTWVkaWFEZWNvZGVUaW1lKSB7XG4gICAgICAgICAgICBpZiAoYXVkaW9UcmFjaykge1xuICAgICAgICAgICAgICBwaXBlbGluZS5hdWRpb1NlZ21lbnRTdHJlYW0uc2V0VmlkZW9CYXNlTWVkaWFEZWNvZGVUaW1lKGJhc2VNZWRpYURlY29kZVRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gU2V0IHVwIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSB2aWRlbyBwaXBlbGluZVxuICAgICAgICAgIHBpcGVsaW5lLmgyNjRTdHJlYW1cbiAgICAgICAgICAgIC5waXBlKHBpcGVsaW5lLnZpZGVvU2VnbWVudFN0cmVhbSlcbiAgICAgICAgICAgIC5waXBlKHBpcGVsaW5lLmNvYWxlc2NlU3RyZWFtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdWRpb1RyYWNrICYmICFwaXBlbGluZS5hdWRpb1NlZ21lbnRTdHJlYW0pIHtcbiAgICAgICAgICAvLyBob29rIHVwIHRoZSBhdWRpbyBzZWdtZW50IHN0cmVhbSB0byB0aGUgZmlyc3QgdHJhY2sgd2l0aCBhYWMgZGF0YVxuICAgICAgICAgIHBpcGVsaW5lLmNvYWxlc2NlU3RyZWFtLm51bWJlck9mVHJhY2tzKys7XG4gICAgICAgICAgcGlwZWxpbmUuYXVkaW9TZWdtZW50U3RyZWFtID0gbmV3IEF1ZGlvU2VnbWVudFN0cmVhbShhdWRpb1RyYWNrKTtcblxuICAgICAgICAgIC8vIFNldCB1cCB0aGUgZmluYWwgcGFydCBvZiB0aGUgYXVkaW8gcGlwZWxpbmVcbiAgICAgICAgICBwaXBlbGluZS5hZHRzU3RyZWFtXG4gICAgICAgICAgICAucGlwZShwaXBlbGluZS5hdWRpb1NlZ21lbnRTdHJlYW0pXG4gICAgICAgICAgICAucGlwZShwaXBlbGluZS5jb2FsZXNjZVN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlLWVtaXQgYW55IGRhdGEgY29taW5nIGZyb20gdGhlIGNvYWxlc2NlIHN0cmVhbSB0byB0aGUgb3V0c2lkZSB3b3JsZFxuICAgIHBpcGVsaW5lLmNvYWxlc2NlU3RyZWFtLm9uKCdkYXRhJywgdGhpcy50cmlnZ2VyLmJpbmQodGhpcywgJ2RhdGEnKSk7XG4gICAgLy8gTGV0IHRoZSBjb25zdW1lciBrbm93IHdlIGhhdmUgZmluaXNoZWQgZmx1c2hpbmcgdGhlIGVudGlyZSBwaXBlbGluZVxuICAgIHBpcGVsaW5lLmNvYWxlc2NlU3RyZWFtLm9uKCdkb25lJywgdGhpcy50cmlnZ2VyLmJpbmQodGhpcywgJ2RvbmUnKSk7XG4gIH07XG5cbiAgLy8gaG9vayB1cCB0aGUgc2VnbWVudCBzdHJlYW1zIG9uY2UgdHJhY2sgbWV0YWRhdGEgaXMgZGVsaXZlcmVkXG4gIHRoaXMuc2V0QmFzZU1lZGlhRGVjb2RlVGltZSA9IGZ1bmN0aW9uKGJhc2VNZWRpYURlY29kZVRpbWUpIHtcbiAgICB2YXIgcGlwZWxpbmUgPSB0aGlzLnRyYW5zbXV4UGlwZWxpbmVfO1xuXG4gICAgdGhpcy5iYXNlTWVkaWFEZWNvZGVUaW1lID0gYmFzZU1lZGlhRGVjb2RlVGltZTtcbiAgICBpZiAoYXVkaW9UcmFjaykge1xuICAgICAgYXVkaW9UcmFjay50aW1lbGluZVN0YXJ0SW5mby5kdHMgPSB1bmRlZmluZWQ7XG4gICAgICBhdWRpb1RyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLnB0cyA9IHVuZGVmaW5lZDtcbiAgICAgIGNsZWFyRHRzSW5mbyhhdWRpb1RyYWNrKTtcbiAgICAgIGF1ZGlvVHJhY2sudGltZWxpbmVTdGFydEluZm8uYmFzZU1lZGlhRGVjb2RlVGltZSA9IGJhc2VNZWRpYURlY29kZVRpbWU7XG4gICAgICBpZiAocGlwZWxpbmUuYXVkaW9UaW1lc3RhbXBSb2xsb3ZlclN0cmVhbSkge1xuICAgICAgICBwaXBlbGluZS5hdWRpb1RpbWVzdGFtcFJvbGxvdmVyU3RyZWFtLmRpc2NvbnRpbnVpdHkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZpZGVvVHJhY2spIHtcbiAgICAgIGlmIChwaXBlbGluZS52aWRlb1NlZ21lbnRTdHJlYW0pIHtcbiAgICAgICAgcGlwZWxpbmUudmlkZW9TZWdtZW50U3RyZWFtLmdvcENhY2hlXyA9IFtdO1xuICAgICAgICBwaXBlbGluZS52aWRlb1RpbWVzdGFtcFJvbGxvdmVyU3RyZWFtLmRpc2NvbnRpbnVpdHkoKTtcbiAgICAgIH1cbiAgICAgIHZpZGVvVHJhY2sudGltZWxpbmVTdGFydEluZm8uZHRzID0gdW5kZWZpbmVkO1xuICAgICAgdmlkZW9UcmFjay50aW1lbGluZVN0YXJ0SW5mby5wdHMgPSB1bmRlZmluZWQ7XG4gICAgICBjbGVhckR0c0luZm8odmlkZW9UcmFjayk7XG4gICAgICBwaXBlbGluZS5jYXB0aW9uU3RyZWFtLnJlc2V0KCk7XG4gICAgICB2aWRlb1RyYWNrLnRpbWVsaW5lU3RhcnRJbmZvLmJhc2VNZWRpYURlY29kZVRpbWUgPSBiYXNlTWVkaWFEZWNvZGVUaW1lO1xuICAgIH1cblxuICAgIGlmIChwaXBlbGluZS50aW1lZE1ldGFkYXRhVGltZXN0YW1wUm9sbG92ZXJTdHJlYW0pIHtcbiAgICAgIHBpcGVsaW5lLnRpbWVkTWV0YWRhdGFUaW1lc3RhbXBSb2xsb3ZlclN0cmVhbS5kaXNjb250aW51aXR5KCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuc2V0QXVkaW9BcHBlbmRTdGFydCA9IGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgIGlmIChhdWRpb1RyYWNrKSB7XG4gICAgICB0aGlzLnRyYW5zbXV4UGlwZWxpbmVfLmF1ZGlvU2VnbWVudFN0cmVhbS5zZXRBdWRpb0FwcGVuZFN0YXJ0KHRpbWVzdGFtcCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuYWxpZ25Hb3BzV2l0aCA9IGZ1bmN0aW9uKGdvcHNUb0FsaWduV2l0aCkge1xuICAgIGlmICh2aWRlb1RyYWNrICYmIHRoaXMudHJhbnNtdXhQaXBlbGluZV8udmlkZW9TZWdtZW50U3RyZWFtKSB7XG4gICAgICB0aGlzLnRyYW5zbXV4UGlwZWxpbmVfLnZpZGVvU2VnbWVudFN0cmVhbS5hbGlnbkdvcHNXaXRoKGdvcHNUb0FsaWduV2l0aCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmIChoYXNGbHVzaGVkKSB7XG4gICAgICB2YXIgaXNBYWMgPSBpc0xpa2VseUFhY0RhdGEoZGF0YSk7XG5cbiAgICAgIGlmIChpc0FhYyAmJiB0aGlzLnRyYW5zbXV4UGlwZWxpbmVfLnR5cGUgIT09ICdhYWMnKSB7XG4gICAgICAgIHRoaXMuc2V0dXBBYWNQaXBlbGluZSgpO1xuICAgICAgfSBlbHNlIGlmICghaXNBYWMgJiYgdGhpcy50cmFuc211eFBpcGVsaW5lXy50eXBlICE9PSAndHMnKSB7XG4gICAgICAgIHRoaXMuc2V0dXBUc1BpcGVsaW5lKCk7XG4gICAgICB9XG4gICAgICBoYXNGbHVzaGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMudHJhbnNtdXhQaXBlbGluZV8uaGVhZE9mUGlwZWxpbmUucHVzaChkYXRhKTtcbiAgfTtcblxuICAvLyBmbHVzaCBhbnkgYnVmZmVyZWQgZGF0YVxuICB0aGlzLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBoYXNGbHVzaGVkID0gdHJ1ZTtcbiAgICAvLyBTdGFydCBhdCB0aGUgdG9wIG9mIHRoZSBwaXBlbGluZSBhbmQgZmx1c2ggYWxsIHBlbmRpbmcgd29ya1xuICAgIHRoaXMudHJhbnNtdXhQaXBlbGluZV8uaGVhZE9mUGlwZWxpbmUuZmx1c2goKTtcbiAgfTtcblxuICAvLyBDYXB0aW9uIGRhdGEgaGFzIHRvIGJlIHJlc2V0IHdoZW4gc2Vla2luZyBvdXRzaWRlIGJ1ZmZlcmVkIHJhbmdlXG4gIHRoaXMucmVzZXRDYXB0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnRyYW5zbXV4UGlwZWxpbmVfLmNhcHRpb25TdHJlYW0pIHtcbiAgICAgIHRoaXMudHJhbnNtdXhQaXBlbGluZV8uY2FwdGlvblN0cmVhbS5yZXNldCgpO1xuICAgIH1cbiAgfTtcblxufTtcblRyYW5zbXV4ZXIucHJvdG90eXBlID0gbmV3IFN0cmVhbSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVHJhbnNtdXhlcjogVHJhbnNtdXhlcixcbiAgVmlkZW9TZWdtZW50U3RyZWFtOiBWaWRlb1NlZ21lbnRTdHJlYW0sXG4gIEF1ZGlvU2VnbWVudFN0cmVhbTogQXVkaW9TZWdtZW50U3RyZWFtLFxuICBBVURJT19QUk9QRVJUSUVTOiBBVURJT19QUk9QRVJUSUVTLFxuICBWSURFT19QUk9QRVJUSUVTOiBWSURFT19QUk9QRVJUSUVTXG59O1xuXG59LHtcIi4uL2FhY1wiOjM4LFwiLi4vY29kZWNzL2FkdHMuanNcIjo0MCxcIi4uL2NvZGVjcy9oMjY0XCI6NDEsXCIuLi9kYXRhL3NpbGVuY2VcIjo0MixcIi4uL20ydHMvbTJ0cy5qc1wiOjUwLFwiLi4vdXRpbHMvY2xvY2tcIjo2MCxcIi4uL3V0aWxzL3N0cmVhbS5qc1wiOjYyLFwiLi9tcDQtZ2VuZXJhdG9yLmpzXCI6NTZ9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIG11eC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiBCcmlnaHRjb3ZlXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFBhcnNlIG1wZWcyIHRyYW5zcG9ydCBzdHJlYW0gcGFja2V0cyB0byBleHRyYWN0IGJhc2ljIHRpbWluZyBpbmZvcm1hdGlvblxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTdHJlYW1UeXBlcyA9IHJlcXVpcmUoJy4uL20ydHMvc3RyZWFtLXR5cGVzLmpzJyk7XG52YXIgaGFuZGxlUm9sbG92ZXIgPSByZXF1aXJlKCcuLi9tMnRzL3RpbWVzdGFtcC1yb2xsb3Zlci1zdHJlYW0uanMnKS5oYW5kbGVSb2xsb3ZlcjtcbnZhciBwcm9iZSA9IHt9O1xucHJvYmUudHMgPSByZXF1aXJlKCcuLi9tMnRzL3Byb2JlLmpzJyk7XG5wcm9iZS5hYWMgPSByZXF1aXJlKCcuLi9hYWMvcHJvYmUuanMnKTtcblxuXG52YXJcbiAgUEVTX1RJTUVTQ0FMRSA9IDkwMDAwLFxuICBNUDJUX1BBQ0tFVF9MRU5HVEggPSAxODgsIC8vIGJ5dGVzXG4gIFNZTkNfQllURSA9IDB4NDc7XG5cbnZhciBpc0xpa2VseUFhY0RhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGlmICgoZGF0YVswXSA9PT0gJ0knLmNoYXJDb2RlQXQoMCkpICYmXG4gICAgICAoZGF0YVsxXSA9PT0gJ0QnLmNoYXJDb2RlQXQoMCkpICYmXG4gICAgICAoZGF0YVsyXSA9PT0gJzMnLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiB3YWxrcyB0aHJvdWdoIHNlZ21lbnQgZGF0YSBsb29raW5nIGZvciBwYXQgYW5kIHBtdCBwYWNrZXRzIHRvIHBhcnNlIG91dFxuICogcHJvZ3JhbSBtYXAgdGFibGUgaW5mb3JtYXRpb25cbiAqL1xudmFyIHBhcnNlUHNpXyA9IGZ1bmN0aW9uKGJ5dGVzLCBwbXQpIHtcbiAgdmFyXG4gICAgc3RhcnRJbmRleCA9IDAsXG4gICAgZW5kSW5kZXggPSBNUDJUX1BBQ0tFVF9MRU5HVEgsXG4gICAgcGFja2V0LCB0eXBlO1xuXG4gIHdoaWxlIChlbmRJbmRleCA8IGJ5dGVzLmJ5dGVMZW5ndGgpIHtcbiAgICAvLyBMb29rIGZvciBhIHBhaXIgb2Ygc3RhcnQgYW5kIGVuZCBzeW5jIGJ5dGVzIGluIHRoZSBkYXRhLi5cbiAgICBpZiAoYnl0ZXNbc3RhcnRJbmRleF0gPT09IFNZTkNfQllURSAmJiBieXRlc1tlbmRJbmRleF0gPT09IFNZTkNfQllURSkge1xuICAgICAgLy8gV2UgZm91bmQgYSBwYWNrZXRcbiAgICAgIHBhY2tldCA9IGJ5dGVzLnN1YmFycmF5KHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICAgIHR5cGUgPSBwcm9iZS50cy5wYXJzZVR5cGUocGFja2V0LCBwbXQucGlkKTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3BhdCc6XG4gICAgICAgICAgaWYgKCFwbXQucGlkKSB7XG4gICAgICAgICAgICBwbXQucGlkID0gcHJvYmUudHMucGFyc2VQYXQocGFja2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3BtdCc6XG4gICAgICAgICAgaWYgKCFwbXQudGFibGUpIHtcbiAgICAgICAgICAgIHBtdC50YWJsZSA9IHByb2JlLnRzLnBhcnNlUG10KHBhY2tldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3VuZCB0aGUgcGF0IGFuZCBwbXQsIHdlIGNhbiBzdG9wIHdhbGtpbmcgdGhlIHNlZ21lbnRcbiAgICAgIGlmIChwbXQucGlkICYmIHBtdC50YWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0SW5kZXggKz0gTVAyVF9QQUNLRVRfTEVOR1RIO1xuICAgICAgZW5kSW5kZXggKz0gTVAyVF9QQUNLRVRfTEVOR1RIO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHdlIGhhdmUgc29tZWhvdyBiZWNvbWUgZGUtc3luY2hyb25pemVkIGFuZCB3ZSBuZWVkIHRvIHN0ZXBcbiAgICAvLyBmb3J3YXJkIG9uZSBieXRlIGF0IGEgdGltZSB1bnRpbCB3ZSBmaW5kIGEgcGFpciBvZiBzeW5jIGJ5dGVzIHRoYXQgZGVub3RlXG4gICAgLy8gYSBwYWNrZXRcbiAgICBzdGFydEluZGV4Kys7XG4gICAgZW5kSW5kZXgrKztcbiAgfVxufTtcblxuLyoqXG4gKiB3YWxrcyB0aHJvdWdoIHRoZSBzZWdtZW50IGRhdGEgZnJvbSB0aGUgc3RhcnQgYW5kIGVuZCB0byBnZXQgdGltaW5nIGluZm9ybWF0aW9uXG4gKiBmb3IgdGhlIGZpcnN0IGFuZCBsYXN0IGF1ZGlvIHBlcyBwYWNrZXRzXG4gKi9cbnZhciBwYXJzZUF1ZGlvUGVzXyA9IGZ1bmN0aW9uKGJ5dGVzLCBwbXQsIHJlc3VsdCkge1xuICB2YXJcbiAgICBzdGFydEluZGV4ID0gMCxcbiAgICBlbmRJbmRleCA9IE1QMlRfUEFDS0VUX0xFTkdUSCxcbiAgICBwYWNrZXQsIHR5cGUsIHBlc1R5cGUsIHB1c2ksIHBhcnNlZDtcblxuICB2YXIgZW5kTG9vcCA9IGZhbHNlO1xuXG4gIC8vIFN0YXJ0IHdhbGtpbmcgZnJvbSBzdGFydCBvZiBzZWdtZW50IHRvIGdldCBmaXJzdCBhdWRpbyBwYWNrZXRcbiAgd2hpbGUgKGVuZEluZGV4IDwgYnl0ZXMuYnl0ZUxlbmd0aCkge1xuICAgIC8vIExvb2sgZm9yIGEgcGFpciBvZiBzdGFydCBhbmQgZW5kIHN5bmMgYnl0ZXMgaW4gdGhlIGRhdGEuLlxuICAgIGlmIChieXRlc1tzdGFydEluZGV4XSA9PT0gU1lOQ19CWVRFICYmIGJ5dGVzW2VuZEluZGV4XSA9PT0gU1lOQ19CWVRFKSB7XG4gICAgICAvLyBXZSBmb3VuZCBhIHBhY2tldFxuICAgICAgcGFja2V0ID0gYnl0ZXMuc3ViYXJyYXkoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgdHlwZSA9IHByb2JlLnRzLnBhcnNlVHlwZShwYWNrZXQsIHBtdC5waWQpO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAncGVzJzpcbiAgICAgICAgICBwZXNUeXBlID0gcHJvYmUudHMucGFyc2VQZXNUeXBlKHBhY2tldCwgcG10LnRhYmxlKTtcbiAgICAgICAgICBwdXNpID0gcHJvYmUudHMucGFyc2VQYXlsb2FkVW5pdFN0YXJ0SW5kaWNhdG9yKHBhY2tldCk7XG4gICAgICAgICAgaWYgKHBlc1R5cGUgPT09ICdhdWRpbycgJiYgcHVzaSkge1xuICAgICAgICAgICAgcGFyc2VkID0gcHJvYmUudHMucGFyc2VQZXNUaW1lKHBhY2tldCk7XG4gICAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICAgIHBhcnNlZC50eXBlID0gJ2F1ZGlvJztcbiAgICAgICAgICAgICAgcmVzdWx0LmF1ZGlvLnB1c2gocGFyc2VkKTtcbiAgICAgICAgICAgICAgZW5kTG9vcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kTG9vcCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc3RhcnRJbmRleCArPSBNUDJUX1BBQ0tFVF9MRU5HVEg7XG4gICAgICBlbmRJbmRleCArPSBNUDJUX1BBQ0tFVF9MRU5HVEg7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgd2UgaGF2ZSBzb21laG93IGJlY29tZSBkZS1zeW5jaHJvbml6ZWQgYW5kIHdlIG5lZWQgdG8gc3RlcFxuICAgIC8vIGZvcndhcmQgb25lIGJ5dGUgYXQgYSB0aW1lIHVudGlsIHdlIGZpbmQgYSBwYWlyIG9mIHN5bmMgYnl0ZXMgdGhhdCBkZW5vdGVcbiAgICAvLyBhIHBhY2tldFxuICAgIHN0YXJ0SW5kZXgrKztcbiAgICBlbmRJbmRleCsrO1xuICB9XG5cbiAgLy8gU3RhcnQgd2Fsa2luZyBmcm9tIGVuZCBvZiBzZWdtZW50IHRvIGdldCBsYXN0IGF1ZGlvIHBhY2tldFxuICBlbmRJbmRleCA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gIHN0YXJ0SW5kZXggPSBlbmRJbmRleCAtIE1QMlRfUEFDS0VUX0xFTkdUSDtcbiAgZW5kTG9vcCA9IGZhbHNlO1xuICB3aGlsZSAoc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgLy8gTG9vayBmb3IgYSBwYWlyIG9mIHN0YXJ0IGFuZCBlbmQgc3luYyBieXRlcyBpbiB0aGUgZGF0YS4uXG4gICAgaWYgKGJ5dGVzW3N0YXJ0SW5kZXhdID09PSBTWU5DX0JZVEUgJiYgYnl0ZXNbZW5kSW5kZXhdID09PSBTWU5DX0JZVEUpIHtcbiAgICAgIC8vIFdlIGZvdW5kIGEgcGFja2V0XG4gICAgICBwYWNrZXQgPSBieXRlcy5zdWJhcnJheShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICB0eXBlID0gcHJvYmUudHMucGFyc2VUeXBlKHBhY2tldCwgcG10LnBpZCk7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdwZXMnOlxuICAgICAgICAgIHBlc1R5cGUgPSBwcm9iZS50cy5wYXJzZVBlc1R5cGUocGFja2V0LCBwbXQudGFibGUpO1xuICAgICAgICAgIHB1c2kgPSBwcm9iZS50cy5wYXJzZVBheWxvYWRVbml0U3RhcnRJbmRpY2F0b3IocGFja2V0KTtcbiAgICAgICAgICBpZiAocGVzVHlwZSA9PT0gJ2F1ZGlvJyAmJiBwdXNpKSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBwcm9iZS50cy5wYXJzZVBlc1RpbWUocGFja2V0KTtcbiAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgcGFyc2VkLnR5cGUgPSAnYXVkaW8nO1xuICAgICAgICAgICAgICByZXN1bHQuYXVkaW8ucHVzaChwYXJzZWQpO1xuICAgICAgICAgICAgICBlbmRMb29wID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRMb29wKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzdGFydEluZGV4IC09IE1QMlRfUEFDS0VUX0xFTkdUSDtcbiAgICAgIGVuZEluZGV4IC09IE1QMlRfUEFDS0VUX0xFTkdUSDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIHNvbWVob3cgYmVjb21lIGRlLXN5bmNocm9uaXplZCBhbmQgd2UgbmVlZCB0byBzdGVwXG4gICAgLy8gZm9yd2FyZCBvbmUgYnl0ZSBhdCBhIHRpbWUgdW50aWwgd2UgZmluZCBhIHBhaXIgb2Ygc3luYyBieXRlcyB0aGF0IGRlbm90ZVxuICAgIC8vIGEgcGFja2V0XG4gICAgc3RhcnRJbmRleC0tO1xuICAgIGVuZEluZGV4LS07XG4gIH1cbn07XG5cbi8qKlxuICogd2Fsa3MgdGhyb3VnaCB0aGUgc2VnbWVudCBkYXRhIGZyb20gdGhlIHN0YXJ0IGFuZCBlbmQgdG8gZ2V0IHRpbWluZyBpbmZvcm1hdGlvblxuICogZm9yIHRoZSBmaXJzdCBhbmQgbGFzdCB2aWRlbyBwZXMgcGFja2V0cyBhcyB3ZWxsIGFzIHRpbWluZyBpbmZvcm1hdGlvbiBmb3IgdGhlIGZpcnN0XG4gKiBrZXkgZnJhbWUuXG4gKi9cbnZhciBwYXJzZVZpZGVvUGVzXyA9IGZ1bmN0aW9uKGJ5dGVzLCBwbXQsIHJlc3VsdCkge1xuICB2YXJcbiAgICBzdGFydEluZGV4ID0gMCxcbiAgICBlbmRJbmRleCA9IE1QMlRfUEFDS0VUX0xFTkdUSCxcbiAgICBwYWNrZXQsIHR5cGUsIHBlc1R5cGUsIHB1c2ksIHBhcnNlZCwgZnJhbWUsIGksIHBlcztcblxuICB2YXIgZW5kTG9vcCA9IGZhbHNlO1xuXG4gIHZhciBjdXJyZW50RnJhbWUgPSB7XG4gICAgZGF0YTogW10sXG4gICAgc2l6ZTogMFxuICB9O1xuXG4gIC8vIFN0YXJ0IHdhbGtpbmcgZnJvbSBzdGFydCBvZiBzZWdtZW50IHRvIGdldCBmaXJzdCB2aWRlbyBwYWNrZXRcbiAgd2hpbGUgKGVuZEluZGV4IDwgYnl0ZXMuYnl0ZUxlbmd0aCkge1xuICAgIC8vIExvb2sgZm9yIGEgcGFpciBvZiBzdGFydCBhbmQgZW5kIHN5bmMgYnl0ZXMgaW4gdGhlIGRhdGEuLlxuICAgIGlmIChieXRlc1tzdGFydEluZGV4XSA9PT0gU1lOQ19CWVRFICYmIGJ5dGVzW2VuZEluZGV4XSA9PT0gU1lOQ19CWVRFKSB7XG4gICAgICAvLyBXZSBmb3VuZCBhIHBhY2tldFxuICAgICAgcGFja2V0ID0gYnl0ZXMuc3ViYXJyYXkoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgdHlwZSA9IHByb2JlLnRzLnBhcnNlVHlwZShwYWNrZXQsIHBtdC5waWQpO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAncGVzJzpcbiAgICAgICAgICBwZXNUeXBlID0gcHJvYmUudHMucGFyc2VQZXNUeXBlKHBhY2tldCwgcG10LnRhYmxlKTtcbiAgICAgICAgICBwdXNpID0gcHJvYmUudHMucGFyc2VQYXlsb2FkVW5pdFN0YXJ0SW5kaWNhdG9yKHBhY2tldCk7XG4gICAgICAgICAgaWYgKHBlc1R5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIGlmIChwdXNpICYmICFlbmRMb29wKSB7XG4gICAgICAgICAgICAgIHBhcnNlZCA9IHByb2JlLnRzLnBhcnNlUGVzVGltZShwYWNrZXQpO1xuICAgICAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnR5cGUgPSAndmlkZW8nO1xuICAgICAgICAgICAgICAgIHJlc3VsdC52aWRlby5wdXNoKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgZW5kTG9vcCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzdWx0LmZpcnN0S2V5RnJhbWUpIHtcbiAgICAgICAgICAgICAgaWYgKHB1c2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZyYW1lLnNpemUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGZyYW1lID0gbmV3IFVpbnQ4QXJyYXkoY3VycmVudEZyYW1lLnNpemUpO1xuICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudEZyYW1lLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcyA9IGN1cnJlbnRGcmFtZS5kYXRhLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLnNldChwZXMsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IHBlcy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHByb2JlLnRzLnZpZGVvUGFja2V0Q29udGFpbnNLZXlGcmFtZShmcmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZpcnN0S2V5RnJhbWUgPSBwcm9iZS50cy5wYXJzZVBlc1RpbWUoZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZmlyc3RLZXlGcmFtZS50eXBlID0gJ3ZpZGVvJztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZS5zaXplID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudEZyYW1lLmRhdGEucHVzaChwYWNrZXQpO1xuICAgICAgICAgICAgICBjdXJyZW50RnJhbWUuc2l6ZSArPSBwYWNrZXQuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRMb29wICYmIHJlc3VsdC5maXJzdEtleUZyYW1lKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzdGFydEluZGV4ICs9IE1QMlRfUEFDS0VUX0xFTkdUSDtcbiAgICAgIGVuZEluZGV4ICs9IE1QMlRfUEFDS0VUX0xFTkdUSDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIHNvbWVob3cgYmVjb21lIGRlLXN5bmNocm9uaXplZCBhbmQgd2UgbmVlZCB0byBzdGVwXG4gICAgLy8gZm9yd2FyZCBvbmUgYnl0ZSBhdCBhIHRpbWUgdW50aWwgd2UgZmluZCBhIHBhaXIgb2Ygc3luYyBieXRlcyB0aGF0IGRlbm90ZVxuICAgIC8vIGEgcGFja2V0XG4gICAgc3RhcnRJbmRleCsrO1xuICAgIGVuZEluZGV4Kys7XG4gIH1cblxuICAvLyBTdGFydCB3YWxraW5nIGZyb20gZW5kIG9mIHNlZ21lbnQgdG8gZ2V0IGxhc3QgdmlkZW8gcGFja2V0XG4gIGVuZEluZGV4ID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgc3RhcnRJbmRleCA9IGVuZEluZGV4IC0gTVAyVF9QQUNLRVRfTEVOR1RIO1xuICBlbmRMb29wID0gZmFsc2U7XG4gIHdoaWxlIChzdGFydEluZGV4ID49IDApIHtcbiAgICAvLyBMb29rIGZvciBhIHBhaXIgb2Ygc3RhcnQgYW5kIGVuZCBzeW5jIGJ5dGVzIGluIHRoZSBkYXRhLi5cbiAgICBpZiAoYnl0ZXNbc3RhcnRJbmRleF0gPT09IFNZTkNfQllURSAmJiBieXRlc1tlbmRJbmRleF0gPT09IFNZTkNfQllURSkge1xuICAgICAgLy8gV2UgZm91bmQgYSBwYWNrZXRcbiAgICAgIHBhY2tldCA9IGJ5dGVzLnN1YmFycmF5KHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICAgIHR5cGUgPSBwcm9iZS50cy5wYXJzZVR5cGUocGFja2V0LCBwbXQucGlkKTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3Blcyc6XG4gICAgICAgICAgcGVzVHlwZSA9IHByb2JlLnRzLnBhcnNlUGVzVHlwZShwYWNrZXQsIHBtdC50YWJsZSk7XG4gICAgICAgICAgcHVzaSA9IHByb2JlLnRzLnBhcnNlUGF5bG9hZFVuaXRTdGFydEluZGljYXRvcihwYWNrZXQpO1xuICAgICAgICAgIGlmIChwZXNUeXBlID09PSAndmlkZW8nICYmIHB1c2kpIHtcbiAgICAgICAgICAgICAgcGFyc2VkID0gcHJvYmUudHMucGFyc2VQZXNUaW1lKHBhY2tldCk7XG4gICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQudHlwZSA9ICd2aWRlbyc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpZGVvLnB1c2gocGFyc2VkKTtcbiAgICAgICAgICAgICAgICBlbmRMb29wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZExvb3ApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0SW5kZXggLT0gTVAyVF9QQUNLRVRfTEVOR1RIO1xuICAgICAgZW5kSW5kZXggLT0gTVAyVF9QQUNLRVRfTEVOR1RIO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHdlIGhhdmUgc29tZWhvdyBiZWNvbWUgZGUtc3luY2hyb25pemVkIGFuZCB3ZSBuZWVkIHRvIHN0ZXBcbiAgICAvLyBmb3J3YXJkIG9uZSBieXRlIGF0IGEgdGltZSB1bnRpbCB3ZSBmaW5kIGEgcGFpciBvZiBzeW5jIGJ5dGVzIHRoYXQgZGVub3RlXG4gICAgLy8gYSBwYWNrZXRcbiAgICBzdGFydEluZGV4LS07XG4gICAgZW5kSW5kZXgtLTtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGp1c3RzIHRoZSB0aW1lc3RhbXAgaW5mb3JtYXRpb24gZm9yIHRoZSBzZWdtZW50IHRvIGFjY291bnQgZm9yXG4gKiByb2xsb3ZlciBhbmQgY29udmVydCB0byBzZWNvbmRzIGJhc2VkIG9uIHBlcyBwYWNrZXQgdGltZXNjYWxlICg5MGtoeiBjbG9jaylcbiAqL1xudmFyIGFkanVzdFRpbWVzdGFtcF8gPSBmdW5jdGlvbihzZWdtZW50SW5mbywgYmFzZVRpbWVzdGFtcCkge1xuICBpZiAoc2VnbWVudEluZm8uYXVkaW8gJiYgc2VnbWVudEluZm8uYXVkaW8ubGVuZ3RoKSB7XG4gICAgdmFyIGF1ZGlvQmFzZVRpbWVzdGFtcCA9IGJhc2VUaW1lc3RhbXA7XG4gICAgaWYgKHR5cGVvZiBhdWRpb0Jhc2VUaW1lc3RhbXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBhdWRpb0Jhc2VUaW1lc3RhbXAgPSBzZWdtZW50SW5mby5hdWRpb1swXS5kdHM7XG4gICAgfVxuICAgIHNlZ21lbnRJbmZvLmF1ZGlvLmZvckVhY2goZnVuY3Rpb24oaW5mbykge1xuICAgICAgaW5mby5kdHMgPSBoYW5kbGVSb2xsb3ZlcihpbmZvLmR0cywgYXVkaW9CYXNlVGltZXN0YW1wKTtcbiAgICAgIGluZm8ucHRzID0gaGFuZGxlUm9sbG92ZXIoaW5mby5wdHMsIGF1ZGlvQmFzZVRpbWVzdGFtcCk7XG4gICAgICAvLyB0aW1lIGluIHNlY29uZHNcbiAgICAgIGluZm8uZHRzVGltZSA9IGluZm8uZHRzIC8gUEVTX1RJTUVTQ0FMRTtcbiAgICAgIGluZm8ucHRzVGltZSA9IGluZm8ucHRzIC8gUEVTX1RJTUVTQ0FMRTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzZWdtZW50SW5mby52aWRlbyAmJiBzZWdtZW50SW5mby52aWRlby5sZW5ndGgpIHtcbiAgICB2YXIgdmlkZW9CYXNlVGltZXN0YW1wID0gYmFzZVRpbWVzdGFtcDtcbiAgICBpZiAodHlwZW9mIHZpZGVvQmFzZVRpbWVzdGFtcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZpZGVvQmFzZVRpbWVzdGFtcCA9IHNlZ21lbnRJbmZvLnZpZGVvWzBdLmR0cztcbiAgICB9XG4gICAgc2VnbWVudEluZm8udmlkZW8uZm9yRWFjaChmdW5jdGlvbihpbmZvKSB7XG4gICAgICBpbmZvLmR0cyA9IGhhbmRsZVJvbGxvdmVyKGluZm8uZHRzLCB2aWRlb0Jhc2VUaW1lc3RhbXApO1xuICAgICAgaW5mby5wdHMgPSBoYW5kbGVSb2xsb3ZlcihpbmZvLnB0cywgdmlkZW9CYXNlVGltZXN0YW1wKTtcbiAgICAgIC8vIHRpbWUgaW4gc2Vjb25kc1xuICAgICAgaW5mby5kdHNUaW1lID0gaW5mby5kdHMgLyBQRVNfVElNRVNDQUxFO1xuICAgICAgaW5mby5wdHNUaW1lID0gaW5mby5wdHMgLyBQRVNfVElNRVNDQUxFO1xuICAgIH0pO1xuICAgIGlmIChzZWdtZW50SW5mby5maXJzdEtleUZyYW1lKSB7XG4gICAgICB2YXIgZnJhbWUgPSBzZWdtZW50SW5mby5maXJzdEtleUZyYW1lO1xuICAgICAgZnJhbWUuZHRzID0gaGFuZGxlUm9sbG92ZXIoZnJhbWUuZHRzLCB2aWRlb0Jhc2VUaW1lc3RhbXApO1xuICAgICAgZnJhbWUucHRzID0gaGFuZGxlUm9sbG92ZXIoZnJhbWUucHRzLCB2aWRlb0Jhc2VUaW1lc3RhbXApO1xuICAgICAgLy8gdGltZSBpbiBzZWNvbmRzXG4gICAgICBmcmFtZS5kdHNUaW1lID0gZnJhbWUuZHRzIC8gUEVTX1RJTUVTQ0FMRTtcbiAgICAgIGZyYW1lLnB0c1RpbWUgPSBmcmFtZS5kdHMgLyBQRVNfVElNRVNDQUxFO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBpbnNwZWN0cyB0aGUgYWFjIGRhdGEgc3RyZWFtIGZvciBzdGFydCBhbmQgZW5kIHRpbWUgaW5mb3JtYXRpb25cbiAqL1xudmFyIGluc3BlY3RBYWNfID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgdmFyXG4gICAgZW5kTG9vcCA9IGZhbHNlLFxuICAgIGF1ZGlvQ291bnQgPSAwLFxuICAgIHNhbXBsZVJhdGUgPSBudWxsLFxuICAgIHRpbWVzdGFtcCA9IG51bGwsXG4gICAgZnJhbWVTaXplID0gMCxcbiAgICBieXRlSW5kZXggPSAwLFxuICAgIHBhY2tldDtcblxuICB3aGlsZSAoYnl0ZXMubGVuZ3RoIC0gYnl0ZUluZGV4ID49IDMpIHtcbiAgICB2YXIgdHlwZSA9IHByb2JlLmFhYy5wYXJzZVR5cGUoYnl0ZXMsIGJ5dGVJbmRleCk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICd0aW1lZC1tZXRhZGF0YSc6XG4gICAgICAgIC8vIEV4aXQgZWFybHkgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGVub3VnaCB0byBwYXJzZVxuICAgICAgICAvLyB0aGUgSUQzIHRhZyBoZWFkZXJcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAtIGJ5dGVJbmRleCA8IDEwKSB7XG4gICAgICAgICAgZW5kTG9vcCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFtZVNpemUgPSBwcm9iZS5hYWMucGFyc2VJZDNUYWdTaXplKGJ5dGVzLCBieXRlSW5kZXgpO1xuXG4gICAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggaW4gdGhlIGJ1ZmZlclxuICAgICAgICAvLyB0byBlbWl0IGEgZnVsbCBwYWNrZXRcbiAgICAgICAgaWYgKGZyYW1lU2l6ZSA+IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgIGVuZExvb3AgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lc3RhbXAgPT09IG51bGwpIHtcbiAgICAgICAgICBwYWNrZXQgPSBieXRlcy5zdWJhcnJheShieXRlSW5kZXgsIGJ5dGVJbmRleCArIGZyYW1lU2l6ZSk7XG4gICAgICAgICAgdGltZXN0YW1wID0gcHJvYmUuYWFjLnBhcnNlQWFjVGltZXN0YW1wKHBhY2tldCk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZUluZGV4ICs9IGZyYW1lU2l6ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgIC8vIEV4aXQgZWFybHkgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGVub3VnaCB0byBwYXJzZVxuICAgICAgICAvLyB0aGUgQURUUyBmcmFtZSBoZWFkZXJcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAtIGJ5dGVJbmRleCA8IDcpIHtcbiAgICAgICAgICBlbmRMb29wID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYW1lU2l6ZSA9IHByb2JlLmFhYy5wYXJzZUFkdHNTaXplKGJ5dGVzLCBieXRlSW5kZXgpO1xuXG4gICAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggaW4gdGhlIGJ1ZmZlclxuICAgICAgICAvLyB0byBlbWl0IGEgZnVsbCBwYWNrZXRcbiAgICAgICAgaWYgKGZyYW1lU2l6ZSA+IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgIGVuZExvb3AgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzYW1wbGVSYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgcGFja2V0ID0gYnl0ZXMuc3ViYXJyYXkoYnl0ZUluZGV4LCBieXRlSW5kZXggKyBmcmFtZVNpemUpO1xuICAgICAgICAgIHNhbXBsZVJhdGUgPSBwcm9iZS5hYWMucGFyc2VTYW1wbGVSYXRlKHBhY2tldCk7XG4gICAgICAgIH1cbiAgICAgICAgYXVkaW9Db3VudCsrO1xuICAgICAgICBieXRlSW5kZXggKz0gZnJhbWVTaXplO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJ5dGVJbmRleCsrO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGVuZExvb3ApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAoc2FtcGxlUmF0ZSA9PT0gbnVsbCB8fCB0aW1lc3RhbXAgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhdWRpb1RpbWVzY2FsZSA9IFBFU19USU1FU0NBTEUgLyBzYW1wbGVSYXRlO1xuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgYXVkaW86IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgZHRzOiB0aW1lc3RhbXAsXG4gICAgICAgIHB0czogdGltZXN0YW1wXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICBkdHM6IHRpbWVzdGFtcCArIChhdWRpb0NvdW50ICogMTAyNCAqIGF1ZGlvVGltZXNjYWxlKSxcbiAgICAgICAgcHRzOiB0aW1lc3RhbXAgKyAoYXVkaW9Db3VudCAqIDEwMjQgKiBhdWRpb1RpbWVzY2FsZSlcbiAgICAgIH1cbiAgICBdXG4gIH07XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogaW5zcGVjdHMgdGhlIHRyYW5zcG9ydCBzdHJlYW0gc2VnbWVudCBkYXRhIGZvciBzdGFydCBhbmQgZW5kIHRpbWUgaW5mb3JtYXRpb25cbiAqIG9mIHRoZSBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzICh3aGVuIHByZXNlbnQpIGFzIHdlbGwgYXMgdGhlIGZpcnN0IGtleSBmcmFtZSdzXG4gKiBzdGFydCB0aW1lLlxuICovXG52YXIgaW5zcGVjdFRzXyA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHZhciBwbXQgPSB7XG4gICAgcGlkOiBudWxsLFxuICAgIHRhYmxlOiBudWxsXG4gIH07XG5cbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIHBhcnNlUHNpXyhieXRlcywgcG10KTtcblxuICBmb3IgKHZhciBwaWQgaW4gcG10LnRhYmxlKSB7XG4gICAgaWYgKHBtdC50YWJsZS5oYXNPd25Qcm9wZXJ0eShwaWQpKSB7XG4gICAgICB2YXIgdHlwZSA9IHBtdC50YWJsZVtwaWRdO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgU3RyZWFtVHlwZXMuSDI2NF9TVFJFQU1fVFlQRTpcbiAgICAgICAgICByZXN1bHQudmlkZW8gPSBbXTtcbiAgICAgICAgICBwYXJzZVZpZGVvUGVzXyhieXRlcywgcG10LCByZXN1bHQpO1xuICAgICAgICAgIGlmIChyZXN1bHQudmlkZW8ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgcmVzdWx0LnZpZGVvO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTdHJlYW1UeXBlcy5BRFRTX1NUUkVBTV9UWVBFOlxuICAgICAgICAgIHJlc3VsdC5hdWRpbyA9IFtdO1xuICAgICAgICAgIHBhcnNlQXVkaW9QZXNfKGJ5dGVzLCBwbXQsIHJlc3VsdCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5hdWRpby5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXN1bHQuYXVkaW87XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBJbnNwZWN0cyBzZWdtZW50IGJ5dGUgZGF0YSBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBzdGFydCBhbmQgZW5kIHRpbWluZyBpbmZvcm1hdGlvblxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXMgVGhlIHNlZ21lbnQgYnl0ZSBkYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gYmFzZVRpbWVzdGFtcCBSZWxhdGl2ZSByZWZlcmVuY2UgdGltZXN0YW1wIHVzZWQgd2hlbiBhZGp1c3RpbmcgZnJhbWVcbiAqICB0aW1lc3RhbXBzIGZvciByb2xsb3Zlci4gVGhpcyB2YWx1ZSBtdXN0IGJlIGluIDkwa2h6IGNsb2NrLlxuICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyBzdGFydCBhbmQgZW5kIGZyYW1lIHRpbWluZyBpbmZvIG9mIHNlZ21lbnQuXG4gKi9cbnZhciBpbnNwZWN0ID0gZnVuY3Rpb24oYnl0ZXMsIGJhc2VUaW1lc3RhbXApIHtcbiAgdmFyIGlzQWFjRGF0YSA9IGlzTGlrZWx5QWFjRGF0YShieXRlcyk7XG5cbiAgdmFyIHJlc3VsdDtcblxuICBpZiAoaXNBYWNEYXRhKSB7XG4gICAgcmVzdWx0ID0gaW5zcGVjdEFhY18oYnl0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGluc3BlY3RUc18oYnl0ZXMpO1xuICB9XG5cbiAgaWYgKCFyZXN1bHQgfHwgKCFyZXN1bHQuYXVkaW8gJiYgIXJlc3VsdC52aWRlbykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGFkanVzdFRpbWVzdGFtcF8ocmVzdWx0LCBiYXNlVGltZXN0YW1wKTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluc3BlY3Q6IGluc3BlY3Rcbn07XG5cbn0se1wiLi4vYWFjL3Byb2JlLmpzXCI6MzksXCIuLi9tMnRzL3Byb2JlLmpzXCI6NTIsXCIuLi9tMnRzL3N0cmVhbS10eXBlcy5qc1wiOjUzLFwiLi4vbTJ0cy90aW1lc3RhbXAtcm9sbG92ZXItc3RyZWFtLmpzXCI6NTR9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXJcbiAgT05FX1NFQ09ORF9JTl9UUyA9IDkwMDAwLCAvLyA5MGtIeiBjbG9ja1xuICBzZWNvbmRzVG9WaWRlb1RzLFxuICBzZWNvbmRzVG9BdWRpb1RzLFxuICB2aWRlb1RzVG9TZWNvbmRzLFxuICBhdWRpb1RzVG9TZWNvbmRzLFxuICBhdWRpb1RzVG9WaWRlb1RzLFxuICB2aWRlb1RzVG9BdWRpb1RzO1xuXG5zZWNvbmRzVG9WaWRlb1RzID0gZnVuY3Rpb24oc2Vjb25kcykge1xuICByZXR1cm4gc2Vjb25kcyAqIE9ORV9TRUNPTkRfSU5fVFM7XG59O1xuXG5zZWNvbmRzVG9BdWRpb1RzID0gZnVuY3Rpb24oc2Vjb25kcywgc2FtcGxlUmF0ZSkge1xuICByZXR1cm4gc2Vjb25kcyAqIHNhbXBsZVJhdGU7XG59O1xuXG52aWRlb1RzVG9TZWNvbmRzID0gZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gIHJldHVybiB0aW1lc3RhbXAgLyBPTkVfU0VDT05EX0lOX1RTO1xufTtcblxuYXVkaW9Uc1RvU2Vjb25kcyA9IGZ1bmN0aW9uKHRpbWVzdGFtcCwgc2FtcGxlUmF0ZSkge1xuICByZXR1cm4gdGltZXN0YW1wIC8gc2FtcGxlUmF0ZTtcbn07XG5cbmF1ZGlvVHNUb1ZpZGVvVHMgPSBmdW5jdGlvbih0aW1lc3RhbXAsIHNhbXBsZVJhdGUpIHtcbiAgcmV0dXJuIHNlY29uZHNUb1ZpZGVvVHMoYXVkaW9Uc1RvU2Vjb25kcyh0aW1lc3RhbXAsIHNhbXBsZVJhdGUpKTtcbn07XG5cbnZpZGVvVHNUb0F1ZGlvVHMgPSBmdW5jdGlvbih0aW1lc3RhbXAsIHNhbXBsZVJhdGUpIHtcbiAgcmV0dXJuIHNlY29uZHNUb0F1ZGlvVHModmlkZW9Uc1RvU2Vjb25kcyh0aW1lc3RhbXApLCBzYW1wbGVSYXRlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZWNvbmRzVG9WaWRlb1RzOiBzZWNvbmRzVG9WaWRlb1RzLFxuICBzZWNvbmRzVG9BdWRpb1RzOiBzZWNvbmRzVG9BdWRpb1RzLFxuICB2aWRlb1RzVG9TZWNvbmRzOiB2aWRlb1RzVG9TZWNvbmRzLFxuICBhdWRpb1RzVG9TZWNvbmRzOiBhdWRpb1RzVG9TZWNvbmRzLFxuICBhdWRpb1RzVG9WaWRlb1RzOiBhdWRpb1RzVG9WaWRlb1RzLFxuICB2aWRlb1RzVG9BdWRpb1RzOiB2aWRlb1RzVG9BdWRpb1RzXG59O1xuXG59LHt9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeHBHb2xvbWI7XG5cbi8qKlxuICogUGFyc2VyIGZvciBleHBvbmVudGlhbCBHb2xvbWIgY29kZXMsIGEgdmFyaWFibGUtYml0d2lkdGggbnVtYmVyIGVuY29kaW5nXG4gKiBzY2hlbWUgdXNlZCBieSBoMjY0LlxuICovXG5FeHBHb2xvbWIgPSBmdW5jdGlvbih3b3JraW5nRGF0YSkge1xuICB2YXJcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGxlZnQgdG8gZXhhbWluZSBpbiB3b3JraW5nRGF0YVxuICAgIHdvcmtpbmdCeXRlc0F2YWlsYWJsZSA9IHdvcmtpbmdEYXRhLmJ5dGVMZW5ndGgsXG5cbiAgICAvLyB0aGUgY3VycmVudCB3b3JkIGJlaW5nIGV4YW1pbmVkXG4gICAgd29ya2luZ1dvcmQgPSAwLCAvLyA6dWludFxuXG4gICAgLy8gdGhlIG51bWJlciBvZiBiaXRzIGxlZnQgdG8gZXhhbWluZSBpbiB0aGUgY3VycmVudCB3b3JkXG4gICAgd29ya2luZ0JpdHNBdmFpbGFibGUgPSAwOyAvLyA6dWludDtcblxuICAvLyAoKTp1aW50XG4gIHRoaXMubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICg4ICogd29ya2luZ0J5dGVzQXZhaWxhYmxlKTtcbiAgfTtcblxuICAvLyAoKTp1aW50XG4gIHRoaXMuYml0c0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoOCAqIHdvcmtpbmdCeXRlc0F2YWlsYWJsZSkgKyB3b3JraW5nQml0c0F2YWlsYWJsZTtcbiAgfTtcblxuICAvLyAoKTp2b2lkXG4gIHRoaXMubG9hZFdvcmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXJcbiAgICAgIHBvc2l0aW9uID0gd29ya2luZ0RhdGEuYnl0ZUxlbmd0aCAtIHdvcmtpbmdCeXRlc0F2YWlsYWJsZSxcbiAgICAgIHdvcmtpbmdCeXRlcyA9IG5ldyBVaW50OEFycmF5KDQpLFxuICAgICAgYXZhaWxhYmxlQnl0ZXMgPSBNYXRoLm1pbig0LCB3b3JraW5nQnl0ZXNBdmFpbGFibGUpO1xuXG4gICAgaWYgKGF2YWlsYWJsZUJ5dGVzID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJ5dGVzIGF2YWlsYWJsZScpO1xuICAgIH1cblxuICAgIHdvcmtpbmdCeXRlcy5zZXQod29ya2luZ0RhdGEuc3ViYXJyYXkocG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArIGF2YWlsYWJsZUJ5dGVzKSk7XG4gICAgd29ya2luZ1dvcmQgPSBuZXcgRGF0YVZpZXcod29ya2luZ0J5dGVzLmJ1ZmZlcikuZ2V0VWludDMyKDApO1xuXG4gICAgLy8gdHJhY2sgdGhlIGFtb3VudCBvZiB3b3JraW5nRGF0YSB0aGF0IGhhcyBiZWVuIHByb2Nlc3NlZFxuICAgIHdvcmtpbmdCaXRzQXZhaWxhYmxlID0gYXZhaWxhYmxlQnl0ZXMgKiA4O1xuICAgIHdvcmtpbmdCeXRlc0F2YWlsYWJsZSAtPSBhdmFpbGFibGVCeXRlcztcbiAgfTtcblxuICAvLyAoY291bnQ6aW50KTp2b2lkXG4gIHRoaXMuc2tpcEJpdHMgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBza2lwQnl0ZXM7IC8vIDppbnRcbiAgICBpZiAod29ya2luZ0JpdHNBdmFpbGFibGUgPiBjb3VudCkge1xuICAgICAgd29ya2luZ1dvcmQgICAgICAgICAgPDw9IGNvdW50O1xuICAgICAgd29ya2luZ0JpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50IC09IHdvcmtpbmdCaXRzQXZhaWxhYmxlO1xuICAgICAgc2tpcEJ5dGVzID0gTWF0aC5mbG9vcihjb3VudCAvIDgpO1xuXG4gICAgICBjb3VudCAtPSAoc2tpcEJ5dGVzICogOCk7XG4gICAgICB3b3JraW5nQnl0ZXNBdmFpbGFibGUgLT0gc2tpcEJ5dGVzO1xuXG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG5cbiAgICAgIHdvcmtpbmdXb3JkIDw8PSBjb3VudDtcbiAgICAgIHdvcmtpbmdCaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgIH1cbiAgfTtcblxuICAvLyAoc2l6ZTppbnQpOnVpbnRcbiAgdGhpcy5yZWFkQml0cyA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB2YXJcbiAgICAgIGJpdHMgPSBNYXRoLm1pbih3b3JraW5nQml0c0F2YWlsYWJsZSwgc2l6ZSksIC8vIDp1aW50XG4gICAgICB2YWx1ID0gd29ya2luZ1dvcmQgPj4+ICgzMiAtIGJpdHMpOyAvLyA6dWludFxuICAgIC8vIGlmIHNpemUgPiAzMSwgaGFuZGxlIGVycm9yXG4gICAgd29ya2luZ0JpdHNBdmFpbGFibGUgLT0gYml0cztcbiAgICBpZiAod29ya2luZ0JpdHNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB3b3JraW5nV29yZCA8PD0gYml0cztcbiAgICB9IGVsc2UgaWYgKHdvcmtpbmdCeXRlc0F2YWlsYWJsZSA+IDApIHtcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICB9XG5cbiAgICBiaXRzID0gc2l6ZSAtIGJpdHM7XG4gICAgaWYgKGJpdHMgPiAwKSB7XG4gICAgICByZXR1cm4gdmFsdSA8PCBiaXRzIHwgdGhpcy5yZWFkQml0cyhiaXRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHU7XG4gIH07XG5cbiAgLy8gKCk6dWludFxuICB0aGlzLnNraXBMZWFkaW5nWmVyb3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVhZGluZ1plcm9Db3VudDsgLy8gOnVpbnRcbiAgICBmb3IgKGxlYWRpbmdaZXJvQ291bnQgPSAwOyBsZWFkaW5nWmVyb0NvdW50IDwgd29ya2luZ0JpdHNBdmFpbGFibGU7ICsrbGVhZGluZ1plcm9Db3VudCkge1xuICAgICAgaWYgKCh3b3JraW5nV29yZCAmICgweDgwMDAwMDAwID4+PiBsZWFkaW5nWmVyb0NvdW50KSkgIT09IDApIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IGJpdCBvZiB3b3JraW5nIHdvcmQgaXMgMVxuICAgICAgICB3b3JraW5nV29yZCA8PD0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgd29ya2luZ0JpdHNBdmFpbGFibGUgLT0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gd2UgZXhoYXVzdGVkIHdvcmtpbmdXb3JkIGFuZCBzdGlsbCBoYXZlIG5vdCBmb3VuZCBhIDFcbiAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQgKyB0aGlzLnNraXBMZWFkaW5nWmVyb3MoKTtcbiAgfTtcblxuICAvLyAoKTp2b2lkXG4gIHRoaXMuc2tpcFVuc2lnbmVkRXhwR29sb21iID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTGVhZGluZ1plcm9zKCkpO1xuICB9O1xuXG4gIC8vICgpOnZvaWRcbiAgdGhpcy5za2lwRXhwR29sb21iID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTGVhZGluZ1plcm9zKCkpO1xuICB9O1xuXG4gIC8vICgpOnVpbnRcbiAgdGhpcy5yZWFkVW5zaWduZWRFeHBHb2xvbWIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2x6ID0gdGhpcy5za2lwTGVhZGluZ1plcm9zKCk7IC8vIDp1aW50XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoY2x6ICsgMSkgLSAxO1xuICB9O1xuXG4gIC8vICgpOmludFxuICB0aGlzLnJlYWRFeHBHb2xvbWIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdSA9IHRoaXMucmVhZFVuc2lnbmVkRXhwR29sb21iKCk7IC8vIDppbnRcbiAgICBpZiAoMHgwMSAmIHZhbHUpIHtcbiAgICAgIC8vIHRoZSBudW1iZXIgaXMgb2RkIGlmIHRoZSBsb3cgb3JkZXIgYml0IGlzIHNldFxuICAgICAgcmV0dXJuICgxICsgdmFsdSkgPj4+IDE7IC8vIGFkZCAxIHRvIG1ha2UgaXQgZXZlbiwgYW5kIGRpdmlkZSBieSAyXG4gICAgfVxuICAgIHJldHVybiAtMSAqICh2YWx1ID4+PiAxKTsgLy8gZGl2aWRlIGJ5IHR3byB0aGVuIG1ha2UgaXQgbmVnYXRpdmVcbiAgfTtcblxuICAvLyBTb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9uc1xuICAvLyA6Qm9vbGVhblxuICB0aGlzLnJlYWRCb29sZWFuID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMSkgPT09IDE7XG4gIH07XG5cbiAgLy8gKCk6aW50XG4gIHRoaXMucmVhZFVuc2lnbmVkQnl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDgpO1xuICB9O1xuXG4gIHRoaXMubG9hZFdvcmQoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhwR29sb21iO1xuXG59LHt9XSw2MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIG11eC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcmlnaHRjb3ZlXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIEEgbGlnaHR3ZWlnaHQgcmVhZGFibGUgc3RyZWFtIGltcGxlbWVudGlvbiB0aGF0IGhhbmRsZXMgZXZlbnQgZGlzcGF0Y2hpbmcuXG4gKiBPYmplY3RzIHRoYXQgaW5oZXJpdCBmcm9tIHN0cmVhbXMgc2hvdWxkIGNhbGwgaW5pdCBpbiB0aGVpciBjb25zdHJ1Y3RvcnMuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0ge307XG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHR5cGUge3N0cmluZ30gdGhlIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIge2Z1bmN0aW9ufSB0aGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGFuIGV2ZW50IG9mXG4gICAgICogdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vyc1xuICAgICAqL1xuICAgIHRoaXMub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKCFsaXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgbGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcnNbdHlwZV0uY29uY2F0KGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIGZvciBhIHNwZWNpZmllZCBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSB0eXBlIHtzdHJpbmd9IHRoZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIHtmdW5jdGlvbn0gYSBmdW5jdGlvbiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgZm9yIHRoaXNcbiAgICAgKiB0eXBlIG9mIGV2ZW50IHRocm91Z2ggYG9uYFxuICAgICAqL1xuICAgIHRoaXMub2ZmID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBpbmRleDtcbiAgICAgIGlmICghbGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGluZGV4ID0gbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXJzW3R5cGVdLnNsaWNlKCk7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHJldHVybiBpbmRleCA+IC0xO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb24gdGhpcyBzdHJlYW0uIEFueSBhZGRpdGlvbmFsXG4gICAgICogYXJndW1lbnRzIHRvIHRoaXMgZnVuY3Rpb24gYXJlIHBhc3NlZCBhcyBwYXJhbWV0ZXJzIHRvIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfSB0aGUgZXZlbnQgbmFtZVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBjYWxsYmFja3MsIGksIGxlbmd0aCwgYXJncztcbiAgICAgIGNhbGxiYWNrcyA9IGxpc3RlbmVyc1t0eXBlXTtcbiAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFNsaWNpbmcgdGhlIGFyZ3VtZW50cyBvbiBldmVyeSBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kXG4gICAgICAvLyBjYW4gYWRkIGEgc2lnbmlmaWNhbnQgYW1vdW50IG9mIG92ZXJoZWFkLiBBdm9pZCB0aGVcbiAgICAgIC8vIGludGVybWVkaWF0ZSBvYmplY3QgY3JlYXRpb24gZm9yIHRoZSBjb21tb24gY2FzZSBvZiBhXG4gICAgICAvLyBzaW5nbGUgY2FsbGJhY2sgYXJndW1lbnRcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGxlbmd0aCA9IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBzdHJlYW0gYW5kIGNsZWFucyB1cC5cbiAgICAgKi9cbiAgICB0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGxpc3RlbmVycyA9IHt9O1xuICAgIH07XG4gIH07XG59O1xuXG4vKipcbiAqIEZvcndhcmRzIGFsbCBgZGF0YWAgZXZlbnRzIG9uIHRoaXMgc3RyZWFtIHRvIHRoZSBkZXN0aW5hdGlvbiBzdHJlYW0uIFRoZVxuICogZGVzdGluYXRpb24gc3RyZWFtIHNob3VsZCBwcm92aWRlIGEgbWV0aG9kIGBwdXNoYCB0byByZWNlaXZlIHRoZSBkYXRhXG4gKiBldmVudHMgYXMgdGhleSBhcnJpdmUuXG4gKiBAcGFyYW0gZGVzdGluYXRpb24ge3N0cmVhbX0gdGhlIHN0cmVhbSB0aGF0IHdpbGwgcmVjZWl2ZSBhbGwgYGRhdGFgIGV2ZW50c1xuICogQHBhcmFtIGF1dG9GbHVzaCB7Ym9vbGVhbn0gaWYgZmFsc2UsIHdlIHdpbGwgbm90IGNhbGwgYGZsdXNoYCBvbiB0aGUgZGVzdGluYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gdGhlIGN1cnJlbnQgc3RyZWFtIGVtaXRzIGEgJ2RvbmUnIGV2ZW50XG4gKiBAc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fcmVhZGFibGVfcGlwZV9kZXN0aW5hdGlvbl9vcHRpb25zXG4gKi9cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3RpbmF0aW9uKSB7XG4gIHRoaXMub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgZGVzdGluYXRpb24ucHVzaChkYXRhKTtcbiAgfSk7XG5cbiAgdGhpcy5vbignZG9uZScsIGZ1bmN0aW9uKGZsdXNoU291cmNlKSB7XG4gICAgZGVzdGluYXRpb24uZmx1c2goZmx1c2hTb3VyY2UpO1xuICB9KTtcblxuICByZXR1cm4gZGVzdGluYXRpb247XG59O1xuXG4vLyBEZWZhdWx0IHN0cmVhbSBmdW5jdGlvbnMgdGhhdCBhcmUgZXhwZWN0ZWQgdG8gYmUgb3ZlcnJpZGRlbiB0byBwZXJmb3JtXG4vLyBhY3R1YWwgd29yay4gVGhlc2UgYXJlIHByb3ZpZGVkIGJ5IHRoZSBwcm90b3R5cGUgYXMgYSBzb3J0IG9mIG5vLW9wXG4vLyBpbXBsZW1lbnRhdGlvbiBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2hlY2sgZm9yIHRoZWlyIGV4aXN0ZW5jZSBpbiB0aGVcbi8vIGBwaXBlYCBmdW5jdGlvbiBhYm92ZS5cblN0cmVhbS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy50cmlnZ2VyKCdkYXRhJywgZGF0YSk7XG59O1xuXG5TdHJlYW0ucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oZmx1c2hTb3VyY2UpIHtcbiAgdGhpcy50cmlnZ2VyKCdkb25lJywgZmx1c2hTb3VyY2UpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbn0se31dLDYzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cclxuKGZ1bmN0aW9uKHJvb3QpIHsgXHJcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXHJcbiAgdmFyIFVSTFRvb2xraXQgPSB7XHJcbiAgICAvLyBidWlsZCBhbiBhYnNvbHV0ZSBVUkwgZnJvbSBhIHJlbGF0aXZlIG9uZSB1c2luZyB0aGUgcHJvdmlkZWQgYmFzZVVSTFxyXG4gICAgLy8gaWYgcmVsYXRpdmVVUkwgaXMgYW4gYWJzb2x1dGUgVVJMIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMgaXMuXHJcbiAgICBidWlsZEFic29sdXRlVVJMOiBmdW5jdGlvbihiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xyXG4gICAgICAvLyByZW1vdmUgYW55IHJlbWFpbmluZyBzcGFjZSBhbmQgQ1JMRlxyXG4gICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMLnRyaW0oKTtcclxuICAgICAgaWYgKC9eW2Etel0rOi9pLnRlc3QocmVsYXRpdmVVUkwpKSB7XHJcbiAgICAgICAgLy8gY29tcGxldGUgdXJsLCBub3QgcmVsYXRpdmVcclxuICAgICAgICByZXR1cm4gcmVsYXRpdmVVUkw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciByZWxhdGl2ZVVSTFF1ZXJ5ID0gbnVsbDtcclxuICAgICAgdmFyIHJlbGF0aXZlVVJMSGFzaCA9IG51bGw7XHJcblxyXG4gICAgICB2YXIgcmVsYXRpdmVVUkxIYXNoU3BsaXQgPSAvXihbXiNdKikoLiopJC8uZXhlYyhyZWxhdGl2ZVVSTCk7XHJcbiAgICAgIGlmIChyZWxhdGl2ZVVSTEhhc2hTcGxpdCkge1xyXG4gICAgICAgIHJlbGF0aXZlVVJMSGFzaCA9IHJlbGF0aXZlVVJMSGFzaFNwbGl0WzJdO1xyXG4gICAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkxIYXNoU3BsaXRbMV07XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHJlbGF0aXZlVVJMUXVlcnlTcGxpdCA9IC9eKFteXFw/XSopKC4qKSQvLmV4ZWMocmVsYXRpdmVVUkwpO1xyXG4gICAgICBpZiAocmVsYXRpdmVVUkxRdWVyeVNwbGl0KSB7XHJcbiAgICAgICAgcmVsYXRpdmVVUkxRdWVyeSA9IHJlbGF0aXZlVVJMUXVlcnlTcGxpdFsyXTtcclxuICAgICAgICByZWxhdGl2ZVVSTCA9IHJlbGF0aXZlVVJMUXVlcnlTcGxpdFsxXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGJhc2VVUkxIYXNoU3BsaXQgPSAvXihbXiNdKikoLiopJC8uZXhlYyhiYXNlVVJMKTtcclxuICAgICAgaWYgKGJhc2VVUkxIYXNoU3BsaXQpIHtcclxuICAgICAgICBiYXNlVVJMID0gYmFzZVVSTEhhc2hTcGxpdFsxXTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgYmFzZVVSTFF1ZXJ5U3BsaXQgPSAvXihbXlxcP10qKSguKikkLy5leGVjKGJhc2VVUkwpO1xyXG4gICAgICBpZiAoYmFzZVVSTFF1ZXJ5U3BsaXQpIHtcclxuICAgICAgICBiYXNlVVJMID0gYmFzZVVSTFF1ZXJ5U3BsaXRbMV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBiYXNlVVJMRG9tYWluU3BsaXQgPSAvXigoW2Etel0rOik/XFwvXFwvW146XFwvXSsoOlswLTldKyk/KT8oXFwvPy4qKSQvaS5leGVjKGJhc2VVUkwpO1xyXG4gICAgICBpZiAoIWJhc2VVUkxEb21haW5TcGxpdCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBlLmcuICdodHRwOicsICdodHRwczonLCAnJ1xyXG4gICAgICB2YXIgYmFzZVVSTFByb3RvY29sID0gYmFzZVVSTERvbWFpblNwbGl0WzJdIHx8ICcnO1xyXG4gICAgICAvLyBlLmcuICdodHRwOi8vZXhhbXBsZS5jb20nLCAnLy9leGFtcGxlLmNvbScsICcnXHJcbiAgICAgIHZhciBiYXNlVVJMUHJvdG9jb2xEb21haW4gPSBiYXNlVVJMRG9tYWluU3BsaXRbMV0gfHwgJyc7XHJcbiAgICAgIC8vIGUuZy4gJy9hL2IvYy9wbGF5bGlzdC5tM3U4JywgJ2EvYi9jL3BsYXlsaXN0Lm0zdTgnXHJcbiAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VVUkxEb21haW5TcGxpdFs0XTtcclxuICAgICAgaWYgKGJhc2VVUkxQYXRoLmluZGV4T2YoJy8nKSAhPT0gMCAmJiBiYXNlVVJMUHJvdG9jb2xEb21haW4gIT09ICcnKSB7XHJcbiAgICAgICAgLy8gdGhpcyBoYW5kbGVzIGEgYmFzZSB1cmwgb2YgaHR0cDovL2V4YW1wbGUuY29tIChtaXNzaW5nIGxhc3Qgc2xhc2gpXHJcbiAgICAgICAgYmFzZVVSTFBhdGggPSAnLycrYmFzZVVSTFBhdGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBidWlsdFVSTCA9IG51bGw7XHJcbiAgICAgIGlmICgvXlxcL1xcLy8udGVzdChyZWxhdGl2ZVVSTCkpIHtcclxuICAgICAgICAvLyByZWxhdGl2ZSB1cmwgc3RhcnRzIHd0aCAnLy8nIHNvIGNvcHkgcHJvdG9jb2wgKHdoaWNoIG1heSBiZSAnJyBpZiBiYXNlVXJsIGRpZG4ndCBwcm92aWRlIG9uZSlcclxuICAgICAgICBidWlsdFVSTCA9IGJhc2VVUkxQcm90b2NvbCsnLy8nK1VSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVBhdGgoJycsIHJlbGF0aXZlVVJMLnN1YnN0cmluZygyKSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoL15cXC8vLnRlc3QocmVsYXRpdmVVUkwpKSB7XHJcbiAgICAgICAgLy8gcmVsYXRpdmUgdXJsIHN0YXJ0cyB3aXRoICcvJyBzbyBzdGFydCBmcm9tIHJvb3Qgb2YgZG9tYWluXHJcbiAgICAgICAgYnVpbHRVUkwgPSBiYXNlVVJMUHJvdG9jb2xEb21haW4rJy8nK1VSTFRvb2xraXQuYnVpbGRBYnNvbHV0ZVBhdGgoJycsIHJlbGF0aXZlVVJMLnN1YnN0cmluZygxKSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgYnVpbHRVUkwgPSBVUkxUb29sa2l0LmJ1aWxkQWJzb2x1dGVQYXRoKGJhc2VVUkxQcm90b2NvbERvbWFpbitiYXNlVVJMUGF0aCwgcmVsYXRpdmVVUkwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBwdXQgdGhlIHF1ZXJ5IGFuZCBoYXNoIHBhcnRzIGJhY2tcclxuICAgICAgaWYgKHJlbGF0aXZlVVJMUXVlcnkpIHtcclxuICAgICAgICBidWlsdFVSTCArPSByZWxhdGl2ZVVSTFF1ZXJ5O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZWxhdGl2ZVVSTEhhc2gpIHtcclxuICAgICAgICBidWlsdFVSTCArPSByZWxhdGl2ZVVSTEhhc2g7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGJ1aWx0VVJMO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBidWlsZCBhbiBhYnNvbHV0ZSBwYXRoIHVzaW5nIHRoZSBwcm92aWRlZCBiYXNlUGF0aFxyXG4gICAgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9kb2N1bWVudC9jb29raWUjVXNpbmdfcmVsYXRpdmVfVVJMc19pbl90aGVfcGF0aF9wYXJhbWV0ZXJcclxuICAgIC8vIHRoaXMgZG9lcyBub3QgaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHJlbGF0aXZlUGF0aCBpcyBcIi9cIiBvciBcIi8vXCIuIFRoZXNlIGNhc2VzIHNob3VsZCBiZSBoYW5kbGVkIG91dHNpZGUgdGhpcy5cclxuICAgIGJ1aWxkQWJzb2x1dGVQYXRoOiBmdW5jdGlvbihiYXNlUGF0aCwgcmVsYXRpdmVQYXRoKSB7XHJcbiAgICAgIHZhciBzUmVsUGF0aCA9IHJlbGF0aXZlUGF0aDtcclxuICAgICAgdmFyIG5VcExuLCBzRGlyID0gJycsIHNQYXRoID0gYmFzZVBhdGgucmVwbGFjZSgvW15cXC9dKiQvLCBzUmVsUGF0aC5yZXBsYWNlKC8oXFwvfF4pKD86XFwuP1xcLyspKy9nLCAnJDEnKSk7XHJcbiAgICAgIGZvciAodmFyIG5FbmQsIG5TdGFydCA9IDA7IG5FbmQgPSBzUGF0aC5pbmRleE9mKCcvLi4vJywgblN0YXJ0KSwgbkVuZCA+IC0xOyBuU3RhcnQgPSBuRW5kICsgblVwTG4pIHtcclxuICAgICAgICBuVXBMbiA9IC9eXFwvKD86XFwuXFwuXFwvKSovLmV4ZWMoc1BhdGguc2xpY2UobkVuZCkpWzBdLmxlbmd0aDtcclxuICAgICAgICBzRGlyID0gKHNEaXIgKyBzUGF0aC5zdWJzdHJpbmcoblN0YXJ0LCBuRW5kKSkucmVwbGFjZShuZXcgUmVnRXhwKCcoPzpcXFxcXFwvK1teXFxcXFxcL10qKXswLCcgKyAoKG5VcExuIC0gMSkgLyAzKSArICd9JCcpLCAnLycpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzRGlyICsgc1BhdGguc3Vic3RyKG5TdGFydCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cclxuICBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFVSTFRvb2xraXQ7XHJcbiAgZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXHJcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gVVJMVG9vbGtpdDsgfSk7XHJcbiAgZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcbiAgICBleHBvcnRzW1wiVVJMVG9vbGtpdFwiXSA9IFVSTFRvb2xraXQ7XHJcbiAgZWxzZVxyXG4gICAgcm9vdFtcIlVSTFRvb2xraXRcIl0gPSBVUkxUb29sa2l0O1xyXG59KSh0aGlzKTtcclxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cclxuXG59LHt9XSw2NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIEBmaWxlIGFkZC10ZXh0LXRyYWNrLWRhdGEuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2dsb2JhbFdpbmRvdyA9IHJlcXVpcmUoJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIF9nbG9iYWxXaW5kb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsV2luZG93KTtcblxudmFyIF92aWRlb0pzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ3ZpZGVvanMnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ3ZpZGVvanMnXSA6IG51bGwpO1xuXG52YXIgX3ZpZGVvSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlkZW9Kcyk7XG5cbi8qKlxuICogRGVmaW5lIHByb3BlcnRpZXMgb24gYSBjdWUgZm9yIGJhY2t3YXJkcyBjb21wYXRhYmlsaXR5LFxuICogYnV0IHdhcm4gdGhlIHVzZXIgdGhhdCB0aGUgd2F5IHRoYXQgdGhleSBhcmUgdXNpbmcgaXRcbiAqIGlzIGRlcHJpY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBhdCBhIGxhdGVyIGRhdGUuXG4gKlxuICogQHBhcmFtIHtDdWV9IGN1ZSB0aGUgY3VlIHRvIGFkZCB0aGUgcHJvcGVydGllcyBvblxuICogQHByaXZhdGVcbiAqL1xudmFyIGRlcHJlY2F0ZU9sZEN1ZSA9IGZ1bmN0aW9uIGRlcHJlY2F0ZU9sZEN1ZShjdWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY3VlLmZyYW1lLCB7XG4gICAgaWQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBfdmlkZW9KczJbJ2RlZmF1bHQnXS5sb2cud2FybignY3VlLmZyYW1lLmlkIGlzIGRlcHJlY2F0ZWQuIFVzZSBjdWUudmFsdWUua2V5IGluc3RlYWQuJyk7XG4gICAgICAgIHJldHVybiBjdWUudmFsdWUua2V5O1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsdWU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBfdmlkZW9KczJbJ2RlZmF1bHQnXS5sb2cud2FybignY3VlLmZyYW1lLnZhbHVlIGlzIGRlcHJlY2F0ZWQuIFVzZSBjdWUudmFsdWUuZGF0YSBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm4gY3VlLnZhbHVlLmRhdGE7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcml2YXRlRGF0YToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIF92aWRlb0pzMlsnZGVmYXVsdCddLmxvZy53YXJuKCdjdWUuZnJhbWUucHJpdmF0ZURhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIGN1ZS52YWx1ZS5kYXRhIGluc3RlYWQuJyk7XG4gICAgICAgIHJldHVybiBjdWUudmFsdWUuZGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGR1cmF0aW9uT2ZWaWRlbyA9IGZ1bmN0aW9uIGR1cmF0aW9uT2ZWaWRlbyhkdXJhdGlvbikge1xuICB2YXIgZHVyID0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc05hTihkdXJhdGlvbikgfHwgTWF0aC5hYnMoZHVyYXRpb24pID09PSBJbmZpbml0eSkge1xuICAgIGR1ciA9IE51bWJlci5NQVhfVkFMVUU7XG4gIH0gZWxzZSB7XG4gICAgZHVyID0gZHVyYXRpb247XG4gIH1cbiAgcmV0dXJuIGR1cjtcbn07XG4vKipcbiAqIEFkZCB0ZXh0IHRyYWNrIGRhdGEgdG8gYSBzb3VyY2UgaGFuZGxlciBnaXZlbiB0aGUgY2FwdGlvbnMgYW5kXG4gKiBtZXRhZGF0YSBmcm9tIHRoZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZUhhbmRsZXIgdGhlIGZsYXNoIG9yIHZpcnR1YWwgc291cmNlIGJ1ZmZlclxuICogQHBhcmFtIHtBcnJheX0gY2FwdGlvbkFycmF5IGFuIGFycmF5IG9mIGNhcHRpb24gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gbWV0YWRhdGFBcnJheSBhbiBhcnJheSBvZiBtZXRhIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBhZGRUZXh0VHJhY2tEYXRhID0gZnVuY3Rpb24gYWRkVGV4dFRyYWNrRGF0YShzb3VyY2VIYW5kbGVyLCBjYXB0aW9uQXJyYXksIG1ldGFkYXRhQXJyYXkpIHtcbiAgdmFyIEN1ZSA9IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uV2ViS2l0RGF0YUN1ZSB8fCBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLlZUVEN1ZTtcblxuICBpZiAoY2FwdGlvbkFycmF5KSB7XG4gICAgY2FwdGlvbkFycmF5LmZvckVhY2goZnVuY3Rpb24gKGNhcHRpb24pIHtcbiAgICAgIHZhciB0cmFjayA9IGNhcHRpb24uc3RyZWFtO1xuXG4gICAgICB0aGlzLmluYmFuZFRleHRUcmFja3NfW3RyYWNrXS5hZGRDdWUobmV3IEN1ZShjYXB0aW9uLnN0YXJ0VGltZSArIHRoaXMudGltZXN0YW1wT2Zmc2V0LCBjYXB0aW9uLmVuZFRpbWUgKyB0aGlzLnRpbWVzdGFtcE9mZnNldCwgY2FwdGlvbi50ZXh0KSk7XG4gICAgfSwgc291cmNlSGFuZGxlcik7XG4gIH1cblxuICBpZiAobWV0YWRhdGFBcnJheSkge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmlkZW9EdXJhdGlvbiA9IGR1cmF0aW9uT2ZWaWRlbyhzb3VyY2VIYW5kbGVyLm1lZGlhU291cmNlXy5kdXJhdGlvbik7XG5cbiAgICAgIG1ldGFkYXRhQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAobWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBtZXRhZGF0YS5jdWVUaW1lICsgdGhpcy50aW1lc3RhbXBPZmZzZXQ7XG5cbiAgICAgICAgbWV0YWRhdGEuZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgdmFyIGN1ZSA9IG5ldyBDdWUodGltZSwgdGltZSwgZnJhbWUudmFsdWUgfHwgZnJhbWUudXJsIHx8IGZyYW1lLmRhdGEgfHwgJycpO1xuXG4gICAgICAgICAgY3VlLmZyYW1lID0gZnJhbWU7XG4gICAgICAgICAgY3VlLnZhbHVlID0gZnJhbWU7XG4gICAgICAgICAgZGVwcmVjYXRlT2xkQ3VlKGN1ZSk7XG5cbiAgICAgICAgICB0aGlzLm1ldGFkYXRhVHJhY2tfLmFkZEN1ZShjdWUpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sIHNvdXJjZUhhbmRsZXIpO1xuXG4gICAgICAvLyBVcGRhdGluZyB0aGUgbWV0YWRldGEgY3VlcyBzbyB0aGF0XG4gICAgICAvLyB0aGUgZW5kVGltZSBvZiBlYWNoIGN1ZSBpcyB0aGUgc3RhcnRUaW1lIG9mIHRoZSBuZXh0IGN1ZVxuICAgICAgLy8gdGhlIGVuZFRpbWUgb2YgbGFzdCBjdWUgaXMgdGhlIGR1cmF0aW9uIG9mIHRoZSB2aWRlb1xuICAgICAgaWYgKHNvdXJjZUhhbmRsZXIubWV0YWRhdGFUcmFja18gJiYgc291cmNlSGFuZGxlci5tZXRhZGF0YVRyYWNrXy5jdWVzICYmIHNvdXJjZUhhbmRsZXIubWV0YWRhdGFUcmFja18uY3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgY3VlcyA9IHNvdXJjZUhhbmRsZXIubWV0YWRhdGFUcmFja18uY3VlcztcbiAgICAgICAgICB2YXIgY3Vlc0FycmF5ID0gW107XG5cbiAgICAgICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBUZXh0VHJhY2tDdWVMaXN0Li4uXG4gICAgICAgICAgLy8gLi4uZGlzcmVnYXJkaW5nIGN1ZXMgd2l0aCBhIGZhbHNleSB2YWx1ZVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3Vlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGN1ZXNbaV0pIHtcbiAgICAgICAgICAgICAgY3Vlc0FycmF5LnB1c2goY3Vlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gR3JvdXAgY3VlcyBieSB0aGVpciBzdGFydFRpbWUgdmFsdWVcbiAgICAgICAgICB2YXIgY3Vlc0dyb3VwZWRCeVN0YXJ0VGltZSA9IGN1ZXNBcnJheS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgY3VlKSB7XG4gICAgICAgICAgICB2YXIgdGltZVNsb3QgPSBvYmpbY3VlLnN0YXJ0VGltZV0gfHwgW107XG5cbiAgICAgICAgICAgIHRpbWVTbG90LnB1c2goY3VlKTtcbiAgICAgICAgICAgIG9ialtjdWUuc3RhcnRUaW1lXSA9IHRpbWVTbG90O1xuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgIH0sIHt9KTtcblxuICAgICAgICAgIC8vIFNvcnQgc3RhcnRUaW1lcyBieSBhc2NlbmRpbmcgb3JkZXJcbiAgICAgICAgICB2YXIgc29ydGVkU3RhcnRUaW1lcyA9IE9iamVjdC5rZXlzKGN1ZXNHcm91cGVkQnlTdGFydFRpbWUpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoYSkgLSBOdW1iZXIoYik7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBNYXAgZWFjaCBjdWUgZ3JvdXAncyBlbmRUaW1lIHRvIHRoZSBuZXh0IGdyb3VwJ3Mgc3RhcnRUaW1lXG4gICAgICAgICAgc29ydGVkU3RhcnRUaW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGFydFRpbWUsIGlkeCkge1xuICAgICAgICAgICAgdmFyIGN1ZUdyb3VwID0gY3Vlc0dyb3VwZWRCeVN0YXJ0VGltZVtzdGFydFRpbWVdO1xuICAgICAgICAgICAgdmFyIG5leHRUaW1lID0gTnVtYmVyKHNvcnRlZFN0YXJ0VGltZXNbaWR4ICsgMV0pIHx8IHZpZGVvRHVyYXRpb247XG5cbiAgICAgICAgICAgIC8vIE1hcCBlYWNoIGN1ZSdzIGVuZFRpbWUgdGhlIG5leHQgZ3JvdXAncyBzdGFydFRpbWVcbiAgICAgICAgICAgIGN1ZUdyb3VwLmZvckVhY2goZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgICAgICAgICBjdWUuZW5kVGltZSA9IG5leHRUaW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0ge1xuICBhZGRUZXh0VHJhY2tEYXRhOiBhZGRUZXh0VHJhY2tEYXRhLFxuICBkdXJhdGlvbk9mVmlkZW86IGR1cmF0aW9uT2ZWaWRlb1xufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcImdsb2JhbC93aW5kb3dcIjozMn1dLDY1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgY29kZWMtdXRpbHMuanNcbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGEgY29kZWMgc3RyaW5nIHJlZmVycyB0byBhbiBhdWRpbyBjb2RlYy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29kZWMgY29kZWMgc3RyaW5nIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSBpZiB0aGlzIGlzIGFuIGF1ZGlvIGNvZGVjXG4gKiBAcHJpdmF0ZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIGlzQXVkaW9Db2RlYyA9IGZ1bmN0aW9uIGlzQXVkaW9Db2RlYyhjb2RlYykge1xuICByZXR1cm4gKC9tcDRhXFwuXFxkKy5cXGQrL2kudGVzdChjb2RlYylcbiAgKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjb2RlYyBzdHJpbmcgcmVmZXJzIHRvIGEgdmlkZW8gY29kZWMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvZGVjIGNvZGVjIHN0cmluZyB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn0gaWYgdGhpcyBpcyBhIHZpZGVvIGNvZGVjXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaXNWaWRlb0NvZGVjID0gZnVuY3Rpb24gaXNWaWRlb0NvZGVjKGNvZGVjKSB7XG4gIHJldHVybiAoL2F2YzFcXC5bXFxkYS1mXSsvaS50ZXN0KGNvZGVjKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIGNvbnRlbnQgdHlwZSBoZWFkZXIgaW50byBhIHR5cGUgYW5kIHBhcmFtZXRlcnNcbiAqIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBjb250ZW50IHR5cGUgaGVhZGVyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBwYXJzZWQgY29udGVudC10eXBlXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgcGFyc2VDb250ZW50VHlwZSA9IGZ1bmN0aW9uIHBhcnNlQ29udGVudFR5cGUodHlwZSkge1xuICB2YXIgb2JqZWN0ID0geyB0eXBlOiAnJywgcGFyYW1ldGVyczoge30gfTtcbiAgdmFyIHBhcmFtZXRlcnMgPSB0eXBlLnRyaW0oKS5zcGxpdCgnOycpO1xuXG4gIC8vIGZpcnN0IHBhcmFtZXRlciBzaG91bGQgYWx3YXlzIGJlIGNvbnRlbnQtdHlwZVxuICBvYmplY3QudHlwZSA9IHBhcmFtZXRlcnMuc2hpZnQoKS50cmltKCk7XG4gIHBhcmFtZXRlcnMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW1ldGVyKSB7XG4gICAgdmFyIHBhaXIgPSBwYXJhbWV0ZXIudHJpbSgpLnNwbGl0KCc9Jyk7XG5cbiAgICBpZiAocGFpci5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgX25hbWUgPSBwYWlyWzBdLnJlcGxhY2UoL1wiL2csICcnKS50cmltKCk7XG4gICAgICB2YXIgdmFsdWUgPSBwYWlyWzFdLnJlcGxhY2UoL1wiL2csICcnKS50cmltKCk7XG5cbiAgICAgIG9iamVjdC5wYXJhbWV0ZXJzW19uYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbi8qKlxuICogUmVwbGFjZSB0aGUgb2xkIGFwcGxlLXN0eWxlIGBhdmMxLjxkZD4uPGRkPmAgY29kZWMgc3RyaW5nIHdpdGggdGhlIHN0YW5kYXJkXG4gKiBgYXZjMS48aGhoaGhoPmBcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBjb2RlY3MgYW4gYXJyYXkgb2YgY29kZWMgc3RyaW5ncyB0byBmaXhcbiAqIEByZXR1cm4ge0FycmF5fSB0aGUgdHJhbnNsYXRlZCBjb2RlYyBhcnJheVxuICogQHByaXZhdGVcbiAqL1xudmFyIHRyYW5zbGF0ZUxlZ2FjeUNvZGVjcyA9IGZ1bmN0aW9uIHRyYW5zbGF0ZUxlZ2FjeUNvZGVjcyhjb2RlY3MpIHtcbiAgcmV0dXJuIGNvZGVjcy5tYXAoZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgcmV0dXJuIGNvZGVjLnJlcGxhY2UoL2F2YzFcXC4oXFxkKylcXC4oXFxkKykvaSwgZnVuY3Rpb24gKG9yaWcsIHByb2ZpbGUsIGF2Y0xldmVsKSB7XG4gICAgICB2YXIgcHJvZmlsZUhleCA9ICgnMDAnICsgTnVtYmVyKHByb2ZpbGUpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuICAgICAgdmFyIGF2Y0xldmVsSGV4ID0gKCcwMCcgKyBOdW1iZXIoYXZjTGV2ZWwpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xuXG4gICAgICByZXR1cm4gJ2F2YzEuJyArIHByb2ZpbGVIZXggKyAnMDAnICsgYXZjTGV2ZWxIZXg7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0ge1xuICBpc0F1ZGlvQ29kZWM6IGlzQXVkaW9Db2RlYyxcbiAgcGFyc2VDb250ZW50VHlwZTogcGFyc2VDb250ZW50VHlwZSxcbiAgaXNWaWRlb0NvZGVjOiBpc1ZpZGVvQ29kZWMsXG4gIHRyYW5zbGF0ZUxlZ2FjeUNvZGVjczogdHJhbnNsYXRlTGVnYWN5Q29kZWNzXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG59LHt9XSw2NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBmaWxlIGNyZWF0ZS10ZXh0LXRyYWNrcy1pZi1uZWNlc3NhcnkuanNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSB0ZXh0IHRyYWNrcyBvbiB2aWRlby5qcyBpZiB0aGV5IGV4aXN0IG9uIGEgc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlQnVmZmVyIHRoZSBWU0Igb3IgRlNCXG4gKiBAcGFyYW0ge09iamVjdH0gbWVkaWFTb3VyY2UgdGhlIEhUTUwgb3IgRmxhc2ggbWVkaWEgc291cmNlXG4gKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudCB0aGUgc2VnbWVudCB0aGF0IG1heSBjb250YWluIHRoZSB0ZXh0IHRyYWNrXG4gKiBAcHJpdmF0ZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIGNyZWF0ZVRleHRUcmFja3NJZk5lY2Vzc2FyeSA9IGZ1bmN0aW9uIGNyZWF0ZVRleHRUcmFja3NJZk5lY2Vzc2FyeShzb3VyY2VCdWZmZXIsIG1lZGlhU291cmNlLCBzZWdtZW50KSB7XG4gIHZhciBwbGF5ZXIgPSBtZWRpYVNvdXJjZS5wbGF5ZXJfO1xuXG4gIC8vIGNyZWF0ZSBhbiBpbi1iYW5kIGNhcHRpb24gdHJhY2sgaWYgb25lIGlzIHByZXNlbnQgaW4gdGhlIHNlZ21lbnRcbiAgaWYgKHNlZ21lbnQuY2FwdGlvbnMgJiYgc2VnbWVudC5jYXB0aW9ucy5sZW5ndGgpIHtcbiAgICBpZiAoIXNvdXJjZUJ1ZmZlci5pbmJhbmRUZXh0VHJhY2tzXykge1xuICAgICAgc291cmNlQnVmZmVyLmluYmFuZFRleHRUcmFja3NfID0ge307XG4gICAgfVxuXG4gICAgZm9yICh2YXIgdHJhY2tJZCBpbiBzZWdtZW50LmNhcHRpb25TdHJlYW1zKSB7XG4gICAgICBpZiAoIXNvdXJjZUJ1ZmZlci5pbmJhbmRUZXh0VHJhY2tzX1t0cmFja0lkXSkge1xuICAgICAgICBwbGF5ZXIudGVjaF8udHJpZ2dlcih7IHR5cGU6ICd1c2FnZScsIG5hbWU6ICdobHMtNjA4JyB9KTtcbiAgICAgICAgdmFyIHRyYWNrID0gcGxheWVyLnRleHRUcmFja3MoKS5nZXRUcmFja0J5SWQodHJhY2tJZCk7XG5cbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgLy8gUmVzdXNlIGFuIGV4aXN0aW5nIHRyYWNrIHdpdGggYSBDQyMgaWQgYmVjYXVzZSB0aGlzIHdhc1xuICAgICAgICAgIC8vIHZlcnkgbGlrZWx5IGNyZWF0ZWQgYnkgdmlkZW9qcy1jb250cmliLWhscyBmcm9tIGluZm9ybWF0aW9uXG4gICAgICAgICAgLy8gaW4gdGhlIG0zdTggZm9yIHVzIHRvIHVzZVxuICAgICAgICAgIHNvdXJjZUJ1ZmZlci5pbmJhbmRUZXh0VHJhY2tzX1t0cmFja0lkXSA9IHRyYWNrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSwgY3JlYXRlIGEgdHJhY2sgd2l0aCB0aGUgZGVmYXVsdCBgQ0MjYCBsYWJlbCBhbmRcbiAgICAgICAgICAvLyB3aXRob3V0IGEgbGFuZ3VhZ2VcbiAgICAgICAgICBzb3VyY2VCdWZmZXIuaW5iYW5kVGV4dFRyYWNrc19bdHJhY2tJZF0gPSBwbGF5ZXIuYWRkUmVtb3RlVGV4dFRyYWNrKHtcbiAgICAgICAgICAgIGtpbmQ6ICdjYXB0aW9ucycsXG4gICAgICAgICAgICBpZDogdHJhY2tJZCxcbiAgICAgICAgICAgIGxhYmVsOiB0cmFja0lkXG4gICAgICAgICAgfSwgZmFsc2UpLnRyYWNrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlZ21lbnQubWV0YWRhdGEgJiYgc2VnbWVudC5tZXRhZGF0YS5sZW5ndGggJiYgIXNvdXJjZUJ1ZmZlci5tZXRhZGF0YVRyYWNrXykge1xuICAgIHNvdXJjZUJ1ZmZlci5tZXRhZGF0YVRyYWNrXyA9IHBsYXllci5hZGRSZW1vdGVUZXh0VHJhY2soe1xuICAgICAga2luZDogJ21ldGFkYXRhJyxcbiAgICAgIGxhYmVsOiAnVGltZWQgTWV0YWRhdGEnXG4gICAgfSwgZmFsc2UpLnRyYWNrO1xuICAgIHNvdXJjZUJ1ZmZlci5tZXRhZGF0YVRyYWNrXy5pbkJhbmRNZXRhZGF0YVRyYWNrRGlzcGF0Y2hUeXBlID0gc2VnbWVudC5tZXRhZGF0YS5kaXNwYXRjaFR5cGU7XG4gIH1cbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZVRleHRUcmFja3NJZk5lY2Vzc2FyeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSx7fV0sNjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBmbGFzaC1jb25zdGFudHMuanNcbiAqL1xuLyoqXG4gKiBUaGUgbWF4aW11bSBzaXplIGluIGJ5dGVzIGZvciBhcHBlbmQgb3BlcmF0aW9ucyB0byB0aGUgdmlkZW8uanNcbiAqIFNXRi4gQ2FsbGluZyB0aHJvdWdoIHRvIEZsYXNoIGJsb2NrcyBhbmQgY2FuIGJlIGV4cGVuc2l2ZSBzb1xuICogd2UgY2h1bmsgZGF0YSBhbmQgcGFzcyB0aHJvdWdoIDRLQiBhdCBhIHRpbWUsIHlpZWxkaW5nIHRvIHRoZVxuICogYnJvd3NlciBiZXR3ZWVuIGNodW5rcy4gVGhpcyBnaXZlcyBhIHRoZW9yZXRpY2FsIG1heGltdW0gcmF0ZSBvZlxuICogMU1CL3MgaW50byBGbGFzaC4gQW55IGhpZ2hlciBhbmQgd2UgYmVnaW4gdG8gZHJvcCBmcmFtZXMgYW5kIFVJXG4gKiByZXNwb25zaXZlbmVzcyBzdWZmZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIGZsYXNoQ29uc3RhbnRzID0ge1xuICAvLyB0aW1lcyBpbiBtaWxsaXNlY29uZHNcbiAgVElNRV9CRVRXRUVOX0NIVU5LUzogMSxcbiAgQllURVNfUEVSX0NIVU5LOiAxMDI0ICogMzJcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZmxhc2hDb25zdGFudHM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xufSx7fV0sNjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBAZmlsZSBmbGFzaC1tZWRpYS1zb3VyY2UuanNcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2dsb2JhbERvY3VtZW50ID0gcmVxdWlyZSgnZ2xvYmFsL2RvY3VtZW50Jyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsRG9jdW1lbnQpO1xuXG52YXIgX3ZpZGVvSnMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sndmlkZW9qcyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndmlkZW9qcyddIDogbnVsbCk7XG5cbnZhciBfdmlkZW9KczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aWRlb0pzKTtcblxudmFyIF9mbGFzaFNvdXJjZUJ1ZmZlciA9IHJlcXVpcmUoJy4vZmxhc2gtc291cmNlLWJ1ZmZlcicpO1xuXG52YXIgX2ZsYXNoU291cmNlQnVmZmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZsYXNoU291cmNlQnVmZmVyKTtcblxudmFyIF9mbGFzaENvbnN0YW50cyA9IHJlcXVpcmUoJy4vZmxhc2gtY29uc3RhbnRzJyk7XG5cbnZhciBfZmxhc2hDb25zdGFudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmxhc2hDb25zdGFudHMpO1xuXG52YXIgX2NvZGVjVXRpbHMgPSByZXF1aXJlKCcuL2NvZGVjLXV0aWxzJyk7XG5cbi8qKlxuICogQSBmbGFzaCBpbXBsbWVudGF0aW9uIG9mIEhUTUwgTWVkaWFTb3VyY2VzIGFuZCBhIHBvbHlmaWxsXG4gKiBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IG5hdGl2ZSBvciBIVE1MIE1lZGlhU291cmNlcy4uXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhU291cmNlXG4gKiBAY2xhc3MgRmxhc2hNZWRpYVNvdXJjZVxuICogQGV4dGVuZHMgdmlkZW9qcy5FdmVudFRhcmdldFxuICovXG5cbnZhciBGbGFzaE1lZGlhU291cmNlID0gKGZ1bmN0aW9uIChfdmlkZW9qcyRFdmVudFRhcmdldCkge1xuICBfaW5oZXJpdHMoRmxhc2hNZWRpYVNvdXJjZSwgX3ZpZGVvanMkRXZlbnRUYXJnZXQpO1xuXG4gIGZ1bmN0aW9uIEZsYXNoTWVkaWFTb3VyY2UoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGbGFzaE1lZGlhU291cmNlKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEZsYXNoTWVkaWFTb3VyY2UucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMgPSBbXTtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuICAgIHRoaXMub24oWydzb3VyY2VvcGVuJywgJ3dlYmtpdHNvdXJjZW9wZW4nXSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAvLyBmaW5kIHRoZSBzd2Ygd2hlcmUgd2Ugd2lsbCBwdXNoIG1lZGlhIGRhdGFcbiAgICAgIF90aGlzLnN3Zk9iaiA9IF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5nZXRFbGVtZW50QnlJZChldmVudC5zd2ZJZCk7XG4gICAgICBfdGhpcy5wbGF5ZXJfID0gKDAsIF92aWRlb0pzMlsnZGVmYXVsdCddKShfdGhpcy5zd2ZPYmoucGFyZW50Tm9kZSk7XG4gICAgICBfdGhpcy50ZWNoXyA9IF90aGlzLnN3Zk9iai50ZWNoO1xuICAgICAgX3RoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcblxuICAgICAgX3RoaXMudGVjaF8ub24oJ3NlZWtpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpID0gX3RoaXMuc291cmNlQnVmZmVycy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIF90aGlzLnNvdXJjZUJ1ZmZlcnNbaV0uYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIHRyaWdnZXIgbG9hZCBldmVudHNcbiAgICAgIGlmIChfdGhpcy5zd2ZPYmopIHtcbiAgICAgICAgX3RoaXMuc3dmT2JqLnZqc19sb2FkKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICAqIFNldCBvciByZXR1cm4gdGhlIHByZXNlbnRhdGlvbiBkdXJhdGlvbi5cbiAgICAqXG4gICAgKiBAcGFyYW0ge0RvdWJsZX0gdmFsdWUgdGhlIGR1cmF0aW9uIG9mIHRoZSBtZWRpYSBpbiBzZWNvbmRzXG4gICAgKiBAcGFyYW0ge0RvdWJsZX0gdGhlIGN1cnJlbnQgcHJlc2VudGF0aW9uIGR1cmF0aW9uXG4gICAgKiBAbGluayBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3dpZGwtTWVkaWFTb3VyY2UtZHVyYXRpb25cbiAgICAqL1xuXG4gIC8qKlxuICAgKiBXZSBoYXZlIHRoaXMgZnVuY3Rpb24gc28gdGhhdCB0aGUgaHRtbCBhbmQgZmxhc2ggaW50ZXJmYWNlc1xuICAgKiBhcmUgdGhlIHNhbWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhGbGFzaE1lZGlhU291cmNlLCBbe1xuICAgIGtleTogJ2FkZFNlZWthYmxlUmFuZ2VfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU2Vla2FibGVSYW5nZV8oKSB7fVxuICAgIC8vIGludGVudGlvbmFsIG5vLW9wXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgZmxhc2ggc291cmNlIGJ1ZmZlciBhbmQgYWRkIGl0IHRvIG91ciBmbGFzaCBtZWRpYSBzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFTb3VyY2UvYWRkU291cmNlQnVmZmVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIGNvbnRlbnQtdHlwZSBvZiB0aGUgc291cmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgZmxhc2ggc291cmNlIGJ1ZmZlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRTb3VyY2VCdWZmZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTb3VyY2VCdWZmZXIodHlwZSkge1xuICAgICAgdmFyIHBhcnNlZFR5cGUgPSAoMCwgX2NvZGVjVXRpbHMucGFyc2VDb250ZW50VHlwZSkodHlwZSk7XG4gICAgICB2YXIgc291cmNlQnVmZmVyID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBpZiB0aGlzIGlzIGFuIEZMViB0eXBlLCB3ZSdsbCBwdXNoIGRhdGEgdG8gZmxhc2hcbiAgICAgIGlmIChwYXJzZWRUeXBlLnR5cGUgPT09ICd2aWRlby9tcDJ0JyB8fCBwYXJzZWRUeXBlLnR5cGUgPT09ICdhdWRpby9tcDJ0Jykge1xuICAgICAgICAvLyBGbGFzaCBzb3VyY2UgYnVmZmVyc1xuICAgICAgICBzb3VyY2VCdWZmZXIgPSBuZXcgX2ZsYXNoU291cmNlQnVmZmVyMlsnZGVmYXVsdCddKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3RTdXBwb3J0ZWRFcnJvciAoVmlkZW8uanMpJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc291cmNlQnVmZmVycy5wdXNoKHNvdXJjZUJ1ZmZlcik7XG4gICAgICByZXR1cm4gc291cmNlQnVmZmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpZ25hbHMgdGhlIGVuZCBvZiB0aGUgc3RyZWFtLlxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL21lZGlhLXNvdXJjZS8jd2lkbC1NZWRpYVNvdXJjZS1lbmRPZlN0cmVhbS12b2lkLUVuZE9mU3RyZWFtRXJyb3ItZXJyb3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IGVycm9yIFNpZ25hbHMgdGhhdCBhIHBsYXliYWNrIGVycm9yXG4gICAgICogaGFzIG9jY3VycmVkLiBJZiBzcGVjaWZpZWQsIGl0IG11c3QgYmUgZWl0aGVyIFwibmV0d29ya1wiIG9yXG4gICAgICogXCJkZWNvZGVcIi5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2VuZE9mU3RyZWFtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kT2ZTdHJlYW0oZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciA9PT0gJ25ldHdvcmsnKSB7XG4gICAgICAgIC8vIE1FRElBX0VSUl9ORVRXT1JLXG4gICAgICAgIHRoaXMudGVjaF8uZXJyb3IoMik7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yID09PSAnZGVjb2RlJykge1xuICAgICAgICAvLyBNRURJQV9FUlJfREVDT0RFXG4gICAgICAgIHRoaXMudGVjaF8uZXJyb3IoMyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSAnZW5kZWQnKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdlbmRlZCc7XG4gICAgICAgIHRoaXMuc3dmT2JqLnZqc19lbmRPZlN0cmVhbSgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGbGFzaE1lZGlhU291cmNlO1xufSkoX3ZpZGVvSnMyWydkZWZhdWx0J10uRXZlbnRUYXJnZXQpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBGbGFzaE1lZGlhU291cmNlO1xudHJ5IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZsYXNoTWVkaWFTb3VyY2UucHJvdG90eXBlLCAnZHVyYXRpb24nLCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwcmVzZW50YXRpb24gZHVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtEb3VibGV9IHRoZSBkdXJhdGlvbiBvZiB0aGUgbWVkaWEgaW4gc2Vjb25kc1xuICAgICAqIEBsaW5rIGh0dHA6Ly93d3cudzMub3JnL1RSL21lZGlhLXNvdXJjZS8jd2lkbC1NZWRpYVNvdXJjZS1kdXJhdGlvblxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLnN3Zk9iaikge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IGR1cmF0aW9uIGZyb20gdGhlIFNXRlxuICAgICAgcmV0dXJuIHRoaXMuc3dmT2JqLnZqc19nZXRQcm9wZXJ0eSgnZHVyYXRpb24nKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcHJlc2VudGF0aW9uIGR1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtEb3VibGV9IHZhbHVlIHRoZSBkdXJhdGlvbiBvZiB0aGUgbWVkaWEgaW4gc2Vjb25kc1xuICAgICAqIEByZXR1cm4ge0RvdWJsZX0gdGhlIGR1cmF0aW9uIG9mIHRoZSBtZWRpYSBpbiBzZWNvbmRzXG4gICAgICogQGxpbmsgaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtc291cmNlLyN3aWRsLU1lZGlhU291cmNlLWR1cmF0aW9uXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHZhciBpID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIG9sZER1cmF0aW9uID0gdGhpcy5zd2ZPYmoudmpzX2dldFByb3BlcnR5KCdkdXJhdGlvbicpO1xuXG4gICAgICB0aGlzLnN3Zk9iai52anNfc2V0UHJvcGVydHkoJ2R1cmF0aW9uJywgdmFsdWUpO1xuXG4gICAgICBpZiAodmFsdWUgPCBvbGREdXJhdGlvbikge1xuICAgICAgICAvLyBJbiBNU0UsIHRoaXMgdHJpZ2dlcnMgdGhlIHJhbmdlIHJlbW92YWwgYWxnb3JpdGhtIHdoaWNoIGNhdXNlc1xuICAgICAgICAvLyBhbiB1cGRhdGUgdG8gb2NjdXJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc291cmNlQnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuc291cmNlQnVmZmVyc1tpXS5yZW1vdmUodmFsdWUsIG9sZER1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9KTtcbn0gY2F0Y2ggKGUpIHtcbiAgLy8gSUU4IHRocm93cyBpZiBkZWZpbmVQcm9wZXJ0eSBpcyBjYWxsZWQgb24gYSBub24tRE9NIG5vZGUuIFdlXG4gIC8vIGRvbid0IHN1cHBvcnQgSUU4IGJ1dCB3ZSBzaG91bGRuJ3QgdGhyb3cgYW4gZXJyb3IgaWYgbG9hZGVkXG4gIC8vIHRoZXJlLlxuICBGbGFzaE1lZGlhU291cmNlLnByb3RvdHlwZS5kdXJhdGlvbiA9IE5hTjtcbn1cblxuZm9yICh2YXIgcHJvcGVydHkgaW4gX2ZsYXNoQ29uc3RhbnRzMlsnZGVmYXVsdCddKSB7XG4gIEZsYXNoTWVkaWFTb3VyY2VbcHJvcGVydHldID0gX2ZsYXNoQ29uc3RhbnRzMlsnZGVmYXVsdCddW3Byb3BlcnR5XTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4vY29kZWMtdXRpbHNcIjo2NSxcIi4vZmxhc2gtY29uc3RhbnRzXCI6NjcsXCIuL2ZsYXNoLXNvdXJjZS1idWZmZXJcIjo2OSxcImdsb2JhbC9kb2N1bWVudFwiOjMxfV0sNjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBAZmlsZSBmbGFzaC1zb3VyY2UtYnVmZmVyLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9nbG9iYWxXaW5kb3cgPSByZXF1aXJlKCdnbG9iYWwvd2luZG93Jyk7XG5cbnZhciBfZ2xvYmFsV2luZG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbFdpbmRvdyk7XG5cbnZhciBfdmlkZW9KcyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2aWRlb2pzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd2aWRlb2pzJ10gOiBudWxsKTtcblxudmFyIF92aWRlb0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvSnMpO1xuXG52YXIgX211eEpzTGliRmx2ID0gcmVxdWlyZSgnbXV4LmpzL2xpYi9mbHYnKTtcblxudmFyIF9tdXhKc0xpYkZsdjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tdXhKc0xpYkZsdik7XG5cbnZhciBfcmVtb3ZlQ3Vlc0Zyb21UcmFjayA9IHJlcXVpcmUoJy4vcmVtb3ZlLWN1ZXMtZnJvbS10cmFjaycpO1xuXG52YXIgX3JlbW92ZUN1ZXNGcm9tVHJhY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVtb3ZlQ3Vlc0Zyb21UcmFjayk7XG5cbnZhciBfY3JlYXRlVGV4dFRyYWNrc0lmTmVjZXNzYXJ5ID0gcmVxdWlyZSgnLi9jcmVhdGUtdGV4dC10cmFja3MtaWYtbmVjZXNzYXJ5Jyk7XG5cbnZhciBfY3JlYXRlVGV4dFRyYWNrc0lmTmVjZXNzYXJ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRleHRUcmFja3NJZk5lY2Vzc2FyeSk7XG5cbnZhciBfYWRkVGV4dFRyYWNrRGF0YSA9IHJlcXVpcmUoJy4vYWRkLXRleHQtdHJhY2stZGF0YScpO1xuXG52YXIgX2ZsYXNoVHJhbnNtdXhlcldvcmtlciA9IHJlcXVpcmUoJy4vZmxhc2gtdHJhbnNtdXhlci13b3JrZXInKTtcblxudmFyIF9mbGFzaFRyYW5zbXV4ZXJXb3JrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmxhc2hUcmFuc211eGVyV29ya2VyKTtcblxudmFyIF93ZWJ3b3JraWZ5ID0gcmVxdWlyZSgnd2Vid29ya2lmeScpO1xuXG52YXIgX3dlYndvcmtpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2Vid29ya2lmeSk7XG5cbnZhciBfZmxhc2hDb25zdGFudHMgPSByZXF1aXJlKCcuL2ZsYXNoLWNvbnN0YW50cycpO1xuXG52YXIgX2ZsYXNoQ29uc3RhbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZsYXNoQ29uc3RhbnRzKTtcblxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBzZXRUaW1lb3V0IGZ1bmN0aW9uIHRoYXQgdXNlc1xuICogdGhlIGZsYXNoIGNvbnN0YW50IHRpbWUgYmV0d2VlbiB0aWNrcyB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIHRoZSBmdW5jdGlvbiBjYWxsYmFjayB0byBydW5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBzY2hlZHVsZVRpY2sgPSBmdW5jdGlvbiBzY2hlZHVsZVRpY2soZnVuYykge1xuICAvLyBDaHJvbWUgZG9lc24ndCBpbnZva2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGNhbGxiYWNrc1xuICAvLyBpbiBiYWNrZ3JvdW5kIHRhYnMsIHNvIHVzZSBzZXRUaW1lb3V0LlxuICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnNldFRpbWVvdXQoZnVuYywgX2ZsYXNoQ29uc3RhbnRzMlsnZGVmYXVsdCddLlRJTUVfQkVUV0VFTl9DSFVOS1MpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gc3RyaW5nIG9mIG1heCBsZW5ndGggNlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHJhbmRvbWx5IGdlbmVyYXRlZCBzdHJpbmdcbiAqIEBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbVN0cmluZ1xuICogQHByaXZhdGVcbiAqL1xudmFyIGdlbmVyYXRlUmFuZG9tU3RyaW5nID0gZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21TdHJpbmcoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCA4KTtcbn07XG5cbi8qKlxuICogUm91bmQgYSBudW1iZXIgdG8gYSBzcGVjaWZpZWQgbnVtYmVyIG9mIHBsYWNlcyBtdWNoIGxpa2VcbiAqIHRvRml4ZWQgYnV0IHJldHVybiBhIG51bWJlciBpbnN0ZWFkIG9mIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gQSBudW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBwbGFjZXMgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB3aGljaCB0b1xuICogcm91bmRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciB0b0RlY2ltYWxQbGFjZXMgPSBmdW5jdGlvbiB0b0RlY2ltYWxQbGFjZXMobnVtLCBwbGFjZXMpIHtcbiAgaWYgKHR5cGVvZiBwbGFjZXMgIT09ICdudW1iZXInIHx8IHBsYWNlcyA8IDApIHtcbiAgICBwbGFjZXMgPSAwO1xuICB9XG5cbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coMTAsIHBsYWNlcyk7XG5cbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogc2NhbGUpIC8gc2NhbGU7XG59O1xuXG4vKipcbiAqIEEgU291cmNlQnVmZmVyIGltcGxlbWVudGF0aW9uIGZvciBGbGFzaCByYXRoZXIgdGhhbiBIVE1MLlxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IG1lZGlhU291cmNlIHRoZSBmbGFzaCBtZWRpYSBzb3VyY2VcbiAqIEBjbGFzcyBGbGFzaFNvdXJjZUJ1ZmZlclxuICogQGV4dGVuZHMgdmlkZW9qcy5FdmVudFRhcmdldFxuICovXG5cbnZhciBGbGFzaFNvdXJjZUJ1ZmZlciA9IChmdW5jdGlvbiAoX3ZpZGVvanMkRXZlbnRUYXJnZXQpIHtcbiAgX2luaGVyaXRzKEZsYXNoU291cmNlQnVmZmVyLCBfdmlkZW9qcyRFdmVudFRhcmdldCk7XG5cbiAgZnVuY3Rpb24gRmxhc2hTb3VyY2VCdWZmZXIobWVkaWFTb3VyY2UpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZsYXNoU291cmNlQnVmZmVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEZsYXNoU291cmNlQnVmZmVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgdmFyIGVuY29kZWRIZWFkZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBTdGFydCBvZmYgdXNpbmcgdGhlIGdsb2JhbGx5IGRlZmluZWQgdmFsdWUgYnV0IHJlZmluZVxuICAgIC8vIGFzIHdlIGFwcGVuZCBkYXRhIGludG8gZmxhc2hcbiAgICB0aGlzLmNodW5rU2l6ZV8gPSBfZmxhc2hDb25zdGFudHMyWydkZWZhdWx0J10uQllURVNfUEVSX0NIVU5LO1xuXG4gICAgLy8gYnl0ZSBhcnJheXMgcXVldWVkIHRvIGJlIGFwcGVuZGVkXG4gICAgdGhpcy5idWZmZXJfID0gW107XG5cbiAgICAvLyB0aGUgdG90YWwgbnVtYmVyIG9mIHF1ZXVlZCBieXRlc1xuICAgIHRoaXMuYnVmZmVyU2l6ZV8gPSAwO1xuXG4gICAgLy8gdG8gYmUgYWJsZSB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgcG9zaXRpb24gdG8gc2VlayB0bywgd2VcbiAgICAvLyBuZWVkIHRvIHJldGFpbiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbWFwcGluZyBiZXR3ZWVuIHRoZVxuICAgIC8vIG1lZGlhIHRpbWVsaW5lIGFuZCBQVFMgdmFsdWVzXG4gICAgdGhpcy5iYXNlUHRzT2Zmc2V0XyA9IE5hTjtcblxuICAgIHRoaXMubWVkaWFTb3VyY2VfID0gbWVkaWFTb3VyY2U7XG5cbiAgICB0aGlzLmF1ZGlvQnVmZmVyRW5kXyA9IE5hTjtcbiAgICB0aGlzLnZpZGVvQnVmZmVyRW5kXyA9IE5hTjtcblxuICAgIC8vIGluZGljYXRlcyB3aGV0aGVyIHRoZSBhc3luY2hyb25vdXMgY29udGludWF0aW9uIG9mIGFuIG9wZXJhdGlvblxuICAgIC8vIGlzIHN0aWxsIGJlaW5nIHByb2Nlc3NlZFxuICAgIC8vIHNlZSBodHRwczovL3czYy5naXRodWIuaW8vbWVkaWEtc291cmNlLyN3aWRsLVNvdXJjZUJ1ZmZlci11cGRhdGluZ1xuICAgIHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnRpbWVzdGFtcE9mZnNldF8gPSAwO1xuXG4gICAgZW5jb2RlZEhlYWRlciA9IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKF9tdXhKc0xpYkZsdjJbJ2RlZmF1bHQnXS5nZXRGbHZIZWFkZXIoKSkpKTtcblxuICAgIC8vIGNyZWF0ZSBmdW5jdGlvbiBuYW1lcyB3aXRoIGFkZGVkIHJhbmRvbW5lc3MgZm9yIHRoZSBnbG9iYWwgY2FsbGJhY2tzIGZsYXNoIHdpbGwgdXNlXG4gICAgLy8gdG8gZ2V0IGRhdGEgZnJvbSBqYXZhc2NyaXB0IGludG8gdGhlIHN3Zi4gUmFuZG9tIHN0cmluZ3MgYXJlIGFkZGVkIGFzIGEgc2FmZXR5XG4gICAgLy8gbWVhc3VyZSBmb3IgcGFnZXMgd2l0aCBtdWx0aXBsZSBwbGF5ZXJzIHNpbmNlIHRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGdsb2JhbFxuICAgIC8vIGluc3RlYWQgb2YgcGVyIGluc3RhbmNlLiBXaGVuIG1ha2luZyBhIGNhbGwgdG8gdGhlIHN3ZiwgdGhlIGJyb3dzZXIgZ2VuZXJhdGVzIGFcbiAgICAvLyB0cnkgY2F0Y2ggY29kZSBzbmlwcGV0LCBidXQganVzdCB0YWtlcyB0aGUgZnVuY3Rpb24gbmFtZSBhbmQgd3JpdGVzIG91dCBhbiB1bnF1b3RlZFxuICAgIC8vIGNhbGwgdG8gdGhhdCBmdW5jdGlvbi4gSWYgdGhlIHBsYXllciBpZCBoYXMgYW55IHNwZWNpYWwgY2hhcmFjdGVycywgdGhpcyB3aWxsIHJlc3VsdFxuICAgIC8vIGluIGFuIGVycm9yLCBzbyBzYWZlUGxheWVySWQgcmVwbGFjZXMgYWxsIHNwZWNpYWwgY2hhcmFjdGVycyB0byAnXydcbiAgICB2YXIgc2FmZVBsYXllcklkID0gdGhpcy5tZWRpYVNvdXJjZV8ucGxheWVyXy5pZCgpLnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCAnXycpO1xuXG4gICAgdGhpcy5mbGFzaEVuY29kZWRIZWFkZXJOYW1lXyA9ICd2anNfZmxhc2hFbmNvZGVkSGVhZGVyXycgKyBzYWZlUGxheWVySWQgKyBnZW5lcmF0ZVJhbmRvbVN0cmluZygpO1xuICAgIHRoaXMuZmxhc2hFbmNvZGVkRGF0YU5hbWVfID0gJ3Zqc19mbGFzaEVuY29kZWREYXRhXycgKyBzYWZlUGxheWVySWQgKyBnZW5lcmF0ZVJhbmRvbVN0cmluZygpO1xuXG4gICAgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXVt0aGlzLmZsYXNoRW5jb2RlZEhlYWRlck5hbWVfXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlbGV0ZSBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddW190aGlzLmZsYXNoRW5jb2RlZEhlYWRlck5hbWVfXTtcbiAgICAgIHJldHVybiBlbmNvZGVkSGVhZGVyO1xuICAgIH07XG5cbiAgICB0aGlzLm1lZGlhU291cmNlXy5zd2ZPYmoudmpzX2FwcGVuZENodW5rUmVhZHkodGhpcy5mbGFzaEVuY29kZWRIZWFkZXJOYW1lXyk7XG5cbiAgICB0aGlzLnRyYW5zbXV4ZXJfID0gKDAsIF93ZWJ3b3JraWZ5MlsnZGVmYXVsdCddKShfZmxhc2hUcmFuc211eGVyV29ya2VyMlsnZGVmYXVsdCddKTtcbiAgICB0aGlzLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiAnaW5pdCcsIG9wdGlvbnM6IHt9IH0pO1xuICAgIHRoaXMudHJhbnNtdXhlcl8ub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGF0YS5hY3Rpb24gPT09ICdkYXRhJykge1xuICAgICAgICBfdGhpcy5yZWNlaXZlQnVmZmVyXyhldmVudC5kYXRhLnNlZ21lbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uZSgndXBkYXRlZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMubWVkaWFTb3VyY2VfLnRlY2hfLnRyaWdnZXIoJ2xvYWRlZG1ldGFkYXRhJyk7XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcE9mZnNldCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXBPZmZzZXRfO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgdmFsID49IDApIHtcbiAgICAgICAgICB0aGlzLnRpbWVzdGFtcE9mZnNldF8gPSB2YWw7XG4gICAgICAgICAgLy8gV2UgaGF2ZSB0byB0ZWxsIGZsYXNoIHRvIGV4cGVjdCBhIGRpc2NvbnRpbnVpdHlcbiAgICAgICAgICB0aGlzLm1lZGlhU291cmNlXy5zd2ZPYmoudmpzX2Rpc2NvbnRpbnVpdHkoKTtcbiAgICAgICAgICAvLyB0aGUgbWVkaWEgPC0+IFBUUyBtYXBwaW5nIG11c3QgYmUgcmUtZXN0YWJsaXNoZWQgYWZ0ZXJcbiAgICAgICAgICAvLyB0aGUgZGlzY29udGludWl0eVxuICAgICAgICAgIHRoaXMuYmFzZVB0c09mZnNldF8gPSBOYU47XG4gICAgICAgICAgdGhpcy5hdWRpb0J1ZmZlckVuZF8gPSBOYU47XG4gICAgICAgICAgdGhpcy52aWRlb0J1ZmZlckVuZF8gPSBOYU47XG5cbiAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiAncmVzZXQnIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2J1ZmZlcmVkJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5tZWRpYVNvdXJjZV8gfHwgIXRoaXMubWVkaWFTb3VyY2VfLnN3Zk9iaiB8fCAhKCd2anNfZ2V0UHJvcGVydHknIGluIHRoaXMubWVkaWFTb3VyY2VfLnN3Zk9iaikpIHtcbiAgICAgICAgICByZXR1cm4gX3ZpZGVvSnMyWydkZWZhdWx0J10uY3JlYXRlVGltZVJhbmdlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLm1lZGlhU291cmNlXy5zd2ZPYmoudmpzX2dldFByb3BlcnR5KCdidWZmZXJlZCcpO1xuXG4gICAgICAgIGlmIChidWZmZXJlZCAmJiBidWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgICBidWZmZXJlZFswXVswXSA9IHRvRGVjaW1hbFBsYWNlcyhidWZmZXJlZFswXVswXSwgMyk7XG4gICAgICAgICAgYnVmZmVyZWRbMF1bMV0gPSB0b0RlY2ltYWxQbGFjZXMoYnVmZmVyZWRbMF1bMV0sIDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdmlkZW9KczJbJ2RlZmF1bHQnXS5jcmVhdGVUaW1lUmFuZ2VzKGJ1ZmZlcmVkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIE9uIGEgc2VlayB3ZSByZW1vdmUgYWxsIHRleHQgdHJhY2sgZGF0YSBzaW5jZSBmbGFzaCBoYXMgbm8gY29uY2VwdFxuICAgIC8vIG9mIGEgYnVmZmVyZWQtcmFuZ2UgYW5kIGV2ZXJ5dGhpbmcgZWxzZSBpcyByZXNldCBvbiBzZWVrXG4gICAgdGhpcy5tZWRpYVNvdXJjZV8ucGxheWVyXy5vbignc2Vla2VkJywgZnVuY3Rpb24gKCkge1xuICAgICAgKDAsIF9yZW1vdmVDdWVzRnJvbVRyYWNrMlsnZGVmYXVsdCddKSgwLCBJbmZpbml0eSwgX3RoaXMubWV0YWRhdGFUcmFja18pO1xuICAgICAgaWYgKF90aGlzLmluYmFuZFRleHRUcmFja3NfKSB7XG4gICAgICAgIGZvciAodmFyIHRyYWNrIGluIF90aGlzLmluYmFuZFRleHRUcmFja3NfKSB7XG4gICAgICAgICAgKDAsIF9yZW1vdmVDdWVzRnJvbVRyYWNrMlsnZGVmYXVsdCddKSgwLCBJbmZpbml0eSwgX3RoaXMuaW5iYW5kVGV4dFRyYWNrc19bdHJhY2tdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIG9uSGxzUmVzZXQgPSB0aGlzLm9uSGxzUmVzZXRfLmJpbmQodGhpcyk7XG5cbiAgICAvLyBobHMtcmVzZXQgaXMgZmlyZWQgYnkgdmlkZW9qcy5IbHMgb24gdG8gdGhlIHRlY2ggYWZ0ZXIgdGhlIG1haW4gU2VnbWVudExvYWRlclxuICAgIC8vIHJlc2V0cyBpdHMgc3RhdGUgYW5kIGZsdXNoZXMgdGhlIGJ1ZmZlclxuICAgIHRoaXMubWVkaWFTb3VyY2VfLnBsYXllcl8udGVjaF8ub24oJ2hscy1yZXNldCcsIG9uSGxzUmVzZXQpO1xuXG4gICAgdGhpcy5tZWRpYVNvdXJjZV8ucGxheWVyXy50ZWNoXy5obHMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy50cmFuc211eGVyXy50ZXJtaW5hdGUoKTtcbiAgICAgIF90aGlzLm1lZGlhU291cmNlXy5wbGF5ZXJfLnRlY2hfLm9mZignaGxzLXJlc2V0Jywgb25IbHNSZXNldCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kIGJ5dGVzIHRvIHRoZSBzb3VyY2VidWZmZXJzIGJ1ZmZlciwgaW4gdGhpcyBjYXNlIHdlXG4gICAqIGhhdmUgdG8gYXBwZW5kIGl0IHRvIHN3ZiBvYmplY3QuXG4gICAqXG4gICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Tb3VyY2VCdWZmZXIvYXBwZW5kQnVmZmVyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJ5dGVzXG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhGbGFzaFNvdXJjZUJ1ZmZlciwgW3tcbiAgICBrZXk6ICdhcHBlbmRCdWZmZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRCdWZmZXIoYnl0ZXMpIHtcbiAgICAgIHZhciBlcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ1NvdXJjZUJ1ZmZlci5hcHBlbmQoKSBjYW5ub3QgYmUgY2FsbGVkICcgKyAnd2hpbGUgYW4gdXBkYXRlIGlzIGluIHByb2dyZXNzJyk7XG4gICAgICAgIGVycm9yLm5hbWUgPSAnSW52YWxpZFN0YXRlRXJyb3InO1xuICAgICAgICBlcnJvci5jb2RlID0gMTE7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGluZyA9IHRydWU7XG4gICAgICB0aGlzLm1lZGlhU291cmNlXy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3VwZGF0ZScgfSk7XG5cbiAgICAgIHRoaXMudHJhbnNtdXhlcl8ucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBhY3Rpb246ICdwdXNoJyxcbiAgICAgICAgZGF0YTogYnl0ZXMuYnVmZmVyLFxuICAgICAgICBieXRlT2Zmc2V0OiBieXRlcy5ieXRlT2Zmc2V0LFxuICAgICAgICBieXRlTGVuZ3RoOiBieXRlcy5ieXRlTGVuZ3RoXG4gICAgICB9LCBbYnl0ZXMuYnVmZmVyXSk7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiAnZmx1c2gnIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBwYXJzZXIgYW5kIHJlbW92ZSBhbnkgZGF0YSBxdWV1ZWQgdG8gYmUgc2VudCB0byB0aGUgU1dGLlxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NvdXJjZUJ1ZmZlci9hYm9ydFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnYWJvcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIHRoaXMuYnVmZmVyXyA9IFtdO1xuICAgICAgdGhpcy5idWZmZXJTaXplXyA9IDA7XG4gICAgICB0aGlzLm1lZGlhU291cmNlXy5zd2ZPYmoudmpzX2Fib3J0KCk7XG5cbiAgICAgIC8vIHJlcG9ydCBhbnkgb3V0c3RhbmRpbmcgdXBkYXRlcyBoYXZlIGVuZGVkXG4gICAgICBpZiAodGhpcy51cGRhdGluZykge1xuICAgICAgICB0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICd1cGRhdGVlbmQnIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXNoIGNhbm5vdCByZW1vdmUgcmFuZ2VzIGFscmVhZHkgYnVmZmVyZWQgaW4gdGhlIE5ldFN0cmVhbVxuICAgICAqIGJ1dCBzZWVraW5nIGNsZWFycyB0aGUgYnVmZmVyIGVudGlyZWx5LiBGb3IgbW9zdCBwdXJwb3NlcyxcbiAgICAgKiBoYXZpbmcgdGhpcyBvcGVyYXRpb24gYWN0IGFzIGEgbm8tb3AgaXMgYWNjZXB0YWJsZS5cbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Tb3VyY2VCdWZmZXIvcmVtb3ZlXG4gICAgICogQHBhcmFtIHtEb3VibGV9IHN0YXJ0IHN0YXJ0IG9mIHRoZSBzZWN0aW9uIHRvIHJlbW92ZVxuICAgICAqIEBwYXJhbSB7RG91YmxlfSBlbmQgZW5kIG9mIHRoZSBzZWN0aW9uIHRvIHJlbW92ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICgwLCBfcmVtb3ZlQ3Vlc0Zyb21UcmFjazJbJ2RlZmF1bHQnXSkoc3RhcnQsIGVuZCwgdGhpcy5tZXRhZGF0YVRyYWNrXyk7XG4gICAgICBpZiAodGhpcy5pbmJhbmRUZXh0VHJhY2tzXykge1xuICAgICAgICBmb3IgKHZhciB0cmFjayBpbiB0aGlzLmluYmFuZFRleHRUcmFja3NfKSB7XG4gICAgICAgICAgKDAsIF9yZW1vdmVDdWVzRnJvbVRyYWNrMlsnZGVmYXVsdCddKShzdGFydCwgZW5kLCB0aGlzLmluYmFuZFRleHRUcmFja3NfW3RyYWNrXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICd1cGRhdGUnIH0pO1xuICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3VwZGF0ZWVuZCcgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjZWl2ZSBhIGJ1ZmZlciBmcm9tIHRoZSBmbHYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZWNlaXZlQnVmZmVyXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2VpdmVCdWZmZXJfKHNlZ21lbnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBjcmVhdGUgYW4gaW4tYmFuZCBjYXB0aW9uIHRyYWNrIGlmIG9uZSBpcyBwcmVzZW50IGluIHRoZSBzZWdtZW50XG4gICAgICAoMCwgX2NyZWF0ZVRleHRUcmFja3NJZk5lY2Vzc2FyeTJbJ2RlZmF1bHQnXSkodGhpcywgdGhpcy5tZWRpYVNvdXJjZV8sIHNlZ21lbnQpO1xuICAgICAgKDAsIF9hZGRUZXh0VHJhY2tEYXRhLmFkZFRleHRUcmFja0RhdGEpKHRoaXMsIHNlZ21lbnQuY2FwdGlvbnMsIHNlZ21lbnQubWV0YWRhdGEpO1xuXG4gICAgICAvLyBEbyB0aGlzIGFzeW5jaHJvbm91c2x5IHNpbmNlIGNvbnZlcnRUYWdzVG9EYXRhXyBjYW4gYmUgdGltZSBjb25zdW1pbmdcbiAgICAgIHNjaGVkdWxlVGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmbHZCeXRlcyA9IF90aGlzMi5jb252ZXJ0VGFnc1RvRGF0YV8oc2VnbWVudCk7XG5cbiAgICAgICAgaWYgKF90aGlzMi5idWZmZXJfLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHNjaGVkdWxlVGljayhfdGhpczIucHJvY2Vzc0J1ZmZlcl8uYmluZChfdGhpczIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbHZCeXRlcykge1xuICAgICAgICAgIF90aGlzMi5idWZmZXJfLnB1c2goZmx2Qnl0ZXMpO1xuICAgICAgICAgIF90aGlzMi5idWZmZXJTaXplXyArPSBmbHZCeXRlcy5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgYSBwb3J0aW9uIG9mIHRoZSBjdXJyZW50IGJ1ZmZlciB0byB0aGUgU1dGLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3NCdWZmZXJfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0J1ZmZlcl8oKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGNodW5rU2l6ZSA9IF9mbGFzaENvbnN0YW50czJbJ2RlZmF1bHQnXS5CWVRFU19QRVJfQ0hVTks7XG5cbiAgICAgIGlmICghdGhpcy5idWZmZXJfLmxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3VwZGF0ZWVuZCcgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG8gbm90aGluZyBpZiB0aGUgYnVmZmVyIGlzIGVtcHR5XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY29uY2F0ZW5hdGUgYXBwZW5kcyB1cCB0byB0aGUgbWF4IGFwcGVuZCBzaXplXG4gICAgICB2YXIgY2h1bmsgPSB0aGlzLmJ1ZmZlcl9bMF0uc3ViYXJyYXkoMCwgY2h1bmtTaXplKTtcblxuICAgICAgLy8gcmVxdWV1ZSBhbnkgYnl0ZXMgdGhhdCB3b24ndCBtYWtlIGl0IHRoaXMgcm91bmRcbiAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoIDwgY2h1bmtTaXplIHx8IHRoaXMuYnVmZmVyX1swXS5ieXRlTGVuZ3RoID09PSBjaHVua1NpemUpIHtcbiAgICAgICAgdGhpcy5idWZmZXJfLnNoaWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJ1ZmZlcl9bMF0gPSB0aGlzLmJ1ZmZlcl9bMF0uc3ViYXJyYXkoY2h1bmtTaXplKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWZmZXJTaXplXyAtPSBjaHVuay5ieXRlTGVuZ3RoO1xuXG4gICAgICAvLyBiYXNlNjQgZW5jb2RlIHRoZSBieXRlc1xuICAgICAgdmFyIGJpbmFyeSA9IFtdO1xuICAgICAgdmFyIGxlbmd0aCA9IGNodW5rLmJ5dGVMZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmluYXJ5LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjaHVua1tpXSkpO1xuICAgICAgfVxuICAgICAgdmFyIGI2NHN0ciA9IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uYnRvYShiaW5hcnkuam9pbignJykpO1xuXG4gICAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddW3RoaXMuZmxhc2hFbmNvZGVkRGF0YU5hbWVfXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gc2NoZWR1bGUgYW5vdGhlciBwcm9jZXNzQnVmZmVyIHRvIHByb2Nlc3MgYW55IGxlZnQgb3ZlciBkYXRhIG9yIHRvXG4gICAgICAgIC8vIHRyaWdnZXIgdXBkYXRlZW5kXG4gICAgICAgIHNjaGVkdWxlVGljayhfdGhpczMucHJvY2Vzc0J1ZmZlcl8uYmluZChfdGhpczMpKTtcbiAgICAgICAgZGVsZXRlIF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J11bX3RoaXMzLmZsYXNoRW5jb2RlZERhdGFOYW1lX107XG4gICAgICAgIHJldHVybiBiNjRzdHI7XG4gICAgICB9O1xuXG4gICAgICAvLyBOb3RpZnkgdGhlIHN3ZiB0aGF0IHNlZ21lbnQgZGF0YSBpcyByZWFkeSB0byBiZSBhcHBlbmRlZFxuICAgICAgdGhpcy5tZWRpYVNvdXJjZV8uc3dmT2JqLnZqc19hcHBlbmRDaHVua1JlYWR5KHRoaXMuZmxhc2hFbmNvZGVkRGF0YU5hbWVfKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUdXJucyBhbiBhcnJheSBvZiBmbHYgdGFncyBpbnRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlXG4gICAgICogZmx2IGRhdGEuIEFsc28gcmVtb3ZlcyBhbnkgdGFncyB0aGF0IGFyZSBiZWZvcmUgdGhlIGN1cnJlbnRcbiAgICAgKiB0aW1lIHNvIHRoYXQgcGxheWJhY2sgYmVnaW5zIGF0IG9yIHNsaWdodGx5IGFmdGVyIHRoZSByaWdodFxuICAgICAqIHBsYWNlIG9uIGEgc2Vla1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2VnbWVudERhdGEgb2JqZWN0IG9mIHNlZ21lbnQgZGF0YVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY29udmVydFRhZ3NUb0RhdGFfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udmVydFRhZ3NUb0RhdGFfKHNlZ21lbnREYXRhKSB7XG4gICAgICB2YXIgc2VnbWVudEJ5dGVMZW5ndGggPSAwO1xuICAgICAgdmFyIHRlY2ggPSB0aGlzLm1lZGlhU291cmNlXy50ZWNoXztcbiAgICAgIHZhciB2aWRlb1RhcmdldFB0cyA9IDA7XG4gICAgICB2YXIgc2VnbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciB2aWRlb1RhZ3MgPSBzZWdtZW50RGF0YS50YWdzLnZpZGVvVGFncztcbiAgICAgIHZhciBhdWRpb1RhZ3MgPSBzZWdtZW50RGF0YS50YWdzLmF1ZGlvVGFncztcblxuICAgICAgLy8gRXN0YWJsaXNoIHRoZSBtZWRpYSB0aW1lbGluZSB0byBQVFMgdHJhbnNsYXRpb24gaWYgd2UgZG9uJ3RcbiAgICAgIC8vIGhhdmUgb25lIGFscmVhZHlcbiAgICAgIGlmIChpc05hTih0aGlzLmJhc2VQdHNPZmZzZXRfKSAmJiAodmlkZW9UYWdzLmxlbmd0aCB8fCBhdWRpb1RhZ3MubGVuZ3RoKSkge1xuICAgICAgICAvLyBXZSBrbm93IHRoZXJlIGlzIGF0IGxlYXN0IG9uZSB2aWRlbyBvciBhdWRpbyB0YWcsIGJ1dCBzaW5jZSB3ZSBtYXkgbm90IGhhdmUgYm90aCxcbiAgICAgICAgLy8gd2UgdXNlIHB0czogSW5maW5pdHkgZm9yIHRoZSBtaXNzaW5nIHRhZy4gVGhlIHdpbGwgZm9yY2UgdGhlIGZvbGxvd2luZyBNYXRoLm1pblxuICAgICAgICAvLyBjYWxsIHdpbGwgdG8gdXNlIHRoZSBwcm9wZXIgcHRzIHZhbHVlIHNpbmNlIGl0IHdpbGwgYWx3YXlzIGJlIGxlc3MgdGhhbiBJbmZpbml0eVxuICAgICAgICB2YXIgZmlyc3RWaWRlb1RhZyA9IHZpZGVvVGFnc1swXSB8fCB7IHB0czogSW5maW5pdHkgfTtcbiAgICAgICAgdmFyIGZpcnN0QXVkaW9UYWcgPSBhdWRpb1RhZ3NbMF0gfHwgeyBwdHM6IEluZmluaXR5IH07XG5cbiAgICAgICAgdGhpcy5iYXNlUHRzT2Zmc2V0XyA9IE1hdGgubWluKGZpcnN0QXVkaW9UYWcucHRzLCBmaXJzdFZpZGVvVGFnLnB0cyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZWNoLnNlZWtpbmcoKSkge1xuICAgICAgICAvLyBEbyBub3QgdXNlIHByZXZpb3VzbHkgc2F2ZWQgYnVmZmVyIGVuZCB2YWx1ZXMgd2hpbGUgc2Vla2luZyBzaW5jZSBidWZmZXJcbiAgICAgICAgLy8gaXMgY2xlYXJlZCBvbiBhbGwgc2Vla3NcbiAgICAgICAgdGhpcy52aWRlb0J1ZmZlckVuZF8gPSBOYU47XG4gICAgICAgIHRoaXMuYXVkaW9CdWZmZXJFbmRfID0gTmFOO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOYU4odGhpcy52aWRlb0J1ZmZlckVuZF8pKSB7XG4gICAgICAgIGlmICh0ZWNoLmJ1ZmZlcmVkKCkubGVuZ3RoKSB7XG4gICAgICAgICAgdmlkZW9UYXJnZXRQdHMgPSB0ZWNoLmJ1ZmZlcmVkKCkuZW5kKDApIC0gdGhpcy50aW1lc3RhbXBPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmltIHRvIGN1cnJlbnRUaW1lIGlmIHNlZWtpbmdcbiAgICAgICAgaWYgKHRlY2guc2Vla2luZygpKSB7XG4gICAgICAgICAgdmlkZW9UYXJnZXRQdHMgPSBNYXRoLm1heCh2aWRlb1RhcmdldFB0cywgdGVjaC5jdXJyZW50VGltZSgpIC0gdGhpcy50aW1lc3RhbXBPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUFRTIHZhbHVlcyBhcmUgcmVwcmVzZW50ZWQgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgIHZpZGVvVGFyZ2V0UHRzICo9IDFlMztcbiAgICAgICAgdmlkZW9UYXJnZXRQdHMgKz0gdGhpcy5iYXNlUHRzT2Zmc2V0XztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBhIGZ1ZGdlIGZhY3RvciBvZiAwLjEgdG8gdGhlIGxhc3QgdmlkZW8gcHRzIGFwcGVuZGVkIHNpbmNlIGEgcmVuZGl0aW9uIGNoYW5nZVxuICAgICAgICAvLyBjb3VsZCBhcHBlbmQgYW4gb3ZlcmxhcHBpbmcgc2VnbWVudCwgaW4gd2hpY2ggY2FzZSB0aGVyZSBpcyBhIGhpZ2ggbGlrZWx5aG9vZFxuICAgICAgICAvLyBhIHRhZyBjb3VsZCBoYXZlIGEgbWF0Y2hpbmcgcHRzIHRvIHZpZGVvQnVmZmVyRW5kXywgd2hpY2ggd291bGQgY2F1c2VcbiAgICAgICAgLy8gdGhhdCB0YWcgdG8gZ2V0IGFwcGVuZGVkIGJ5IHRoZSB0YWcucHRzID49IHRhcmdldFB0cyBjaGVjayBiZWxvdyBldmVuIHRob3VnaCBpdFxuICAgICAgICAvLyBpcyBhIGR1cGxpY2F0ZSBvZiB3aGF0IHdhcyBwcmV2aW91c2x5IGFwcGVuZGVkXG4gICAgICAgIHZpZGVvVGFyZ2V0UHRzID0gdGhpcy52aWRlb0J1ZmZlckVuZF8gKyAwLjE7XG4gICAgICB9XG5cbiAgICAgIC8vIGZpbHRlciBjb21wbGV0ZSBHT1BzIHdpdGggYSBwcmVzZW50YXRpb24gdGltZSBsZXNzIHRoYW4gdGhlIHNlZWsgdGFyZ2V0L2VuZCBvZiBidWZmZXJcbiAgICAgIHZhciBjdXJyZW50SW5kZXggPSB2aWRlb1RhZ3MubGVuZ3RoO1xuXG4gICAgICAvLyBpZiB0aGUgbGFzdCB0YWcgaXMgYmV5b25kIHZpZGVvVGFyZ2V0UHRzLCB0aGVuIGRvIG5vdCBzZWFyY2ggdGhlIGxpc3QgZm9yIGEgR09QXG4gICAgICAvLyBzaW5jZSBvdXIgdmlkZW9UYXJnZXRQdHMgbGllcyBpbiBhIGZ1dHVyZSBzZWdtZW50XG4gICAgICBpZiAoY3VycmVudEluZGV4ICYmIHZpZGVvVGFnc1tjdXJyZW50SW5kZXggLSAxXS5wdHMgPj0gdmlkZW9UYXJnZXRQdHMpIHtcbiAgICAgICAgLy8gU3RhcnQgYnkgd2Fsa2luZyBiYWNrd2FyZHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBsaXN0IHVudGlsIHdlIHJlYWNoIGEgdGFnIHRoYXRcbiAgICAgICAgLy8gaXMgZXF1YWwgdG8gb3IgbGVzcyB0aGFuIHZpZGVvVGFyZ2V0UHRzXG4gICAgICAgIHdoaWxlICgtLWN1cnJlbnRJbmRleCkge1xuICAgICAgICAgIHZhciBjdXJyZW50VGFnID0gdmlkZW9UYWdzW2N1cnJlbnRJbmRleF07XG5cbiAgICAgICAgICBpZiAoY3VycmVudFRhZy5wdHMgPiB2aWRlb1RhcmdldFB0cykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgd2Ugc2VlIGEga2V5RnJhbWUgb3IgbWV0YWRhdGEgdGFnIG9uY2Ugd2UndmUgZ29uZSBiZWxvdyB2aWRlb1RhcmdldFB0cyxcbiAgICAgICAgICAvLyBleGl0IHRoZSBsb29wIGFzIHRoaXMgaXMgdGhlIHN0YXJ0IG9mIHRoZSBHT1AgdGhhdCB3ZSB3YW50IHRvIGFwcGVuZFxuICAgICAgICAgIGlmIChjdXJyZW50VGFnLmtleUZyYW1lIHx8IGN1cnJlbnRUYWcubWV0YURhdGFUYWcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBtZXRhZGF0YSB0YWdzIHRoYXQgY29tZSBiZWZvcmUgY3VycmVudEluZGV4XG4gICAgICAgIC8vIGFzIHRob3NlIHdpbGwgYmUgbWV0YWRhdGEgdGFncyBhc3NvY2lhdGVkIHdpdGggdGhlIEdPUCB3ZSBhcmUgYXBwZW5kaW5nXG4gICAgICAgIC8vIFRoZXJlIGNvdWxkIGJlIDAgdG8gMiBtZXRhZGF0YSB0YWdzIHRoYXQgY29tZSBiZWZvcmUgdGhlIGN1cnJlbnRJbmRleCBkZXBlbmRpbmdcbiAgICAgICAgLy8gb24gd2hhdCB2aWRlb1RhcmdldFB0cyBpcyBhbmQgd2hldGhlciB0aGUgdHJhbnNtdXhlciBwcmVwZW5kZWQgbWV0YWRhdGEgdGFncyB0byB0aGlzXG4gICAgICAgIC8vIGtleSBmcmFtZVxuICAgICAgICB3aGlsZSAoY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgdmFyIG5leHRUYWcgPSB2aWRlb1RhZ3NbY3VycmVudEluZGV4IC0gMV07XG5cbiAgICAgICAgICBpZiAoIW5leHRUYWcubWV0YURhdGFUYWcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRJbmRleC0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWx0ZXJlZFZpZGVvVGFncyA9IHZpZGVvVGFncy5zbGljZShjdXJyZW50SW5kZXgpO1xuXG4gICAgICB2YXIgYXVkaW9UYXJnZXRQdHMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpc05hTih0aGlzLmF1ZGlvQnVmZmVyRW5kXykpIHtcbiAgICAgICAgYXVkaW9UYXJnZXRQdHMgPSB2aWRlb1RhcmdldFB0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBhIGZ1ZGdlIGZhY3RvciBvZiAwLjEgdG8gdGhlIGxhc3QgdmlkZW8gcHRzIGFwcGVuZGVkIHNpbmNlIGEgcmVuZGl0aW9uIGNoYW5nZVxuICAgICAgICAvLyBjb3VsZCBhcHBlbmQgYW4gb3ZlcmxhcHBpbmcgc2VnbWVudCwgaW4gd2hpY2ggY2FzZSB0aGVyZSBpcyBhIGhpZ2ggbGlrZWx5aG9vZFxuICAgICAgICAvLyBhIHRhZyBjb3VsZCBoYXZlIGEgbWF0Y2hpbmcgcHRzIHRvIHZpZGVvQnVmZmVyRW5kXywgd2hpY2ggd291bGQgY2F1c2VcbiAgICAgICAgLy8gdGhhdCB0YWcgdG8gZ2V0IGFwcGVuZGVkIGJ5IHRoZSB0YWcucHRzID49IHRhcmdldFB0cyBjaGVjayBiZWxvdyBldmVuIHRob3VnaCBpdFxuICAgICAgICAvLyBpcyBhIGR1cGxpY2F0ZSBvZiB3aGF0IHdhcyBwcmV2aW91c2x5IGFwcGVuZGVkXG4gICAgICAgIGF1ZGlvVGFyZ2V0UHRzID0gdGhpcy5hdWRpb0J1ZmZlckVuZF8gKyAwLjE7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWx0ZXJlZFZpZGVvVGFncy5sZW5ndGgpIHtcbiAgICAgICAgLy8gSWYgdGFyZ2V0UHRzIGludGVyc2VjdHMgYSBHT1AgYW5kIHdlIGFwcGVuZGVkIHRoZSB0YWdzIGZvciB0aGUgR09QIHRoYXQgY2FtZVxuICAgICAgICAvLyBiZWZvcmUgdGFyZ2V0UHRzLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0byB0cmltIGF1ZGlvIHRhZ3MgYXQgdGhlIHB0c1xuICAgICAgICAvLyBvZiB0aGUgZmlyc3QgdmlkZW8gdGFnIHRvIGF2b2lkIGJyaWVmIG1vbWVudHMgb2Ygc2lsZW5jZVxuICAgICAgICBhdWRpb1RhcmdldFB0cyA9IE1hdGgubWluKGF1ZGlvVGFyZ2V0UHRzLCBmaWx0ZXJlZFZpZGVvVGFnc1swXS5wdHMpO1xuICAgICAgfVxuXG4gICAgICAvLyBza2lwIHRhZ3Mgd2l0aCBhIHByZXNlbnRhdGlvbiB0aW1lIGxlc3MgdGhhbiB0aGUgc2VlayB0YXJnZXQvZW5kIG9mIGJ1ZmZlclxuICAgICAgY3VycmVudEluZGV4ID0gMDtcblxuICAgICAgd2hpbGUgKGN1cnJlbnRJbmRleCA8IGF1ZGlvVGFncy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGF1ZGlvVGFnc1tjdXJyZW50SW5kZXhdLnB0cyA+PSBhdWRpb1RhcmdldFB0cykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudEluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWx0ZXJlZEF1ZGlvVGFncyA9IGF1ZGlvVGFncy5zbGljZShjdXJyZW50SW5kZXgpO1xuXG4gICAgICAvLyB1cGRhdGUgdGhlIGF1ZGlvIGFuZCB2aWRlbyBidWZmZXIgZW5kc1xuICAgICAgaWYgKGZpbHRlcmVkQXVkaW9UYWdzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmF1ZGlvQnVmZmVyRW5kXyA9IGZpbHRlcmVkQXVkaW9UYWdzW2ZpbHRlcmVkQXVkaW9UYWdzLmxlbmd0aCAtIDFdLnB0cztcbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXJlZFZpZGVvVGFncy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy52aWRlb0J1ZmZlckVuZF8gPSBmaWx0ZXJlZFZpZGVvVGFnc1tmaWx0ZXJlZFZpZGVvVGFncy5sZW5ndGggLSAxXS5wdHM7XG4gICAgICB9XG5cbiAgICAgIHZhciB0YWdzID0gdGhpcy5nZXRPcmRlcmVkVGFnc18oZmlsdGVyZWRWaWRlb1RhZ3MsIGZpbHRlcmVkQXVkaW9UYWdzKTtcblxuICAgICAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgYXJlIGFwcGVuZGluZyBkYXRhIHRoYXQgY29tZXMgYmVmb3JlIG91ciB0YXJnZXQgcHRzLCB3ZSB3YW50IHRvIHRlbGxcbiAgICAgIC8vIHRoZSBzd2YgdG8gYWRqdXN0IGl0cyBub3Rpb24gb2YgY3VycmVudCB0aW1lIHRvIGFjY291bnQgZm9yIHRoZSBleHRyYSB0YWdzXG4gICAgICAvLyB3ZSBhcmUgYXBwZW5kaW5nIHRvIGNvbXBsZXRlIHRoZSBHT1AgdGhhdCBpbnRlcnNlY3RzIHdpdGggdGFyZ2V0UHRzXG4gICAgICBpZiAodGFnc1swXS5wdHMgPCB2aWRlb1RhcmdldFB0cyAmJiB0ZWNoLnNlZWtpbmcoKSkge1xuICAgICAgICB2YXIgZnVkZ2VGYWN0b3IgPSAxIC8gMzA7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IHRlY2guY3VycmVudFRpbWUoKTtcbiAgICAgICAgdmFyIGRpZmYgPSAodmlkZW9UYXJnZXRQdHMgLSB0YWdzWzBdLnB0cykgLyAxZTM7XG4gICAgICAgIHZhciBhZGp1c3RlZFRpbWUgPSBjdXJyZW50VGltZSAtIGRpZmY7XG5cbiAgICAgICAgaWYgKGFkanVzdGVkVGltZSA8IGZ1ZGdlRmFjdG9yKSB7XG4gICAgICAgICAgYWRqdXN0ZWRUaW1lID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5tZWRpYVNvdXJjZV8uc3dmT2JqLnZqc19hZGp1c3RDdXJyZW50VGltZShhZGp1c3RlZFRpbWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gbm8tb3AgZm9yIGJhY2t3YXJkcyBjb21wYXRhYmlsaXR5IG9mIHN3Zi4gSWYgYWRqdXN0Q3VycmVudFRpbWUgZmFpbHMsXG4gICAgICAgICAgLy8gdGhlIHN3ZiBtYXkgaW5jb3JyZWN0bHkgcmVwb3J0IGN1cnJlbnRUaW1lIGFuZCBidWZmZXJlZCByYW5nZXNcbiAgICAgICAgICAvLyBidXQgc2hvdWxkIG5vdCBhZmZlY3QgcGxheWJhY2sgb3ZlciB0aGFuIHRoZSB0aW1lIGRpc3BsYXllZCBvbiB0aGVcbiAgICAgICAgICAvLyBwcm9ncmVzcyBiYXIgaXMgaW5hY2N1cmF0ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbmNhdGVuYXRlIHRoZSBieXRlcyBpbnRvIGEgc2luZ2xlIHNlZ21lbnRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWdtZW50Qnl0ZUxlbmd0aCArPSB0YWdzW2ldLmJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICBzZWdtZW50ID0gbmV3IFVpbnQ4QXJyYXkoc2VnbWVudEJ5dGVMZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgdGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWdtZW50LnNldCh0YWdzW2ldLmJ5dGVzLCBqKTtcbiAgICAgICAgaiArPSB0YWdzW2ldLmJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2VtYmxlIHRoZSBGTFYgdGFncyBpbiBkZWNvZGVyIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2aWRlb1RhZ3MgbGlzdCBvZiB2aWRlbyB0YWdzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXVkaW9UYWdzIGxpc3Qgb2YgYXVkaW8gdGFnc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZ2V0T3JkZXJlZFRhZ3NfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3JkZXJlZFRhZ3NfKHZpZGVvVGFncywgYXVkaW9UYWdzKSB7XG4gICAgICB2YXIgdGFnID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIHRhZ3MgPSBbXTtcblxuICAgICAgd2hpbGUgKHZpZGVvVGFncy5sZW5ndGggfHwgYXVkaW9UYWdzLmxlbmd0aCkge1xuICAgICAgICBpZiAoIXZpZGVvVGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBvbmx5IGF1ZGlvIHRhZ3MgcmVtYWluXG4gICAgICAgICAgdGFnID0gYXVkaW9UYWdzLnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWF1ZGlvVGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBvbmx5IHZpZGVvIHRhZ3MgcmVtYWluXG4gICAgICAgICAgdGFnID0gdmlkZW9UYWdzLnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXVkaW9UYWdzWzBdLmR0cyA8IHZpZGVvVGFnc1swXS5kdHMpIHtcbiAgICAgICAgICAvLyBhdWRpbyBzaG91bGQgYmUgZGVjb2RlZCBuZXh0XG4gICAgICAgICAgdGFnID0gYXVkaW9UYWdzLnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdmlkZW8gc2hvdWxkIGJlIGRlY29kZWQgbmV4dFxuICAgICAgICAgIHRhZyA9IHZpZGVvVGFncy5zaGlmdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFncy5wdXNoKHRhZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YWdzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uSGxzUmVzZXRfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25IbHNSZXNldF8oKSB7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiAncmVzZXRDYXB0aW9ucycgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZsYXNoU291cmNlQnVmZmVyO1xufSkoX3ZpZGVvSnMyWydkZWZhdWx0J10uRXZlbnRUYXJnZXQpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBGbGFzaFNvdXJjZUJ1ZmZlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4vYWRkLXRleHQtdHJhY2stZGF0YVwiOjY0LFwiLi9jcmVhdGUtdGV4dC10cmFja3MtaWYtbmVjZXNzYXJ5XCI6NjYsXCIuL2ZsYXNoLWNvbnN0YW50c1wiOjY3LFwiLi9mbGFzaC10cmFuc211eGVyLXdvcmtlclwiOjcwLFwiLi9yZW1vdmUtY3Vlcy1mcm9tLXRyYWNrXCI6NzIsXCJnbG9iYWwvd2luZG93XCI6MzIsXCJtdXguanMvbGliL2ZsdlwiOjQ2LFwid2Vid29ya2lmeVwiOjc2fV0sNzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSBmbGFzaC10cmFuc211eGVyLXdvcmtlci5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgX2dsb2JhbFdpbmRvdyA9IHJlcXVpcmUoJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIF9nbG9iYWxXaW5kb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsV2luZG93KTtcblxudmFyIF9tdXhKc0xpYkZsdiA9IHJlcXVpcmUoJ211eC5qcy9saWIvZmx2Jyk7XG5cbnZhciBfbXV4SnNMaWJGbHYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbXV4SnNMaWJGbHYpO1xuXG4vKipcbiAqIFJlLWVtaXRzIHRyYW5zbXV4ZXIgZXZlbnRzIGJ5IGNvbnZlcnRpbmcgdGhlbSBpbnRvIG1lc3NhZ2VzIHRvIHRoZVxuICogd29ybGQgb3V0c2lkZSB0aGUgd29ya2VyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc211eGVyIHRoZSB0cmFuc211eGVyIHRvIHdpcmUgZXZlbnRzIG9uXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgd2lyZVRyYW5zbXV4ZXJFdmVudHMgPSBmdW5jdGlvbiB3aXJlVHJhbnNtdXhlckV2ZW50cyh0cmFuc211eGVyKSB7XG4gIHRyYW5zbXV4ZXIub24oJ2RhdGEnLCBmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgIF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10ucG9zdE1lc3NhZ2Uoe1xuICAgICAgYWN0aW9uOiAnZGF0YScsXG4gICAgICBzZWdtZW50OiBzZWdtZW50XG4gICAgfSk7XG4gIH0pO1xuXG4gIHRyYW5zbXV4ZXIub24oJ2RvbmUnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10ucG9zdE1lc3NhZ2UoeyBhY3Rpb246ICdkb25lJyB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFsbCBpbmNvbWluZyBtZXNzYWdlcyByb3V0ZSB0aHJvdWdoIHRoaXMgaGFzaC4gSWYgbm8gZnVuY3Rpb24gZXhpc3RzXG4gKiB0byBoYW5kbGUgYW4gaW5jb21pbmcgbWVzc2FnZSwgdGhlbiB3ZSBpZ25vcmUgdGhlIG1lc3NhZ2UuXG4gKlxuICogQGNsYXNzIE1lc3NhZ2VIYW5kbGVyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gaW5pdGlhbGl6ZSB3aXRoXG4gKi9cblxudmFyIE1lc3NhZ2VIYW5kbGVycyA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1lc3NhZ2VIYW5kbGVycyhvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lc3NhZ2VIYW5kbGVycyk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE91ciB3ZWIgd3Jva2VyIGludGVyZmFjZSBzbyB0aGF0IHRoaW5ncyBjYW4gdGFsayB0byBtdXguanNcbiAgICogdGhhdCB3aWxsIGJlIHJ1bm5pbmcgaW4gYSB3ZWIgd29ya2VyLiBUaGUgc2NvcGUgaXMgcGFzc2VkIHRvIHRoaXMgYnlcbiAgICogd2Vid29ya2lmeS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlbGYgdGhlIHNjb3BlIGZvciB0aGUgd2ViIHdvcmtlclxuICAgKi9cblxuICAvKipcbiAgICogaW5pdGlhbGl6ZSBvdXIgd2ViIHdvcmtlciBhbmQgd2lyZSBhbGwgdGhlIGV2ZW50cy5cbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKE1lc3NhZ2VIYW5kbGVycywgW3tcbiAgICBrZXk6ICdpbml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIGlmICh0aGlzLnRyYW5zbXV4ZXIpIHtcbiAgICAgICAgdGhpcy50cmFuc211eGVyLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNtdXhlciA9IG5ldyBfbXV4SnNMaWJGbHYyWydkZWZhdWx0J10uVHJhbnNtdXhlcih0aGlzLm9wdGlvbnMpO1xuICAgICAgd2lyZVRyYW5zbXV4ZXJFdmVudHModGhpcy50cmFuc211eGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGRhdGEgKGEgdHMgc2VnbWVudCkgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0cmFuc211eGVyIHBpcGVsaW5lIGZvclxuICAgICAqIHByb2Nlc3NpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhIGRhdGEgdG8gcHVzaCBpbnRvIHRoZSBtdXhlclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncHVzaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2goZGF0YSkge1xuICAgICAgLy8gQ2FzdCBhcnJheSBidWZmZXIgdG8gY29ycmVjdCB0eXBlIGZvciB0cmFuc211eGVyXG4gICAgICB2YXIgc2VnbWVudCA9IG5ldyBVaW50OEFycmF5KGRhdGEuZGF0YSwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gICAgICB0aGlzLnRyYW5zbXV4ZXIucHVzaChzZWdtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNyZWF0ZSB0aGUgdHJhbnNtdXhlciBzbyB0aGF0IHRoZSBuZXh0IHNlZ21lbnQgYWRkZWQgdmlhIGBwdXNoYFxuICAgICAqIHN0YXJ0IHdpdGggYSBmcmVzaCB0cmFuc211eGVyLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcmNlcyB0aGUgcGlwZWxpbmUgdG8gZmluaXNoIHByb2Nlc3NpbmcgdGhlIGxhc3Qgc2VnbWVudCBhbmQgZW1pdCBpdHNcbiAgICAgKiByZXN1bHRzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZmx1c2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgIHRoaXMudHJhbnNtdXhlci5mbHVzaCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0Q2FwdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldENhcHRpb25zKCkge1xuICAgICAgdGhpcy50cmFuc211eGVyLnJlc2V0Q2FwdGlvbnMoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWVzc2FnZUhhbmRsZXJzO1xufSkoKTtcblxudmFyIEZsYXNoVHJhbnNtdXhlcldvcmtlciA9IGZ1bmN0aW9uIEZsYXNoVHJhbnNtdXhlcldvcmtlcihzZWxmKSB7XG4gIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmRhdGEuYWN0aW9uID09PSAnaW5pdCcgJiYgZXZlbnQuZGF0YS5vcHRpb25zKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVycyA9IG5ldyBNZXNzYWdlSGFuZGxlcnMoZXZlbnQuZGF0YS5vcHRpb25zKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubWVzc2FnZUhhbmRsZXJzKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVycyA9IG5ldyBNZXNzYWdlSGFuZGxlcnMoKTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLmFjdGlvbiAmJiBldmVudC5kYXRhLmFjdGlvbiAhPT0gJ2luaXQnKSB7XG4gICAgICBpZiAodGhpcy5tZXNzYWdlSGFuZGxlcnNbZXZlbnQuZGF0YS5hY3Rpb25dKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzW2V2ZW50LmRhdGEuYWN0aW9uXShldmVudC5kYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoc2VsZikge1xuICByZXR1cm4gbmV3IEZsYXNoVHJhbnNtdXhlcldvcmtlcihzZWxmKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSx7XCJnbG9iYWwvd2luZG93XCI6MzIsXCJtdXguanMvbGliL2ZsdlwiOjQ2fV0sNzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBAZmlsZSBodG1sLW1lZGlhLXNvdXJjZS5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfZ2xvYmFsV2luZG93ID0gcmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgX2dsb2JhbFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxXaW5kb3cpO1xuXG52YXIgX2dsb2JhbERvY3VtZW50ID0gcmVxdWlyZSgnZ2xvYmFsL2RvY3VtZW50Jyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsRG9jdW1lbnQpO1xuXG52YXIgX3ZpZGVvSnMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sndmlkZW9qcyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndmlkZW9qcyddIDogbnVsbCk7XG5cbnZhciBfdmlkZW9KczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aWRlb0pzKTtcblxudmFyIF92aXJ0dWFsU291cmNlQnVmZmVyID0gcmVxdWlyZSgnLi92aXJ0dWFsLXNvdXJjZS1idWZmZXInKTtcblxudmFyIF92aXJ0dWFsU291cmNlQnVmZmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpcnR1YWxTb3VyY2VCdWZmZXIpO1xuXG52YXIgX2FkZFRleHRUcmFja0RhdGEgPSByZXF1aXJlKCcuL2FkZC10ZXh0LXRyYWNrLWRhdGEnKTtcblxudmFyIF9jb2RlY1V0aWxzID0gcmVxdWlyZSgnLi9jb2RlYy11dGlscycpO1xuXG4vKipcbiAqIE91ciBNZWRpYVNvdXJjZSBpbXBsZW1lbnRhdGlvbiBpbiBIVE1MLCBtaW1pY3MgbmF0aXZlXG4gKiBNZWRpYVNvdXJjZSB3aGVyZS9pZiBwb3NzaWJsZS5cbiAqXG4gKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFTb3VyY2VcbiAqIEBjbGFzcyBIdG1sTWVkaWFTb3VyY2VcbiAqIEBleHRlbmRzIHZpZGVvanMuRXZlbnRUYXJnZXRcbiAqL1xuXG52YXIgSHRtbE1lZGlhU291cmNlID0gKGZ1bmN0aW9uIChfdmlkZW9qcyRFdmVudFRhcmdldCkge1xuICBfaW5oZXJpdHMoSHRtbE1lZGlhU291cmNlLCBfdmlkZW9qcyRFdmVudFRhcmdldCk7XG5cbiAgZnVuY3Rpb24gSHRtbE1lZGlhU291cmNlKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSHRtbE1lZGlhU291cmNlKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEh0bWxNZWRpYVNvdXJjZS5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIHZhciBwcm9wZXJ0eSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMubmF0aXZlTWVkaWFTb3VyY2VfID0gbmV3IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uTWVkaWFTb3VyY2UoKTtcbiAgICAvLyBkZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIE1lZGlhU291cmNlJ3MgbWV0aG9kcyBieSBkZWZhdWx0XG4gICAgZm9yIChwcm9wZXJ0eSBpbiB0aGlzLm5hdGl2ZU1lZGlhU291cmNlXykge1xuICAgICAgaWYgKCEocHJvcGVydHkgaW4gSHRtbE1lZGlhU291cmNlLnByb3RvdHlwZSkgJiYgdHlwZW9mIHRoaXMubmF0aXZlTWVkaWFTb3VyY2VfW3Byb3BlcnR5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IHRoaXMubmF0aXZlTWVkaWFTb3VyY2VfW3Byb3BlcnR5XS5iaW5kKHRoaXMubmF0aXZlTWVkaWFTb3VyY2VfKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlbXVsYXRlIGBkdXJhdGlvbmAgYW5kIGBzZWVrYWJsZWAgdW50aWwgc2Vla2luZyBjYW4gYmVcbiAgICAvLyBoYW5kbGVkIHVuaWZvcm1seSBmb3IgbGl2ZSBzdHJlYW1zXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvbWVkaWEtc291cmNlL2lzc3Vlcy81XG4gICAgdGhpcy5kdXJhdGlvbl8gPSBOYU47XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdkdXJhdGlvbicsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5kdXJhdGlvbl8gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHVyYXRpb25fO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZU1lZGlhU291cmNlXy5kdXJhdGlvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChkdXJhdGlvbikge1xuICAgICAgICB0aGlzLmR1cmF0aW9uXyA9IGR1cmF0aW9uO1xuICAgICAgICBpZiAoZHVyYXRpb24gIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgdGhpcy5uYXRpdmVNZWRpYVNvdXJjZV8uZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NlZWthYmxlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmR1cmF0aW9uXyA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXR1cm4gX3ZpZGVvSnMyWydkZWZhdWx0J10uY3JlYXRlVGltZVJhbmdlcyhbWzAsIHRoaXMubmF0aXZlTWVkaWFTb3VyY2VfLmR1cmF0aW9uXV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZU1lZGlhU291cmNlXy5zZWVrYWJsZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVhZHlTdGF0ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVNZWRpYVNvdXJjZV8ucmVhZHlTdGF0ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYWN0aXZlU291cmNlQnVmZmVycycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVTb3VyY2VCdWZmZXJzXztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHRoZSBsaXN0IG9mIHZpcnR1YWwgYW5kIG5hdGl2ZSBTb3VyY2VCdWZmZXJzIGNyZWF0ZWQgYnkgdGhpc1xuICAgIC8vIE1lZGlhU291cmNlXG4gICAgdGhpcy5zb3VyY2VCdWZmZXJzID0gW107XG5cbiAgICB0aGlzLmFjdGl2ZVNvdXJjZUJ1ZmZlcnNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgdGhlIGxpc3Qgb2YgYWN0aXZlIHNvdXJjZSBidWZmZXJzIGJhc2VkIHVwb24gdmFyaW91c1xuICAgICAqIGltZm9ybWF0aW9uIGZyb20gSExTIGFuZCB2aWRlby5qc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZUFjdGl2ZVNvdXJjZUJ1ZmZlcnNfID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gUmV0YWluIHRoZSByZWZlcmVuY2UgYnV0IGVtcHR5IHRoZSBhcnJheVxuICAgICAgX3RoaXMuYWN0aXZlU291cmNlQnVmZmVyc18ubGVuZ3RoID0gMDtcblxuICAgICAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgc291cmNlIGJ1ZmZlciwgdGhlbiBpdCB3aWxsIGFsd2F5cyBiZSBhY3RpdmUgYW5kIGF1ZGlvIHdpbGxcbiAgICAgIC8vIGJlIGRpc2FibGVkIGJhc2VkIG9uIHRoZSBjb2RlYyBvZiB0aGUgc291cmNlIGJ1ZmZlclxuICAgICAgaWYgKF90aGlzLnNvdXJjZUJ1ZmZlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBzb3VyY2VCdWZmZXIgPSBfdGhpcy5zb3VyY2VCdWZmZXJzWzBdO1xuXG4gICAgICAgIHNvdXJjZUJ1ZmZlci5hcHBlbmRBdWRpb0luaXRTZWdtZW50XyA9IHRydWU7XG4gICAgICAgIHNvdXJjZUJ1ZmZlci5hdWRpb0Rpc2FibGVkXyA9ICFzb3VyY2VCdWZmZXIuYXVkaW9Db2RlY187XG4gICAgICAgIF90aGlzLmFjdGl2ZVNvdXJjZUJ1ZmZlcnNfLnB1c2goc291cmNlQnVmZmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGVyZSBhcmUgMiBzb3VyY2UgYnVmZmVycywgYSBjb21iaW5lZCAocG9zc2libHkgdmlkZW8gb25seSkgc291cmNlIGJ1ZmZlciBhbmRcbiAgICAgIC8vIGFuZCBhbiBhdWRpbyBvbmx5IHNvdXJjZSBidWZmZXIuXG4gICAgICAvLyBCeSBkZWZhdWx0LCB0aGUgYXVkaW8gaW4gdGhlIGNvbWJpbmVkIHZpcnR1YWwgc291cmNlIGJ1ZmZlciBpcyBlbmFibGVkXG4gICAgICAvLyBhbmQgdGhlIGF1ZGlvLW9ubHkgc291cmNlIGJ1ZmZlciAoaWYgaXQgZXhpc3RzKSBpcyBkaXNhYmxlZC5cbiAgICAgIHZhciBkaXNhYmxlQ29tYmluZWQgPSBmYWxzZTtcbiAgICAgIHZhciBkaXNhYmxlQXVkaW9Pbmx5ID0gdHJ1ZTtcblxuICAgICAgLy8gVE9ETzogbWF5YmUgd2UgY2FuIHN0b3JlIHRoZSBzb3VyY2VidWZmZXJzIG9uIHRoZSB0cmFjayBvYmplY3RzP1xuICAgICAgLy8gc2FmYXJpIG1heSBkbyBzb21ldGhpbmcgbGlrZSB0aGlzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLnBsYXllcl8uYXVkaW9UcmFja3MoKS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHJhY2sgPSBfdGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzKClbaV07XG5cbiAgICAgICAgaWYgKHRyYWNrLmVuYWJsZWQgJiYgdHJhY2sua2luZCAhPT0gJ21haW4nKSB7XG4gICAgICAgICAgLy8gVGhlIGVuYWJsZWQgdHJhY2sgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrIHNvIGRpc2FibGUgdGhlIGF1ZGlvIGluXG4gICAgICAgICAgLy8gdGhlIGNvbWJpbmVkIHNvdXJjZSBidWZmZXIgYW5kIGVuYWJsZSB0aGUgYXVkaW8tb25seSBzb3VyY2UgYnVmZmVyLlxuICAgICAgICAgIGRpc2FibGVDb21iaW5lZCA9IHRydWU7XG4gICAgICAgICAgZGlzYWJsZUF1ZGlvT25seSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlQnVmZmVyKSB7XG4gICAgICAgIC8qIGVzbGluc3QtZGlzYWJsZSAqL1xuICAgICAgICAvLyBUT0RPIG9uY2UgY29kZWNzIGFyZSByZXF1aXJlZCwgd2UgY2FuIHN3aXRjaCB0byB1c2luZyB0aGUgY29kZWNzIHRvIGRldGVybWluZVxuICAgICAgICAvLyAgICAgIHdoYXQgc3RyZWFtIGlzIHRoZSB2aWRlbyBzdHJlYW0sIHJhdGhlciB0aGFuIHJlbHlpbmcgb24gdmlkZW9UcmFja3NcbiAgICAgICAgLyogZXNsaW5zdC1lbmFibGUgKi9cblxuICAgICAgICBzb3VyY2VCdWZmZXIuYXBwZW5kQXVkaW9Jbml0U2VnbWVudF8gPSB0cnVlO1xuXG4gICAgICAgIGlmIChzb3VyY2VCdWZmZXIudmlkZW9Db2RlY18gJiYgc291cmNlQnVmZmVyLmF1ZGlvQ29kZWNfKSB7XG4gICAgICAgICAgLy8gY29tYmluZWRcbiAgICAgICAgICBzb3VyY2VCdWZmZXIuYXVkaW9EaXNhYmxlZF8gPSBkaXNhYmxlQ29tYmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlQnVmZmVyLnZpZGVvQ29kZWNfICYmICFzb3VyY2VCdWZmZXIuYXVkaW9Db2RlY18pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgXCJjb21iaW5lZFwiIHNvdXJjZSBidWZmZXIgaXMgdmlkZW8gb25seSwgdGhlbiB3ZSBkbyBub3Qgd2FudFxuICAgICAgICAgIC8vIGRpc2FibGUgdGhlIGF1ZGlvLW9ubHkgc291cmNlIGJ1ZmZlciAodGhpcyBpcyBtb3N0bHkgZm9yIGRlbXV4ZWRcbiAgICAgICAgICAvLyBhdWRpbyBhbmQgdmlkZW8gaGxzKVxuICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hdWRpb0Rpc2FibGVkXyA9IHRydWU7XG4gICAgICAgICAgZGlzYWJsZUF1ZGlvT25seSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCFzb3VyY2VCdWZmZXIudmlkZW9Db2RlY18gJiYgc291cmNlQnVmZmVyLmF1ZGlvQ29kZWNfKSB7XG4gICAgICAgICAgLy8gYXVkaW8gb25seVxuICAgICAgICAgIHNvdXJjZUJ1ZmZlci5hdWRpb0Rpc2FibGVkXyA9IGRpc2FibGVBdWRpb09ubHk7XG4gICAgICAgICAgaWYgKGRpc2FibGVBdWRpb09ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5hY3RpdmVTb3VyY2VCdWZmZXJzXy5wdXNoKHNvdXJjZUJ1ZmZlcik7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblBsYXllck1lZGlhY2hhbmdlXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlQnVmZmVyKSB7XG4gICAgICAgIHNvdXJjZUJ1ZmZlci5hcHBlbmRBdWRpb0luaXRTZWdtZW50XyA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5vbkhsc1Jlc2V0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlQnVmZmVyKSB7XG4gICAgICAgIGlmIChzb3VyY2VCdWZmZXIudHJhbnNtdXhlcl8pIHtcbiAgICAgICAgICBzb3VyY2VCdWZmZXIudHJhbnNtdXhlcl8ucG9zdE1lc3NhZ2UoeyBhY3Rpb246ICdyZXNldENhcHRpb25zJyB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMub25IbHNTZWdtZW50VGltZU1hcHBpbmdfID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBfdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gYnVmZmVyLnRpbWVNYXBwaW5nXyA9IGV2ZW50Lm1hcHBpbmc7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gUmUtZW1pdCBNZWRpYVNvdXJjZSBldmVudHMgb24gdGhlIHBvbHlmaWxsXG4gICAgWydzb3VyY2VvcGVuJywgJ3NvdXJjZWNsb3NlJywgJ3NvdXJjZWVuZGVkJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICB0aGlzLm5hdGl2ZU1lZGlhU291cmNlXy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdGhpcy50cmlnZ2VyLmJpbmQodGhpcykpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8gY2FwdHVyZSB0aGUgYXNzb2NpYXRlZCBwbGF5ZXIgd2hlbiB0aGUgTWVkaWFTb3VyY2UgaXNcbiAgICAvLyBzdWNjZXNzZnVsbHkgYXR0YWNoZWRcbiAgICB0aGlzLm9uKCdzb3VyY2VvcGVuJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAvLyBHZXQgdGhlIHBsYXllciB0aGlzIE1lZGlhU291cmNlIGlzIGF0dGFjaGVkIHRvXG4gICAgICB2YXIgdmlkZW8gPSBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10ucXVlcnlTZWxlY3RvcignW3NyYz1cIicgKyBfdGhpcy51cmxfICsgJ1wiXScpO1xuXG4gICAgICBpZiAoIXZpZGVvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMucGxheWVyXyA9ICgwLCBfdmlkZW9KczJbJ2RlZmF1bHQnXSkodmlkZW8ucGFyZW50Tm9kZSk7XG5cbiAgICAgIC8vIGhscy1yZXNldCBpcyBmaXJlZCBieSB2aWRlb2pzLkhscyBvbiB0byB0aGUgdGVjaCBhZnRlciB0aGUgbWFpbiBTZWdtZW50TG9hZGVyXG4gICAgICAvLyByZXNldHMgaXRzIHN0YXRlIGFuZCBmbHVzaGVzIHRoZSBidWZmZXJcbiAgICAgIF90aGlzLnBsYXllcl8udGVjaF8ub24oJ2hscy1yZXNldCcsIF90aGlzLm9uSGxzUmVzZXRfKTtcbiAgICAgIC8vIGhscy1zZWdtZW50LXRpbWUtbWFwcGluZyBpcyBmaXJlZCBieSB2aWRlb2pzLkhscyBvbiB0byB0aGUgdGVjaCBhZnRlciB0aGUgbWFpblxuICAgICAgLy8gU2VnbWVudExvYWRlciBpbnNwZWN0cyBhbiBNVFMgc2VnbWVudCBhbmQgaGFzIGFuIGFjY3VyYXRlIHN0cmVhbSB0byBkaXNwbGF5XG4gICAgICAvLyB0aW1lIG1hcHBpbmdcbiAgICAgIF90aGlzLnBsYXllcl8udGVjaF8ub24oJ2hscy1zZWdtZW50LXRpbWUtbWFwcGluZycsIF90aGlzLm9uSGxzU2VnbWVudFRpbWVNYXBwaW5nXyk7XG5cbiAgICAgIGlmIChfdGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzICYmIF90aGlzLnBsYXllcl8uYXVkaW9UcmFja3MoKSkge1xuICAgICAgICBfdGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzKCkub24oJ2NoYW5nZScsIF90aGlzLnVwZGF0ZUFjdGl2ZVNvdXJjZUJ1ZmZlcnNfKTtcbiAgICAgICAgX3RoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpLm9uKCdhZGR0cmFjaycsIF90aGlzLnVwZGF0ZUFjdGl2ZVNvdXJjZUJ1ZmZlcnNfKTtcbiAgICAgICAgX3RoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpLm9uKCdyZW1vdmV0cmFjaycsIF90aGlzLnVwZGF0ZUFjdGl2ZVNvdXJjZUJ1ZmZlcnNfKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMucGxheWVyXy5vbignbWVkaWFjaGFuZ2UnLCBfdGhpcy5vblBsYXllck1lZGlhY2hhbmdlXyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdzb3VyY2VlbmRlZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGR1cmF0aW9uID0gKDAsIF9hZGRUZXh0VHJhY2tEYXRhLmR1cmF0aW9uT2ZWaWRlbykoX3RoaXMuZHVyYXRpb24pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLnNvdXJjZUJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZWJ1ZmZlciA9IF90aGlzLnNvdXJjZUJ1ZmZlcnNbaV07XG4gICAgICAgIHZhciBjdWVzID0gc291cmNlYnVmZmVyLm1ldGFkYXRhVHJhY2tfICYmIHNvdXJjZWJ1ZmZlci5tZXRhZGF0YVRyYWNrXy5jdWVzO1xuXG4gICAgICAgIGlmIChjdWVzICYmIGN1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgY3Vlc1tjdWVzLmxlbmd0aCAtIDFdLmVuZFRpbWUgPSBkdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZXhwbGljaXRseSB0ZXJtaW5hdGUgYW55IFdlYldvcmtlcnMgdGhhdCB3ZXJlIGNyZWF0ZWRcbiAgICAvLyBieSBTb3VyY2VIYW5kbGVyc1xuICAgIHRoaXMub24oJ3NvdXJjZWNsb3NlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlQnVmZmVyKSB7XG4gICAgICAgIGlmIChzb3VyY2VCdWZmZXIudHJhbnNtdXhlcl8pIHtcbiAgICAgICAgICBzb3VyY2VCdWZmZXIudHJhbnNtdXhlcl8udGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMubGVuZ3RoID0gMDtcbiAgICAgIGlmICghdGhpcy5wbGF5ZXJfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucGxheWVyXy5hdWRpb1RyYWNrcyAmJiB0aGlzLnBsYXllcl8uYXVkaW9UcmFja3MoKSkge1xuICAgICAgICB0aGlzLnBsYXllcl8uYXVkaW9UcmFja3MoKS5vZmYoJ2NoYW5nZScsIHRoaXMudXBkYXRlQWN0aXZlU291cmNlQnVmZmVyc18pO1xuICAgICAgICB0aGlzLnBsYXllcl8uYXVkaW9UcmFja3MoKS5vZmYoJ2FkZHRyYWNrJywgdGhpcy51cGRhdGVBY3RpdmVTb3VyY2VCdWZmZXJzXyk7XG4gICAgICAgIHRoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpLm9mZigncmVtb3ZldHJhY2snLCB0aGlzLnVwZGF0ZUFjdGl2ZVNvdXJjZUJ1ZmZlcnNfKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgY2FuIG9ubHkgY2hhbmdlIHRoaXMgaWYgdGhlIHBsYXllciBoYXNuJ3QgYmVlbiBkaXNwb3NlZCBvZiB5ZXRcbiAgICAgIC8vIGJlY2F1c2UgYG9mZmAgZXZlbnR1YWxseSB0cmllcyB0byB1c2UgdGhlIGVsXyBwcm9wZXJ0eS4gSWYgaXQgaGFzXG4gICAgICAvLyBiZWVuIGRpc3Bvc2VkIG9mLCB0aGVuIGRvbid0IHdvcnJ5IGFib3V0IGl0IGJlY2F1c2UgdGhlcmUgYXJlIG5vXG4gICAgICAvLyBldmVudCBoYW5kbGVycyBsZWZ0IHRvIHVuYmluZCBhbnl3YXlcbiAgICAgIGlmICh0aGlzLnBsYXllcl8uZWxfKSB7XG4gICAgICAgIHRoaXMucGxheWVyXy5vZmYoJ21lZGlhY2hhbmdlJywgdGhpcy5vblBsYXllck1lZGlhY2hhbmdlXyk7XG4gICAgICAgIHRoaXMucGxheWVyXy50ZWNoXy5vZmYoJ2hscy1yZXNldCcsIHRoaXMub25IbHNSZXNldF8pO1xuICAgICAgICB0aGlzLnBsYXllcl8udGVjaF8ub2ZmKCdobHMtc2VnbWVudC10aW1lLW1hcHBpbmcnLCB0aGlzLm9uSGxzU2VnbWVudFRpbWVNYXBwaW5nXyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgcmFuZ2UgdGhhdCB0aGF0IGNhbiBub3cgYmUgc2Vla2VkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge0RvdWJsZX0gc3RhcnQgd2hlcmUgdG8gc3RhcnQgdGhlIGFkZGl0aW9uXG4gICAqIEBwYXJhbSB7RG91YmxlfSBlbmQgd2hlcmUgdG8gZW5kIHRoZSBhZGRpdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoSHRtbE1lZGlhU291cmNlLCBbe1xuICAgIGtleTogJ2FkZFNlZWthYmxlUmFuZ2VfJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU2Vla2FibGVSYW5nZV8oc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodGhpcy5kdXJhdGlvbiAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01lZGlhU291cmNlLmFkZFNlZWthYmxlUmFuZ2UoKSBjYW4gb25seSBiZSBpbnZva2VkICcgKyAnd2hlbiB0aGUgZHVyYXRpb24gaXMgSW5maW5pdHknKTtcbiAgICAgICAgZXJyb3IubmFtZSA9ICdJbnZhbGlkU3RhdGVFcnJvcic7XG4gICAgICAgIGVycm9yLmNvZGUgPSAxMTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPiB0aGlzLm5hdGl2ZU1lZGlhU291cmNlXy5kdXJhdGlvbiB8fCBpc05hTih0aGlzLm5hdGl2ZU1lZGlhU291cmNlXy5kdXJhdGlvbikpIHtcbiAgICAgICAgdGhpcy5uYXRpdmVNZWRpYVNvdXJjZV8uZHVyYXRpb24gPSBlbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgc291cmNlIGJ1ZmZlciB0byB0aGUgbWVkaWEgc291cmNlLlxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhU291cmNlL2FkZFNvdXJjZUJ1ZmZlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBjb250ZW50LXR5cGUgb2YgdGhlIGNvbnRlbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBjcmVhdGVkIHNvdXJjZSBidWZmZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2FkZFNvdXJjZUJ1ZmZlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNvdXJjZUJ1ZmZlcih0eXBlKSB7XG4gICAgICB2YXIgYnVmZmVyID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIHBhcnNlZFR5cGUgPSAoMCwgX2NvZGVjVXRpbHMucGFyc2VDb250ZW50VHlwZSkodHlwZSk7XG5cbiAgICAgIC8vIENyZWF0ZSBhIFZpcnR1YWxTb3VyY2VCdWZmZXIgdG8gdHJhbnNtdXggTVBFRy0yIHRyYW5zcG9ydFxuICAgICAgLy8gc3RyZWFtIHNlZ21lbnRzIGludG8gZnJhZ21lbnRlZCBNUDRzXG4gICAgICBpZiAoL14odmlkZW98YXVkaW8pXFwvbXAydCQvaS50ZXN0KHBhcnNlZFR5cGUudHlwZSkpIHtcbiAgICAgICAgdmFyIGNvZGVjcyA9IFtdO1xuXG4gICAgICAgIGlmIChwYXJzZWRUeXBlLnBhcmFtZXRlcnMgJiYgcGFyc2VkVHlwZS5wYXJhbWV0ZXJzLmNvZGVjcykge1xuICAgICAgICAgIGNvZGVjcyA9IHBhcnNlZFR5cGUucGFyYW1ldGVycy5jb2RlY3Muc3BsaXQoJywnKTtcbiAgICAgICAgICBjb2RlY3MgPSAoMCwgX2NvZGVjVXRpbHMudHJhbnNsYXRlTGVnYWN5Q29kZWNzKShjb2RlY3MpO1xuICAgICAgICAgIGNvZGVjcyA9IGNvZGVjcy5maWx0ZXIoZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9jb2RlY1V0aWxzLmlzQXVkaW9Db2RlYykoY29kZWMpIHx8ICgwLCBfY29kZWNVdGlscy5pc1ZpZGVvQ29kZWMpKGNvZGVjKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29kZWNzID0gWydhdmMxLjRkNDAwZCcsICdtcDRhLjQwLjInXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZlciA9IG5ldyBfdmlydHVhbFNvdXJjZUJ1ZmZlcjJbJ2RlZmF1bHQnXSh0aGlzLCBjb2RlY3MpO1xuXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZUJ1ZmZlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgLy8gSWYgYW5vdGhlciBWaXJ0dWFsU291cmNlQnVmZmVyIGFscmVhZHkgZXhpc3RzLCB0aGVuIHdlIGFyZSBjcmVhdGluZyBhXG4gICAgICAgICAgLy8gU291cmNlQnVmZmVyIGZvciBhbiBhbHRlcm5hdGUgYXVkaW8gdHJhY2sgYW5kIHRoZXJlZm9yZSB3ZSBrbm93IHRoYXRcbiAgICAgICAgICAvLyB0aGUgc291cmNlIGhhcyBib3RoIGFuIGF1ZGlvIGFuZCB2aWRlbyB0cmFjay5cbiAgICAgICAgICAvLyBUaGF0IG1lYW5zIHdlIHNob3VsZCB0cmlnZ2VyIHRoZSBtYW51YWwgY3JlYXRpb24gb2YgdGhlIHJlYWxcbiAgICAgICAgICAvLyBTb3VyY2VCdWZmZXJzIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIHRyYW5zbXV4ZXIgdG8gcmV0dXJuIGRhdGFcbiAgICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnNbMF0uY3JlYXRlUmVhbFNvdXJjZUJ1ZmZlcnNfKCk7XG4gICAgICAgICAgYnVmZmVyLmNyZWF0ZVJlYWxTb3VyY2VCdWZmZXJzXygpO1xuXG4gICAgICAgICAgLy8gQXV0b21hdGljYWxseSBkaXNhYmxlIHRoZSBhdWRpbyBvbiB0aGUgZmlyc3Qgc291cmNlIGJ1ZmZlciBpZlxuICAgICAgICAgIC8vIGEgc2Vjb25kIHNvdXJjZSBidWZmZXIgaXMgZXZlciBjcmVhdGVkXG4gICAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzWzBdLmF1ZGlvRGlzYWJsZWRfID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICBidWZmZXIgPSB0aGlzLm5hdGl2ZU1lZGlhU291cmNlXy5hZGRTb3VyY2VCdWZmZXIodHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc291cmNlQnVmZmVycy5wdXNoKGJ1ZmZlcik7XG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIdG1sTWVkaWFTb3VyY2U7XG59KShfdmlkZW9KczJbJ2RlZmF1bHQnXS5FdmVudFRhcmdldCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEh0bWxNZWRpYVNvdXJjZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4vYWRkLXRleHQtdHJhY2stZGF0YVwiOjY0LFwiLi9jb2RlYy11dGlsc1wiOjY1LFwiLi92aXJ0dWFsLXNvdXJjZS1idWZmZXJcIjo3NSxcImdsb2JhbC9kb2N1bWVudFwiOjMxLFwiZ2xvYmFsL3dpbmRvd1wiOjMyfV0sNzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAZmlsZSByZW1vdmUtY3Vlcy1mcm9tLXRyYWNrLmpzXG4gKi9cblxuLyoqXG4gKiBSZW1vdmUgY3VlcyBmcm9tIGEgdHJhY2sgb24gdmlkZW8uanMuXG4gKlxuICogQHBhcmFtIHtEb3VibGV9IHN0YXJ0IHN0YXJ0IG9mIHdoZXJlIHdlIHNob3VsZCByZW1vdmUgdGhlIGN1ZVxuICogQHBhcmFtIHtEb3VibGV9IGVuZCBlbmQgb2Ygd2hlcmUgdGhlIHdlIHNob3VsZCByZW1vdmUgdGhlIGN1ZVxuICogQHBhcmFtIHtPYmplY3R9IHRyYWNrIHRoZSB0ZXh0IHRyYWNrIHRvIHJlbW92ZSB0aGUgY3VlcyBmcm9tXG4gKiBAcHJpdmF0ZVxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciByZW1vdmVDdWVzRnJvbVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlQ3Vlc0Zyb21UcmFjayhzdGFydCwgZW5kLCB0cmFjaykge1xuICB2YXIgaSA9IHVuZGVmaW5lZDtcbiAgdmFyIGN1ZSA9IHVuZGVmaW5lZDtcblxuICBpZiAoIXRyYWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF0cmFjay5jdWVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaSA9IHRyYWNrLmN1ZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBjdWUgPSB0cmFjay5jdWVzW2ldO1xuXG4gICAgLy8gUmVtb3ZlIGFueSBvdmVybGFwcGluZyBjdWVcbiAgICBpZiAoY3VlLnN0YXJ0VGltZSA8PSBlbmQgJiYgY3VlLmVuZFRpbWUgPj0gc3RhcnQpIHtcbiAgICAgIHRyYWNrLnJlbW92ZUN1ZShjdWUpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSByZW1vdmVDdWVzRnJvbVRyYWNrO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcbn0se31dLDczOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGZpbGUgdHJhbnNtdXhlci13b3JrZXIuanNcbiAqL1xuXG4vKipcbiAqIHZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEJyaWdodGNvdmVcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogSGFuZGxlcyBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIGJyb3dzZXItd29ybGQgYW5kIHRoZSBtdXguanNcbiAqIHRyYW5zbXV4ZXIgcnVubmluZyBpbnNpZGUgb2YgYSBXZWJXb3JrZXIgYnkgZXhwb3NpbmcgYSBzaW1wbGVcbiAqIG1lc3NhZ2UtYmFzZWQgaW50ZXJmYWNlIHRvIGEgVHJhbnNtdXhlciBvYmplY3QuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBfZ2xvYmFsV2luZG93ID0gcmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgX2dsb2JhbFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxXaW5kb3cpO1xuXG52YXIgX211eEpzTGliTXA0ID0gcmVxdWlyZSgnbXV4LmpzL2xpYi9tcDQnKTtcblxudmFyIF9tdXhKc0xpYk1wNDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tdXhKc0xpYk1wNCk7XG5cbi8qKlxuICogUmUtZW1pdHMgdHJhbnNtdXhlciBldmVudHMgYnkgY29udmVydGluZyB0aGVtIGludG8gbWVzc2FnZXMgdG8gdGhlXG4gKiB3b3JsZCBvdXRzaWRlIHRoZSB3b3JrZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zbXV4ZXIgdGhlIHRyYW5zbXV4ZXIgdG8gd2lyZSBldmVudHMgb25cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB3aXJlVHJhbnNtdXhlckV2ZW50cyA9IGZ1bmN0aW9uIHdpcmVUcmFuc211eGVyRXZlbnRzKHRyYW5zbXV4ZXIpIHtcbiAgdHJhbnNtdXhlci5vbignZGF0YScsIGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgLy8gdHJhbnNmZXIgb3duZXJzaGlwIG9mIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyXG4gICAgLy8gaW5zdGVhZCBvZiBkb2luZyBhIGNvcHkgdG8gc2F2ZSBtZW1vcnlcbiAgICAvLyBBcnJheUJ1ZmZlcnMgYXJlIHRyYW5zZmVyYWJsZSBidXQgZ2VuZXJpYyBUeXBlZEFycmF5cyBhcmUgbm90XG4gICAgLy8gQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9Xb3JrZXJzX0FQSS9Vc2luZ193ZWJfd29ya2VycyNQYXNzaW5nX2RhdGFfYnlfdHJhbnNmZXJyaW5nX293bmVyc2hpcF8odHJhbnNmZXJhYmxlX29iamVjdHMpXG4gICAgdmFyIGluaXRBcnJheSA9IHNlZ21lbnQuaW5pdFNlZ21lbnQ7XG5cbiAgICBzZWdtZW50LmluaXRTZWdtZW50ID0ge1xuICAgICAgZGF0YTogaW5pdEFycmF5LmJ1ZmZlcixcbiAgICAgIGJ5dGVPZmZzZXQ6IGluaXRBcnJheS5ieXRlT2Zmc2V0LFxuICAgICAgYnl0ZUxlbmd0aDogaW5pdEFycmF5LmJ5dGVMZW5ndGhcbiAgICB9O1xuXG4gICAgdmFyIHR5cGVkQXJyYXkgPSBzZWdtZW50LmRhdGE7XG5cbiAgICBzZWdtZW50LmRhdGEgPSB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnBvc3RNZXNzYWdlKHtcbiAgICAgIGFjdGlvbjogJ2RhdGEnLFxuICAgICAgc2VnbWVudDogc2VnbWVudCxcbiAgICAgIGJ5dGVPZmZzZXQ6IHR5cGVkQXJyYXkuYnl0ZU9mZnNldCxcbiAgICAgIGJ5dGVMZW5ndGg6IHR5cGVkQXJyYXkuYnl0ZUxlbmd0aFxuICAgIH0sIFtzZWdtZW50LmRhdGFdKTtcbiAgfSk7XG5cbiAgaWYgKHRyYW5zbXV4ZXIuY2FwdGlvblN0cmVhbSkge1xuICAgIHRyYW5zbXV4ZXIuY2FwdGlvblN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjYXB0aW9uKSB7XG4gICAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgYWN0aW9uOiAnY2FwdGlvbicsXG4gICAgICAgIGRhdGE6IGNhcHRpb25cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgdHJhbnNtdXhlci5vbignZG9uZScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5wb3N0TWVzc2FnZSh7IGFjdGlvbjogJ2RvbmUnIH0pO1xuICB9KTtcblxuICB0cmFuc211eGVyLm9uKCdnb3BJbmZvJywgZnVuY3Rpb24gKGdvcEluZm8pIHtcbiAgICBfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLnBvc3RNZXNzYWdlKHtcbiAgICAgIGFjdGlvbjogJ2dvcEluZm8nLFxuICAgICAgZ29wSW5mbzogZ29wSW5mb1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogQWxsIGluY29taW5nIG1lc3NhZ2VzIHJvdXRlIHRocm91Z2ggdGhpcyBoYXNoLiBJZiBubyBmdW5jdGlvbiBleGlzdHNcbiAqIHRvIGhhbmRsZSBhbiBpbmNvbWluZyBtZXNzYWdlLCB0aGVuIHdlIGlnbm9yZSB0aGUgbWVzc2FnZS5cbiAqXG4gKiBAY2xhc3MgTWVzc2FnZUhhbmRsZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byBpbml0aWFsaXplIHdpdGhcbiAqL1xuXG52YXIgTWVzc2FnZUhhbmRsZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWVzc2FnZUhhbmRsZXJzKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVzc2FnZUhhbmRsZXJzKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogT3VyIHdlYiB3cm9rZXIgaW50ZXJmYWNlIHNvIHRoYXQgdGhpbmdzIGNhbiB0YWxrIHRvIG11eC5qc1xuICAgKiB0aGF0IHdpbGwgYmUgcnVubmluZyBpbiBhIHdlYiB3b3JrZXIuIHRoZSBzY29wZSBpcyBwYXNzZWQgdG8gdGhpcyBieVxuICAgKiB3ZWJ3b3JraWZ5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2VsZiB0aGUgc2NvcGUgZm9yIHRoZSB3ZWIgd29ya2VyXG4gICAqL1xuXG4gIC8qKlxuICAgKiBpbml0aWFsaXplIG91ciB3ZWIgd29ya2VyIGFuZCB3aXJlIGFsbCB0aGUgZXZlbnRzLlxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoTWVzc2FnZUhhbmRsZXJzLCBbe1xuICAgIGtleTogJ2luaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgaWYgKHRoaXMudHJhbnNtdXhlcikge1xuICAgICAgICB0aGlzLnRyYW5zbXV4ZXIuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc211eGVyID0gbmV3IF9tdXhKc0xpYk1wNDJbJ2RlZmF1bHQnXS5UcmFuc211eGVyKHRoaXMub3B0aW9ucyk7XG4gICAgICB3aXJlVHJhbnNtdXhlckV2ZW50cyh0aGlzLnRyYW5zbXV4ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgZGF0YSAoYSB0cyBzZWdtZW50KSB0byB0aGUgc3RhcnQgb2YgdGhlIHRyYW5zbXV4ZXIgcGlwZWxpbmUgZm9yXG4gICAgICogcHJvY2Vzc2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGEgZGF0YSB0byBwdXNoIGludG8gdGhlIG11eGVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdwdXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChkYXRhKSB7XG4gICAgICAvLyBDYXN0IGFycmF5IGJ1ZmZlciB0byBjb3JyZWN0IHR5cGUgZm9yIHRyYW5zbXV4ZXJcbiAgICAgIHZhciBzZWdtZW50ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5kYXRhLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgICAgIHRoaXMudHJhbnNtdXhlci5wdXNoKHNlZ21lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3JlYXRlIHRoZSB0cmFuc211eGVyIHNvIHRoYXQgdGhlIG5leHQgc2VnbWVudCBhZGRlZCB2aWEgYHB1c2hgXG4gICAgICogc3RhcnQgd2l0aCBhIGZyZXNoIHRyYW5zbXV4ZXIuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2YWx1ZSB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGUgYGJhc2VNZWRpYURlY29kZVRpbWVgIHRpbWUgZm9yIHRoZVxuICAgICAqIG5leHQgc2VnbWVudCBwdXNoZWQgaW4uIFN1YnNlcXVlbnQgc2VnbWVudHMgd2lsbCBoYXZlIHRoZWlyIGBiYXNlTWVkaWFEZWNvZGVUaW1lYFxuICAgICAqIHNldCByZWxhdGl2ZSB0byB0aGUgZmlyc3QgYmFzZWQgb24gdGhlIFBUUyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSB1c2VkIHRvIHNldCB0aGUgdGltZXN0YW1wIG9mZnNldCBpbiB0aGUgbXV4ZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldFRpbWVzdGFtcE9mZnNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRpbWVzdGFtcE9mZnNldChkYXRhKSB7XG4gICAgICB2YXIgdGltZXN0YW1wT2Zmc2V0ID0gZGF0YS50aW1lc3RhbXBPZmZzZXQgfHwgMDtcblxuICAgICAgdGhpcy50cmFuc211eGVyLnNldEJhc2VNZWRpYURlY29kZVRpbWUoTWF0aC5yb3VuZCh0aW1lc3RhbXBPZmZzZXQgKiA5MDAwMCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldEF1ZGlvQXBwZW5kU3RhcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdWRpb0FwcGVuZFN0YXJ0KGRhdGEpIHtcbiAgICAgIHRoaXMudHJhbnNtdXhlci5zZXRBdWRpb0FwcGVuZFN0YXJ0KE1hdGguY2VpbChkYXRhLmFwcGVuZFN0YXJ0ICogOTAwMDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdGhlIHBpcGVsaW5lIHRvIGZpbmlzaCBwcm9jZXNzaW5nIHRoZSBsYXN0IHNlZ21lbnQgYW5kIGVtaXQgaXQnc1xuICAgICAqIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBldmVudCBkYXRhLCBub3QgcmVhbGx5IHVzZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2ZsdXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmx1c2goZGF0YSkge1xuICAgICAgdGhpcy50cmFuc211eGVyLmZsdXNoKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVzZXRDYXB0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0Q2FwdGlvbnMoKSB7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXIucmVzZXRDYXB0aW9ucygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FsaWduR29wc1dpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbGlnbkdvcHNXaXRoKGRhdGEpIHtcbiAgICAgIHRoaXMudHJhbnNtdXhlci5hbGlnbkdvcHNXaXRoKGRhdGEuZ29wc1RvQWxpZ25XaXRoLnNsaWNlKCkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNZXNzYWdlSGFuZGxlcnM7XG59KSgpO1xuXG52YXIgVHJhbnNtdXhlcldvcmtlciA9IGZ1bmN0aW9uIFRyYW5zbXV4ZXJXb3JrZXIoc2VsZikge1xuICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5kYXRhLmFjdGlvbiA9PT0gJ2luaXQnICYmIGV2ZW50LmRhdGEub3B0aW9ucykge1xuICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcnMgPSBuZXcgTWVzc2FnZUhhbmRsZXJzKGV2ZW50LmRhdGEub3B0aW9ucyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm1lc3NhZ2VIYW5kbGVycykge1xuICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcnMgPSBuZXcgTWVzc2FnZUhhbmRsZXJzKCk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5hY3Rpb24gJiYgZXZlbnQuZGF0YS5hY3Rpb24gIT09ICdpbml0Jykge1xuICAgICAgaWYgKHRoaXMubWVzc2FnZUhhbmRsZXJzW2V2ZW50LmRhdGEuYWN0aW9uXSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyc1tldmVudC5kYXRhLmFjdGlvbl0oZXZlbnQuZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKHNlbGYpIHtcbiAgcmV0dXJuIG5ldyBUcmFuc211eGVyV29ya2VyKHNlbGYpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG59LHtcImdsb2JhbC93aW5kb3dcIjozMixcIm11eC5qcy9saWIvbXA0XCI6NTV9XSw3NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIEBmaWxlIHZpZGVvanMtY29udHJpYi1tZWRpYS1zb3VyY2VzLmpzXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9nbG9iYWxXaW5kb3cgPSByZXF1aXJlKCdnbG9iYWwvd2luZG93Jyk7XG5cbnZhciBfZ2xvYmFsV2luZG93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbFdpbmRvdyk7XG5cbnZhciBfZmxhc2hNZWRpYVNvdXJjZSA9IHJlcXVpcmUoJy4vZmxhc2gtbWVkaWEtc291cmNlJyk7XG5cbnZhciBfZmxhc2hNZWRpYVNvdXJjZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mbGFzaE1lZGlhU291cmNlKTtcblxudmFyIF9odG1sTWVkaWFTb3VyY2UgPSByZXF1aXJlKCcuL2h0bWwtbWVkaWEtc291cmNlJyk7XG5cbnZhciBfaHRtbE1lZGlhU291cmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2h0bWxNZWRpYVNvdXJjZSk7XG5cbnZhciBfdmlkZW9KcyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2aWRlb2pzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd2aWRlb2pzJ10gOiBudWxsKTtcblxudmFyIF92aWRlb0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvSnMpO1xuXG52YXIgdXJsQ291bnQgPSAwO1xuXG4vLyAtLS0tLS0tLS0tLS1cbi8vIE1lZGlhIFNvdXJjZVxuLy8gLS0tLS0tLS0tLS0tXG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgLy8gaG93IHRvIGRldGVybWluZSB0aGUgTWVkaWFTb3VyY2UgaW1wbGVtZW50YXRpb24gdG8gdXNlLiBUaGVyZVxuICAvLyBhcmUgdGhyZWUgYXZhaWxhYmxlIG1vZGVzOlxuICAvLyAtIGF1dG86IHVzZSBuYXRpdmUgTWVkaWFTb3VyY2VzIHdoZXJlIGF2YWlsYWJsZSBhbmQgRmxhc2hcbiAgLy8gICBldmVyeXdoZXJlIGVsc2VcbiAgLy8gLSBodG1sNTogYWx3YXlzIHVzZSBuYXRpdmUgTWVkaWFTb3VyY2VzXG4gIC8vIC0gZmxhc2g6IGFsd2F5cyB1c2UgdGhlIEZsYXNoIE1lZGlhU291cmNlIHBvbHlmaWxsXG4gIG1vZGU6ICdhdXRvJ1xufTtcblxuLy8gc3RvcmUgcmVmZXJlbmNlcyB0byB0aGUgbWVkaWEgc291cmNlcyBzbyB0aGV5IGNhbiBiZSBjb25uZWN0ZWRcbi8vIHRvIGEgdmlkZW8gZWxlbWVudCAoYSBzd2Ygb2JqZWN0KVxuLy8gVE9ETzogY2FuIHdlIHN0b3JlIHRoaXMgc29tZXdoZXJlIGxvY2FsIHRvIHRoaXMgbW9kdWxlP1xuX3ZpZGVvSnMyWydkZWZhdWx0J10ubWVkaWFTb3VyY2VzID0ge307XG5cbi8qKlxuICogUHJvdmlkZSBhIG1ldGhvZCBmb3IgYSBzd2Ygb2JqZWN0IHRvIG5vdGlmeSBKUyB0aGF0IGFcbiAqIG1lZGlhIHNvdXJjZSBpcyBub3cgb3Blbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNPYmplY3RVUkwgc3RyaW5nIHJlZmVyZW5jaW5nIHRoZSBNU0UgT2JqZWN0IFVSTFxuICogQHBhcmFtIHtTdHJpbmd9IHN3ZklkIHRoZSBzd2YgaWRcbiAqL1xudmFyIG9wZW4gPSBmdW5jdGlvbiBvcGVuKG1zT2JqZWN0VVJMLCBzd2ZJZCkge1xuICB2YXIgbWVkaWFTb3VyY2UgPSBfdmlkZW9KczJbJ2RlZmF1bHQnXS5tZWRpYVNvdXJjZXNbbXNPYmplY3RVUkxdO1xuXG4gIGlmIChtZWRpYVNvdXJjZSkge1xuICAgIG1lZGlhU291cmNlLnRyaWdnZXIoeyB0eXBlOiAnc291cmNlb3BlbicsIHN3ZklkOiBzd2ZJZCB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01lZGlhIFNvdXJjZSBub3QgZm91bmQgKFZpZGVvLmpzKScpO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIHRvIHNlZSBpZiB0aGUgbmF0aXZlIE1lZGlhU291cmNlIG9iamVjdCBleGlzdHMgYW5kIHN1cHBvcnRzXG4gKiBhbiBNUDQgY29udGFpbmVyIHdpdGggYm90aCBILjI2NCB2aWRlbyBhbmQgQUFDLUxDIGF1ZGlvLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlmICBuYXRpdmUgbWVkaWEgc291cmNlcyBhcmUgc3VwcG9ydGVkXG4gKi9cbnZhciBzdXBwb3J0c05hdGl2ZU1lZGlhU291cmNlcyA9IGZ1bmN0aW9uIHN1cHBvcnRzTmF0aXZlTWVkaWFTb3VyY2VzKCkge1xuICByZXR1cm4gISFfZ2xvYmFsV2luZG93MlsnZGVmYXVsdCddLk1lZGlhU291cmNlICYmICEhX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5NZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQgJiYgX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5NZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ3ZpZGVvL21wNDtjb2RlY3M9XCJhdmMxLjRkNDAwZCxtcDRhLjQwLjJcIicpO1xufTtcblxuLyoqXG4gKiBBbiBlbXVsYXRpb24gb2YgdGhlIE1lZGlhU291cmNlIEFQSSBzbyB0aGF0IHdlIGNhbiBzdXBwb3J0XG4gKiBuYXRpdmUgYW5kIG5vbi1uYXRpdmUgZnVuY3Rpb25hbGl0eSBzdWNoIGFzIGZsYXNoIGFuZFxuICogdmlkZW8vbXAydCB2aWRlb3MuIHJldHVybnMgYW4gaW5zdGFuY2Ugb2YgSHRtbE1lZGlhU291cmNlIG9yXG4gKiBGbGFzaE1lZGlhU291cmNlIGRlcGVuZGluZyBvbiB3aGF0IGlzIHN1cHBvcnRlZCBhbmQgd2hhdCBvcHRpb25zXG4gKiBhcmUgcGFzc2VkIGluLlxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVNvdXJjZS9NZWRpYVNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyB0byB1c2UgZHVyaW5nIHNldHVwLlxuICovXG52YXIgTWVkaWFTb3VyY2UgPSBmdW5jdGlvbiBNZWRpYVNvdXJjZShvcHRpb25zKSB7XG4gIHZhciBzZXR0aW5ncyA9IF92aWRlb0pzMlsnZGVmYXVsdCddLm1lcmdlT3B0aW9ucyhkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgdGhpcy5NZWRpYVNvdXJjZSA9IHtcbiAgICBvcGVuOiBvcGVuLFxuICAgIHN1cHBvcnRzTmF0aXZlTWVkaWFTb3VyY2VzOiBzdXBwb3J0c05hdGl2ZU1lZGlhU291cmNlc1xuICB9O1xuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIEhUTUwgTWVkaWFTb3VyY2VzIHNob3VsZCBiZSB1c2VkXG4gIGlmIChzZXR0aW5ncy5tb2RlID09PSAnaHRtbDUnIHx8IHNldHRpbmdzLm1vZGUgPT09ICdhdXRvJyAmJiBzdXBwb3J0c05hdGl2ZU1lZGlhU291cmNlcygpKSB7XG4gICAgcmV0dXJuIG5ldyBfaHRtbE1lZGlhU291cmNlMlsnZGVmYXVsdCddKCk7XG4gIH0gZWxzZSBpZiAoX3ZpZGVvSnMyWydkZWZhdWx0J10uZ2V0VGVjaCgnRmxhc2gnKSkge1xuICAgIHJldHVybiBuZXcgX2ZsYXNoTWVkaWFTb3VyY2UyWydkZWZhdWx0J10oKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBGbGFzaCBvciBIdG1sNSB0byBjcmVhdGUgYSBNZWRpYVNvdXJjZSBmb3IgdGhpcyB2aWRlbycpO1xufTtcblxuZXhwb3J0cy5NZWRpYVNvdXJjZSA9IE1lZGlhU291cmNlO1xuTWVkaWFTb3VyY2Uub3BlbiA9IG9wZW47XG5NZWRpYVNvdXJjZS5zdXBwb3J0c05hdGl2ZU1lZGlhU291cmNlcyA9IHN1cHBvcnRzTmF0aXZlTWVkaWFTb3VyY2VzO1xuXG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgdGhlIG5hdGl2ZSBVUkwgZm9yIG91ciBNU0Ugb2JqZWN0XG4gKiBpbXBsZW1lbnRhdGlvbiwgdGhpcyBvYmplY3QgaXMgZXhwb3NlZCB1bmRlciB2aWRlb2pzLlVSTFxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9VUkwvVVJMXG4gKi9cbnZhciBVUkwgPSB7XG4gIC8qKlxuICAgKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBuYXRpdmUgY3JlYXRlT2JqZWN0VVJMIGZvciBvdXIgb2JqZWN0cy5cbiAgICogVGhpcyBmdW5jdGlvbiBtYXBzIGEgbmF0aXZlIG9yIGVtdWxhdGVkIG1lZGlhU291cmNlIHRvIGEgYmxvYlxuICAgKiB1cmwgc28gdGhhdCBpdCBjYW4gYmUgbG9hZGVkIGludG8gdmlkZW8uanNcbiAgICpcbiAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9jcmVhdGVPYmplY3RVUkxcbiAgICogQHBhcmFtIHtNZWRpYVNvdXJjZX0gb2JqZWN0IHRoZSBvYmplY3QgdG8gY3JlYXRlIGEgYmxvYiB1cmwgdG9cbiAgICovXG4gIGNyZWF0ZU9iamVjdFVSTDogZnVuY3Rpb24gY3JlYXRlT2JqZWN0VVJMKG9iamVjdCkge1xuICAgIHZhciBvYmplY3RVcmxQcmVmaXggPSAnYmxvYjp2anMtbWVkaWEtc291cmNlLyc7XG4gICAgdmFyIHVybCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHVzZSB0aGUgbmF0aXZlIE1lZGlhU291cmNlIHRvIGdlbmVyYXRlIGFuIG9iamVjdCBVUkxcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgX2h0bWxNZWRpYVNvdXJjZTJbJ2RlZmF1bHQnXSkge1xuICAgICAgdXJsID0gX2dsb2JhbFdpbmRvdzJbJ2RlZmF1bHQnXS5VUkwuY3JlYXRlT2JqZWN0VVJMKG9iamVjdC5uYXRpdmVNZWRpYVNvdXJjZV8pO1xuICAgICAgb2JqZWN0LnVybF8gPSB1cmw7XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgb2JqZWN0IGlzbid0IGFuIGVtdWxhdGVkIE1lZGlhU291cmNlLCBkZWxlZ2F0ZSB0byB0aGVcbiAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb25cbiAgICBpZiAoIShvYmplY3QgaW5zdGFuY2VvZiBfZmxhc2hNZWRpYVNvdXJjZTJbJ2RlZmF1bHQnXSkpIHtcbiAgICAgIHVybCA9IF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uVVJMLmNyZWF0ZU9iamVjdFVSTChvYmplY3QpO1xuICAgICAgb2JqZWN0LnVybF8gPSB1cmw7XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cblxuICAgIC8vIGJ1aWxkIGEgVVJMIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFwIGJhY2sgdG8gdGhlIGVtdWxhdGVkXG4gICAgLy8gTWVkaWFTb3VyY2VcbiAgICB1cmwgPSBvYmplY3RVcmxQcmVmaXggKyB1cmxDb3VudDtcblxuICAgIHVybENvdW50Kys7XG5cbiAgICAvLyBzZXR1cCB0aGUgbWFwcGluZyBiYWNrIHRvIG9iamVjdFxuICAgIF92aWRlb0pzMlsnZGVmYXVsdCddLm1lZGlhU291cmNlc1t1cmxdID0gb2JqZWN0O1xuXG4gICAgcmV0dXJuIHVybDtcbiAgfVxufTtcblxuZXhwb3J0cy5VUkwgPSBVUkw7XG5fdmlkZW9KczJbJ2RlZmF1bHQnXS5NZWRpYVNvdXJjZSA9IE1lZGlhU291cmNlO1xuX3ZpZGVvSnMyWydkZWZhdWx0J10uVVJMID0gVVJMO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4vZmxhc2gtbWVkaWEtc291cmNlXCI6NjgsXCIuL2h0bWwtbWVkaWEtc291cmNlXCI6NzEsXCJnbG9iYWwvd2luZG93XCI6MzJ9XSw3NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIEBmaWxlIHZpcnR1YWwtc291cmNlLWJ1ZmZlci5qc1xuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfdmlkZW9KcyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2aWRlb2pzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd2aWRlb2pzJ10gOiBudWxsKTtcblxudmFyIF92aWRlb0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvSnMpO1xuXG52YXIgX2NyZWF0ZVRleHRUcmFja3NJZk5lY2Vzc2FyeSA9IHJlcXVpcmUoJy4vY3JlYXRlLXRleHQtdHJhY2tzLWlmLW5lY2Vzc2FyeScpO1xuXG52YXIgX2NyZWF0ZVRleHRUcmFja3NJZk5lY2Vzc2FyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUZXh0VHJhY2tzSWZOZWNlc3NhcnkpO1xuXG52YXIgX3JlbW92ZUN1ZXNGcm9tVHJhY2sgPSByZXF1aXJlKCcuL3JlbW92ZS1jdWVzLWZyb20tdHJhY2snKTtcblxudmFyIF9yZW1vdmVDdWVzRnJvbVRyYWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbW92ZUN1ZXNGcm9tVHJhY2spO1xuXG52YXIgX2FkZFRleHRUcmFja0RhdGEgPSByZXF1aXJlKCcuL2FkZC10ZXh0LXRyYWNrLWRhdGEnKTtcblxudmFyIF93ZWJ3b3JraWZ5ID0gcmVxdWlyZSgnd2Vid29ya2lmeScpO1xuXG52YXIgX3dlYndvcmtpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2Vid29ya2lmeSk7XG5cbnZhciBfdHJhbnNtdXhlcldvcmtlciA9IHJlcXVpcmUoJy4vdHJhbnNtdXhlci13b3JrZXInKTtcblxudmFyIF90cmFuc211eGVyV29ya2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyYW5zbXV4ZXJXb3JrZXIpO1xuXG52YXIgX2NvZGVjVXRpbHMgPSByZXF1aXJlKCcuL2NvZGVjLXV0aWxzJyk7XG5cbi8vIFdlIGNyZWF0ZSBhIHdyYXBwZXIgYXJvdW5kIHRoZSBTb3VyY2VCdWZmZXIgc28gdGhhdCB3ZSBjYW4gbWFuYWdlIHRoZVxuLy8gc3RhdGUgb2YgdGhlIGB1cGRhdGluZ2AgcHJvcGVydHkgbWFudWFsbHkuIFdlIGhhdmUgdG8gZG8gdGhpcyBiZWNhdXNlXG4vLyBGaXJlZm94IGNoYW5nZXMgYHVwZGF0aW5nYCB0byBmYWxzZSBsb25nIGJlZm9yZSB0cmlnZ2VyaW5nIGB1cGRhdGVlbmRgXG4vLyBldmVudHMgYW5kIHRoYXQgd2FzIGNhdXNpbmcgc3RyYW5nZSBwcm9ibGVtcyBpbiB2aWRlb2pzLWNvbnRyaWItaGxzXG52YXIgbWFrZVdyYXBwZWRTb3VyY2VCdWZmZXIgPSBmdW5jdGlvbiBtYWtlV3JhcHBlZFNvdXJjZUJ1ZmZlcihtZWRpYVNvdXJjZSwgbWltZVR5cGUpIHtcbiAgdmFyIHNvdXJjZUJ1ZmZlciA9IG1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcihtaW1lVHlwZSk7XG4gIHZhciB3cmFwcGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB3cmFwcGVyLnVwZGF0aW5nID0gZmFsc2U7XG4gIHdyYXBwZXIucmVhbEJ1ZmZlcl8gPSBzb3VyY2VCdWZmZXI7XG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlQnVmZmVyW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdyYXBwZXJba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZUJ1ZmZlcltrZXldLmFwcGx5KHNvdXJjZUJ1ZmZlciwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd3JhcHBlcltrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdyYXBwZXIsIGtleSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gc291cmNlQnVmZmVyW2tleV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHYpIHtcbiAgICAgICAgICByZXR1cm4gc291cmNlQnVmZmVyW2tleV0gPSB2O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZUJ1ZmZlcikge1xuICAgIF9sb29wKGtleSk7XG4gIH1cblxuICByZXR1cm4gd3JhcHBlcjtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgZ29wcyBpbiB0aGUgYnVmZmVyIHRoYXQgaGF2ZSBhIHB0cyB2YWx1ZSBvZiAzIHNlY29uZHMgb3IgbW9yZSBpblxuICogZnJvbnQgb2YgY3VycmVudCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlclxuICogICAgICAgIFRoZSBjdXJyZW50IGJ1ZmZlciBvZiBnb3AgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAqICAgICAgICBUaGUgcGxheWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge0RvdWJsZX0gbWFwcGluZ1xuICogICAgICAgIE9mZnNldCB0byBtYXAgZGlzcGxheSB0aW1lIHRvIHN0cmVhbSBwcmVzZW50YXRpb24gdGltZVxuICogQHJldHVybiB7QXJyYXl9XG4gKiAgICAgICAgIExpc3Qgb2YgZ29wcyBjb25zaWRlcmVkIHNhZmUgdG8gYXBwZW5kIG92ZXJcbiAqL1xudmFyIGdvcHNTYWZlVG9BbGlnbldpdGggPSBmdW5jdGlvbiBnb3BzU2FmZVRvQWxpZ25XaXRoKGJ1ZmZlciwgcGxheWVyLCBtYXBwaW5nKSB7XG4gIGlmICghcGxheWVyIHx8ICFidWZmZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gcHRzIHZhbHVlIGZvciBjdXJyZW50IHRpbWUgKyAzIHNlY29uZHMgdG8gZ2l2ZSBhIGJpdCBtb3JlIHdpZ2dsZSByb29tXG4gIHZhciBjdXJyZW50VGltZVB0cyA9IE1hdGguY2VpbCgocGxheWVyLmN1cnJlbnRUaW1lKCkgLSBtYXBwaW5nICsgMykgKiA5MDAwMCk7XG5cbiAgdmFyIGkgPSB1bmRlZmluZWQ7XG5cbiAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChidWZmZXJbaV0ucHRzID4gY3VycmVudFRpbWVQdHMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZmZXIuc2xpY2UoaSk7XG59O1xuXG5leHBvcnRzLmdvcHNTYWZlVG9BbGlnbldpdGggPSBnb3BzU2FmZVRvQWxpZ25XaXRoO1xuLyoqXG4gKiBBcHBlbmRzIGdvcCBpbmZvcm1hdGlvbiAodGltaW5nIGFuZCBieXRlTGVuZ3RoKSByZWNlaXZlZCBieSB0aGUgdHJhbnNtdXhlciBmb3IgdGhlXG4gKiBnb3BzIGFwcGVuZGVkIGluIHRoZSBsYXN0IGNhbGwgdG8gYXBwZW5kQnVmZmVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYnVmZmVyXG4gKiAgICAgICAgVGhlIGN1cnJlbnQgYnVmZmVyIG9mIGdvcCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtBcnJheX0gZ29wc1xuICogICAgICAgIExpc3Qgb2YgbmV3IGdvcCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtib29sZWFufSByZXBsYWNlXG4gKiAgICAgICAgSWYgdHJ1ZSwgcmVwbGFjZSB0aGUgYnVmZmVyIHdpdGggdGhlIG5ldyBnb3AgaW5mb3JtYXRpb24uIElmIGZhbHNlLCBhcHBlbmQgdGhlXG4gKiAgICAgICAgbmV3IGdvcCBpbmZvcm1hdGlvbiB0byB0aGUgYnVmZmVyIGluIHRoZSByaWdodCBsb2NhdGlvbiBvZiB0aW1lLlxuICogQHJldHVybiB7QXJyYXl9XG4gKiAgICAgICAgIFVwZGF0ZWQgbGlzdCBvZiBnb3AgaW5mb3JtYXRpb25cbiAqL1xudmFyIHVwZGF0ZUdvcEJ1ZmZlciA9IGZ1bmN0aW9uIHVwZGF0ZUdvcEJ1ZmZlcihidWZmZXIsIGdvcHMsIHJlcGxhY2UpIHtcbiAgaWYgKCFnb3BzLmxlbmd0aCkge1xuICAgIHJldHVybiBidWZmZXI7XG4gIH1cblxuICBpZiAocmVwbGFjZSkge1xuICAgIC8vIElmIHdlIGFyZSBpbiBzYWZlIGFwcGVuZCBtb2RlLCB0aGVuIGNvbXBsZXRlbHkgb3ZlcndyaXRlIHRoZSBnb3AgYnVmZmVyXG4gICAgLy8gd2l0aCB0aGUgbW9zdCByZWNlbnQgYXBwZW5lZGVkIGRhdGEuIFRoaXMgd2lsbCBtYWtlIHN1cmUgdGhhdCB3aGVuIGFwcGVuZGluZ1xuICAgIC8vIGZ1dHVyZSBzZWdtZW50cywgd2Ugb25seSB0cnkgdG8gYWxpZ24gd2l0aCBnb3BzIHRoYXQgYXJlIGJvdGggYWhlYWQgb2YgY3VycmVudFxuICAgIC8vIHRpbWUgYW5kIGluIHRoZSBsYXN0IHNlZ21lbnQgYXBwZW5kZWQuXG4gICAgcmV0dXJuIGdvcHMuc2xpY2UoKTtcbiAgfVxuXG4gIHZhciBzdGFydCA9IGdvcHNbMF0ucHRzO1xuXG4gIHZhciBpID0gMDtcblxuICBmb3IgKGk7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYnVmZmVyW2ldLnB0cyA+PSBzdGFydCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlci5zbGljZSgwLCBpKS5jb25jYXQoZ29wcyk7XG59O1xuXG5leHBvcnRzLnVwZGF0ZUdvcEJ1ZmZlciA9IHVwZGF0ZUdvcEJ1ZmZlcjtcbi8qKlxuICogUmVtb3ZlcyBnb3AgaW5mb3JtYXRpb24gaW4gYnVmZmVyIHRoYXQgb3ZlcmxhcHMgd2l0aCBwcm92aWRlZCBzdGFydCBhbmQgZW5kXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYnVmZmVyXG4gKiAgICAgICAgVGhlIGN1cnJlbnQgYnVmZmVyIG9mIGdvcCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtEb3VibGV9IHN0YXJ0XG4gKiAgICAgICAgcG9zaXRpb24gdG8gc3RhcnQgdGhlIHJlbW92ZSBhdFxuICogQHBhcmFtIHtEb3VibGV9IGVuZFxuICogICAgICAgIHBvc2l0aW9uIHRvIGVuZCB0aGUgcmVtb3ZlIGF0XG4gKiBAcGFyYW0ge0RvdWJsZX0gbWFwcGluZ1xuICogICAgICAgIE9mZnNldCB0byBtYXAgZGlzcGxheSB0aW1lIHRvIHN0cmVhbSBwcmVzZW50YXRpb24gdGltZVxuICovXG52YXIgcmVtb3ZlR29wQnVmZmVyID0gZnVuY3Rpb24gcmVtb3ZlR29wQnVmZmVyKGJ1ZmZlciwgc3RhcnQsIGVuZCwgbWFwcGluZykge1xuICB2YXIgc3RhcnRQdHMgPSBNYXRoLmNlaWwoKHN0YXJ0IC0gbWFwcGluZykgKiA5MDAwMCk7XG4gIHZhciBlbmRQdHMgPSBNYXRoLmNlaWwoKGVuZCAtIG1hcHBpbmcpICogOTAwMDApO1xuICB2YXIgdXBkYXRlZEJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgpO1xuXG4gIHZhciBpID0gYnVmZmVyLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGJ1ZmZlcltpXS5wdHMgPD0gZW5kUHRzKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaSA9PT0gLTEpIHtcbiAgICAvLyBubyByZW1vdmFsIGJlY2F1c2UgZW5kIG9mIHJlbW92ZSByYW5nZSBpcyBiZWZvcmUgc3RhcnQgb2YgYnVmZmVyXG4gICAgcmV0dXJuIHVwZGF0ZWRCdWZmZXI7XG4gIH1cblxuICB2YXIgaiA9IGkgKyAxO1xuXG4gIHdoaWxlIChqLS0pIHtcbiAgICBpZiAoYnVmZmVyW2pdLnB0cyA8PSBzdGFydFB0cykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gY2xhbXAgcmVtb3ZlIHJhbmdlIHN0YXJ0IHRvIDAgaW5kZXhcbiAgaiA9IE1hdGgubWF4KGosIDApO1xuXG4gIHVwZGF0ZWRCdWZmZXIuc3BsaWNlKGosIGkgLSBqICsgMSk7XG5cbiAgcmV0dXJuIHVwZGF0ZWRCdWZmZXI7XG59O1xuXG5leHBvcnRzLnJlbW92ZUdvcEJ1ZmZlciA9IHJlbW92ZUdvcEJ1ZmZlcjtcbi8qKlxuICogVmlydHVhbFNvdXJjZUJ1ZmZlcnMgZXhpc3Qgc28gdGhhdCB3ZSBjYW4gdHJhbnNtdXggbm9uIG5hdGl2ZSBmb3JtYXRzXG4gKiBpbnRvIGEgbmF0aXZlIGZvcm1hdCwgYnV0IGtlZXAgdGhlIHNhbWUgYXBpIGFzIGEgbmF0aXZlIHNvdXJjZSBidWZmZXIuXG4gKiBJdCBjcmVhdGVzIGEgdHJhbnNtdXhlciwgdGhhdCB3b3JrcyBpbiBpdHMgb3duIHRocmVhZCAoYSB3ZWIgd29ya2VyKSBhbmRcbiAqIHRoYXQgdHJhbnNtdXhlciBtdXhlcyB0aGUgZGF0YSBpbnRvIGEgbmF0aXZlIGZvcm1hdC4gVmlydHVhbFNvdXJjZUJ1ZmZlciB3aWxsXG4gKiB0aGVuIHNlbmQgYWxsIG9mIHRoYXQgZGF0YSB0byB0aGUgbmFpdmUgc291cmNlYnVmZmVyIHNvIHRoYXQgaXQgaXNcbiAqIGluZGVzdGluZ3Vpc2hhYmxlIGZyb20gYSBuYXRpdmVseSBzdXBwb3J0ZWQgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSB7SHRtbE1lZGlhU291cmNlfSBtZWRpYVNvdXJjZSB0aGUgcGFyZW50IG1lZGlhU291cmNlXG4gKiBAcGFyYW0ge0FycmF5fSBjb2RlY3MgYXJyYXkgb2YgY29kZWNzIHRoYXQgd2Ugd2lsbCBiZSBkZWFsaW5nIHdpdGhcbiAqIEBjbGFzcyBWaXJ0dWFsU291cmNlQnVmZmVyXG4gKiBAZXh0ZW5kcyB2aWRlby5qcy5FdmVudFRhcmdldFxuICovXG5cbnZhciBWaXJ0dWFsU291cmNlQnVmZmVyID0gKGZ1bmN0aW9uIChfdmlkZW9qcyRFdmVudFRhcmdldCkge1xuICBfaW5oZXJpdHMoVmlydHVhbFNvdXJjZUJ1ZmZlciwgX3ZpZGVvanMkRXZlbnRUYXJnZXQpO1xuXG4gIGZ1bmN0aW9uIFZpcnR1YWxTb3VyY2VCdWZmZXIobWVkaWFTb3VyY2UsIGNvZGVjcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlydHVhbFNvdXJjZUJ1ZmZlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihWaXJ0dWFsU291cmNlQnVmZmVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcywgX3ZpZGVvSnMyWydkZWZhdWx0J10uRXZlbnRUYXJnZXQpO1xuICAgIHRoaXMudGltZXN0YW1wT2Zmc2V0XyA9IDA7XG4gICAgdGhpcy5wZW5kaW5nQnVmZmVyc18gPSBbXTtcbiAgICB0aGlzLmJ1ZmZlclVwZGF0aW5nXyA9IGZhbHNlO1xuXG4gICAgdGhpcy5tZWRpYVNvdXJjZV8gPSBtZWRpYVNvdXJjZTtcbiAgICB0aGlzLmNvZGVjc18gPSBjb2RlY3M7XG4gICAgdGhpcy5hdWRpb0NvZGVjXyA9IG51bGw7XG4gICAgdGhpcy52aWRlb0NvZGVjXyA9IG51bGw7XG4gICAgdGhpcy5hdWRpb0Rpc2FibGVkXyA9IGZhbHNlO1xuICAgIHRoaXMuYXBwZW5kQXVkaW9Jbml0U2VnbWVudF8gPSB0cnVlO1xuICAgIHRoaXMuZ29wQnVmZmVyXyA9IFtdO1xuICAgIHRoaXMudGltZU1hcHBpbmdfID0gMDtcbiAgICB0aGlzLnNhZmVBcHBlbmRfID0gX3ZpZGVvSnMyWydkZWZhdWx0J10uYnJvd3Nlci5JRV9WRVJTSU9OID49IDExO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICByZW11eDogZmFsc2UsXG4gICAgICBhbGlnbkdvcHNBdEVuZDogdGhpcy5zYWZlQXBwZW5kX1xuICAgIH07XG5cbiAgICB0aGlzLmNvZGVjc18uZm9yRWFjaChmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgIGlmICgoMCwgX2NvZGVjVXRpbHMuaXNBdWRpb0NvZGVjKShjb2RlYykpIHtcbiAgICAgICAgX3RoaXMuYXVkaW9Db2RlY18gPSBjb2RlYztcbiAgICAgIH0gZWxzZSBpZiAoKDAsIF9jb2RlY1V0aWxzLmlzVmlkZW9Db2RlYykoY29kZWMpKSB7XG4gICAgICAgIF90aGlzLnZpZGVvQ29kZWNfID0gY29kZWM7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBhcHBlbmQgbXV4ZWQgc2VnbWVudHMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBuYXRpdmUgYnVmZmVycyBhc1xuICAgIC8vIHNvb24gYXMgdGhleSBhcmUgYXZhaWxhYmxlXG4gICAgdGhpcy50cmFuc211eGVyXyA9ICgwLCBfd2Vid29ya2lmeTJbJ2RlZmF1bHQnXSkoX3RyYW5zbXV4ZXJXb3JrZXIyWydkZWZhdWx0J10pO1xuICAgIHRoaXMudHJhbnNtdXhlcl8ucG9zdE1lc3NhZ2UoeyBhY3Rpb246ICdpbml0Jywgb3B0aW9uczogb3B0aW9ucyB9KTtcblxuICAgIHRoaXMudHJhbnNtdXhlcl8ub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGF0YS5hY3Rpb24gPT09ICdkYXRhJykge1xuICAgICAgICByZXR1cm4gX3RoaXMuZGF0YV8oZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQuZGF0YS5hY3Rpb24gPT09ICdkb25lJykge1xuICAgICAgICByZXR1cm4gX3RoaXMuZG9uZV8oZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQuZGF0YS5hY3Rpb24gPT09ICdnb3BJbmZvJykge1xuICAgICAgICByZXR1cm4gX3RoaXMuYXBwZW5kR29wSW5mb18oZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyB0aGlzIHRpbWVzdGFtcE9mZnNldCBpcyBhIHByb3BlcnR5IHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHJlc2V0dGluZ1xuICAgIC8vIGJhc2VNZWRpYURlY29kZVRpbWUgaW4gdGhlIHRyYW5zbXV4ZXIgb24gdGhlIHNldHRlclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndGltZXN0YW1wT2Zmc2V0Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcE9mZnNldF87XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiB2YWwgPj0gMCkge1xuICAgICAgICAgIHRoaXMudGltZXN0YW1wT2Zmc2V0XyA9IHZhbDtcbiAgICAgICAgICB0aGlzLmFwcGVuZEF1ZGlvSW5pdFNlZ21lbnRfID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIHJlc2V0IGdvcCBidWZmZXIgb24gdGltZXN0YW1wb2Zmc2V0IGFzIHRoaXMgc2lnbmFscyBhIGNoYW5nZSBpbiB0aW1lbGluZVxuICAgICAgICAgIHRoaXMuZ29wQnVmZmVyXy5sZW5ndGggPSAwO1xuICAgICAgICAgIHRoaXMudGltZU1hcHBpbmdfID0gMDtcblxuICAgICAgICAgIC8vIFdlIGhhdmUgdG8gdGVsbCB0aGUgdHJhbnNtdXhlciB0byBzZXQgdGhlIGJhc2VNZWRpYURlY29kZVRpbWUgdG9cbiAgICAgICAgICAvLyB0aGUgZGVzaXJlZCB0aW1lc3RhbXBPZmZzZXQgZm9yIHRoZSBuZXh0IHNlZ21lbnRcbiAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGFjdGlvbjogJ3NldFRpbWVzdGFtcE9mZnNldCcsXG4gICAgICAgICAgICB0aW1lc3RhbXBPZmZzZXQ6IHZhbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBzZXR0aW5nIHRoZSBhcHBlbmQgd2luZG93IGFmZmVjdHMgYm90aCBzb3VyY2UgYnVmZmVyc1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYXBwZW5kV2luZG93U3RhcnQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnZpZGVvQnVmZmVyXyB8fCB0aGlzLmF1ZGlvQnVmZmVyXykuYXBwZW5kV2luZG93U3RhcnQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMudmlkZW9CdWZmZXJfKSB7XG4gICAgICAgICAgdGhpcy52aWRlb0J1ZmZlcl8uYXBwZW5kV2luZG93U3RhcnQgPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdWRpb0J1ZmZlcl8pIHtcbiAgICAgICAgICB0aGlzLmF1ZGlvQnVmZmVyXy5hcHBlbmRXaW5kb3dTdGFydCA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyB0aGlzIGJ1ZmZlciBpcyBcInVwZGF0aW5nXCIgaWYgZWl0aGVyIG9mIGl0cyBuYXRpdmUgYnVmZmVycyBhcmVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3VwZGF0aW5nJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLmJ1ZmZlclVwZGF0aW5nXyB8fCAhdGhpcy5hdWRpb0Rpc2FibGVkXyAmJiB0aGlzLmF1ZGlvQnVmZmVyXyAmJiB0aGlzLmF1ZGlvQnVmZmVyXy51cGRhdGluZyB8fCB0aGlzLnZpZGVvQnVmZmVyXyAmJiB0aGlzLnZpZGVvQnVmZmVyXy51cGRhdGluZyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyB0aGUgYnVmZmVyZWQgcHJvcGVydHkgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgYnVmZmVyZWRcbiAgICAvLyByYW5nZXMgb2YgdGhlIG5hdGl2ZSBzb3VyY2UgYnVmZmVyc1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYnVmZmVyZWQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdmFyIGVuZCA9IG51bGw7XG4gICAgICAgIHZhciBhcml0eSA9IDA7XG4gICAgICAgIHZhciBleHRlbnRzID0gW107XG4gICAgICAgIHZhciByYW5nZXMgPSBbXTtcblxuICAgICAgICAvLyBuZWl0aGVyIGJ1ZmZlciBoYXMgYmVlbiBjcmVhdGVkIHlldFxuICAgICAgICBpZiAoIXRoaXMudmlkZW9CdWZmZXJfICYmICF0aGlzLmF1ZGlvQnVmZmVyXykge1xuICAgICAgICAgIHJldHVybiBfdmlkZW9KczJbJ2RlZmF1bHQnXS5jcmVhdGVUaW1lUmFuZ2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkgb25lIGJ1ZmZlciBpcyBjb25maWd1cmVkXG4gICAgICAgIGlmICghdGhpcy52aWRlb0J1ZmZlcl8pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdWRpb0J1ZmZlcl8uYnVmZmVyZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmF1ZGlvQnVmZmVyXykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZpZGVvQnVmZmVyXy5idWZmZXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJvdGggYnVmZmVycyBhcmUgY29uZmlndXJlZFxuICAgICAgICBpZiAodGhpcy5hdWRpb0Rpc2FibGVkXykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZpZGVvQnVmZmVyXy5idWZmZXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJvdGggYnVmZmVycyBhcmUgZW1wdHlcbiAgICAgICAgaWYgKHRoaXMudmlkZW9CdWZmZXJfLmJ1ZmZlcmVkLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmF1ZGlvQnVmZmVyXy5idWZmZXJlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gX3ZpZGVvSnMyWydkZWZhdWx0J10uY3JlYXRlVGltZVJhbmdlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgaGF2ZSBib3RoIGJ1ZmZlcnMgYW5kIGNyZWF0ZSBhblxuICAgICAgICAvLyBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3b1xuICAgICAgICB2YXIgdmlkZW9CdWZmZXJlZCA9IHRoaXMudmlkZW9CdWZmZXJfLmJ1ZmZlcmVkO1xuICAgICAgICB2YXIgYXVkaW9CdWZmZXJlZCA9IHRoaXMuYXVkaW9CdWZmZXJfLmJ1ZmZlcmVkO1xuICAgICAgICB2YXIgY291bnQgPSB2aWRlb0J1ZmZlcmVkLmxlbmd0aDtcblxuICAgICAgICAvLyBBKSBHYXRoZXIgdXAgYWxsIHN0YXJ0IGFuZCBlbmQgdGltZXNcbiAgICAgICAgd2hpbGUgKGNvdW50LS0pIHtcbiAgICAgICAgICBleHRlbnRzLnB1c2goeyB0aW1lOiB2aWRlb0J1ZmZlcmVkLnN0YXJ0KGNvdW50KSwgdHlwZTogJ3N0YXJ0JyB9KTtcbiAgICAgICAgICBleHRlbnRzLnB1c2goeyB0aW1lOiB2aWRlb0J1ZmZlcmVkLmVuZChjb3VudCksIHR5cGU6ICdlbmQnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ID0gYXVkaW9CdWZmZXJlZC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChjb3VudC0tKSB7XG4gICAgICAgICAgZXh0ZW50cy5wdXNoKHsgdGltZTogYXVkaW9CdWZmZXJlZC5zdGFydChjb3VudCksIHR5cGU6ICdzdGFydCcgfSk7XG4gICAgICAgICAgZXh0ZW50cy5wdXNoKHsgdGltZTogYXVkaW9CdWZmZXJlZC5lbmQoY291bnQpLCB0eXBlOiAnZW5kJyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCKSBTb3J0IHRoZW0gYnkgdGltZVxuICAgICAgICBleHRlbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDKSBHbyBhbG9uZyBvbmUgYnkgb25lIGluY3JlbWVudGluZyBhcml0eSBmb3Igc3RhcnQgYW5kIGRlY3JlbWVudGluZ1xuICAgICAgICAvLyAgICBhcml0eSBmb3IgZW5kc1xuICAgICAgICBmb3IgKGNvdW50ID0gMDsgY291bnQgPCBleHRlbnRzLmxlbmd0aDsgY291bnQrKykge1xuICAgICAgICAgIGlmIChleHRlbnRzW2NvdW50XS50eXBlID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICBhcml0eSsrO1xuXG4gICAgICAgICAgICAvLyBEKSBJZiBhcml0eSBpcyBldmVyIGluY3JlbWVudGVkIHRvIDIgd2UgYXJlIGVudGVyaW5nIGFuXG4gICAgICAgICAgICAvLyAgICBvdmVybGFwcGluZyByYW5nZVxuICAgICAgICAgICAgaWYgKGFyaXR5ID09PSAyKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gZXh0ZW50c1tjb3VudF0udGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGV4dGVudHNbY291bnRdLnR5cGUgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICBhcml0eS0tO1xuXG4gICAgICAgICAgICAvLyBFKSBJZiBhcml0eSBpcyBldmVyIGRlY3JlbWVudGVkIHRvIDEgd2UgbGVhdmluZyBhblxuICAgICAgICAgICAgLy8gICAgb3ZlcmxhcHBpbmcgcmFuZ2VcbiAgICAgICAgICAgIGlmIChhcml0eSA9PT0gMSkge1xuICAgICAgICAgICAgICBlbmQgPSBleHRlbnRzW2NvdW50XS50aW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEYpIFJlY29yZCBvdmVybGFwcGluZyByYW5nZXNcbiAgICAgICAgICBpZiAoc3RhcnQgIT09IG51bGwgJiYgZW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICByYW5nZXMucHVzaChbc3RhcnQsIGVuZF0pO1xuICAgICAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgZW5kID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3ZpZGVvSnMyWydkZWZhdWx0J10uY3JlYXRlVGltZVJhbmdlcyhyYW5nZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gd2UgZ2V0IGEgZGF0YSBldmVudCBmcm9tIHRoZSB0cmFuc211eGVyXG4gICAqIHdlIGNhbGwgdGhpcyBmdW5jdGlvbiBhbmQgaGFuZGxlIHRoZSBkYXRhIHRoYXRcbiAgICogd2FzIHNlbnQgdG8gdXNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgdGhlIGRhdGEgZXZlbnQgZnJvbSB0aGUgdHJhbnNtdXhlclxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoVmlydHVhbFNvdXJjZUJ1ZmZlciwgW3tcbiAgICBrZXk6ICdkYXRhXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRhdGFfKGV2ZW50KSB7XG4gICAgICB2YXIgc2VnbWVudCA9IGV2ZW50LmRhdGEuc2VnbWVudDtcblxuICAgICAgLy8gQ2FzdCBBcnJheUJ1ZmZlciB0byBUeXBlZEFycmF5XG4gICAgICBzZWdtZW50LmRhdGEgPSBuZXcgVWludDhBcnJheShzZWdtZW50LmRhdGEsIGV2ZW50LmRhdGEuYnl0ZU9mZnNldCwgZXZlbnQuZGF0YS5ieXRlTGVuZ3RoKTtcblxuICAgICAgc2VnbWVudC5pbml0U2VnbWVudCA9IG5ldyBVaW50OEFycmF5KHNlZ21lbnQuaW5pdFNlZ21lbnQuZGF0YSwgc2VnbWVudC5pbml0U2VnbWVudC5ieXRlT2Zmc2V0LCBzZWdtZW50LmluaXRTZWdtZW50LmJ5dGVMZW5ndGgpO1xuXG4gICAgICAoMCwgX2NyZWF0ZVRleHRUcmFja3NJZk5lY2Vzc2FyeTJbJ2RlZmF1bHQnXSkodGhpcywgdGhpcy5tZWRpYVNvdXJjZV8sIHNlZ21lbnQpO1xuXG4gICAgICAvLyBBZGQgdGhlIHNlZ21lbnRzIHRvIHRoZSBwZW5kaW5nQnVmZmVycyBhcnJheVxuICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyc18ucHVzaChzZWdtZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIGdldCBhIGRvbmUgZXZlbnQgZnJvbSB0aGUgdHJhbnNtdXhlclxuICAgICAqIHdlIGNhbGwgdGhpcyBmdW5jdGlvbiBhbmQgd2UgcHJvY2VzcyBhbGxcbiAgICAgKiBvZiB0aGUgcGVuZGluZyBkYXRhIHRoYXQgd2UgaGF2ZSBiZWVuIHNhdmluZyBpbiB0aGVcbiAgICAgKiBkYXRhXyBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCB0aGUgZG9uZSBldmVudCBmcm9tIHRoZSB0cmFuc211eGVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdkb25lXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvbmVfKGV2ZW50KSB7XG4gICAgICAvLyBEb24ndCBwcm9jZXNzIGFuZCBhcHBlbmQgZGF0YSBpZiB0aGUgbWVkaWFTb3VyY2UgaXMgY2xvc2VkXG4gICAgICBpZiAodGhpcy5tZWRpYVNvdXJjZV8ucmVhZHlTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyc18ubGVuZ3RoID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGwgYnVmZmVycyBzaG91bGQgaGF2ZSBiZWVuIGZsdXNoZWQgZnJvbSB0aGUgbXV4ZXJcbiAgICAgIC8vIHN0YXJ0IHByb2Nlc3NpbmcgYW55dGhpbmcgd2UgaGF2ZSByZWNlaXZlZFxuICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ1NlZ21lbnRzXygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBvdXIgaW50ZXJuYWwgbmF0aXZlIGF1ZGlvL3ZpZGVvIHNvdXJjZSBidWZmZXJzIGFuZCBhZGRcbiAgICAgKiBldmVudCBoYW5kbGVycyB0byB0aGVtIHdpdGggdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgICAqIDEuIHRoZXkgZG8gbm90IGFscmVhZHkgZXhpc3Qgb24gdGhlIG1lZGlhU291cmNlXG4gICAgICogMi4gdGhpcyBWU0IgaGFzIGEgY29kZWMgZm9yIHRoZW1cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVSZWFsU291cmNlQnVmZmVyc18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSZWFsU291cmNlQnVmZmVyc18oKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHR5cGVzID0gWydhdWRpbycsICd2aWRlbyddO1xuXG4gICAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIC8vIERvbid0IGNyZWF0ZSBhIFNvdXJjZUJ1ZmZlciBvZiB0aGlzIHR5cGUgaWYgd2UgZG9uJ3QgaGF2ZSBhXG4gICAgICAgIC8vIGNvZGVjIGZvciBpdFxuICAgICAgICBpZiAoIV90aGlzMlt0eXBlICsgJ0NvZGVjXyddKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBhIFNvdXJjZUJ1ZmZlciBvZiB0aGlzIHR5cGUgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKF90aGlzMlt0eXBlICsgJ0J1ZmZlcl8nXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBidWZmZXIgPSBudWxsO1xuXG4gICAgICAgIC8vIElmIHRoZSBtZWRpYXNvdXJjZSBhbHJlYWR5IGhhcyBhIFNvdXJjZUJ1ZmZlciBmb3IgdGhlIGNvZGVjXG4gICAgICAgIC8vIHVzZSB0aGF0XG4gICAgICAgIGlmIChfdGhpczIubWVkaWFTb3VyY2VfW3R5cGUgKyAnQnVmZmVyXyddKSB7XG4gICAgICAgICAgYnVmZmVyID0gX3RoaXMyLm1lZGlhU291cmNlX1t0eXBlICsgJ0J1ZmZlcl8nXTtcbiAgICAgICAgICAvLyBJbiBtdWx0aXBsZSBhdWRpbyB0cmFjayBjYXNlcywgdGhlIGF1ZGlvIHNvdXJjZSBidWZmZXIgaXMgZGlzYWJsZWRcbiAgICAgICAgICAvLyBvbiB0aGUgbWFpbiBWaXJ0dWFsU291cmNlQnVmZmVyIGJ5IHRoZSBIVE1MTWVkaWFTb3VyY2UgbXVjaCBlYXJsaWVyXG4gICAgICAgICAgLy8gdGhhbiBjcmVhdGVSZWFsU291cmNlQnVmZmVyc18gaXMgY2FsbGVkIHRvIGNyZWF0ZSB0aGUgc2Vjb25kXG4gICAgICAgICAgLy8gVmlydHVhbFNvdXJjZUJ1ZmZlciBiZWNhdXNlIHRoYXQgaGFwcGVucyBhcyBhIHNpZGUtZWZmZWN0IG9mXG4gICAgICAgICAgLy8gdmlkZW9qcy1jb250cmliLWhscyBzdGFydGluZyB0aGUgYXVkaW9TZWdtZW50TG9hZGVyLiBBcyBhIHJlc3VsdCxcbiAgICAgICAgICAvLyB0aGUgYXVkaW9CdWZmZXIgaXMgZXNzZW50aWFsbHkgXCJvd25lcmxlc3NcIiBhbmQgbm8gb25lIHdpbGwgdG9nZ2xlXG4gICAgICAgICAgLy8gdGhlIGB1cGRhdGluZ2Agc3RhdGUgYmFjayB0byBmYWxzZSBvbmNlIHRoZSBgdXBkYXRlZW5kYCBldmVudCBpcyByZWNlaXZlZFxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gU2V0dGluZyBgdXBkYXRpbmdgIHRvIGZhbHNlIG1hbnVhbGx5IHdpbGwgd29yayBhcm91bmQgdGhpc1xuICAgICAgICAgIC8vIHNpdHVhdGlvbiBhbmQgYWxsb3cgd29yayB0byBjb250aW51ZVxuICAgICAgICAgIGJ1ZmZlci51cGRhdGluZyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjb2RlY1Byb3BlcnR5ID0gdHlwZSArICdDb2RlY18nO1xuICAgICAgICAgIHZhciBtaW1lVHlwZSA9IHR5cGUgKyAnL21wNDtjb2RlY3M9XCInICsgX3RoaXMyW2NvZGVjUHJvcGVydHldICsgJ1wiJztcblxuICAgICAgICAgIGJ1ZmZlciA9IG1ha2VXcmFwcGVkU291cmNlQnVmZmVyKF90aGlzMi5tZWRpYVNvdXJjZV8ubmF0aXZlTWVkaWFTb3VyY2VfLCBtaW1lVHlwZSk7XG5cbiAgICAgICAgICBfdGhpczIubWVkaWFTb3VyY2VfW3R5cGUgKyAnQnVmZmVyXyddID0gYnVmZmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyW3R5cGUgKyAnQnVmZmVyXyddID0gYnVmZmVyO1xuXG4gICAgICAgIC8vIFdpcmUgdXAgdGhlIGV2ZW50cyB0byB0aGUgU291cmNlQnVmZmVyXG4gICAgICAgIFsndXBkYXRlJywgJ3VwZGF0ZXN0YXJ0JywgJ3VwZGF0ZWVuZCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgYnVmZmVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGlmIGF1ZGlvIGlzIGRpc2FibGVkXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiBfdGhpczIuYXVkaW9EaXNhYmxlZF8pIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09ICd1cGRhdGVlbmQnKSB7XG4gICAgICAgICAgICAgIF90aGlzMlt0eXBlICsgJ0J1ZmZlcl8nXS51cGRhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2hvdWxkVHJpZ2dlciA9IHR5cGVzLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIC8vIHNraXAgY2hlY2tpbmcgYXVkaW8ncyB1cGRhdGluZyBzdGF0dXMgaWYgYXVkaW9cbiAgICAgICAgICAgICAgLy8gaXMgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgaWYgKHQgPT09ICdhdWRpbycgJiYgX3RoaXMyLmF1ZGlvRGlzYWJsZWRfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gaWYgdGhlIG90aGVyIHR5cGUgaWYgdXBkYXRpbmcgd2UgZG9uJ3QgdHJpZ2dlclxuICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gdCAmJiBfdGhpczJbdCArICdCdWZmZXJfJ10gJiYgX3RoaXMyW3QgKyAnQnVmZmVyXyddLnVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChzaG91bGRUcmlnZ2VyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczIudHJpZ2dlcihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW11bGF0ZSB0aGUgbmF0aXZlIG1lZGlhc291cmNlIGZ1bmN0aW9uLCBidXQgb3VyIGZ1bmN0aW9uIHdpbGxcbiAgICAgKiBzZW5kIGFsbCBvZiB0aGUgcHJvcG9zZWQgc2VnbWVudHMgdG8gdGhlIHRyYW5zbXV4ZXIgc28gdGhhdCB3ZVxuICAgICAqIGNhbiB0cmFuc211eCB0aGVtIGJlZm9yZSB3ZSBhcHBlbmQgdGhlbSB0byBvdXIgaW50ZXJuYWxcbiAgICAgKiBuYXRpdmUgc291cmNlIGJ1ZmZlcnMgaW4gdGhlIGNvcnJlY3QgZm9ybWF0LlxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NvdXJjZUJ1ZmZlci9hcHBlbmRCdWZmZXJcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHNlZ21lbnQgdGhlIHNlZ21lbnQgdG8gYXBwZW5kIHRvIHRoZSBidWZmZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2FwcGVuZEJ1ZmZlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZEJ1ZmZlcihzZWdtZW50KSB7XG4gICAgICAvLyBTdGFydCB0aGUgaW50ZXJuYWwgXCJ1cGRhdGluZ1wiIHN0YXRlXG4gICAgICB0aGlzLmJ1ZmZlclVwZGF0aW5nXyA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLmF1ZGlvQnVmZmVyXyAmJiB0aGlzLmF1ZGlvQnVmZmVyXy5idWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGF1ZGlvQnVmZmVyZWQgPSB0aGlzLmF1ZGlvQnVmZmVyXy5idWZmZXJlZDtcblxuICAgICAgICB0aGlzLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBhY3Rpb246ICdzZXRBdWRpb0FwcGVuZFN0YXJ0JyxcbiAgICAgICAgICBhcHBlbmRTdGFydDogYXVkaW9CdWZmZXJlZC5lbmQoYXVkaW9CdWZmZXJlZC5sZW5ndGggLSAxKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudmlkZW9CdWZmZXJfKSB7XG4gICAgICAgIHRoaXMudHJhbnNtdXhlcl8ucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGFjdGlvbjogJ2FsaWduR29wc1dpdGgnLFxuICAgICAgICAgIGdvcHNUb0FsaWduV2l0aDogZ29wc1NhZmVUb0FsaWduV2l0aCh0aGlzLmdvcEJ1ZmZlcl8sIHRoaXMubWVkaWFTb3VyY2VfLnBsYXllcl8sIHRoaXMudGltZU1hcHBpbmdfKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmFuc211eGVyXy5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGFjdGlvbjogJ3B1c2gnLFxuICAgICAgICAvLyBTZW5kIHRoZSB0eXBlZC1hcnJheSBvZiBkYXRhIGFzIGFuIEFycmF5QnVmZmVyIHNvIHRoYXRcbiAgICAgICAgLy8gaXQgY2FuIGJlIHNlbnQgYXMgYSBcIlRyYW5zZmVyYWJsZVwiIGFuZCBhdm9pZCB0aGUgY29zdGx5XG4gICAgICAgIC8vIG1lbW9yeSBjb3B5XG4gICAgICAgIGRhdGE6IHNlZ21lbnQuYnVmZmVyLFxuXG4gICAgICAgIC8vIFRvIHJlY3JlYXRlIHRoZSBvcmlnaW5hbCB0eXBlZC1hcnJheSwgd2UgbmVlZCBpbmZvcm1hdGlvblxuICAgICAgICAvLyBhYm91dCB3aGF0IHBvcnRpb24gb2YgdGhlIEFycmF5QnVmZmVyIGl0IHdhcyBhIHZpZXcgaW50b1xuICAgICAgICBieXRlT2Zmc2V0OiBzZWdtZW50LmJ5dGVPZmZzZXQsXG4gICAgICAgIGJ5dGVMZW5ndGg6IHNlZ21lbnQuYnl0ZUxlbmd0aFxuICAgICAgfSwgW3NlZ21lbnQuYnVmZmVyXSk7XG4gICAgICB0aGlzLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiAnZmx1c2gnIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgZ29wIGluZm9ybWF0aW9uICh0aW1pbmcgYW5kIGJ5dGVMZW5ndGgpIHJlY2VpdmVkIGJ5IHRoZSB0cmFuc211eGVyIGZvciB0aGVcbiAgICAgKiBnb3BzIGFwcGVuZGVkIGluIHRoZSBsYXN0IGNhbGwgdG8gYXBwZW5kQnVmZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqICAgICAgICBUaGUgZ29wSW5mbyBldmVudCBmcm9tIHRoZSB0cmFuc211eGVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZXZlbnQuZGF0YS5nb3BJbmZvXG4gICAgICogICAgICAgIExpc3Qgb2YgZ29wIGluZm8gdG8gYXBwZW5kXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdhcHBlbmRHb3BJbmZvXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZEdvcEluZm9fKGV2ZW50KSB7XG4gICAgICB0aGlzLmdvcEJ1ZmZlcl8gPSB1cGRhdGVHb3BCdWZmZXIodGhpcy5nb3BCdWZmZXJfLCBldmVudC5kYXRhLmdvcEluZm8sIHRoaXMuc2FmZUFwcGVuZF8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtdWxhdGUgdGhlIG5hdGl2ZSBtZWRpYXNvdXJjZSBmdW5jdGlvbiBhbmQgcmVtb3ZlIHBhcnRzXG4gICAgICogb2YgdGhlIGJ1ZmZlciBmcm9tIGFueSBvZiBvdXIgaW50ZXJuYWwgYnVmZmVycyB0aGF0IGV4aXN0XG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU291cmNlQnVmZmVyL3JlbW92ZVxuICAgICAqIEBwYXJhbSB7RG91YmxlfSBzdGFydCBwb3NpdGlvbiB0byBzdGFydCB0aGUgcmVtb3ZlIGF0XG4gICAgICogQHBhcmFtIHtEb3VibGV9IGVuZCBwb3NpdGlvbiB0byBlbmQgdGhlIHJlbW92ZSBhdFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICh0aGlzLnZpZGVvQnVmZmVyXykge1xuICAgICAgICB0aGlzLnZpZGVvQnVmZmVyXy51cGRhdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudmlkZW9CdWZmZXJfLnJlbW92ZShzdGFydCwgZW5kKTtcbiAgICAgICAgdGhpcy5nb3BCdWZmZXJfID0gcmVtb3ZlR29wQnVmZmVyKHRoaXMuZ29wQnVmZmVyXywgc3RhcnQsIGVuZCwgdGhpcy50aW1lTWFwcGluZ18pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmF1ZGlvRGlzYWJsZWRfICYmIHRoaXMuYXVkaW9CdWZmZXJfKSB7XG4gICAgICAgIHRoaXMuYXVkaW9CdWZmZXJfLnVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hdWRpb0J1ZmZlcl8ucmVtb3ZlKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgTWV0YWRhdGEgQ3VlcyAoaWQzKVxuICAgICAgKDAsIF9yZW1vdmVDdWVzRnJvbVRyYWNrMlsnZGVmYXVsdCddKShzdGFydCwgZW5kLCB0aGlzLm1ldGFkYXRhVHJhY2tfKTtcblxuICAgICAgLy8gUmVtb3ZlIEFueSBDYXB0aW9uc1xuICAgICAgaWYgKHRoaXMuaW5iYW5kVGV4dFRyYWNrc18pIHtcbiAgICAgICAgZm9yICh2YXIgdHJhY2sgaW4gdGhpcy5pbmJhbmRUZXh0VHJhY2tzXykge1xuICAgICAgICAgICgwLCBfcmVtb3ZlQ3Vlc0Zyb21UcmFjazJbJ2RlZmF1bHQnXSkoc3RhcnQsIGVuZCwgdGhpcy5pbmJhbmRUZXh0VHJhY2tzX1t0cmFja10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhbnkgc2VnbWVudHMgdGhhdCB0aGUgbXV4ZXIgaGFzIG91dHB1dFxuICAgICAqIENvbmNhdGVuYXRlIHNlZ21lbnRzIHRvZ2V0aGVyIGJhc2VkIG9uIHR5cGUgYW5kIGFwcGVuZCB0aGVtIGludG9cbiAgICAgKiB0aGVpciByZXNwZWN0aXZlIHNvdXJjZUJ1ZmZlcnNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzUGVuZGluZ1NlZ21lbnRzXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NQZW5kaW5nU2VnbWVudHNfKCkge1xuICAgICAgdmFyIHNvcnRlZFNlZ21lbnRzID0ge1xuICAgICAgICB2aWRlbzoge1xuICAgICAgICAgIHNlZ21lbnRzOiBbXSxcbiAgICAgICAgICBieXRlczogMFxuICAgICAgICB9LFxuICAgICAgICBhdWRpbzoge1xuICAgICAgICAgIHNlZ21lbnRzOiBbXSxcbiAgICAgICAgICBieXRlczogMFxuICAgICAgICB9LFxuICAgICAgICBjYXB0aW9uczogW10sXG4gICAgICAgIG1ldGFkYXRhOiBbXVxuICAgICAgfTtcblxuICAgICAgLy8gU29ydCBzZWdtZW50cyBpbnRvIHNlcGFyYXRlIHZpZGVvL2F1ZGlvIGFycmF5cyBhbmRcbiAgICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlaXIgdG90YWwgYnl0ZSBsZW5ndGhzXG4gICAgICBzb3J0ZWRTZWdtZW50cyA9IHRoaXMucGVuZGluZ0J1ZmZlcnNfLnJlZHVjZShmdW5jdGlvbiAoc2VnbWVudE9iaiwgc2VnbWVudCkge1xuICAgICAgICB2YXIgdHlwZSA9IHNlZ21lbnQudHlwZTtcbiAgICAgICAgdmFyIGRhdGEgPSBzZWdtZW50LmRhdGE7XG4gICAgICAgIHZhciBpbml0U2VnbWVudCA9IHNlZ21lbnQuaW5pdFNlZ21lbnQ7XG5cbiAgICAgICAgc2VnbWVudE9ialt0eXBlXS5zZWdtZW50cy5wdXNoKGRhdGEpO1xuICAgICAgICBzZWdtZW50T2JqW3R5cGVdLmJ5dGVzICs9IGRhdGEuYnl0ZUxlbmd0aDtcblxuICAgICAgICBzZWdtZW50T2JqW3R5cGVdLmluaXRTZWdtZW50ID0gaW5pdFNlZ21lbnQ7XG5cbiAgICAgICAgLy8gR2F0aGVyIGFueSBjYXB0aW9ucyBpbnRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgIGlmIChzZWdtZW50LmNhcHRpb25zKSB7XG4gICAgICAgICAgc2VnbWVudE9iai5jYXB0aW9ucyA9IHNlZ21lbnRPYmouY2FwdGlvbnMuY29uY2F0KHNlZ21lbnQuY2FwdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlZ21lbnQuaW5mbykge1xuICAgICAgICAgIHNlZ21lbnRPYmpbdHlwZV0uaW5mbyA9IHNlZ21lbnQuaW5mbztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdhdGhlciBhbnkgbWV0YWRhdGEgaW50byBhIHNpbmdsZSBhcnJheVxuICAgICAgICBpZiAoc2VnbWVudC5tZXRhZGF0YSkge1xuICAgICAgICAgIHNlZ21lbnRPYmoubWV0YWRhdGEgPSBzZWdtZW50T2JqLm1ldGFkYXRhLmNvbmNhdChzZWdtZW50Lm1ldGFkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWdtZW50T2JqO1xuICAgICAgfSwgc29ydGVkU2VnbWVudHMpO1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIHJlYWwgc291cmNlIGJ1ZmZlcnMgaWYgdGhleSBkb24ndCBleGlzdCBieSBub3cgc2luY2Ugd2VcbiAgICAgIC8vIGZpbmFsbHkgYXJlIHN1cmUgd2hhdCB0cmFja3MgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc291cmNlXG4gICAgICBpZiAoIXRoaXMudmlkZW9CdWZmZXJfICYmICF0aGlzLmF1ZGlvQnVmZmVyXykge1xuICAgICAgICAvLyBSZW1vdmUgYW55IGNvZGVjcyB0aGF0IG1heSBoYXZlIGJlZW4gc3BlY2lmaWVkIGJ5IGRlZmF1bHQgYnV0XG4gICAgICAgIC8vIGFyZSBubyBsb25nZXIgYXBwbGljYWJsZSBub3dcbiAgICAgICAgaWYgKHNvcnRlZFNlZ21lbnRzLnZpZGVvLmJ5dGVzID09PSAwKSB7XG4gICAgICAgICAgdGhpcy52aWRlb0NvZGVjXyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvcnRlZFNlZ21lbnRzLmF1ZGlvLmJ5dGVzID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5hdWRpb0NvZGVjXyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNyZWF0ZVJlYWxTb3VyY2VCdWZmZXJzXygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc29ydGVkU2VnbWVudHMuYXVkaW8uaW5mbykge1xuICAgICAgICB0aGlzLm1lZGlhU291cmNlXy50cmlnZ2VyKHsgdHlwZTogJ2F1ZGlvaW5mbycsIGluZm86IHNvcnRlZFNlZ21lbnRzLmF1ZGlvLmluZm8gfSk7XG4gICAgICB9XG4gICAgICBpZiAoc29ydGVkU2VnbWVudHMudmlkZW8uaW5mbykge1xuICAgICAgICB0aGlzLm1lZGlhU291cmNlXy50cmlnZ2VyKHsgdHlwZTogJ3ZpZGVvaW5mbycsIGluZm86IHNvcnRlZFNlZ21lbnRzLnZpZGVvLmluZm8gfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmFwcGVuZEF1ZGlvSW5pdFNlZ21lbnRfKSB7XG4gICAgICAgIGlmICghdGhpcy5hdWRpb0Rpc2FibGVkXyAmJiB0aGlzLmF1ZGlvQnVmZmVyXykge1xuICAgICAgICAgIHNvcnRlZFNlZ21lbnRzLmF1ZGlvLnNlZ21lbnRzLnVuc2hpZnQoc29ydGVkU2VnbWVudHMuYXVkaW8uaW5pdFNlZ21lbnQpO1xuICAgICAgICAgIHNvcnRlZFNlZ21lbnRzLmF1ZGlvLmJ5dGVzICs9IHNvcnRlZFNlZ21lbnRzLmF1ZGlvLmluaXRTZWdtZW50LmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBlbmRBdWRpb0luaXRTZWdtZW50XyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJpZ2dlclVwZGF0ZWVuZCA9IGZhbHNlO1xuXG4gICAgICAvLyBNZXJnZSBtdWx0aXBsZSB2aWRlbyBhbmQgYXVkaW8gc2VnbWVudHMgaW50byBvbmUgYW5kIGFwcGVuZFxuICAgICAgaWYgKHRoaXMudmlkZW9CdWZmZXJfICYmIHNvcnRlZFNlZ21lbnRzLnZpZGVvLmJ5dGVzKSB7XG4gICAgICAgIHNvcnRlZFNlZ21lbnRzLnZpZGVvLnNlZ21lbnRzLnVuc2hpZnQoc29ydGVkU2VnbWVudHMudmlkZW8uaW5pdFNlZ21lbnQpO1xuICAgICAgICBzb3J0ZWRTZWdtZW50cy52aWRlby5ieXRlcyArPSBzb3J0ZWRTZWdtZW50cy52aWRlby5pbml0U2VnbWVudC5ieXRlTGVuZ3RoO1xuICAgICAgICB0aGlzLmNvbmNhdEFuZEFwcGVuZFNlZ21lbnRzXyhzb3J0ZWRTZWdtZW50cy52aWRlbywgdGhpcy52aWRlb0J1ZmZlcl8pO1xuICAgICAgICAvLyBUT0RPOiBhcmUgdmlkZW8gdHJhY2tzIHRoZSBvbmx5IG9uZXMgd2l0aCB0ZXh0IHRyYWNrcz9cbiAgICAgICAgKDAsIF9hZGRUZXh0VHJhY2tEYXRhLmFkZFRleHRUcmFja0RhdGEpKHRoaXMsIHNvcnRlZFNlZ21lbnRzLmNhcHRpb25zLCBzb3J0ZWRTZWdtZW50cy5tZXRhZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudmlkZW9CdWZmZXJfICYmICh0aGlzLmF1ZGlvRGlzYWJsZWRfIHx8ICF0aGlzLmF1ZGlvQnVmZmVyXykpIHtcbiAgICAgICAgLy8gVGhlIHRyYW5zbXV4ZXIgZGlkIG5vdCByZXR1cm4gYW55IGJ5dGVzIG9mIHZpZGVvLCBtZWFuaW5nIGl0IHdhcyBhbGwgdHJpbW1lZFxuICAgICAgICAvLyBmb3IgZ29wIGFsaWdubWVudC4gU2luY2Ugd2UgaGF2ZSBhIHZpZGVvIGJ1ZmZlciBhbmQgYXVkaW8gaXMgZGlzYWJsZWQsIHVwZGF0ZWVuZFxuICAgICAgICAvLyB3aWxsIG5ldmVyIGJlIHRyaWdnZXJlZCBieSB0aGlzIHNvdXJjZSBidWZmZXIsIHdoaWNoIHdpbGwgY2F1c2UgY29udHJpYi1obHNcbiAgICAgICAgLy8gdG8gYmUgc3R1Y2sgZm9yZXZlciB3YWl0aW5nIGZvciB1cGRhdGVlbmQuIElmIGF1ZGlvIGlzIG5vdCBkaXNhYmxlZCwgdXBkYXRlZW5kXG4gICAgICAgIC8vIHdpbGwgYmUgdHJpZ2dlcmVkIGJ5IHRoZSBhdWRpbyBidWZmZXIsIHdoaWNoIHdpbGwgYmUgc2VudCB1cHdhcmRzIHNpbmNlIHRoZSB2aWRlb1xuICAgICAgICAvLyBidWZmZXIgd2lsbCBub3QgYmUgaW4gYW4gdXBkYXRpbmcgc3RhdGUuXG4gICAgICAgIHRyaWdnZXJVcGRhdGVlbmQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuYXVkaW9EaXNhYmxlZF8gJiYgdGhpcy5hdWRpb0J1ZmZlcl8pIHtcbiAgICAgICAgdGhpcy5jb25jYXRBbmRBcHBlbmRTZWdtZW50c18oc29ydGVkU2VnbWVudHMuYXVkaW8sIHRoaXMuYXVkaW9CdWZmZXJfKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyc18ubGVuZ3RoID0gMDtcblxuICAgICAgaWYgKHRyaWdnZXJVcGRhdGVlbmQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd1cGRhdGVlbmQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYXJlIG5vIGxvbmdlciBpbiB0aGUgaW50ZXJuYWwgXCJ1cGRhdGluZ1wiIHN0YXRlXG4gICAgICB0aGlzLmJ1ZmZlclVwZGF0aW5nXyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbWJpbmUgYWxsIHNlZ21lbnRzIGludG8gYSBzaW5nbGUgVWludDhBcnJheSBhbmQgdGhlbiBhcHBlbmQgdGhlbVxuICAgICAqIHRvIHRoZSBkZXN0aW5hdGlvbiBidWZmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWdtZW50T2JqXG4gICAgICogQHBhcmFtIHtTb3VyY2VCdWZmZXJ9IGRlc3RpbmF0aW9uQnVmZmVyIG5hdGl2ZSBzb3VyY2UgYnVmZmVyIHRvIGFwcGVuZCBkYXRhIHRvXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2NvbmNhdEFuZEFwcGVuZFNlZ21lbnRzXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmNhdEFuZEFwcGVuZFNlZ21lbnRzXyhzZWdtZW50T2JqLCBkZXN0aW5hdGlvbkJ1ZmZlcikge1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICB2YXIgdGVtcEJ1ZmZlciA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHNlZ21lbnRPYmouYnl0ZXMpIHtcbiAgICAgICAgdGVtcEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHNlZ21lbnRPYmouYnl0ZXMpO1xuXG4gICAgICAgIC8vIENvbWJpbmUgdGhlIGluZGl2aWR1YWwgc2VnbWVudHMgaW50byBvbmUgbGFyZ2UgdHlwZWQtYXJyYXlcbiAgICAgICAgc2VnbWVudE9iai5zZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgICAgdGVtcEJ1ZmZlci5zZXQoc2VnbWVudCwgb2Zmc2V0KTtcbiAgICAgICAgICBvZmZzZXQgKz0gc2VnbWVudC5ieXRlTGVuZ3RoO1xuICAgICAgICB9KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGRlc3RpbmF0aW9uQnVmZmVyLnVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBkZXN0aW5hdGlvbkJ1ZmZlci5hcHBlbmRCdWZmZXIodGVtcEJ1ZmZlcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaWYgKHRoaXMubWVkaWFTb3VyY2VfLnBsYXllcl8pIHtcbiAgICAgICAgICAgIHRoaXMubWVkaWFTb3VyY2VfLnBsYXllcl8uZXJyb3Ioe1xuICAgICAgICAgICAgICBjb2RlOiAtMyxcbiAgICAgICAgICAgICAgdHlwZTogJ0FQUEVORF9CVUZGRVJfRVJSJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvcjogZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtdWxhdGUgdGhlIG5hdGl2ZSBtZWRpYXNvdXJjZSBmdW5jdGlvbi4gYWJvcnQgYW55IHNvdXJlQnVmZmVyXG4gICAgICogYWN0aW9ucyBhbmQgdGhyb3cgb3V0IGFueSB1bi1hcHBlbmRlZCBkYXRhLlxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NvdXJjZUJ1ZmZlci9hYm9ydFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnYWJvcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIGlmICh0aGlzLnZpZGVvQnVmZmVyXykge1xuICAgICAgICB0aGlzLnZpZGVvQnVmZmVyXy5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmF1ZGlvRGlzYWJsZWRfICYmIHRoaXMuYXVkaW9CdWZmZXJfKSB7XG4gICAgICAgIHRoaXMuYXVkaW9CdWZmZXJfLmFib3J0KCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50cmFuc211eGVyXykge1xuICAgICAgICB0aGlzLnRyYW5zbXV4ZXJfLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiAncmVzZXQnIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyc18ubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuYnVmZmVyVXBkYXRpbmdfID0gZmFsc2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZpcnR1YWxTb3VyY2VCdWZmZXI7XG59KShfdmlkZW9KczJbJ2RlZmF1bHQnXS5FdmVudFRhcmdldCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFZpcnR1YWxTb3VyY2VCdWZmZXI7XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi9hZGQtdGV4dC10cmFjay1kYXRhXCI6NjQsXCIuL2NvZGVjLXV0aWxzXCI6NjUsXCIuL2NyZWF0ZS10ZXh0LXRyYWNrcy1pZi1uZWNlc3NhcnlcIjo2NixcIi4vcmVtb3ZlLWN1ZXMtZnJvbS10cmFja1wiOjcyLFwiLi90cmFuc211eGVyLXdvcmtlclwiOjczLFwid2Vid29ya2lmeVwiOjc2fV0sNzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGJ1bmRsZUZuID0gYXJndW1lbnRzWzNdO1xudmFyIHNvdXJjZXMgPSBhcmd1bWVudHNbNF07XG52YXIgY2FjaGUgPSBhcmd1bWVudHNbNV07XG5cbnZhciBzdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIHZhciB3a2V5O1xuICAgIHZhciBjYWNoZUtleXMgPSBPYmplY3Qua2V5cyhjYWNoZSk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYWNoZUtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBjYWNoZUtleXNbaV07XG4gICAgICAgIGlmIChjYWNoZVtrZXldLmV4cG9ydHMgPT09IGZuKSB7XG4gICAgICAgICAgICB3a2V5ID0ga2V5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKCF3a2V5KSB7XG4gICAgICAgIHdrZXkgPSBNYXRoLmZsb29yKE1hdGgucG93KDE2LCA4KSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgdmFyIHdjYWNoZSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNhY2hlS2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjYWNoZUtleXNbaV07XG4gICAgICAgICAgICB3Y2FjaGVba2V5XSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VzW3drZXldID0gW1xuICAgICAgICAgICAgRnVuY3Rpb24oWydyZXF1aXJlJywnbW9kdWxlJywnZXhwb3J0cyddLCAnKCcgKyBmbiArICcpKHNlbGYpJyksXG4gICAgICAgICAgICB3Y2FjaGVcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFyIHNrZXkgPSBNYXRoLmZsb29yKE1hdGgucG93KDE2LCA4KSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcbiAgICBcbiAgICB2YXIgc2NhY2hlID0ge307IHNjYWNoZVt3a2V5XSA9IHdrZXk7XG4gICAgc291cmNlc1tza2V5XSA9IFtcbiAgICAgICAgRnVuY3Rpb24oWydyZXF1aXJlJ10sJ3JlcXVpcmUoJyArIHN0cmluZ2lmeSh3a2V5KSArICcpKHNlbGYpJyksXG4gICAgICAgIHNjYWNoZVxuICAgIF07XG4gICAgXG4gICAgdmFyIHNyYyA9ICcoJyArIGJ1bmRsZUZuICsgJykoeydcbiAgICAgICAgKyBPYmplY3Qua2V5cyhzb3VyY2VzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShrZXkpICsgJzpbJ1xuICAgICAgICAgICAgICAgICsgc291cmNlc1trZXldWzBdXG4gICAgICAgICAgICAgICAgKyAnLCcgKyBzdHJpbmdpZnkoc291cmNlc1trZXldWzFdKSArICddJ1xuICAgICAgICAgICAgO1xuICAgICAgICB9KS5qb2luKCcsJylcbiAgICAgICAgKyAnfSx7fSxbJyArIHN0cmluZ2lmeShza2V5KSArICddKSdcbiAgICA7XG4gICAgXG4gICAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCB8fCB3aW5kb3cubW96VVJMIHx8IHdpbmRvdy5tc1VSTDtcbiAgICBcbiAgICByZXR1cm4gbmV3IFdvcmtlcihVUkwuY3JlYXRlT2JqZWN0VVJMKFxuICAgICAgICBuZXcgQmxvYihbc3JjXSwgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KVxuICAgICkpO1xufTtcblxufSx7fV0sNzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBAZmlsZSB2aWRlb2pzLWNvbnRyaWItaGxzLmpzXG4gKlxuICogVGhlIG1haW4gZmlsZSBmb3IgdGhlIEhMUyBwcm9qZWN0LlxuICogTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW9qcy1jb250cmliLWhscy9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3g0LCBfeDUsIF94NikgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeDQsIHByb3BlcnR5ID0gX3g1LCByZWNlaXZlciA9IF94NjsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeDQgPSBwYXJlbnQ7IF94NSA9IHByb3BlcnR5OyBfeDYgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2dsb2JhbERvY3VtZW50ID0gcmVxdWlyZSgnZ2xvYmFsL2RvY3VtZW50Jyk7XG5cbnZhciBfZ2xvYmFsRG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xvYmFsRG9jdW1lbnQpO1xuXG52YXIgX3BsYXlsaXN0TG9hZGVyID0gcmVxdWlyZSgnLi9wbGF5bGlzdC1sb2FkZXInKTtcblxudmFyIF9wbGF5bGlzdExvYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF5bGlzdExvYWRlcik7XG5cbnZhciBfcGxheWxpc3QgPSByZXF1aXJlKCcuL3BsYXlsaXN0Jyk7XG5cbnZhciBfcGxheWxpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxheWxpc3QpO1xuXG52YXIgX3hociA9IHJlcXVpcmUoJy4veGhyJyk7XG5cbnZhciBfeGhyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3hocik7XG5cbnZhciBfYWVzRGVjcnlwdGVyID0gcmVxdWlyZSgnYWVzLWRlY3J5cHRlcicpO1xuXG52YXIgX2JpblV0aWxzID0gcmVxdWlyZSgnLi9iaW4tdXRpbHMnKTtcblxudmFyIF9iaW5VdGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iaW5VdGlscyk7XG5cbnZhciBfdmlkZW9qc0NvbnRyaWJNZWRpYVNvdXJjZXMgPSByZXF1aXJlKCd2aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlcycpO1xuXG52YXIgX20zdThQYXJzZXIgPSByZXF1aXJlKCdtM3U4LXBhcnNlcicpO1xuXG52YXIgX20zdThQYXJzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbTN1OFBhcnNlcik7XG5cbnZhciBfdmlkZW9KcyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2aWRlb2pzJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd2aWRlb2pzJ10gOiBudWxsKTtcblxudmFyIF92aWRlb0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZpZGVvSnMpO1xuXG52YXIgX21hc3RlclBsYXlsaXN0Q29udHJvbGxlciA9IHJlcXVpcmUoJy4vbWFzdGVyLXBsYXlsaXN0LWNvbnRyb2xsZXInKTtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG52YXIgX2NvbmZpZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25maWcpO1xuXG52YXIgX3JlbmRpdGlvbk1peGluID0gcmVxdWlyZSgnLi9yZW5kaXRpb24tbWl4aW4nKTtcblxudmFyIF9yZW5kaXRpb25NaXhpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZW5kaXRpb25NaXhpbik7XG5cbnZhciBfZ2xvYmFsV2luZG93ID0gcmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgX2dsb2JhbFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxXaW5kb3cpO1xuXG52YXIgX3BsYXliYWNrV2F0Y2hlciA9IHJlcXVpcmUoJy4vcGxheWJhY2std2F0Y2hlcicpO1xuXG52YXIgX3BsYXliYWNrV2F0Y2hlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF5YmFja1dhdGNoZXIpO1xuXG52YXIgX3JlbG9hZFNvdXJjZU9uRXJyb3IgPSByZXF1aXJlKCcuL3JlbG9hZC1zb3VyY2Utb24tZXJyb3InKTtcblxudmFyIF9yZWxvYWRTb3VyY2VPbkVycm9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbG9hZFNvdXJjZU9uRXJyb3IpO1xuXG52YXIgX3BsYXlsaXN0U2VsZWN0b3JzSnMgPSByZXF1aXJlKCcuL3BsYXlsaXN0LXNlbGVjdG9ycy5qcycpO1xuXG52YXIgSGxzID0ge1xuICBQbGF5bGlzdExvYWRlcjogX3BsYXlsaXN0TG9hZGVyMlsnZGVmYXVsdCddLFxuICBQbGF5bGlzdDogX3BsYXlsaXN0MlsnZGVmYXVsdCddLFxuICBEZWNyeXB0ZXI6IF9hZXNEZWNyeXB0ZXIuRGVjcnlwdGVyLFxuICBBc3luY1N0cmVhbTogX2Flc0RlY3J5cHRlci5Bc3luY1N0cmVhbSxcbiAgZGVjcnlwdDogX2Flc0RlY3J5cHRlci5kZWNyeXB0LFxuICB1dGlsczogX2JpblV0aWxzMlsnZGVmYXVsdCddLFxuXG4gIFNUQU5EQVJEX1BMQVlMSVNUX1NFTEVDVE9SOiBfcGxheWxpc3RTZWxlY3RvcnNKcy5sYXN0QmFuZHdpZHRoU2VsZWN0b3IsXG4gIElOSVRJQUxfUExBWUxJU1RfU0VMRUNUT1I6IF9wbGF5bGlzdFNlbGVjdG9yc0pzLmxvd2VzdEJpdHJhdGVDb21wYXRpYmxlVmFyaWFudFNlbGVjdG9yLFxuICBjb21wYXJlUGxheWxpc3RCYW5kd2lkdGg6IF9wbGF5bGlzdFNlbGVjdG9yc0pzLmNvbXBhcmVQbGF5bGlzdEJhbmR3aWR0aCxcbiAgY29tcGFyZVBsYXlsaXN0UmVzb2x1dGlvbjogX3BsYXlsaXN0U2VsZWN0b3JzSnMuY29tcGFyZVBsYXlsaXN0UmVzb2x1dGlvbixcblxuICB4aHI6ICgwLCBfeGhyMlsnZGVmYXVsdCddKSgpXG59O1xuXG4vLyAwLjUgTUIvc1xudmFyIElOSVRJQUxfQkFORFdJRFRIID0gNDE5NDMwNDtcblxuLy8gRGVmaW5lIGdldHRlci9zZXR0ZXJzIGZvciBjb25maWcgcHJvcGVyaXRlc1xuWydHT0FMX0JVRkZFUl9MRU5HVEgnLCAnTUFYX0dPQUxfQlVGRkVSX0xFTkdUSCcsICdHT0FMX0JVRkZFUl9MRU5HVEhfUkFURScsICdCVUZGRVJfTE9XX1dBVEVSX0xJTkUnLCAnTUFYX0JVRkZFUl9MT1dfV0FURVJfTElORScsICdCVUZGRVJfTE9XX1dBVEVSX0xJTkVfUkFURScsICdCQU5EV0lEVEhfVkFSSUFOQ0UnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIbHMsIHByb3AsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIF92aWRlb0pzMlsnZGVmYXVsdCddLmxvZy53YXJuKCd1c2luZyBIbHMuJyArIHByb3AgKyAnIGlzIFVOU0FGRSBiZSBzdXJlIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZycpO1xuICAgICAgcmV0dXJuIF9jb25maWcyWydkZWZhdWx0J11bcHJvcF07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgX3ZpZGVvSnMyWydkZWZhdWx0J10ubG9nLndhcm4oJ3VzaW5nIEhscy4nICsgcHJvcCArICcgaXMgVU5TQUZFIGJlIHN1cmUgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nJyk7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICBfdmlkZW9KczJbJ2RlZmF1bHQnXS5sb2cud2FybigndmFsdWUgb2YgSGxzLicgKyBwcm9wICsgJyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX2NvbmZpZzJbJ2RlZmF1bHQnXVtwcm9wXSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG59KTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBzZWxlY3RlZEluZGV4IG9mIHRoZSBRdWFsaXR5TGV2ZWxMaXN0IHdoZW4gYSBtZWRpYWNoYW5nZSBoYXBwZW5zIGluIGhscy5cbiAqXG4gKiBAcGFyYW0ge1F1YWxpdHlMZXZlbExpc3R9IHF1YWxpdHlMZXZlbHMgVGhlIFF1YWxpdHlMZXZlbExpc3QgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtQbGF5bGlzdExvYWRlcn0gcGxheWxpc3RMb2FkZXIgUGxheWxpc3RMb2FkZXIgY29udGFpbmluZyB0aGUgbmV3IG1lZGlhIGluZm8uXG4gKiBAZnVuY3Rpb24gaGFuZGxlSGxzTWVkaWFDaGFuZ2VcbiAqL1xudmFyIGhhbmRsZUhsc01lZGlhQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlSGxzTWVkaWFDaGFuZ2UocXVhbGl0eUxldmVscywgcGxheWxpc3RMb2FkZXIpIHtcbiAgdmFyIG5ld1BsYXlsaXN0ID0gcGxheWxpc3RMb2FkZXIubWVkaWEoKTtcbiAgdmFyIHNlbGVjdGVkSW5kZXggPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1YWxpdHlMZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocXVhbGl0eUxldmVsc1tpXS5pZCA9PT0gbmV3UGxheWxpc3QudXJpKSB7XG4gICAgICBzZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHF1YWxpdHlMZXZlbHMuc2VsZWN0ZWRJbmRleF8gPSBzZWxlY3RlZEluZGV4O1xuICBxdWFsaXR5TGV2ZWxzLnRyaWdnZXIoe1xuICAgIHNlbGVjdGVkSW5kZXg6IHNlbGVjdGVkSW5kZXgsXG4gICAgdHlwZTogJ2NoYW5nZSdcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFkZHMgcXVhbGl0eSBsZXZlbHMgdG8gbGlzdCBvbmNlIHBsYXlsaXN0IG1ldGFkYXRhIGlzIGF2YWlsYWJsZVxuICpcbiAqIEBwYXJhbSB7UXVhbGl0eUxldmVsTGlzdH0gcXVhbGl0eUxldmVscyBUaGUgUXVhbGl0eUxldmVsTGlzdCB0byBhdHRhY2ggZXZlbnRzIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IGhscyBIbHMgb2JqZWN0IHRvIGxpc3RlbiB0byBmb3IgbWVkaWEgZXZlbnRzLlxuICogQGZ1bmN0aW9uIGhhbmRsZUhsc0xvYWRlZE1ldGFkYXRhXG4gKi9cbnZhciBoYW5kbGVIbHNMb2FkZWRNZXRhZGF0YSA9IGZ1bmN0aW9uIGhhbmRsZUhsc0xvYWRlZE1ldGFkYXRhKHF1YWxpdHlMZXZlbHMsIGhscykge1xuICBobHMucmVwcmVzZW50YXRpb25zKCkuZm9yRWFjaChmdW5jdGlvbiAocmVwKSB7XG4gICAgcXVhbGl0eUxldmVscy5hZGRRdWFsaXR5TGV2ZWwocmVwKTtcbiAgfSk7XG4gIGhhbmRsZUhsc01lZGlhQ2hhbmdlKHF1YWxpdHlMZXZlbHMsIGhscy5wbGF5bGlzdHMpO1xufTtcblxuLy8gSExTIGlzIGEgc291cmNlIGhhbmRsZXIsIG5vdCBhIHRlY2guIE1ha2Ugc3VyZSBhdHRlbXB0cyB0byB1c2UgaXRcbi8vIGFzIG9uZSBkbyBub3QgY2F1c2UgZXhjZXB0aW9ucy5cbkhscy5jYW5QbGF5U291cmNlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX3ZpZGVvSnMyWydkZWZhdWx0J10ubG9nLndhcm4oJ0hMUyBpcyBubyBsb25nZXIgYSB0ZWNoLiBQbGVhc2UgcmVtb3ZlIGl0IGZyb20gJyArICd5b3VyIHBsYXllclxcJ3MgdGVjaE9yZGVyLicpO1xufTtcblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBicm93c2VyIGhhcyBidWlsdC1pbiBITFMgc3VwcG9ydC5cbiAqL1xuSGxzLnN1cHBvcnRzTmF0aXZlSGxzID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZpZGVvID0gX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG5cbiAgLy8gbmF0aXZlIEhMUyBpcyBkZWZpbml0ZWx5IG5vdCBzdXBwb3J0ZWQgaWYgSFRNTDUgdmlkZW8gaXNuJ3RcbiAgaWYgKCFfdmlkZW9KczJbJ2RlZmF1bHQnXS5nZXRUZWNoKCdIdG1sNScpLmlzU3VwcG9ydGVkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBITFMgbWFuaWZlc3RzIGNhbiBnbyBieSBtYW55IG1pbWUtdHlwZXNcbiAgdmFyIGNhblBsYXkgPSBbXG4gIC8vIEFwcGxlIHNhbnRpb25lZFxuICAnYXBwbGljYXRpb24vdm5kLmFwcGxlLm1wZWd1cmwnLFxuICAvLyBBcHBsZSBzYW5jdGlvbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAnYXVkaW8vbXBlZ3VybCcsXG4gIC8vIFZlcnkgY29tbW9uXG4gICdhdWRpby94LW1wZWd1cmwnLFxuICAvLyBWZXJ5IGNvbW1vblxuICAnYXBwbGljYXRpb24veC1tcGVndXJsJyxcbiAgLy8gSW5jbHVkZWQgZm9yIGNvbXBsZXRlbmVzc1xuICAndmlkZW8veC1tcGVndXJsJywgJ3ZpZGVvL21wZWd1cmwnLCAnYXBwbGljYXRpb24vbXBlZ3VybCddO1xuXG4gIHJldHVybiBjYW5QbGF5LnNvbWUoZnVuY3Rpb24gKGNhbkl0UGxheSkge1xuICAgIHJldHVybiAoL21heWJlfHByb2JhYmx5L2kudGVzdCh2aWRlby5jYW5QbGF5VHlwZShjYW5JdFBsYXkpKVxuICAgICk7XG4gIH0pO1xufSkoKTtcblxuLyoqXG4gKiBITFMgaXMgYSBzb3VyY2UgaGFuZGxlciwgbm90IGEgdGVjaC4gTWFrZSBzdXJlIGF0dGVtcHRzIHRvIHVzZSBpdFxuICogYXMgb25lIGRvIG5vdCBjYXVzZSBleGNlcHRpb25zLlxuICovXG5IbHMuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfdmlkZW9KczJbJ2RlZmF1bHQnXS5sb2cud2FybignSExTIGlzIG5vIGxvbmdlciBhIHRlY2guIFBsZWFzZSByZW1vdmUgaXQgZnJvbSAnICsgJ3lvdXIgcGxheWVyXFwncyB0ZWNoT3JkZXIuJyk7XG59O1xuXG52YXIgQ29tcG9uZW50ID0gX3ZpZGVvSnMyWydkZWZhdWx0J10uZ2V0Q29tcG9uZW50KCdDb21wb25lbnQnKTtcblxuLyoqXG4gKiBUaGUgSGxzIEhhbmRsZXIgb2JqZWN0LCB3aGVyZSB3ZSBvcmNoZXN0cmF0ZSBhbGwgb2YgdGhlIHBhcnRzXG4gKiBvZiBITFMgdG8gaW50ZXJhY3Qgd2l0aCB2aWRlby5qc1xuICpcbiAqIEBjbGFzcyBIbHNIYW5kbGVyXG4gKiBAZXh0ZW5kcyB2aWRlb2pzLkNvbXBvbmVudFxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSB0aGUgc29ydWNlIG9iamVjdFxuICogQHBhcmFtIHtUZWNofSB0ZWNoIHRoZSBwYXJlbnQgdGVjaCBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbmFsIGFuZCByZXF1aXJlZCBvcHRpb25zXG4gKi9cblxudmFyIEhsc0hhbmRsZXIgPSAoZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEhsc0hhbmRsZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEhsc0hhbmRsZXIoc291cmNlLCB0ZWNoLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIbHNIYW5kbGVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEhsc0hhbmRsZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzLCB0ZWNoLCBvcHRpb25zLmhscyk7XG5cbiAgICAvLyB0ZWNoLnBsYXllcigpIGlzIGRlcHJlY2F0ZWQgYnV0IHNldHVwIGEgcmVmZXJlbmNlIHRvIEhMUyBmb3JcbiAgICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eVxuICAgIGlmICh0ZWNoLm9wdGlvbnNfICYmIHRlY2gub3B0aW9uc18ucGxheWVySWQpIHtcbiAgICAgIHZhciBfcGxheWVyID0gKDAsIF92aWRlb0pzMlsnZGVmYXVsdCddKSh0ZWNoLm9wdGlvbnNfLnBsYXllcklkKTtcblxuICAgICAgaWYgKCFfcGxheWVyLmhhc093blByb3BlcnR5KCdobHMnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3BsYXllciwgJ2hscycsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIF92aWRlb0pzMlsnZGVmYXVsdCddLmxvZy53YXJuKCdwbGF5ZXIuaGxzIGlzIGRlcHJlY2F0ZWQuIFVzZSBwbGF5ZXIudGVjaF8uaGxzIGluc3RlYWQuJyk7XG4gICAgICAgICAgICB0ZWNoLnRyaWdnZXIoeyB0eXBlOiAndXNhZ2UnLCBuYW1lOiAnaGxzLXBsYXllci1hY2Nlc3MnIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50ZWNoXyA9IHRlY2g7XG4gICAgdGhpcy5zb3VyY2VfID0gc291cmNlO1xuICAgIHRoaXMuc3RhdHMgPSB7fTtcbiAgICB0aGlzLmlnbm9yZU5leHRTZWVraW5nRXZlbnRfID0gZmFsc2U7XG4gICAgdGhpcy5zZXRPcHRpb25zXygpO1xuXG4gICAgLy8gb3ZlcnJpZGluZyBuYXRpdmUgSExTIG9ubHkgd29ya3MgaWYgYXVkaW8gdHJhY2tzIGhhdmUgYmVlbiBlbXVsYXRlZFxuICAgIC8vIGVycm9yIGVhcmx5IGlmIHdlJ3JlIG1pc2NvbmZpZ3VyZWQ6XG4gICAgaWYgKHRoaXMub3B0aW9uc18ub3ZlcnJpZGVOYXRpdmUgJiYgKHRlY2guZmVhdHVyZXNOYXRpdmVWaWRlb1RyYWNrcyB8fCB0ZWNoLmZlYXR1cmVzTmF0aXZlQXVkaW9UcmFja3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJyaWRpbmcgbmF0aXZlIEhMUyByZXF1aXJlcyBlbXVsYXRlZCB0cmFja3MuICcgKyAnU2VlIGh0dHBzOi8vZ2l0LmlvL3ZNcGpCJyk7XG4gICAgfVxuXG4gICAgLy8gbGlzdGVuIGZvciBmdWxsc2NyZWVuY2hhbmdlIGV2ZW50cyBmb3IgdGhpcyBwbGF5ZXIgc28gdGhhdCB3ZVxuICAgIC8vIGNhbiBhZGp1c3Qgb3VyIHF1YWxpdHkgc2VsZWN0aW9uIHF1aWNrbHlcbiAgICB0aGlzLm9uKF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXSwgWydmdWxsc2NyZWVuY2hhbmdlJywgJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLCAnbW96ZnVsbHNjcmVlbmNoYW5nZScsICdNU0Z1bGxzY3JlZW5DaGFuZ2UnXSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgZnVsbHNjcmVlbkVsZW1lbnQgPSBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10uZnVsbHNjcmVlbkVsZW1lbnQgfHwgX2dsb2JhbERvY3VtZW50MlsnZGVmYXVsdCddLndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IHx8IF9nbG9iYWxEb2N1bWVudDJbJ2RlZmF1bHQnXS5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fCBfZ2xvYmFsRG9jdW1lbnQyWydkZWZhdWx0J10ubXNGdWxsc2NyZWVuRWxlbWVudDtcblxuICAgICAgaWYgKGZ1bGxzY3JlZW5FbGVtZW50ICYmIGZ1bGxzY3JlZW5FbGVtZW50LmNvbnRhaW5zKF90aGlzLnRlY2hfLmVsKCkpKSB7XG4gICAgICAgIF90aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8uZmFzdFF1YWxpdHlDaGFuZ2VfKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdzZWVraW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuaWdub3JlTmV4dFNlZWtpbmdFdmVudF8pIHtcbiAgICAgICAgdGhpcy5pZ25vcmVOZXh0U2Vla2luZ0V2ZW50XyA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0Q3VycmVudFRpbWUodGhpcy50ZWNoXy5jdXJyZW50VGltZSgpKTtcbiAgICB9KTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8pIHtcbiAgICAgICAgdGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLnBhdXNlTG9hZGluZygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAncGxheScsIHRoaXMucGxheSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFNvdXJjZSBIYW5kbGVyIG9iamVjdCwgd2hpY2ggaW5mb3JtcyB2aWRlby5qcyB3aGF0IGFkZGl0aW9uYWxcbiAgICogTUlNRSB0eXBlcyBhcmUgc3VwcG9ydGVkIGFuZCBzZXRzIHVwIHBsYXliYWNrLiBJdCBpcyByZWdpc3RlcmVkXG4gICAqIGF1dG9tYXRpY2FsbHkgdG8gdGhlIGFwcHJvcHJpYXRlIHRlY2ggYmFzZWQgb24gdGhlIGNhcGFiaWxpdGllcyBvZlxuICAgKiB0aGUgYnJvd3NlciBpdCBpcyBydW5uaW5nIGluLiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIHVzZSBvciBtb2RpZnlcbiAgICogdGhpcyBvYmplY3QgaW4gbm9ybWFsIHVzYWdlLlxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoSGxzSGFuZGxlciwgW3tcbiAgICBrZXk6ICdzZXRPcHRpb25zXycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnNfKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIGRlZmF1bHRzXG4gICAgICB0aGlzLm9wdGlvbnNfLndpdGhDcmVkZW50aWFscyA9IHRoaXMub3B0aW9uc18ud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc18uYmxhY2tsaXN0RHVyYXRpb24gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc18uYmxhY2tsaXN0RHVyYXRpb24gPSA1ICogNjA7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0YXJ0IHBsYXlsaXN0IHNlbGVjdGlvbiBhdCBhIHJlYXNvbmFibGUgYmFuZHdpZHRoIGZvclxuICAgICAgLy8gYnJvYWRiYW5kIGludGVybmV0ICgwLjUgTUIvcykgb3IgbW9iaWxlICgwLjA2MjUgTUIvcylcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zXy5iYW5kd2lkdGggIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc18uYmFuZHdpZHRoID0gSU5JVElBTF9CQU5EV0lEVEg7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBiYW5kd2lkdGggbnVtYmVyIGlzIHVuY2hhbmdlZCBmcm9tIHRoZSBpbml0aWFsIHNldHRpbmdcbiAgICAgIC8vIHRoZW4gdGhpcyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhlIGVuYWJsZUxvd0luaXRpYWxQbGF5bGlzdCBvcHRpb25cbiAgICAgIHRoaXMub3B0aW9uc18uZW5hYmxlTG93SW5pdGlhbFBsYXlsaXN0ID0gdGhpcy5vcHRpb25zXy5lbmFibGVMb3dJbml0aWFsUGxheWxpc3QgJiYgdGhpcy5vcHRpb25zXy5iYW5kd2lkdGggPT09IElOSVRJQUxfQkFORFdJRFRIO1xuXG4gICAgICAvLyBncmFiIG9wdGlvbnMgcGFzc2VkIHRvIHBsYXllci5zcmNcbiAgICAgIFsnd2l0aENyZWRlbnRpYWxzJywgJ2JhbmR3aWR0aCddLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIF90aGlzMi5zb3VyY2VfW29wdGlvbl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgX3RoaXMyLm9wdGlvbnNfW29wdGlvbl0gPSBfdGhpczIuc291cmNlX1tvcHRpb25dO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5iYW5kd2lkdGggPSB0aGlzLm9wdGlvbnNfLmJhbmR3aWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiBwbGF5ZXIuc3JjIGdldHMgY2FsbGVkLCBoYW5kbGUgYSBuZXcgc291cmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjIHRoZSBzb3VyY2Ugb2JqZWN0IHRvIGhhbmRsZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnc3JjJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3JjKF9zcmMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAvLyBkbyBub3RoaW5nIGlmIHRoZSBzcmMgaXMgZmFsc2V5XG4gICAgICBpZiAoIV9zcmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRPcHRpb25zXygpO1xuICAgICAgLy8gYWRkIG1hc3RlciBwbGF5bGlzdCBjb250cm9sbGVyIG9wdGlvbnNcbiAgICAgIHRoaXMub3B0aW9uc18udXJsID0gdGhpcy5zb3VyY2VfLnNyYztcbiAgICAgIHRoaXMub3B0aW9uc18udGVjaCA9IHRoaXMudGVjaF87XG4gICAgICB0aGlzLm9wdGlvbnNfLmV4dGVybkhscyA9IEhscztcblxuICAgICAgdGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfID0gbmV3IF9tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXIuTWFzdGVyUGxheWxpc3RDb250cm9sbGVyKHRoaXMub3B0aW9uc18pO1xuICAgICAgdGhpcy5wbGF5YmFja1dhdGNoZXJfID0gbmV3IF9wbGF5YmFja1dhdGNoZXIyWydkZWZhdWx0J10oX3ZpZGVvSnMyWydkZWZhdWx0J10ubWVyZ2VPcHRpb25zKHRoaXMub3B0aW9uc18sIHtcbiAgICAgICAgc2Vla2FibGU6IGZ1bmN0aW9uIHNlZWthYmxlKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuc2Vla2FibGUoKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICB0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8ub24oJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGxheWVyID0gX3ZpZGVvSnMyWydkZWZhdWx0J10ucGxheWVyc1tfdGhpczMudGVjaF8ub3B0aW9uc18ucGxheWVySWRdO1xuXG4gICAgICAgIHBsYXllci5lcnJvcihfdGhpczMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5lcnJvcik7XG4gICAgICB9KTtcblxuICAgICAgLy8gYHRoaXNgIGluIHNlbGVjdFBsYXlsaXN0IHNob3VsZCBiZSB0aGUgSGxzSGFuZGxlciBmb3IgYmFja3dhcmRzXG4gICAgICAvLyBjb21wYXRpYmlsaXR5IHdpdGggPCB2MlxuICAgICAgdGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLnNlbGVjdFBsYXlsaXN0ID0gdGhpcy5zZWxlY3RQbGF5bGlzdCA/IHRoaXMuc2VsZWN0UGxheWxpc3QuYmluZCh0aGlzKSA6IEhscy5TVEFOREFSRF9QTEFZTElTVF9TRUxFQ1RPUi5iaW5kKHRoaXMpO1xuXG4gICAgICB0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8uc2VsZWN0SW5pdGlhbFBsYXlsaXN0ID0gSGxzLklOSVRJQUxfUExBWUxJU1RfU0VMRUNUT1IuYmluZCh0aGlzKTtcblxuICAgICAgLy8gcmUtZXhwb3NlIHNvbWUgaW50ZXJuYWwgb2JqZWN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCA8IHYyXG4gICAgICB0aGlzLnBsYXlsaXN0cyA9IHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5tYXN0ZXJQbGF5bGlzdExvYWRlcl87XG4gICAgICB0aGlzLm1lZGlhU291cmNlID0gdGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm1lZGlhU291cmNlO1xuXG4gICAgICAvLyBQcm94eSBhc3NpZ25tZW50IG9mIHNvbWUgcHJvcGVydGllcyB0byB0aGUgbWFzdGVyIHBsYXlsaXN0XG4gICAgICAvLyBjb250cm9sbGVyLiBVc2luZyBhIGN1c3RvbSBwcm9wZXJ0eSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgIC8vIHdpdGggPCB2MlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICBzZWxlY3RQbGF5bGlzdDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5zZWxlY3RQbGF5bGlzdDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHNlbGVjdFBsYXlsaXN0KSB7XG4gICAgICAgICAgICB0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8uc2VsZWN0UGxheWxpc3QgPSBzZWxlY3RQbGF5bGlzdC5iaW5kKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGhyb3VnaHB1dDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5tYWluU2VnbWVudExvYWRlcl8udGhyb3VnaHB1dC5yYXRlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGhyb3VnaHB1dCkge1xuICAgICAgICAgICAgdGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm1haW5TZWdtZW50TG9hZGVyXy50aHJvdWdocHV0LnJhdGUgPSB0aHJvdWdocHV0O1xuICAgICAgICAgICAgLy8gQnkgc2V0dGluZyBgY291bnRgIHRvIDEgdGhlIHRocm91Z2hwdXQgdmFsdWUgYmVjb21lcyB0aGUgc3RhcnRpbmcgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciB0aGUgY3VtdWxhdGl2ZSBhdmVyYWdlXG4gICAgICAgICAgICB0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8ubWFpblNlZ21lbnRMb2FkZXJfLnRocm91Z2hwdXQuY291bnQgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYmFuZHdpZHRoOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm1haW5TZWdtZW50TG9hZGVyXy5iYW5kd2lkdGg7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChiYW5kd2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5tYWluU2VnbWVudExvYWRlcl8uYmFuZHdpZHRoID0gYmFuZHdpZHRoO1xuICAgICAgICAgICAgLy8gc2V0dGluZyB0aGUgYmFuZHdpZHRoIG1hbnVhbGx5IHJlc2V0cyB0aGUgdGhyb3VnaHB1dCBjb3VudGVyXG4gICAgICAgICAgICAvLyBgY291bnRgIGlzIHNldCB0byB6ZXJvIHRoYXQgY3VycmVudCB2YWx1ZSBvZiBgcmF0ZWAgaXNuJ3QgaW5jbHVkZWRcbiAgICAgICAgICAgIC8vIGluIHRoZSBjdW11bGF0aXZlIGF2ZXJhZ2VcbiAgICAgICAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5tYWluU2VnbWVudExvYWRlcl8udGhyb3VnaHB1dCA9IHtcbiAgICAgICAgICAgICAgcmF0ZTogMCxcbiAgICAgICAgICAgICAgY291bnQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogYHN5c3RlbUJhbmR3aWR0aGAgaXMgYSBjb21iaW5hdGlvbiBvZiB0d28gc2VyaWFsIHByb2Nlc3NlcyBiaXQtcmF0ZXMuIFRoZSBmaXJzdFxuICAgICAgICAgKiBpcyB0aGUgbmV0d29yayBiaXRyYXRlIHByb3ZpZGVkIGJ5IGBiYW5kd2lkdGhgIGFuZCB0aGUgc2Vjb25kIGlzIHRoZSBiaXRyYXRlIG9mXG4gICAgICAgICAqIHRoZSBlbnRpcmUgcHJvY2VzcyBhZnRlciB0aGF0IC0gZGVjcnlwdGlvbiwgdHJhbnNtdXhpbmcsIGFuZCBhcHBlbmRpbmcgLSBwcm92aWRlZFxuICAgICAgICAgKiBieSBgdGhyb3VnaHB1dGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNpbmNlIHRoZSB0d28gcHJvY2VzcyBhcmUgc2VyaWFsLCB0aGUgb3ZlcmFsbCBzeXN0ZW0gYmFuZHdpZHRoIGlzIGdpdmVuIGJ5OlxuICAgICAgICAgKiAgIHN5c0JhbmR3aWR0aCA9IDEgLyAoMSAvIGJhbmR3aWR0aCArIDEgLyB0aHJvdWdocHV0KVxuICAgICAgICAgKi9cbiAgICAgICAgc3lzdGVtQmFuZHdpZHRoOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICB2YXIgaW52QmFuZHdpZHRoID0gMSAvICh0aGlzLmJhbmR3aWR0aCB8fCAxKTtcbiAgICAgICAgICAgIHZhciBpbnZUaHJvdWdocHV0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBpZiAodGhpcy50aHJvdWdocHV0ID4gMCkge1xuICAgICAgICAgICAgICBpbnZUaHJvdWdocHV0ID0gMSAvIHRoaXMudGhyb3VnaHB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGludlRocm91Z2hwdXQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3lzdGVtQml0cmF0ZSA9IE1hdGguZmxvb3IoMSAvIChpbnZCYW5kd2lkdGggKyBpbnZUaHJvdWdocHV0KSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzeXN0ZW1CaXRyYXRlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICAgICAgICBfdmlkZW9KczJbJ2RlZmF1bHQnXS5sb2cuZXJyb3IoJ1RoZSBcInN5c3RlbUJhbmR3aWR0aFwiIHByb3BlcnR5IGlzIHJlYWQtb25seScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMuc3RhdHMsIHtcbiAgICAgICAgYmFuZHdpZHRoOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLmJhbmR3aWR0aCB8fCAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBtZWRpYVJlcXVlc3RzOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8ubWVkaWFSZXF1ZXN0c18oKSB8fCAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBtZWRpYVJlcXVlc3RzQWJvcnRlZDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm1lZGlhUmVxdWVzdHNBYm9ydGVkXygpIHx8IDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG1lZGlhUmVxdWVzdHNUaW1lZG91dDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm1lZGlhUmVxdWVzdHNUaW1lZG91dF8oKSB8fCAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBtZWRpYVJlcXVlc3RzRXJyb3JlZDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm1lZGlhUmVxdWVzdHNFcnJvcmVkXygpIHx8IDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG1lZGlhVHJhbnNmZXJEdXJhdGlvbjoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLm1lZGlhVHJhbnNmZXJEdXJhdGlvbl8oKSB8fCAwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBtZWRpYUJ5dGVzVHJhbnNmZXJyZWQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5tZWRpYUJ5dGVzVHJhbnNmZXJyZWRfKCkgfHwgMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgbWVkaWFTZWNvbmRzTG9hZGVkOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8ubWVkaWFTZWNvbmRzTG9hZGVkXygpIHx8IDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnRlY2hfLm9uZSgnY2FucGxheScsIHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5zZXR1cEZpcnN0UGxheS5iaW5kKHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXykpO1xuXG4gICAgICB0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8ub24oJ3NlbGVjdGVkaW5pdGlhbG1lZGlhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBZGQgdGhlIG1hbnVhbCByZW5kaXRpb24gbWl4LWluIHRvIEhsc0hhbmRsZXJcbiAgICAgICAgKDAsIF9yZW5kaXRpb25NaXhpbjJbJ2RlZmF1bHQnXSkoX3RoaXMzKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGUgYmFuZHdpZHRoIG9mIHRoZSBwcmltYXJ5IHNlZ21lbnQgbG9hZGVyIGlzIG91ciBiZXN0XG4gICAgICAvLyBlc3RpbWF0ZSBvZiBvdmVyYWxsIGJhbmR3aWR0aFxuICAgICAgdGhpcy5vbih0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8sICdwcm9ncmVzcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50ZWNoXy50cmlnZ2VyKCdwcm9ncmVzcycpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEluIHRoZSBsaXZlIGNhc2UsIHdlIG5lZWQgdG8gaWdub3JlIHRoZSB2ZXJ5IGZpcnN0IGBzZWVraW5nYCBldmVudCBzaW5jZVxuICAgICAgLy8gdGhhdCB3aWxsIGJlIHRoZSByZXN1bHQgb2YgdGhlIHNlZWstdG8tbGl2ZSBiZWhhdmlvclxuICAgICAgdGhpcy5vbih0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8sICdmaXJzdHBsYXknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWdub3JlTmV4dFNlZWtpbmdFdmVudF8gPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMudGVjaF8ucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLnNldHVwUXVhbGl0eUxldmVsc18oKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBkbyBub3RoaW5nIGlmIHRoZSB0ZWNoIGhhcyBiZWVuIGRpc3Bvc2VkIGFscmVhZHlcbiAgICAgIC8vIHRoaXMgY2FuIG9jY3VyIGlmIHNvbWVvbmUgc2V0cyB0aGUgc3JjIGluIHBsYXllci5yZWFkeSgpLCBmb3IgaW5zdGFuY2VcbiAgICAgIGlmICghdGhpcy50ZWNoXy5lbCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZWNoXy5zcmMoX3ZpZGVvSnMyWydkZWZhdWx0J10uVVJMLmNyZWF0ZU9iamVjdFVSTCh0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8ubWVkaWFTb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgcXVhbGl0eSBsZXZlbHMgYW5kIHNldHMgbGlzdGVuZXJzIHRvIHVwZGF0ZSB0aGVtLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXR1cFF1YWxpdHlMZXZlbHNfXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldHVwUXVhbGl0eUxldmVsc18nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cFF1YWxpdHlMZXZlbHNfKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBwbGF5ZXIgPSBfdmlkZW9KczJbJ2RlZmF1bHQnXS5wbGF5ZXJzW3RoaXMudGVjaF8ub3B0aW9uc18ucGxheWVySWRdO1xuXG4gICAgICBpZiAocGxheWVyICYmIHBsYXllci5xdWFsaXR5TGV2ZWxzKSB7XG4gICAgICAgIHRoaXMucXVhbGl0eUxldmVsc18gPSBwbGF5ZXIucXVhbGl0eUxldmVscygpO1xuXG4gICAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5vbignc2VsZWN0ZWRpbml0aWFsbWVkaWEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaGFuZGxlSGxzTG9hZGVkTWV0YWRhdGEoX3RoaXM0LnF1YWxpdHlMZXZlbHNfLCBfdGhpczQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnBsYXlsaXN0cy5vbignbWVkaWFjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaGFuZGxlSGxzTWVkaWFDaGFuZ2UoX3RoaXM0LnF1YWxpdHlMZXZlbHNfLCBfdGhpczQucGxheWxpc3RzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmVnaW4gcGxheWluZyB0aGUgdmlkZW8uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5wbGF5KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYSB3cmFwcGVyIGFyb3VuZCB0aGUgZnVuY3Rpb24gaW4gTWFzdGVyUGxheWxpc3RDb250cm9sbGVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRDdXJyZW50VGltZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1cnJlbnRUaW1lKGN1cnJlbnRUaW1lKSB7XG4gICAgICB0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8uc2V0Q3VycmVudFRpbWUoY3VycmVudFRpbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGEgd3JhcHBlciBhcm91bmQgdGhlIGZ1bmN0aW9uIGluIE1hc3RlclBsYXlsaXN0Q29udHJvbGxlclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZHVyYXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hc3RlclBsYXlsaXN0Q29udHJvbGxlcl8uZHVyYXRpb24oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhIHdyYXBwZXIgYXJvdW5kIHRoZSBmdW5jdGlvbiBpbiBNYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NlZWthYmxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Vla2FibGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfLnNlZWthYmxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBBYm9ydCBhbGwgb3V0c3RhbmRpbmcgd29yayBhbmQgY2xlYW51cC5cbiAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZGlzcG9zZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICBpZiAodGhpcy5wbGF5YmFja1dhdGNoZXJfKSB7XG4gICAgICAgIHRoaXMucGxheWJhY2tXYXRjaGVyXy5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tYXN0ZXJQbGF5bGlzdENvbnRyb2xsZXJfKSB7XG4gICAgICAgIHRoaXMubWFzdGVyUGxheWxpc3RDb250cm9sbGVyXy5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5xdWFsaXR5TGV2ZWxzXykge1xuICAgICAgICB0aGlzLnF1YWxpdHlMZXZlbHNfLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEhsc0hhbmRsZXIucHJvdG90eXBlKSwgJ2Rpc3Bvc2UnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIbHNIYW5kbGVyO1xufSkoQ29tcG9uZW50KTtcblxudmFyIEhsc1NvdXJjZUhhbmRsZXIgPSBmdW5jdGlvbiBIbHNTb3VyY2VIYW5kbGVyKG1vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBjYW5IYW5kbGVTb3VyY2U6IGZ1bmN0aW9uIGNhbkhhbmRsZVNvdXJjZShzcmNPYmopIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgIHZhciBsb2NhbE9wdGlvbnMgPSBfdmlkZW9KczJbJ2RlZmF1bHQnXS5tZXJnZU9wdGlvbnMoX3ZpZGVvSnMyWydkZWZhdWx0J10ub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIHRoaXMgZm9yY2VzIHZpZGVvLmpzIHRvIHNraXAgdGhpcyB0ZWNoL21vZGUgaWYgaXRzIG5vdCB0aGUgb25lIHdlIGhhdmUgYmVlblxuICAgICAgLy8gb3ZlcnJpZGVuIHRvIHVzZSwgYnkgcmV0dXJpbmcgdGhhdCB3ZSBjYW5ub3QgaGFuZGxlIHRoZSBzb3VyY2UuXG4gICAgICBpZiAobG9jYWxPcHRpb25zLmhscyAmJiBsb2NhbE9wdGlvbnMuaGxzLm1vZGUgJiYgbG9jYWxPcHRpb25zLmhscy5tb2RlICE9PSBtb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBIbHNTb3VyY2VIYW5kbGVyLmNhblBsYXlUeXBlKHNyY09iai50eXBlLCBsb2NhbE9wdGlvbnMpO1xuICAgIH0sXG4gICAgaGFuZGxlU291cmNlOiBmdW5jdGlvbiBoYW5kbGVTb3VyY2Uoc291cmNlLCB0ZWNoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdO1xuXG4gICAgICB2YXIgbG9jYWxPcHRpb25zID0gX3ZpZGVvSnMyWydkZWZhdWx0J10ubWVyZ2VPcHRpb25zKF92aWRlb0pzMlsnZGVmYXVsdCddLm9wdGlvbnMsIG9wdGlvbnMsIHsgaGxzOiB7IG1vZGU6IG1vZGUgfSB9KTtcblxuICAgICAgaWYgKG1vZGUgPT09ICdmbGFzaCcpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byB0cmlnZ2VyIHRoaXMgYXN5bmNocm9ub3VzbHkgdG8gZ2l2ZSBvdGhlcnMgdGhlIGNoYW5jZVxuICAgICAgICAvLyB0byBiaW5kIHRvIHRoZSBldmVudCB3aGVuIGEgc291cmNlIGlzIHNldCBhdCBwbGF5ZXIgY3JlYXRpb25cbiAgICAgICAgdGVjaC5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0ZWNoLnRyaWdnZXIoJ2xvYWRzdGFydCcpO1xuICAgICAgICB9LCAxKTtcbiAgICAgIH1cblxuICAgICAgdGVjaC5obHMgPSBuZXcgSGxzSGFuZGxlcihzb3VyY2UsIHRlY2gsIGxvY2FsT3B0aW9ucyk7XG4gICAgICB0ZWNoLmhscy54aHIgPSAoMCwgX3hocjJbJ2RlZmF1bHQnXSkoKTtcblxuICAgICAgdGVjaC5obHMuc3JjKHNvdXJjZS5zcmMpO1xuICAgICAgcmV0dXJuIHRlY2guaGxzO1xuICAgIH0sXG4gICAgY2FuUGxheVR5cGU6IGZ1bmN0aW9uIGNhblBsYXlUeXBlKHR5cGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgIHZhciBsb2NhbE9wdGlvbnMgPSBfdmlkZW9KczJbJ2RlZmF1bHQnXS5tZXJnZU9wdGlvbnMoX3ZpZGVvSnMyWydkZWZhdWx0J10ub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChIbHNTb3VyY2VIYW5kbGVyLmNhblBsYXlUeXBlKHR5cGUsIGxvY2FsT3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuICdtYXliZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9O1xufTtcblxuSGxzU291cmNlSGFuZGxlci5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBvcHRpb25zKSB7XG4gIC8vIE5vIHN1cHBvcnQgZm9yIElFIDEwIG9yIGJlbG93XG4gIGlmIChfdmlkZW9KczJbJ2RlZmF1bHQnXS5icm93c2VyLklFX1ZFUlNJT04gJiYgX3ZpZGVvSnMyWydkZWZhdWx0J10uYnJvd3Nlci5JRV9WRVJTSU9OIDw9IDEwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG1wZWd1cmxSRSA9IC9eKGF1ZGlvfHZpZGVvfGFwcGxpY2F0aW9uKVxcLyh4LXx2bmRcXC5hcHBsZVxcLik/bXBlZ3VybC9pO1xuXG4gIC8vIGZhdm9yIG5hdGl2ZSBITFMgc3VwcG9ydCBpZiBpdCdzIGF2YWlsYWJsZVxuICBpZiAoIW9wdGlvbnMuaGxzLm92ZXJyaWRlTmF0aXZlICYmIEhscy5zdXBwb3J0c05hdGl2ZUhscykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbXBlZ3VybFJFLnRlc3QodHlwZSk7XG59O1xuXG5pZiAodHlwZW9mIF92aWRlb0pzMlsnZGVmYXVsdCddLk1lZGlhU291cmNlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgX3ZpZGVvSnMyWydkZWZhdWx0J10uVVJMID09PSAndW5kZWZpbmVkJykge1xuICBfdmlkZW9KczJbJ2RlZmF1bHQnXS5NZWRpYVNvdXJjZSA9IF92aWRlb2pzQ29udHJpYk1lZGlhU291cmNlcy5NZWRpYVNvdXJjZTtcbiAgX3ZpZGVvSnMyWydkZWZhdWx0J10uVVJMID0gX3ZpZGVvanNDb250cmliTWVkaWFTb3VyY2VzLlVSTDtcbn1cblxudmFyIGZsYXNoVGVjaCA9IF92aWRlb0pzMlsnZGVmYXVsdCddLmdldFRlY2goJ0ZsYXNoJyk7XG5cbi8vIHJlZ2lzdGVyIHNvdXJjZSBoYW5kbGVycyB3aXRoIHRoZSBhcHByb3ByaWF0ZSB0ZWNoc1xuaWYgKF92aWRlb2pzQ29udHJpYk1lZGlhU291cmNlcy5NZWRpYVNvdXJjZS5zdXBwb3J0c05hdGl2ZU1lZGlhU291cmNlcygpKSB7XG4gIF92aWRlb0pzMlsnZGVmYXVsdCddLmdldFRlY2goJ0h0bWw1JykucmVnaXN0ZXJTb3VyY2VIYW5kbGVyKEhsc1NvdXJjZUhhbmRsZXIoJ2h0bWw1JyksIDApO1xufVxuaWYgKF9nbG9iYWxXaW5kb3cyWydkZWZhdWx0J10uVWludDhBcnJheSAmJiBmbGFzaFRlY2gpIHtcbiAgZmxhc2hUZWNoLnJlZ2lzdGVyU291cmNlSGFuZGxlcihIbHNTb3VyY2VIYW5kbGVyKCdmbGFzaCcpKTtcbn1cblxuX3ZpZGVvSnMyWydkZWZhdWx0J10uSGxzSGFuZGxlciA9IEhsc0hhbmRsZXI7XG5fdmlkZW9KczJbJ2RlZmF1bHQnXS5IbHNTb3VyY2VIYW5kbGVyID0gSGxzU291cmNlSGFuZGxlcjtcbl92aWRlb0pzMlsnZGVmYXVsdCddLkhscyA9IEhscztcbmlmICghX3ZpZGVvSnMyWydkZWZhdWx0J10udXNlKSB7XG4gIF92aWRlb0pzMlsnZGVmYXVsdCddLnJlZ2lzdGVyQ29tcG9uZW50KCdIbHMnLCBIbHMpO1xufVxuX3ZpZGVvSnMyWydkZWZhdWx0J10ubTN1OCA9IF9tM3U4UGFyc2VyMlsnZGVmYXVsdCddO1xuX3ZpZGVvSnMyWydkZWZhdWx0J10ub3B0aW9ucy5obHMgPSBfdmlkZW9KczJbJ2RlZmF1bHQnXS5vcHRpb25zLmhscyB8fCB7fTtcblxuaWYgKF92aWRlb0pzMlsnZGVmYXVsdCddLnJlZ2lzdGVyUGx1Z2luKSB7XG4gIF92aWRlb0pzMlsnZGVmYXVsdCddLnJlZ2lzdGVyUGx1Z2luKCdyZWxvYWRTb3VyY2VPbkVycm9yJywgX3JlbG9hZFNvdXJjZU9uRXJyb3IyWydkZWZhdWx0J10pO1xufSBlbHNlIHtcbiAgX3ZpZGVvSnMyWydkZWZhdWx0J10ucGx1Z2luKCdyZWxvYWRTb3VyY2VPbkVycm9yJywgX3JlbG9hZFNvdXJjZU9uRXJyb3IyWydkZWZhdWx0J10pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSGxzOiBIbHMsXG4gIEhsc0hhbmRsZXI6IEhsc0hhbmRsZXIsXG4gIEhsc1NvdXJjZUhhbmRsZXI6IEhsc1NvdXJjZUhhbmRsZXJcbn07XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi9iaW4tdXRpbHNcIjoyLFwiLi9jb25maWdcIjozLFwiLi9tYXN0ZXItcGxheWxpc3QtY29udHJvbGxlclwiOjUsXCIuL3BsYXliYWNrLXdhdGNoZXJcIjo4LFwiLi9wbGF5bGlzdFwiOjExLFwiLi9wbGF5bGlzdC1sb2FkZXJcIjo5LFwiLi9wbGF5bGlzdC1zZWxlY3RvcnMuanNcIjoxMCxcIi4vcmVsb2FkLXNvdXJjZS1vbi1lcnJvclwiOjEzLFwiLi9yZW5kaXRpb24tbWl4aW5cIjoxNCxcIi4veGhyXCI6MjEsXCJhZXMtZGVjcnlwdGVyXCI6MjUsXCJnbG9iYWwvZG9jdW1lbnRcIjozMSxcImdsb2JhbC93aW5kb3dcIjozMixcIm0zdTgtcGFyc2VyXCI6MzMsXCJ2aWRlb2pzLWNvbnRyaWItbWVkaWEtc291cmNlc1wiOjc0fV19LHt9LFs3N10pKDc3KVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdmlkZW9qcy1jb250cmliLWhscy9kaXN0L3ZpZGVvanMtY29udHJpYi1obHMuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///32\n")}])});